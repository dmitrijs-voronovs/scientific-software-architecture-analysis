quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Testability,"onst char* workdir); TSlave*TProof::CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TList*TProof::GetEnabledPackages() const; static Bool_tTProof::GetFileInCmd(const char* cmd, TString& fn); static Int_tTProof::GetInputData(TList* input, const char* cachedir, TString& emsg); TStringGetJobAd(); TList*TProof::GetListOfActiveSlaves() const; TVirtualProofPlayer*TProof::GetPlayer() const; TPluginHandler*TProof::GetProgressDialog() const; Int_tTProof::GetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTProof::HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tTProof::HandleOutputOptions(TString& opt, TString& target, Int_t action); Int_tTProof::Init(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidTProof::InitMembers(); virtual TVirtualProofPlayer*TProof::MakePlayer(const char* player = 0, TSocket* s = 0); voidTObject::MakeZombie(); virtual Int_tTProof::PollForNewWorkers(); voidTProof::PrepareInputDataFile(TString& dataFile); Int_tTProof::RemoveWorkers(TList* wrks); static Int_tTProof::SaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidTProof::SaveWorkerInfo(); Int_tTProof::SendFile(const char* file, Int_t opt = (kBinary|kForward|kCp|kCpBin), const char* rfile = 0, TSlave* sl = 0); static Int_tTProof::SendInputData(TQueryResult* qr, TProof* p, TString& emsg); virtual voidTProof::SendInputDataFile(); voidTProof::SetDSet(TDSet* dset); voidTProof::SetFeedback(TString& opt, TString& optfb, Int_t action); voidTProof::SetPlayer(TVirtualProofPlayer* player); voidTProof::SetupWorkersEnv(TList* wrks, Bool_t increasingpool = kFALSE); static void*TProof::SlaveStartupThread(void* arg); virtual Bool_tStartSlaves(Bool_t); static ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofCondor.html:22313,log,loglevel,22313,root/html534/TProofCondor.html,https://root.cern,https://root.cern/root/html534/TProofCondor.html,1,['log'],['loglevel']
Testability,"onst double * ez , const double * eval ) :; 152 FitData( n, dataX, dataY, dataZ ),; 153 fDataErrorPtr( nullptr ), fDataErrorHighPtr( nullptr ), fDataErrorLowPtr( nullptr ),; 154 fpTmpCoordErrorVector( nullptr ), fpTmpBinEdgeVector( nullptr ); 155 {; 156 assert( val );; 157 fDataPtr = val;; 158 ; 159 if ( nullptr != eval ); 160 {; 161 fDataErrorPtr = eval;; 162 ; 163 fErrorType = kValueError;; 164 ; 165 if ( nullptr != ex || nullptr != ey || nullptr != ez ); 166 {; 167 fCoordErrorsPtr.resize( 3 );; 168 ; 169 fCoordErrorsPtr[0] = ex;; 170 fCoordErrorsPtr[1] = ey;; 171 fCoordErrorsPtr[2] = ez;; 172 ; 173 fErrorType = kCoordError;; 174 }; 175 }; 176 else; 177 {; 178 fErrorType = kNoError;; 179 }; 180 ; 181 fpTmpCoordErrorVector = new double [ fDim ];; 182 ComputeSums();; 183 }; 184 ; 185 /**; 186 destructor; 187 */; 188 BinData::~BinData(); 189 {; 190 assert( fMaxPoints == 0 || fWrapped == fData.empty() );; 191 ; 192 assert( kValueError == fErrorType || kCoordError == fErrorType ||; 193 kAsymError == fErrorType || kNoError == fErrorType );; 194 assert( fMaxPoints == 0 || fDataError.empty() || &fDataError.front() == fDataErrorPtr );; 195 assert( fMaxPoints == 0 || fDataErrorHigh.empty() || &fDataErrorHigh.front() == fDataErrorHighPtr );; 196 assert( fMaxPoints == 0 || fDataErrorLow.empty() || &fDataErrorLow.front() == fDataErrorLowPtr );; 197 assert( fMaxPoints == 0 || fDataErrorLow.empty() == fDataErrorHigh.empty() );; 198 assert( fMaxPoints == 0 || fData.empty() || &fData.front() == fDataPtr );; 199 ; 200 for ( unsigned int i=0; i < fDim; i++ ); 201 {; 202 assert( fCoordErrors.empty() || &fCoordErrors[i].front() == fCoordErrorsPtr[i] );; 203 }; 204 ; 205 if ( fpTmpBinEdgeVector ); 206 {; 207 delete[] fpTmpBinEdgeVector;; 208 fpTmpBinEdgeVector= nullptr;; 209 }; 210 ; 211 if ( fpTmpCoordErrorVector ); 212 {; 213 delete[] fpTmpCoordErrorVector;; 214 fpTmpCoordErrorVector = nullptr;; 215 }; 216 }; 217 ; 218 /**; 219 copy constructors; 220 */; 221 BinData::BinData(const Bi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:5163,assert,assert,5163,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,2,['assert'],['assert']
Testability,"onst vector<Float_t>& vs, const vector<UInt_t>& fTS); voidDrawMesh(const vector<Double_t>& vs, const vector<UInt_t>& fTS); voidDrawMesh(const vector<Float_t>& vs, const vector<Float_t>& ns, const vector<UInt_t>& ts); voidDrawMesh(const vector<Double_t>& vs, const vector<Double_t>& ns, const vector<UInt_t>& ts); voidDrawMesh(const vector<Float_t>& vs, const vector<UInt_t>& ts, const TGLBoxCut& box); voidDrawMesh(const vector<Double_t>& vs, const vector<UInt_t>& ts, const TGLBoxCut& box); voidDrawMesh(const vector<Float_t>& vs, const vector<Float_t>& ns, const vector<UInt_t>& ts, const TGLBoxCut& box); voidDrawMesh(const vector<Double_t>& vs, const vector<Double_t>& ns, const vector<UInt_t>& ts, const TGLBoxCut& box); voidDrawPalette(const TGLPlotCamera* camera, const TGLLevelPalette& palette); voidDrawPalette(const TGLPlotCamera* camera, const TGLLevelPalette& palette, const vector<Double_t>& levels); voidDrawPaletteAxis(const TGLPlotCamera* camera, const Rgl::Range_t& minMax, Bool_t logZ); voidDrawQuadFilled(const TGLVertex3& v0, const TGLVertex3& v1, const TGLVertex3& v2, const TGLVertex3& v3, const TGLVector3& normal); voidDrawQuadFilled(const Double_t* v0, const Double_t* v1, const Double_t* v2, const Double_t* v3, const Double_t* normal); voidDrawQuadOutline(const TGLVertex3& v1, const TGLVertex3& v2, const TGLVertex3& v3, const TGLVertex3& v4); voidDrawQuadStripWithRadialGradientFill(unsigned int nPoints, const Double_t* inner, const Double_t* innerRGBA, const Double_t* outer, const Double_t* outerRGBA); voidDrawSmoothFace(const TGLVertex3& v1, const TGLVertex3& v2, const TGLVertex3& v3, const TGLVector3& norm1, const TGLVector3& norm2, const TGLVector3& norm3); voidDrawSphere(TGLQuadric* quadric, Double_t xMin, Double_t xMax, Double_t yMin, Double_t yMax, Double_t zMin, Double_t zMax); voidDrawTransparentBox(Double_t xMin, Double_t xMax, Double_t yMin, Double_t yMax, Double_t zMin, Double_t zMax, Int_t fp); voidDrawTrapezoid(const Double_t[][3] ver); voidDrawTr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/Rgl.html:3155,log,logZ,3155,root/html602/Rgl.html,https://root.cern,https://root.cern/root/html602/Rgl.html,2,['log'],['logZ']
Testability,"onst vector<Float_t>& vs, const vector<UInt_t>& fTS); voidDrawMesh(const vector<Double_t>& vs, const vector<UInt_t>& fTS); voidDrawMesh(const vector<Float_t>& vs, const vector<Float_t>& ns, const vector<UInt_t>& ts); voidDrawMesh(const vector<Double_t>& vs, const vector<Double_t>& ns, const vector<UInt_t>& ts); voidDrawMesh(const vector<Float_t>& vs, const vector<UInt_t>& ts, const TGLBoxCut& box); voidDrawMesh(const vector<Double_t>& vs, const vector<UInt_t>& ts, const TGLBoxCut& box); voidDrawMesh(const vector<Float_t>& vs, const vector<Float_t>& ns, const vector<UInt_t>& ts, const TGLBoxCut& box); voidDrawMesh(const vector<Double_t>& vs, const vector<Double_t>& ns, const vector<UInt_t>& ts, const TGLBoxCut& box); voidDrawPalette(const TGLPlotCamera* camera, const TGLLevelPalette& palette); voidDrawPalette(const TGLPlotCamera* camera, const TGLLevelPalette& palette, const vector<Double_t>& levels); voidDrawPaletteAxis(const TGLPlotCamera* camera, const Rgl::Range_t& minMax, Bool_t logZ); voidDrawQuadFilled(const TGLVertex3& v0, const TGLVertex3& v1, const TGLVertex3& v2, const TGLVertex3& v3, const TGLVector3& normal); voidDrawQuadFilled(const Double_t* v0, const Double_t* v1, const Double_t* v2, const Double_t* v3, const Double_t* normal); voidDrawQuadOutline(const TGLVertex3& v1, const TGLVertex3& v2, const TGLVertex3& v3, const TGLVertex3& v4); voidDrawQuadStripWithRadialGradientFill(unsigned int, const Double_t* inner, const Double_t* innerRGBA, const Double_t* outer, const Double_t* outerRGBA); voidDrawSmoothFace(const TGLVertex3& v1, const TGLVertex3& v2, const TGLVertex3& v3, const TGLVector3& norm1, const TGLVector3& norm2, const TGLVector3& norm3); voidDrawSphere(TGLQuadric* quadric, Double_t xMin, Double_t xMax, Double_t yMin, Double_t yMax, Double_t zMin, Double_t zMax); voidDrawTransparentBox(Double_t xMin, Double_t xMax, Double_t yMin, Double_t yMax, Double_t zMin, Double_t zMax, Int_t fp); voidGetColor(Float_t v, Float_t vmin, Float_t vmax, Int_t type",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/Rgl.html:2742,log,logZ,2742,root/html534/Rgl.html,https://root.cern,https://root.cern/root/html534/Rgl.html,1,['log'],['logZ']
Testability,"onst vector<Float_t>& vs, const vector<UInt_t>& fTS); voidDrawMesh(const vector<Double_t>& vs, const vector<UInt_t>& fTS); voidDrawMesh(const vector<Float_t>& vs, const vector<Float_t>& ns, const vector<UInt_t>& ts); voidDrawMesh(const vector<Double_t>& vs, const vector<Double_t>& ns, const vector<UInt_t>& ts); voidDrawMesh(const vector<Float_t>& vs, const vector<UInt_t>& ts, const TGLBoxCut& box); voidDrawMesh(const vector<Double_t>& vs, const vector<UInt_t>& ts, const TGLBoxCut& box); voidDrawMesh(const vector<Float_t>& vs, const vector<Float_t>& ns, const vector<UInt_t>& ts, const TGLBoxCut& box); voidDrawMesh(const vector<Double_t>& vs, const vector<Double_t>& ns, const vector<UInt_t>& ts, const TGLBoxCut& box); voidDrawPalette(const TGLPlotCamera* camera, const TGLLevelPalette& palette); voidDrawPalette(const TGLPlotCamera* camera, const TGLLevelPalette& palette, const vector<Double_t>& levels); voidDrawPaletteAxis(const TGLPlotCamera* camera, const Rgl::Range_t& minMax, Bool_t logZ); voidDrawQuadFilled(const TGLVertex3& v0, const TGLVertex3& v1, const TGLVertex3& v2, const TGLVertex3& v3, const TGLVector3& normal); voidDrawQuadFilled(const Double_t* v0, const Double_t* v1, const Double_t* v2, const Double_t* v3, const Double_t* normal); voidDrawQuadOutline(const TGLVertex3& v1, const TGLVertex3& v2, const TGLVertex3& v3, const TGLVertex3& v4); voidDrawSmoothFace(const TGLVertex3& v1, const TGLVertex3& v2, const TGLVertex3& v3, const TGLVector3& norm1, const TGLVector3& norm2, const TGLVector3& norm3); voidDrawSphere(TGLQuadric* quadric, Double_t xMin, Double_t xMax, Double_t yMin, Double_t yMax, Double_t zMin, Double_t zMax); voidDrawTransparentBox(Double_t xMin, Double_t xMax, Double_t yMin, Double_t yMax, Double_t zMin, Double_t zMax, Int_t fp); voidGetColor(Float_t v, Float_t vmin, Float_t vmax, Int_t type, Float_t* rgba); voidObjectIDToColor(Int_t objectID, Bool_t highColor); voidSetZLevels(TAxis* zAxis, Double_t zMin, Double_t zMax, Double_t zScale, vector",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/Rgl.html:2615,log,logZ,2615,root/html530/Rgl.html,https://root.cern,https://root.cern/root/html530/Rgl.html,2,['log'],['logZ']
Testability,"onst. compute the net with the given input and the given weights ; compute the neural net; Parameters. inputthe input data ; weightsthe weight data . Definition at line 1037 of file NeuralNet.icc. ◆ computeError(). template<typename ItWeight > . std::tuple< double, double > TMVA::DNN::Net::computeError ; (; const Settings & ; settings, . std::vector< LayerData > & ; lastLayerData, . Batch & ; batch, . ItWeight ; itWeightBegin, . ItWeight ; itWeightEnd . ); const. Definition at line 1321 of file NeuralNet.icc. ◆ dE(). void TMVA::DNN::Net::dE ; (; ). ◆ dropOutWeightFactor(). template<typename WeightsType , typename DropProbabilities > . void TMVA::DNN::Net::dropOutWeightFactor ; (; WeightsType & ; weights, . const DropProbabilities & ; drops, . bool ; inverse = false . ). set the drop out configuration ; compute the drop-out-weight factor; when using drop-out a fraction of the nodes is turned off at each cycle of the computation once all nodes are turned on again (for instances when the test samples are evaluated), the weights have to be adjusted to account for the different number of active nodes this function computes the factor and applies it to the weights ; Definition at line 652 of file NeuralNet.icc. ◆ E(). double TMVA::DNN::Net::E ; (; ). ◆ errorFunction(). template<typename Container , typename ItWeight > . double TMVA::DNN::Net::errorFunction ; (; LayerData & ; layerData, . Container ; truth, . ItWeight ; itWeight, . ItWeight ; itWeightEnd, . double ; patternWeight, . double ; factorWeightDecay, . EnumRegularization ; eRegularization . ); const. computes the error of the DNN ; compute the error function; Definition at line 1579 of file NeuralNet.icc. ◆ fetchOutput() [1/2]. template<typename OutputContainer > . void TMVA::DNN::Net::fetchOutput ; (; const LayerData & ; lastLayerData, . OutputContainer & ; outputContainer . ); const. Definition at line 1291 of file NeuralNet.icc. ◆ fetchOutput() [2/2]. template<typename OutputContainer > . void TMVA::DNN::Net::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Net.html:9512,test,test,9512,doc/master/classTMVA_1_1DNN_1_1Net.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Net.html,1,['test'],['test']
Testability,"onst; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t , Bool_t = kTRUE); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsOptTestStatistic.html:38701,log,logic,38701,root/html532/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html532/RooAbsOptTestStatistic.html,4,['log'],['logic']
Testability,"onst; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGDMLWrite&operator=(const TGDMLWrite&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetG4Compatibility(Bool_t G4Compatible); voidSetNamingSpeed(TGDMLWrite::ENamingType naming); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); static voidStartGDMLWriting(TGeoManager* geomanager, const char* filename, TString option); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidWriteGDMLfile(TGeoManager* geomanager, const char* filename = ""test.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGDMLWrite.html:8394,test,test,8394,root/html534/TGDMLWrite.html,https://root.cern,https://root.cern/root/html534/TGDMLWrite.html,1,['test'],['test']
Testability,"onst; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidLoadDataSet(RooDataSet& data); voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooKeysPdf.html:20518,log,logEvalError,20518,root/html532/RooKeysPdf.html,https://root.cern,https://root.cern/root/html532/RooKeysPdf.html,1,['log'],['logEvalError']
Testability,"onst; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual TFormula*TF1::GetFormula(); virtual const TFormula*TF1::GetFormula() const; virtual TH1*TF1::GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*TF1::GetLinearPart(Int_t i) const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual Double_tTF1::GetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.0E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMaximumStored() const; virtual Double_tTF1::GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.0E-10, Int_t maxiter = 100, Bool_t logx = false) const; TMethodCall*TF1::GetMethodCall() const; virtual Double_tTF1::GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.0E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMinimumStored() const; virtual Double_tTF1::GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.0E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual const char*TNamed::GetName() const; virtual Int_tTF1::GetNDF() const; virtual Int_tTF1::GetNdim() const; virtual Int_tTF1::GetNpar() const; virtual Int_tTF1::GetNpx() const; virtual Int_tTF1::GetNumber() const; virtual Int_tTF1::GetNumberFitPoints() const; virtual Int_tTF1::GetNumberFreeParameters() const; virtual char*TF1::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Double_tTF1::GetParameter(Int_t ipar) const; virtual Double_tTF1::GetParameter(const TString& name) const; virtual Double_t*TF1::GetParameters() const; virtual voidTF1::GetParameters(Double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TF12.html:4358,log,logx,4358,root/html604/TF12.html,https://root.cern,https://root.cern/root/html604/TF12.html,1,['log'],['logx']
Testability,"onst; virtual Double_tGetMinimumStored() const; virtual Double_tGetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.0E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual const char*TNamed::GetName() const; virtual Int_tGetNDF() const; virtual Int_tTFormula::GetNdim() const; virtual Int_tTFormula::GetNpar() const; virtual Int_tGetNpx() const; virtual Int_tTFormula::GetNumber() const; virtual Int_tGetNumberFitPoints() const; virtual Int_tGetNumberFreeParameters() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tTFormula::GetParameter(Int_t ipar) const; Double_tTFormula::GetParameter(const char* name) const; virtual Double_t*TFormula::GetParameters() const; virtual voidTFormula::GetParameters(Double_t* params); TObject*GetParent() const; virtual Double_tGetParError(Int_t ipar) const; virtual Double_t*GetParErrors() const; virtual voidGetParLimits(Int_t ipar, Double_t& parmin, Double_t& parmax) const; virtual const char*TFormula::GetParName(Int_t ipar) const; virtual Int_tTFormula::GetParNumber(const char* name) const; virtual Double_tGetProb() const; virtual Int_tGetQuantiles(Int_t nprobSum, Double_t* q, const Double_t* probSum); virtual Double_tGetRandom(); virtual Double_tGetRandom(Double_t xmin, Double_t xmax); virtual voidGetRange(Double_t& xmin, Double_t& xmax) const; virtual voidGetRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; virtual voidGetRange(Double_t& xmin, Double_t& ymin, Double_t& zmin, Double_t& xmax, Double_t& ymax, Double_t& zmax) const; virtual Double_tGetSave(const Double_t* x); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Double_tGetX(Double_t y, Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.0E-10, Int_t maxiter = 100, Bool_t logx = false) const; TAxis*GetXaxis() const; virtual Double_tGetXmax() const; virtual Double_tGetXmi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF1.html:9768,log,logx,9768,root/html602/TF1.html,https://root.cern,https://root.cern/root/html602/TF1.html,1,['log'],['logx']
Testability,"onst; virtual Int_tGetContour(Double_t* levels = 0); virtual Double_tGetContourLevel(Int_t level) const; static TF1*TF1::GetCurrent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TStringTFormula::GetExpFormula(Option_t* option = """") const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TH1*TF1::GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*TFormula::GetLinearPart(Int_t i); virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual Double_tTF1::GetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMaximumStored() const; virtual Double_tTF1::GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; TMethodCall*TF1::GetMethodCall() const; virtual Double_tTF1::GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMinimumStored() const; virtual Double_tTF1::GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual voidGetMinimumXY(Double_t& x, Double_t& y); virtual const char*TNamed::GetName() const; virtual Int_tTF1::GetNDF() const; virtual Int_tTFormula::GetNdim() const; virtual Int_tTFormula::GetNpar() const; virtual Int_tTF1::GetNpx() const; Int_tGetNpy() const; virtual Int_tTFormula::GetNumber() const; virtual Int_tTF1::GetNumberFitPoints() const; virtual Int_tTF1::GetNumberFreeParameters() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TF2.html:5622,log,logx,5622,root/html534/TF2.html,https://root.cern,https://root.cern/root/html534/TF2.html,1,['log'],['logx']
Testability,"onst; virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/PiecewiseInterpolation.html:17896,test,testArg,17896,root/html532/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html532/PiecewiseInterpolation.html,1,['test'],['testArg']
Testability,"onst; voidInvertBit(UInt_t f); virtual TClass*IsA() const; boolQWidget::isActiveWindow() const; boolQWidget::isAncestorOf(const QWidget* child) const; boolIsDoubleBuffered() const; boolQWidget::isEnabled() const; boolQWidget::isEnabledTo(QWidget*) const; boolQWidget::isEnabledToTLW() const; boolQWidget::isFullScreen() const; boolQWidget::isHidden() const; boolQWidget::isLeftToRight() const; boolQWidget::isMaximized() const; boolQWidget::isMinimized() const; boolQWidget::isModal() const; boolQWidget::isRightToLeft() const; Bool_tIsSignalEventEnabled(UInt_t f) const; boolQWidget::isTopLevel() const; boolQWidget::isVisible() const; boolQWidget::isVisibleTo(QWidget*) const; boolQObject::isWidgetType() const; boolQWidget::isWindow() const; boolQWidget::isWindowModified() const; static QWidget*QWidget::keyboardGrabber(); voidQObject::killTimer(int id); QLayout*QWidget::layout() const; Qt::LayoutDirectionQWidget::layoutDirection() const; QLocaleQWidget::locale() const; intQPaintDevice::logicalDpiX() const; intQPaintDevice::logicalDpiY() const; voidQWidget::lower(); QPointQWidget::mapFrom(QWidget*, const QPoint&) const; QPointQWidget::mapFromGlobal(const QPoint&) const; QPointQWidget::mapFromParent(const QPoint&) const; QPointQWidget::mapTo(QWidget*, const QPoint&) const; QPointQWidget::mapToGlobal(const QPoint&) const; QPointQWidget::mapToParent(const QPoint&) const; QRegionQWidget::mask() const; intQWidget::maximumHeight() const; QSizeQWidget::maximumSize() const; intQWidget::maximumWidth() const; virtual const QMetaObject*metaObject() const; intQWidget::minimumHeight() const; QSizeQWidget::minimumSize() const; virtual QSizeminimumSizeHint() const; intQWidget::minimumWidth() const; static QWidget*QWidget::mouseGrabber(); voidQWidget::move(const QPoint&); voidQWidget::move(int x, int y); voidQObject::moveToThread(QThread* thread); QWidget*QWidget::nativeParentWidget() const; QWidget*QWidget::nextInFocusChain() const; QRectQWidget::normalGeometry() const; intQPaintDevice::n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQtWidget.html:9004,log,logicalDpiX,9004,root/html602/TQtWidget.html,https://root.cern,https://root.cern/root/html602/TQtWidget.html,2,['log'],['logicalDpiX']
Testability,"onst; { return fRho*std::cos(fPhi); }. T Y() const; { return fRho*std::sin(fPhi); }. T Z() const. T R() const. T Mag2() const; { return R()*R(); }. T Perp2() const; { return fRho*fRho; }. T Theta() const. void SetRho(Double32_t rho); setters (only for data members). set the rho coordinate value keeping eta and phi constant. void SetEta(Double32_t eta). set the eta coordinate value keeping rho and phi constant. void SetPhi(Double32_t phi). set the phi coordinate value keeping rho and eta constant. void SetXYZ(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar xx, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar yy, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar zz). set all values using cartesian coordinates. void Scale(Double32_t a). scale by a scalar quantity a --; for cylindrical eta coords, as long as a >= 0, only rho changes!. Negate(). bool operator==(const ROOT::Math::CylindricalEta3D<Double32_t>& rhs) const. Exact component-by-component equality; Note: Peculiar representaions of the zero vector such as (0,1,0) will; not test as equal to one another. bool operator!=(const ROOT::Math::CylindricalEta3D<Double32_t>& rhs) const; {return !(operator==(rhs));}. T x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X();}. T y() const; { return Y();}. T z() const; { return Z(); }. void SetX(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar xx); ============= Specializations for improved speed ==================; (none); ====== Set member functions for coordinates in other systems =======. void SetY(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar yy). void SetZ(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar zz). void SetR(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar r). void SetTheta(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar theta). » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 16:58; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__CylindricalEta3D_Double32_t_.html:6068,test,test,6068,root/html534/ROOT__Math__CylindricalEta3D_Double32_t_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__CylindricalEta3D_Double32_t_.html,1,['test'],['test']
Testability,"onst; { return fRho*std::cos(fPhi); }. T Y() const; { return fRho*std::sin(fPhi); }. T Z() const. T R() const. T Mag2() const; { return R()*R(); }. T Perp2() const; { return fRho*fRho; }. T Theta() const. void SetRho(Double32_t rho); setters (only for data members). set the rho coordinate value keeping eta and phi constant. void SetEta(Double32_t eta). set the eta coordinate value keeping rho and phi constant. void SetPhi(Double32_t phi). set the phi coordinate value keeping rho and eta constant. void SetXYZ(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar xx, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar yy, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar zz). set all values using cartesian coordinates. void Scale(Double32_t a). scale by a scalar quantity a --; for cylindrical eta coords, as long as a >= 0, only rho changes!. Negate(). bool operator==(const ROOT::Math::CylindricalEta3D<Double32_t>& rhs) const. Exact component-by-component equality; Note: Peculiar representaions of the zero vector such as (0,1,0) will; not test as equal to one another. bool operator!=(const ROOT::Math::CylindricalEta3D<Double32_t>& rhs) const; {return !(operator==(rhs));}. T x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X();}. T y() const; { return Y();}. T z() const; { return Z(); }. void SetX(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar xx); ============= Specializations for improved speed ==================; (none); ====== Set member functions for coordinates in other systems =======. void SetY(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar yy). void SetZ(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar zz). void SetR(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar r). void SetTheta(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar theta). » Last changed: root/mathcore:$Id: CylindricalEta3D.h 24923 2008-07-23 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__CylindricalEta3D_Double32_t_.html:6066,test,test,6066,root/html526/ROOT__Math__CylindricalEta3D_Double32_t_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__CylindricalEta3D_Double32_t_.html,1,['test'],['test']
Testability,"onst; { return fRho*std::cos(fPhi); }. T Y() const; { return fRho*std::sin(fPhi); }. T Z() const. T R() const. T Mag2() const; { return R()*R(); }. T Perp2() const; { return fRho*fRho; }. T Theta() const. void SetRho(Double32_t rho); setters (only for data members). set the rho coordinate value keeping eta and phi constant. void SetEta(Double32_t eta). set the eta coordinate value keeping rho and phi constant. void SetPhi(Double32_t phi). set the phi coordinate value keeping rho and eta constant. void SetXYZ(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar xx, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar yy, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar zz). set all values using cartesian coordinates. void Scale(Double32_t a). scale by a scalar quantity a --; for cylindrical eta coords, as long as a >= 0, only rho changes!. Negate(). bool operator==(const ROOT::Math::CylindricalEta3D<Double32_t>& rhs) const. Exact component-by-component equality; Note: Peculiar representaions of the zero vector such as (0,1,0) will; not test as equal to one another. bool operator!=(const ROOT::Math::CylindricalEta3D<Double32_t>& rhs) const; {return !(operator==(rhs));}. T x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X();}. T y() const; { return Y();}. T z() const; { return Z(); }. void SetX(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar xx); ============= Specializations for improved speed ==================; (none); ====== Set member functions for coordinates in other systems =======. void SetY(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar yy). void SetZ(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar zz). void SetR(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar r). void SetTheta(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar theta). » Last changed: root/mathcore:$Id: CylindricalEta3D.h 31938 2009-12-18 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__CylindricalEta3D_Double32_t_.html:6066,test,test,6066,root/html528/ROOT__Math__CylindricalEta3D_Double32_t_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__CylindricalEta3D_Double32_t_.html,3,['test'],['test']
Testability,"onst;  ; Int_t GetFittingBox (const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override;  ; virtual const Double_t * GetOrigin () const;  ; virtual Bool_t GetPointsOnFacet (Int_t index, Int_t npoints, Double_t *array) const;  ; Bool_t GetPointsOnSegments (Int_t npoints, Double_t *array) const override;  ; virtual Bool_t IsNullBox () const;  ; Bool_t IsValidBox () const override;  ; TBuffer3D * MakeBuffer3D () const override;  ; void SetBoxDimensions (Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ; void SetBoxPoints (Double_t *points) const;  ; void SetSegsAndPols (TBuffer3D &buffer) const override;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoShape;  TGeoShape ();  Default constructor. ;  ;  TGeoShape (const char *name);  Default constructor. ;  ;  ~TGeoShape () override;  Destructor. ;  ; virtual void AfterStreamer ();  ; void CheckShape (Int_t testNo, Int_t nsamples=10000, Option_t *option="""");  Test for shape navigation methods. ;  ; virtual void ClearThreadData () const;  ; virtual void CreateThreadData (Int_t);  ; void Draw (Option_t *option="""") override;  Draw this shape. ;  ; void ExecuteEvent (Int_t event, Int_t px, Int_t py) override;  Execute mouse actions on this shape. ;  ; Int_t GetId () const;  ; const char * GetName () const override;  Get the shape name. ;  ; const char * GetPointerName () const;  Provide a pointer name containing uid. ;  ; void InvertShapeBit (UInt_t f);  ; TClass * IsA () const override;  ; virtual Bool_t IsAssembly () const;  ; virtual Bool_t IsComposite () const;  ; virtual Bool_t IsReflected () const;  ; Bool_t IsRunTimeShape () const;  ; Bool_t IsValid () const;  ; virtual Bool_t IsVecGeom () const;  ; void Paint (Option_t *option="""") override;  Paint this shape. ;  ; void ResetShapeBit (UInt_t f);  ; void SetId (Int_t id);  ; void SetRuntime (Bool_t flag=kTRUE);  ; void SetShapeBit (UInt_t f);  ; vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoHalfSpace.html:6558,test,testNo,6558,doc/master/classTGeoHalfSpace.html,https://root.cern,https://root.cern/doc/master/classTGeoHalfSpace.html,1,['test'],['testNo']
Testability,"onstructor which takes a folder; 3462 // as an argument. The mother branch has internal; 3463 // dots in its name to represent the folder hierarchy.; 3464 // The TTree::Bronch() routine has handled us as a; 3465 // special case, we must compensate.; 3466 if ((fID > -1) && (mother == mother->GetSubBranch(this)) && (branchElem->IsA() == TStreamerBase::Class())) {; 3467 // -- Our parent's name is the mother name, remove it.; 3468 // Note: The test is our parent's parent is a top-level branch; 3469 // and our parent's streamer is the base class streamer,; 3470 // this matches the exact test in TTree::Bronch().; 3471 if (parentName.Length() == motherName.Length()) {; 3472 parentName.Remove(0, motherName.Length());; 3473 }; 3474 } else {; 3475 // -- Remove the mother name and the dot.; 3476 if (parentName.Length() > motherName.Length()) {; 3477 parentName.Remove(0, motherName.Length() + 1);; 3478 }; 3479 }; 3480 }; 3481 // FIXME: Do we need to use the other tests for a base class here?; 3482 if (fType == 1) {; 3483 // -- Our parent is a base class sub-branch, remove the base class name suffix from its name.; 3484 if (mother != mother->GetSubBranch(this)) {; 3485 // -- My parent's parent is not a top-level branch.; 3486 // Remove the base class name suffix from the parent name.; 3487 // Note: The pattern is the name of the base class.; 3488 // coverity[var_deref_model] branchElem is non zero here since fType==1 and thus fID > -1; 3489 TString pattern(branchElem->GetName());; 3490 if (pattern.Length() <= parentName.Length()) {; 3491 if (!strcmp(parentName.Data() + (parentName.Length() - pattern.Length()), pattern.Data())) {; 3492 // The branch name contains the name of the base class in it.; 3493 // This name is not reproduced in the sub-branches, so we need to; 3494 // remove it.; 3495 parentName.Remove(parentName.Length() - pattern.Length());; 3496 }; 3497 }; 3498 }; 3499 // Note: We intentionally leave any trailing dots; 3500 // in the modified parent name here.; 3501 }; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:125956,test,tests,125956,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['test'],['tests']
Testability,"onstructor. ;  ;  ~BrentMinimizer1D () override;  Default Destructor. ;  ; double FValLower () const override;  Return function value at current lower bound of the minimization interval. ;  ; double FValMinimum () const override;  Return function value at current estimate of the minimum. ;  ; double FValUpper () const override;  Return function value at current upper bound of the minimization interval. ;  ; int Iterations () const override;  Return number of iteration used to find minimum. ;  ; bool Minimize (int maxIter, double absTol=1.E-8, double relTol=1.E-10) override;  Find minimum position iterating until convergence specified by the absolute and relative tolerance or the maximum number of iteration is reached. ;  ; const char * Name () const override;  Return name of minimization algorithm (""BrentMinimizer1D"") ;  ; void SetFunction (const ROOT::Math::IGenFunction &f, double xlow, double xup);  Sets function to be minimized. ;  ; void SetLogScan (bool on);  Set a log grid scan (default is equidistant bins) will work only if xlow > 0. ;  ; void SetNpx (int npx);  Set the number of point used to bracket root using a grid. ;  ; int Status () const override;  Returns status of last estimate. ;  ; double XLower () const override;  Return current lower bound of the minimization interval. ;  ; double XMinimum () const override;  Return current estimate of the position of the minimum. ;  ; double XUpper () const override;  Return current upper bound of the minimization interval. ;  . Static Public Member Functions; static void SetDefaultNpx (int npx);  set number of default Npx used at construction time (when SetNpx is not called) Default value is 100 ;  ; static void SetDefaultNSearch (int n);  set number of times the bracketing search in combination with is done to find a good interval Default value is 10 ;  . Private Attributes; const IGenFunction * fFunction;  Pointer to the function. ;  ; bool fLogScan;  flag to control usage of a log scan ;  ; int fNIter;  Numbe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1BrentMinimizer1D.html:2633,log,log,2633,doc/master/classROOT_1_1Math_1_1BrentMinimizer1D.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1BrentMinimizer1D.html,1,['log'],['log']
Testability,"onstructor. ;  ;  ~HybridResult () override;  Destructor of HybridResult. ;  ; void Add (HybridResult *other);  add additional toy-MC experiments to the current results use the data test statistics of the added object if none is already present (otherwise, ignore the new one) ;  ; double AlternatePValue () const override;  Returns \(CL_{s+b}\) : the S+B p-value. ;  ; double CLbError () const;  The error on the ""confidence level"" of the null hypothesis. ;  ; double CLsError () const;  The error on the ratio \(CL_{s+b}/CL_{b}\). ;  ; double CLsplusbError () const;  The error on the ""confidence level"" of the alternative hypothesis. ;  ; HybridPlot * GetPlot (const char *name, const char *title, int n_bins);  prepare a plot showing a result and return a pointer to a HybridPlot object the needed arguments are: an object name, a title and the number of bins in the plot ;  ; std::vector< double > GetTestStat_b ();  Get test statistics values for the b model. ;  ; double GetTestStat_data ();  Get test statistics value for data. ;  ; std::vector< double > GetTestStat_sb ();  Get test statistics values for the sb model. ;  ; TClass * IsA () const override;  ; double NullPValue () const override;  Returns \(1 - CL_{b}\) : the B p-value. ;  ; void PrintMore (const char *options);  Print out some information about the results. ;  ; void SetDataTestStatistics (double testStat_data_val);  set the value of the test statistics on data ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooStats::HypoTestResult;  HypoTestResult (const char *name, double nullp, double altp);  constructor from name, null and alternate p values ;  ;  HypoTestResult (const char *name=nullptr);  default constructor ;  ;  HypoTestResult (const HypoTestResult &other);  copy constructor ;  ;  ~HypoTestResult () override;  destructor ;  ; virtual void Append (const HypoTestRes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1HybridResult.html:2153,test,test,2153,doc/master/classRooStats_1_1HybridResult.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1HybridResult.html,1,['test'],['test']
Testability,onstructorHolder.cxx;  TConstructorHolder.h;  TCustomPyTypes.cxx;  TCustomPyTypes.h;  TemplateProxy.cxx;  TemplateProxy.h;  TFunctionHolder.cxx;  TFunctionHolder.h;  TMemoryRegulator.cxx;  TMemoryRegulator.h;  TMethodHolder.cxx;  TMethodHolder.h;  TPyArg.cxx;  TPyBufferFactory.cxx;  TPyBufferFactory.h;  TPyClassGenerator.cxx;  TPyClassGenerator.h;  TPyDispatcher.cxx;  TPyException.cxx;  TPyFitFunction.cxx;  TPyReturn.cxx;  TPyROOTApplication.cxx;  TPySelector.cxx;  TPython.cxx;  TSetItemHolder.cxx;  TSetItemHolder.h;  TTupleOfInstances.cxx;  TTupleOfInstances.h;  Utility.cxx;  Utility.h;  ► r;  ► inc;  RExports.h;  TRDataFrame.h;  TRDataFrame__ctors.h;  TRFunctionExport.h;  TRFunctionImport.h;  TRFunctionImport__oprtr.h;  TRInterface.h;  TRInterface_Binding.h;  TRInternalFunction.h;  TRInternalFunction__ctors.h;  TRObject.h;  ► src;  RExports.cxx;  TRCompletion.cxx;  TRCompletion.h;  TRDataFrame.cxx;  TRFunctionExport.cxx;  TRFunctionImport.cxx;  TRInterface.cxx;  TRObject.cxx;  ► tests;  Binding.C;  Class.C;  DataFrame.C;  Exception.C;  ExpClass.C;  Functions.C;  Functor.C;  FunModule.C;  Object.C;  Proxy.C;  ROOTR.C;  ► core;  ► base;  ► doc;  ► macros;  fillpatterns.C;  fonts.C;  textalign.C;  textangle.C;  ► inc;  ► ROOT;  RConfig.h;  StringConv.hxx;  TExecutor.hxx;  TSequentialExecutor.hxx;  Bswapcpy.h;  Buttons.h;  Bytes.h;  Byteswap.h;  CommandLineOptionsHelp.h;  DllImport.h;  GLConstants.h;  Gtypes.h;  GuiTypes.h;  Htypes.h;  KeySymbols.h;  LinkDef1.h;  LinkDef2.h;  LinkDef3.h;  Match.h;  MessageTypes.h;  RConfig.h;  Riostream.h;  Rpair.h;  RQ_OBJECT.h;  RStipples.h;  Rstrstream.h;  Rtypes.h;  RtypesCore.h;  RtypesImp.h;  RVersion.h;  Strlen.h;  TApplication.h;  TApplicationImp.h;  TAtt3D.h;  TAttAxis.h;  TAttBBox.h;  TAttBBox2D.h;  TAttFill.h;  TAttLine.h;  TAttMarker.h;  TAttPad.h;  TAttText.h;  TBase64.h;  TBenchmark.h;  TBrowser.h;  TBrowserImp.h;  TBuffer.h;  TBuffer3D.h;  TBuffer3DTypes.h;  TCanvasImp.h;  TColor.h;  TColorGradient.h;  TContextMenu.h;  ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:1818,test,tests,1818,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,1,['test'],['tests']
Testability,onstructorHolder.cxx;  TConstructorHolder.h;  TCustomPyTypes.cxx;  TCustomPyTypes.h;  TemplateProxy.cxx;  TemplateProxy.h;  TFunctionHolder.cxx;  TFunctionHolder.h;  TMemoryRegulator.cxx;  TMemoryRegulator.h;  TMethodHolder.cxx;  TMethodHolder.h;  TPyArg.cxx;  TPyBufferFactory.cxx;  TPyBufferFactory.h;  TPyClassGenerator.cxx;  TPyClassGenerator.h;  TPyDispatcher.cxx;  TPyException.cxx;  TPyFitFunction.cxx;  TPyReturn.cxx;  TPyROOTApplication.cxx;  TPySelector.cxx;  TPython.cxx;  TSetItemHolder.cxx;  TSetItemHolder.h;  TTupleOfInstances.cxx;  TTupleOfInstances.h;  Utility.cxx;  Utility.h;  ► r;  ► inc;  RExports.h;  TRDataFrame.h;  TRDataFrame__ctors.h;  TRFunctionExport.h;  TRFunctionImport.h;  TRFunctionImport__oprtr.h;  TRInterface.h;  TRInterface_Binding.h;  TRInternalFunction.h;  TRInternalFunction__ctors.h;  TRObject.h;  ► src;  RExports.cxx;  TRCompletion.cxx;  TRCompletion.h;  TRDataFrame.cxx;  TRFunctionExport.cxx;  TRFunctionImport.cxx;  TRInterface.cxx;  TRObject.cxx;  ► tests;  Binding.C;  Class.C;  DataFrame.C;  Exception.C;  ExpClass.C;  Functions.C;  Functor.C;  FunModule.C;  Object.C;  Proxy.C;  ROOTR.C;  ► core;  ► base;  ► doc;  ► macros;  fillpatterns.C;  fonts.C;  textalign.C;  textangle.C;  ► inc;  ► ROOT;  StringConv.hxx;  TExecutor.hxx;  Bswapcpy.h;  Buttons.h;  Bytes.h;  Byteswap.h;  CommandLineOptionsHelp.h;  DllImport.h;  GLConstants.h;  Gtypes.h;  GuiTypes.h;  Htypes.h;  KeySymbols.h;  LinkDef1.h;  LinkDef2.h;  LinkDef3.h;  Match.h;  MessageTypes.h;  RConfig.h;  Riostream.h;  Rpair.h;  RQ_OBJECT.h;  RStipples.h;  Rstrstream.h;  Rtypes.h;  RtypesCore.h;  RtypesImp.h;  RVersion.h;  Strlen.h;  TApplication.h;  TApplicationImp.h;  TAtt3D.h;  TAttAxis.h;  TAttBBox.h;  TAttBBox2D.h;  TAttFill.h;  TAttLine.h;  TAttMarker.h;  TAttPad.h;  TAttText.h;  TBase64.h;  TBenchmark.h;  TBrowser.h;  TBrowserImp.h;  TBuffer.h;  TBuffer3D.h;  TBuffer3DTypes.h;  TCanvasImp.h;  TColor.h;  TColorGradient.h;  TContextMenu.h;  TContextMenuImp.h;  TControlBarImp.h; ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:1796,test,tests,1796,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,1,['test'],['tests']
Testability,onstructorHolder.cxx;  TConstructorHolder.h;  TCustomPyTypes.cxx;  TCustomPyTypes.h;  TemplateProxy.cxx;  TemplateProxy.h;  TFunctionHolder.cxx;  TFunctionHolder.h;  TMemoryRegulator.cxx;  TMemoryRegulator.h;  TMethodHolder.cxx;  TMethodHolder.h;  TPyArg.cxx;  TPyBufferFactory.cxx;  TPyBufferFactory.h;  TPyClassGenerator.cxx;  TPyClassGenerator.h;  TPyDispatcher.cxx;  TPyException.cxx;  TPyFitFunction.cxx;  TPyReturn.cxx;  TPyROOTApplication.cxx;  TPySelector.cxx;  TPython.cxx;  TSetItemHolder.cxx;  TSetItemHolder.h;  TTupleOfInstances.cxx;  TTupleOfInstances.h;  Utility.cxx;  Utility.h;  ► r;  ► inc;  RExports.h;  TRDataFrame.h;  TRDataFrame__ctors.h;  TRFunctionExport.h;  TRFunctionImport.h;  TRFunctionImport__oprtr.h;  TRInterface.h;  TRInterface_Binding.h;  TRInternalFunction.h;  TRInternalFunction__ctors.h;  TRObject.h;  ► src;  RExports.cxx;  TRCompletion.cxx;  TRCompletion.h;  TRDataFrame.cxx;  TRFunctionExport.cxx;  TRFunctionImport.cxx;  TRInterface.cxx;  TRObject.cxx;  ► tests;  Binding.C;  Class.C;  DataFrame.C;  Exception.C;  ExpClass.C;  Functions.C;  Functor.C;  FunModule.C;  Object.C;  Proxy.C;  ROOTR.C;  ► core;  ► base;  ► doc;  ► macros;  fillpatterns.C;  fonts.C;  textalign.C;  textangle.C;  ► inc;  ► ROOT;  StringConv.hxx;  TExecutor.hxx;  Bswapcpy.h;  Buttons.h;  Bytes.h;  Byteswap.h;  DllImport.h;  GLConstants.h;  Gtypes.h;  GuiTypes.h;  Htypes.h;  KeySymbols.h;  LinkDef1.h;  LinkDef2.h;  LinkDef3.h;  Match.h;  MessageTypes.h;  RConfig.h;  Riosfwd.h;  Riostream.h;  Rpair.h;  RQ_OBJECT.h;  RStipples.h;  Rstrstream.h;  Rtypeinfo.h;  Rtypes.h;  RtypesCore.h;  RtypesImp.h;  RVersion.h;  Strlen.h;  TApplication.h;  TApplicationImp.h;  TAtt3D.h;  TAttAxis.h;  TAttBBox.h;  TAttBBox2D.h;  TAttFill.h;  TAttLine.h;  TAttMarker.h;  TAttPad.h;  TAttText.h;  TBase64.h;  TBenchmark.h;  TBrowser.h;  TBrowserImp.h;  TBuffer.h;  TBuffer3D.h;  TBuffer3DTypes.h;  TCanvasImp.h;  TColor.h;  TColorGradient.h;  TContextMenu.h;  TContextMenuImp.h;  TControlBarImp.h;  ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:1796,test,tests,1796,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['test'],['tests']
Testability,"onstructs a numeric entry widget. ;  ;  ~TGNumberEntry () override;  Destructs a numeric entry widget. ;  ; void Associate (const TGWindow *w) override;  Make w the window that will receive the generated messages. ;  ; TGButton * GetButtonDown () const;  Get the down button. ;  ; TGButton * GetButtonUp () const;  Get the up button. ;  ; virtual void GetDate (Int_t &year, Int_t &month, Int_t &day) const;  ; UInt_t GetDefaultHeight () const override;  ; virtual ULong_t GetHexNumber () const;  ; virtual Long_t GetIntNumber () const;  ; TGLayoutManager * GetLayoutManager () const override;  Return layout manager. ;  ; virtual EAttribute GetNumAttr () const;  ; virtual Double_t GetNumber () const;  ; TGNumberEntryField * GetNumberEntry () const;  Get the number entry field. ;  ; virtual ELimit GetNumLimits () const;  ; virtual Double_t GetNumMax () const;  ; virtual Double_t GetNumMin () const;  ; virtual EStyle GetNumStyle () const;  ; virtual void GetTime (Int_t &hour, Int_t &min, Int_t &sec) const;  ; virtual void IncreaseNumber (EStepSize step=kNSSSmall, Int_t sign=1, Bool_t logstep=kFALSE);  ; TClass * IsA () const override;  ; Bool_t IsEditable () const override;  Return kTRUE if frame is being edited. ;  ; virtual Bool_t IsLogStep () const;  ; virtual void Modified ();  Emit Modified() signal. ;  ; Bool_t ProcessMessage (Longptr_t msg, Longptr_t parm1, Longptr_t parm2) override;  Process the up/down button messages. ;  ; void SavePrimitive (std::ostream &out, Option_t *="""") override;  Save a number entry widget as a C++ statement(s) on output stream out. ;  ; virtual void SetButtonToNum (Bool_t state);  Send button messages to the number field (true) or parent widget (false). ;  ; virtual void SetDate (Int_t year, Int_t month, Int_t day, Bool_t emit=kTRUE);  ; virtual void SetFormat (EStyle style, EAttribute attr=TGNumberFormat::kNEAAnyNumber);  ; virtual void SetHexNumber (ULong_t val, Bool_t emit=kTRUE);  ; virtual void SetIntNumber (Long_t val, Bool_t emit=kTRUE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGNumberEntry.html:4231,log,logstep,4231,doc/master/classTGNumberEntry.html,https://root.cern,https://root.cern/doc/master/classTGNumberEntry.html,1,['log'],['logstep']
Testability,"onteCarloEventsDefinition MethodCuts.h:151; TMVA::MethodCuts::fCutRangeMinDouble_t * fCutRangeMinminimum of allowed cut rangeDefinition MethodCuts.h:175; TMVA::MethodCuts::fBinaryTreeBBinarySearchTree * fBinaryTreeBDefinition MethodCuts.h:181; TMVA::MethodCuts::fRmsSstd::vector< Double_t > * fRmsSRMSs of variables (signal)Definition MethodCuts.h:199; TMVA::MethodCuts::fMeanSstd::vector< Double_t > * fMeanSmeans of variables (signal)Definition MethodCuts.h:197; TMVA::MethodCuts::fMeanBstd::vector< Double_t > * fMeanBmeans of variables (background)Definition MethodCuts.h:198; TMVA::MethodCuts::fAllVarsITString * fAllVarsIwhat to do with variablesDefinition MethodCuts.h:188; TMVA::MethodCuts::fFitParamsstd::vector< EFitParameters > * fFitParamsvector for series of fit methodsDefinition MethodCuts.h:171; TMVA::MethodCuts::GetSeparationDouble_t GetSeparation(TH1 *, TH1 *) constcompute ""separation"" defined asDefinition MethodCuts.h:100; TMVA::MethodCuts::fTestSignalEffDouble_t fTestSignalEffused to test optimized signal efficiencyDefinition MethodCuts.h:172; TMVA::MethodCuts::fCutRangestd::vector< Interval * > fCutRangeallowed ranges for cut optimisationDefinition MethodCuts.h:177; TMVA::MethodCuts::fTmpCutMaxDouble_t * fTmpCutMaxtemporary maximum requirementDefinition MethodCuts.h:187; TMVA::MethodCuts::fVarHistS_smoothstd::vector< TH1 * > * fVarHistS_smoothsmoothed reference histograms (signal)Definition MethodCuts.h:207; TMVA::MethodCuts::MatchParsToCutsvoid MatchParsToCuts(Double_t *, Double_t *, Double_t *); TMVA::MethodCuts::fCutMaxDouble_t ** fCutMaxmaximum requirementDefinition MethodCuts.h:185; TMVA::MethodCuts::ReadWeightsFromXMLvoid ReadWeightsFromXML(void *wghtnode)read coefficients from xml weight fileDefinition MethodCuts.cxx:1327; TMVA::MethodCuts::fEffBvsSLocalTH1 * fEffBvsSLocalintermediate eff. background versus eff signal histoDefinition MethodCuts.h:202; TMVA::MethodCuts::GetEffsfromPDFsvoid GetEffsfromPDFs(Double_t *cutMin, Double_t *cutMax, Double_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodCuts_8h_source.html:20767,test,test,20767,doc/master/MethodCuts_8h_source.html,https://root.cern,https://root.cern/doc/master/MethodCuts_8h_source.html,1,['test'],['test']
Testability,"ooAbsArg &server, bool force=false);  Unregister another RooAbsArg as a server to us, ie, declare that we no longer depend on its value and shape. ;  ; RooAbsArg * findNewServer (const RooAbsCollection &newSet, bool nameChange) const;  Find the new server in the specified set that matches the old server. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChi2Var.html:38971,test,test,38971,doc/master/classRooChi2Var.html,https://root.cern,https://root.cern/doc/master/classRooChi2Var.html,2,['test'],['test']
Testability,"ooAbsArg &server, bool force=false);  Unregister another RooAbsArg as a server to us, ie, declare that we no longer depend on its value and shape. ;  ; RooAbsArg * findNewServer (const RooAbsCollection &newSet, bool nameChange) const;  Find the new server in the specified set that matches the old server. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:48723,test,test,48723,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,9,['test'],['test']
Testability,"ooAbsArg &server, bool force=false);  Unregister another RooAbsArg as a server to us, ie, declare that we no longer depend on its value and shape. ;  ; RooAbsArg * findNewServer (const RooAbsCollection &newSet, bool nameChange) const;  Find the new server in the specified set that matches the old server. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBMixDecay.html:48772,test,test,48772,doc/master/classRooBMixDecay.html,https://root.cern,https://root.cern/doc/master/classRooBMixDecay.html,7,['test'],['test']
Testability,"ooAbsArg &server, bool force=false);  Unregister another RooAbsArg as a server to us, ie, declare that we no longer depend on its value and shape. ;  ; RooAbsArg * findNewServer (const RooAbsCollection &newSet, bool nameChange) const;  Find the new server in the specified set that matches the old server. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinWidthFunction.html:33959,test,test,33959,doc/master/classRooBinWidthFunction.html,https://root.cern,https://root.cern/doc/master/classRooBinWidthFunction.html,135,['test'],['test']
Testability,"ooAbsArg& , RooArgSet& , RooArgSet& ); { return fNToys; }. void SetNToys(const Int_t ntoy); { fNToys = ntoy; }. void SetNEventsPerToy(const Int_t nevents); Forces n events even for extended PDFs. Set NEvents=0 to; use the Poisson distributed events from the extended PDF. void SetParametersForTestStat(const RooArgSet& nullpoi); Set the Pdf, add to the the workspace if not already there. void SetPdf(RooAbsPdf& pdf); { fPdf = &pdf; ClearCache(); }. void SetPriorNuisance(RooAbsPdf* pdf); How to randomize the prior. Set to NULL to deactivate randomization. void SetNuisanceParameters(const RooArgSet& np); specify the nuisance parameters (eg. the rest of the parameters). { fNuisancePars = &np; }. void SetObservables(const RooArgSet& o); specify the observables in the dataset (needed to evaluate the test statistic). { fObservables = &o; }. void SetGlobalObservables(const RooArgSet& o); specify the conditional observables. { fGlobalObservables = &o; }. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). { fSize = size; }. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). { fSize = 1. - cl; }. void SetTestStatistic(RooStats::TestStatistic* testStatistic, unsigned int i); Set the TestStatistic (want the argument to be a function of the data & parameter points. void SetTestStatistic(RooStats::TestStatistic* t); { return SetTestStatistic(t,0); }. void SetExpectedNuisancePar(Bool_t i = kTRUE); { fExpectedNuisancePar = i; }. void SetAsimovNuisancePar(Bool_t i = kTRUE); { fExpectedNuisancePar = i; }. void SetGenerateBinned(bool binned = true); control to use bin data generation (=> see RooFit::AllBinned() option). { fGenerateBinned = binned; }. void SetGenerateBinnedTag(const char* binnedTag = """"); name of the tag for individual components to be generated binned (=> see RooFit::GenBinned() option). { fGenerateBinnedTag = binnedTag; }. void S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__ToyMCSampler.html:9751,test,test,9751,root/html534/RooStats__ToyMCSampler.html,https://root.cern,https://root.cern/root/html534/RooStats__ToyMCSampler.html,3,['test'],['test']
Testability,"ooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; const RooCatType*lookupType(Int_t index, Bool_t printError = kFALSE) const; const RooCatType*lookupType(const char* label, Bool_t printError = kFALSE) const; const RooCatType*lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; Int_tnumTypes(const char* = 0) const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_toperator!=(Int_t index); Bool_toperator!=(const char* label); Bool_toperator!=(const RooAbsArg& other); TNamed&TNamed::operator=(const TNamed& rhs); Bool_toperator==(Int_t index) const; Bool_toperator==(const char* label) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCategory.html:10325,test,testArg,10325,root/html534/RooAbsCategory.html,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html,1,['test'],['testArg']
Testability,"ooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; const RooCatType*lookupType(Int_t index, Bool_t printError = kFALSE) const; const RooCatType*lookupType(const char* label, Bool_t printError = kFALSE) const; const RooCatType*lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; Int_tnumTypes(const char* = 0) const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_toperator!=(Int_t index); Bool_toperator!=(const char* label); Bool_toperator!=(const RooAbsArg& other); RooAbsCategory&operator=(const RooAbsCategory&); Bool_toperator==(Int_t index) const; Bool_toperator==(const char* label) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCategory.html:10320,test,testArg,10320,root/html602/RooAbsCategory.html,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html,2,['test'],['testArg']
Testability,"ooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_toperator==(const char*) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0); voidRooAbsArg::printDirty(Bool_t depth = kTRUE) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsArg::printMetaArgs(ostream&) const; virtual voidRooAbsArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsString.html:9529,test,testArg,9529,root/html526/RooAbsString.html,https://root.cern,https://root.cern/root/html526/RooAbsString.html,1,['test'],['testArg']
Testability,"ooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_toperator==(const char*) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidRooAbsArg::printDirty(Bool_t depth = kTRUE) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsArg::printMetaArgs(ostream&) const; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsString.html:9644,test,testArg,9644,root/html528/RooAbsString.html,https://root.cern,https://root.cern/root/html528/RooAbsString.html,1,['test'],['testArg']
Testability,"ooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRangeBoolean&operator=(const RooRangeBoolean&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRangeBoolean.html:19369,test,testArg,19369,root/html602/RooRangeBoolean.html,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html,2,['test'],['testArg']
Testability,"ooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRealIntegral&operator=(const RooRealIntegral&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealIntegral.html:19284,test,testArg,19284,root/html602/RooRealIntegral.html,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html,2,['test'],['testArg']
Testability,"ooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooStepFunction&operator=(const RooStepFunction&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStepFunction.html:19851,test,testArg,19851,root/html602/RooStepFunction.html,https://root.cern,https://root.cern/root/html602/RooStepFunction.html,2,['test'],['testArg']
Testability,"ooAbsData*fDatapointer to the data sets ; boolfGenerateBinnedFlag to control binned generation; unsigned intfNToysnumber of Toys MC; const RooArgSet*fNuisanceParametersCollection of the nuisance parameters in the model; RooArgList*fObservablesCollection of the observables of the model; RooAbsPdf*fPriorPdfPrior PDF of the nuisance parameters; RooAbsPdf*fSbModelThe pdf of the signal+background model; unsigned intfTestStatisticsIdxIndex of the test statistics to use; boolfTmpDoExtended; boolfUsePriorPdfuse a prior for nuisance parameters . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; HybridCalculatorOriginal(const char* name = 0); constructor with name and title; set default parameters. HybridCalculatorOriginal(RooAbsPdf& sb_model, RooAbsPdf& b_model, RooArgList& observables, const RooArgSet* nuisance_parameters = 0, RooAbsPdf* prior_pdf = 0, bool GenerateBinned = false, int testStatistics = 1, int ntoys = 1000); HybridCalculatorOriginal constructor without specifying a data set; the user need to specify the models in the S+B case and B-only case,; the list of observables of the model(s) (for MC-generation), the list of parameters; that are marginalised and the prior distribution of those parameters. HybridCalculatorOriginal(RooAbsData& data, RooAbsPdf& sb_model, RooAbsPdf& b_model, const RooArgSet* nuisance_parameters = 0, RooAbsPdf* prior_pdf = 0, bool GenerateBinned = false, int testStatistics = 1, int ntoys = 1000); HybridCalculatorOriginal constructor for performing hypotesis test; the user need to specify the data set, the models in the S+B case and B-only case.; In case of treatment of nuisance parameter, the user need to specify the; the list of parameters that are marginalised and the prior distribution of those parameters. HybridCalculatorOriginal(RooAbsData& data, const RooStats::ModelConfig& sb_model, const RooStats::ModelConfig& b_model, bool GenerateBinned = false, int testStatistics = 1, int ntoys = 1000); Co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__HybridCalculatorOriginal.html:10746,test,testStatistics,10746,root/html528/RooStats__HybridCalculatorOriginal.html,https://root.cern,https://root.cern/root/html528/RooStats__HybridCalculatorOriginal.html,4,['test'],['testStatistics']
Testability,"ooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tmaxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*mean(RooRealVar& obs); RooMoment*mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tminTrialSamples(const RooArgSet&) const; RooMoment*moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tnumEvalErrorItems(); static Int_tnumEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_toperator==(Double_t value) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsReal.html:17174,test,testArg,17174,root/html532/RooAbsReal.html,https://root.cern,https://root.cern/root/html532/RooAbsReal.html,1,['test'],['testArg']
Testability,"ooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = RooCmdArg::none(), const RooCmdArg arg7 = RooCmdArg::none(), const RooCmdArg arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedReal.html:8832,test,testArg,8832,root/html526/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedReal.html,198,['test'],['testArg']
Testability,ooAbsReal*_funcInt! Function integral; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooNumIntConfig_intConfigNumeric integrator configuration for integration of function over bin; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_t_integrateIs integration over the bin volume requested; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*RooAbsOptTestStatistic::_normSetPointer to set with observables used for normalization; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooAbsOptTestStatistic::_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgSetRooAbsOptTestStatistic::_ownedDataObs! Dataset observables we've agreed to own; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*RooAbsOptTestStatistic::_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; TListRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; RooArgSet_rrvArgsSet of real-valued observables; TIterator*_rrvIter! Iterator over set of real-valued observables; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TStringRooAbsOptTestStatistic::_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_tRooAbsOptTestStatistic::_sealedIs test statistic sealed -- i.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooXYChi2Var.html:35294,test,test,35294,root/html530/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html530/RooXYChi2Var.html,3,['test'],['test']
Testability,"ooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyk; RooRealProxym0; RooRealProxyx. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooLognormal(const char* name, const char* title, RooAbsReal& _x, RooAbsReal& _m0, RooAbsReal& _k). RooLognormal(const RooLognormal& other, const char* name = 0). Double_t evaluate() const; ln(k)<1 would correspond to sigma < 0 in the parametrization; resulting by transforming a normal random variable in its; standard parametrization to a lognormal random variable; => treat ln(k) as -ln(k) for k<1. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const. void generateEvent(Int_t code). RooLognormal(); {}. TObject* clone(const char* newname) const; { return new RooLognormal(*this,newname); }. virtual ~RooLognormal(); { }. » Last changed: Tue Jun 2 15:31:56 2015 » Last generated: 2015-06-02 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooLognormal.html:45398,log,lognormal,45398,root/html604/RooLognormal.html,https://root.cern,https://root.cern/root/html604/RooLognormal.html,1,['log'],['lognormal']
Testability,"ooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual voidnormLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooResolutionModel.html:25996,test,testArg,25996,root/html534/RooResolutionModel.html,https://root.cern,https://root.cern/root/html534/RooResolutionModel.html,1,['test'],['testArg']
Testability,"ooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAddition.html:19044,test,testArg,19044,root/html532/RooAddition.html,https://root.cern,https://root.cern/root/html532/RooAddition.html,2,['test'],['testArg']
Testability,"ooAbsRealvirtual; MayNotUse(const char *method) constTObject; mean(RooRealVar &obs)RooAbsRealinline; mean(RooRealVar &obs, const RooArgSet &nset)RooAbsRealinline; minTrialSamples(const RooArgSet &) constRooAbsRealinlinevirtual; moment(RooRealVar &obs, Int_t order, bool central, bool takeRoot)RooAbsReal; moment(RooRealVar &obs, const RooArgSet &normObs, Int_t order, bool central, bool takeRoot, bool intNormObs)RooAbsReal; mustBeExtended() constRooAbsPdfinline; MustBeExtended enum valueRooAbsPdf; nameFieldLength(Int_t newLen)RooPrintablestatic; namePtr() constRooAbsArginline; Never enum valueRooAbsArg; normalizeWithNaNPacking(double rawVal, double normVal) constRooAbsPdfprotected; normRange() constRooAbsPdfinline; NotAdvised enum valueRooAbsArg; Notify()TObjectvirtual; numCaches() constRooAbsArg; numEvalErrorItems()RooAbsRealstatic; numEvalErrors()RooAbsRealstatic; NumEvent enum valueRooAbsReal; numProxies() constRooAbsArg; observableOverlaps(const RooAbsData *dset, const RooAbsArg &testArg) constRooAbsArg; observableOverlaps(const RooArgSet *depList, const RooAbsArg &testArg) constRooAbsArg; Obsolete(const char *method, const char *asOfVers, const char *removedFromVers) constTObject; offset() constRooAbsRealinlinevirtual; operator delete(void *ptr)TObject; operator delete(void *ptr, void *vp)TObject; operator delete[](void *ptr)TObject; operator delete[](void *ptr, void *vp)TObject; operator new(size_t sz)TObjectinline; operator new(size_t sz, void *vp)TObjectinline; operator new[](size_t sz)TObjectinline; operator new[](size_t sz, void *vp)TObjectinline; operator=(const RooAbsArg &other)=deleteRooAbsArg; TNamed::operator=(const TNamed &rhs)TNamed; TObject::operator=(const TObject &rhs)TObjectinline; operator==(double value) constRooAbsReal; operator==(const RooAbsArg &other) const overrideRooAbsRealvirtual; operMode() constRooAbsArginline; OperMode enum nameRooAbsArg; operModeHook()RooAbsArginlineprotectedvirtual; optimizeCacheMode(const RooArgSet &observables)RooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf-members.html:27290,test,testArg,27290,doc/master/classRooAbsPdf-members.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf-members.html,1,['test'],['testArg']
Testability,"ooArgSet& anaIntSet); 74```; 75should return the analytical integrals that are supported. `integSet`; 76is the set of dependents for which integration is requested. The; 77function should copy the subset of dependents it can analytically; 78integrate to `anaIntSet`, and return a unique identification code for; 79this integration configuration. If no integration can be; 80performed, zero should be returned. Second,; 81 ; 82```; 83double analyticalIntegral(Int_t code); 84```; 85 ; 86implements the actual analytical integral(s) advertised by; 87`getAnalyticalIntegral()`. This function will only be called with; 88codes returned by `getAnalyticalIntegral()`, except code zero.; 89 ; 90The integration range for each dependent to be integrated can; 91be obtained from the dependent's proxy functions `min()` and; 92`max()`. Never call these proxy functions for any proxy not known to; 93be a dependent via the integration code. Doing so may be; 94ill-defined, e.g., in case the proxy holds a function, and will; 95trigger an assert. Integrated category dependents should always be; 96summed over all of their states.; 97 ; 98 ; 99 ; 100### Direct generation of observables; 101 ; 102Distributions for any PDF can be generated with the accept/reject method,; 103but for certain PDFs, more efficient methods may be implemented. To; 104implement direct generation of one or more observables, two; 105functions need to be implemented, similar to those for analytical; 106integrals:; 107 ; 108```; 109Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars); 110```; 111and; 112```; 113void generateEvent(Int_t code); 114```; 115 ; 116The first function advertises observables, for which distributions can be generated,; 117similar to the way analytical integrals are advertised. The second; 118function implements the actual generator for the advertised observables.; 119 ; 120The generated dependent values should be stored in the proxy; 121objects. For this, the assignment operator c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:4737,assert,assert,4737,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['assert'],['assert']
Testability,"ooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = RooCmdArg::none(), const RooCmdArg arg7 = RooCmdArg::none(), const RooCmdArg arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsData&data(); const RooAbsData&data() const; virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsOptTestStatistic.html:9173,test,testArg,9173,root/html526/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html526/RooAbsOptTestStatistic.html,2,['test'],['testArg']
Testability,"ooArgSet& paramsOfInterest); virtual RooAbsPdf*createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooProjectedPdf.html:9073,test,testArg,9073,root/html530/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html530/RooProjectedPdf.html,10,['test'],['testArg']
Testability,"ooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual voidRooResolutionModel::normLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAddModel.html:22210,test,testArg,22210,root/html528/RooAddModel.html,https://root.cern,https://root.cern/root/html528/RooAddModel.html,4,['test'],['testArg']
Testability,"ooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual voidRooResolutionModel::normLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAddModel.html:22354,test,testArg,22354,root/html530/RooAddModel.html,https://root.cern,https://root.cern/root/html530/RooAddModel.html,8,['test'],['testArg']
Testability,"ooProjectedPdf(const RooProjectedPdf& other, const char* name = 0); Copy constructor. Double_t getValV(const RooArgSet* set = 0) const; Special version of getVal() overrides RooAbsReal::getValF() to save value of current normalization set. Double_t evaluate() const; Evaluate projected p.d.f. const RooAbsReal* getProjection(const RooArgSet* iset, const RooArgSet* nset, const char* rangeName, int& code) const; Retrieve object representing projection integral of input p.d.f; over observables iset, while normalizing over observables; nset. The code argument returned by reference is the unique code; defining this particular projection configuration. RooAbsPdf* createProjection(const RooArgSet& iset); Special version of RooAbsReal::createProjection that deals with; projections of projections. Instead of integrating twice, a new; RooProjectedPdf is returned that is configured to perform the; complete integration in one step. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to relegate integration of all observables to internal logic. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Mark all requested variables as internally integrated. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integral represent by appropriate element of projection cache. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; No internal generator is implemented. void generateEvent(Int_t code); No internal generator is implemented. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t , Bool_t , Bool_t ); Intercept a server redirection all and update list of dependents if necessary; Specifically update the set proxy 'deps' which introduces the dependency; on server value dirty flags of ourselves. void printMetaArgs(ostream& os) const; Customized print",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooProjectedPdf.html:43799,log,logic,43799,root/html532/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html532/RooProjectedPdf.html,4,['log'],['logic']
Testability,"ooRealMPFE::applyNLLWeightSquared ; (; bool ; flag). Control verbose messaging related to inter process communication on both client and server side. ; Definition at line 725 of file RooRealMPFE.cxx. ◆ arg(). RooAbsReal & RooRealMPFE::arg ; (; ); const. inline . Definition at line 49 of file RooRealMPFE.h. ◆ calculate(). void RooRealMPFE::calculate ; (; ); const. Client-side function that instructs server process to start asynchronuous (re)calculation of function value. ; This function returns immediately. The calculated value can be retrieved using getVal() ; Definition at line 425 of file RooRealMPFE.cxx. ◆ clone(). TObject * RooRealMPFE::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 34 of file RooRealMPFE.h. ◆ constOptimizeTestStatistic(). void RooRealMPFE::constOptimizeTestStatistic ; (; ConstOpCode ; opcode, . bool ; doAlsoTracking = true . ). overrideprotectedvirtual . Intercept call to optimize constant term in test statistics and forward it to object on server side. ; Reimplemented from RooAbsArg.; Definition at line 681 of file RooRealMPFE.cxx. ◆ doApplyNLLW2(). void RooRealMPFE::doApplyNLLW2 ; (; bool ; flag). protected . Definition at line 741 of file RooRealMPFE.cxx. ◆ enableOffsetting(). void RooRealMPFE::enableOffsetting ; (; bool ; flag). overridevirtual . Control verbose messaging related to inter process communication on both client and server side. ; Reimplemented from RooAbsReal.; Definition at line 754 of file RooRealMPFE.cxx. ◆ evaluate(). double RooRealMPFE::evaluate ; (; ); const. overrideprotectedvirtual . Send message to server process to retrieve output value If error were logged use logEvalError() on remote side transfer those errors to the local eval error queue. ; Implements RooAbsReal.; Definition at line 558 of file RooRealMPFE.cxx. ◆ followAsSlave(). void RooRealMPFE::followAsSlave ; (; RooRealMPFE & ; master). inline . Definition at line 47 of file RooRealMPFE.h. ◆ getCarr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealMPFE.html:65635,test,test,65635,doc/master/classRooRealMPFE.html,https://root.cern,https://root.cern/doc/master/classRooRealMPFE.html,1,['test'],['test']
Testability,"ooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsCachedPdf&operator=(const RooAbsCachedPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCachedPdf.html:24159,test,testArg,24159,root/html602/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html,2,['test'],['testArg']
Testability,"ooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooChiSquarePdf&operator=(const RooChiSquarePdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooChiSquarePdf.html:23227,test,testArg,23227,root/html602/RooChiSquarePdf.html,https://root.cern,https://root.cern/root/html602/RooChiSquarePdf.html,2,['test'],['testArg']
Testability,"ooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooExtendedTerm&operator=(const RooExtendedTerm&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooExtendedTerm.html:23240,test,testArg,23240,root/html602/RooExtendedTerm.html,https://root.cern,https://root.cern/root/html602/RooExtendedTerm.html,2,['test'],['testArg']
Testability,"ooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooProjectedPdf&operator=(const RooProjectedPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProjectedPdf.html:23739,test,testArg,23739,root/html602/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html602/RooProjectedPdf.html,2,['test'],['testArg']
Testability,"ooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooSimultaneous&operator=(const RooSimultaneous&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSimultaneous.html:23758,test,testArg,23758,root/html602/RooSimultaneous.html,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html,2,['test'],['testArg']
Testability,"ooSpline() [1/4]. RooSpline::RooSpline ; (; ). default . ◆ RooSpline() [2/4]. RooSpline::RooSpline ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; x, . std::span< const double > ; x0, . std::span< const double > ; y0, . int ; order = 3, . bool ; logx = false, . bool ; logy = false . ). Constructor for creating a spline from raw data. ; Parameters. [in]nameThe name of the spline. ; [in]titleThe title of the spline. ; [in]xThe independent variable. ; [in]x0The array of x values for the spline points. ; [in]y0The array of y values for the spline points. ; [in]orderThe order of the spline (3 or 5). ; [in]logxIf true, the x values are logarithmically scaled before spline creation. ; [in]logyIf true, the y values are logarithmically scaled before spline creation. . Definition at line 74 of file RooSpline.cxx. ◆ RooSpline() [3/4]. RooSpline::RooSpline ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; x, . const TGraph & ; gr, . int ; order = 3, . bool ; logy = false, . bool ; logx = false . ). Constructor for creating a spline from a TGraph. ; Parameters. [in]nameThe name of the spline. ; [in]titleThe title of the spline. ; [in]xThe independent variable. ; [in]grThe input TGraph containing the data points. ; [in]orderThe order of the spline (3 or 5). ; [in]logxIf true, the x values are logarithmically scaled before spline creation. ; [in]logyIf true, the y values are logarithmically scaled before spline creation. . Definition at line 58 of file RooSpline.cxx. ◆ RooSpline() [4/4]. RooSpline::RooSpline ; (; const RooSpline & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Parameters. [in]otherThe RooSpline object to copy from. ; [in]nameThe name of the new RooSpline object (optional). . Definition at line 118 of file RooSpline.cxx. Member Function Documentation. ◆ Class(). static TClass * RooSpline::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooSpline::Class_Name ; (; )",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSpline.html:62605,log,logy,62605,doc/master/classRooSpline.html,https://root.cern,https://root.cern/doc/master/classRooSpline.html,1,['log'],['logy']
Testability,ooStats::HistFactory::EstimateSummary ; RooStats::HistFactory::FlexibleInterpVar flexible interpolation; RooStats::HistFactory::HistoToWorkspaceFactory ; RooStats::HistFactory::HistoToWorkspaceFactoryFast ; RooStats::HistFactory::LinInterpVar Piecewise linear interpolation; RooStats::HybridCalculator ; RooStats::HybridCalculatorOriginal Hypothesis test calculator using a Bayesian-frequentist hybrid method; RooStats::HybridPlot Provides the plots for an HybridResult; RooStats::HybridResult Class containing the results of the HybridCalculator; RooStats::HypoTestCalculator Interface for tools doing hypothesis tests; RooStats::HypoTestCalculatorGeneric ; RooStats::HypoTestInverter HypoTestInverter class; RooStats::HypoTestInverterOriginal HypoTestInverterOriginal class; RooStats::HypoTestInverterPlot HypoTestInverterPlot class; RooStats::HypoTestInverterResult HypoTestInverterResult class ; RooStats::HypoTestPlot ; RooStats::HypoTestResult Base class to represent results of a hypothesis test; RooStats::IntervalCalculator Interface for tools setting limits (producing confidence intervals); RooStats::LikelihoodInterval Concrete implementation of a ConfInterval based on a likelihood ratio; RooStats::LikelihoodIntervalPlot Class containing the results of the IntervalCalculator; RooStats::MCMCCalculator Markov Chain Monte Carlo calculator for Bayesian credible intervals; RooStats::MCMCInterval Concrete implementation of a ConfInterval based on MCMC calculation; RooStats::MCMCIntervalPlot Class containing the results of the MCMCCalculator; RooStats::MarkovChain ; RooStats::MaxLikelihoodEstimateTestStat ; RooStats::MetropolisHastings Markov Chain Monte Carlo calculator for Bayesian credible intervals; RooStats::ModelConfig A class that holds configuration information for a model using a workspace as a store; RooStats::NeymanConstruction Interface for tools setting limits (producing confidence intervals); RooStats::NumEventsTestStat ; RooStats::NumberCountingPdfFactory A factory,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ClassIndex.html:45351,test,test,45351,root/html530/ClassIndex.html,https://root.cern,https://root.cern/root/html530/ClassIndex.html,2,['test'],['test']
Testability,ooStats::HistFactory::HistoToWorkspaceFactory ; RooStats::HistFactory::HistoToWorkspaceFactoryFast ; RooStats::HistFactory::LinInterpVar Piecewise linear interpolation; RooStats::HistFactory::Measurement ; RooStats::HistFactory::NormFactor ; RooStats::HistFactory::OverallSys ; RooStats::HistFactory::PreprocessFunction ; RooStats::HistFactory::RooBarlowBeestonLL Real-valued function representing a Barlow-Beeston minimized profile likelihood of external (likelihood) function; RooStats::HistFactory::Sample ; RooStats::HistFactory::ShapeFactor ; RooStats::HistFactory::ShapeSys ; RooStats::HistFactory::StatError ; RooStats::HistFactory::StatErrorConfig ; RooStats::HybridCalculator ; RooStats::HybridCalculatorOriginal Hypothesis test calculator using a Bayesian-frequentist hybrid method; RooStats::HybridPlot Provides the plots for an HybridResult; RooStats::HybridResult Class containing the results of the HybridCalculator; RooStats::HypoTestCalculator Interface for tools doing hypothesis tests; RooStats::HypoTestCalculatorGeneric ; RooStats::HypoTestInverter HypoTestInverter class; RooStats::HypoTestInverterOriginal HypoTestInverterOriginal class; RooStats::HypoTestInverterPlot HypoTestInverterPlot class; RooStats::HypoTestInverterResult HypoTestInverterResult class ; RooStats::HypoTestPlot ; RooStats::HypoTestResult Base class to represent results of a hypothesis test; RooStats::IntervalCalculator Interface for tools setting limits (producing confidence intervals); RooStats::LikelihoodInterval Concrete implementation of a ConfInterval based on a likelihood ratio; RooStats::LikelihoodIntervalPlot Class containing the results of the IntervalCalculator; RooStats::MCMCCalculator Markov Chain Monte Carlo calculator for Bayesian credible intervals; RooStats::MCMCInterval Concrete implementation of a ConfInterval based on MCMC calculation; RooStats::MCMCIntervalPlot Class containing the results of the MCMCCalculator; RooStats::MarkovChain ; RooStats::MaxLikelihoodEstimateTestSt,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:47415,test,tests,47415,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,1,['test'],['tests']
Testability,"ooStats::SamplingDistribution* other); Merge SamplingDistributions (does nothing if NULL is given).; If variable name was not set before, it is copied from the added; SamplingDistribution. Double_t Integral(Double_t low, Double_t high, Bool_t normalize = kTRUE, Bool_t lowClosed = kTRUE, Bool_t highClosed = kFALSE) const; Returns the integral in the open/closed/mixed interval. Default is [low,high) interval.; Normalization can be turned off. void SortValues() const. Double_t IntegralAndError(Double_t& error, Double_t low, Double_t high, Bool_t normalize = kTRUE, Bool_t lowClosed = kTRUE, Bool_t highClosed = kFALSE) const; Returns the integral in the open/closed/mixed interval. Default is [low,high) interval.; Normalization can be turned off.; compute also the error on the integral. Double_t CDF(Double_t x) const; returns the closed integral [-inf,x]. Double_t InverseCDF(Double_t pvalue); returns the inverse of the cumulative distribution function. Double_t InverseCDF(Double_t pvalue, Double_t sigmaVariaton, Double_t& inverseVariation); returns the inverse of the cumulative distribution function, with variations depending on number of samples. Double_t InverseCDFInterpolate(Double_t pvalue); returns the inverse of the cumulative distribution function. SamplingDistribution(const char* name, const char* title, vector<Double_t>& samplingDist, const char* varName = 0); Constructor for SamplingDistribution. Int_t GetSize() const; size of samples. {return fSamplingDist.size();}. const std::vector<Double_t> & GetSamplingDistribution() const; Get test statistics values. {return fSamplingDist;}. const std::vector<Double_t> & GetSampleWeights() const; Get the sampling weights. {return fSampleWeights;}. const TString GetVarName() const; {return fVarName;}. » Last changed: root/roostats:$Id$ » Last generated: 2015-03-10 17:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__SamplingDistribution.html:10491,test,test,10491,root/html534/RooStats__SamplingDistribution.html,https://root.cern,https://root.cern/root/html534/RooStats__SamplingDistribution.html,1,['test'],['test']
Testability,"ooStats::SamplingDistribution* other); Merge SamplingDistributions (does nothing if NULL is given).; If variable name was not set before, it is copied from the added; SamplingDistribution. Double_t Integral(Double_t low, Double_t high, Bool_t normalize = kTRUE, Bool_t lowClosed = kTRUE, Bool_t highClosed = kFALSE) const; Returns the integral in the open/closed/mixed interval. Default is [low,high) interval.; Normalization can be turned off. void SortValues() const. Double_t IntegralAndError(Double_t& error, Double_t low, Double_t high, Bool_t normalize = kTRUE, Bool_t lowClosed = kTRUE, Bool_t highClosed = kFALSE) const; Returns the integral in the open/closed/mixed interval. Default is [low,high) interval.; Normalization can be turned off.; compute also the error on the integral. Double_t CDF(Double_t x) const; returns the closed integral [-inf,x]. Double_t InverseCDF(Double_t pvalue); returns the inverse of the cumulative distribution function. Double_t InverseCDF(Double_t pvalue, Double_t sigmaVariaton, Double_t& inverseVariation); returns the inverse of the cumulative distribution function, with variations depending on number of samples. Double_t InverseCDFInterpolate(Double_t pvalue); returns the inverse of the cumulative distribution function. SamplingDistribution(const char* name, const char* title, vector<Double_t>& samplingDist, const char* varName = 0); Constructor for SamplingDistribution. Int_t GetSize() const; size of samples. {return fSamplingDist.size();}. const std::vector<Double_t> & GetSamplingDistribution() const; Get test statistics values. {return fSamplingDist;}. const std::vector<Double_t> & GetSampleWeights() const; Get the sampling weights. {return fSampleWeights;}. const TString GetVarName() const; {return fVarName;}. » Last changed: root/roostats:$Id$ » Last generated: 2015-06-02 15:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooStats__SamplingDistribution.html:10950,test,test,10950,root/html604/RooStats__SamplingDistribution.html,https://root.cern,https://root.cern/root/html604/RooStats__SamplingDistribution.html,1,['test'],['test']
Testability,"ooStats::SamplingDistribution* other); Merge SamplingDistributions (does nothing if NULL is given).; If variable name was not set before, it is copied from the added; SamplingDistribution. Double_t Integral(Double_t low, Double_t high, Bool_t normalize = kTRUE, Bool_t lowClosed = kTRUE, Bool_t highClosed = kFALSE) const; Returns the integral in the open/closed/mixed interval. Default is [low,high) interval.; Normalization can be turned off. void SortValues() const. Double_t IntegralAndError(Double_t& error, Double_t low, Double_t high, Bool_t normalize = kTRUE, Bool_t lowClosed = kTRUE, Bool_t highClosed = kFALSE) const; Returns the integral in the open/closed/mixed interval. Default is [low,high) interval.; Normalization can be turned off.; compute also the error on the integral. Double_t CDF(Double_t x) const; returns the closed integral [-inf,x]. Double_t InverseCDF(Double_t pvalue); returns the inverse of the cumulative distribution function. Double_t InverseCDF(Double_t pvalue, Double_t sigmaVariaton, Double_t& inverseVariation); returns the inverse of the cumulative distribution function, with variations depending on number of samples. Double_t InverseCDFInterpolate(Double_t pvalue); returns the inverse of the cumulative distribution function. SamplingDistribution(const char* name, const char* title, vector<Double_t>& samplingDist, const char* varName = 0); Constructor for SamplingDistribution. Int_t GetSize() const; size of samples. {return fSamplingDist.size();}. const std::vector<Double_t> & GetSamplingDistribution() const; Get test statistics values. {return fSamplingDist;}. const std::vector<Double_t> & GetSampleWeights() const; Get the sampling weights. {return fSampleWeights;}. const TString GetVarName() const; {return fVarName;}. » Last changed: root/roostats:$Id$ » Last generated: 2015-06-30 14:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__SamplingDistribution.html:10950,test,test,10950,root/html602/RooStats__SamplingDistribution.html,https://root.cern,https://root.cern/root/html602/RooStats__SamplingDistribution.html,1,['test'],['test']
Testability,"oof (they have to call Init themselves and override StartSlaves appropriately). ; This constructor simply closes any previous gProof and sets gProof to this instance. ; Definition at line 513 of file TProof.cxx. ◆ TProof() [3/3]. TProof::TProof ; (; const char * ; masterurl, . const char * ; conffile = kPROOF_ConfFile, . const char * ; confdir = kPROOF_ConfDir, . Int_t ; loglevel = 0, . const char * ; alias = 0, . TProofMgr * ; mgr = 0 . ). Create a PROOF environment. ; Starting PROOF involves either connecting to a master server, which in turn will start a set of slave servers, or directly starting as master server (if master = """"). Masterurl is of the form: [proof[s]://]host[:port]. Conffile is the name of the config file describing the remote PROOF cluster (this argument alows you to describe different cluster configurations). The default is proof.conf. Confdir is the directory where the config file and other PROOF related files are (like motd and noproof files). Loglevel is the log level (default = 1). User specified custom config files will be first looked for in $HOME/.conffile. ; Definition at line 387 of file TProof.cxx. ◆ ~TProof(). TProof::~TProof ; (; ). override . Clean up PROOF environment. ; Definition at line 652 of file TProof.cxx. Member Function Documentation. ◆ Activate(). void TProof::Activate ; (; TList * ; slaves = 0). private . Activate slave server list. ; Definition at line 2389 of file TProof.cxx. ◆ ActivateAsyncInput(). void TProof::ActivateAsyncInput ; (; ). private . Activate the a-sync input handler. ; Definition at line 4410 of file TProof.cxx. ◆ ActivateWorker(). Int_t TProof::ActivateWorker ; (; const char * ; ord, . Bool_t ; save = kTRUE . ). Make sure that the worker identified by the ordinal number 'ord' is in the active list. ; The request will be forwarded to the master in direct contact with the worker. If needed, this master will move the worker from the inactive to the active list and rebuild the list of unique workers. Use or",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:61192,log,log,61192,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['log'],['log']
Testability,"oofEventProc.CSelector to process trees containing Event structures ;  ProofEventProc.hSelector to process trees containing Event structures ;  ProofFriends.CSelector to process tree friends ;  ProofFriends.hSelector to process tree friends ;  ProofNtuple.CSelector to fill a simple ntuple ;  ProofNtuple.hSelector to fill a simple ntuple ;  ProofPythia.CSelector to generate Monte Carlo events with Pythia8 ;  ProofPythia.hSelector to generate Monte Carlo events with Pythia8 ;  ProofSimple.CSelector to fill a set of histograms ;  ProofSimple.hSelector to fill a set of histograms ;  ProofSimpleFile.CSelector to fill a set of histograms and merging via file ;  ProofSimpleFile.hSelector to fill a set of histograms and merging via file ;  ProofStdVect.CSelector for generic processing with stdlib collections ;  ProofStdVect.hSelector for generic processing with stdlib collections ;  ProofTests.CAuxilliary selector used to test PROOF functionality ;  ProofTests.hAuxilliary selector used to test PROOF functionality ;  runProof.CMacro to run examples of analysis on PROOF, corresponding to the TSelector implementations found under <ROOTSYS>/tutorials/proof ;  ► pyroot;  benchmarks.pyRun benchmarks macros ;  demo.pyTo run, do an ""execfile( '<path-to>/demo.py' )"" or ""python <path-to>/demo.py"" ;  demoshelp.py Display demo help ;  DynamicSlice.py Example of function called when a mouse event occurs in a pad ;  fildir.py This macro displays the ROOT Directory data structure ;  file.py This macro displays the physical ROOT file structure ;  fillrandom.py FillRandom example ;  first.py My first PyROOT interactive session ;  fit1.py Fit example ;  fit1_py.py;  formula1.py TF1 example ;  framework.py The ROOT Framework ;  geometry.py Geometry ;  gerrors.py A Simple Graph with error bars ;  graph.py A Simple Graph Example ;  gui_ex.pyA Simple GUI Example ;  h1draw.py A Simple histogram drawing example ;  hsimple.py This program creates : ;  hsum.py Simple example illustrating how to use ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:137185,test,test,137185,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,5,['test'],['test']
Testability,"oofMgr*TProof::fManagermanager to which this session belongs (if any); Bool_tTProof::fMasterServtrue if we are a master server; TStringTNamed::fNameobject identifier; Int_tTProof::fProtocolremote PROOF server protocol version number; TProof::EQueryModeTProof::fQueryModedefault query mode; TList*TProof::fRunningDSetsTemporary datasets used for async running; TSelector*TProof::fSelectorSelector to be processed, if any; TProofMgr::EServTypeTProof::fServTypetype of server: proofd, XrdProofd; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TList*TProof::fSlaveslist of all slave servers as in config file; TList*TProof::fTerminatedSlaveInfoslist of unique infos of terminated slaves; TStringTNamed::fTitleobject title; Long64_tTProof::fTotalBytesnumber of bytes to be analyzed; TUrlTProof::fUrlUrl of the master; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TSemaphore*TProof::fgSemaphoresemaphore to control no of parallel startup threads. private:. TCondor*fCondorproxy for our Condor pool; TTimer*fTimertimer for delayed Condor COD suspend. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofCondor(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); Start proof using condor. ~TProofCondor(); Clean up Condor PROOF environment. Bool_t StartSlaves(Bool_t ); Setup Condor workers using dynamic information. void SetActive(Bool_t active); Suspend or resume PROOF via Condor. TString GetJobAd(); Get job Ad. void SetActive(); { TProof::SetActive(); }. » Author: Fons Rademakers 13/02/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-03-14 16:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofCondor.html:26817,log,loglevel,26817,root/html534/TProofCondor.html,https://root.cern,https://root.cern/root/html534/TProofCondor.html,1,['log'],['loglevel']
Testability,"ook(RooArgSet*, double) const. private:. RooStats::SamplingDistribution*GenerateSamplingDistribution(RooStats::ModelConfig* thisModel, double obsTestStat, RooAbsPdf* impDens = NULL, const RooArgSet* impSnapshot = NULL) const; voidSetAdaptiveLimits(Double_t obsTestStat, Bool_t forNull) const; voidSetupSampler(const RooStats::ModelConfig& model) const. Data Members; protected:. const RooStats::ModelConfig*fAltModel; unsigned intfAltToysSeedto have same toys for alternate ; const RooAbsData*fData; RooStats::TestStatSampler*fDefaultSampler; RooStats::TestStatistic*fDefaultTestStat; const RooStats::ModelConfig*fNullModel; RooStats::TestStatSampler*fTestStatSampler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; HypoTestCalculatorGeneric(const RooAbsData& data, const RooStats::ModelConfig& altModel, const RooStats::ModelConfig& nullModel, RooStats::TestStatSampler* sampler = 0); Constructor. When test stat sampler is not provided; uses ToyMCSampler and RatioOfProfiledLikelihoodsTestStat; and nToys = 1000.; User can : GetTestStatSampler()->SetNToys( # ). void SetupSampler(const RooStats::ModelConfig& model) const; common setup for both models. ~HypoTestCalculatorGeneric(). HypoTestResult* GetHypoTest() const. void UseSameAltToys(); to re-use same toys for alternate hypothesis. HypoTestCalculatorGeneric(const RooAbsData& data, const RooStats::ModelConfig& altModel, const RooStats::ModelConfig& nullModel, RooStats::TestStatSampler* sampler = 0). void SetNullModel(const RooStats::ModelConfig& nullModel); set the model for the null hypothesis (only B). { fNullModel = &nullModel; }. const RooAbsData * GetData(void); { return fData; }. const ModelConfig* GetNullModel(void); { return fNullModel; }. const RooArgSet* GetFitInfo() const; set the model for the alternate hypothesis (S+B). { return NULL; }. void SetAlternateModel(const RooStats::ModelConfig& altModel); { fAltModel = &altModel; }. const ModelConfig* GetAlternateModel(void); Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HypoTestCalculatorGeneric.html:2771,test,test,2771,root/html534/RooStats__HypoTestCalculatorGeneric.html,https://root.cern,https://root.cern/root/html534/RooStats__HypoTestCalculatorGeneric.html,1,['test'],['test']
Testability,"ool(DescriptorId_t, DescriptorId_t)> & ; comparator . ); const. Definition at line 1165 of file RNTupleDescriptor.cxx. ◆ GetFieldIterable() [3/4]. ROOT::Experimental::RNTupleDescriptor::RFieldDescriptorIterable ROOT::Experimental::RNTupleDescriptor::GetFieldIterable ; (; DescriptorId_t ; fieldId); const. Definition at line 1172 of file RNTupleDescriptor.cxx. ◆ GetFieldIterable() [4/4]. ROOT::Experimental::RNTupleDescriptor::RFieldDescriptorIterable ROOT::Experimental::RNTupleDescriptor::GetFieldIterable ; (; DescriptorId_t ; fieldId, . const std::function< bool(DescriptorId_t, DescriptorId_t)> & ; comparator . ); const. Definition at line 1177 of file RNTupleDescriptor.cxx. ◆ GetFieldZero(). const RFieldDescriptor & ROOT::Experimental::RNTupleDescriptor::GetFieldZero ; (; ); const. inline . Definition at line 660 of file RNTupleDescriptor.hxx. ◆ GetFieldZeroId(). DescriptorId_t ROOT::Experimental::RNTupleDescriptor::GetFieldZeroId ; (; ); const. inline . Returns the logical parent of all top-level NTuple data fields. ; Definition at line 659 of file RNTupleDescriptor.hxx. ◆ GetGeneration(). std::uint64_t ROOT::Experimental::RNTupleDescriptor::GetGeneration ; (; ); const. inline . Definition at line 686 of file RNTupleDescriptor.hxx. ◆ GetHeaderExtension(). const RHeaderExtension * ROOT::Experimental::RNTupleDescriptor::GetHeaderExtension ; (; ); const. inline . Return header extension information; if the descriptor does not have a header extension, return nullptr ; Definition at line 680 of file RNTupleDescriptor.hxx. ◆ GetNActiveClusters(). std::size_t ROOT::Experimental::RNTupleDescriptor::GetNActiveClusters ; (; ); const. inline . Definition at line 651 of file RNTupleDescriptor.hxx. ◆ GetName(). const std::string & ROOT::Experimental::RNTupleDescriptor::GetName ; (; ); const. inline . Definition at line 643 of file RNTupleDescriptor.hxx. ◆ GetNClusterGroups(). std::size_t ROOT::Experimental::RNTupleDescriptor::GetNClusterGroups ; (; ); const. inline . Definition",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleDescriptor.html:15827,log,logical,15827,doc/master/classROOT_1_1Experimental_1_1RNTupleDescriptor.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleDescriptor.html,1,['log'],['logical']
Testability,"ool=kFALSE);  Set up packages, loaded macros, include and lib paths ... ;  ; virtual Bool_t StartSlaves (Bool_t attach=kFALSE);  Start up PROOF slaves. ;  ; void UpdateDialog ();  Final update of the progress dialog. ;  ; virtual void ValidateDSet (TDSet *dset);  Validate a TDSet. ;  ; Int_t VerifyDataSetParallel (const char *uri, const char *optStr);  Internal function for parallel dataset verification used TProof::VerifyDataSet and TProofLite::VerifyDataSet. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual void * GetSender ();  ; virtual const char * GetSenderClassName () const;  . Private Member Functions;  TProofLite (const TProofLite &);  ; Int_t CleanupSandbox ();  Remove old sessions dirs keep at most 'Proof.MaxOldSessions' (default 10) ;  ; Int_t CreateSandbox ();  Create the sandbox for this session. ;  ; void FindUniqueSlaves () override;  Add to the fUniqueSlave list the active slaves that have a unique (user) file system image. ;  ; Int_t InitDataSetManager ();  Initialize the dataset manager from directives or from defaults Return 0 on success, -1 on failure. ;  ; void NotifyStartUp (const char *action, Int_t done, Int_t tot);  Notify setting-up operation message. ;  ; void operator= (const TProofLite &);  ; void ResolveKeywords (TString &s, const char *ord, const char *logfile);  Resolve some keywords in 's' <logfilewrk>, <user>, <rootsys>, <cpupin> ;  ; void SendInputDataFile () override;  Make sure that the input data objects are available to the workers in a dedicated file in the cache; the objects are taken from the dedicated list and / or the specified file. ;  ; Int_t SetProofServEnv (const char *ord);  Create environment files for worker 'ord'. ;  ; void ShowDataDir (const char *dirname);  List contents of the data directo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:39808,sandbox,sandbox,39808,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['sandbox'],['sandbox']
Testability,"ool_t ComputeCdfTable(Option_t *opt)Compute the cumulative function at fNpx points between fXmin and fXmax.Definition TF1.cxx:2081; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:677; TF1::EvalParTemplT EvalParTempl(const T *data, const Double_t *params=nullptr)Eval for vectorized functions.Definition TF1.h:844; TF1::DrawIntegralvirtual TObject * DrawIntegral(Option_t *option=""al"")Draw integral of this function.Definition TF1.cxx:1407; TF1::fIntegralstd::vector< Double_t > fIntegral! Integral of function binned on fNpx binsDefinition TF1.h:278; TF1::DrawDerivativevirtual TObject * DrawDerivative(Option_t *option=""al"")Draw derivative of this function.Definition TF1.cxx:1385; TF1::Evalvirtual Double_t Eval(Double_t x, Double_t y=0, Double_t z=0, Double_t t=0) constEvaluate this function.Definition TF1.cxx:1439; TF1::GetMaximumvirtual Double_t GetMaximum(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the maximum value of the function.Definition TF1.cxx:1614; TF1::fParamsstd::unique_ptr< TF1Parameters > fParamsPointer to Function parameters object (exists only for not-formula functions)Definition TF1.h:289; TF1::SetParametervirtual void SetParameter(const TString &name, Double_t value)Definition TF1.h:672; TF1::SetParametervirtual void SetParameter(Int_t param, Double_t value)Definition TF1.h:667; TF1::Derivative3virtual Double_t Derivative3(Double_t x, Double_t *params=nullptr, Double_t epsilon=0.001) constReturns the third derivative of the function at point x, computed by Richardson's extrapolation metho...Definition TF1.cxx:1243; TF1::Savevirtual void Save(Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Double_t zmin, Double_t zmax)Save values of function in array fSave.Definition TF1.cxx:3161; TF1::CloneTObject * Clone(const char *newname=nullptr) const overrideMake a complete copy of the underlying object.Definition TF1.cxx:1064; TF1::EFTypeEFTypeDefinit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8h_source.html:65749,log,logx,65749,doc/master/TF1_8h_source.html,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html,1,['log'],['logx']
Testability,"ool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual voidnormLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooResolutionModel.html:24408,test,testArg,24408,root/html532/RooResolutionModel.html,https://root.cern,https://root.cern/root/html532/RooResolutionModel.html,1,['test'],['testArg']
Testability,"ool_t localFile = kFALSE;; 4838 TUrl url(name);; 4839 //; 4840 // Check whether we should try to optimize for local files; 4841 Bool_t forceRemote = gEnv->GetValue(""Path.ForceRemote"", 0);; 4842 forceRemote = (forceRemote) ? kTRUE : gEnv->GetValue(""TFile.ForceRemote"", 0);; 4843 TString opts = url.GetOptions();; 4844 if (opts.Contains(""remote=1"")); 4845 forceRemote = kTRUE;; 4846 else if (opts.Contains(""remote=0"")); 4847 forceRemote = kFALSE;; 4848 if (!forceRemote) {; 4849 // Generic locality test; 4850 localFile = gSystem->IsPathLocal(name);; 4851 if (localFile) {; 4852 // Local path including the prefix; 4853 const char *fname = url.GetFileAndOptions();; 4854 TString lfname;; 4855 if (fname[0] == '/') {; 4856 if (prefix); 4857 lfname.Form(""%s%s"", prefix->Data(), fname);; 4858 else; 4859 lfname = fname;; 4860 } else if (fname[0] == '~' || fname[0] == '$') {; 4861 lfname = fname;; 4862 } else {; 4863 lfname.Form(""%s/%s"", gSystem->HomeDirectory(), fname);; 4864 }; 4865 // If option ""READ"" test existence and access; 4866 TString opt = option;; 4867 Bool_t read = (opt.IsNull() ||; 4868 !opt.CompareTo(""READ"", TString::kIgnoreCase)) ? kTRUE : kFALSE;; 4869 if (read) {; 4870 TString fn = TUrl(lfname).GetFile();; 4871 if (!gSystem->ExpandPathName(fn)) {; 4872 if (gSystem->AccessPathName(fn, kReadPermission)); 4873 localFile = kFALSE;; 4874 }; 4875 }; 4876 // Return full local path if requested (and if the case); 4877 if (localFile && prefix); 4878 *prefix = lfname;; 4879 }; 4880 }; 4881 //; 4882 // Adjust the type according to findings; 4883 type = (localFile) ? kLocal : type;; 4884 } else if (TPMERegexp(""^(http[s]?|s3http[s]?|[a]?s3|gs|gshttp[s]?){1}:"", ""i"").Match(name)) {; 4885 //; 4886 // Web file; 4887 type = kWeb;; 4888 } else if (!strncmp(name, ""file:"", 5)) {; 4889 //; 4890 // 'file' protocol; 4891 type = kFile;; 4892 }; 4893 // We are done; 4894 return type;; 4895}; 4896 ; 4897////////////////////////////////////////////////////////////////////////////////; 4898/// Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:178305,test,test,178305,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['test'],['test']
Testability,"ool_t python_owns = kFALSE); TPython&operator=(const TPython&); static voidPrompt(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TPython(); TPython(const TPython&). private:. static Bool_tInitialize(). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t Initialize(); Private initialization method: setup the python interpreter and load the; ROOT module. Bool_t Import(const char* name); Import the named python module and create Cling equivalents for its classes; and methods. void LoadMacro(const char* name); Execute the give python script as if it were a macro (effectively an; execfile in __main__), and create Cling equivalents for any newly available; python classes. void ExecScript(const char* name, int argc = 0, const char** argv = 0); Execute a python stand-alone script, with argv CLI arguments. example of use:; const char* argv[] = { ""1"", ""2"", ""3"" };; TPython::ExecScript( ""test.py"", sizeof(argv)/sizeof(argv[0]), argv );. Bool_t Exec(const char* cmd); Execute a python statement (e.g. ""import ROOT""). const TPyReturn Eval(const char* expr); Evaluate a python expression (e.g. ""ROOT.TBrowser()""). Caution: do not hold on to the return value: either store it in a builtin; type (implicit casting will work), or in a pointer to a ROOT object (explicit; casting to a void* is required). Bool_t Bind(TObject* object, const char* label); Bind a ROOT object with, at the python side, the name ""label"". void Prompt(); Enter an interactive python session (exit with ^D). State is preserved; between successive calls. Bool_t ObjectProxy_Check(PyObject* pyobject); Test whether the type of the given pyobject is of ObjectProxy type or any; derived type. Bool_t ObjectProxy_CheckExact(PyObject* pyobject); Test whether the type of the given pyobject is ObjectProxy type. Bool_t MethodProxy_Check(PyObject* pyobject); Test whether the type of the g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TPython.html:4013,test,test,4013,root/html604/TPython.html,https://root.cern,https://root.cern/root/html604/TPython.html,1,['test'],['test']
Testability,"ool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction1PdfBinding<double,double>&operator=(const RooCFunction1PdfBinding<double,double>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction1PdfBinding_double_double_.html:23716,test,testArg,23716,root/html602/RooCFunction1PdfBinding_double_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction1PdfBinding_double_double_.html,2,['test'],['testArg']
Testability,"ool_t*fFixAmpX1[fNPeaks] array of logical values which allow to fix appropriate amplitudes of 1D ridges in x direction (not fit). However they are present in the estimated functional; Bool_t*fFixAmpY1[fNPeaks] array of logical values which allow to fix appropriate amplitudes of 1D ridges in y direction (not fit). However they are present in the estimated functional; Bool_tfFixAxlogical value of ax parameter, which allows to fix the parameter (not to fit).; Bool_tfFixAylogical value of ay parameter, which allows to fix the parameter (not to fit).; Bool_tfFixBxlogical value of b parameter for 1D ridges in x direction, which allows to fix the parameter (not to fit).; Bool_tfFixBylogical value of b parameter for 1D ridges in y direction, which allows to fix the parameter (not to fit).; Bool_t*fFixPositionX[fNPeaks] array of logical values which allow to fix appropriate x positions of 2D peaks (not fit). However they are present in the estimated functional; Bool_t*fFixPositionX1[fNPeaks] array of logical values which allow to fix appropriate x positions of 1D ridges (not fit). However they are present in the estimated functional; Bool_t*fFixPositionY[fNPeaks] array of logical values which allow to fix appropriate y positions of 2D peaks (not fit). However they are present in the estimated functional; Bool_t*fFixPositionY1[fNPeaks] array of logical values which allow to fix appropriate y positions of 1D ridges (not fit). However they are present in the estimated functional; Bool_tfFixRological value of correlation coefficient, which allows to fix the parameter (not to fit).; Bool_tfFixSigmaXlogical value of sigma x parameter, which allows to fix the parameter (not to fit).; Bool_tfFixSigmaYlogical value of sigma y parameter, which allows to fix the parameter (not to fit).; Bool_tfFixSxlogical value of s parameter for 1D ridges in x direction, which allows to fix the parameter (not to fit).; Bool_tfFixSxylogical value of s parameter for 2D peaks, which allows to fix the pa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2Fit.html:16098,log,logical,16098,root/html528/TSpectrum2Fit.html,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html,6,['log'],['logical']
Testability,"ool_tRooAbsArg::isDerived() const; virtual Bool_tRooAbsPdf::isDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidLoadDataSet(RooDataSet& data); voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooKeysPdf.html:20419,log,logEvalError,20419,root/html532/RooKeysPdf.html,https://root.cern,https://root.cern/root/html532/RooKeysPdf.html,1,['log'],['logEvalError']
Testability,"ool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); RooArgSetparameters() const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooChangeTracker.html:20186,test,testArg,20186,root/html534/RooChangeTracker.html,https://root.cern,https://root.cern/root/html534/RooChangeTracker.html,1,['test'],['testArg']
Testability,"ool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tnumEvalErrorItems(); static Int_tnumEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_toperator==(Double_t value) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsReal.html:17758,test,testArg,17758,root/html530/RooAbsReal.html,https://root.cern,https://root.cern/root/html530/RooAbsReal.html,2,['test'],['testArg']
Testability,"ool_t���; fFixTx;������������������������ //logical value of t parameter for 1D ridges in; x direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixTy;������������������������ //logical value of t parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSx;������������������������ //logical value of s parameter for 1D ridges in; x direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSy;������������������������ //logical value of s parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t��� fFixBx;�� ����������������������//logical; value of b parameter for 1D ridges in x direction, which allows to fix the; parameter (not to fit).; �� Bool_t���; fFixBy;������������������������ //logical value of b parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixA0;������������������������ //logical value of a0 parameter, which allows; to fix the parameter (not to fit).; �� Bool_t���; fFixAx;������������������������ //logical value of ax parameter, which allows; to fix the parameter (not to fit).; �� Bool_t���; fFixAy;������������������������ //logical value of ay parameter, which allows; to fix the parameter (not to fit).; �; References:; [1] Phillps G.W., Marlow K.W.,; NIM 137 (1976) 525.; [2] I. A. Slavic: Nonlinear; least-squares fitting without matrix inversion applied to complex Gaussian; spectra analysis. NIM 134 (1976) 285-289.; [3] T. Awaya: A new method for; curve fitting to the data with low statistics not using chi-square method. NIM; 165 (1979) 317-323.; [4] T. Hauschild, M. Jentschel:; Comparison of maximum likelihood estimation and chi-square statistics applied; to counting experiments. NIM A 457 (2001) 384-401.; �[5]� M. Morh�č,� J.; Kliman,� M. Jandel,� Ľ. Krupa, V. Matou�ek: Study of fitting algorithms; applied to simultaneous analysis of large number of peaks in -ray s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2Fit.html:50433,log,logical,50433,root/html528/TSpectrum2Fit.html,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html,6,['log'],['logical']
Testability,"ooleans, or via the prompt command, for example: root -l TMVARegression.C\‍(\""LD,MLP\""\‍); (note that the backslashes are mandatory) If no method given, a default set is used.; The output file ""TMVAReg.root"" can be analysed with the use of dedicated macros (simply say: root -l <macro.C>), which can be conveniently invoked through a GUI that will appear at the end of the run of this macro.; Project : TMVA - a Root-integrated toolkit for multivariate data analysis; Package : TMVA; Root Macro: TMVARegression. ; ; ==> Start TMVARegression; --- TMVARegression : Using input file: ./files/tmva_reg_example.root; DataSetInfo : [datasetreg] : Added class ""Regression""; : Add Tree TreeR of type Regression with 10000 events; : Dataset[datasetreg] : Class index : 0 name : Regression; Factory : Booking method: ␛[1mPDEFoam␛[0m; : ; : Rebuilding Dataset datasetreg; : Building event vectors for type 2 Regression; : Dataset[datasetreg] : create input formulas for tree TreeR; DataSetFactory : [datasetreg] : Number of events in input trees; : ; : Number of training and testing events; : ---------------------------------------------------------------------------; : Regression -- training events : 1000; : Regression -- testing events : 9000; : Regression -- training and testing events: 10000; : ; DataSetInfo : Correlation matrix (Regression):; : ------------------------; : var1 var2; : var1: +1.000 +0.006; : var2: +0.006 +1.000; : ------------------------; DataSetFactory : [datasetreg] : ; : ; Factory : Booking method: ␛[1mKNN␛[0m; : ; Factory : Booking method: ␛[1mLD␛[0m; : ; Factory : Booking method: ␛[1mDNN_CPU␛[0m; : ; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=SUMOFSQUARES:VarTransform=G:WeightInitialization=XAVIERUNIFORM:Architecture=CPU:Layout=TANH|50,TANH|50,TANH|50,LINEAR:TrainingStrategy=LearningRate=1e-3,Momentum=0.3,ConvergenceSteps=20,BatchSize=50,TestRepetitions=1,WeightDecay=0.0,Regularization=None,Optimizer=Adam""; : The following options are set:; : - By User:; : ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:1551,test,testing,1551,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,3,['test'],['testing']
Testability,"oolfSaveBeltToFilecontrols use if ConfidenceBelt should be saved to a TFile; Double_tfSizesize of the test (eg. specified rate of Type I error); RooStats::ToyMCSampler*fTestStatSamplerthe test statistic sampler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FeldmanCousins(); default constructor; fWS = new RooWorkspace(""FeldmanCousinsWS"");; fOwnsWorkspace = true;; fDataName = """";; fPdfName = """";. ~FeldmanCousins(); destructor; if(fOwnsWorkspace && fWS) delete fWS;. void SetModel(const RooStats::ModelConfig& ); set the model. void CreateTestStatSampler() const; specify the Test Statistic and create a ToyMC test statistic sampler. void CreateParameterPoints() const; specify the parameter points to perform the construction.; allow ability to profile on some nuisance paramters. ConfInterval* GetInterval() const; Main interface to get a RooStats::ConfInterval.; It constructs a RooStats::PointSetInterval. FeldmanCousins(). Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void SetData(RooAbsData& data); Set the DataSet. { fData = &data; }. void SetPdf(RooAbsPdf& pdf); Set the Pdf. { fPdf = &pdf; }. void SetParameters(const RooArgSet& set); specify the parameters of interest in the interval. { fPOI.removeAll(); fPOI.add(set); }. void SetNuisanceParameters(const RooArgSet& set); specify the nuisance parameters (eg. the rest of the parameters). {fNuisParams.removeAll(); fNuisParams.add(set);}. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size;}. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. RooAbsData* GetPointsToScan(). ConfidenceBelt* GetConfidenceBelt(); {return fConfBelt;}. void UseAdaptiveSampling(bool flag = true);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__FeldmanCousins.html:9271,test,test,9271,root/html526/RooStats__FeldmanCousins.html,https://root.cern,https://root.cern/root/html526/RooStats__FeldmanCousins.html,1,['test'],['test']
Testability,"oordError );; 369 // for coordinate error we store the error and not the inverse; 370 return 1.0 / fDataErrorPtr[ ipoint ];; 371 }; 372 ; 373 ; 374 /**; 375 retrieve at the same time a pointer to the coordinate data and the fit value; 376 More efficient than calling Coords(i) and Value(i); 377 */; 378 // not threadsafe, to be replaced with never constructs!; 379 // for example: just return std::array or std::vector, there's; 380 // is going to be only minor overhead in c++11.; 381 const double * GetPoint( unsigned int ipoint, double & value ) const; 382 {; 383 assert( ipoint < fMaxPoints );; 384 value = Value( ipoint );; 385 ; 386 return Coords( ipoint );; 387 }; 388 ; 389 /**; 390 returns a single coordinate error component of a point.; 391 This function is threadsafe in contrast to Coords(...); 392 and can easily get vectorized by the compiler in loops; 393 running over the ipoint-index.; 394 */; 395 double GetCoordErrorComponent( unsigned int ipoint, unsigned int icoord ) const; 396 {; 397 assert( ipoint < fMaxPoints );; 398 assert( icoord < fDim );; 399 assert( fCoordErrorsPtr.size() == fDim );; 400 assert( fCoordErrorsPtr[icoord] );; 401 assert( fCoordErrors.empty() || &fCoordErrors[icoord].front() == fCoordErrorsPtr[icoord] );; 402 ; 403 return fCoordErrorsPtr[icoord][ipoint];; 404 }; 405 ; 406 /**; 407 Return a pointer to the errors in the coordinates for the given fit point; 408 */; 409 // not threadsafe, to be replaced with never constructs!; 410 // for example: just return std::array or std::vector, there's; 411 // is going to be only minor overhead in c++11.; 412 const double* CoordErrors( unsigned int ipoint ) const; 413 {; 414 assert( ipoint < fMaxPoints );; 415 assert( fpTmpCoordErrorVector );; 416 assert( fErrorType == kCoordError || fErrorType == kAsymError );; 417 ; 418 for ( unsigned int i=0; i < fDim; i++ ); 419 {; 420 assert( fCoordErrorsPtr[i] );; 421 assert( fCoordErrors.empty() || &fCoordErrors[i].front() == fCoordErrorsPtr[i] );; 422 ; 423 fp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8h_source.html:13931,assert,assert,13931,doc/master/BinData_8h_source.html,https://root.cern,https://root.cern/doc/master/BinData_8h_source.html,3,['assert'],['assert']
Testability,"oordErrorsPtr[i][ipoint];; 424 }; 425 ; 426 return fpTmpCoordErrorVector;; 427 }; 428 ; 429 ; 430 /**; 431 retrieve in a single call a pointer to the coordinate data, value and inverse error for; 432 the given fit point.; 433 To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; 434 for the error.; 435 */; 436 // not threadsafe, to be replaced with never constructs!; 437 // for example: just return std::array or std::vector, there's; 438 // is going to be only minor overhead in c++11.; 439 const double* GetPoint( unsigned int ipoint, double & value, double & invError ) const; 440 {; 441 assert( ipoint < fMaxPoints );; 442 assert( fErrorType == kNoError || fErrorType == kValueError );; 443 ; 444 double e = Error( ipoint );; 445 ; 446 if (fWrapped); 447 invError = e;; 448 else; 449 invError = ( e != 0.0 ) ? 1.0/e : 1.0;; 450 ; 451 return GetPoint( ipoint, value );; 452 }; 453 ; 454 /**; 455 Retrieve the errors on the point (coordinate and value) for the given fit point; 456 It must be called only when the coordinate errors are stored otherwise it will produce an; 457 assert.; 458 */; 459 // not threadsafe, to be replaced with never constructs!; 460 // for example: just return std::array or std::vector, there's; 461 // is going to be only minor overhead in c++11.; 462 const double* GetPointError(unsigned int ipoint, double & errvalue) const; 463 {; 464 assert( ipoint < fMaxPoints );; 465 assert( fErrorType == kCoordError || fErrorType == kAsymError );; 466 ; 467 errvalue = Error( ipoint );; 468 return CoordErrors( ipoint );; 469 }; 470 ; 471 /**; 472 Get errors on the point (coordinate errors and asymmetric value errors) for the; 473 given fit point.; 474 It must be called only when the coordinate errors and asymmetric errors are stored; 475 otherwise it will produce an assert.; 476 */; 477 // not threadsafe, to be replaced with never constructs!; 478 // for example: just return std::array or std::vector, there's; 479 // is goi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8h_source.html:16074,assert,assert,16074,doc/master/BinData_8h_source.html,https://root.cern,https://root.cern/doc/master/BinData_8h_source.html,1,['assert'],['assert']
Testability,"oordinates); // Side effect: Active bin is now `index`.; coordinates are now passed into calcTreeIndex without side effects:; // In a subclass:; auto index = calcTreeIndex(externalCoordinates, fast=<true/false>); // No side effect. // From the outside:; auto index = dataHist.getIndex(externalCoordinates); // No side effect; This will allow for marking more functions const, or for lying less about const correctness. RooDataHist now supports fits with RooFit’s faster BatchMode().; Lower memory footprint. If weight errors are not needed, RooDataHist now allocates only 40% of the memory that the old implementation used. Fix bin volume correction logic in RooDataHist::sum(); The public member function RooDataHist::sum() has three overloads. Two of these overloads accept a sumSet parameter to not sum over all variables. These two overloads previously behaved inconsistently when the correctForBinSize or inverseBinCor flags were set. If you use the RooDataHist::sum() function in you own classes, please check that it can still be used with its new logic. The new and corrected bin correction behaviour is:. correctForBinSize: multiply counts in each bin by the bin volume corresponding to the variables in sumSet; inverseBinCor: divide counts in each bin by the bin volume corresponding to the variables not in sumSet. New fully parametrised Crystal Ball shape class; So far, the Crystal Ball distribution has been represented in RooFit only by the RooCBShape class, which has a Gaussian core and a single power-law tail on one side. This release introduces RooCrystalBall, which implements some common generalizations of the Crystal Ball shape:. symmetric or asymmetric power-law tails on both sides; different width parameters for the left and right sides of the Gaussian core. The new RooCrystalBall class can substitute the RooDSCBShape and RooSDSCBShape, which were passed around in the community.; 2D Graphics Libraries. Add the method AddPointto TGraph(x,y) and TGraph2D(x,y,z), equival",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:25156,log,logic,25156,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['log'],['logic']
Testability,"oot file. Returns the list of the distributions; for each point. ConfInterval* GetIntervalUsingList() const; Main interface to get a RooStats::ConfInterval.; It constructs a RooStats::PointSetInterval. ConfInterval* GetInterval(const char* asciiFilePat) const; This method returns a confidence interval exactly like GetInterval(), but; instead of generating the sampling disribution (long computation) it takes; the distribution from the file provided. ConfInterval* Run(TList* SamplingList) const; Main method to perform the interval calculation. NeymanConstruction(). void SetTestStatSampler(RooStats::TestStatSampler& distCreator); in addition to interface we also need:; Set the TestStatSampler (eg. ToyMC or FFT, includes choice of TestStatistic). {fTestStatSampler = &distCreator;}. void SetLeftSideTailFraction(Double_t leftSideFraction = 0.); fLeftSideTailFraction*fSize defines lower edge of acceptance region.; Unified limits use 0, central limits use 0.5,; for upper/lower limits it is 0/1 depends on sign of test statistic w.r.t. parameter. {fLeftSideFraction = leftSideFraction;}. void SetParameterPointsToTest(RooAbsData& pointsToTest); User-defined set of points to test. Double_t Size() const; This class can make regularly spaced scans based on range stored in RooRealVars.; Choose number of steps for a rastor scan (common for each dimension); void SetNumSteps(Int_t);; This class can make regularly spaced scans based on range stored in RooRealVars.; Choose number of steps for a rastor scan (specific for each dimension); void SetNumSteps(map<RooAbsArg, Int_t>); Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void SetData(RooAbsData& data); Set the DataSet. { fData = &data; }. void SetPdf(RooAbsPdf& pdf); Set the Pdf, add to the the workspace if not already there. { 	fPdf = &pdf; }. void SetParameters(const RooArgSet& set); specify the parameters of interest i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__NeymanConstruction.html:11025,test,test,11025,root/html526/RooStats__NeymanConstruction.html,https://root.cern,https://root.cern/root/html526/RooStats__NeymanConstruction.html,1,['test'],['test']
Testability,"oot"" containing the MVA output histograms; ==> TMVARegressionApplication is done!; ; ; #include <cstdlib>; #include <vector>; #include <iostream>; #include <map>; #include <string>; ; #include ""TFile.h""; #include ""TTree.h""; #include ""TString.h""; #include ""TSystem.h""; #include ""TROOT.h""; #include ""TStopwatch.h""; ; #include ""TMVA/Tools.h""; #include ""TMVA/Reader.h""; ; using namespace TMVA;; ; void TMVARegressionApplication( TString myMethodList = """" ); {; //---------------------------------------------------------------; // This loads the library; TMVA::Tools::Instance();; ; // Default MVA methods to be trained + tested; std::map<std::string,int> Use;; ; // --- Mutidimensional likelihood and Nearest-Neighbour methods; Use[""PDERS""] = 0;; Use[""PDEFoam""] = 1;; Use[""KNN""] = 1;; //; // --- Linear Discriminant Analysis; Use[""LD""] = 1;; //; // --- Function Discriminant analysis; Use[""FDA_GA""] = 0;; Use[""FDA_MC""] = 0;; Use[""FDA_MT""] = 0;; Use[""FDA_GAMT""] = 0;; //; // --- Neural Network; Use[""MLP""] = 0;; // Deep neural network; #ifdef R__HAS_TMVAGPU; Use[""DNN_GPU""] = 1;; Use[""DNN_CPU""] = 0;; #else; Use[""DNN_GPU""] = 0;; #ifdef R__HAS_TMVACPU; Use[""DNN_CPU""] = 1;; #else; Use[""DNN_CPU""] = 0;; #endif; #endif; //; // --- Support Vector Machine; Use[""SVM""] = 0;; //; // --- Boosted Decision Trees; Use[""BDT""] = 0;; Use[""BDTG""] = 1;; // ---------------------------------------------------------------; ; std::cout << std::endl;; std::cout << ""==> Start TMVARegressionApplication"" << std::endl;; ; // Select methods (don't look at this code - not of interest); if (myMethodList != """") {; for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) it->second = 0;; ; std::vector<TString> mlist = gTools().SplitString( myMethodList, ',' );; for (UInt_t i=0; i<mlist.size(); i++) {; std::string regMethod(mlist[i]);; ; if (Use.find(regMethod) == Use.end()) {; std::cout << ""Method \"""" << regMethod << ""\"" not known in TMVA under this name. Choose among the following:"" << std::end",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegressionApplication_8C.html:2820,test,tested,2820,doc/master/TMVARegressionApplication_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegressionApplication_8C.html,1,['test'],['tested']
Testability,"oot"", Bool_t withWrks=kFALSE);  Enable/Disable saving of the performance tree. ;  ; void SetPrintProgress (PrintProgress_t pp);  ; void SetProgressDialog (Bool_t on=kTRUE);  Enable/Disable the graphic progress dialog. ;  ; void SetQueryMode (EQueryMode mode);  Change query running mode to the one specified by 'mode'. ;  ; void SetRealTimeLog (Bool_t on=kTRUE);  Switch ON/OFF the real-time logging facility. ;  ; void ShowDataSet (const char *dataset="""", const char *opt=""filter:SsCc"");  display meta-info for given dataset usi ;  ; void ShowDataSetQuota (Option_t *opt=0);  shows the quota and usage of all groups if opt contains ""U"" shows also distribution of usage on user-level ;  ; void ShowEnabledPackages (Bool_t all=kFALSE);  List which packages are enabled. ;  ; void ShowFeedback () const;  Show items in feedback list. ;  ; void ShowLog (const char *queryref);  Display on screen the content of the temporary log file for query in reference. ;  ; void ShowLog (Int_t qry=-1);  Display on screen the content of the temporary log file. ;  ; void ShowMissingFiles (TQueryResult *qr=0);  Show information about missing files during query described by 'qr' or the last query if qr is null (default). ;  ; void ShowPackages (Bool_t all=kFALSE, Bool_t redirlog=kFALSE);  List contents of package directory. ;  ; void ShowParameters (const char *wildcard=""PROOF_*"") const;  Show the input list parameters specified by the wildcard. ;  ; void ShowQueries (Option_t *opt="""");  Ask the master for the list of queries. ;  ; virtual void ShowStagingStatusDataSet (const char *dataset, const char *optStr=""filter:SsCc"");  Like GetStagingStatusDataSet, but displays results immediately. ;  ; void StartupMessage (const char *msg, Bool_t status, Int_t done, Int_t total);  Send startup message. ;  ; void StopProcess (Bool_t abort, Int_t timeout=-1);  Send STOPPROCESS message to master and workers. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Touch ();  Ping PROOF slaves",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:18870,log,log,18870,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['log'],['log']
Testability,"ooth (Int_t ntimes=1, Option_t *option="""") override;  Smooth bin contents of this 2-d histogram using kernel algorithms similar to the ones used in the raster graphics community. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TH2. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TH1;  ~TH1 () override;  Histogram default destructor. ;  ; virtual Bool_t Add (const TH1 *h, const TH1 *h2, Double_t c1=1, Double_t c2=1);  Replace contents of this histogram by the addition of h1 and h2. ;  ; virtual Bool_t Add (const TH1 *h1, Double_t c1=1);  Performs the operation: this = this + c1*h1 If errors are defined (see TH1::Sumw2), errors are also recalculated. ;  ; virtual Bool_t Add (TF1 *h1, Double_t c1=1, Option_t *option="""");  Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2), errors are also recalculated. ;  ; virtual Double_t AndersonDarlingTest (const TH1 *h2, Double_t &advalue) const;  Same function as above but returning also the test statistic value. ;  ; virtual Double_t AndersonDarlingTest (const TH1 *h2, Option_t *option="""") const;  Statistical test of compatibility in shape between this histogram and h2, using the Anderson-Darling 2 sample test. ;  ; void Browse (TBrowser *b) override;  Browse the Histogram object. ;  ; virtual Bool_t CanExtendAllAxes () const;  Returns true if all axes are extendable. ;  ; virtual Double_t Chi2Test (const TH1 *h2, Option_t *option=""UU"", Double_t *res=nullptr) const;  \( \chi^{2} \) test for comparing weighted and unweighted histograms. ;  ; virtual Double_t Chi2TestX (const TH1 *h2, Double_t &chi2, Int_t &ndf, Int_t &igood, Option_t *option=""UU"", Double_t *res=nullptr) const;  The computation routine of the Chisquare test. ;  ; virtual Double_t Chisquare (TF1 *f1, Option_t *option="""") const;  Compute and return the chisquare of this histogram with respect to a function The chisquare is computed by weighting each histo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2.html:11788,test,test,11788,doc/master/classTH2.html,https://root.cern,https://root.cern/doc/master/classTH2.html,1,['test'],['test']
Testability,"operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Attributes; bool _disableCache = false;  Flag to run object in passthrough (= non-caching mode) ;  . Friends; class PdfCacheElem;  . Additional Inherited Members;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #incl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCachedPdf.html:75433,test,testArg,75433,doc/master/classRooAbsCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsCachedPdf.html,4,['test'],['testArg']
Testability,"operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0); voidRooAbsArg::printDirty(Bool_t depth = kTRUE) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsArg::printMetaArgs(ostream&) const; virtual voidprintMult",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooBinningCategory.html:10536,test,testArg,10536,root/html526/RooBinningCategory.html,https://root.cern,https://root.cern/root/html526/RooBinningCategory.html,4,['test'],['testArg']
Testability,"operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0); voidRooAbsArg::printDirty(Bool_t depth = kTRUE) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMetaArgs(ostream& os) const; virtual voidprintMultiline(os",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMappedCategory.html:10551,test,testArg,10551,root/html526/RooMappedCategory.html,https://root.cern,https://root.cern/root/html526/RooMappedCategory.html,1,['test'],['testArg']
Testability,"operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidRooAbsArg::printDirty(Bool_t depth = kTRUE) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsArg::printMetaArgs(ostream&) const; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooBinningCategory.html:10651,test,testArg,10651,root/html528/RooBinningCategory.html,https://root.cern,https://root.cern/root/html528/RooBinningCategory.html,16,['test'],['testArg']
Testability,"operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidRooAbsArg::printDirty(Bool_t depth = kTRUE) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMetaArgs(ostream& os) const; virtual v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooMappedCategory.html:10666,test,testArg,10666,root/html528/RooMappedCategory.html,https://root.cern,https://root.cern/root/html528/RooMappedCategory.html,4,['test'],['testArg']
Testability,"operator= (const LorentzVector< OtherCoords > &v);  Assignment operator from a lorentz vector of arbitrary type. ;  ; bool operator== (const LorentzVector &rhs) const;  Exact equality. ;  ; Scalar P () const;  ; Scalar P2 () const;  return the square of the spatial (3D) magnitude ( X**2 + Y**2 + Z**2 ) ;  ; Scalar Perp2 () const;  return the square of the transverse spatial component ( X**2 + Y**2 ) ;  ; Scalar perp2 () const;  ; Scalar Phi () const;  azimuthal Angle ;  ; Scalar phi () const;  ; Scalar Pt () const;  return the transverse spatial component sqrt ( X**2 + Y**2 ) ;  ; Scalar pt () const;  ; Scalar Px () const;  spatial X component ;  ; Scalar px () const;  ; Scalar Py () const;  spatial Y component ;  ; Scalar py () const;  ; Scalar Pz () const;  spatial Z component ;  ; Scalar pz () const;  ; Scalar R () const;  return the spatial (3D) magnitude ( sqrt(X**2 + Y**2 + Z**2) ) ;  ; Scalar r () const;  ; Scalar Rapidity () const;  Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. ;  ; Scalar Rho () const;  ; Scalar rho () const;  ; LorentzVector< CoordSystem > & SetCoordinates (const Scalar src[]);  Set internal data based on an array of 4 Scalar numbers. ;  ; template<class IT > ; LorentzVector< CoordSystem > & SetCoordinates (IT begin, IT end);  Set internal data based on 4 Scalars at *begin to *end. ;  ; LorentzVector< CoordSystem > & SetCoordinates (Scalar a, Scalar b, Scalar c, Scalar d);  Set internal data based on 4 Scalar numbers. ;  ; LorentzVector< CoordSystem > & SetE (Scalar a);  Methods setting a Single-component Work only if the component is one of which the vector is represented. ;  ; LorentzVector< CoordSystem > & SetEta (Scalar a);  ; LorentzVector< CoordSystem > & SetM (Scalar a);  ; LorentzVector< CoordSystem > & SetPhi (Scalar a);  ; LorentzVector< CoordSystem > & SetPt (Scalar a);  ; LorentzVector< CoordSystem > & SetPx (Scalar a);  ; LorentzVector< CoordSystem > & SetPxPyPzE (Scalar xx, Scalar yy, Scalar zz, Scalar ee);  ; Lore",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1LorentzVector.html:8184,log,log,8184,doc/master/classROOT_1_1Math_1_1LorentzVector.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1LorentzVector.html,1,['log'],['log']
Testability,"opic, RooFit::MsgLevel level); Check if logging is active for given object/topic/RooFit::MsgLevel combination. Bool_t isActive(const TObject* self, RooFit::MsgTopic topic, RooFit::MsgLevel level); Check if logging is active for given object/topic/RooFit::MsgLevel combination. Int_t activeStream(const RooAbsArg* self, RooFit::MsgTopic topic, RooFit::MsgLevel level); Find appropriate logging stream for message from given object with given topic and message level. Int_t activeStream(const TObject* self, RooFit::MsgTopic topic, RooFit::MsgLevel level); Find appropriate logging stream for message from given object with given topic and message level. ostream& log(const RooAbsArg* self, RooFit::MsgLevel level, RooFit::MsgTopic topic, Bool_t skipPrefix); Log error message associated with RooAbsArg object self at given level and topic. If skipPrefix; is true the standard RooMsgService prefix is not added. ostream& log(const TObject* self, RooFit::MsgLevel level, RooFit::MsgTopic topic, Bool_t skipPrefix); Log error message associated with TObject object self at given level and topic. If skipPrefix; is true the standard RooMsgService prefix is not added. void Print(Option_t* options = 0) const; Print configuration of message service. If ""v"" option is given also; inactive streams are listed. StreamConfig& getStream(Int_t id); { return _streams[id] ; }. Int_t numStreams() const; { return _streams.size() ; }. void reset(); { cleanup() ; }. void setGlobalKillBelow(RooFit::MsgLevel level); { _globMinLevel = level ; }. RooFit::MsgLevel globalKillBelow() const; { return _globMinLevel ; }. void showPid(Bool_t flag); { _showPid = flag ; }. Bool_t silentMode() const; Print level support for RooFit-related messages that are not routed through RooMsgService (such as Minuit printouts). { return _silentMode ; }. void setSilentMode(Bool_t flag); { _silentMode = flag ; }. Int_t errorCount() const; { return _errorCount ; }. void clearErrorCount(); { _errorCount = 0 ; }. RooMsgService(); Priva",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMsgService.html:11177,log,log,11177,root/html526/RooMsgService.html,https://root.cern,https://root.cern/root/html526/RooMsgService.html,1,['log'],['log']
Testability,"option = """"); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidSetMinNodeSize(Double_t sizeInPercent); voidSetMinNodeSize(TString sizeInPercent); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); Double_tTestTreeQuality(TMVA::DecisionTree* dt); virtual voidTrain(); voidTMVA::Meth",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodDT.html:15155,test,testTime,15155,root/html602/TMVA__MethodDT.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodDT.html,2,['test'],['testTime']
Testability,"option = """"); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidSetMinNodeSize(Double_t sizeInPercent); voidSetMinNodeSize(TString sizeInPercent); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); Double_tTestTreeQuality(TMVA::DecisionTree* dt); virtual voidTrain(); voidTMVA::MethodBase::Tra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodDT.html:14544,test,testTime,14544,root/html534/TMVA__MethodDT.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodDT.html,1,['test'],['testTime']
Testability,"option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. RooStats::SamplingDistribution*RooStats::HypoTestResult::fAltDistr; Double_tRooStats::HypoTestResult::fAlternatePValuep-value for the alternate hypothesis (small number means disfavored); Double_tRooStats::HypoTestResult::fAlternatePValueErrorerror of p-value for the alternate hypothesis (small number means disfavored); Bool_tRooStats::HypoTestResult::fBackgroundIsAlt; TStringTNamed::fNameobject identifier; RooStats::SamplingDistribution*RooStats::HypoTestResult::fNullDistr; Double_tRooStats::HypoTestResult::fNullPValuep-value for the null hypothesis (small number means disfavored); Double_tRooStats::HypoTestResult::fNullPValueErrorerror of p-value for the null hypothesis (small number means disfavored); Bool_tRooStats::HypoTestResult::fPValueIsRightTail; Double_tRooStats::HypoTestResult::fTestStatisticDataresult of the test statistic evaluated on data; TStringTNamed::fTitleobject title. private:. boolfComputationsAltDoneFlagflag if the fAlternatePValue computation have been already done or not (ie need to be refreshed); boolfComputationsNulDoneFlagflag if the fNullPValue computation have been already done or not (ie need to be refreshed); boolfSumLargerValuesp-value for velues of testStat >= testStat_data (or testStat <= testStat_data); vector<double>fTestStat_bvector of results for B-only toy-MC; doublefTestStat_dataresults (test statistics) evaluated for data; vector<double>fTestStat_sbvector of results for S+B toy-MC. Clas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__HybridResult.html:8976,test,test,8976,root/html530/RooStats__HybridResult.html,https://root.cern,https://root.cern/root/html530/RooStats__HybridResult.html,2,['test'],['test']
Testability,"option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidSetBins(const RooAbsCollection& coll, Int_t numBins) const; voidSetupBasicUsage(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. RooArgList*fAxeswhich variables to put on each axis; RooAbsData*fDatapointer to the data (owned by the workspace); TStringTNamed::fNameobject identifier; RooArgSetfNuisParamsnuisance parameters for interval (not really used); Int_tfNumBinsset the number of bins to create for each; Int_tfNumBurnInStepsnumber of iterations to discard as burn-in, starting from the first; Int_tfNumItersnumber of iterations to run metropolis algorithm; RooArgSetfPOIparameters of interest for interval; RooAbsPdf*fPdfpointer to common PDF (owned by the workspace) ; RooAbsPdf*fPriorPdfpointer to prior PDF (owned by the workspace) ; RooStats::ProposalFunction*fPropFuncProposal function for MCMC integration; Double_tfSizesize of the test (eg. specified rate of Type I error); TStringTNamed::fTitleobject title; Bool_tfUseKeyswhether to use kernel estimation to determine interval; Bool_tfUseSparseHistwhether to use sparse histogram (if using hist at all). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MCMCCalculator(); default constructor. MCMCCalculator(RooAbsData& data, RooAbsPdf& pdf, const RooArgSet& paramsOfInterest, RooAbsPdf& priorPdf); Constructor for automatic configuration with basic settings. Uses a; UniformProposal,10,000 iterations, 40 burn in steps, 50 bins for each; RooRealVar, determines interval by keys, and t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__MCMCCalculator.html:8397,test,test,8397,root/html526/RooStats__MCMCCalculator.html,https://root.cern,https://root.cern/root/html526/RooStats__MCMCCalculator.html,1,['test'],['test']
Testability,"option bf().; The number of nodes can be change with n(nodesx, nodesy). Example: h2->Draw(""SPEC n(40,40)"");; Sometimes the displayed region is rather large. When displaying all channels pictures become very dense and complicated. It is very difficult to understand the overall shape of data. ""n(nx,ny)"" allows to change the density of displayed channels. Only the channels coinciding with given nodes are displayed.; The visualization angles can be changed with a(alpha, beta, view). Example: h2->Draw(""SPEC n(40,40) dm(0,1) a(30,30,0)"");; Alpha defines the angle between bottom horizontal screen line and the displayed space on the right side of the picture and beta on the left side, respectively. One can rotate the 3-d space around vertical axis going through the center of it employing the view parameter. Allowed values are 0, 90, 180 and 270 degrees.; zs(scale) changes the scale of the Z-axis Possible values are:. 0 = Linear (default); 1 = Log; 2 = Sqrt. If gPad->SetLogz() has been set, log scale on Z-axis is set automatically. No need to use the zs() operator. Note that the X and Y axis are always linear.; ci(r,g,b), were r,g and b are floats defines the colors increments. For sophisticated shading (Light, Height and LightHeight Display Modes Groups) the color palette starts from the basic pen color (see pa() function). There is a predefined number of color levels (256). Color in every level is calculated by adding the increments of the r, g, b components to the previous level. Using this function one can change the color increments between two neighbouring color levels. The function does not apply dor the Simple Display Modes Group. The default values are: (1,1,1).; ca(color_algorithm) allows to choose the Color Algorithm. To define the colors one can employ one of the following color algorithms (RGB, CMY, CIE, YIQ, HVS models). When the level of a component reaches the limit value one can choose either smooth transition (by decreasing the limit value) or a sharp modulo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2Painter.html:47179,log,log,47179,doc/master/classTSpectrum2Painter.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2Painter.html,1,['log'],['log']
Testability,"option, Int_t nbins)=0; TVirtualPad::TContextsmall helper class to store/restore gPad context in TPad methodsDefinition TVirtualPad.h:61; bool; double; int; unsigned int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; h1TH1F * h1Definition legend1.C:5; f1TF1 * f1Definition legend1.C:11; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ProbDouble_t Prob(Double_t chi2, Int_t ndf)Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf...Definition TMath.cxx:637; TMath::PermuteBool_t Permute(Int_t n, Int_t *a)Simple recursive algorithm to find the permutations of n natural numbers, not necessarily all distinc...Definition TMath.cxx:2557; TMath::QuietNaNDouble_t QuietNaN()Returns a quiet NaN as defined by IEEE 754.Definition TMath.h:902; TMath::FloorDouble_t Floor(Double_t x)Rounds x downward, returning the largest integral value that is not greater than x.Definition TMath.h:680; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::MeanDouble_t Mean(Long64_t n, const T *a, const Double_t *w=nullptr)Returns the weighted mean of an array a with length n.Definition TMath.h:1089; TMath::KolmogorovProbDouble_t KolmogorovProb(Double_t z)Calculates the Kolmogorov distribution function,.Definition TMath.cxx:679; TMath::BinarySearchLong64_t BinarySearch(Long64_t n, const T *array, T value)Binary search in an array of n values to locate value.Definition TMathBase.h:347; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; v@ vDefinition rootcling_impl.cxx:3699. histhistsrcTH3.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:34 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH3_8cxx_source.html:217692,log,logarithm,217692,doc/master/TH3_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html,1,['log'],['logarithm']
Testability,"option.Logx) {; 6448 if (xp <= 0) goto L30;; 6449 if (xp < logxmin) goto L30;; 6450 if (xp > TMath::Power(10,xmax)) break;; 6451 } else {; 6452 if (xp < xmin) goto L30;; 6453 if (xp > xmax) break;; 6454 }; 6455 yp = factor*fH->GetBinContent(k);; 6456 if (optionI0 && yp==0) goto L30;; 6457 if (fixbin) {; 6458 ex1 = xerror*Hparam.xbinsize;; 6459 } else {; 6460 delta = fH->GetBinWidth(k);; 6461 ex1 = xerror*delta;; 6462 }; 6463 if (fH->GetBinErrorOption() == TH1::kNormal) {; 6464 ey1 = factor*fH->GetBinError(k);; 6465 ey2 = ey1;; 6466 } else {; 6467 ey1 = factor*fH->GetBinErrorLow(k);; 6468 ey2 = factor*fH->GetBinErrorUp(k);; 6469 }; 6470 ex2 = ex1;; 6471 ; 6472 xi4 = xp;; 6473 xi3 = xp;; 6474 xi2 = xp + ex2;; 6475 xi1 = xp - ex1;; 6476 ; 6477 yi1 = yp;; 6478 yi2 = yp;; 6479 yi3 = yp - ey1;; 6480 yi4 = yp + ey2;; 6481 ; 6482 // take the LOG if necessary; 6483 if (Hoption.Logx) {; 6484 xi1 = TMath::Log10(TMath::Max(xi1,logxmin));; 6485 xi2 = TMath::Log10(TMath::Max(xi2,logxmin));; 6486 xi3 = TMath::Log10(TMath::Max(xi3,logxmin));; 6487 xi4 = TMath::Log10(TMath::Max(xi4,logxmin));; 6488 }; 6489 if (Hoption.Logy) {; 6490 yi1 = TMath::Log10(TMath::Max(yi1,logymin));; 6491 yi2 = TMath::Log10(TMath::Max(yi2,logymin));; 6492 yi3 = TMath::Log10(TMath::Max(yi3,logymin));; 6493 yi4 = TMath::Log10(TMath::Max(yi4,logymin));; 6494 }; 6495 ; 6496 // test if error bars are not outside the limits; 6497 // otherwise they are truncated; 6498 ; 6499 xi1 = TMath::Max(xi1,xmin);; 6500 xi2 = TMath::Min(xi2,xmax);; 6501 yi3 = TMath::Max(yi3,ymin);; 6502 yi4 = TMath::Min(yi4,ymax);; 6503 ; 6504 // test if the marker is on the frame limits. If ""Yes"", the; 6505 // marker will not be drawn and the error bars will be readjusted.; 6506 ; 6507 drawmarker = kTRUE;; 6508 if (!option0 && !option3) {; 6509 if (Hoption.Logy && yp < logymin) goto L30;; 6510 if (yi1 < ymin || yi1 > ymax) goto L30;; 6511 if (Hoption.Error != 0 && yp == 0 && ey1 <= 0) drawmarker = kFALSE;; 6512 }; 6513 if (!symbolsize || !e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:237979,log,logxmin,237979,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,4,['log'],['logxmin']
Testability,"options and the details about fitting histograms ; Definition at line 3898 of file TH1.cxx. ◆ Fit() [2/2]. TFitResultPtr TH1::Fit ; (; TF1 * ; f1, . Option_t * ; option = """", . Option_t * ; goption = """", . Double_t ; xxmin = 0, . Double_t ; xxmax = 0 . ). virtual . Fit histogram with the function pointer f1. ; Parameters. [in]f1pointer to the function object ; [in]optionstring defining the fit options (see table below). ; [in]goptionspecify a list of graphics options. See TH1::Draw for a complete list of these options. ; [in]xxminlower fitting range ; [in]xxmaxupper fitting range . ReturnsA smart pointer to the TFitResult class. Histogram Fitting Options; Here is the full list of fit options that can be given in the parameter option. Several options can be used together by concatanating the strings without the need of any delimiters. option description . ""L"" Uses a log likelihood method (default is chi-square method). To be used when the histogram represents counts. . ""WL"" Weighted log likelihood method. To be used when the histogram has been filled with weights different than 1. This is needed for getting correct parameter uncertainties for weighted fits. . ""P"" Uses Pearson chi-square method. Uses expected errors instead of the observed one (default case). The expected error is instead estimated from the square-root of the bin function value. . ""MULTI"" Uses Loglikelihood method based on multi-nomial distribution. In this case the function must be normalized and one fits only the function shape. . ""W"" Fit using the chi-square method and ignoring the bin uncertainties and skip empty bins. . ""WW"" Fit using the chi-square method and ignoring the bin uncertainties and include the empty bins. . ""I"" Uses the integral of function in the bin instead of the default bin center value. . ""F"" Uses the default minimizer (e.g. Minuit) when fitting a linear function (e.g. polN) instead of the linear fitter. . ""U"" Uses a user specified objective function (e.g. user providedlikelihood",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:126105,log,log,126105,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['log'],['log']
Testability,"or (unsigned int j = 0; j <= i; j++) {; 330 unsigned int ih = j + i *(i+1)/2; // formula for j <= i; 331 unsigned int im = i*np + j;; 332 h[ih] = h2[im];; 333 }; 334 }; 335 return true;; 336 }; 337 static bool IsAvailable(TF1 * func) {; 338 auto formula = func->GetFormula();; 339 if (!formula) return false;; 340 return formula->GenerateHessianPar();; 341 }; 342 };; 343 ; 344 ; 345 ; 346 template <class T>; 347 bool WrappedMultiTF1Templ<T>::ParameterHessian(const T *x, const double *par, T *h) const; 348 {; 349 if (fLinear) {; 350 std::fill(h, h + NPar()*(NPar()+1)/2, 0.0);; 351 return true;; 352 }; 353 return GeneralHessianCalc<T>::Hessian(fFunc, x, par, h);; 354 }; 355 ; 356 template <class T>; 357 bool WrappedMultiTF1Templ<T>::HasParameterHessian() const; 358 {; 359 return GeneralHessianCalc<T>::IsAvailable(fFunc);; 360 }; 361 ; 362 template <class T>; 363 T WrappedMultiTF1Templ<T>::DoParameterDerivative(const T *x, const double *p, unsigned int ipar) const; 364 {; 365 // evaluate the derivative of the function with respect to parameter ipar; 366 // see note above concerning the fixed parameters; 367 if (!fLinear) {; 368 fFunc->SetParameters(p);; 369 double prec = this->GetDerivPrecision();; 370 return fFunc->GradientPar(ipar, x, prec);; 371 }; 372 if (fPolynomial) {; 373 // case of polynomial function (no parameter dependency) (case for dim = 1); 374 assert(fDim == 1);; 375 if (ipar == 0) return 1.0;; 376#ifdef R__HAS_VECCORE; 377 return vecCore::math::Pow(x[0], static_cast<T>(ipar));; 378#else; 379 return std::pow(x[0], static_cast<int>(ipar));; 380#endif; 381 } else {; 382 // case of general linear function (built in TFormula with ++ ); 383 return GeneralLinearFunctionDerivation<T>::DoParameterDerivative(this, x, ipar);; 384 }; 385 }; 386 template<class T>; 387 void WrappedMultiTF1Templ<T>::SetDerivPrecision(double eps); 388 {; 389 ::ROOT::Math::Internal::DerivPrecision(eps);; 390 }; 391 ; 392 template<class T>; 393 double WrappedMultiTF1Templ<T>::GetDerivPreci",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html:13182,assert,assert,13182,doc/master/WrappedMultiTF1_8h_source.html,https://root.cern,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html,1,['assert'],['assert']
Testability,"or (with name ). HybridResult(const char* name, vector<double>& testStat_sb_vals, vector<double>& testStat_b_vals, bool sumLargerValues = true); HybridResult constructor (with name, title and vectors of S+B and B values). ~HybridResult(); HybridResult destructor. void SetDataTestStatistics(double testStat_data_val); set the value of the test statistics on data. double NullPValue() const; return 1-CL_b : the B p-value. double AlternatePValue() const; return CL_s+b : the S+B p-value. Double_t CLbError() const; Returns an estimate of the error on CLb assuming a binomial error on; CLb:. Double_t CLsplusbError() const; Returns an estimate of the error on CLsplusb assuming a binomial; error on CLsplusb:. Double_t CLsError() const; Returns an estimate of the error on CLs through combination of the; errors on CLb and CLsplusb:. void Add(RooStats::HybridResult* other); add additional toy-MC experiments to the current results; use the data test statistics of the added object if none is already present (otherwise, ignore the new one). HybridPlot* GetPlot(const char* name, const char* title, int n_bins); prepare a plot showing a result and return a pointer to a HybridPlot object; the needed arguments are: an object name, a title and the number of bins in the plot. void PrintMore(const char* options); Print out some information about the results. explicit HybridResult(const char *name = 0); Default constructor. std::vector<double> GetTestStat_sb(); Get test statistics values for the sb model. {return fTestStat_sb;}. std::vector<double> GetTestStat_b(); Get test statistics values for the b model. {return fTestStat_b;}. double GetTestStat_data(); Get test statistics value for data. { return fTestStat_data;}. » Last changed: root/roostats:$Id: HybridResult.h 31276 2009-11-18 15:06:42Z moneta $ » Last generated: 2009-12-07 13:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__HybridResult.html:9591,test,test,9591,root/html526/RooStats__HybridResult.html,https://root.cern,https://root.cern/root/html526/RooStats__HybridResult.html,3,['test'],['test']
Testability,"or <= 0. ); 1588 minValError = valError;; 1589 ; 1590 if (!computeLossInTraining) {; 1591 trainingError = 0.0;; 1592 // Compute training error.; 1593 for (auto batch : trainingData) {; 1594 auto inputTensor = batch.GetInput();; 1595 auto outputMatrix = batch.GetOutput();; 1596 auto weights = batch.GetWeights();; 1597 trainingError += deepNet.Loss(inputTensor, outputMatrix, weights, false, false);; 1598 }; 1599 }; 1600 // normalize loss to number of batches and add regularization term; 1601 trainingError /= (Double_t)(nTrainingSamples / settings.batchSize);; 1602 trainingError += regTerm;; 1603 ; 1604 //Log the loss value; 1605 fTrainHistory.AddValue(""trainingError"",nTrainEpochs,trainingError);; 1606 ; 1607 // stop measuring; 1608 tend = std::chrono::system_clock::now();; 1609 ; 1610 // Compute numerical throughput.; 1611 std::chrono::duration<double> elapsed_seconds = tend - tstart;; 1612 std::chrono::duration<double> elapsed1 = t1-tstart;; 1613 // std::chrono::duration<double> elapsed2 = t2-tstart;; 1614 // time to compute training and test errors; 1615 std::chrono::duration<double> elapsed_testing = tend-t1;; 1616 ; 1617 double seconds = elapsed_seconds.count();; 1618 // double nGFlops = (double)(settings.testInterval * batchesInEpoch * settings.batchSize)*1.E-9;; 1619 // nGFlops *= deepnet.GetNFlops() * 1e-9;; 1620 double eventTime = elapsed1.count()/( batchesInEpoch * settings.testInterval * settings.batchSize);; 1621 ; 1622 converged =; 1623 convergenceCount > settings.convergenceSteps || nTrainEpochs >= settings.maxEpochs;; 1624 ; 1625 ; 1626 Log() << std::setw(10) << nTrainEpochs << "" | ""; 1627 << std::setw(12) << trainingError; 1628 << std::setw(12) << valError; 1629 << std::setw(12) << seconds / settings.testInterval; 1630 << std::setw(12) << elapsed_testing.count(); 1631 << std::setw(12) << 1. / eventTime; 1632 << std::setw(12) << convergenceCount; 1633 << Endl;; 1634 ; 1635 if (converged) {; 1636 Log() << Endl;; 1637 }; 1638 tstart = std::chrono::system_c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:64167,test,test,64167,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['test'],['test']
Testability,or Abstract base class for numeric event generator algorithms; RooAbsOptTestStatistic Abstract base class for optimized test statistics; RooAbsPdf Abstract PDF with normalization support; RooAbsPdf::GenSpec ; RooAbsProxy Abstract proxy interface; RooAbsReal Abstract real-valued variable; RooAbsRealLValue Abstract modifiable real-valued object; RooAbsRootFinder Abstract interface for 1-dim real-valued function root finders; RooAbsSelfCachedPdf Abstract base class for self-caching p.d.f.s; RooAbsSelfCachedReal Abstract base class for self-caching functions; RooAbsString Abstract string-valued variable; RooAbsStudy Abstract base class for RooStudyManager modules; RooAbsTestStatistic Abstract base class for real-valued test statistics; RooAcceptReject Context for generating a dataset from a PDF; RooAdaptiveGaussKronrodIntegrator1D 1-dimensional adaptive Gauss-Kronrod numerical integration engine; RooAdaptiveIntegratorND N-dimensional adaptive integration (interface to MathCore integrator); RooAddGenContext Specialized context for generating a dataset from a RooAddPdf; RooAddModel Resolution model representing a sum of resolution models; RooAddPdf PDF representing a sum of PDFs; RooAddition Sum of RooAbsReal objects; RooArgList Ordered list of RooAbsArg objects; RooArgProxy Abstract proxy for RooAbsArg objects; RooArgSet Set of RooAbsArg objects; RooArgusBG Argus background shape PDF; RooBCPEffDecay B Mixing decay PDF; RooBCPGenDecay B decay time distribution with CP violation; RooBDecay P.d.f of general description of B decay time distribution; RooBMixDecay B Mixing decay PDF; RooBernstein Bernstein polynomial PDF; RooBifurGauss Bifurcated Gaussian PDF; RooBinning Generic binning specification; RooBinningCategory RealVar-to-Category function defined by bin boundaries on input var; RooBlindTools Root implementation of BlindTools; RooBreitWigner Breit Wigner PDF; RooBrentRootFinder Abstract interface for 1-dim real-valued function root finders; RooBukinPdf Variation of No,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ClassIndex.html:24954,test,test,24954,root/html526/ClassIndex.html,https://root.cern,https://root.cern/root/html526/ClassIndex.html,2,['test'],['test']
Testability,"or Sub-editor for TGLClipSet.; TGLColor Color in preferred GL format - RGBA.; TGLColorSet Collection of colors used for GL rendering.; TGLContext Control internal gl-context resources.; TGLContextIdentity Identity of a shared GL context.; TGLCylinder a cylinderical logical shape; TGLEmbeddedViewer Embedded GL viewer.; TGLEventHandler Base-class and default implementation of event-handler for TGLViewer.; TGLFaceSet a faceset logical shape; TGLFaderHelper ; TGLFont A wrapper class for FTFont.; TGLFontManager A FreeType GL font manager.; TGLFormat Describes GL buffer format.; TGLHistPainter Proxy class for GL hist painters.; TGLIsoPainter Iso option for TH3.; TGLLegoPainter Lego painter; TGLLightSet A set of OpenGL lights.; TGLLightSetEditor Editor for TGLLightSet.; TGLLightSetSubEditor Sub-editor for TGLLightSet.; TGLLine3 GL line wrapper class; TGLLockable Lock for viewers and scenes.; TGLLogicalShape a logical (non-placed, local frame) drawable object; TGLManager Interface for OpenGL manager; TGLManip abstract base GL manipulator widget; TGLManipSet A collection of available manipulators.; TGLMatrix GL matrix helper/wrapper class; TGLObject Base-class for direct OpenGL renderers; TGLOrthoCamera Camera for orthographic view.; TGLOutput Wrapper class for GL capture & output routines; TGLOverlayButton GL-overlay button.; TGLOverlayElement Base class for GL overlay elements.; TGLOverlayList Collection of overlay elements to draw/select together.; TGLOvlSelectRecord Standard GL overlay-selection record.; TGLPShapeObj This object wraps TGLPhysicalShape (not a TObject); TGLPShapeObjEditor GUI for editing attributes of a physical-shape.; TGLPShapeRef Reference to a TGLPhysicalShape object.; TGLPadPainter ; TGLPaintDevice Base class for GL widgets and GL off-screen rendering; TGLParametricEquation Equation of parametric surface.; TGLParametricEquationGL GL renderer for TGLParametricEquation; TGLParametricPlot Parametric plot's painter.; TGLPerspectiveCamera Camera for perspec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:72225,log,logical,72225,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,1,['log'],['logical']
Testability,"or a master server.; If bin is true it is a binary file, other wise it is an ASCII; file and we need to check for Windows \r tokens. Returns -1 in; case of error, 0 otherwise. void Run(Bool_t retrn = kFALSE); Main server eventloop. void SendLogFile(Int_t status = 0, Int_t start = -1, Int_t end = -1); Send log file to master.; If start > -1 send only bytes in the range from start to end,; if end <= start send everything from start. void SendStatistics(); Send statistics of slave server to master or client. void SendParallel(Bool_t async = kFALSE); Send number of parallel nodes to master or client. Int_t UnloadPackage(const char* package); Removes link to package in working directory,; removes entry from include path,; removes entry from enabled package list,; does not currently remove entry from interpreter include path.; Returns -1 in case of error, 0 otherwise. Int_t UnloadPackages(); Unloads all enabled packages. Returns -1 in case of error, 0 otherwise. Int_t Setup(); Print the ProofServ logo on standard output.; Return 0 on success, -1 on failure. Int_t SetupCommon(); Common part (between TProofServ and TXProofServ) of the setup phase.; Return 0 on success, -1 on error. void Terminate(Int_t status); Terminate the proof server. Bool_t UnlinkDataDir(const char* path); Scan recursively the datadir and unlink it if empty; Return kTRUE if it can be unlinked, kFALSE otherwise. Bool_t IsActive(); Static function that returns kTRUE in case we are a PROOF server. TProofServ * This(); Static function returning pointer to global object gProofServ.; Mainly for use via CINT, where the gProofServ symbol might be; deleted from the symbol table. Int_t OldAuthSetup(TString& wconf); Setup authentication related stuff for old versions.; Provided for backward compatibility. TProofQueryResult * MakeQueryResult(Long64_t nentries, const char* opt, TList* inl, Long64_t first, TDSet* dset, const char* selec, TObject* elist); Create a TProofQueryResult instance for this query. void SetQu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofServ.html:24183,log,logo,24183,root/html528/TProofServ.html,https://root.cern,https://root.cern/root/html528/TProofServ.html,6,['log'],['logo']
Testability,"or details see references; -statisticType - type of statistics, possible values kFitOptimChiCounts (chi square statistics with counts as weighting coefficients), kFitOptimChiFuncValues (chi square statistics with function values as weighting coefficients),kFitOptimMaxLikelihood; -alphaOptim - optimization of convergence algorithm, possible values kFitAlphaHalving, kFitAlphaOptimal; -power - possible values kFitPower2,4,6,8,10,12, for details see references. It applies only for Awmi fitting function.; -fitTaylor - order of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function. void SetPeakParameters(Double_t sigma, Bool_t fixSigma, const Float_t* positionInit, const Bool_t* fixPosition, const Float_t* ampInit, const Bool_t* fixAmp). SETTER FUNCTION. This function sets the following fitting parameters of peaks:; -sigma - initial value of sigma parameter; -fixSigma - logical value of sigma parameter, which allows to fix the parameter (not to fit); -positionInit - aray of initial values of peaks positions; -fixPosition - array of logical values which allow to fix appropriate positions (not fit). However they are present in the estimated functional.; -ampInit - aray of initial values of peaks amplitudes; -fixAmp - aray of logical values which allow to fix appropriate amplitudes (not fit). However they are present in the estimated functional. void SetBackgroundParameters(Double_t a0Init, Bool_t fixA0, Double_t a1Init, Bool_t fixA1, Double_t a2Init, Bool_t fixA2). SETTER FUNCTION. This function sets the following fitting parameters of background:; -a0Init - initial value of a0 parameter (backgroud is estimated as a0+a1*x+a2*x*x); -fixA0 - logical value of a0 parameter, which allows to fix the parameter (not to fit); -a1Init - initial value of a1 parameter; -fixA1 - logical value of a1 parameter, which allows to fix the parameter (not to fit); -a2Init - initial value of a2 parameter; -fixA2 - logical value o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrumFit.html:35893,log,logical,35893,root/html528/TSpectrumFit.html,https://root.cern,https://root.cern/root/html528/TSpectrumFit.html,8,['log'],['logical']
Testability,or floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*RooAbsOptTestStatistic::_funcClonePointer to internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooAbsTestStatistic**RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::_gofOpModeOperation mode of test statistic instance ; vector<RooFit::MPSplit>RooAbsTestStatistic::_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsTestStatistic::_init! Is object initialized ; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealMPFE**RooAbsTestStatistic::_mpfeArray! Array of parallel execution frond ends; RooFit::MPSplitRooAbsTestStatistic::_mpinterlUse interleaving strategy rather than N-wise split for partioning of dataset for multiprocessor-split; Int_tRooAbsTestStatistic::_nCPUNumber of processors to use in parallel calculation mode; Int_tRooAbsTestStatistic::_nEventsTotal number of events in test statistic calculation; Int_tRooAbsTestStatistic::_nGofNumber of sub-contexts ; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDataWeightedAverage.html:38784,test,test,38784,root/html534/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html534/RooDataWeightedAverage.html,2,['test'],['test']
Testability,"or hatch styles > 3100; TStringfHeaderPSUser defined additional Postscript header; Color_tfHistFillColorhistogram fill color; Style_tfHistFillStylehistogram fill style; Color_tfHistLineColorhistogram line color; Style_tfHistLineStylehistogram line style; Width_tfHistLineWidthhistogram line width; Bool_tfHistMinimumZerotrue if default minimum is 0, false if minimum is automatic; Double_tfHistTopMarginmargin between histogram's top and pad's top; Bool_tfIsReading!Set to FALSE when userclass::UseCurrentStyle is called by the style manager; Width_tfLegendBorderSizeTLegend box border size; Float_tfLegoInnerRInner radius for cylindrical legos; Float_tfLineScalePSLine scale factor when drawing lines on Postscript; TStringfLineStyle[30]String describing line style i (for postScript); Int_tfNumberContoursdefault number of contours for 2-d plots; Int_tfOptDate=1 if date option is selected; Int_tfOptFile=1 if option File is selected; Int_tfOptFit=1 if option Fit is selected; Int_tfOptLogx=1 if log scale in X; Int_tfOptLogy=1 if log scale in y; Int_tfOptLogz=1 if log scale in z; Int_tfOptStat=1 if option Stat is selected; Int_tfOptTitle=1 if option Title is selected; Int_tfPadBorderModepad border mode; Width_tfPadBorderSizepad border size; Float_tfPadBottomMarginpad bottom margin; Color_tfPadColorpad color; Bool_tfPadGridXtrue to get the grid along X; Bool_tfPadGridYtrue to get the grid along Y; Float_tfPadLeftMarginpad left margin; Float_tfPadRightMarginpad right margin; Int_tfPadTickX=1 to set special pad ticks along X; Int_tfPadTickY=1 to set special pad ticks along Y; Float_tfPadTopMarginpad top margin; TStringfPaintTextFormatPrinting format for TH2::PaintText; Float_tfPaperSizeXPostScript paper size along X; Float_tfPaperSizeYPostScript paper size along Y; Float_tfScreenFactorMultiplication factor for canvas size and position; Int_tfShowEditorShow pad editor; Int_tfShowEventStatusShow event status panel; Int_tfShowToolBarShow toolbar; Width_tfStatBorderSizeborder size of S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStyle.html:19755,log,log,19755,root/html528/TStyle.html,https://root.cern,https://root.cern/root/html528/TStyle.html,1,['log'],['log']
Testability,"or nTest_<class>; 1120 if(eventCounts[cls].TrainTestSplitRequested < 1.0 && eventCounts[cls].TrainTestSplitRequested > 0.0){; 1121 eventCounts[cls].nTrainingEventsRequested = Int_t(eventCounts[cls].TrainTestSplitRequested*(availableTraining+availableTesting+availableUndefined));; 1122 eventCounts[cls].nTestingEventsRequested = Int_t(0);; 1123 }; 1124 else if(eventCounts[cls].TrainTestSplitRequested != 0.0) Log() << kFATAL << Form(""The option TrainTestSplit_<class> has to be in range (0, 1] but is set to %f."",eventCounts[cls].TrainTestSplitRequested) << Endl;; 1125 Int_t requestedTraining = Int_t(eventCounts[cls].nTrainingEventsRequested * presel_scale);; 1126 Int_t requestedTesting = Int_t(eventCounts[cls].nTestingEventsRequested * presel_scale);; 1127 ; 1128 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""events in training trees : "" << availableTraining << Endl;; 1129 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""events in testing trees : "" << availableTesting << Endl;; 1130 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""events in unspecified trees : "" << availableUndefined << Endl;; 1131 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""requested for training : "" << requestedTraining << Endl;; 1132 ; 1133 if(presel_scale<1); 1134 Log() << "" ( "" << eventCounts[cls].nTrainingEventsRequested; 1135 << "" * "" << presel_scale << "" preselection efficiency)"" << Endl;; 1136 else; 1137 Log() << Endl;; 1138 Log() << kDEBUG << ""requested for testing : "" << requestedTesting;; 1139 if(presel_scale<1); 1140 Log() << "" ( "" << eventCounts[cls].nTestingEventsRequested; 1141 << "" * "" << presel_scale << "" preselection efficiency)"" << Endl;; 1142 else; 1143 Log() << Endl;; 1144 ; 1145 // nomenclature r = available training; 1146 // s = available testing; 1147 // u = available undefined; 1148 // R = requested training; 1149 // S = requested testing; 1150 // nR = to be used to select training events; 1151 // nS = to be used to select test eve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataSetFactory_8cxx_source.html:49682,test,testing,49682,doc/master/DataSetFactory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html,1,['test'],['testing']
Testability,or numeric event generator algorithms; RooAbsOptTestStatistic Abstract base class for optimized test statistics; RooAbsPdf Abstract PDF with normalization support; RooAbsPdf::GenSpec Generation specification; RooAbsProxy Abstract proxy interface; RooAbsReal Abstract real-valued variable; RooAbsRealLValue Abstract modifiable real-valued object; RooAbsRootFinder Abstract interface for 1-dim real-valued function root finders; RooAbsSelfCachedPdf Abstract base class for self-caching p.d.f.s; RooAbsSelfCachedReal Abstract base class for self-caching functions; RooAbsString Abstract string-valued variable; RooAbsStudy Abstract base class for RooStudyManager modules; RooAbsTestStatistic Abstract base class for real-valued test statistics; RooAcceptReject Context for generating a dataset from a PDF; RooAdaptiveGaussKronrodIntegrator1D 1-dimensional adaptive Gauss-Kronrod numerical integration engine; RooAdaptiveIntegratorND N-dimensional adaptive integration (interface to MathCore integrator); RooAddGenContext Specialized context for generating a dataset from a RooAddPdf; RooAddModel Resolution model representing a sum of resolution models; RooAddPdf PDF representing a sum of PDFs; RooAddition Sum of RooAbsReal objects; RooArgList Ordered list of RooAbsArg objects; RooArgProxy Abstract proxy for RooAbsArg objects; RooArgSet Set of RooAbsArg objects; RooArgusBG Argus background shape PDF; RooBCPEffDecay B Mixing decay PDF; RooBCPGenDecay B decay time distribution with CP violation; RooBDecay P.d.f of general description of B decay time distribution; RooBMixDecay B Mixing decay PDF; RooBernstein Bernstein polynomial PDF; RooBifurGauss Bifurcated Gaussian PDF; RooBinIntegrator 1-dimensional numerical integration engine; RooBinnedGenContext Specialized context for generating a dataset from a binned pdf; RooBinning Generic binning specification; RooBinningCategory RealVar-to-Category function defined by bin boundaries on input var; RooBlindTools Root implementation of BlindTools,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ClassIndex.html:26397,test,test,26397,root/html532/ClassIndex.html,https://root.cern,https://root.cern/root/html532/ClassIndex.html,4,['test'],['test']
Testability,or numeric event generator algorithms; RooAbsOptTestStatistic Abstract base class for optimized test statistics; RooAbsPdf Abstract PDF with normalization support; RooAbsPdf::GenSpec Generation specification; RooAbsProxy Abstract proxy interface; RooAbsReal Abstract real-valued variable; RooAbsRealLValue Abstract modifiable real-valued object; RooAbsRootFinder Abstract interface for 1-dim real-valued function root finders; RooAbsSelfCachedPdf Abstract base class for self-caching p.d.f.s; RooAbsSelfCachedReal Abstract base class for self-caching functions; RooAbsString Abstract string-valued variable; RooAbsStudy Abstract base class for RooStudyManager modules; RooAbsTestStatistic Abstract base class for real-valued test statistics; RooAcceptReject Context for generating a dataset from a PDF; RooAdaptiveGaussKronrodIntegrator1D 1-dimensional adaptive Gauss-Kronrod numerical integration engine; RooAdaptiveIntegratorND N-dimensional adaptive integration (interface to MathCore integrator); RooAddGenContext Specialized context for generating a dataset from a RooAddPdf; RooAddModel Resolution model representing a sum of resolution models; RooAddPdf PDF representing a sum of PDFs; RooAddition Sum of RooAbsReal objects; RooArgList Ordered list of RooAbsArg objects; RooArgProxy Abstract proxy for RooAbsArg objects; RooArgSet Set of RooAbsArg objects; RooArgusBG Argus background shape PDF; RooBCPEffDecay B Mixing decay PDF; RooBCPGenDecay B decay time distribution with CP violation; RooBDecay P.d.f of general description of B decay time distribution; RooBMixDecay B Mixing decay PDF; RooBernstein Bernstein polynomial PDF; RooBifurGauss Bifurcated Gaussian PDF; RooBinning Generic binning specification; RooBinningCategory RealVar-to-Category function defined by bin boundaries on input var; RooBlindTools Root implementation of BlindTools; RooBreitWigner Breit Wigner PDF; RooBrentRootFinder Abstract interface for 1-dim real-valued function root finders; RooBukinPdf Variation of No,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ClassIndex.html:26022,test,test,26022,root/html530/ClassIndex.html,https://root.cern,https://root.cern/root/html530/ClassIndex.html,1,['test'],['test']
Testability,"or the connection. In addition, several parameters can be specified in url after ""?"" symbol:; timeout=N n is connect timeout is seconds; socket=socketname socketname should be name of Unix socket, used; for connection; multi_statements tell the server that the client may send multiple; statements in a single string (separated by ;);; multi_results tell the server that the client can handle multiple; result sets from multiple-statement executions or; stored procedures; reconnect=0|1 enable or disable automatic reconnection to the server; if the connection is found to have been lost; compress use the compressed client/server protocol; cnf_file=filename Read options from the named option file instead of; from my.cnf; cnf_group=groupname Read options from the named group from my.cnf or the; file specified with cnf_file option; If several parameters are specified, they should be separated by ""&"" symbol; Example of connection argument:; TSQLServer::Connect(""mysql://host.domain/test?timeout=10&multi_statements"");. ~TMySQLServer(); Close connection to MySQL DB server. void Close(Option_t* opt = """"); Close connection to MySQL DB server. TSQLResult * Query(const char* sql); Execute SQL command. Result object must be deleted by the user.; Returns a pointer to a TSQLResult object if successful, 0 otherwise.; The result object must be deleted by the user. Bool_t Exec(const char* sql); Execute SQL command which does not produce any result sets.; Returns kTRUE if successful. Int_t SelectDataBase(const char* dbname); Select a database. Returns 0 if successful, non-zero otherwise. TSQLResult * GetDataBases(const char* wild = 0); List all available databases. Wild is for wildcarding ""t%"" list all; databases starting with ""t"".; Returns a pointer to a TSQLResult object if successful, 0 otherwise.; The result object must be deleted by the user. TSQLResult * GetTables(const char* dbname, const char* wild = 0); List all tables in the specified database. Wild is for wildcarding; ""t%"" list a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMySQLServer.html:9927,test,test,9927,root/html528/TMySQLServer.html,https://root.cern,https://root.cern/root/html528/TMySQLServer.html,6,['test'],['test']
Testability,"or the current state.; 2872 ; 2873void TGeoManager::InspectState() const; 2874{; 2875 GetCurrentNavigator()->InspectState();; 2876}; 2877 ; 2878////////////////////////////////////////////////////////////////////////////////; 2879/// Get path to the current node in the form /node0/node1/...; 2880 ; 2881const char *TGeoManager::GetPath() const; 2882{; 2883 return GetCurrentNavigator()->GetPath();; 2884}; 2885 ; 2886////////////////////////////////////////////////////////////////////////////////; 2887/// Get total size of geometry in bytes.; 2888 ; 2889Int_t TGeoManager::GetByteCount(Option_t * /*option*/); 2890{; 2891 Int_t count = 0;; 2892 TIter next(fVolumes);; 2893 TGeoVolume *vol;; 2894 while ((vol = (TGeoVolume *)next())); 2895 count += vol->GetByteCount();; 2896 TIter next1(fMatrices);; 2897 TGeoMatrix *matrix;; 2898 while ((matrix = (TGeoMatrix *)next1())); 2899 count += matrix->GetByteCount();; 2900 TIter next2(fMaterials);; 2901 TGeoMaterial *mat;; 2902 while ((mat = (TGeoMaterial *)next2())); 2903 count += mat->GetByteCount();; 2904 TIter next3(fMedia);; 2905 TGeoMedium *med;; 2906 while ((med = (TGeoMedium *)next3())); 2907 count += med->GetByteCount();; 2908 if (fgVerboseLevel > 0); 2909 Info(""GetByteCount"", ""Total size of logical tree : %i bytes"", count);; 2910 return count;; 2911}; 2912 ; 2913////////////////////////////////////////////////////////////////////////////////; 2914/// Make a default painter if none present. Returns pointer to it.; 2915 ; 2916TVirtualGeoPainter *TGeoManager::GetGeomPainter(); 2917{; 2918 if (!fPainter) {; 2919 const char *kind = gEnv->GetValue(""GeomPainter.Name"", """");; 2920 if (!kind || !*kind); 2921 kind = (gROOT->IsWebDisplay() && !gROOT->IsWebDisplayBatch()) ? ""web"" : ""root"";; 2922 if (auto h = gROOT->GetPluginManager()->FindHandler(""TVirtualGeoPainter"", kind)) {; 2923 if (h->LoadPlugin() == -1) {; 2924 Error(""GetGeomPainter"", ""could not load plugin for %s geo_painter"", kind);; 2925 return nullptr;; 2926 }; 2927 fPainter ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:104724,log,logical,104724,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['log'],['logical']
Testability,"or this interface is that we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IntervalCalculator(); static TClass*Class(); virtual Double_tConfidenceLevel() const; virtual RooStats::ConfInterval*GetInterval() const; virtual TClass*IsA() const; RooStats::IntervalCalculator&operator=(const RooStats::IntervalCalculator&); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetData(RooAbsData&); virtual voidSetModel(const RooStats::ModelConfig&); virtual voidSetTestSize(Double_t size); virtual voidShowMembers(TMemberInspector&); virtual Double_tSize() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IntervalCalculator(); {}. ConfInterval* GetInterval() const; Main interface to get a ConfInterval, pure virtual. Double_t Size() const; Get the size of the test (eg. rate of Type I error). Double_t ConfidenceLevel() const; Get the Confidence level for the test. void SetData(RooAbsData& ); Set the DataSet ( add to the the workspace if not already there ?). void SetModel(const RooStats::ModelConfig& ); Set the Model. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( e.g. 0.05 for a 95% Confidence Interval). void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (e.g. 0.95 for a 95% Confidence Interval). » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id$ » Last generated: 2015-09-08 17:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__IntervalCalculator.html:2416,test,test,2416,root/html534/RooStats__IntervalCalculator.html,https://root.cern,https://root.cern/root/html534/RooStats__IntervalCalculator.html,3,['test'],['test']
Testability,"or this pdf to 'resetValue'. Bool_t checkObservables(const RooArgSet* nset) const; Check if PDF is valid for given normalization set.; Coeffient and PDF must be non-overlapping, but pdf-coefficient; pairs may overlap each other. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const. void getCompIntList(const RooArgSet* nset, const RooArgSet* iset, RooAddModel::pRooArgList& compIntList, Int_t& code, const char* isetRangeName) const; Check if this configuration was created before. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integral defined by given scenario code. Double_t expectedEvents(const RooArgSet* nset) const; Return the number of expected events, which is either the sum of all coefficients; or the sum of the components extended terms. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of observables; for interpretation of fraction coefficients. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of fraction coefficients. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return specialized context to efficiently generate toy events from RooAddPdfs. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Direct generation is safe if all components say so. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Return pseud-code that indicates if all components can do internal generation (1) or not (0). void generateEvent(Int_t code); This function should never be called as RooAddModel implements a custom generator context. void printMetaArgs(ostream& os) const; Customiz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAddModel.html:47188,test,test,47188,root/html528/RooAddModel.html,https://root.cern,https://root.cern/root/html528/RooAddModel.html,6,['test'],['test']
Testability,"or"");; 18000 return -1;; 18001 }; 18002 ; 18003 /* Reset the previous responses */; 18004 conn->data_len = 0;; 18005 ; 18006 /* Implementation of API function for HTTP clients */; 18007 save_timeout = conn->dom_ctx->config[REQUEST_TIMEOUT];; 18008 ; 18009 if (timeout >= 0) {; 18010 mg_snprintf(conn, NULL, txt, sizeof(txt), ""%i"", timeout);; 18011 new_timeout = txt;; 18012 } else {; 18013 new_timeout = NULL;; 18014 }; 18015 ; 18016 conn->dom_ctx->config[REQUEST_TIMEOUT] = new_timeout;; 18017 ret = get_response(conn, ebuf, ebuf_len, &err);; 18018 conn->dom_ctx->config[REQUEST_TIMEOUT] = save_timeout;; 18019 ; 18020 /* TODO: here, the URI is the http response code */; 18021 conn->request_info.local_uri_raw = conn->request_info.request_uri;; 18022 conn->request_info.local_uri = conn->request_info.local_uri_raw;; 18023 ; 18024 /* TODO (mid): Define proper return values - maybe return length?; 18025 * For the first test use <0 for error and >0 for OK */; 18026 return (ret == 0) ? -1 : +1;; 18027}; 18028 ; 18029 ; 18030struct mg_connection *; 18031mg_download(const char *host,; 18032 int port,; 18033 int use_ssl,; 18034 char *ebuf,; 18035 size_t ebuf_len,; 18036 const char *fmt,; 18037 ...); 18038{; 18039 struct mg_connection *conn;; 18040 va_list ap;; 18041 int i;; 18042 int reqerr;; 18043 ; 18044 if (ebuf_len > 0) {; 18045 ebuf[0] = '\0';; 18046 }; 18047 ; 18048 va_start(ap, fmt);; 18049 ; 18050 /* open a connection */; 18051 conn = mg_connect_client(host, port, use_ssl, ebuf, ebuf_len);; 18052 ; 18053 if (conn != NULL) {; 18054 i = mg_vprintf(conn, fmt, ap);; 18055 if (i <= 0) {; 18056 mg_snprintf(conn,; 18057 NULL, /* No truncation check for ebuf */; 18058 ebuf,; 18059 ebuf_len,; 18060 ""%s"",; 18061 ""Error sending request"");; 18062 } else {; 18063 /* make sure the buffer is clear */; 18064 conn->data_len = 0;; 18065 get_response(conn, ebuf, ebuf_len, &reqerr);; 18066 ; 18067 /* TODO: here, the URI is the http response code */; 18068 conn->request_info.local_uri = conn->re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:535248,test,test,535248,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['test'],['test']
Testability,"or"");; 18001 return -1;; 18002 }; 18003 ; 18004 /* Reset the previous responses */; 18005 conn->data_len = 0;; 18006 ; 18007 /* Implementation of API function for HTTP clients */; 18008 save_timeout = conn->dom_ctx->config[REQUEST_TIMEOUT];; 18009 ; 18010 if (timeout >= 0) {; 18011 mg_snprintf(conn, NULL, txt, sizeof(txt), ""%i"", timeout);; 18012 new_timeout = txt;; 18013 } else {; 18014 new_timeout = NULL;; 18015 }; 18016 ; 18017 conn->dom_ctx->config[REQUEST_TIMEOUT] = new_timeout;; 18018 ret = get_response(conn, ebuf, ebuf_len, &err);; 18019 conn->dom_ctx->config[REQUEST_TIMEOUT] = save_timeout;; 18020 ; 18021 /* TODO: here, the URI is the http response code */; 18022 conn->request_info.local_uri_raw = conn->request_info.request_uri;; 18023 conn->request_info.local_uri = conn->request_info.local_uri_raw;; 18024 ; 18025 /* TODO (mid): Define proper return values - maybe return length?; 18026 * For the first test use <0 for error and >0 for OK */; 18027 return (ret == 0) ? -1 : +1;; 18028}; 18029 ; 18030 ; 18031struct mg_connection *; 18032mg_download(const char *host,; 18033 int port,; 18034 int use_ssl,; 18035 char *ebuf,; 18036 size_t ebuf_len,; 18037 const char *fmt,; 18038 ...); 18039{; 18040 struct mg_connection *conn;; 18041 va_list ap;; 18042 int i;; 18043 int reqerr;; 18044 ; 18045 if (ebuf_len > 0) {; 18046 ebuf[0] = '\0';; 18047 }; 18048 ; 18049 va_start(ap, fmt);; 18050 ; 18051 /* open a connection */; 18052 conn = mg_connect_client(host, port, use_ssl, ebuf, ebuf_len);; 18053 ; 18054 if (conn != NULL) {; 18055 i = mg_vprintf(conn, fmt, ap);; 18056 if (i <= 0) {; 18057 mg_snprintf(conn,; 18058 NULL, /* No truncation check for ebuf */; 18059 ebuf,; 18060 ebuf_len,; 18061 ""%s"",; 18062 ""Error sending request"");; 18063 } else {; 18064 /* make sure the buffer is clear */; 18065 conn->data_len = 0;; 18066 get_response(conn, ebuf, ebuf_len, &reqerr);; 18067 ; 18068 /* TODO: here, the URI is the http response code */; 18069 conn->request_info.local_uri = conn->re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:535281,test,test,535281,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['test'],['test']
Testability,"or(); {}. Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void SetData(RooAbsData& data); Set the DataSet if not already there. { fData = &data; }. void SetPdf(RooAbsPdf& pdf); Set the Pdf if not already there. { fPdf = &pdf; }. void SetPriorPdf(RooAbsPdf& pdf); Set the Prior Pdf if not already there. { fPriorPdf = &pdf; }. void SetParameters(const RooArgSet& set); specify the parameters of interest in the interval. { fPOI.removeAll(); fPOI.add(set); }. void SetChainParameters(const RooArgSet& set); specify the parameters to store in the Markov chain; By default all the parameters are stored. { fChainParams.removeAll(); fChainParams.add(set); }. void SetNuisanceParameters(const RooArgSet& set); specify the nuisance parameters (eg. the rest of the parameters). {fNuisParams.removeAll(); fNuisParams.add(set);}. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size;}. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. void SetProposalFunction(RooStats::ProposalFunction& proposalFunction); set the proposal function for suggesting new points for the MCMC. { fPropFunc = &proposalFunction; }. void SetNumIters(Int_t numIters); set the number of iterations to run the metropolis algorithm. { fNumIters = numIters; }. void SetNumBurnInSteps(Int_t numBurnInSteps); set the number of steps in the chain to discard as burn-in,; starting from the first. { fNumBurnInSteps = numBurnInSteps; }. void SetNumBins(Int_t numBins); set the number of bins to create for each axis when constructing the interval. { fNumBins = numBins; }. void SetAxes(RooArgList& axes); set which variables to put on each axis. { fAxes = &axes; }. void SetUseKeys(Bool_t useKeys); set whether to use kernel estima",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__MCMCCalculator.html:10094,test,test,10094,root/html532/RooStats__MCMCCalculator.html,https://root.cern,https://root.cern/root/html532/RooStats__MCMCCalculator.html,1,['test'],['test']
Testability,"or(const char* errmsg); TProofOutputFile&operator=(const TProofOutputFile&); voidSetDir(const char* dir, Bool_t raw = kFALSE); voidSetFileName(const char* name); voidSetMerged(Bool_t merged = kTRUE); voidSetWorkerOrdinal(const char* ordinal); voidUnlink(const char* path). Data Members; public:. enum ERunType { kMerge; kDataset; };; enum ETypeOpt { kRemote; kLocal; kCreate; kRegister; kOverwrite; kVerify; };; enum EStatusBits { kOutputFileNameSet; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TFileCollection*fDataSetInstance of the file collection in 'dataset' mode; TStringfDirname of the directory to be exported; TStringfFileName; Bool_tfIsLocalkTRUE if the file is in the sandbox; TStringfLocalHostHost where the file was created; Bool_tfMerged; TFileMerger*fMergerInstance of the file merger in 'merge' mode; TStringfOptionsAnchoroptions and anchor string including delimiters, e.g. ""?myopts#myanchor""; TStringfOutputFileName; TStringfRawDirname of the local directory where to create the file; TProofOutputFile::ERunTypefRunTypeType of run (see enum ERunType); UInt_tfTypeOptOption (see enum ETypeOpt); TStringfWorkerOrdinal. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofOutputFile(const char* path, TProofOutputFile::ERunType type, UInt_t opt = kRemote, const char* dsname = 0); Main constructor. TProofOutputFile(const char* path, const char* option = ""M"", const char* dsname = 0); Constructor with the old signature, kept for convenience and backard compatibility.; Options:; 'M' merge: finally merge the created files; 'L' local: copy locally the files before merging (implies 'M'); 'D' dataset: create a TFileCollection; 'R' ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofOutputFile.html:7096,sandbox,sandbox,7096,root/html530/TProofOutputFile.html,https://root.cern,https://root.cern/root/html530/TProofOutputFile.html,2,['sandbox'],['sandbox']
Testability,"or(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TMVA::MsgLogger&Log() const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfAbsTolabsolute tolerance deviation; Double_t (*)(Double_t)fGetRootVal; TMVA::MsgLogger*fLogger! message logger; Int_tfMaxItermaximum number of iterations; Double_tfRootMaxmaximum root value; Double_tfRootMinminimum root value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RootFinder(Double_t (*)(Double_t) rootVal, Double_t rootMin, Double_t rootMax, Int_t maxIterations = 100, Double_t absTolerance = 0.0); constructor. ~RootFinder( void ); destructor. Double_t Root(Double_t refValue); Root finding using Brents algorithm; taken from CERNLIB function RZERO. RootFinder(Double_t (*)(Double_t) rootVal, Double_t rootMin, Double_t rootMax, Int_t maxIterations = 100, Double_t absTolerance = 0.0). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: RootFinder.h 39395 2011-05-26 10:05:54Z moneta $ » Last generated: 2011-07-04 15:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__RootFinder.html:5430,log,logger,5430,root/html530/TMVA__RootFinder.html,https://root.cern,https://root.cern/root/html530/TMVA__RootFinder.html,1,['log'],['logger']
Testability,"or, Entries= 0, Total sum= 13.7968; TH1.Print Name = TrainingHistory_PyKeras_LSTM_'accuracy', Entries= 0, Total sum= 14.2691; TH1.Print Name = TrainingHistory_PyKeras_LSTM_'loss', Entries= 0, Total sum= 10.8696; TH1.Print Name = TrainingHistory_PyKeras_LSTM_'val_accuracy', Entries= 0, Total sum= 14.125; TH1.Print Name = TrainingHistory_PyKeras_LSTM_'val_loss', Entries= 0, Total sum= 11.0066; Factory : === Destroy and recreate all methods via weight files for testing ===; : ; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_DNN.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_PyKeras_LSTM.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_BDTG.weights.xml␛[0m; nthreads = 4; Factory : ␛[1mTest all methods␛[0m; Factory : Test method: TMVA_LSTM for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 800; : ; TMVA_LSTM : [dataset] : Evaluation of TMVA_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.0529 sec ; Factory : Test method: TMVA_DNN for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 800; : ; TMVA_DNN : [dataset] : Evaluation of TMVA_DNN on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.0218 sec ; Factory : Test method: PyKeras_LSTM for Classification performance; : ; : Setting up tf.keras; : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Disabled TF eager execution when evaluating model ; : Loading Keras Model ; : Loaded model from file: trained_model_LSTM.h5; PyKeras_LSTM : [dataset] : Evaluation of PyKeras_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.249 sec ; Factory : Test method: BDTG for Classification perf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html:52811,test,testing,52811,doc/master/TMVA__RNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html,1,['test'],['testing']
Testability,"or. Bool_t GetFileInCmd(const char* cmd, TString& fn); Static method to extract the filename (if any) form a CINT command.; Returns kTRUE and the filename in 'fn'; returns kFALSE if not found or not; appliable. Int_t Exec(const char* cmd, Bool_t plusMaster = kFALSE); Send command to be executed on the PROOF master and/or slaves.; If plusMaster is kTRUE then exeucte on slaves and master too.; Command can be any legal command line command. Commands like; "".x file.C"" or "".L file.C"" will cause the file file.C to be send; to the PROOF cluster. Returns -1 in case of error, >=0 in case of; succes. Int_t Exec(const char *cmd, ESlaves list, Bool_t plusMaster); Send command to be executed on the PROOF master and/or slaves.; Command can be any legal command line command. Commands like; "".x file.C"" or "".L file.C"" will cause the file file.C to be send; to the PROOF cluster. Returns -1 in case of error, >=0 in case of; succes. Int_t Exec(const char* cmd, const char* ord, Bool_t logtomacro = kFALSE); Send command to be executed on node of ordinal 'ord' (use ""0"" for master).; Command can be any legal command line command. Commands like; "".x file.C"" or "".L file.C"" will cause the file file.C to be send; to the PROOF cluster.; If logtomacro is TRUE the text result of the action is saved in the fMacroLog; TMacro, accessible via TMacro::GetMacroLog();; Returns -1 in case of error, >=0 in case of succes. Int_t SendCommand(const char* cmd, TProof::ESlaves list = kActive); Send command to be executed on the PROOF master and/or slaves.; Command can be any legal command line command, however commands; like "".x file.C"" or "".L file.C"" will not cause the file.C to be; transfered to the PROOF cluster. In that case use TProof::Exec().; Returns the status send by the remote server as part of the; kPROOF_LOGDONE message. Typically this is the return code of the; command on the remote side. Returns -1 in case of error. TString Getenv(const char* env, const char* ord = ""0""); Get value of environment v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:61976,log,logtomacro,61976,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,3,['log'],['logtomacro']
Testability,"or.C Palette coloring for histogram is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color) ;  hksimple.C Illustrates the advantages of a TH1K histogram ;  hlabels1.C 1-D histograms with alphanumeric labels ;  hlabels2.C 2-D histograms with alphanumeric labels ;  hlHisto1.CThis tutorial demonstrates how the highlight mechanism can be used on an histogram ;  hlHisto2.CThis tutorial demonstrates how the highlight mechanism can be used on an histogram ;  hlHisto3.CThis tutorial demonstrates how the highlight mechanism can be used on a ntuple ;  hlHisto4.CThis tutorial demonstrates how the highlight mechanism can be used on an histogram ;  hstack.C Example of stacked histograms: class THStack ;  hsum.C Histograms filled and drawn in a loop ;  hsumTimer.C Demo of Timers ;  legendautoplaced.C The legend can be placed automatically in the current pad in an empty space found at painting time ;  logscales.C Draw parametric functions with log scales ;  multicolor.C Use a THStack to show a 2-D hist with cells with different colors ;  ratioplot1.C Example creating a simple ratio plot of two histograms using the pois division option ;  ratioplot1.py Example creating a simple ratio plot of two histograms using the pois division option ;  ratioplot2.C Example of a fit residual plot ;  ratioplot2.py Example of a fit residual plot ;  ratioplot3.C Example which shows how you can get the graph of the lower plot and set the y axis range for it ;  ratioplot3.py Example which shows how you can get the graph of the lower plot and set the y axis range for it ;  ratioplot4.C Example that shows custom dashed lines on the lower plot, specified by a vector of floats ;  ratioplot4.py Example that shows custom dashed lines on the lower plot, specified by a vector of floats ;  ratioplot5.C Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors ;  ratiopl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:127490,log,log,127490,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['log'],['log']
Testability,or.cxx;  RootFinder.cxx;  SparseData.cxx;  SpecFuncCephes.cxx;  SpecFuncCephes.h;  SpecFuncCephesInv.cxx;  SpecFuncMathCore.cxx;  StdEngine.cxx;  TComplex.cxx;  TKDTree.cxx;  TKDTreeBinning.cxx;  TMath.cxx;  TRandom.cxx;  TRandom1.cxx;  TRandom2.cxx;  TRandom3.cxx;  TRandomGen.cxx;  triangle.c;  triangle.h;  TStatistic.cxx;  UnBinData.cxx;  ► test;  ► fit;  GaussFunction.h;  MinimizerTypes.h;  SparseDataComparer.cxx;  SparseFit3.cxx;  SparseFit4.cxx;  testFit.cxx;  testFitPerf.cxx;  testGraphFit.cxx;  testMinim.cxx;  testRooFit.cxx;  WrapperRooPdf.h;  binarySearchTime.cxx;  kDTreeTest.cxx;  newKDTreeTest.cxx;  stdsort.cxx;  stressGoFTest.cxx;  stressTF1.cxx;  stressTMath.cxx;  testAnalyticalIntegrals.cxx;  testBinarySearch.cxx;  testDistSampler.cxx;  testIntegration.cxx;  testIntegrationMultiDim.cxx;  testkdTreeBinning.cxx;  testMathRandom.cxx;  testRootFinder.cxx;  testSampleQuantiles.cxx;  testSortOrder.cxx;  testSpecFuncBeta.cxx;  testSpecFuncBetaI.cxx;  testSpecFuncErf.cxx;  testSpecFuncGamma.cxx;  testSpecFuncSiCi.cxx;  testTMath.cxx;  testTStatistic.cxx;  ► v7;  ► inc;  ► ROOT;  TFit.hxx;  ► mathmore;  ► inc;  ► Math;  ChebyshevApprox.h;  Derivator.h;  DistFuncMathMore.h;  GSLFunctionAdapter.h;  GSLIntegrator.h;  GSLMCIntegrator.h;  GSLMinimizer.h;  GSLMinimizer1D.h;  GSLMultiRootFinder.h;  GSLNLSMinimizer.h;  GSLQuasiRandom.h;  GSLRandom.h;  GSLRandomFunctions.h;  GSLRndmEngines.h;  GSLRootFinder.h;  GSLRootFinderDeriv.h;  GSLRootHelper.h;  GSLSimAnMinimizer.h;  GSLSimAnnealing.h;  IntegrationTypes.h;  InterpolationTypes.h;  Interpolator.h;  KelvinFunctions.h;  LinkDef.h;  LinkDef_Func.h;  LinkDef_RootFinding.h;  MCIntegrationTypes.h;  MCParameters.h;  MultiNumGradFunction.h;  MultiRootFinder.h;  ParamFunction.h;  PdfFuncMathMore.h;  Polynomial.h;  QuantFuncMathMore.h;  QuasiRandom.h;  RootFinderAlgorithms.h;  SpecFuncMathMore.h;  Vavilov.h;  VavilovAccurate.h;  VavilovAccurateCdf.h;  VavilovAccuratePdf.h;  VavilovAccurateQuantile.h;  VavilovFast.h;  ► src;  ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:46769,test,testSpecFuncGamma,46769,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,1,['test'],['testSpecFuncGamma']
Testability,or4D.h;  LorentzRotation.h;  LorentzVector.h;  Plane3D.h;  Point2D.h;  Point2Dfwd.h;  Point3D.h;  Point3Dfwd.h;  Polar2D.h;  Polar3D.h;  PositionVector2D.h;  PositionVector3D.h;  PtEtaPhiE4D.h;  PtEtaPhiM4D.h;  PxPyPzE4D.h;  PxPyPzM4D.h;  Quaternion.h;  Rotation3D.h;  RotationX.h;  RotationY.h;  RotationZ.h;  RotationZYX.h;  Transform3D.h;  Translation3D.h;  Vector2D.h;  Vector2Dfwd.h;  Vector3D.h;  Vector3Dfwd.h;  Vector4D.h;  Vector4Dfwd.h;  VectorUtil.h;  ► src;  3DConversions.cxx;  3DDistances.cxx;  AxisAngle.cxx;  AxisAngleXother.cxx;  BitReproducible.cxx;  Boost.cxx;  BoostX.cxx;  BoostY.cxx;  BoostZ.cxx;  EulerAngles.cxx;  GenVector_exception.cxx;  LorentzRotation.cxx;  Plane3D.cxx;  Quaternion.cxx;  QuaternionXaxial.cxx;  Rotation3D.cxx;  Rotation3DxAxial.cxx;  RotationZYX.cxx;  Transform3D.cxx;  Translation3D.cxx;  VectorUtil.cxx;  ► test;  coordinates3D.cxx;  coordinates4D.cxx;  CoordinateTraits.h;  rotationApplication.cxx;  RotationTraits.h;  stress2D.cxx;  stress3D.cxx;  testBoost.cxx;  testGenVector.cxx;  testIterator.cxx;  testVectorIO.cxx;  Track.h;  TrackLinkDef.h;  vectorOperation.cxx;  ► mathcore;  ► inc;  ► Fit;  BasicFCN.h;  BinData.h;  BinPoint.h;  Chi2FCN.h;  DataOptions.h;  DataRange.h;  DataVector.h;  DataVectorfwd.h;  FcnAdapter.h;  FitConfig.h;  FitResult.h;  Fitter.h;  FitUtil.h;  FitUtilParallel.h;  LogLikelihoodFCN.h;  ParameterSettings.h;  PoissonLikelihoodFCN.h;  SparseData.h;  UnBinData.h;  ► Math;  AdaptiveIntegratorMultiDim.h;  AllIntegrationTypes.h;  BasicMinimizer.h;  BrentMethods.h;  BrentMinimizer1D.h;  BrentRootFinder.h;  ChebyshevPol.h;  Delaunay2D.h;  DistFunc.h;  DistFuncMathCore.h;  DistSampler.h;  DistSamplerOptions.h;  Error.h;  Factory.h;  FitMethodFunction.h;  Functor.h;  GaussIntegrator.h;  GaussLegendreIntegrator.h;  GenAlgoOptions.h;  GoFTest.h;  IFunction.h;  IFunctionfwd.h;  IMinimizer1D.h;  Integrator.h;  IntegratorMultiDim.h;  IntegratorOptions.h;  IOptions.h;  IParamFunction.h;  IParamFunctionfwd.h;  IRootFinder,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:42911,test,testBoost,42911,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,2,['test'],['testBoost']
Testability,"or< Double_t > fParams;  The distribution parameters (e.g. fParams[0] = mean, fParams[1] = sigma for a Gaussian) ;  ; std::vector< std::vector< Double_t > > fSamples;  The input data. ;  ; Bool_t fTestSampleFromH0;  . #include <Math/GoFTest.h>; Member Enumeration Documentation. ◆ EDistribution. enum ROOT::Math::GoFTest::EDistribution. H0 distributions for using only with 1-sample tests. ; One should provide the distribution parameters otherwise the default values will be used . EnumeratorkUndefined ; kUserDefined Default value for non templated 1-sample test. Set with SetDistribution. . kGaussian For internal use only within the class's template constructor. . kLogNormal Gaussian distribution with default mean=0, sigma=1. . kExponential Lognormal distribution with default meanlog=0, sigmalog=1. ; Exponential distribution with default rate=1 . Definition at line 70 of file GoFTest.h. ◆ ETestType. enum ROOT::Math::GoFTest::ETestType. Goodness of Fit test types for using with the class's unary functions as a shorthand for the in-built methods. . EnumeratorkAD ; kAD2s Anderson-Darling Test. Default value. . kKS Anderson-Darling 2-Samples Test. . kKS2s Kolmogorov-Smirnov Test. ; Kolmogorov-Smirnov 2-Samples Test . Definition at line 85 of file GoFTest.h. ◆ EUserDistribution. enum ROOT::Math::GoFTest::EUserDistribution. User input distribution option. . EnumeratorkCDF ; kPDF Input distribution is a CDF : cumulative distribution function. ; Input distribution is a PDF (Default value) . Definition at line 79 of file GoFTest.h. Constructor & Destructor Documentation. ◆ GoFTest() [1/6]. ROOT::Math::GoFTest::GoFTest ; (; size_t ; sample1Size, . const Double_t * ; sample1, . size_t ; sample2Size, . const Double_t * ; sample2 . ). Constructor for 2-samples tests. ; Definition at line 134 of file GoFTest.cxx. ◆ GoFTest() [2/6]. ROOT::Math::GoFTest::GoFTest ; (; size_t ; sampleSize, . const Double_t * ; sample, . EDistribution ; dist = kUndefined, . const std::vector< double > & ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GoFTest.html:8599,test,test,8599,doc/master/classROOT_1_1Math_1_1GoFTest.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GoFTest.html,1,['test'],['test']
Testability,"or<Double_t>& ); sort vector. void UsefulSortAscending(vector<Double_t>& ); sort vector. Int_t GetIndexMaxElement(vector<Double_t>& ); find index of maximum entry in vector. Int_t GetIndexMinElement(vector<Double_t>& ); find index of minimum entry in vector. Bool_t ContainsRegularExpression(const TString& s); check if regular expression; helper function to search for ""$!%^&()'<>?= "" in a string. TString ReplaceRegularExpressions(const TString& s, const TString& replace = ""+""); replace regular expressions; helper function to remove all occurences ""$!%^&()'<>?= "" from a string; and replace all ::,$,*,/,+,- with _M_,_S_,_T_,_D_,_P_,_M_ respectively. const TString& Color(const TString& ); human readable color strings. void FormattedOutput(const vector<Double_t>& , const vector<TString>& , const TString titleVars, const TString titleValues, TMVA::MsgLogger& logger, TString format = ""%+1.3f""); formatted output of simple table. void FormattedOutput(const TMatrixD& , const vector<TString>& , TMVA::MsgLogger& logger); formatted output of matrix (with labels). void FormattedOutput(const TMatrixD& , const vector<TString>& vert, const vector<TString>& horiz, TMVA::MsgLogger& logger); formatted output of matrix (with labels). TString GetXTitleWithUnit(const TString& title, const TString& unit); histogramming utility. TString GetYTitleWithUnit(const TH1& h, const TString& unit, Bool_t normalised); histogramming utility. void WriteFloatArbitraryPrecision(Float_t val, ostream& os); writes a float value with the available precision to a stream. void ReadFloatArbitraryPrecision(Float_t& val, istream& is); reads a float value with the available precision from a stream. Bool_t HasAttr(void* node, const char* attrname); add attribute from xml. void ReadAttr(void* node, const char* attrname, TString& value); add attribute from xml. void AddAttr(void* node, const char* attrname, const char* value); add attribute to node. void* AddChild(void* parent, const char* childname, const char* cont",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__Tools.html:9434,log,logger,9434,root/html528/TMVA__Tools.html,https://root.cern,https://root.cern/root/html528/TMVA__Tools.html,6,['log'],['logger']
Testability,"or= new double[ fDim ];; 304 ; 305 if ( HasBinEdges() ); 306 fpTmpBinEdgeVector = new double[ fDim ];; 307 ; 308 return *this;; 309 }; 310 ; 311 ; 312 /**; 313 preallocate a data set with given size , dimension and error type (to get the full point size); 314 If the data set already exists and it is having the compatible point size space for the new points; 315 is created in the data sets, while if not compatible the old data are erased and new space of; 316 new size is allocated.; 317 (i.e if exists initialize is equivalent to a resize( NPoints() + maxpoints); 318 */; 319 ; 320 void BinData::Append( unsigned int newPoints, unsigned int dim , ErrorType err ); 321 {; 322 assert( !fWrapped );; 323 assert( fMaxPoints == 0 || fWrapped == fData.empty() );; 324 ; 325 assert( kValueError == fErrorType || kCoordError == fErrorType ||; 326 kAsymError == fErrorType || kNoError == fErrorType );; 327 assert( fMaxPoints == 0 || fDataError.empty() || &fDataError.front() == fDataErrorPtr );; 328 assert( fMaxPoints == 0 || fDataErrorHigh.empty() || &fDataErrorHigh.front() == fDataErrorHighPtr );; 329 assert( fMaxPoints == 0 || fDataErrorLow.empty() || &fDataErrorLow.front() == fDataErrorLowPtr );; 330 assert( fMaxPoints == 0 || fDataErrorLow.empty() == fDataErrorHigh.empty() );; 331 assert( fMaxPoints == 0 || fData.empty() || &fData.front() == fDataPtr );; 332 ; 333 FitData::Append( newPoints, dim );; 334 ; 335 fErrorType = err;; 336 ; 337 InitDataVector( );; 338 InitializeErrors( );; 339 }; 340 ; 341 ; 342 /**; 343 apply a Log transformation of the data values; 344 can be used for example when fitting an exponential or gaussian; 345 Transform the data in place need to copy if want to preserve original data; 346 The data sets must not contain negative values. IN case it does,; 347 an empty data set is returned; 348 */; 349 BinData & BinData::LogTransform(); 350 { // apply log transform on the bin data values; 351 ; 352 if ( fWrapped ); 353 {; 354 UnWrap();; 355 }; 356 ; 357 if ( kNo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:9666,assert,assert,9666,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['assert'],['assert']
Testability,"or[17]! GL color array; TGLPShapeRef*fFirstPSRef! pointer to first reference; UInt_tfID! unique physical ID within containing scene; Bool_tfInvertedWind! face winding TODO: can get directly from fTransform?; Bool_tfIsScaleForRnr! cache; const TGLLogicalShape*fLogicalShape! the associated logical shape; TGLPhysicalShape::EManipfManip! permitted manipulation bitflags - see EManip; Bool_tfModified! has been modified - retain across scene rebuilds; TGLPhysicalShape*fNextPhysical! pointer to next replica; UChar_tfSelected! selected state; TGLMatrixfTransform! transform (placement) of physical instance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const TGLMatrix& transform, Bool_t invertedWind, const Float_t[4] rgba); Construct a physical shape using arguments:; ID - unique drawable id.; logicalShape - bound logical shape; transform - transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const double* transform, Bool_t invertedWind, const Float_t[4] rgba); Construct a physical shape using arguments:; id - unique drawable id.; logicalShape - bound logical shape; transform - 16 Double_t component transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. ~TGLPhysicalShape(); Destroy the physical shape. void AddReference(TGLPShapeRef* ref); Add reference ref. void RemoveReference(TGLPShapeRef* ref); Remove reference ref. void Modified(); Call this after modifying the physical so that the information; can be propagated to the object referencing it. void UpdateBoundingBox(); Update our internal bounding box (in global frame). void InitColor(const Float_t[4] rgba); Initialise the colors, using basic RGBA diffuse material color sup",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLPhysicalShape.html:5061,log,logicalShape,5061,root/html602/TGLPhysicalShape.html,https://root.cern,https://root.cern/root/html602/TGLPhysicalShape.html,6,['log'],"['logical', 'logicalShape']"
Testability,"ord. In addition, in order to inform canvases that OpenGL should be used to render 3D representations, the following option should be set: gStyle->SetCanvasPreferGL(true);; General information: plot types and supported options; The following types of plots are provided:; For lego plots the supported options are:. Option Description . ""GLLEGO"" Draw a lego plot. It works also for TH2Poly. . ""GLLEGO2"" Bins with color levels. . ""GLLEGO3"" Cylindrical bars. . Lego painter in cartesian supports logarithmic scales for X, Y, Z. In polar only Z axis can be logarithmic, in cylindrical only Y.; For surface plots (TF2 and TH2) the supported options are:. Option Description . ""GLSURF"" Draw a surface. . ""GLSURF1"" Surface with color levels . ""GLSURF2"" The same as ""GLSURF1"" but without polygon outlines. . ""GLSURF3"" Color level projection on top of plot (works only in cartesian coordinate system). . ""GLSURF4"" Same as ""GLSURF"" but without polygon outlines. . The surface painting in cartesian coordinates supports logarithmic scales along X, Y, Z axis. In polar coordinates only the Z axis can be logarithmic, in cylindrical coordinates only the Y axis.; Additional options to SURF and LEGO - Coordinate systems:. Option Description . "" "" Default, cartesian coordinates system. . ""POL"" Polar coordinates system. . ""CYL"" Cylindrical coordinates system. . ""SPH"" Spherical coordinates system. . TH3 as color boxes; The supported option is:. Option Description . ""GLCOL"" H3 is drawn using semi-transparent colored boxes. See $ROOTSYS/tutorials/gl/glvox1.C. . TH3 as boxes (spheres); The supported options are:. Option Description . ""GLBOX"" TH3 as a set of boxes, size of box is proportional to bin content. . ""GLBOX1"" The same as ""glbox"", but spheres are drawn instead of boxes. . TH3 as iso-surface(s); The supported option is:. Option Description . ""GLISO"" TH3 is drawn using iso-surfaces. . TF3 (implicit function); The supported option is:. Option Description . ""GL"" Draw a TF3. . Parametric surfaces; $RO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:124480,log,logarithmic,124480,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['log'],['logarithmic']
Testability,"ordErrorVector );; 416 assert( fErrorType == kCoordError || fErrorType == kAsymError );; 417 ; 418 for ( unsigned int i=0; i < fDim; i++ ); 419 {; 420 assert( fCoordErrorsPtr[i] );; 421 assert( fCoordErrors.empty() || &fCoordErrors[i].front() == fCoordErrorsPtr[i] );; 422 ; 423 fpTmpCoordErrorVector[i] = fCoordErrorsPtr[i][ipoint];; 424 }; 425 ; 426 return fpTmpCoordErrorVector;; 427 }; 428 ; 429 ; 430 /**; 431 retrieve in a single call a pointer to the coordinate data, value and inverse error for; 432 the given fit point.; 433 To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; 434 for the error.; 435 */; 436 // not threadsafe, to be replaced with never constructs!; 437 // for example: just return std::array or std::vector, there's; 438 // is going to be only minor overhead in c++11.; 439 const double* GetPoint( unsigned int ipoint, double & value, double & invError ) const; 440 {; 441 assert( ipoint < fMaxPoints );; 442 assert( fErrorType == kNoError || fErrorType == kValueError );; 443 ; 444 double e = Error( ipoint );; 445 ; 446 if (fWrapped); 447 invError = e;; 448 else; 449 invError = ( e != 0.0 ) ? 1.0/e : 1.0;; 450 ; 451 return GetPoint( ipoint, value );; 452 }; 453 ; 454 /**; 455 Retrieve the errors on the point (coordinate and value) for the given fit point; 456 It must be called only when the coordinate errors are stored otherwise it will produce an; 457 assert.; 458 */; 459 // not threadsafe, to be replaced with never constructs!; 460 // for example: just return std::array or std::vector, there's; 461 // is going to be only minor overhead in c++11.; 462 const double* GetPointError(unsigned int ipoint, double & errvalue) const; 463 {; 464 assert( ipoint < fMaxPoints );; 465 assert( fErrorType == kCoordError || fErrorType == kAsymError );; 466 ; 467 errvalue = Error( ipoint );; 468 return CoordErrors( ipoint );; 469 }; 470 ; 471 /**; 472 Get errors on the point (coordinate errors and asymmetric value errors) for ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8h_source.html:15586,assert,assert,15586,doc/master/BinData_8h_source.html,https://root.cern,https://root.cern/doc/master/BinData_8h_source.html,2,['assert'],['assert']
Testability,"ordErrors[0][ fNPoints ] = ex;; 465 fDataError[ fNPoints ] = ey;; 466 ; 467 FitData::Add( x );; 468 fSumContent += y;; 469 if (y != 0 || ey != 1.0) fSumError2 += ey*ey;; 470 // set the weight flag checking if error^2 != y; 471 if (!fIsWeighted); 472 if (y != 0 && std::abs( ey*ey/y - 1.0) > 1.E-12) fIsWeighted = true;; 473 }; 474 ; 475 /**; 476 add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); 477 in this case store the y errors and not the inverse; 478 */; 479 void BinData::Add( double x, double y, double ex, double eyl, double eyh ); 480 {; 481 assert( kAsymError == fErrorType );; 482 assert( !fData.empty() && fDataPtr );; 483 assert( !fDataErrorHigh.empty() && fDataErrorHighPtr );; 484 assert( !fDataErrorLow.empty() && fDataErrorLowPtr );; 485 assert( fDataError.empty() && !fDataErrorPtr );; 486 assert( !fCoordErrors.empty() && fCoordErrors.size() == 1 );; 487 assert( !fCoordErrorsPtr.empty() && fCoordErrorsPtr.size() == 1 && fCoordErrorsPtr[0] );; 488 assert( &fCoordErrors[0].front() == fCoordErrorsPtr[0] );; 489 ; 490 fData[ fNPoints ] = y;; 491 fCoordErrors[0][ fNPoints ] = ex;; 492 fDataErrorHigh[ fNPoints ] = eyh;; 493 fDataErrorLow[ fNPoints ] = eyl;; 494 ; 495 FitData::Add( x );; 496 fSumContent += y;; 497 if (y != 0 || eyl != 1.0 || eyh != 1.0) fSumError2 += (eyl+eyh)*(eyl+eyh)/4;; 498 ; 499 }; 500 ; 501 /**; 502 add multi-dim coordinate data with only value; 503 */; 504 void BinData::Add( const double* x, double val ); 505 {; 506 assert( kNoError == fErrorType );; 507 ; 508 assert( !fData.empty() && fDataPtr );; 509 assert( fDataErrorHigh.empty() && !fDataErrorHighPtr );; 510 assert( fDataErrorLow.empty() && !fDataErrorLowPtr );; 511 assert( fDataError.empty() && !fDataErrorPtr );; 512 assert( fCoordErrors.empty() && fCoordErrorsPtr.empty() );; 513 ; 514 fData[ fNPoints ] = val;; 515 ; 516 FitData::Add( x );; 517 fSumContent += val;; 518 }; 519 ; 520 /**; 521 add multi-dim coordinate data with only error in value; 52",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:14858,assert,assert,14858,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['assert'],['assert']
Testability,"order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/Roo2DKeysPdf.html:23681,test,testArg,23681,root/html534/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html534/Roo2DKeysPdf.html,71,['test'],['testArg']
Testability,"ordinates.Mt2(); }. Scalar Mt() const. return the transverse mass; \f[ \sqrt{ m_t^2 = E^2 - p{_z}^2} X sign(E^ - p{_z}^2) \f]. { return fCoordinates.Mt(); }. Scalar Et2() const. return the transverse energy squared; \f[ e_t = \frac{E^2 p_{\perp}^2 }{ |p|^2 } \f]. { return fCoordinates.Et2(); }. Scalar Et() const. return the transverse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Sca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html:15683,log,log,15683,root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html,4,['log'],['log']
Testability,"ordinates.Mt2(); }. Scalar Mt() const. return the transverse mass; \f[ \sqrt{ m_t^2 = E^2 - p{_z}^2} X sign(E^ - p{_z}^2) \f]. { return fCoordinates.Mt(); }. Scalar Et2() const. return the transverse energy squared; \f[ e_t = \frac{E^2 p_{\perp}^2 }{ |p|^2 } \f]. { return fCoordinates.Et2(); }. Scalar Et() const. return the transverse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar tolerance = 100 * std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scala",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html:15196,log,log,15196,root/html602/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html,4,['log'],['log']
Testability,"ordinates.Mt2(); }. Scalar Mt() const. return the transverse mass; \f[ \sqrt{ m_t^2 = E^2 - p{_z}^2} X sign(E^ - p{_z}^2) \f]. { return fCoordinates.Mt(); }. Scalar Et2() const. return the transverse energy squared; \f[ e_t = \frac{E^2 p_{\perp}^2 }{ |p|^2 } \f]. { return fCoordinates.Et2(); }. Scalar Et() const. return the transverse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Sca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html:15683,log,log,15683,root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html,4,['log'],['log']
Testability,"ordinates.Mt2(); }. Scalar Mt() const. return the transverse mass; \f[ \sqrt{ m_t^2 = E^2 - p{_z}^2} X sign(E^ - p{_z}^2) \f]. { return fCoordinates.Mt(); }. Scalar Et2() const. return the transverse energy squared; \f[ e_t = \frac{E^2 p_{\perp}^2 }{ |p|^2 } \f]. { return fCoordinates.Et2(); }. Scalar Et() const. return the transverse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar tolerance = 100 * std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scala",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html:15196,log,log,15196,root/html602/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html,4,['log'],['log']
Testability,"ordinates.Mt2(); }. Scalar Mt() const. return the transverse mass; \f[ \sqrt{ m_t^2 = E^2 - p{_z}^2} X sign(E^ - p{_z}^2) \f]. { return fCoordinates.Mt(); }. Scalar Et2() const. return the transverse energy squared; \f[ e_t = \frac{E^2 p_{\perp}^2 }{ |p|^2 } \f]. { return fCoordinates.Et2(); }. Scalar Et() const. return the transverse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scala",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html:15401,log,log,15401,root/html528/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html,4,['log'],['log']
Testability,"ordinates.Mt2(); }. Scalar Mt() const. return the transverse mass; \f[ \sqrt{ m_t^2 = E^2 - p{_z}^2} X sign(E^ - p{_z}^2) \f]. { return fCoordinates.Mt(); }. Scalar Et2() const. return the transverse energy squared; \f[ e_t = \frac{E^2 p_{\perp}^2 }{ |p|^2 } \f]. { return fCoordinates.Et2(); }. Scalar Et() const. return the transverse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar tolerance = 100 * std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html:14912,log,log,14912,root/html602/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html,4,['log'],['log']
Testability,"ordinates.Mt2(); }. Scalar Mt() const. return the transverse mass; \f[ \sqrt{ m_t^2 = E^2 - p{_z}^2} X sign(E^ - p{_z}^2) \f]. { return fCoordinates.Mt(); }. Scalar Et2() const. return the transverse energy squared; \f[ e_t = \frac{E^2 p_{\perp}^2 }{ |p|^2 } \f]. { return fCoordinates.Et2(); }. Scalar Et() const. return the transverse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scala",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html:15401,log,log,15401,root/html528/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html,4,['log'],['log']
Testability,"ordinates.Mt2(); }. Scalar Mt() const. return the transverse mass; \f[ \sqrt{ m_t^2 = E^2 - p{_z}^2} X sign(E^ - p{_z}^2) \f]. { return fCoordinates.Mt(); }. Scalar Et2() const. return the transverse energy squared; \f[ e_t = \frac{E^2 p_{\perp}^2 }{ |p|^2 } \f]. { return fCoordinates.Et2(); }. Scalar Et() const. return the transverse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar tolerance = 100 * std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html:14912,log,log,14912,root/html602/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html,4,['log'],['log']
Testability,"ore iterating; 5465/// through all of the bins.; 5466///; 5467/// \param pAxis the axis to consider; 5468/// \param nPixels the number of pixels to render axis into; 5469/// \param isLog whether the axis is log scale; 5470 ; 5471std::vector<THistRenderingRegion>; 5472THistPainter::ComputeRenderingRegions(TAxis* pAxis, Int_t nPixels, Bool_t isLog); 5473{; 5474 std::vector<THistRenderingRegion> regions;; 5475 ; 5476 enum STRATEGY { Bins, Pixels } strategy;; 5477 ; 5478 Int_t nBins = (pAxis->GetLast() - pAxis->GetFirst() + 1);; 5479 ; 5480 if (nBins >= nPixels) {; 5481 // more bins than pixels... we should loop over pixels and sample; 5482 strategy = Pixels;; 5483 } else {; 5484 // fewer bins than pixels... we should loop over bins; 5485 strategy = Bins;; 5486 }; 5487 ; 5488 if (isLog) {; 5489 ; 5490 Double_t xMin = pAxis->GetBinLowEdge(pAxis->GetFirst());; 5491 Int_t binOffset=0;; 5492 while (xMin <= 0 && ((pAxis->GetFirst()+binOffset) != pAxis->GetLast()) ) {; 5493 binOffset++;; 5494 xMin = pAxis->GetBinLowEdge(pAxis->GetFirst()+binOffset);; 5495 }; 5496 if (xMin <= 0) {; 5497 // this should cause an error if we have; 5498 return regions;; 5499 }; 5500 Double_t xMax = pAxis->GetBinUpEdge(pAxis->GetLast());; 5501 ; 5502 if (strategy == Bins) {; 5503 // logarithmic plot. we find the pixel for the bin; 5504 // pixel = eta * log10(V) - alpha; 5505 // where eta = nPixels/(log10(Vmax)-log10(Vmin)); 5506 // and alpha = nPixels*log10(Vmin)/(log10(Vmax)-log10(Vmin)); 5507 // and V is axis value; 5508 Double_t eta = (nPixels-1.0)/(TMath::Log10(xMax) - TMath::Log10(xMin));; 5509 Double_t offset = -1.0 * eta * TMath::Log10(xMin);; 5510 ; 5511 for (Int_t bin=pAxis->GetFirst()+binOffset; bin<=pAxis->GetLast(); bin++) {; 5512 ; 5513 // linear plot. we simply need to find the appropriate bin; 5514 // for the; 5515 Double_t xLowValue = pAxis->GetBinLowEdge(bin);; 5516 Double_t xUpValue = pAxis->GetBinUpEdge(bin);; 5517 Int_t xPx0 = eta*TMath::Log10(xLowValue)+ offset;; 5518 Int_t xPx1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:205694,log,logarithmic,205694,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['log'],['logarithmic']
Testability,"origName, const char* message, const char* serverValueString = 0); const RooArgList&lowList() const; virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/PiecewiseInterpolation.html:17801,test,testArg,17801,root/html532/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html532/PiecewiseInterpolation.html,1,['test'],['testArg']
Testability,"origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tnumBins() const; Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ParamHistFunc.html:19016,test,testArg,19016,root/html534/ParamHistFunc.html,https://root.cern,https://root.cern/root/html534/ParamHistFunc.html,1,['test'],['testArg']
Testability,"origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tnumBins() const; Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); ParamHistFunc&operator=(const ParamHistFunc&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinke",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ParamHistFunc.html:18704,test,testArg,18704,root/html602/ParamHistFunc.html,https://root.cern,https://root.cern/root/html602/ParamHistFunc.html,2,['test'],['testArg']
Testability,"originator];; 3440 evalErrorList.first = origName ;; 3441 evalErrorList.second.push_back(ee) ;; 3442 }; 3443 ; 3444 ; 3445 inLogEvalError = false ;; 3446}; 3447 ; 3448 ; 3449 ; 3450////////////////////////////////////////////////////////////////////////////////; 3451/// Log evaluation error message. Evaluation errors may be routed through a different; 3452/// protocol than generic RooFit warning message (which go straight through RooMsgService); 3453/// because evaluation errors can occur in very large numbers in the use of likelihood; 3454/// evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); 3455/// messages reported through this function are not printed but all stored in a list,; 3456/// along with server values at the time of reporting. Error messages logged in this; 3457/// way can be printed in a structured way, eliminating duplicates and with the ability; 3458/// to truncate the list by printEvalErrors. This is the standard mode of error logging; 3459/// during MINUIT operations. If enableEvalErrorLogging() is false, all errors; 3460/// reported through this method are passed for immediate printing through RooMsgService.; 3461/// A string with server names and values is constructed automatically for error logging; 3462/// purposes, unless a custom string with similar information is passed as argument.; 3463 ; 3464void RooAbsReal::logEvalError(const char* message, const char* serverValueString) const; 3465{; 3466 if (evalErrorData().mode == Ignore) {; 3467 return ;; 3468 }; 3469 ; 3470 if (evalErrorData().mode == CountErrors) {; 3471 evalErrorData().count++ ;; 3472 return ;; 3473 }; 3474 ; 3475 static bool inLogEvalError = false ;; 3476 ; 3477 if (inLogEvalError) {; 3478 return ;; 3479 }; 3480 inLogEvalError = true ;; 3481 ; 3482 EvalError ee ;; 3483 ee.setMessage(message) ;; 3484 ; 3485 if (serverValueString) {; 3486 ee.setServerValues(serverValueString) ;; 3487 } else {; 3488 std::string srvval ;; 3489 std::ostringstream",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:148387,log,logging,148387,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['log'],['logging']
Testability,"orithm; RooArgSetfPOIparameters of interest for interval; RooAbsPdf*fPdfpointer to common PDF (owned by the workspace); RooAbsPdf*fPriorPdfpointer to prior PDF (owned by the workspace); RooStats::ProposalFunction*fPropFuncProposal function for MCMC integration; Double_tfSizesize of the test (eg. specified rate of Type I error); TStringTNamed::fTitleobject title; Bool_tfUseKeyswhether to use kernel estimation to determine interval; Bool_tfUseSparseHistwhether to use sparse histogram (if using hist at all). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MCMCCalculator(). MCMCCalculator(RooAbsData& data, const RooStats::ModelConfig& model). void SetModel(const RooStats::ModelConfig& model); set the model. void SetupBasicUsage(). void SetLeftSideTailFraction(Double_t a). MCMCInterval* GetInterval() const; Main interface to get a RooStats::ConfInterval. MCMCCalculator(); default constructor. virtual ~MCMCCalculator(); {}. Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void SetData(RooAbsData& data); Set the DataSet if not already there. { fData = &data; }. void SetPdf(RooAbsPdf& pdf); Set the Pdf if not already there. { fPdf = &pdf; }. void SetPriorPdf(RooAbsPdf& pdf); Set the Prior Pdf if not already there. { fPriorPdf = &pdf; }. void SetParameters(const RooArgSet& set); specify the parameters of interest in the interval. { fPOI.removeAll(); fPOI.add(set); }. void SetChainParameters(const RooArgSet& set); specify the parameters to store in the Markov chain; By default all the parameters are stored. { fChainParams.removeAll(); fChainParams.add(set); }. void SetNuisanceParameters(const RooArgSet& set); specify the nuisance parameters (eg. the rest of the parameters). {fNuisParams.removeAll(); fNuisParams.add(set);}. void SetConditionalObservables(const RooArgSet& set); set the conditional obse",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__MCMCCalculator.html:9265,test,test,9265,root/html534/RooStats__MCMCCalculator.html,https://root.cern,https://root.cern/root/html534/RooStats__MCMCCalculator.html,3,['test'],['test']
Testability,"orithm; RooArgSetfPOIparameters of interest for interval; RooAbsPdf*fPdfpointer to common PDF (owned by the workspace); RooAbsPdf*fPriorPdfpointer to prior PDF (owned by the workspace); RooStats::ProposalFunction*fPropFuncProposal function for MCMC integration; Double_tfSizesize of the test (eg. specified rate of Type I error); TStringTNamed::fTitleobject title; Bool_tfUseKeyswhether to use kernel estimation to determine interval; Bool_tfUseSparseHistwhether to use sparse histogram (if using hist at all). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MCMCCalculator(). MCMCCalculator(RooAbsData& data, const RooStats::ModelConfig& model). void SetModel(const RooStats::ModelConfig& model); set the model. void SetupBasicUsage(). void SetLeftSideTailFraction(Double_t a). MCMCInterval* GetInterval() const; Main interface to get a RooStats::ConfInterval. MCMCCalculator(); default constructor. virtual ~MCMCCalculator(); {}. Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void SetData(RooAbsData& data); Set the DataSet if not already there. { fData = &data; }. void SetPdf(RooAbsPdf& pdf); Set the Pdf if not already there. { fPdf = &pdf; }. void SetPriorPdf(RooAbsPdf& pdf); Set the Prior Pdf if not already there. { fPriorPdf = &pdf; }. void SetParameters(const RooArgSet& set); specify the parameters of interest in the interval. { fPOI.removeAll(); fPOI.add(set); }. void SetChainParameters(const RooArgSet& set); specify the parameters to store in the Markov chain; By default all the parameters are stored. { fChainParams.removeAll(); fChainParams.add(set); }. void SetNuisanceParameters(const RooArgSet& set); specify the nuisance parameters (eg. the rest of the parameters). {fNuisParams.removeAll(); fNuisParams.add(set);}. void SetTestSize(Double_t size); set the size of the test (rate of Type I erro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__MCMCCalculator.html:9136,test,test,9136,root/html532/RooStats__MCMCCalculator.html,https://root.cern,https://root.cern/root/html532/RooStats__MCMCCalculator.html,1,['test'],['test']
Testability,"orithm; RooArgSetfPOIparameters of interest for interval; RooAbsPdf*fPdfpointer to common PDF (owned by the workspace); RooAbsPdf*fPriorPdfpointer to prior PDF (owned by the workspace); RooStats::ProposalFunction*fPropFuncProposal function for MCMC integration; Double_tfSizesize of the test (eg. specified rate of Type I error); TStringTNamed::fTitleobject title; Bool_tfUseKeyswhether to use kernel estimation to determine interval; Bool_tfUseSparseHistwhether to use sparse histogram (if using hist at all). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MCMCCalculator(). MCMCCalculator(RooAbsData& data, const RooStats::ModelConfig& model). void SetModel(const RooStats::ModelConfig& model); set the model. void SetupBasicUsage(). void SetLeftSideTailFraction(Double_t a). MCMCInterval* GetInterval() const; Main interface to get a RooStats::ConfInterval. MCMCCalculator(); default constructor. virtual ~MCMCCalculator(); {}. Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void SetData(RooAbsData& data); Set the DataSet if not already there. { fData = &data; }. void SetPdf(RooAbsPdf& pdf); Set the Pdf if not already there. { fPdf = &pdf; }. void SetPriorPdf(RooAbsPdf& pdf); Set the Prior Pdf if not already there. { fPriorPdf = &pdf; }. void SetParameters(const RooArgSet& set); specify the parameters of interest in the interval. { fPOI.removeAll(); fPOI.add(set); }. void SetNuisanceParameters(const RooArgSet& set); specify the nuisance parameters (eg. the rest of the parameters). {fNuisParams.removeAll(); fNuisParams.add(set);}. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size;}. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__MCMCCalculator.html:8907,test,test,8907,root/html528/RooStats__MCMCCalculator.html,https://root.cern,https://root.cern/root/html528/RooStats__MCMCCalculator.html,2,['test'],['test']
Testability,"orkers(); Show available workers. TList * QuerySessions(Option_t* opt = ""S""); Get list of sessions accessible to this manager. Bool_t HandleInput(const void* ); Handle asynchronous input on the socket. Bool_t HandleError(const void* in = 0); Handle error on the input socket. Int_t Reset(Bool_t hard = kFALSE, const char* usr = 0); Send a cleanup request for the sessions associated with the current user.; If 'hard' is true sessions are signalled for termination and moved to; terminate at all stages (top master, sub-master, workers). Otherwise; (default) only top-master sessions are asked to terminate, triggering; a gentle session termination. In all cases all sessions should be gone; after a few (2 or 3) session checking cycles.; A user with superuser privileges can also asks cleaning for an different; user, specified by 'usr', or for all users (usr = *); Return 0 on success, -1 in case of error. TProofLog * GetSessionLogs(Int_t ridx = 0, const char* stag = 0, const char* pattern = ""-v \""| SvcMsg\""""); Get logs or log tails from last session associated with this manager; instance.; The arguments allow to specify a session different from the last one:; isess specifies a position relative to the last one, i.e. 1; for the next to last session; the absolute value is taken; so -1 and 1 are equivalent.; stag specifies the unique tag of the wanted session; The special value stag = ""NR"" allows to just initialize the TProofLog; object w/o retrieving the files; this may be useful when the number; of workers is large and only a subset of logs is required.; If 'stag' is specified 'isess' is ignored (unless stag = ""NR"").; If 'pattern' is specified only the lines containing it are retrieved; (remote grep functionality); to filter out a pattern 'pat' use; pattern = ""-v pat"".; Returns a TProofLog object (to be deleted by the caller) on success,; 0 if something wrong happened. TObjString * ReadBuffer(const char* file, Long64_t ofs, Int_t len); Read, via the coordinator, 'len' bytes from",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXProofMgr.html:11637,log,logs,11637,root/html528/TXProofMgr.html,https://root.cern,https://root.cern/root/html528/TXProofMgr.html,2,['log'],"['log', 'logs']"
Testability,"orld coordinates.Definition TPad.cxx:4525; TPad::fPhiDouble_t fPhiphi angle to view as lego/surfaceDefinition TPad.h:80; TPad::fPixeltoYDouble_t fPixeltoYyworld = fPixeltoYk + fPixeltoY*ypixelDefinition TPad.h:60; TPad::RecordLatexvirtual void RecordLatex(const TObject *obj)Emit RecordLatex() signal.Definition TPad.cxx:7254; TPad::fAbsXlowNDCDouble_t fAbsXlowNDCAbsolute X top left corner of pad in NDC [0,1].Definition TPad.h:69; TPad::fVtoPixelkDouble_t fVtoPixelkConversion coefficient for V NDC to pixel.Definition TPad.h:52; TPad::fGridxBool_t fGridxSet to true if grid along X.Definition TPad.h:100; TPad::fPadView3DTObject * fPadView3D! 3D View of this TPadDefinition TPad.h:114; TPad::CopyBackgroundPixmapsvoid CopyBackgroundPixmaps(TPad *start, TPad *stop, Int_t x, Int_t y)Copy pixmaps of pads laying below pad ""stop"" into pad ""stop"".Definition TPad.cxx:3990; TPad::GetUxmaxDouble_t GetUxmax() const overrideReturns the maximum x-coordinate value visible on the pad. If log axis the returned value is in decad...Definition TPad.h:232; TPad::Dividevoid Divide(Int_t nx=1, Int_t ny=1, Float_t xmargin=0.01, Float_t ymargin=0.01, Int_t color=0) overrideAutomatic pad generation by division.Definition TPad.cxx:1249; TPad::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitives in this pad on the C++ source file out.Definition TPad.cxx:5847; TPad::fXtoPixelDouble_t fXtoPixelxpixel = fXtoPixelk + fXtoPixel*xworldDefinition TPad.h:43; TPad::fExecsTList * fExecsList of commands to be executed when a pad event occurs.Definition TPad.h:108; TPad::PadtoYDouble_t PadtoY(Double_t y) const overrideConvert y from pad to Y.Definition TPad.cxx:3551; TPad::fTickxInt_t fTickxSet to 1 if tick marks along X.Definition TPad.h:89; TPad::SetBBoxY1void SetBBoxY1(const Int_t y) overrideSet top of BoundingBox to a value (resize in y direction on top)Definition TPad.cxx:7348; TPad::fTickyInt_t fTickySet to 1 if tick marks along Y.Definition TPad.h:90; TPad::Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:292241,log,log,292241,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['log'],['log']
Testability,"orm valid Delaunay triangles. Choose diagonal; 874 // with highest average z-value. Whichever we choose we will have; 875 // verified two triangles as good and two as bad, only note the good ones; 876 d = degen;; 877 f = fdegen;; 878 o1 = o1degen;; 879 o2 = o2degen;; 880 if ((fZ[o1-1]+fZ[o2-1]) > (fZ[d-1]+fZ[f-1])) {; 881 // best diagonalisation of quadrilateral is current one, we have; 882 // the triangle; 883 t1 = p;; 884 t2 = n;; 885 t3 = m;; 886 // file the good triangles; 887 FileIt(p, n, m);; 888 FileIt(d, o1, o2);; 889 } else {; 890 // use other diagonal to split quadrilateral, use triangle formed by; 891 // point f, the degnerate point d and whichever of o1 and o2 create; 892 // an enclosing triangle; 893 t1 = f;; 894 t2 = d;; 895 if (Enclose(f,d,o1,0)) {; 896 t3 = o1;; 897 } else {; 898 t3 = o2;; 899 }; 900 // file the good triangles; 901 FileIt(f, d, o1);; 902 FileIt(f, d, o2);; 903 }; 904 } else {; 905 // this is a Delaunay triangle, file it; 906 FileIt(p, n, m);; 907 t1 = p;; 908 t2 = n;; 909 t3 = m;; 910 }; 911 // do the interpolation; 912 thevalue = InterpolateOnPlane(t1,t2,t3,0);; 913 return thevalue;; 914L90:; 915 continue;; 916 }; 917 }; 918 }; 919 if (shouldbein) {; 920 Error(""Interpolate"",; 921 ""Point outside hull when expected inside: this point could be dodgy %g %g %d"",; 922 xx, yy, ntris_tried);; 923 }; 924 return thevalue;; 925}; 926 ; 927 ; 928////////////////////////////////////////////////////////////////////////////////; 929/// Defines the number of triangles tested for a Delaunay triangle; 930/// (number of iterations) before abandoning the search; 931 ; 932void TGraphDelaunay::SetMaxIter(Int_t n); 933{; 934 fAllTri = kFALSE;; 935 fMaxIter = n;; 936}; 937 ; 938 ; 939////////////////////////////////////////////////////////////////////////////////; 940/// Sets the histogram bin height for points lying outside the convex hull ie:; 941/// the bins in the margin.; 942 ; 943void TGraphDelaunay::SetMarginBinsContent(Double_t z); 944{; 945 fZout =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html:31722,test,tested,31722,doc/master/TGraphDelaunay_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html,1,['test'],['tested']
Testability,"orm=None"" );; 233 // And the options strings for the MinMax and RMS methods, respectively:; 234 //; 235 // ""!H:!V:VolumeRangeMode=MinMax:DeltaFrac=0.2:KernelEstimator=Gauss:GaussSigma=0.3"" );; 236 // ""!H:!V:VolumeRangeMode=RMS:DeltaFrac=3:KernelEstimator=Gauss:GaussSigma=0.3"" );; 237 ; 238 if (Use[""PDEFoam""]); 239 factory->BookMethod( dataloader, TMVA::Types::kPDEFoam, ""PDEFoam"",; 240 ""!H:!V:MultiTargetRegression=F:TargetSelection=Mpv:TailCut=0.001:VolFrac=0.0666:nActiveCells=500:nSampl=2000:nBin=5:Compress=T:Kernel=None:Nmin=10:VarTransform=None"" );; 241 ; 242 // K-Nearest Neighbour classifier (KNN); 243 if (Use[""KNN""]); 244 factory->BookMethod( dataloader, TMVA::Types::kKNN, ""KNN"",; 245 ""nkNN=20:ScaleFrac=0.8:SigmaFact=1.0:Kernel=Gaus:UseKernel=F:UseWeight=T:!Trim"" );; 246 ; 247 // Linear discriminant; 248 if (Use[""LD""]); 249 factory->BookMethod( dataloader, TMVA::Types::kLD, ""LD"",; 250 ""!H:!V:VarTransform=None"" );; 251 ; 252 // Function discrimination analysis (FDA) -- test of various fitters - the recommended one is Minuit (or GA or SA); 253 if (Use[""FDA_MC""]); 254 factory->BookMethod( dataloader, TMVA::Types::kFDA, ""FDA_MC"",; 255 ""!H:!V:Formula=(0)+(1)*x0+(2)*x1:ParRanges=(-100,100);(-100,100);(-100,100):FitMethod=MC:SampleSize=100000:Sigma=0.1:VarTransform=D"" );; 256 ; 257 if (Use[""FDA_GA""]) // can also use Simulated Annealing (SA) algorithm (see Cuts_SA options) .. the formula of this example is good for parabolas; 258 factory->BookMethod( dataloader, TMVA::Types::kFDA, ""FDA_GA"",; 259 ""!H:!V:Formula=(0)+(1)*x0+(2)*x1:ParRanges=(-100,100);(-100,100);(-100,100):FitMethod=GA:PopSize=100:Cycles=3:Steps=30:Trim=True:SaveBestGen=1:VarTransform=Norm"" );; 260 ; 261 if (Use[""FDA_MT""]); 262 factory->BookMethod( dataloader, TMVA::Types::kFDA, ""FDA_MT"",; 263 ""!H:!V:Formula=(0)+(1)*x0+(2)*x1:ParRanges=(-100,100);(-100,100);(-100,100);(-10,10):FitMethod=MINUIT:ErrorLevel=1:PrintLevel=-1:FitStrategy=2:UseImprove:UseMinos:SetBatch"" );; 264 ; 265 if (Use[""FDA_GAMT""]); 266 fact",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C_source.html:10294,test,test,10294,doc/master/TMVARegression_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C_source.html,1,['test'],['test']
Testability,"orms an on-the-fly RVec <-> std::vector conversion rather than writing RVecs to disk. Note that, currently, RVecs written e.g. in a TTree cannot be read back using certain ROOT interfaces (e.g. TTreeReaderArray, RDataFrame and the experimental RNTuple). All these limitations will be lifted in v6.26.; Portable implementation of the RANLUX++ generator, see RanluxppEngine and our blog post.; Change TRandom3::GetSeed to return the current state element in the contained seed vector of TRandom3. The return value will now change after every call of TRandom3::Rndm (when generating a random number). Before the function was returning the first element of the state, which was changing only after 624 calls to Rndm().; Fix a bug in ROOT::Fit::BinData copy constructor; Fix a bug in applying a correction factor used for the computation of the fit confidence level in ROOT::Fit::FitResult.; TMatrix: optimize implementation of TPrincipal::AddRow that is heavily used by CMS. Minuit2. Add a new improved message logging system. Debug message now can be enabled in Minuit2 when using maximum print level.; When using external provided gradient, compute in MnSeed still numerical gradients to obtain correct step sizes and initial estimate of covariance matrix. This allows to start with a good first state estimation, reducing significantly the number of subsequent iterations. TMVA. Introducing TMVA PyTorch Interface, a method to use PyTorch internally with TMVA for deep learning. This can be used as an alternative to PyKeras Interface for complex models providing more flexibility and power.; Add support in the TMVA Keras interface for Tensorflow.Keras (the version embedded in Tensorflow) and for standalone Keras versions up to it latest 2.3. For using Tensorflow.Keras one needs to use the booking option tf.keras=True.; Update the TMVA Keras tutorials to use now tensorflow.keras.; Deprecate the MethodDNN in favour of MethodDL supporting both CNN and RNN; Add possibility to customize all relevan",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:14943,log,logging,14943,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['log'],['logging']
Testability,"ormula * TF1::GetFormula ; (; ). inlinevirtual . Definition at line 481 of file TF1.h. ◆ GetFormula() [2/2]. virtual const TFormula * TF1::GetFormula ; (; ); const. inlinevirtual . Definition at line 485 of file TF1.h. ◆ GetHistogram(). TH1 * TF1::GetHistogram ; (; ); const. virtual . Return a pointer to the histogram used to visualise the function Note that this histogram is managed by the function and in same case it is automatically deleted when some TF1 functions are called such as TF1::SetParameters, TF1::SetNpx, TF1::SetRange It is then reccomended either to clone the return object or calling again teh GetHistogram function whenever is needed. ; Definition at line 1584 of file TF1.cxx. ◆ GetLinearPart(). virtual const TObject * TF1::GetLinearPart ; (; Int_t ; i); const. inlinevirtual . Definition at line 493 of file TF1.h. ◆ GetMaximum(). Double_t TF1::GetMaximum ; (; Double_t ; xmin = 0, . Double_t ; xmax = 0, . Double_t ; epsilon = 1.E-10, . Int_t ; maxiter = 100, . Bool_t ; logx = false . ); const. virtual . Returns the maximum value of the function. ; Method: First, the grid search is used to bracket the maximum with the step size = (xmax-xmin)/fNpx. This way, the step size can be controlled via the SetNpx() function. If the function is unimodal or if its extrema are far apart, setting the fNpx to a small value speeds the algorithm up many times. Then, Brent's method is applied on the bracketed interval epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ) and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number of iteration of the Brent algorithm If the flag logx is set the grid search is done in log step size This is done automatically if the log scale is set in the current Pad; NOTE: see also TF1::GetMaximumX and TF1::GetX ; Reimplemented in TF2.; Definition at line 1614 of file TF1.cxx. ◆ GetMaximumStored(). virtual Double_t TF1::GetMaximumStored ; (; ); const. inlinevirtual . Definition at line 501 of file TF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1.html:74608,log,logx,74608,doc/master/classTF1.html,https://root.cern,https://root.cern/doc/master/classTF1.html,1,['log'],['logx']
Testability,"ormula::GetParName(Int_t ipar) const; virtual Int_tTFormula::GetParNumber(const char* name) const; virtual Double_tTF1::GetProb() const; virtual Int_tTF1::GetQuantiles(Int_t nprobSum, Double_t* q, const Double_t* probSum); virtual Double_tGetRandom(); virtual Double_tGetRandom(Double_t xmin, Double_t xmax); virtual voidGetRandom2(Double_t& xrandom, Double_t& yrandom); virtual voidGetRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; virtual voidGetRange(Double_t& xmin, Double_t& ymin, Double_t& zmin, Double_t& xmax, Double_t& ymax, Double_t& zmax) const; virtual Double_tGetSave(const Double_t* x); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Double_tTF1::GetX(Double_t y, Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.0E-10, Int_t maxiter = 100, Bool_t logx = false) const; TAxis*TF1::GetXaxis() const; virtual Double_tTF1::GetXmax() const; virtual Double_tTF1::GetXmin() const; TAxis*TF1::GetYaxis() const; virtual Double_tGetYmax() const; virtual Double_tGetYmin() const; TAxis*TF1::GetZaxis() const; virtual Double_tTF1::GradientPar(Int_t ipar, const Double_t* x, Double_t eps = 0.01); virtual voidTF1::GradientPar(const Double_t* x, Double_t* grad, Double_t eps = 0.01); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTF1::InitArgs(const Double_t* x, const Double_t* params); static voidTF1::InitStandardFunctions(); virtual voidTObject::Inspect() constMENU ; virtual Double_tIntegral(Double_t ax, Double_t bx, Double_t ay, Double_t by, Double_t epsrel = 9.9999999999999995E-7); virtual Double_tTF1::IntegralError(Double_t a, Double_t b, const Double_t* params = 0, const Double_t* covmat = 0, Double_t epsilon = 0.01); virtual Double_tTF1::Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF2.html:7340,log,logx,7340,root/html602/TF2.html,https://root.cern,https://root.cern/root/html602/TF2.html,1,['log'],['logx']
Testability,"orov test. Default: Ignore under- and overflow bins in comparison. option is a character string to specify options; ""U"" include Underflows in test (also for 2-dim); ""O"" include Overflows (also valid for 2-dim); ""N"" include comparison of normalizations; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob; ""X"" Run the pseudo experiments post-processor with the following procedure:; make pseudoexperiments based on random values from the parent; distribution and compare the KS distance of the pseudoexperiment; to the parent distribution. Bin the KS distances in a histogram,; and then take the integral of all the KS values above the value; obtained from the original data to Monte Carlo distribution.; The number of pseudo-experiments nEXPT is currently fixed at 1000.; The function returns the integral.; (thanks to Ben Kilminster to submit this procedure). Note that; this option ""X"" is much slower. The returned function value is the probability of test; (much less than one means NOT compatible). Code adapted by Rene Brun from original HBOOK routine HDIFF. NOTE1; A good description of the Kolmogorov test can be seen at:; http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm. NOTE2; see also alternative function TH1::Chi2Test; The Kolmogorov test is assumed to give better results than Chi2Test; in case of histograms with low statistics. NOTE3 (Jan Conrad, Fred James); ""The returned value PROB is calculated such that it will be; uniformly distributed between zero and one for compatible histograms,; provided the data are not binned (or the number of bins is very large; compared with the number of events). Users who have access to unbinned; data and wish exact confidence levels should therefore not put their data; into histograms, but should call directly TMath::KolmogorovTest. On; the other hand, since TH1 is a convenient way of collecting data and; saving space, this function has been provided. However, the values of; PR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:108364,test,test,108364,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,3,['test'],['test']
Testability,"ors); Int_tsetPrintLevel(Int_t newLevel); voidsetProfile(Bool_t flag = kTRUE); voidsetStrategy(Int_t strat); virtual voidTObject::SetUniqueID(UInt_t uid); voidsetVerbose(Bool_t flag = kTRUE); virtual voidShowMembers(TMemberInspector&); Int_tsimplex(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidzeroEvalCount(). protected:. voidapplyCovarianceMatrix(TMatrixDSym& V); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; const RooMinimizerFcn*fitterFcn() const; RooMinimizerFcn*fitterFcn(); Int_tgetNPar() const; ofstream*logfile(); voidTObject::MakeZombie(); Double_t&maxFCN(); voidprofileStart(); voidprofileStop(). private:. RooMinimizer(const RooMinimizer&). Data Members; public:. enum Strategy { Speed; Balance; Robustness; };; enum PrintLevel { None; Reduced; Normal; ExtraForProblem; Maximum; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TStopwatch_cumulTimer; TMatrixDSym*_extV; RooMinimizerFcn*_fcn; RooAbsReal*_func; string_minimizerType; Bool_t_optConst; Int_t_printLevel; Bool_t_profile; Bool_t_profileStart; Int_t_status; vector<std::pair<std::string,int> >_statusHistory; static ROOT::Fit::Fitter*_theFitter; TStopwatch_timer; Bool_t_verbose. Class Charts. Inheritance; Inherited Members; Includes; Libraries. F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMinimizer.html:7107,log,logfile,7107,root/html534/RooMinimizer.html,https://root.cern,https://root.cern/root/html534/RooMinimizer.html,1,['log'],['logfile']
Testability,"ory objects into a single category ;  CRooMultiCatIterRooMultiCatIter iterators over all state permutations of a list of categories ;  CRooMultiGenFunctionLightweight interface adaptor that exports a RooAbsReal as a ROOT::Math::IMultiGenFunction ;  ►CRooMultiVarGaussianMultivariate Gaussian p.d.f ;  CAnaIntData;  CBitBlock;  CGenData;  CRooNameRegRooNameReg is a registry for 'const char*' name ;  CRooNameSetRooNameSet is a utility class that stores the names the objects in a RooArget ;  ►CRooNDKeysPdfGeneric N-dimensional implementation of a kernel estimation p.d.f ;  CBoxInfo;  CSorterTV_L2HDo not persist ;  CRooNLLVarClass RooNLLVar implements a a -log(likelihood) calculation from a dataset and a PDF ;  CRooNonCentralChiSquareThe PDF of the Non-Central Chi Square distribution for n degrees of freedom ;  CRooNonCPEigenDecayTime-dependent RooAbsAnaConvPdf for CP violating decays to Non-CP eigenstates (eg, \( B_0 \rightarrow \rho^\pm \pi^\mp\)) ;  ►CRooNormSetCacheClass RooNormSet cache manage the bookkeeping of multiple instances of sets of integration and normalization observables that effectively have the same definition ;  CPairCmp;  CRooNovosibirskRooNovosibirsk implements the Novosibirsk function ;  CRooNumberClass RooNumber implements numeric constants used by RooFit ;  CRooNumCdfClass RooNumCdf is an implementation of RooNumRunningInt specialized to calculate cumulative distribution functions from p.d.f.s ;  CRooNumConvolutionNumeric 1-dimensional convolution operator PDF ;  CRooNumConvPdfNumeric 1-dimensional convolution operator PDF ;  CRooNumGenConfigRooNumGenConfig holds the configuration parameters of the various numeric integrators used by RooRealIntegral ;  CRooNumGenFactoryRooNumGenFactory is a factory to instantiate numeric integrators from a given function binding and a given configuration ;  CRooNumIntConfigRooNumIntConfig holds the configuration parameters of the various numeric integrators used by RooRealIntegral ;  CRooNumIntFactoryRooNumIntFact",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:113097,log,log,113097,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,3,['log'],['log']
Testability,"ory objects into a single category ;  CRooMultiCatIterRooMultiCatIter iterators over all state permutations of a list of categories ;  CRooMultiGenFunctionLightweight interface adaptor that exports a RooAbsReal as a ROOT::Math::IMultiGenFunction ;  ►CRooMultiVarGaussianMultivariate Gaussian p.d.f ;  CAnaIntData;  CBitBlock;  CGenData;  CRooNameRegRooNameReg is a registry for 'const char*' name ;  CRooNameSetRooNameSet is a utility class that stores the names the objects in a RooArget ;  ►CRooNDKeysPdfGeneric N-dimensional implementation of a kernel estimation p.d.f ;  CBoxInfo;  CSorterTV_L2HSorter function ;  CRooNLLVarClass RooNLLVar implements a a -log(likelihood) calculation from a dataset and a PDF ;  CRooNonCentralChiSquareThe PDF of the Non-Central Chi Square distribution for n degrees of freedom ;  CRooNonCPEigenDecayTime-dependent RooAbsAnaConvPdf for CP violating decays to Non-CP eigenstates (eg, \( B_0 \rightarrow \rho^\pm \pi^\mp\)) ;  ►CRooNormSetCacheClass RooNormSet cache manage the bookkeeping of multiple instances of sets of integration and normalization observables that effectively have the same definition ;  CPairCmp;  CRooNovosibirskRooNovosibirsk implements the Novosibirsk function ;  CRooNumberClass RooNumber implements numeric constants used by RooFit ;  CRooNumCdfClass RooNumCdf is an implementation of RooNumRunningInt specialized to calculate cumulative distribution functions from p.d.f.s ;  CRooNumConvolutionNumeric 1-dimensional convolution operator PDF ;  CRooNumConvPdfNumeric 1-dimensional convolution operator PDF ;  CRooNumGenConfigRooNumGenConfig holds the configuration parameters of the various numeric integrators used by RooRealIntegral ;  CRooNumGenFactoryRooNumGenFactory is a factory to instantiate numeric integrators from a given function binding and a given configuration ;  CRooNumIntConfigRooNumIntConfig holds the configuration parameters of the various numeric integrators used by RooRealIntegral ;  CRooNumIntFactoryRooNumIntFact",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:97042,log,log,97042,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,2,['log'],['log']
Testability,"ory of Contingency and Its Relation to; Association and Normal Correlation. Drapers' Co. Memoirs, Biometric; Series No. 1, London.; [2] Gagunashvili, N., 2006. test for comparison; of weighted and unweighted histograms. Statistical Problems in Particle; Physics, Astrophysics and Cosmology, Proceedings of PHYSTAT05,; Oxford, UK, 12-15 September 2005, Imperial College Press, London, 43-44.; Gagunashvili,N., Comparison of weighted and unweighted histograms,; arXiv:physics/0605123, 2006.; [3] Cramer, H., 1946. Mathematical methods of statistics.; Princeton University Press, Princeton.; [4] Haberman, S.J., 1973. The analysis of residuals in cross-classified tables.; Biometrics 29, 205-220.; [5] Lewontin, R.C. and Felsenstein, J., 1965. The robustness of homogeneity; test in 2xN tables. Biometrics 21, 19-33.; [6] Seber, G.A.F., Lee, A.J., 2003, Linear Regression Analysis.; John Wiley & Sons Inc., New York. Double_t Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; The computation routine of the Chisquare test. For the method description,; see Chi2Test() function.; Returns p-value; parameters:; - h2-second histogram; - option:; ""UU"" = experiment experiment comparison (unweighted-unweighted); ""UW"" = experiment MC comparison (unweighted-weighted). Note that the first; histogram should be unweighted; ""WW"" = MC MC comparison (weighted-weighted). ""NORM"" = if one or both histograms is scaled. ""OF"" = overflows included; ""UF"" = underflows included; by default underflows and overflows are not included. - igood:; igood=0 - no problems; For unweighted unweighted comparison; igood=1'There is a bin in the 1st histogram with less than 1 event'; igood=2'There is a bin in the 2nd histogram with less than 1 event'; igood=3'when the conditions for igood=1 and igood=2 are satisfied'; For unweighted weighted comparison; igood=1'There is a bin in the 1st histogram with less then 1 event'; igood=2'There is a bin in the 2nd hist",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TH1.html:55816,test,test,55816,root/html532/TH1.html,https://root.cern,https://root.cern/root/html532/TH1.html,4,['test'],['test']
Testability,"ory of Contingency and Its Relation to; Association and Normal Correlation. Drapers' Co. Memoirs, Biometric; Series No. 1, London.; [2] Gagunashvili, N., 2006. test for comparison; of weighted and unweighted histograms. Statistical Problems in Particle; Physics, Astrophysics and Cosmology, Proceedings of PHYSTAT05,; Oxford, UK, 12-15 September 2005, Imperial College Press, London, 43-44.; Gagunashvili,N., Comparison of weighted and unweighted histograms,; arXiv:physics/0605123, 2006.; [3] Cramer, H., 1946. Mathematical methods of statistics.; Princeton University Press, Princeton.; [4] Haberman, S.J., 1973. The analysis of residuals in cross-classified tables.; Biometrics 29, 205-220.; [5] Lewontin, R.C. and Felsenstein, J., 1965. The robustness of homogeneity; test in 2xN tables. Biometrics 21, 19-33.; [6] Seber, G.A.F., Lee, A.J., 2003, Linear Regression Analysis.; John Wiley & Sons Inc., New York. Double_t Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; The computation routine of the Chisquare test. For the method description,; see Chi2Test() function.; Returns p-value; parameters:; - h2-second histogram; - option:; ""UU"" = experiment experiment comparison (unweighted-unweighted); ""UW"" = experiment MC comparison (unweighted-weighted). Note that the first; histogram should be unweighted; ""WW"" = MC MC comparison (weighted-weighted). ""NORM"" = if one or both histograms is scaled. ""OF"" = overflows included; ""UF"" = underflows included; by default underflows and overlows are not included. - igood:; igood=0 - no problems; For unweighted unweighted comparison; igood=1'There is a bin in the 1st histogram with less than 1 event'; igood=2'There is a bin in the 2nd histogram with less than 1 event'; igood=3'when the conditions for igood=1 and igood=2 are satisfied'; For unweighted weighted comparison; igood=1'There is a bin in the 1st histogram with less then 1 event'; igood=2'There is a bin in the 2nd histo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:54324,test,test,54324,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,2,['test'],['test']
Testability,"ory(; ""TMVA_CNN_Classification"", outputFile,; ""!V:ROC:!Silent:Color:AnalysisType=Classification:Transformations=None:!Correlations"");; ; /***; ; ## Declare DataLoader(s); ; The next step is to declare the DataLoader class that deals with input variables; ; Define the input variables that shall be used for the MVA training; note that you may also use variable expressions, which can be parsed by TTree::Draw( ""expression"" )]; ; In this case the input data consists of an image of 16x16 pixels. Each single pixel is a branch in a ROOT TTree; ; **/; ; TMVA::DataLoader loader(""dataset"");; ; /***; ; ## Setup Dataset(s); ; Define input data file and signal and background trees; ; **/; ; std::unique_ptr<TFile> inputFile{TFile::Open(inputFileName)};; if (!inputFile) {; Error(""TMVA_CNN_Classification"", ""Error opening input file %s - exit"", inputFileName.Data());; return;; }; ; // --- Register the training and test trees; ; auto signalTree = inputFile->Get<TTree>(""sig_tree"");; auto backgroundTree = inputFile->Get<TTree>(""bkg_tree"");; ; if (!signalTree) {; Error(""TMVA_CNN_Classification"", ""Could not find signal tree in file '%s'"", inputFileName.Data());; return;; }; if (!backgroundTree) {; Error(""TMVA_CNN_Classification"", ""Could not find background tree in file '%s'"", inputFileName.Data());; return;; }; ; int nEventsSig = signalTree->GetEntries();; int nEventsBkg = backgroundTree->GetEntries();; ; // global event weights per tree (see below for setting event-wise weights); Double_t signalWeight = 1.0;; Double_t backgroundWeight = 1.0;; ; // You can add an arbitrary number of signal or background trees; loader.AddSignalTree(signalTree, signalWeight);; loader.AddBackgroundTree(backgroundTree, backgroundWeight);; ; /// add event variables (image); /// use new method (from ROOT 6.20 to add a variable array for all image data); loader.AddVariablesArray(""vars"", imgSize);; ; // Set individual event weights (the variables must exist in the original TTree); // for signal : factory->SetSigna",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:51026,test,test,51026,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['test'],['test']
Testability,"ory.h""; 22 ; 23#include <cmath>; 24 ; 25#include <string>; 26#include <sstream>; 27 ; 28#include ""Math/Error.h""; 29 ; 30//#define DEBUG; 31#ifdef DEBUG; 32#endif; 33 ; 34namespace ROOT {; 35 ; 36namespace Fit {; 37 ; 38 ; 39 ; 40FitConfig::FitConfig(unsigned int npar) :; 41 fNormErrors(false),; 42 fParabErrors(false), // ensure that in any case correct parabolic errors are estimated; 43 fMinosErrors(false), // do full Minos error analysis for all parameters; 44 fUpdateAfterFit(true), // update after fit; 45 fWeightCorr(false),; 46 fSettings(std::vector<ParameterSettings>(npar) ); 47{; 48 // constructor implementation; 49}; 50 ; 51 ; 52FitConfig::~FitConfig(); 53{; 54 // destructor implementation. No Operations; 55}; 56 ; 57FitConfig::FitConfig(const FitConfig &rhs) {; 58 // Implementation of copy constructor; 59 (*this) = rhs;; 60}; 61 ; 62FitConfig & FitConfig::operator = (const FitConfig &rhs) {; 63 // Implementation of assignment operator.; 64 if (this == &rhs) return *this; // time saving self-test; 65 ; 66 fNormErrors = rhs.fNormErrors;; 67 fParabErrors = rhs.fParabErrors;; 68 fMinosErrors = rhs.fMinosErrors;; 69 fUpdateAfterFit = rhs.fUpdateAfterFit;; 70 fWeightCorr = rhs.fWeightCorr;; 71 ; 72 fSettings = rhs.fSettings;; 73 fMinosParams = rhs.fMinosParams;; 74 ; 75 fMinimizerOpts = rhs.fMinimizerOpts;; 76 ; 77 return *this;; 78}; 79 ; 80void FitConfig::SetFromFitResult(const FitResult &result) {; 81 // Implementation of setting of parameters from the result of the fit; 82 // all the other options will stay the same.; 83 // If the size of parameters do not match they will be re-created; 84 // but in that case the bound on the parameter will be lost; 85 ; 86 unsigned int npar = result.NPar();; 87 if (fSettings.size() != npar) {; 88 fSettings.clear();; 89 fSettings.resize(npar);; 90 }; 91 // fill the parameter settings; 92 for (unsigned int i = 0; i < npar; ++i) {; 93 if (result.IsParameterFixed(i) ); 94 fSettings[i].Set(result.ParName(i), result.Value(i) );; 95 e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/FitConfig_8cxx_source.html:1753,test,test,1753,doc/master/FitConfig_8cxx_source.html,https://root.cern,https://root.cern/doc/master/FitConfig_8cxx_source.html,1,['test'],['test']
Testability,"ory_Fisher_1_dsi] : Added class ""Background""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Background""; : Reading weight file: dataset/weights/TMVAClassificationCategory_LikelihoodCat.weights.xml; : Recreating sub-classifiers from XML-file ; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Background""; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Background""; <HEADER> Factory : Test all methods; <HEADER> Factory : Test method: Fisher for Classification performance; : ; <HEADER> Fisher : [dataset] : Evaluation of Fisher on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00318 sec ; <HEADER> Factory : Test method: Likelihood for Classification performance; : ; <HEADER> Likelihood : [dataset] : Evaluation of Likelihood on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00959 sec ; <HEADER> Factory : Test method: FisherCat for Classification performance; : ; <HEADER> Category_Fisher_1 : [Category_Fisher_1_dsi] : Evaluation of Category_Fisher_1 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00192 sec ; <HEADER> Category_Fisher_2 : [Category_Fisher_2_dsi] : Evaluation of Category_Fisher_2 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00196 sec ; <HEADER> Factory : Test method: LikelihoodCat for Classification performance; : ; <HEADER> Category_Likelihood_1 : [Category_Likelihood_1_dsi] : Evaluation of Category_Likelihood_1 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00948 sec ; <HEADER> Category_Likelihood_2 : [Category_Likelihood_2_dsi] : Evaluation of Category_Likelihood_2 on testing sample (10000 events); : Elapsed time for ev",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassificationCategory_8C.html:22964,test,testing,22964,doc/master/TMVAClassificationCategory_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html,1,['test'],['testing']
Testability,"os error for parameter i; 348 fMinosErrors[i] = std::make_pair(elow,eup);; 349}; 350 ; 351int FitResult::Index(const std::string & name) const {; 352 // find index for given parameter name; 353 if (! fFitFunc) return -1;; 354 unsigned int npar = fParams.size();; 355 for (unsigned int i = 0; i < npar; ++i); 356 if ( fFitFunc->ParameterName(i) == name) return i;; 357 ; 358 return -1; // case name is not found; 359}; 360 ; 361bool FitResult::IsParameterBound(unsigned int ipar) const {; 362 return fBoundParams.find(ipar) != fBoundParams.end();; 363}; 364 ; 365bool FitResult::IsParameterFixed(unsigned int ipar) const {; 366 return fFixedParams.find(ipar) != fFixedParams.end();; 367}; 368 ; 369bool FitResult::ParameterBounds(unsigned int ipar, double & lower, double & upper) const {; 370 std::map<unsigned int, unsigned int>::const_iterator itr = fBoundParams.find(ipar);; 371 if (itr == fBoundParams.end() ) {; 372 lower = -std::numeric_limits<Double_t>::infinity();; 373 upper = std::numeric_limits<Double_t>::infinity();; 374 return false;; 375 }; 376 assert(itr->second < fParamBounds.size() );; 377 lower = fParamBounds[itr->second].first;; 378 upper = fParamBounds[itr->second].second;; 379 return true;; 380}; 381 ; 382std::string FitResult::ParName(unsigned int ipar) const {; 383 // return parameter name; 384 if (fFitFunc) return fFitFunc->ParameterName(ipar);; 385 else if (ipar < fParNames.size() ) return fParNames[ipar];; 386 return ""param_"" + ROOT::Math::Util::ToString(ipar);; 387}; 388 ; 389void FitResult::Print(std::ostream & os, bool doCovMatrix) const {; 390 // print the result in the given stream; 391 // need to add also minos errors , globalCC, etc..; 392 unsigned int npar = fParams.size();; 393 if (npar == 0) {; 394 os << ""<Empty FitResult>\n"";; 395 return;; 396 }; 397 os << ""****************************************\n"";; 398 if (!fValid) {; 399 if (fStatus != gInitialResultStatus) {; 400 os << "" Invalid FitResult"";; 401 os << "" (status = "" << fStatus << "" )"";; 40",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/FitResult_8cxx_source.html:12911,assert,assert,12911,doc/master/FitResult_8cxx_source.html,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html,1,['assert'],['assert']
Testability,"oseOptions (Bool_t b=kTRUE);  ; const TString & GetReferenceFile () const;  ; Bool_t LooseOptionCheckingEnabled () const;  ; void ResetSetFlag ();  resets the IsSet flag for all declare options to be called before options are read from stream ;  ; void WriteOptionsReferenceToFile ();  write complete options to output stream ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Types::EAnalysisType fAnalysisType;  ; UInt_t fBackgroundClass;  ; bool fExitFromTraining = false;  ; std::vector< TString > * fInputVars;  ; IPythonInteractive * fInteractive = nullptr;  temporary dataset used when evaluating on a different data (used by MethodCategory::GetMvaValues) ;  ; UInt_t fIPyCurrentIter = 0;  ; UInt_t fIPyMaxIter = 0;  ; std::vector< Float_t > * fMulticlassReturnVal;  ; Int_t fNbins;  ; Int_t fNbinsH;  ; Int_t fNbinsMVAoutput;  ; Ranking * fRanking;  ; std::vector< Float_t > * fRegressionReturnVal;  ; Results * fResults;  ; UInt_t fSignalClass;  ; DataSet * fTmpData = nullptr;  temporary event when testing on a different DataSet than the own one ;  ; const Event * fTmpEvent;  ;  Protected Attributes inherited from TMVA::Configurable; MsgLogger * fLogger;  ! message logger ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Types; enum  ECutOrientation { kNegative = -1; , kPositive = +1; };  . Private Member Functions; void AddClassesXMLTo (void *parent) const;  write class info to XML ;  ; virtual void AddClassifierOutput (Types::ETreeType type);  prepare tree branch with the method's discriminating variable ;  ; virtual void AddClassifierOutputProb (Types::ETreeType type);  prepare tree branch with the method's discriminating variable ;  ; void AddInfoItem (void *gi, const TString &name, const TString &value) const;  xml writing ;  ; virtual vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBase.html:27767,test,testing,27767,doc/master/classTMVA_1_1MethodBase.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBase.html,2,"['log', 'test']","['logger', 'testing']"
Testability,"ositioned - it represents the global reference frame. After building the full geometry tree, the geometry must be closed (see TGeoManager::CloseGeometry()). Voxelization can be redone per volume after this process.; Below is the general scheme of the manager class. An interactive session; Provided that a geometry was successfully built and closed (for instance the previous example $ROOTSYS/tutorials/geom/rootgeom.C ), the manager class will register itself to ROOT and the logical/physical structures will become immediately browsable. The ROOT browser will display starting from the geometry folder : the list of transformations and media, the top volume and the top logical node. These last two can be fully expanded, any intermediate volume/node in the browser being subject of direct access context menu operations (right mouse button click). All user utilities of classes TGeoManager, TGeoVolume and TGeoNode can be called via the context menu. Drawing the geometry; Any logical volume can be drawn via TGeoVolume::Draw() member function. This can be directly accessed from the context menu of the volume object directly from the browser. There are several drawing options that can be set with TGeoManager::SetVisOption(Int_t opt) method :; opt=0; only the content of the volume is drawn, N levels down (default N=3). This is the default behavior. The number of levels to be drawn can be changed via TGeoManager::SetVisLevel(Int_t level) method. opt=1; the final leaves (e.g. daughters with no containment) of the branch starting from volume are drawn down to the current number of levels. WARNING : This mode is memory consuming depending of the size of geometry, so drawing from top level within this mode should be handled with care for expensive geometries. In future there will be a limitation on the maximum number of nodes to be visualized. opt=2; only the clicked volume is visualized. This is automatically set by TGeoVolume::DrawOnly() method; opt=3 - only a given path is visualiz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:16032,log,logical,16032,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['log'],['logical']
Testability,"ossValidation_Fisher_fold1.class.C; <HEADER> Factory : Test all methods; <HEADER> Factory : Test method: Fisher_fold1 for Classification performance; : ; <HEADER> Fisher_fold1 : [datasetcv] : Evaluation of Fisher_fold1 on testing sample (998 events); : Elapsed time for evaluation of 998 events: 0.000121 sec ; <HEADER> Factory : Evaluate all methods; <HEADER> Factory : Evaluate classifier: Fisher_fold1; : ; <HEADER> Fisher_fold1 : [datasetcv] : Loop over test events and fill histograms with classifier response...; : ; : ; : Evaluation results ranked by best signal efficiency and purity (area); : -------------------------------------------------------------------------------------------------------------------; : DataSet MVA ; : Name: Method: ROC-integ; : datasetcv Fisher_fold1 : 0.976; : -------------------------------------------------------------------------------------------------------------------; : ; : Testing efficiency compared to training efficiency (overtraining check); : -------------------------------------------------------------------------------------------------------------------; : DataSet MVA Signal efficiency: from test sample (from training sample) ; : Name: Method: @B=0.01 @B=0.10 @B=0.30 ; : -------------------------------------------------------------------------------------------------------------------; : datasetcv Fisher_fold1 : 0.660 (0.665) 0.952 (0.923) 0.986 (0.985); : -------------------------------------------------------------------------------------------------------------------; : ; <HEADER> Factory : Thank you for using TMVA!; : For citation information, please visit: http://tmva.sf.net/citeTMVA.html; <HEADER> Factory : Booking method: Fisher_fold2; : ; <HEADER> Fisher_fold2 : Results for Fisher coefficients:; : -----------------------; : Variable: Coefficient:; : -----------------------; : x: +0.501; : y: +0.467; : (offset): -0.000; : -----------------------; : Elapsed time for training with 998 events: 0.000263 sec ; <HEADER> Fis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidation_8C.html:10338,test,test,10338,doc/master/TMVACrossValidation_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidation_8C.html,1,['test'],['test']
Testability,"ostream& o) const; voidScaleBoostWeight(Double_t s) const; voidSetBoostWeight(Double_t w) const; voidSetClass(UInt_t t); voidSetDoNotBoost() const; static voidSetIgnoreNegWeightsInTraining(Bool_t); static voidSetIsTraining(Bool_t); voidSetSpectator(UInt_t ivar, Float_t value); voidSetTarget(UInt_t itgt, Float_t value); voidSetVal(UInt_t ivar, Float_t val); voidSetVariableArrangement(vector<UInt_t> *const m) const; voidSetWeight(Double_t w). Data Members; private:. Double_tfBoostWeightinternal weight to be set by boosting algorithm; UInt_tfClassclass number; Bool_tfDoNotBoostmark event as not to be boosted (used to compensate for events with negative event weights; Bool_tfDynamicis set when the dynamic values are taken; vector<Float_t>fSpectators""visisting"" variables not used in MVAs ; mutable, to be able to copy the dynamic values in there; vector<Float_t>fTargetstarget values for regression; vector<Float_t>fValuesthe event values ; mutable, to be able to copy the dynamic values in there; vector<Float_t*>*fValuesDynamicthe event values; vector<Float_t>fValuesRearrangedthe event values ; mutable, to be able to copy the dynamic values in there; vector<UInt_t>*fVariableArrangementneeded for MethodCategories, where we can train on other than the main variables; Double_tfWeightevent weight (product of global and individual weights); static Bool_tfgIgnoreNegWeightsInTraining; static Bool_tfgIsTrainingmark if we are in an actual training or ""evaluation/testing"" phase --> ignoreNegWeights only in actual training !. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Event(); Create an Event object.; When the constructor is invoked for the first time, the class static; variable fgTracks is 0 and the TClonesArray fgTracks is created. ~Event(). Event(); constructors. Event(const TMVA::Event& ). explicit Event(const vector<Float_t>& values, const vector<Float_t>& targetValues, const vector<Float_t>& spectatorValues, UInt_t theClass = 0, Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__Event.html:5911,test,testing,5911,root/html534/TMVA__Event.html,https://root.cern,https://root.cern/root/html534/TMVA__Event.html,1,['test'],['testing']
Testability,"ot independent of \(\mathbf{x}\)) quantities \(\mathbf{Q}^\prime\); For each component \(Q^\prime_i\) make a multidimensional fit, using \(\mathbf{x}^\prime\) as the variables, thus determining a set of coefficients \(\mathbf{c}_i\). To process data, using this parameterisation, do; Test wether the observation \(\mathbf{x}\) within the domain of the parameterization, using the result from the Principal Component Analysis.; Determine \(\mathbf{P}^\prime\) as before.; Determine \(\mathbf{x}^\prime\) as before.; Use the result of the fit to determine \(\mathbf{Q}^\prime\).; Transform back to \(\mathbf{P}\) from \(\mathbf{Q}^\prime\), using the result from the Principal Component Analysis. Testing the parameterization; The class also provides functionality for testing the, over the training sample, found parameterization (TMultiDimFit::Fit). This is done by passing the class a test sample of \( M_t\) tuples of the form \((\mathbf{x}_{t,j},D_{t,j}, E_{t,j})\), where \(\mathbf{x}_{t,j}\) are the independent variables, \( D_{t,j}\) the known, dependent quantity, and \( E_{t,j}\) is the square error in \( D_{t,j}\) (TMultiDimFit::AddTestRow).; The parameterization is then evaluated at every \(\mathbf{x}_t\) in the test sample, and ; \[; S_t \equiv \sum_{j=1}^{M_t} \left(D_{t,j} -; D_p\left(\mathbf{x}_{t,j}\right)\right)^2; \]. is evaluated. The relative error over the test sample ; \[; R_t = \frac{S_t}{\sum_{j=1}^{M_t} D_{t,j}^2}; \]. should not be to low or high compared to \( R\) from the training sample. Also, multiple correlation coefficient from both samples should be fairly close, otherwise one of the samples is not representative of the problem. A large difference in the reduced \( \chi^2\) over the two samples indicate an over fit, and the maximum number of terms in the parameterisation should be reduced.; It's possible to use 4 to further improve the fit, using the test sample.; Christian Holm. Bibliography. Philip R. Bevington and D. Keith Robinson. Data Reduction ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiDimFit.html:16008,test,test,16008,doc/master/classTMultiDimFit.html,https://root.cern,https://root.cern/doc/master/classTMultiDimFit.html,1,['test'],['test']
Testability,"ot to fit). ; Definition at line 67 of file TSpectrumFit.h. ◆ fFixAmp. Bool_t* TSpectrumFit::fFixAmp. protected . [fNPeaks] array of logical values which allow to fix appropriate amplitudes (not fit). However they are present in the estimated functional ; Definition at line 60 of file TSpectrumFit.h. ◆ fFixB. Bool_t TSpectrumFit::fFixB. protected . logical value of b parameter, which allows to fix the parameter (not to fit). ; Definition at line 63 of file TSpectrumFit.h. ◆ fFixPosition. Bool_t* TSpectrumFit::fFixPosition. protected . [fNPeaks] array of logical values which allow to fix appropriate positions (not fit). However they are present in the estimated functional ; Definition at line 59 of file TSpectrumFit.h. ◆ fFixS. Bool_t TSpectrumFit::fFixS. protected . logical value of s parameter, which allows to fix the parameter (not to fit). ; Definition at line 64 of file TSpectrumFit.h. ◆ fFixSigma. Bool_t TSpectrumFit::fFixSigma. protected . logical value of sigma parameter, which allows to fix the parameter (not to fit). ; Definition at line 61 of file TSpectrumFit.h. ◆ fFixT. Bool_t TSpectrumFit::fFixT. protected . logical value of t parameter, which allows to fix the parameter (not to fit). ; Definition at line 62 of file TSpectrumFit.h. ◆ fNPeaks. Int_t TSpectrumFit::fNPeaks. protected . number of peaks present in fit, input parameter, it should be > 0 ; Definition at line 20 of file TSpectrumFit.h. ◆ fNumberIterations. Int_t TSpectrumFit::fNumberIterations. protected . number of iterations in fitting procedure, input parameter, it should be > 0 ; Definition at line 21 of file TSpectrumFit.h. ◆ fPositionCalc. Double_t* TSpectrumFit::fPositionCalc. protected . [fNPeaks] array of calculated values of fitted positions, output parameters ; Definition at line 31 of file TSpectrumFit.h. ◆ fPositionErr. Double_t* TSpectrumFit::fPositionErr. protected . [fNPeaks] array of position errors ; Definition at line 32 of file TSpectrumFit.h. ◆ fPositionInit. Double_t* TSpe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrumFit.html:54368,log,logical,54368,doc/master/classTSpectrumFit.html,https://root.cern,https://root.cern/doc/master/classTSpectrumFit.html,1,['log'],['logical']
Testability,"ot to; fit).; �� Bool_t���; fFixTxy;����������������������� //logical value of t parameter for 2D peaks,; which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSxy;����������������������� //logical value of s parameter for 2D peaks,; which allows to fix the parameter (not to fit).; �� Bool_t���; fFixTx;������������������������ //logical value of t parameter for 1D ridges in; x direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixTy;������������������������ //logical value of t parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSx;������������������������ //logical value of s parameter for 1D ridges in; x direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSy;������������������������ //logical value of s parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t��� fFixBx;�� ����������������������//logical; value of b parameter for 1D ridges in x direction, which allows to fix the; parameter (not to fit).; �� Bool_t���; fFixBy;������������������������ //logical value of b parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixA0;������������������������ //logical value of a0 parameter, which allows; to fix the parameter (not to fit).; �� Bool_t���; fFixAx;������������������������ //logical value of ax parameter, which allows; to fix the parameter (not to fit).; �� Bool_t���; fFixAy;������������������������ //logical value of ay parameter, which allows; to fix the parameter (not to fit).; �; References:; [1] Phillps G.W., Marlow K.W.,; NIM 137 (1976) 525.; [2] I. A. Slavic: Nonlinear; least-squares fitting without matrix inversion applied to complex Gaussian; spectra analysis. NIM 134 (1976) 285-289.; [3] T. Awaya: A new method for; curve fitting to the data with low statistics not using chi-square method. NIM; 165 (1979) 317-323.; [4] T. Hauschild, M. Jents",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2Fit.html:50118,log,logical,50118,root/html528/TSpectrum2Fit.html,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html,6,['log'],['logical']
Testability,"ot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); const RooArgList&paramList() const; virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooJeffreysPrior.html:23344,test,testArg,23344,root/html534/RooJeffreysPrior.html,https://root.cern,https://root.cern/root/html534/RooJeffreysPrior.html,1,['test'],['testArg']
Testability,"otUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsAnaConvPdf.html:23590,test,testArg,23590,root/html532/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsAnaConvPdf.html,10,['test'],['testArg']
Testability,"otal processing time. In this case, if the I/O operation is increased by a factor of 5 it is still a small percentage of the total time and it may very well save a factor of 10 on disk space. On the other hand if the time spend on I/O is large, compression may slow down the program’s performance. The standard test program $ROOTSYS/test/Event was used in various configurations with 400 events. The data file contains a TTree. The program was invoked with:; Event 400 comp split. comp = 0 means: no compression at all.; comp = 1 means: compress everything if split = 0.; comp = 1 means: compress only the tree branches with integers if split = 1.; comp = 2 means: compress everything if split=1.; split = 0 : the full event is serialized into one single buffer.; split = 1 : the event is split into branches. One branch for each data member of the Event class. The list of tracks (a TClonesArray) has the data members of the Track class also split into individual buffers. These tests were run on Pentium III CPU with 650 MHz. Event Parameters; File Size; Total Time to Write (MB/sec); Effective Time to Write (MB/sec); Total Time to Read All (MB/sec); Total Time to Read Sample (MB/sec). Comp = 0; Split = 1; 19.75 MB; 6.84 s.(2.8 MB/s); 3.56 s.(5.4 MB/s); 0.79s.(24.2 MB/s); 0.79 s.(24.2 MB/s). Comp = 1; Split = 1; 17.73 MB; 6.44 s.(3.0 MB/s); 4.02 s.(4.8 MB/s); 0.90 s.(21.3 MB/s); 0.90 s.(21.3 MB/s). Comp = 2; Split = 1; 13.78 MB; 11.34s.(1.7 MB/s); 9.51 s.(2.0 MB/s); 2.17 s.(8.8 MB/s); 2.17 s.(8.8 MB/s). The Total Time is the real time in seconds to run the program. Effective time is the real time minus the time spent in non I/O operations (essentially the random number generator). The program Event generates in average 600 tracks per event. Each track has 17 data members. The read benchmark runs in the interactive version of ROOT. The ‘Total Time to Read All’ is the real time reported by the execution of the script &ROOTSYS/test/eventa.; We did not correct this time for the overhe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:648866,test,tests,648866,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['test'],['tests']
Testability,"otated (analogous to a CVS tag), with an associated SHA1 hash and message. Annotated tags are preferable in general.; Tracking branch: a branch on a remote which is the default source / sink for pull / push operations respectively for the current branch. For instance, origin/master is the tracking branch for the local master in a local repository.; Tree-ish: a ref pointing to either a commit object, a tree object, or a tag object pointing to a tag or commit or tree object.; Un-tracked: not known currently to git. Initializing a repository; git clone <repository-spec> <local-dir>. or; mkdir <local-dir>; cd <local-dir>; git init. or (FNAL Redmine-specific); rclone [-r <repo>] <project> <local-name>. where rclone is defined in cet-chg:export:unix-admin/profile.d/rclone.sh ; Basic log information.>; git log []. Important tip: log messages have an optional structure, since many git commands only look at the first line. Get into the habit of putting only a short synopsis on the first line of a log message and putting more detailed information on subsequent lines. You can omit the -m option entirely and an editor (as specified with VISUAL or EDITOR) will be started.; This command is extremely versatile. You may want to have a couple of aliases defined in your .gitconfig file (see attached gitconfig for ideas). Working in your local repository. Obtain differences with; git status. Move files from one part of your directory tree to another:; git mv <old-path> <new-path>. Delete unwanted tracked files:; git rm <path>. Add un-tracked files:; git add <un-tracked-file>. Stage a modified file for commit:; git add <file>. Commit currently-staged files:; git commit -m <log-message>. Commit only specific files (regardless of what is staged):; git commit -m <log-message>. Commit all modified files:; git commit -a -m <log-message>. Un-stage a previously staged (but not yet committed) file:; git reset HEAD <file>. Examine a representation of your change tree with log files and patch de",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/git-tips-and-tricks.html:7119,log,log,7119,d/git-tips-and-tricks.html,https://root.cern,https://root.cern/d/git-tips-and-tricks.html,1,['log'],['log']
Testability,"otationDescribes a rotation of objects of the TVector3 class ;  CTRotationRow;  CTRotMatrixManages a detector rotation matrix ;  CTRSA_fun;  CTRWLock;  CTS3HTTPRequest;  CTS3WebFile;  CTSapDBResult;  CTSapDBRow;  CTSapDBServer;  CTSAXParserTSAXParser is a subclass of TXMLParser, it is a wraper class to libxml library ;  CTSecContext;  CTSecContextCleanup;  CTSelectorA TSelector object is used by the TTree::Draw, TTree::Scan, TTree::Process to navigate in a TTree and make selections ;  CTSelectorCintThis class is a special version of TSelector for user interpreted classes ;  CTSelectorDrawA specialized TSelector for TTree::Draw ;  CTSelectorEntriesThe class is derived from the ROOT class TSelector ;  CTSelectorListA TList derived class that makes sure that objects added to it are not linked to the currently open file (like histograms, eventlists and trees) ;  CTSelectorScalarNamed scalar type, based on Long64_t, streamable, storable and mergable ;  CTSelEventSelector for PROOF I/O benchmark test ;  CTSelEventGenSelector for event file generation ;  CTSelHandleDataSetPROOF selector for file cache release ;  CTSelHistPROOF selector for CPU-intensive benchmark test ;  CTSelVerifyDataSetSelector to verify dataset in parallel on workers ;  CTSemaphore;  CTSeqCollectionSequenceable collection abstract base class ;  CTServerSocket;  CTSessionDescription;  CTSessionFrame;  CTSessionInputFrame;  CTSessionLogView;  CTSessionOutputFrame;  CTSessionQueryFrame;  CTSessionServerFrame;  CTSessionViewer;  CTShapeThis is the base class for all geometry shapes ;  CTShutdownTimer;  CTSignalHandler;  CTSimpleAnalysisA TSimpleAnalysis object creates histograms from a TChain ;  CTSlaveClass describing a PROOF worker server ;  CTSlaveInfo;  CTSlaveLiteVersion of TSlave for local worker servers ;  CTSliderA specialized TPad including a TSliderBox object ;  CTSliderBoxThe moving box in a TSlider ;  CTSocket;  CTSortedListA sorted doubly linked list ;  CTSpectrumAdvanced Spectra Processing ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:185514,benchmark,benchmark,185514,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,2,['benchmark'],['benchmark']
Testability,"otected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidSetBins(const RooAbsCollection& coll, Int_t numBins) const; voidSetupBasicUsage(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. RooArgList*fAxeswhich variables to put on each axis; RooAbsData*fDatapointer to the data (owned by the workspace); Double_tfDeltaacceptable error for Keys cutoffs being equal; Double_tfEpsilonacceptable error for Keys interval determination; RooStats::MCMCInterval::IntervalTypefIntervalTypetype of interval to find; Double_tfLeftSideTFleft side tail-fraction for interval; TStringTNamed::fNameobject identifier; RooArgSetfNuisParamsnuisance parameters for interval (not really used); Int_tfNumBinsset the number of bins to create for each; Int_tfNumBurnInStepsnumber of iterations to discard as burn-in, starting from the first; Int_tfNumItersnumber of iterations to run metropolis algorithm; RooArgSetfPOIparameters of interest for interval; RooAbsPdf*fPdfpointer to common PDF (owned by the workspace); RooAbsPdf*fPriorPdfpointer to prior PDF (owned by the workspace); RooStats::ProposalFunction*fPropFuncProposal function for MCMC integration; Double_tfSizesize of the test (eg. specified rate of Type I error); TStringTNamed::fTitleobject title; Bool_tfUseKeyswhether to use kernel estimation to determine interval; Bool_tfUseSparseHistwhether to use sparse histogram (if using hist at all). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MCMCCalculator(). MCMCCalculator(RooAbsData& data, const RooStats::ModelConfig& model). void SetModel(const RooStats::ModelConfig& model); set the model. void SetupBasicUsage(). void SetLeftSideTailFract",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__MCMCCalculator.html:8176,test,test,8176,root/html528/RooStats__MCMCCalculator.html,https://root.cern,https://root.cern/root/html528/RooStats__MCMCCalculator.html,2,['test'],['test']
Testability,"oth are in the same tree.; // We distinguish them using TCut objects: selections as one would use in TTree::Draw(). ; TCut signalCut(""muons.fTriggered"");; TCut backgroundCut(""!muons.fTriggered"");; factory->SetInputTrees(tree, signalCut, backgroundCut);. // Now select which algorithm to run - it's not important here as long as it; // determines the parameter correlations.; factory->BookMethod( TMVA::Types::kFisher, ""Fisher"", ""H:!V"" );; // And start the correlation analysis:; factory->TestAllMethods();; }. Parameter correlations; We want to know what muons.fTriggered depends on. A simple check is to look for correlations: variables that it depends on might be linearly correlated. TMVA tells us that the muon and the X position is completely uncorrelated. It also tells us that the muons' pT and energy are somewhat correlated. But what would be the best parameter to determine the muon trigger efficiency - what is most correlated with it?; . ‹ 5. Fitting; up; 7. Using the TTreeReader ›. Navigate through this book; 0. Setting up ROOT; 1. Extracting an object from a TFile; 2. Running code in ROOT; 4. Histogramming; 3. Examining a TTree's data; 5. Fitting; 6. Multivariate Analysis; 7. Using the TTreeReader; 8. Efficiency Calculation; 9. Fitting By Coding; 10. Go Parallel!; TutorialSelector.C; 11. Done!. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/6-multivariate-analysis.html:6532,test,tests,6532,d/6-multivariate-analysis.html,https://root.cern,https://root.cern/d/6-multivariate-analysis.html,1,['test'],['tests']
Testability,"others: ksmooth, lowess, supsmu as described in: ;  ; file  multigraph.C;   Create and Draw a TMultiGraph. ;  ; file  multigraphpalettecolor.C;   Palette coloring for multi-graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ;  ; file  multipalette.C;   Draw color plots using different color palettes. ;  ; file  scatter.C;   Draw a scatter plot. ;  ; file  seism.C;   Strip chart example. ;  ; file  splines_test.C;   Examples of use of the spline classes. ;  ; file  surfaces.C;   Draw 2-Dim functions. ;  ; file  timeonaxis.C;   This macro illustrates the use of the time mode on the axis with different time intervals and time formats. ;  ; file  timeonaxis2.C;   Define the time offset as 2003, January 1st. ;  ; file  timeonaxis3.C;   This example compares what the system time function gmtime and localtime give with what gives TGaxis. ;  ; file  timeSeriesFromCSV.C;   This macro illustrates the use of the time axis on a TGraph with data read from a text file containing the SWAN usage statistics during July 2017. ;  ; file  timeSeriesFromCSV.py;   This macro illustrates the use of the time axis on a TGraph with data read from a text file containing the SWAN usage statistics during July 2017. ;  ; file  timeSeriesFromCSV_TDF.C;   This macro illustrates the use of the time axis on a TGraph with data read from a text file containing the SWAN usage statistics during July 2017. ;  ; file  waves.C;   Hint: Spherical waves ;  ; file  zdemo.C;   This macro is an example of graphs in log scales with annotations. ;  ; file  zones.C;   Example of script showing how to divide a canvas into adjacent subpads + axis labels on the top and right side of the pads. ;  ; file  zones.py;   Example of script showing how to divide a canvas into adjacent subpads + axis labels on the top and right side of the pads. ;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:34 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__graphs.html:3822,log,log,3822,doc/master/group__tutorial__graphs.html,https://root.cern,https://root.cern/doc/master/group__tutorial__graphs.html,1,['log'],['log']
Testability,"othesis of identity is valid, then the maximum likelihood and; 1920/// Least Square Method estimator of pi,i=1,...,r, is; 1921///\f[; 1922/// \hat{p}_{i} = \frac{w_{1i}W_{1}/s_{1i}^{2}+w_{2i}W_{2} /s_{2i}^{2}}{W_{1}^{2}/s_{1i}^{2}+W_{2}^{2}/s_{2i}^{2}}; 1923///\f]; 1924/// We may then use the test statistic; 1925///\f[; 1926/// X^{2} = \sum_{i=1}^{r} \frac{(w_{1i}-W_{1}\hat{p}_{i})^{2}}{s_{1i}^{2}} + \sum_{i=1}^{r} \frac{(w_{2i}-W_{2}\hat{p}_{i})^{2}}{s_{2i}^{2}} = \sum_{i=1}^{r} \frac{(W_{1}w_{2i}-W_{2}w_{1i})^{2}}{W_{1}^{2}s_{2i}^{2}+W_{2}^{2}s_{1i}^{2}}; 1927///\f]; 1928/// and it has approximately a \f$ \chi^{2}_{(r-1)} \f$ distribution [2].; 1929/// The normalized or studentised residuals [6]; 1930///\f[; 1931/// r_{i} = \frac{w_{1i}-W_{1}\hat{p}_{i}}{s_{1i}\sqrt{1 - \frac{1}{(1+W_{2}^{2}s_{1i}^{2}/W_{1}^{2}s_{2i}^{2})}}}; 1932///\f]; 1933/// have approximately a normal distribution with mean equal to 0 and standard; 1934/// deviation 1. A recommended minimal expected frequency is equal to 10 for; 1935/// the proposed test.; 1936///; 1937/// #### Numerical examples:; 1938///; 1939/// The method described herein is now illustrated with an example.; 1940/// We take a distribution; 1941///\f[; 1942/// \phi(x) = \frac{2}{(x-10)^{2}+1} + \frac{1}{(x-14)^{2}+1} (1); 1943///\f]; 1944/// defined on the interval [4,16]. Events distributed according to the formula; 1945/// (1) are simulated to create the unweighted histogram. Uniformly distributed; 1946/// events are simulated for the weighted histogram with weights calculated by; 1947/// formula (1). Each histogram has the same number of bins: 20. Fig.1 shows; 1948/// the result of comparison of the unweighted histogram with 200 events; 1949/// (minimal expected frequency equal to one) and the weighted histogram with; 1950/// 500 events (minimal expected frequency equal to 25); 1951/// Begin_Macro; 1952/// ../../../tutorials/math/chi2test.C; 1953/// End_Macro; 1954/// Fig 1. An example of comparison of the unweighted hi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:78159,test,test,78159,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['test'],['test']
Testability,"ots = df.GetNSlots();; std::vector<double> sumSqs(nSlots, 0.);; std::vector<unsigned int> ns(nSlots, 0);; ; df.ForeachSlot([&sumSqs, &ns](unsigned int slot, double x) { sumSqs[slot] += x*x; ns[slot] += 1; }, {""x""});; double sumSq = std::accumulate(sumSqs.begin(), sumSqs.end(), 0.); // sum all squares; unsigned int n = std::accumulate(ns.begin(), ns.end(), 0); // sum all counts; std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; Notice how we created one double variable for each processing slot and later merged their results via std::accumulate. Dataset joins with friend trees; Vertically concatenating multiple trees that have the same columns (creating a logical dataset with the same columns and more rows) is trivial in RDataFrame: just pass the tree name and a list of file names to RDataFrame's constructor, or create a TChain out of the desired trees and pass that to RDataFrame.; Horizontal concatenations of trees or chains (creating a logical dataset with the same number of rows and the union of the columns of multiple trees) leverages TTree's ""friend"" mechanism.; Simple joins of trees that do not have the same number of rows are also possible with indexed friend trees (see below).; To use friend trees in RDataFrame, set up trees with the appropriate relationships and then instantiate an RDataFrame with the main tree:; TTree main([...]);; TTree friend([...]);; main.AddFriend(&friend, ""myFriend"");; ; RDataFrame df(main);; auto df2 = df.Filter(""myFriend.MyCol == 42"");; The same applies for TChains. Columns coming from the friend trees can be referred to by their full name, like in the example above, or the friend tree name can be omitted in case the column name is not ambiguous (e.g. ""MyCol"" could be used instead of ""myFriend.MyCol"" in the example above if there is no column ""MyCol"" in the main tree).; NoteA common source of confusion is that trees that are written out from a multi-thread Snapshot() call will have their entries (block-wise) shuffled wit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:70129,log,logical,70129,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['log'],['logical']
Testability,"ou want to merge or rebase (see below) to import changes from a branch without having to commit your current work. Save uncommitted changes to the current working area to the stash (not a commit operation):; git stash. Apply previously-saved stash:; git stash pop. (pops off the changes and applies them to the current working area) or; git stash apply. which applies the changes but retains them on the stack.; Examine the current state of the stash:; git stash list. Clear the entire stash:; git stash clear. Rebasing; Rebasing is changing history, if you think that git stores history. As mentioned above, it doesn't: it saves objects with parent, child and other (eg date, author, etc) information. In a truly distributed environment, the actual history will be different for every repository depending exactly how and when changes were fetched, merged or pushed.; Rebasing is a good way to do a couple of things:. ""Squash"" related commits in your local repository prior to a push (eg, ""Implement feature X,"" ""Tests for feature X"" and, ""Fix bugs found while testing feature X"").; Simplify merging branches and keeping up-to-date with remote changes during long periods between pushes. Important tip: do not attempt to rebase anything that has already been pushed to a remote repository. Your next push will almost certainly fail (and quite right too). Squashing related commits:. Squash some of the last few commits in your current branch:; git rebase -i HEAD~5. Your configured editor (VISUAL or EDITOR) will be started and contain a list of your last five commits (most recent at the bottom) along with instructions on what to do. Commits can have their log messages reworded; commits can be removed entirely, combined with other commits or re-ordered. If you specified any rewording or squashing, you will be taken to an edit session for the commit message(s) after saving and exiting the current edit session.; Squash, re-order or reword commits since divergence from :; git rebase -i <branch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/git-tips-and-tricks.html:11616,test,testing,11616,d/git-tips-and-tricks.html,https://root.cern,https://root.cern/d/git-tips-and-tricks.html,1,['test'],['testing']
Testability,"ouble * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError(unsigned int ipoint, double& errvalue) const. Retrieve the errors on the point (coordinate and value) for the given fit point; It must be called only when the coordinate errors are stored otherwise it will produce an; assert. const double * GetPointError(unsigned int ipoint, double& errlow, double& errhigh) const. Get errors on the point (coordinate errors and asymmetric value errors) for the; given fit point.; It must be called only when the coordinate errors and asymmetric errors are stored; otherwise it will produce an assert. void Resize(unsigned int npoints). resize the vector to the new given npoints; if vector does not exists is created using existing point size. unsigned int NPoints() const. return number of fit points. { return fNPoints; }. unsigned int Size() const. return number of fit points. { return fNPoints; }. unsigned int NDim() const. return coordinate data dimension. { return fDim; }. BinData & LogTransform(). apply a Log transformation of the data values; can be used for example when fitting an exponential or gaussian; Transform the data in place need to copy if want to preserve original data; The data sets must not contain negative values. IN case it does,; an empty data set is returned. const double * BinUpEdge(unsigned int icoord) const. return an array containing the upper edge of the bin for coordinate i; In case of empty bin they could be merged in a single larger bin; Return a NULL pointer if the bin width is not stored. bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Fit__BinData.html:11070,assert,assert,11070,root/html526/ROOT__Fit__BinData.html,https://root.cern,https://root.cern/root/html526/ROOT__Fit__BinData.html,7,['assert'],['assert']
Testability,"ouble GetExpectedLimit(double nsig, bool lower, const char* opt = """") const; get expected limit (lower/upper) depending on the flag; for asymptotic is a special case (the distribution is generated an step in sigma values); distringuish asymptotic looking at the hypotest results; if option = ""P"" get expected limit using directly quantiles of p value distribution; else (default) find expected limit by obtaining first a full limit distributions; The last one is in general more correct. explicit HypoTestInverterResult(const char* name = 0); default constructor. double GetLastYValue() const; { return GetYValue( fXValues.size()-1); }. double GetLastXValue() const; { return GetXValue( fXValues.size()-1); }. double GetLastYError() const; { return GetYError( fXValues.size()-1); }. HypoTestResult * GetLastResult() const; { return GetResult( fXValues.size()-1); }. int ArraySize() const; number of entries in the results array. { return fXValues.size(); }. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) (eg. 0.05 for a 95% Confidence Interval). { fConfidenceLevel = 1.-size; }. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). { fConfidenceLevel = cl; }. void SetCLsCleanupThreshold(Double_t th); set CLs threshold for exclusion cleanup function. { fCLsCleanupThreshold = th; }. void UseCLs(bool on = true); flag to switch between using CLsb (default) or CLs as confidence level. { fUseCLs = on; }. bool IsOneSided() const; query if one sided result. { return !fIsTwoSided; }. bool IsTwoSided() const; query if two sided result. { return fIsTwoSided; }. SamplingDistribution * GetNullTestStatDist(int index) const; same in terms of alt and null. SamplingDistribution * GetAltTestStatDist(int index) const. SamplingDistribution* GetLowerLimitDistribution() const; get expected lower limit distributions; implemented using interpolation; The size for the sampling distribution is given (by def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HypoTestInverterResult.html:17926,test,test,17926,root/html602/RooStats__HypoTestInverterResult.html,https://root.cern,https://root.cern/root/html602/RooStats__HypoTestInverterResult.html,2,['test'],['test']
Testability,"ouble RooProjectedPdf::expectedEvents ; (; const RooArgSet * ; nset); const. inlineoverridevirtual . Return expected number of events to be used in calculation of extended likelihood. ; Return expected number of events from this p.d.f for use in extended likelihood calculations.; This default implementation returns zero ; Reimplemented from RooAbsPdf.; Reimplemented in xRooProjectedPdf.; Definition at line 46 of file RooProjectedPdf.h. ◆ extendMode(). ExtendMode RooProjectedPdf::extendMode ; (; ); const. inlineoverridevirtual . Returns ability of PDF to provide extended likelihood terms. ; Possible answers are in the enumerator RooAbsPdf::ExtendMode. This default implementation always returns CanNotBeExtended. ; Reimplemented from RooAbsPdf.; Reimplemented in xRooProjectedPdf.; Definition at line 47 of file RooProjectedPdf.h. ◆ forceAnalyticalInt(). bool RooProjectedPdf::forceAnalyticalInt ; (; const RooAbsArg & ; dep); const. overridevirtual . Force RooRealIntegral to relegate integration of all observables to internal logic. ; Reimplemented from RooAbsReal.; Definition at line 157 of file RooProjectedPdf.cxx. ◆ getAnalyticalIntegralWN(). Int_t RooProjectedPdf::getAnalyticalIntegralWN ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const RooArgSet * ; normSet, . const char * ; rangeName = nullptr . ); const. overridevirtual . Mark all requested variables as internally integrated. ; Reimplemented from RooAbsReal.; Definition at line 167 of file RooProjectedPdf.cxx. ◆ getProjection(). const RooAbsReal * RooProjectedPdf::getProjection ; (; const RooArgSet * ; iset, . const RooArgSet * ; nset, . const char * ; rangeName, . int & ; code . ); const. protected . Retrieve object representing projection integral of input p.d.f over observables iset, while normalizing over observables nset. ; The code argument returned by reference is the unique code defining this particular projection configuration ; Definition at line 109 of file RooProjectedPdf.cxx. ◆ initGenerato",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProjectedPdf.html:78440,log,logic,78440,doc/master/classRooProjectedPdf.html,https://root.cern,https://root.cern/doc/master/classRooProjectedPdf.html,1,['log'],['logic']
Testability,"ouble_t EvaluateTestStatistic(RooAbsData& data, RooArgSet& paramsOfInterest); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetTestStatistic() const; Get the TestStatistic. Double_t ConfidenceLevel() const; Get the Confidence level for the test. void Initialize(RooAbsArg& testStatistic, RooArgSet& paramsOfInterest, RooArgSet& nuisanceParameters); Common Initialization. void SetPdf(RooAbsPdf& ); Set the Pdf, add to the the workspace if not already there. void SetPriorNuisance(RooAbsPdf* ); How to randomize the prior. Set to NULL to deactivate randomization. void SetParametersForTestStat(const RooArgSet& ); specify the values of parameters used when evaluating test statistic. void SetNuisanceParameters(const RooArgSet& ); REMOVE THIS; specify the parameters of interest in the interval; virtual void SetParameters(const RooArgSet&) = 0;; specify the nuisance parameters (eg. the rest of the parameters). void SetObservables(const RooArgSet& ); specify the observables in the dataset (needed to evaluate the test statistic). void SetGlobalObservables(const RooArgSet& ); specify the conditional observables. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). void SetTestStatistic(RooStats::TestStatistic* testStatistic); Set the TestStatistic (want the argument to be a function of the data & parameter points. void SetSamplingDistName(const char* name); Set the name of the sampling distribution used for plotting. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id$ » Last generated: 2015-06-30 14:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT su",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__TestStatSampler.html:3287,test,test,3287,root/html602/RooStats__TestStatSampler.html,https://root.cern,https://root.cern/root/html602/RooStats__TestStatSampler.html,1,['test'],['test']
Testability,"ouble_t EvaluateTestStatistic(RooAbsData& data, RooArgSet& paramsOfInterest); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetTestStatistic() const; Get the TestStatistic. Double_t ConfidenceLevel() const; Get the Confidence level for the test. void Initialize(RooAbsArg& testStatistic, RooArgSet& paramsOfInterest, RooArgSet& nuisanceParameters); Common Initialization. void SetPdf(RooAbsPdf& ); Set the Pdf, add to the the workspace if not already there. void SetPriorNuisance(RooAbsPdf* ); How to randomize the prior. Set to NULL to deactivate randomization. void SetParametersForTestStat(const RooArgSet& ); specify the values of parameters used when evaluating test statistic. void SetNuisanceParameters(const RooArgSet& ); REMOVE THIS; specify the parameters of interest in the interval; virtual void SetParameters(const RooArgSet&) = 0;; specify the nuisance parameters (eg. the rest of the parameters). void SetObservables(const RooArgSet& ); specify the observables in the dataset (needed to evaluate the test statistic). void SetGlobalObservables(const RooArgSet& ); specify the conditional observables. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). void SetTestStatistic(RooStats::TestStatistic* testStatistic); Set the TestStatistic (want the argument to be a function of the data & parameter points. void SetSamplingDistName(const char* name); Set the name of the sampling distribution used for plotting. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id$ » Last generated: 2015-09-08 17:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT su",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__TestStatSampler.html:3156,test,test,3156,root/html534/RooStats__TestStatSampler.html,https://root.cern,https://root.cern/root/html534/RooStats__TestStatSampler.html,1,['test'],['test']
Testability,"ouble_t EvaluateTestStatistic(RooAbsData& data, RooArgSet& paramsOfInterest); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetTestStatistic() const; Get the TestStatistic. Double_t ConfidenceLevel() const; Get the Confidence level for the test. void Initialize(RooAbsArg& testStatistic, RooArgSet& paramsOfInterest, RooArgSet& nuisanceParameters); Common Initialization. void SetPdf(RooAbsPdf& ); Set the Pdf, add to the the workspace if not already there. void SetPriorNuisance(RooAbsPdf* ); How to randomize the prior. Set to NULL to deactivate randomization. void SetParametersForTestStat(const RooArgSet& ); specify the values of parameters used when evaluating test statistic. void SetNuisanceParameters(const RooArgSet& ); REMOVE THIS; specify the parameters of interest in the interval; virtual void SetParameters(const RooArgSet&) = 0;; specify the nuisance parameters (eg. the rest of the parameters). void SetObservables(const RooArgSet& ); specify the observables in the dataset (needed to evaluate the test statistic). void SetGlobalObservables(const RooArgSet& ); specify the conditional observables. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). void SetTestStatistic(RooStats::TestStatistic* testStatistic); Set the TestStatistic (want the argument to be a function of the data & parameter points. void SetSamplingDistName(const char* name); Set the name of the sampling distribution used for plotting. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id$ » Last generated: 2015-09-08 17:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT su",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooStats__TestStatSampler.html:3287,test,test,3287,root/html604/RooStats__TestStatSampler.html,https://root.cern,https://root.cern/root/html604/RooStats__TestStatSampler.html,1,['test'],['test']
Testability,"ouble_t EvaluateTestStatistic(RooAbsData& data, RooArgSet& paramsOfInterest); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetTestStatistic() const; Get the TestStatistic. Double_t ConfidenceLevel() const; Get the Confidence level for the test. void Initialize(RooAbsArg& testStatistic, RooArgSet& paramsOfInterest, RooArgSet& nuisanceParameters); Common Initialization. void SetPdf(RooAbsPdf& ); Set the Pdf, add to the the workspace if not already there. void SetPriorNuisance(RooAbsPdf* ); How to randomize the prior. Set to NULL to deactivate randomization. void SetParametersForTestStat(const RooArgSet& ); specify the values of parameters used when evaluating test statistic. void SetNuisanceParameters(const RooArgSet& ); REMOVE THIS; specify the parameters of interest in the interval; virtual void SetParameters(const RooArgSet&) = 0;; specify the nuisance parameters (eg. the rest of the parameters). void SetObservables(const RooArgSet& ); specify the observables in the dataset (needed to evaluate the test statistic). void SetGlobalObservables(const RooArgSet& ); specify the conditional observables. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). void SetTestStatistic(RooStats::TestStatistic* testStatistic); Set the TestStatistic (want the argument to be a function of the data & parameter points. void SetSamplingDistName(const char* name); Set the name of the sampling distribution used for plotting. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: TestStatSampler.h 34109 2010-06-24 15:00:16Z moneta $ » Last generated: 2010-09-23 20:01; This page has been automatically generated. For comments or suggestions regarding the document",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__TestStatSampler.html:3135,test,test,3135,root/html528/RooStats__TestStatSampler.html,https://root.cern,https://root.cern/root/html528/RooStats__TestStatSampler.html,1,['test'],['test']
Testability,"ouble_t EvaluateTestStatistic(RooAbsData& data, RooArgSet& paramsOfInterest); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetTestStatistic() const; Get the TestStatistic. Double_t ConfidenceLevel() const; Get the Confidence level for the test. void Initialize(RooAbsArg& testStatistic, RooArgSet& paramsOfInterest, RooArgSet& nuisanceParameters); Common Initialization. void SetPdf(RooAbsPdf& ); Set the Pdf, add to the the workspace if not already there. void SetPriorNuisance(RooAbsPdf* ); How to randomize the prior. Set to NULL to deactivate randomization. void SetParametersForTestStat(const RooArgSet& ); specify the values of parameters used when evaluating test statistic. void SetNuisanceParameters(const RooArgSet& ); REMOVE THIS; specify the parameters of interest in the interval; virtual void SetParameters(const RooArgSet&) = 0;; specify the nuisance parameters (eg. the rest of the parameters). void SetObservables(const RooArgSet& ); specify the observables in the dataset (needed to evaluate the test statistic). void SetGlobalObservables(const RooArgSet& ); specify the conditional observables. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). void SetTestStatistic(RooStats::TestStatistic* testStatistic); Set the TestStatistic (want the argument to be a function of the data & parameter points. void SetSamplingDistName(const char* name); Set the name of the sampling distribution used for plotting. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: TestStatSampler.h 39391 2011-05-26 09:51:59Z moneta $ » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the document",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__TestStatSampler.html:3137,test,test,3137,root/html530/RooStats__TestStatSampler.html,https://root.cern,https://root.cern/root/html530/RooStats__TestStatSampler.html,1,['test'],['test']
Testability,"ouble_t EvaluateTestStatistic(RooAbsData& data, RooArgSet& paramsOfInterest); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetTestStatistic() const; Get the TestStatistic. Double_t ConfidenceLevel() const; Get the Confidence level for the test. void Initialize(RooAbsArg& testStatistic, RooArgSet& paramsOfInterest, RooArgSet& nuisanceParameters); Common Initialization. void SetPdf(RooAbsPdf& ); Set the Pdf, add to the the workspace if not already there. void SetPriorNuisance(RooAbsPdf* ); How to randomize the prior. Set to NULL to deactivate randomization. void SetParametersForTestStat(const RooArgSet& ); specify the values of parameters used when evaluating test statistic. void SetNuisanceParameters(const RooArgSet& ); REMOVE THIS; specify the parameters of interest in the interval; virtual void SetParameters(const RooArgSet&) = 0;; specify the nuisance parameters (eg. the rest of the parameters). void SetObservables(const RooArgSet& ); specify the observables in the dataset (needed to evaluate the test statistic). void SetGlobalObservables(const RooArgSet& ); specify the conditional observables. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). void SetTestStatistic(RooStats::TestStatistic* testStatistic); Set the TestStatistic (want the argument to be a function of the data & parameter points. void SetSamplingDistName(const char* name); Set the name of the sampling distribution used for plotting. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: TestStatSampler.h 39391 2011-05-26 09:51:59Z moneta $ » Last generated: 2011-11-03 20:09; This page has been automatically generated. For comments or suggestions regarding the document",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__TestStatSampler.html:3137,test,test,3137,root/html532/RooStats__TestStatSampler.html,https://root.cern,https://root.cern/root/html532/RooStats__TestStatSampler.html,1,['test'],['test']
Testability,"ouble_t fAbsWNDC; ///< Absolute Width of pad along X in NDC; 72 Double_t fAbsHNDC; ///< Absolute Height of pad along Y in NDC; 73 ; 74 Double_t fUxmin; ///< Minimum value on the X axis; 75 Double_t fUymin; ///< Minimum value on the Y axis; 76 Double_t fUxmax; ///< Maximum value on the X axis; 77 Double_t fUymax; ///< Maximum value on the Y axis; 78 ; 79 Double_t fTheta; ///< theta angle to view as lego/surface; 80 Double_t fPhi; ///< phi angle to view as lego/surface; 81 ; 82 Double_t fAspectRatio; ///< ratio of w/h in case of fixed ratio; 83 ; 84 Int_t fPixmapID; ///<! Off-screen pixmap identifier; 85 Int_t fGLDevice; ///<! OpenGL off-screen pixmap identifier; 86 Bool_t fCopyGLDevice; ///<!; 87 Bool_t fEmbeddedGL; ///<!; 88 Int_t fNumber; ///< pad number identifier; 89 Int_t fTickx; ///< Set to 1 if tick marks along X; 90 Int_t fTicky; ///< Set to 1 if tick marks along Y; 91 Int_t fLogx; ///< (=0 if X linear scale, =1 if log scale); 92 Int_t fLogy; ///< (=0 if Y linear scale, =1 if log scale); 93 Int_t fLogz; ///< (=0 if Z linear scale, =1 if log scale); 94 Int_t fPadPaint; ///< Set to 1 while painting the pad; 95 Int_t fCrosshair; ///< Crosshair type (0 if no crosshair requested); 96 Int_t fCrosshairPos; ///< Position of crosshair; 97 Short_t fBorderSize; ///< pad bordersize in pixels; 98 Short_t fBorderMode; ///< Bordermode (-1=down, 0 = no border, 1=up); 99 Bool_t fModified; ///< Set to true when pad is modified; 100 Bool_t fGridx; ///< Set to true if grid along X; 101 Bool_t fGridy; ///< Set to true if grid along Y; 102 Bool_t fAbsCoord; ///< Use absolute coordinates; 103 Bool_t fEditable; ///< True if canvas is editable; 104 Bool_t fFixedAspectRatio; ///< True if fixed aspect ratio; 105 TPad *fMother{nullptr}; ///<! pointer to mother of the list; 106 TCanvas *fCanvas{nullptr}; ///<! Pointer to mother canvas; 107 TList *fPrimitives{nullptr};///<->List of primitives (subpads); 108 TList *fExecs{nullptr}; ///< List of commands to be executed when a pad event occu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8h_source.html:4158,log,log,4158,doc/master/TPad_8h_source.html,https://root.cern,https://root.cern/doc/master/TPad_8h_source.html,1,['log'],['log']
Testability,"ouble_t parmax); Set limits for parameter ipar. The specified limits will be used in a fit operation; when the option ""B"" is specified (Bounds).; To fix a parameter, use TF1::FixParameter. void SetRange(Double_t xmin, Double_t xmax); Initialize the upper and lower bounds to draw the function. The function range is also used in an histogram fit operation; when the option ""R"" is specified. void SetSavedPoint(Int_t point, Double_t value); Restore value of function saved at point. void SetTitle(const char* title = """"); Set function title; if title has the form ""fffffff;xxxx;yyyy"", it is assumed that; the function title is ""fffffff"" and ""xxxx"" and ""yyyy"" are the; titles for the X and Y axis respectively. void Streamer(TBuffer& b); Stream a class object. void Update(); Called by functions such as SetRange, SetNpx, SetParameters; to force the deletion of the associated histogram or Integral. void RejectPoint(Bool_t reject = kTRUE); Static function to set the global flag to reject points; the fgRejectPoint global flag is tested by all fit functions; if TRUE the point is not included in the fit.; This flag can be set by a user in a fitting function.; The fgRejectPoint flag is reset by the TH1 and TGraph fitting functions. Bool_t RejectedPoint(); See TF1::RejectPoint above. Double_t Moment(Double_t n, Double_t a, Double_t b, const Double_t* params = 0, Double_t epsilon = 0.000001); Return nth moment of function between a and b. See TF1::Integral() for parameter definitions. Double_t CentralMoment(Double_t n, Double_t a, Double_t b, const Double_t* params = 0, Double_t epsilon = 0.000001); Return nth central moment of function between a and b; (i.e the n-th moment around the mean value). See TF1::Integral() for parameter definitions; Author: Gene Van Buren <gene@bnl.gov>. void CalcGaussLegendreSamplingPoints(TGraph *g, Double_t eps); Type safe interface (static method); The number of sampling points are taken from the TGraph. Double_t operator()(Double_t x, Double_t y = 0, Dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TF1.html:62694,test,tested,62694,root/html528/TF1.html,https://root.cern,https://root.cern/root/html528/TF1.html,3,['test'],['tested']
Testability,"ouble_t x1, Double_t y1, Double_t x2, Double_t y2, Bool_t swapXY);  Paint a line for candle. ;  . Protected Attributes; Double_t fAxisMax;  The Maximum which is visible by the axis (used by zero indicator) ;  ; Double_t fAxisMin;  The Minimum which is visible by the axis (used by zero indicator) ;  ; Double_t fBoxDown;  Position of the lower box end. ;  ; Double_t fBoxUp;  Position of the upper box end. ;  ; Double_t fCandleWidth;  The candle width. ;  ; Double_t * fDatapoints {nullptr};  position of all Datapoints within this candle ;  ; bool fDismiss;  True if the candle cannot be painted. ;  ; Double_t fDrawPointsX [kNMAXPOINTS];  x-coord for every outlier, .. ;  ; Double_t fDrawPointsY [kNMAXPOINTS];  y-coord for every outlier, .. ;  ; Double_t fHistoPointsX [kNMAXPOINTS];  x-coord for the polyline of the histo ;  ; Double_t fHistoPointsY [kNMAXPOINTS];  y-coord for the polyline of the histo ;  ; Double_t fHistoWidth;  The histo width (the height of the max bin) ;  ; bool fIsCalculated;  ; bool fIsRaw;  0: for TH1 projection, 1: using raw data ;  ; int fLogX;  make the candle appear logx-like ;  ; int fLogY;  make the candle appear logy-like ;  ; int fLogZ;  make the candle appear logz-like ;  ; Double_t fMean;  Position of the mean. ;  ; Double_t fMedian;  Position of the median. ;  ; Double_t fMedianErr;  The size of the notch. ;  ; Long64_t fNDatapoints;  Number of Datapoints within this candle. ;  ; Long64_t fNDrawPoints;  max number of outliers or other point to be shown ;  ; int fNHistoPoints;  ; CandleOption fOption;  Setting the style of the candle. ;  ; TString fOptionStr;  String to draw the candle. ;  ; Double_t fPosCandleAxis;  x-pos for a vertical candle ;  ; TH1D * fProj {nullptr};  ; Double_t fWhiskerDown;  Position of the lower whisker end. ;  ; Double_t fWhiskerUp;  Position of the upper whisker end. ;  ;  Protected Attributes inherited from TAttLine; Color_t fLineColor;  Line color. ;  ; Style_t fLineStyle;  Line style. ;  ; Width_t fLineWidth; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCandle.html:10560,log,logx-like,10560,doc/master/classTCandle.html,https://root.cern,https://root.cern/doc/master/classTCandle.html,3,['log'],"['logx-like', 'logy-like', 'logz-like']"
Testability,"ouble_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constTF1virtual; GetMinMaxNDim(Double_t *x, Bool_t findmax, Double_t epsilon=0, Int_t maxiter=0) constTF1protectedvirtual; GetName() const overrideTNamedinlinevirtual; GetNDF() constTF1virtual; GetNdim() constTF1inlinevirtual; GetNpar() constTF1inlinevirtual; GetNpx() constTF1inlinevirtual; GetNumber() constTF1inlinevirtual; GetNumberFitPoints() constTF1inlinevirtual; GetNumberFreeParameters() constTF1virtual; GetObjectInfo(Int_t px, Int_t py) const overrideTF1virtual; GetObjectStat()TObjectstatic; GetOption() constTObjectinlinevirtual; GetParameter(Int_t ipar) constTF1inlinevirtual; GetParameter(const TString &name) constTF1inlinevirtual; GetParameters() constTF1inlinevirtual; GetParameters(Double_t *params)TF1inlinevirtual; GetParent() constTF1inline; GetParError(Int_t ipar) constTF1virtual; GetParErrors() constTF1inlinevirtual; GetParLimits(Int_t ipar, Double_t &parmin, Double_t &parmax) constTF1virtual; GetParName(Int_t ipar) constTF1inlinevirtual; GetParNumber(const char *name) constTF1inlinevirtual; GetProb() constTF1virtual; GetQuantiles(Int_t n, Double_t *xp, const Double_t *p)TF1virtual; GetRandom(TRandom *rng=nullptr, Option_t *opt=nullptr)TF1virtual; GetRandom(Double_t xmin, Double_t xmax, TRandom *rng=nullptr, Option_t *opt=nullptr)TF1virtual; GetRange(Double_t *xmin, Double_t *xmax) constTF1protectedvirtual; GetRange(Double_t &xmin, Double_t &xmax) constTF1virtual; GetRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) constTF1virtual; GetRange(Double_t &xmin, Double_t &ymin, Double_t &zmin, Double_t &xmax, Double_t &ymax, Double_t &zmax) constTF1virtual; GetSave(const Double_t *x)TF1virtual; GetTitle() const overrideTNamedinlinevirtual; GetUniqueID() constTObjectvirtual; GetVariable(const TString &name)TF1inlinevirtual; GetX(Double_t y, Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constTF1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1-members.html:6199,log,logx,6199,doc/master/classTF1-members.html,https://root.cern,https://root.cern/doc/master/classTF1-members.html,1,['log'],['logx']
Testability,"ouble_t zmin, zmax;; 10544 Int_t maximum = 0;; 10545 Int_t minimum = 0;; 10546 if (fH->GetMaximumStored() != -1111) maximum = 1;; 10547 if (fH->GetMinimumStored() != -1111) minimum = 1;; 10548 ; 10549 // ----------------- Compute X axis parameters; 10550 first = fXaxis->GetFirst();; 10551 last = fXaxis->GetLast();; 10552 Hparam.xlast = last;; 10553 Hparam.xfirst = first;; 10554 Hparam.xlowedge = fXaxis->GetBinLowEdge(first);; 10555 Hparam.xbinsize = fXaxis->GetBinWidth(first);; 10556 Hparam.xmin = Hparam.xlowedge;; 10557 Hparam.xmax = fXaxis->GetBinLowEdge(last)+fXaxis->GetBinWidth(last);; 10558 ; 10559 // if log scale in X, replace xmin,max by the log; 10560 if (Hoption.Logx) {; 10561 // find the first edge of a bin that is > 0; 10562 if (Hparam.xlowedge <=0 ) {; 10563 Hparam.xlowedge = fXaxis->GetBinUpEdge(fXaxis->FindFixBin(0.01*Hparam.xbinsize));; 10564 Hparam.xmin = Hparam.xlowedge;; 10565 }; 10566 if (Hparam.xmin <=0 || Hparam.xmax <=0) {; 10567 Error(where, ""cannot set X axis to log scale"");; 10568 return 0;; 10569 }; 10570 Hparam.xfirst= fXaxis->FindFixBin(Hparam.xmin);; 10571 if (Hparam.xfirst < first) Hparam.xfirst = first;; 10572 Hparam.xlast = fXaxis->FindFixBin(Hparam.xmax);; 10573 if (Hparam.xlast > last) Hparam.xlast = last;; 10574 Hparam.xmin = TMath::Log10(Hparam.xmin);; 10575 Hparam.xmax = TMath::Log10(Hparam.xmax);; 10576 }; 10577 ; 10578 // ----------------- Compute Y axis parameters; 10579 first = fYaxis->GetFirst();; 10580 last = fYaxis->GetLast();; 10581 Hparam.ylast = last;; 10582 Hparam.yfirst = first;; 10583 Hparam.ylowedge = fYaxis->GetBinLowEdge(first);; 10584 Hparam.ybinsize = fYaxis->GetBinWidth(first);; 10585 if (!Hparam.ybinsize) Hparam.ybinsize = 1;; 10586 Hparam.ymin = Hparam.ylowedge;; 10587 Hparam.ymax = fYaxis->GetBinLowEdge(last)+fYaxis->GetBinWidth(last);; 10588 ; 10589 // if log scale in Y, replace ymin,max by the log; 10590 if (Hoption.Logy) {; 10591 if (Hparam.ylowedge <=0 ) {; 10592 Hparam.ylowedge = fYaxis->GetBinUpEdge(fYa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:379650,log,log,379650,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['log'],['log']
Testability,"ouble_t> > vec, const Double_t quantile, const Double_t SumOfWeights = 0.); calculates the quantile of the distribution of the first pair entries weighted with the values in the second pair entries. Double_t GradBoost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt, UInt_t cls = 0); Calculate the desired response value for each region. Double_t GradBoostRegression(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); Implementation of M_TreeBoost using a Huber loss function as desribed by Friedman 1999. void InitGradBoost(vector<const TMVA::Event*>& ); initialize targets for first tree. Double_t TestTreeQuality(TMVA::DecisionTree* dt); test the tree quality.. in terms of Miscalssification. Double_t Boost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt, UInt_t cls = 0); apply the boosting alogrithim (the algorithm is selecte via the the ""option"" given; in the constructor. The return value is the boosting weight. void BoostMonitor(Int_t iTree); fills the ROCIntegral vs Itree from the testSample for the monitoring plots; during the training .. but using the testing events. Double_t AdaBoost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); the AdaBoost implementation.; a new training sample is generated by weighting; events that are misclassified by the decision tree. The weight; applied is w = (1-err)/err or more general:; w = ((1-err)/err)^beta; where err is the fraction of misclassified events in the tree ( <0.5 assuming; demanding the that previous selection was better than random guessing); and ""beta"" being a free parameter (standard: beta = 1) that modifies the; boosting. Double_t AdaCost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); the AdaCost boosting algorithm takes a simple cost Matrix (currently fixed for; all events... later could be modified to use individual cost matrices for each; events as in the original paper... true_signal true_bkg. sel_signal | Css Ctb_ss Cxx.. in the range [0,1]; sel_bkg | Cts_sb Cbb. and takes this into ac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodBDT.html:32854,test,testSample,32854,root/html602/TMVA__MethodBDT.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodBDT.html,2,['test'],['testSample']
Testability,"ouble_t� fA0Calc;������������������� //calculated value of background a0; parameter; ��; Double_t� fA0Err;�������������������� //error value of background a0 parameter; ��; Double_t� fA1Init;������������������� //initial value of background a1; parameter(backgroud is estimated as a0+a1*x+a2*x*x); ��; Double_t� fA1Calc;������������������� //calculated value of background a1; parameter; ��; Double_t� fA1Err;�������������������� //error value of background a1 parameter; ��; Double_t� fA2Init;������������������� //initial value of background a2; parameter(backgroud is estimated as a0+a1*x+a2*x*x); ��; Double_t� fA2Calc;������������������� //calculated value of background a2; parameter; ��; Double_t� fA2Err; ��������������������//error value of background a2 parameter; ��; Bool_t�� *fFixPosition;�������������� //[fNPeaks] array of logical values which; allow to fix appropriate positions (not fit). However they are present in the; estimated functional�� ; ��; Bool_t ��*fFixAmp;������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes (not fit). However they are present in the; estimated functional����� ; ��; Bool_t��� fFixSigma;����������������� //logical value of sigma parameter, which; allows to fix the parameter (not to fit).�� ; ��; Bool_t��� fFixT;��������������������� //logical value of t parameter, which; allows to fix the parameter (not to fit).����� ; ��; Bool_t��� fFixB;��������������������� //logical value of b parameter, which; allows to fix the parameter (not to fit).�� ; ��; Bool_t��� fFixS;��������������������� //logical value of s parameter, which; allows to fix the parameter (not to fit).����� ; ��; Bool_t��� fFixA0;�������������������� //logical value of a0 parameter, which; allows to fix the parameter (not to fit).; ��; Bool_t��� fFixA1;�������������������� //logical value of a1 parameter, which; allows to fix the parameter (not to fit).�� ; ��; Bool_t��� fFixA2;�������������������� //logical value of a2 paramete",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrumFit.html:25319,log,logical,25319,root/html528/TSpectrumFit.html,https://root.cern,https://root.cern/root/html528/TSpectrumFit.html,6,['log'],['logical']
Testability,"ould be silently written if data-member of object has same name as another branch; [ROOT-10703] - TCling fails to catch compiled exception on Mac OS; [ROOT-10752] - segmentation violation in TFractionFitter destructor; [ROOT-10753] - [TTreeReader] Wrong entries are loaded in case of TChain+TEntryList; [ROOT-10762] - [MT] Concurrent construction (or destruction?) of two different TThreadedExecutors is racy; [ROOT-10776] - Fail compilation; [ROOT-10779] - HistFactory models that are written to a file, then retrieved with updated histograms find only old histograms; [ROOT-10782] - With gcc10 STL headers don’t include implicitly stdexcept; [ROOT-10784] - Mistake in what is reported in documentation; [ROOT-10790] - [DF] Single-thread Snapshot into a directory also creates a spurious TTree outside of it; [ROOT-10792] - [DF] Snapshot of TClonesArrays read via TTreeReaderArray is broken; [ROOT-10800] - TClass::GetListOfAllPublicMethods() lists deleted copy constructor of std::unique_ptr; [ROOT-10804] - assertion in clang::Sema::LookupSpecialMember; [ROOT-10810] - Segmentation fault in pickling of weighted RooFit datasets; [ROOT-10815] - Error in parsing TFormula expression using pre-defined functions in function names; [ROOT-10822] - [DF] RVecs of non-split branches can read from invalid addresses; [ROOT-10824] - [TTreeReader] Reading entries from a friend with a TTreeIndex results in wrong entries silently read, or an infinite event loop; [ROOT-10835] - zero/zero computed in test case stressRooStats; [ROOT-10837] - hadd crashes when slow merging file with multiple array with same index; [ROOT-10839] - Missing lock guard in THashTable; [ROOT-10845] - RooArgSet IsOnHeap result incorrect; [ROOT-10846] - TPython documentation is gone; [ROOT-10849] - Recursive ASTReader assertion Fedora32 C++17; [ROOT-10880] - df007*py broken; [ROOT-10882] - Drawing crashes when histogram title contain special characters; [ROOT-10884] - Error importing JupyROOT with conda ROOT; [ROOT-10886] - 6.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:34768,assert,assertion,34768,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,3,"['assert', 'test']","['assertion', 'test']"
Testability,"ould not be stored and will be invalided after performing a new fitting.; In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; obtained calling again GetMinimizer(). { return fMinimizer.get(); }. ROOT::Math::IMultiGenFunction * GetFCN() const. return pointer to last used objective function; (is NULL in case fit is not yet done); This pointer will be valid as far as the data and the fitter class; have not been deleted. To be used after the fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of the function pointer will be re-created and can be; obtained calling again GetFCN(). { return fObjFunction.get(); }. bool ApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2, bool minimizeW2L = false). apply correction in the error matrix for the weights for likelihood fits; This method can be called only after a fit. The; passed function (loglw2) is a log-likelihood function impelemented using the; sum of weight squared; When using FitConfig.SetWeightCorrection() this correction is applied; automatically when doing a likelihood fit (binned or unbinned). bool DoLinearFit(const ROOT::Fit::BinData& data); linear least square fit. bool DoInitMinimizer(); initialize the minimizer. bool DoMinimization(const ROOT::Fit::Fitter::BaseFunc& f, const ROOT::Math::IMultiGenFunction* chifunc = 0); do minimization. bool DoMinimization(const ROOT::Math::IMultiGenFunction* chifunc = 0); do minimization after having set obj function. void DoUpdateFitConfig(); update config after fit. int GetNCallsFromFCN(); get function calls from the FCN. void DoSetFunction(const IModel1DFunction & func, bool useGrad); set 1D function. void DoSetFunction(const IModelFunction & func, bool useGrad); set generic N-d function. » Author: L. Moneta Wed Aug 30 11:05:19 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-06-30 14:21; Th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Fit__Fitter.html:12027,log,log-likelihood,12027,root/html602/ROOT__Fit__Fitter.html,https://root.cern,https://root.cern/root/html602/ROOT__Fit__Fitter.html,1,['log'],['log-likelihood']
Testability,"ould not be stored and will be invalided after performing a new fitting.; In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; obtained calling again GetMinimizer(). { return fMinimizer.get(); }. ROOT::Math::IMultiGenFunction * GetFCN() const. return pointer to last used objective function; (is NULL in case fit is not yet done); This pointer will be valid as far as the data and the fitter class; have not been deleted. To be used after the fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of the function pointer will be re-created and can be; obtained calling again GetFCN(). { return fObjFunction.get(); }. bool ApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2, bool minimizeW2L = false). apply correction in the error matrix for the weights for likelihood fits; This method can be called only after a fit. The; passed function (loglw2) is a log-likelihood function impelemented using the; sum of weight squared; When using FitConfig.SetWeightCorrection() this correction is applied; automatically when doing a likelihood fit (binned or unbinned). bool DoLinearFit(const ROOT::Fit::BinData& data); linear least square fit. bool DoInitMinimizer(); initialize the minimizer. bool DoMinimization(const ROOT::Fit::Fitter::BaseFunc& f, const ROOT::Math::IMultiGenFunction* chifunc = 0); do minimization. bool DoMinimization(const ROOT::Math::IMultiGenFunction* chifunc = 0); do minimization after having set obj function. void DoUpdateFitConfig(); update config after fit. int GetNCallsFromFCN(); get function calls from the FCN. void DoSetFunction(const IModel1DFunction & func, bool useGrad); set 1D function. void DoSetFunction(const IModelFunction & func, bool useGrad); set generic N-d function. » Author: L. Moneta Wed Aug 30 11:05:19 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 16:58; Th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Fit__Fitter.html:13830,log,log-likelihood,13830,root/html534/ROOT__Fit__Fitter.html,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html,1,['log'],['log-likelihood']
Testability,"ould not be stored and will be invalided after performing a new fitting.; In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; obtained calling again GetMinimizer(). { return fMinimizer.get(); }. ROOT::Math::IMultiGenFunction * GetFCN() const. return pointer to last used objective function; (is NULL in case fit is not yet done); This pointer will be valid as far as the data and the fitter class; have not been deleted. To be used after the fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of the function pointer will be re-created and can be; obtained calling again GetFCN(). { return fObjFunction.get(); }. bool ApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2, bool minimizeW2L = false). apply correction in the error matrix for the weights for likelihood fits; This method can be called only after a fit. The; passed function (loglw2) is a log-likelihood function impelemented using the; sum of weight squared; When using FitConfig.SetWeightCorrection() this correction is applied; automatically when doing a likelihood fit (binned or unbinned). bool DoLinearFit(const ROOT::Fit::BinData& data); linear least square fit. bool DoInitMinimizer(); initialize the minimizer. bool DoMinimization(const ROOT::Fit::Fitter::BaseFunc& f, const ROOT::Math::IMultiGenFunction* chifunc = 0); do minimization. bool DoMinimization(const ROOT::Math::IMultiGenFunction* chifunc = 0); do minimization after having set obj function. void DoUpdateFitConfig(); update config after fit. int GetNCallsFromFCN(); get function calls from the FCN. void DoSetFunction(const IModel1DFunction & func, bool useGrad); set 1D function. void DoSetFunction(const IModelFunction & func, bool useGrad); set generic N-d function. » Author: L. Moneta Wed Aug 30 11:05:19 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: Fitter.h 42202 2011-11-23 17:07:20Z mo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Fit__Fitter.html:13829,log,log-likelihood,13829,root/html532/ROOT__Fit__Fitter.html,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html,1,['log'],['log-likelihood']
Testability,"ounter of created windows in SavePrimitive ;  ;  Static Protected Attributes inherited from TQObject; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . #include <TProofProgressLog.h>. Inheritance diagram for TProofProgressLog:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ ETextType. enum TProofProgressLog::ETextType. private . EnumeratorkRaw ; kStd ; kGrep . Definition at line 34 of file TProofProgressLog.h. Constructor & Destructor Documentation. ◆ TProofProgressLog() [1/2]. TProofProgressLog::TProofProgressLog ; (; TProofProgressDialog * ; d, . Int_t ; w = 700, . Int_t ; h = 600 . ). Create a window frame for log messages. ; Definition at line 44 of file TProofProgressLog.cxx. ◆ TProofProgressLog() [2/2]. TProofProgressLog::TProofProgressLog ; (; const char * ; url = nullptr, . Int_t ; sessionidx = 0, . Int_t ; w = 700, . Int_t ; h = 600 . ). Create a window frame for log messages. ; Definition at line 57 of file TProofProgressLog.cxx. ◆ ~TProofProgressLog(). TProofProgressLog::~TProofProgressLog ; (; ). override . Destructor. ; Definition at line 247 of file TProofProgressLog.cxx. Member Function Documentation. ◆ AddBuffer(). void TProofProgressLog::AddBuffer ; (; const char * ; buffer). Add text to the window. ; Definition at line 298 of file TProofProgressLog.cxx. ◆ BuildLogList(). void TProofProgressLog::BuildLogList ; (; Bool_t ; create = kFALSE). Build the list of workers. ; For this, extract the logs and take the names of TProofLogElements ; Definition at line 319 of file TProofProgressLog.cxx. ◆ Class(). static TClass * TProofProgressLog::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TProofProgressLog::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TProofProgressLog::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofProgressLog.html:38742,log,log,38742,doc/master/classTProofProgressLog.html,https://root.cern,https://root.cern/doc/master/classTProofProgressLog.html,1,['log'],['log']
Testability,"ounter;  . Protected Member Functions; MsgLogger & Log () const;  message logger ;  . Protected Attributes; Double_t fBestFitness;  ; Double_t fConvValue;  ; Bool_t fFirstTime;  ; IFitterTarget & fFitterTarget;  ; Double_t fLastResult;  ; MsgLogger * fLogger;  ; Bool_t fMakeCopies;  ; Bool_t fMirror;  ; GeneticPopulation fPopulation;  ; Int_t fPopulationSize;  ; const std::vector< TMVA::Interval * > & fRanges;  ; Double_t fSpread;  ; std::deque< Int_t > fSuccessList;  . #include <TMVA/GeneticAlgorithm.h>; Constructor & Destructor Documentation. ◆ GeneticAlgorithm(). TMVA::GeneticAlgorithm::GeneticAlgorithm ; (; IFitterTarget & ; target, . Int_t ; populationSize, . const std::vector< TMVA::Interval * > & ; ranges, . UInt_t ; seed = 0 . ). Constructor. ; Parameters:. int populationSize : defines the number of ""Individuals"" which are created and tested within one Generation (Iteration of the Evolution); std::vector<TMVA::Interval*> ranges : Interval holds the information of an interval, where the GetMin gets the low and GetMax gets the high constraint of the variable the size of ""ranges"" is the number of coefficients which are optimised Purpose:; Creates a random population with individuals of the size ranges.size() . Definition at line 69 of file GeneticAlgorithm.cxx. ◆ ~GeneticAlgorithm(). TMVA::GeneticAlgorithm::~GeneticAlgorithm ; (; ). virtual . Definition at line 88 of file GeneticAlgorithm.cxx. Member Function Documentation. ◆ CalculateFitness(). Double_t TMVA::GeneticAlgorithm::CalculateFitness ; (; ). virtual . starts the evaluation of the fitness of all different individuals of the population. ; this function calls implicitly (many times) the ""fitnessFunction"" which has been overridden by the user. ; Definition at line 135 of file GeneticAlgorithm.cxx. ◆ Class(). static TClass * TMVA::GeneticAlgorithm::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMVA::GeneticAlgorithm::Class_Name ; (; ). static . ReturnsName",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1GeneticAlgorithm.html:2923,test,tested,2923,doc/master/classTMVA_1_1GeneticAlgorithm.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1GeneticAlgorithm.html,1,['test'],['tested']
Testability,"ounterCounter for all opened files; static Bool_tTFile::fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static Int_tTFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size. private:. XrdClient*fClientHandle to the client object; XrdSysRecMutex*fInitMtxProtects fInitDone, serializes the; Bool_tfIsRootdNature of remote file server; static TFileStager*fgFileStagerStager for IsStaged checks; static Bool_tfgInitDoneAvoid initializing more than once; static Bool_tfgRootdBCControl rootd backward compatibility. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TXNetFile(const char* url, Option_t* option = """", const char* fTitle = """", Int_t compress = 1, Int_t netopt = 0, Bool_t parallelopen = kFALSE, const char* logicalurl = 0); Create a TXNetFile object. A TXNetFile object is the same as a TNetFile; (from which the former derives) except that the protocol is extended to; support dealing with new xrootd data server or xrootd load balancer; server. The ""url"" argument must be of the form. root://server1:port1[,server2:port2,...,serverN:portN]/pathfile,. Note that this means that multiple servers (>= 1) can be specified in; the url. The connection will try to connect to the first server:port; and if that does not succeed, it will try the second one, and so on; until it finds a server that will respond. See the TNetFile documentation for the description of the other arguments. The creation consists of internal variable settings (most important is; the client's domain), creation of a TXUrl array containing all specified; urls (a single url is serverX:portX/pathfile), trying to connect to the; servers calling Connect() method, getti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXNetFile.html:24008,log,logicalurl,24008,root/html528/TXNetFile.html,https://root.cern,https://root.cern/root/html528/TXNetFile.html,3,['log'],['logicalurl']
Testability,"oup view; Int_tfSeqNumRemote sequential # of the last query submitted; Int_tfSessionIDremote ID of the session; TList*fSlaveInfo!list returned by kPROOF_GETSLAVEINFO; Int_tfStatusremote return status (part of kPROOF_LOGDONE); Bool_tfSynctrue if type of currently processed query is sync; TMonitor*fUniqueMonitormonitor activity on all unique slave sockets; TList*fUniqueSlaveslist of all active slaves with unique file systems; Bool_tfValidis this a valid proof object; TList*fWaitingSlavesstores a TPair of the slaves's TSocket and TMessage; TStringfWorkDircurrent work directory on remote servers; Int_tfWorkersToMergeCurrent total number of workers, which have not been yet assigned to any merger; static TPluginHandler*fgLogViewerLog dialog box plugin; static TList*fgProofEnvListList of TNameds defining environment. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProof(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); Create a PROOF environment. Starting PROOF involves either connecting; to a master server, which in turn will start a set of slave servers, or; directly starting as master server (if master = """"). Masterurl is of; the form: [proof[s]://]host[:port]. Conffile is the name of the config; file describing the remote PROOF cluster (this argument alows you to; describe different cluster configurations).; The default is proof.conf. Confdir is the directory where the config; file and other PROOF related files are (like motd and noproof files).; Loglevel is the log level (default = 1). User specified custom config; files will be first looked for in $HOME/.conffile. TProof(); Protected constructor to be used by classes deriving from TProof; (they have to call Init themselves and override StartSlaves; appropriately). This constructor simply closes any previous gProof and sets gProof; to this instance. void InitMem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:31737,log,loglevel,31737,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,3,['log'],['loglevel']
Testability,"ous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; UInt_tfShapeBitsshape bits; Int_tfShapeIdshape id; TStringTNamed::fTitleobject title. private:. static Double_tfgEpsMchMachine round-off error; static TGeoMatrix*fgTransformcurrent transformation matrix that applies to shape. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoShape(); Default constructor. TGeoShape(const char* name); Default constructor. ~TGeoShape(); Destructor. void CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2). Double_t ComputeEpsMch(); Compute machine round-off double precision error as the smallest number that; if added to 1.0 is different than 1.0. Double_t EpsMch(); static function returning the machine round-off error. const char * GetName() const; Get the shape name. Int_t ShapeDistancetoPrimitive(Int_t numpoints, Int_t px, Int_t py) const; Returns distance to shape primitive mesh. Bool_t IsCloseToPhi(Double_t epsil, const Double_t* point, Double_t c1, Double_t s1, Double_t c2, Double_t s2); True if point is closer than epsil to one of the phi planes defined by c1,s1 or c2,s2. Bool_t IsInPhiRange(const Double_t* point, Double_t phi1, Double_t phi2); Static method to check if a ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoShape.html:18385,test,testNo,18385,root/html602/TGeoShape.html,https://root.cern,https://root.cern/root/html602/TGeoShape.html,2,['test'],['testNo']
Testability,"ous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_t_debug; TFile*_refFile; list<pair<RooPlot*,string> >_regPlots; list<pair<RooFitResult*,string> >_regResults; list<pair<TH1*,string> >_regTH; list<pair<RooTable*,string> >_regTables; list<pair<Double_t,string> >_regValues; list<pair<RooWorkspace*,string> >_regWS; Int_t_verb; Bool_t_write; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; static TDirectory*gMemDir. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooUnitTest(const char* name, TFile* refFile, Bool_t writeRef, Int_t verbose). ~RooUnitTest(). void regPlot(RooPlot* frame, const char* refName). void regResult(RooFitResult* r, const char* refName). void regValue(Double_t value, const char* refName). void regTable(RooTable* t, const char* refName). void regWS(RooWorkspace* ws, const char* refName). void regTH(TH1* h, const char* refName). RooWorkspace* getWS(const char* refName). Bool_t areTHidentical(TH1* htest, TH1* href). Bool_t runCompTests(). void setSilentMode(). void clearSilentMode(). Bool_t runTest(). void setMemDir(TDirectory* memDir); Set gMemDir to memDir. RooUnitTest(const char* name, TFile* refFile, Bool_t writeRef, Int_t verbose). void setDebug(Bool_t flag); { _debug = flag ; }. Bool_t isTestAvailable(); { return kTRUE ; }. Bool_t testCode(). Double_t htol(); { return 5e-4 ; }. Double_t ctol(); { return 2e-3 ; }. Double_t fptol(); { return 1e-3 ; }. Double_t fctol(); { return 1e-3 ; }. Double_t vtol(); { return 1e-3 ; }. » Last changed: Tue Jun 30 14:37:59 2015 » Last generated: 2015-06-30 14:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooUnitTest.html:8552,test,testCode,8552,root/html602/RooUnitTest.html,https://root.cern,https://root.cern/root/html602/RooUnitTest.html,1,['test'],['testCode']
Testability,"out . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » First Steps With ROOT Simulation in ROOT. The ROOT framework consists of many classes, grouped into several categories. Finally, the latter are grouped into few top-level categories. Each top-level category comes with a basic description of the framework design and of the purpose of its categories, which also have more detailed documentation about their use. The most complete documentation is the Reference Guide, that contains the automatically generated documentation of each class.; This document is about the top-level categories related to simulation. . ‹ Graphics 3D; up; Virtual Monte-Carlo ›. Navigate through this book; Processing data with ROOT; Showing results with ROOT; Simulation in ROOTVirtual Monte-Carlo; Geometry; Tracks. ROOT I/O. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/simulation-root.html:3145,test,tests,3145,d/simulation-root.html,https://root.cern,https://root.cern/d/simulation-root.html,1,['test'],['tests']
Testability,"outnode, for all test data events. This method is mainly useful; when doing regression analysis with the MLP (i.e. not classification,; but continuous truth values).; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfile::Draw. THStack* DrawTruthDeviations(Option_t* option = """"); Creates TProfiles of the difference of the MLP output minus the; true value vs the true value, one for each output, filled with the; test data events. This method is mainly useful when doing regression; analysis with the MLP (i.e. not classification, but continuous truth; values).; The returned THStack contains all the TProfiles. It is drawn unless; the option ""goff"" is specified.; Options are passed to TProfile::Draw. TProfile* DrawTruthDeviationInOut(Int_t innode, Int_t outnode = 0, Option_t* option = """"); Creates a profile of the difference of the MLP output outnode minus; the true value of outnode vs the input value innode, for all test; data events.; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfile::Draw. THStack* DrawTruthDeviationInsOut(Int_t outnode = 0, Option_t* option = """"); Creates a profile of the difference of the MLP output outnode minus the; true value of outnode vs the input value, stacked for all inputs, for; all test data events.; The returned THStack contains all the TProfiles. It is drawn unless; the option ""goff"" is specified.; Options are passed to TProfile::Draw. TMLPAnalyzer(TMultiLayerPerceptron& net); {}. TMLPAnalyzer(TMultiLayerPerceptron* net); {}. TTree* GetIOTree() const; { return fIOTree;}. » Author: Christophe.Delaere@cern.ch 25/04/04 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/mlp:$Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMLPAnalyzer.html:9727,test,test,9727,root/html534/TMLPAnalyzer.html,https://root.cern,https://root.cern/root/html534/TMLPAnalyzer.html,1,['test'],['test']
Testability,"outnode, for all test data events. This method is mainly useful; when doing regression analysis with the MLP (i.e. not classification,; but continuous truth values).; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfile::Draw. THStack* DrawTruthDeviations(Option_t* option = """"); Creates TProfiles of the difference of the MLP output minus the; true value vs the true value, one for each output, filled with the; test data events. This method is mainly useful when doing regression; analysis with the MLP (i.e. not classification, but continuous truth; values).; The returned THStack contains all the TProfiles. It is drawn unless; the option ""goff"" is specified.; Options are passed to TProfile::Draw. TProfile* DrawTruthDeviationInOut(Int_t innode, Int_t outnode = 0, Option_t* option = """"); Creates a profile of the difference of the MLP output outnode minus; the true value of outnode vs the input value innode, for all test; data events.; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfile::Draw. THStack* DrawTruthDeviationInsOut(Int_t outnode = 0, Option_t* option = """"); Creates a profile of the difference of the MLP output outnode minus the; true value of outnode vs the input value, stacked for all inputs, for; all test data events.; The returned THStack contains all the TProfiles. It is drawn unless; the option ""goff"" is specified.; Options are passed to TProfile::Draw. TMLPAnalyzer(TMultiLayerPerceptron& net); {}. TMLPAnalyzer(TMultiLayerPerceptron* net); {}. TTree* GetIOTree() const; { return fIOTree;}. » Author: Christophe.Delaere@cern.ch 25/04/04 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/mlp:$Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMLPAnalyzer.html:10188,test,test,10188,root/html604/TMLPAnalyzer.html,https://root.cern,https://root.cern/root/html604/TMLPAnalyzer.html,1,['test'],['test']
Testability,"outnode, for all test data events. This method is mainly useful; when doing regression analysis with the MLP (i.e. not classification,; but continuous truth values).; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfile::Draw. THStack* DrawTruthDeviations(Option_t* option = """"); Creates TProfiles of the difference of the MLP output minus the; true value vs the true value, one for each output, filled with the; test data events. This method is mainly useful when doing regression; analysis with the MLP (i.e. not classification, but continuous truth; values).; The returned THStack contains all the TProfiles. It is drawn unless; the option ""goff"" is specified.; Options are passed to TProfile::Draw. TProfile* DrawTruthDeviationInOut(Int_t innode, Int_t outnode = 0, Option_t* option = """"); Creates a profile of the difference of the MLP output outnode minus; the true value of outnode vs the input value innode, for all test; data events.; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfile::Draw. THStack* DrawTruthDeviationInsOut(Int_t outnode = 0, Option_t* option = """"); Creates a profile of the difference of the MLP output outnode minus the; true value of outnode vs the input value, stacked for all inputs, for; all test data events.; The returned THStack contains all the TProfiles. It is drawn unless; the option ""goff"" is specified.; Options are passed to TProfile::Draw. TMLPAnalyzer(TMultiLayerPerceptron& net); {}. TMLPAnalyzer(TMultiLayerPerceptron* net); {}. TTree* GetIOTree() const; { return fIOTree;}. » Author: Christophe.Delaere@cern.ch 25/04/04 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/mlp:$Id$ » Last generated: 2015-06-30 15:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMLPAnalyzer.html:10188,test,test,10188,root/html602/TMLPAnalyzer.html,https://root.cern,https://root.cern/root/html602/TMLPAnalyzer.html,1,['test'],['test']
Testability,"output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are two cuts (see TTreeFormula) defining events; to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor,; or later with the suited setter method. ~TMultiLayerPerceptron(); Destructor. void SetData(TTree* ); Set the data source. void SetEventWeight(const char* ); Set the event weight. void SetTrainingDataSet(TEventList* train); Sets the Training dataset.; Those events will be used for the minimization. void SetTestDataSet(TEventList* test); Sets the Test dataset.; Those events will not be used for the minimization but for control. void SetTrainingDataSet(const char* train); Sets the Training dataset.; Those events will be used for the minimization.; Note that the tree must be already defined. void SetTestDataSet(const char* test); Sets the Test dataset.; Those events will not be used for the minimization but for control.; Note that the tree must be already defined. void SetLearningMethod(TMultiLayerPerceptron::ELearningMethod method); Sets the learning method.; Available methods are: kStochastic, kBatch,; kSteepestDescent, kRibierePolak, kFletcherReeves and kBFGS.; (look at the constructor for the complete description; of learning methods and parameters). void SetEta(Double_t eta); Sets Eta - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetEpsilon(Double_t eps); Sets Epsilon - used in stochastic minimisation; (look at the constru",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiLayerPerceptron.html:22907,test,test,22907,root/html528/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html,6,['test'],['test']
Testability,"output stream ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; std::vector< Float_t > classValues;  ; TString fAlgorithm;  ; TString fBaseEstimator;  ; TString fFilenameClassifier;  ; Double_t fLearningRate;  ; Int_t fNestimators;  ; UInt_t fNoutputs;  ; UInt_t fNvars;  ; TString fRandomState;  ; std::vector< Double_t > mvaValues;  ; PyObject * pAlgorithm;  ; PyObject * pBaseEstimator;  ; PyObject * pLearningRate;  ; PyObject * pNestimators;  ; PyObject * pRandomState;  ;  Protected Attributes inherited from TMVA::PyMethodBase; PyObject * fClassifier;  ; PyObject * fLocalNS;  ; PyObject * fModule;  ; PyObject * fPyReturn;  ;  Protected Attributes inherited from TMVA::MethodBase; Types::EAnalysisType fAnalysisType;  ; UInt_t fBackgroundClass;  ; bool fExitFromTraining = false;  ; std::vector< TString > * fInputVars;  ; IPythonInteractive * fInteractive = nullptr;  temporary dataset used when evaluating on a different data (used by MethodCategory::GetMvaValues) ;  ; UInt_t fIPyCurrentIter = 0;  ; UInt_t fIPyMaxIter = 0;  ; std::vector< Float_t > * fMulticlassReturnVal;  ; Int_t fNbins;  ; Int_t fNbinsH;  ; Int_t fNbinsMVAoutput;  ; Ranking * fRanking;  ; std::vector< Float_t > * fRegressionReturnVal;  ; Results * fResults;  ; UInt_t fSignalClass;  ; DataSet * fTmpData = nullptr;  temporary event when testing on a different DataSet than the own one ;  ; const Event * fTmpEvent;  ;  Protected Attributes inherited from TMVA::Configurable; MsgLogger * fLogger;  ! message logger ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Attributes; DataSetManager * fDataSetManager;  . Friends; class Factory;  ; class Reader;  . Additional Inherited Members;  Public Types inherited from TMVA::MethodBase; enum  EWeightFileType { kROOT =0; , kTEXT; };  ;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodPyAdaBoost.html:28522,test,testing,28522,doc/master/classTMVA_1_1MethodPyAdaBoost.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodPyAdaBoost.html,2,"['log', 'test']","['logger', 'testing']"
Testability,"ov distance instead of prob; ""X"" Run the pseudo experiments post-processor with the following procedure:; make pseudoexperiments based on random values from the parent; distribution and compare the KS distance of the pseudoexperiment; to the parent distribution. Bin the KS distances in a histogram,; and then take the integral of all the KS values above the value; obtained from the original data to Monte Carlo distribution.; The number of pseudo-experiments nEXPT is currently fixed at 1000.; The function returns the integral.; (thanks to Ben Kilminster to submit this procedure). Note that; this option ""X"" is much slower. The returned function value is the probability of test; (much less than one means NOT compatible). Code adapted by Rene Brun from original HBOOK routine HDIFF. NOTE1; A good description of the Kolmogorov test can be seen at:; http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm. NOTE2; see also alternative function TH1::Chi2Test; The Kolmogorov test is assumed to give better results than Chi2Test; in case of histograms with low statistics. NOTE3 (Jan Conrad, Fred James); ""The returned value PROB is calculated such that it will be; uniformly distributed between zero and one for compatible histograms,; provided the data are not binned (or the number of bins is very large; compared with the number of events). Users who have access to unbinned; data and wish exact confidence levels should therefore not put their data; into histograms, but should call directly TMath::KolmogorovTest. On; the other hand, since TH1 is a convenient way of collecting data and; saving space, this function has been provided. However, the values of; PROB for binned data will be shifted slightly higher than expected,; depending on the effects of the binning. For example, when comparing two; uniform distributions of 500 events in 100 bins, the values of PROB,; instead of being exactly uniformly distributed between zero and one, have; a mean value of about 0.56. We can ap",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:108672,test,test,108672,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,6,['test'],['test']
Testability,"oveViewer(TGLViewerBase* viewer); virtual voidTGLSceneBase::Render(TGLRnrCtx& rnrCtx); virtual voidRenderAllPasses(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout); virtual voidRenderElements(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout, const TGLPlaneSet_t* clipPlanes = 0); virtual voidRenderHighlight(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec); virtual voidRenderOpaque(TGLRnrCtx& rnrCtx); virtual voidRenderSelOpaque(TGLRnrCtx& rnrCtx); virtual voidRenderSelOpaqueForHighlight(TGLRnrCtx& rnrCtx); virtual voidRenderSelTransp(TGLRnrCtx& rnrCtx); virtual voidRenderSelTranspForHighlight(TGLRnrCtx& rnrCtx); virtual voidRenderTransp(TGLRnrCtx& rnrCtx); virtual Bool_tResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); static voidRGBAFromColorIdx(Float_t* rgba, Color_t ci, Char_t transp = 0); voidTGLSceneBase::SetAutoDestruct(Bool_t a); voidTGLSceneBase::SetClip(TGLClip* p); voidTGLSceneBase::SetLOD(Short_t lod); virtual voidTGLSceneBase::SetName(const char* name); virtual voidTGLSceneBase::SetNameTitle(const char* name, const char* title); voidTGLSceneBase::SetSelectable(Bool_t a); voidTGLSceneBase::SetStyle(Short_t st); virtual voidTGLSceneBase::SetTitle(const char* title); virtual voidShowMembers(TMemberInspector&); UInt_tSizeOfScene() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); Short_tTGLSceneBase::Style() const; voidTGLSceneBase::TagViewersChanged(); Bool_tTGLLockable::TakeLock(TGLLockable::ELock lock) const; virtual voidUpdateLogical(TObject* logid); virtual voidUpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); virtual voidUpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); virtual voidUpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); virtual voidUpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); virtual voidUpdateSceneInfo(TGLRnrCtx& rnrCtx).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLScene.html:5464,log,logid,5464,root/html534/TGLScene.html,https://root.cern,https://root.cern/root/html534/TGLScene.html,3,['log'],['logid']
Testability,"over uniform observables; RooArgSet_uniformVars; Int_t_updateFMaxPerEventIf true, maximum p.d.f value needs to be recalculated for each event; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0); Initialize a new context for generating events with the specified; variables, using the specified PDF model. A prototype dataset (if provided); is not cloned and still belongs to the caller. The contents and shape; of this dataset can be changed between calls to generate() as long as the; expected columns to be copied to the generated dataset are present.; Any argument supplied in the forceDirect RooArgSet are always offered; for internal generation to the p.d.f., even if this is deemed unsafe by; the logic of RooGenContext. ~RooGenContext(); Destructor. void attach(const RooArgSet& params); Attach the cloned model to the event buffer we will be filling. void initGenerator(const RooArgSet& theEvent); Perform one-time initialization of the generator context. void generateEvent(RooArgSet& theEvent, Int_t remaining); Generate one event. The 'remaining' integer is not used other than; for printing messages. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Printing interface. RooGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0). » Last changed: Fri Dec 11 12:20:07 2009 » Last generated: 2009-12-11 12:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooGenContext.html:9967,log,logic,9967,root/html526/RooGenContext.html,https://root.cern,https://root.cern/root/html526/RooGenContext.html,1,['log'],['logic']
Testability,"over uniform observables; RooArgSet_uniformVars; Int_t_updateFMaxPerEventIf true, maximum p.d.f value needs to be recalculated for each event; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0); Initialize a new context for generating events with the specified; variables, using the specified PDF model. A prototype dataset (if provided); is not cloned and still belongs to the caller. The contents and shape; of this dataset can be changed between calls to generate() as long as the; expected columns to be copied to the generated dataset are present.; Any argument supplied in the forceDirect RooArgSet are always offered; for internal generation to the p.d.f., even if this is deemed unsafe by; the logic of RooGenContext. ~RooGenContext(); Destructor. void attach(const RooArgSet& params); Attach the cloned model to the event buffer we will be filling. void initGenerator(const RooArgSet& theEvent); Perform one-time initialization of the generator context. void generateEvent(RooArgSet& theEvent, Int_t remaining); Generate one event. The 'remaining' integer is not used other than; for printing messages. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Printing interface. RooGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0). » Last changed: Thu Sep 23 19:59:50 2010 » Last generated: 2010-09-23 19:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooGenContext.html:10016,log,logic,10016,root/html528/RooGenContext.html,https://root.cern,https://root.cern/root/html528/RooGenContext.html,1,['log'],['logic']
Testability,"ow available workers. TList * QuerySessions(Option_t* opt = ""S""); Get list of sessions accessible to this manager. Bool_t HandleInput(const void* ); Handle asynchronous input on the socket. Bool_t HandleError(const void* in = 0); Handle error on the input socket. Int_t Reset(Bool_t hard = kFALSE, const char* usr = 0); Send a cleanup request for the sessions associated with the current user.; If 'hard' is true sessions are signalled for termination and moved to; terminate at all stages (top master, sub-master, workers). Otherwise; (default) only top-master sessions are asked to terminate, triggering; a gentle session termination. In all cases all sessions should be gone; after a few (2 or 3) session checking cycles.; A user with superuser privileges can also asks cleaning for an different; user, specified by 'usr', or for all users (usr = *); Return 0 on success, -1 in case of error. TProofLog * GetSessionLogs(Int_t ridx = 0, const char* stag = 0, const char* pattern = ""-v \""| SvcMsg\"""", Bool_t rescan = kFALSE); Get logs or log tails from last session associated with this manager; instance.; The arguments allow to specify a session different from the last one:; isess specifies a position relative to the last one, i.e. 1; for the next to last session; the absolute value is taken; so -1 and 1 are equivalent.; stag specifies the unique tag of the wanted session; The special value stag = ""NR"" allows to just initialize the TProofLog; object w/o retrieving the files; this may be useful when the number; of workers is large and only a subset of logs is required.; If 'stag' is specified 'isess' is ignored (unless stag = ""NR"").; If 'pattern' is specified only the lines containing it are retrieved; (remote grep functionality); to filter out a pattern 'pat' use; pattern = ""-v pat"".; If 'rescan' is TRUE, masters will rescan the worker sandboxes for the exact; paths, instead of using the save information; may be useful when the; ssave information looks wrong or incomplete.; Returns",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TXProofMgr.html:11778,log,logs,11778,root/html530/TXProofMgr.html,https://root.cern,https://root.cern/root/html530/TXProofMgr.html,4,['log'],"['log', 'logs']"
Testability,"ow(Bool_t finished = false); TMVA::PDEFoamPDEFoam(const TMVA::PDEFoam&); Long_tPeekLast(); Long_tPeekMax(); voidSetCellElement(TMVA::PDEFoamCell* cell, UInt_t i, Double_t value); voidVaredu(Double_t*, Int_t&, Double_t&, Double_t&); Float_tWeightGaus(TMVA::PDEFoamCell*, vector<Float_t>&, UInt_t dim = 0); Double_tWeightLinNeighbors(vector<Float_t>& txvec, TMVA::ECellValue cv, Int_t dim1 = -1, Int_t dim2 = -1, Bool_t TreatEmptyCells = kFALSE). private:. TMVA::PDEFoamDistr*GetDistr() const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*fAlpha[fDim] Internal parameters of the hyperrectangle; TMVA::PDEFoamCell**fCells[fNCells] Array of ALL cells; TMVA::EDTSeparationfDTSeparationsplit cells according to decision tree logic; Int_tfDimDimension of the integration/simulation space; TMVA::PDEFoamDistr*fDistr! distribution of training events; Int_tfEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tfFillFoamWithOrigWeightsfill the foam with boost or orig. weights; TMVA::EFoamTypefFoamTypetype of foam; TObjArray*fHistEdgHistograms of wt, one for each cell edge; Int_t*fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tfLastCeIndex of the last cell; TMVA::MsgLogger*fLogger! message logger; Int_t*fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tfMaxDepthmaximum depth of cell tree; Int_tfNBinNo. of bins in the edge histogram for cell MC exploration; Int_tfNCellsMaximum number of cells; UInt_tfNElementsnumber of variables in every cell; Int_tfNSamplNo. of MC events, when dividing (exploring) cell; TStringfNameName of a given instance of the FOAM class; UInt_tfNminminimal number of events in cell to split cell; Int_tfNoActNumber of active cells; Bool_tfPeekMaxpeek up cell with max. driver integral for split; TRan",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__PDEFoam.html:10066,log,logic,10066,root/html528/TMVA__PDEFoam.html,https://root.cern,https://root.cern/root/html528/TMVA__PDEFoam.html,1,['log'],['logic']
Testability,"owPtr( nullptr ),; 154 fpTmpCoordErrorVector( nullptr ), fpTmpBinEdgeVector( nullptr ); 155 {; 156 assert( val );; 157 fDataPtr = val;; 158 ; 159 if ( nullptr != eval ); 160 {; 161 fDataErrorPtr = eval;; 162 ; 163 fErrorType = kValueError;; 164 ; 165 if ( nullptr != ex || nullptr != ey || nullptr != ez ); 166 {; 167 fCoordErrorsPtr.resize( 3 );; 168 ; 169 fCoordErrorsPtr[0] = ex;; 170 fCoordErrorsPtr[1] = ey;; 171 fCoordErrorsPtr[2] = ez;; 172 ; 173 fErrorType = kCoordError;; 174 }; 175 }; 176 else; 177 {; 178 fErrorType = kNoError;; 179 }; 180 ; 181 fpTmpCoordErrorVector = new double [ fDim ];; 182 ComputeSums();; 183 }; 184 ; 185 /**; 186 destructor; 187 */; 188 BinData::~BinData(); 189 {; 190 assert( fMaxPoints == 0 || fWrapped == fData.empty() );; 191 ; 192 assert( kValueError == fErrorType || kCoordError == fErrorType ||; 193 kAsymError == fErrorType || kNoError == fErrorType );; 194 assert( fMaxPoints == 0 || fDataError.empty() || &fDataError.front() == fDataErrorPtr );; 195 assert( fMaxPoints == 0 || fDataErrorHigh.empty() || &fDataErrorHigh.front() == fDataErrorHighPtr );; 196 assert( fMaxPoints == 0 || fDataErrorLow.empty() || &fDataErrorLow.front() == fDataErrorLowPtr );; 197 assert( fMaxPoints == 0 || fDataErrorLow.empty() == fDataErrorHigh.empty() );; 198 assert( fMaxPoints == 0 || fData.empty() || &fData.front() == fDataPtr );; 199 ; 200 for ( unsigned int i=0; i < fDim; i++ ); 201 {; 202 assert( fCoordErrors.empty() || &fCoordErrors[i].front() == fCoordErrorsPtr[i] );; 203 }; 204 ; 205 if ( fpTmpBinEdgeVector ); 206 {; 207 delete[] fpTmpBinEdgeVector;; 208 fpTmpBinEdgeVector= nullptr;; 209 }; 210 ; 211 if ( fpTmpCoordErrorVector ); 212 {; 213 delete[] fpTmpCoordErrorVector;; 214 fpTmpCoordErrorVector = nullptr;; 215 }; 216 }; 217 ; 218 /**; 219 copy constructors; 220 */; 221 BinData::BinData(const BinData &rhs); 222 : FitData(rhs),; 223 fDataPtr(nullptr),; 224 fDataErrorPtr(nullptr), fDataErrorHighPtr(nullptr), fDataErrorLowPtr(nullptr),; 225 fpTmpCoord",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:5387,assert,assert,5387,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['assert'],['assert']
Testability,"ows custom dashed lines on the lower plot, specified by a vector of floats. ;  ;  ratioplot5.C;   Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors. ;  ;  ratioplot5.py;   Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors. ;  ;  ratioplot6.C;   Example showing a fit residual plot, where the separation margin has been set to 0. ;  ;  ratioplot6.py;   Example showing a fit residual plot, where the separation margin has been set to 0. ;  ;  ratioplotOld.C;  Example displaying two histograms and their ratio. ;  ;  rebin.C;   Rebin a variable bin-width histogram. ;  ;  reverseaxis.C;   Example showing an histogram with reverse axis. ;  ;  sparsehist.C;  Evaluate the performance of THnSparse vs TH1/2/3/nF for different numbers of dimensions and bins per dimension. ;  ;  statsEditing.C;   Edit statistics box. ;  ;  testSmooth.C;   Histogram smoothing. ;  ;  th2polyBoxes.C;   This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly). ;  ;  th2polyEurope.C;   This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it. ;  ;  th2polyHoneycomb.C;   This tutorial illustrates how to create an histogram with hexagonal bins (TH2Poly). ;  ;  th2polyUSA.C;   This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it using the col option. ;  ;  thstack2palettecolor.C;   Palette coloring for 2D histograms' stack is activated thanks to the option PFC (Palette Fill Color). ;  ;  thstackcolorscheme.C;   This example demonstrates how to use the accessible color schemes with THStack. ;  ;  thstackpalettecolor.C;   Palette coloring for histograms' stack is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ;  ;  tprofile2polyRealistic.C;   D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html:5187,test,testSmooth,5187,doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html,https://root.cern,https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html,1,['test'],['testSmooth']
Testability,"ows the quota and usage of all groups if opt contains ""U"" shows also distribution of usage on user-level ; Definition at line 11309 of file TProof.cxx. ◆ ShowDataSets(). void TProof::ShowDataSets ; (; const char * ; uri = """", . const char * ; optStr = """" . ). virtual . Shows datasets in locations that match the uri. ; By default shows the user's datasets and global ones ; Reimplemented in TProofLite.; Definition at line 10846 of file TProof.cxx. ◆ ShowEnabledPackages(). void TProof::ShowEnabledPackages ; (; Bool_t ; all = kFALSE). List which packages are enabled. ; If all is true show enabled packages for all active slaves. If everything is ok all active slaves should have the same packages enabled. ; Definition at line 7818 of file TProof.cxx. ◆ ShowFeedback(). void TProof::ShowFeedback ; (; ); const. Show items in feedback list. ; Definition at line 10020 of file TProof.cxx. ◆ ShowLog() [1/2]. void TProof::ShowLog ; (; const char * ; queryref). Display on screen the content of the temporary log file for query in reference. ; Definition at line 10338 of file TProof.cxx. ◆ ShowLog() [2/2]. void TProof::ShowLog ; (; Int_t ; qry = -1). Display on screen the content of the temporary log file. ; If qry == -2 show messages from the last (current) query. If qry == -1 all the messages not yet displayed are shown (default). If qry == 0, all the messages in the file are shown. If qry > 0, only the messages related to query 'qry' are shown. For qry != -1 the original file offset is restored at the end ; Definition at line 10371 of file TProof.cxx. ◆ ShowMissingFiles(). void TProof::ShowMissingFiles ; (; TQueryResult * ; qr = 0). Show information about missing files during query described by 'qr' or the last query if qr is null (default). ; A short summary is printed in the end. ; Definition at line 12522 of file TProof.cxx. ◆ ShowPackages(). void TProof::ShowPackages ; (; Bool_t ; all = kFALSE, . Bool_t ; redirlog = kFALSE . ). List contents of package directory. ; If all is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:149913,log,log,149913,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['log'],['log']
Testability,"ows to fix the parameter (not to fit). ; Definition at line 102 of file TSpectrum2Fit.h. ◆ fFixSigmaY. Bool_t TSpectrum2Fit::fFixSigmaY. protected . logical value of sigma y parameter, which allows to fix the parameter (not to fit). ; Definition at line 103 of file TSpectrum2Fit.h. ◆ fFixSx. Bool_t TSpectrum2Fit::fFixSx. protected . logical value of s parameter for 1D ridges in x direction, which allows to fix the parameter (not to fit). ; Definition at line 109 of file TSpectrum2Fit.h. ◆ fFixSxy. Bool_t TSpectrum2Fit::fFixSxy. protected . logical value of s parameter for 2D peaks, which allows to fix the parameter (not to fit). ; Definition at line 106 of file TSpectrum2Fit.h. ◆ fFixSy. Bool_t TSpectrum2Fit::fFixSy. protected . logical value of s parameter for 1D ridges in y direction, which allows to fix the parameter (not to fit). ; Definition at line 110 of file TSpectrum2Fit.h. ◆ fFixTx. Bool_t TSpectrum2Fit::fFixTx. protected . logical value of t parameter for 1D ridges in x direction, which allows to fix the parameter (not to fit). ; Definition at line 107 of file TSpectrum2Fit.h. ◆ fFixTxy. Bool_t TSpectrum2Fit::fFixTxy. protected . logical value of t parameter for 2D peaks, which allows to fix the parameter (not to fit). ; Definition at line 105 of file TSpectrum2Fit.h. ◆ fFixTy. Bool_t TSpectrum2Fit::fFixTy. protected . logical value of t parameter for 1D ridges in y direction, which allows to fix the parameter (not to fit). ; Definition at line 108 of file TSpectrum2Fit.h. ◆ fNPeaks. Int_t TSpectrum2Fit::fNPeaks. protected . number of peaks present in fit, input parameter, it should be > 0 ; Definition at line 18 of file TSpectrum2Fit.h. ◆ fNumberIterations. Int_t TSpectrum2Fit::fNumberIterations. protected . number of iterations in fitting procedure, input parameter, it should be > 0 ; Definition at line 19 of file TSpectrum2Fit.h. ◆ fPositionCalcX. Double_t* TSpectrum2Fit::fPositionCalcX. protected . [fNPeaks] array of calculated values of x positions of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2Fit.html:86891,log,logical,86891,doc/master/classTSpectrum2Fit.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2Fit.html,1,['log'],['logical']
Testability,"ox with axes aligned box. ;  ; TSceneInfo * CreateSceneInfo (TGLViewerBase *view) override;  Create a scene-info instance appropriate for this scene class. ;  ; virtual Bool_t DestroyLogical (TObject *logid, Bool_t mustFind=kTRUE);  Destroy logical shape defined by unique 'ID'. ;  ; virtual Int_t DestroyLogicals ();  Destroy all logical shapes in scene. ;  ; virtual Bool_t DestroyPhysical (UInt_t phid);  Destroy physical shape defined by unique 'ID'. ;  ; virtual Int_t DestroyPhysicals ();  Destroy physical shapes. ;  ; void DumpMapSizes () const;  Print sizes of logical and physical-shape maps. ;  ; void EndSmartRefresh ();  Wipes logicals in refresh-cache. ;  ; virtual void EndUpdate (Bool_t minorChange=kTRUE, Bool_t sceneChanged=kTRUE, Bool_t updateViewers=kTRUE);  Exit scene update mode. ;  ; TGLLogicalShape * FindLogical (TObject *logid) const override;  Find and return logical shape identified by unique logid. ;  ; TGLLogicalShape * FindLogicalSmartRefresh (TObject *ID) const;  Find and return logical shape identified by unique 'ID' in refresh-cache. ;  ; virtual TGLPhysicalShape * FindPhysical (UInt_t phid) const;  Find and return physical shape identified by unique 'ID'. ;  ; TGLContextIdentity * GetGLCtxIdentity () const;  ; virtual UInt_t GetMaxPhysicalID ();  Returns the maximum used physical id. ;  ; void LodifySceneInfo (TGLRnrCtx &rnrCtx) override;  Setup LOD-dependant values in scene-info. ;  ; void PostDraw (TGLRnrCtx &rnrCtx) override;  Called after the rendering is finished. ;  ; void PreDraw (TGLRnrCtx &rnrCtx) override;  Initialize rendering. ;  ; void RebuildSceneInfo (TGLRnrCtx &rnrCtx) override;  Major change in scene, need to rebuild all-element draw-vector and sort it. ;  ; LogicalShapeMap_t & RefLogicalShapes ();  ; virtual void RenderAllPasses (TGLRnrCtx &rnrCtx, DrawElementPtrVec_t &elVec, Bool_t check_timeout);  Do full rendering of scene. ;  ; virtual void RenderElements (TGLRnrCtx &rnrCtx, DrawElementPtrVec_t &elVec, Bool_t check_timeou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLScenePad.html:12671,log,logical,12671,doc/master/classTGLScenePad.html,https://root.cern,https://root.cern/doc/master/classTGLScenePad.html,1,['log'],['logical']
Testability,"oxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; RooListProxy_set1Set of constraint terms; TIterator*_setIter1! do not persist; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooConstraintSum(); Default constructor. RooConstraintSum(const char* name, const char* title, const RooArgSet& constraintSet, const RooArgSet& paramSet); Constructor with set of constraint p.d.f.s. All elements in constraintSet must inherit from RooAbsPdf. RooConstraintSum(const RooConstraintSum& other, const char* name = 0); Copy constructor. ~RooConstraintSum(); Destructor. Double_t evaluate() const; Return sum of -log of constraint p.d.f.s. TObject* clone(const char* newname) const; { return new RooConstraintSum(*this, newname); }. » Last changed: Mon Jul 4 15:22:32 2011 » Last generated: 2011-07-04 15:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooConstraintSum.html:33823,log,log,33823,root/html530/RooConstraintSum.html,https://root.cern,https://root.cern/root/html530/RooConstraintSum.html,1,['log'],['log']
Testability,"oxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; RooListProxy_set1Set of constraint terms; TIterator*_setIter1! do not persist; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooConstraintSum(); Default constructor. RooConstraintSum(const char* name, const char* title, const RooArgSet& constraintSet, const RooArgSet& paramSet); Constructor with set of constraint p.d.f.s. All elements in constraintSet must inherit from RooAbsPdf. RooConstraintSum(const RooConstraintSum& other, const char* name = 0); Copy constructor. ~RooConstraintSum(); Destructor. Double_t evaluate() const; Return sum of -log of constraint p.d.f.s. TObject* clone(const char* newname) const; { return new RooConstraintSum(*this, newname); }. » Last changed: Thu Nov 3 20:07:50 2011 » Last generated: 2011-11-03 20:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooConstraintSum.html:34202,log,log,34202,root/html532/RooConstraintSum.html,https://root.cern,https://root.cern/root/html532/RooConstraintSum.html,1,['log'],['log']
Testability,"oy(const Int_t nevents); Forces n events even for extended PDFs. Set NEvents=0 to; use the Poisson distributed events from the extended PDF. void SetParametersForTestStat(const RooArgSet& nullpoi); specify the values of parameters used when evaluating test statistic. { fNullPOI = (RooArgSet*)nullpoi.snapshot(); }. void SetPdf(RooAbsPdf& pdf); Set the Pdf, add to the the workspace if not already there. { fPdf = &pdf; }. void SetPriorNuisance(RooAbsPdf* pdf); How to randomize the prior. Set to NULL to deactivate randomization. { fPriorNuisance = pdf; }. void SetNuisanceParameters(const RooArgSet& np); specify the nuisance parameters (eg. the rest of the parameters). { fNuisancePars = &np; }. void SetObservables(const RooArgSet& o); specify the observables in the dataset (needed to evaluate the test statistic). { fObservables = &o; }. void SetGlobalObservables(const RooArgSet& o); specify the conditional observables. { fGlobalObservables = &o; }. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). { fSize = size; }. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). { fSize = 1. - cl; }. void SetTestStatistic(RooStats::TestStatistic* testStatistic); Set the TestStatistic (want the argument to be a function of the data & parameter points. { fTestStat = testStatistic; }. void SetExpectedNuisancePar(Bool_t i = kTRUE); { fExpectedNuisancePar = i; }. void SetAsimovNuisancePar(Bool_t i = kTRUE); { fExpectedNuisancePar = i; }. void SetGenerateBinned(bool binned = true); control to use bin data generation. { fGenerateBinned = binned; }. void SetSamplingDistName(const char* name); Set the name of the sampling distribution used for plotting. { if(name) fSamplingDistName = name; }. string GetSamplingDistName(void); { return fSamplingDistName; }. void SetMaxToys(Double_t t); This option forces a maximum number of total toys. { fMaxToys = t; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__ToyMCSampler.html:6820,test,test,6820,root/html528/RooStats__ToyMCSampler.html,https://root.cern,https://root.cern/root/html528/RooStats__ToyMCSampler.html,1,['test'],['test']
Testability,"oys = ntoy; }. void SetNEventsPerToy(const Int_t nevents); Forces n events even for extended PDFs. Set NEvents=0 to; use the Poisson distributed events from the extended PDF. void SetParametersForTestStat(const RooArgSet& nullpoi); specify the values of parameters used when evaluating test statistic. void SetPdf(RooAbsPdf& pdf); Set the Pdf, add to the the workspace if not already there. { fPdf = &pdf; ClearCache(); }. void SetPriorNuisance(RooAbsPdf* pdf); How to randomize the prior. Set to NULL to deactivate randomization. { fPriorNuisance = pdf; }. void SetNuisanceParameters(const RooArgSet& np); specify the nuisance parameters (eg. the rest of the parameters). { fNuisancePars = &np; }. void SetObservables(const RooArgSet& o); specify the observables in the dataset (needed to evaluate the test statistic). { fObservables = &o; }. void SetGlobalObservables(const RooArgSet& o); specify the conditional observables. { fGlobalObservables = &o; }. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). { fSize = size; }. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). { fSize = 1. - cl; }. void SetTestStatistic(RooStats::TestStatistic* testStatistic); Set the TestStatistic (want the argument to be a function of the data & parameter points. { fTestStat = testStatistic; }. void SetExpectedNuisancePar(Bool_t i = kTRUE); { fExpectedNuisancePar = i; }. void SetAsimovNuisancePar(Bool_t i = kTRUE); { fExpectedNuisancePar = i; }. void SetGenerateBinned(bool binned = true); control to use bin data generation (=> see RooFit::AllBinned() option). { fGenerateBinned = binned; }. void SetGenerateBinnedTag(const char* binnedTag = """"); name of the tag for individual components to be generated binned (=> see RooFit::GenBinned() option). { fGenerateBinnedTag = binnedTag; }. void SetGenerateAutoBinned(Bool_t autoBinned = kTRUE); set auto binned gener",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__ToyMCSampler.html:8730,test,test,8730,root/html532/RooStats__ToyMCSampler.html,https://root.cern,https://root.cern/root/html532/RooStats__ToyMCSampler.html,1,['test'],['test']
Testability,"oys(); stringGetSamplingDistName(); virtual RooStats::SamplingDistribution*GetSamplingDistribution(RooArgSet& paramPoint); virtual RooStats::SamplingDistribution*GetSamplingDistributionSingleWorker(RooArgSet& paramPoint); virtual RooStats::TestStatistic*GetTestStatistic() const; virtual voidInitialize(RooAbsArg&, RooArgSet&, RooArgSet&); virtual TClass*IsA() const; RooStats::TestStatSampler&RooStats::TestStatSampler::operator=(const RooStats::TestStatSampler&); static voidSetAlwaysUseMultiGen(Bool_t flag); virtual voidSetAsimovNuisancePar(Bool_t i = kTRUE); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetExpectedNuisancePar(Bool_t i = kTRUE); voidSetGenerateBinned(bool binned = true); virtual voidSetGlobalObservables(const RooArgSet& o); voidSetImportanceDensity(RooAbsPdf* p); voidSetImportanceSnapshot(const RooArgSet& s); voidSetMaxToys(Double_t t); virtual voidSetNEventsPerToy(const Int_t nevents); virtual voidSetNToys(const Int_t ntoy); virtual voidSetNuisanceParameters(const RooArgSet& np); virtual voidSetObservables(const RooArgSet& o); virtual voidSetParametersForTestStat(const RooArgSet& nullpoi); virtual voidSetPdf(RooAbsPdf& pdf); virtual voidSetPriorNuisance(RooAbsPdf* pdf); voidSetProofConfig(RooStats::ProofConfig* pc = NULL); voidSetProtoData(const RooDataSet* d); virtual voidSetSamplingDistName(const char* name); virtual voidSetTestSize(Double_t size); virtual voidSetTestStatistic(RooStats::TestStatistic* testStatistic); voidSetToysBothTails(Double_t toys, Double_t low_threshold, Double_t high_threshold); voidSetToysLeftTail(Double_t toys, Double_t threshold); voidSetToysRightTail(Double_t toys, Double_t threshold); voidSetUseMultiGen(Bool_t flag); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); RooStats::ToyMCSamplerToyMCSampler(); RooStats::ToyMCSamplerToyMCSampler(const RooStats::ToyMCSampler&); RooStats::ToyMCSamplerToyMCSampler(RooStats::TestStatistic& ts, Int_t ntoys).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__ToyMCSampler.html:2489,test,testStatistic,2489,root/html530/RooStats__ToyMCSampler.html,https://root.cern,https://root.cern/root/html530/RooStats__ToyMCSampler.html,1,['test'],['testStatistic']
Testability,"p = kFALSE). Display logs. ; 'grep' is set to kTRUE if it is invoked by pressing the 'Filter' button. ; Definition at line 388 of file TProofProgressLog.cxx. ◆ Init(). void TProofProgressLog::Init ; (; Int_t ; w = 700, . Int_t ; h = 600 . ). private . Init window frame for log messages. ; Definition at line 70 of file TProofProgressLog.cxx. ◆ IsA(). TClass * TProofProgressLog::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGTransientFrame.; Definition at line 93 of file TProofProgressLog.h. ◆ LoadBuffer(). void TProofProgressLog::LoadBuffer ; (; const char * ; buffer). Load a text buffer in the window. ; Definition at line 280 of file TProofProgressLog.cxx. ◆ LoadFile(). void TProofProgressLog::LoadFile ; (; const char * ; file). Load a file in the window. ; Definition at line 289 of file TProofProgressLog.cxx. ◆ LogMessage(). void TProofProgressLog::LogMessage ; (; const char * ; msg, . Bool_t ; all . ). Load/append a log msg in the log frame, if open. ; Definition at line 519 of file TProofProgressLog.cxx. ◆ NoLineEntry(). void TProofProgressLog::NoLineEntry ; (; ). Enable/disable the line number entry. ; Definition at line 599 of file TProofProgressLog.cxx. ◆ Popup(). void TProofProgressLog::Popup ; (; ). Show log window. ; Definition at line 263 of file TProofProgressLog.cxx. ◆ Rebuild(). void TProofProgressLog::Rebuild ; (; ). Rebuild the log info for a new entered session. ; Definition at line 635 of file TProofProgressLog.cxx. ◆ SaveToFile(). void TProofProgressLog::SaveToFile ; (; ). Save the logs to a file Only the name of the file is taken, no expansion. ; Definition at line 534 of file TProofProgressLog.cxx. ◆ Select(). void TProofProgressLog::Select ; (; Int_t ; id, . Bool_t ; all = kTRUE . ). actions of select all/clear all button ; Definition at line 614 of file TProofProgressLog.cxx. ◆ SetGrepView(). void TProofProgressLog::SetGrepView ; (; ). Sets the view of grep filters according to the value",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofProgressLog.html:41473,log,log,41473,doc/master/classTProofProgressLog.html,https://root.cern,https://root.cern/doc/master/classTProofProgressLog.html,2,['log'],['log']
Testability,"p over all entries on the TTree.; while (subscriptionManager.Next()) {; // Now myTribuneDeGeneve has loaded its data and we can access it.; // TTreeReaderValue behaves like an iterator; you need to use ""->"" on; // it to access the data it refers to.; myTribuneDeGeneve->read();; ...; }. Summary; As you saw, TTree is about. Chunking up similar, disconnected entries of which typically only one needs to be available, just like newspaper issues or data from High Energy Physics collisions, also known as the entries of a TTree; Selecting which data the TTree should provide, i.e. subscribing to certain branches only. Branches can be nested, so depending on the tree you could even subscribe to only the sports section or even only an article, reducing data transfer. A precedure like this is actually what most physicists do to analyze data from a series of TTrees. So let's try it in practice!; . ‹ Using TTree::Draw() to access a TTree; up; Using a Macro to Read a TTree ›. Navigate through this book; Meet a TTree; Accessing a TTree With a TBrowser; Using TTree::Draw() to access a TTree; TTree and Its Data; Using a Macro to Read a TTree; Histogramming; Fit Panel; Compiling Your Code (also known as ACLiC); Accessing a TTree With a TSelector; Histogramming in a Selector; Using a TSelector with PROOF; The End. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/ttree-and-its-data.html:5307,test,tests,5307,d/ttree-and-its-data.html,https://root.cern,https://root.cern/d/ttree-and-its-data.html,1,['test'],['tests']
Testability,p over test events and fill histograms with classifier response...; : ; TFHandler_KNN : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: 0.21781 1.7248 [ -9.8605 7.9024 ]; : myvar2: -0.062175 1.1106 [ -4.0854 4.0259 ]; : var3: 0.16451 1.0589 [ -5.3563 4.6422 ]; : var4: 0.43566 1.2253 [ -6.9675 5.0307 ]; : -----------------------------------------------------------; Factory : Evaluate classifier: LD; : ; LD : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Also filling probability and rarity histograms (on request)...; TFHandler_LD : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: 0.21781 1.7248 [ -9.8605 7.9024 ]; : myvar2: -0.062175 1.1106 [ -4.0854 4.0259 ]; : var3: 0.16451 1.0589 [ -5.3563 4.6422 ]; : var4: 0.43566 1.2253 [ -6.9675 5.0307 ]; : -----------------------------------------------------------; Factory : Evaluate classifier: FDA_GA; : ; FDA_GA : [dataset] : Loop over test events and fill histograms with classifier response...; : ; TFHandler_FDA_GA : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: 0.21781 1.7248 [ -9.8605 7.9024 ]; : myvar2: -0.062175 1.1106 [ -4.0854 4.0259 ]; : var3: 0.16451 1.0589 [ -5.3563 4.6422 ]; : var4: 0.43566 1.2253 [ -6.9675 5.0307 ]; : -----------------------------------------------------------; Factory : Evaluate classifier: MLPBNN; : ; TFHandler_MLPBNN : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: 0.12216 0.20255 [ -1.0614 1.0246 ]; : myvar2: -0.12333 0.30492 [ -1.2280 0.99911 ]; : var3: 0.097148 0.21347 [ -1.0158 0.99984 ]; : var4: 0.17495 0.23851 [ -1.2661 1.0694 ]; : -----------------------------------------------------------; MLPBNN : [dataset] : Loop over test events and fill histograms with classifier response...; : ; TFHandler_MLPBNN : Variable Mean RMS [,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:74078,test,test,74078,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['test'],['test']
Testability,"p(c3*v))/u;; 695 } else if (u < 6.8116) {; 696 r[1] = 0;; 697 r[2] = 0;; 698 r[3] = 0;; 699 Double_t v = u*u;; 700 Int_t maxj = TMath::Max(1,TMath::Nint(3./u));; 701 for (Int_t j=0; j<maxj;j++) {; 702 r[j] = TMath::Exp(fj[j]*v);; 703 }; 704 p = 2*(r[0] - r[1] +r[2] - r[3]);; 705 } else {; 706 p = 0;; 707 }; 708 return p;; 709 }; 710 ; 711////////////////////////////////////////////////////////////////////////////////; 712/// Statistical test whether two one-dimensional sets of points are compatible; 713/// with coming from the same parent distribution, using the Kolmogorov test.; 714/// That is, it is used to compare two experimental distributions of unbinned data.; 715///; 716/// ### Input:; 717/// a,b: One-dimensional arrays of length na, nb, respectively.; 718/// The elements of a and b must be given in ascending order.; 719/// option is a character string to specify options; 720/// ""D"" Put out a line of ""Debug"" printout; 721/// ""M"" Return the Maximum Kolmogorov distance instead of prob; 722///; 723/// ### Output:; 724/// The returned value prob is a calculated confidence level which gives a; 725/// statistical test for compatibility of a and b.; 726/// Values of prob close to zero are taken as indicating a small probability; 727/// of compatibility. For two point sets drawn randomly from the same parent; 728/// distribution, the value of prob should be uniformly distributed between; 729/// zero and one.; 730/// in case of error the function return -1; 731/// If the 2 sets have a different number of points, the minimum of; 732/// the two sets is used.; 733///; 734/// ### Method:; 735/// The Kolmogorov test is used. The test statistic is the maximum deviation; 736/// between the two integrated distribution functions, multiplied by the; 737/// normalizing factor (rdmax*sqrt(na*nb/(na+nb)).; 738///; 739/// Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); 740/// (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; 741/// Statistical Metho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8cxx_source.html:23554,test,test,23554,doc/master/TMath_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html,1,['test'],['test']
Testability,"p); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TMVA::MsgLogger&Log() const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMVA::MsgLogger*fLogger! message logger. private:. TMVA::BinarySearchTree*fBstBinary tree to find events within a volume; TMVA::TDensityCalcfDensityCalcmethod of density calculation; const TMVA::PDEFoam*fPDEFoamPDEFoam to refer to. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamDistr(); {}. ~PDEFoamDistr(). PDEFoamDistr(const TMVA::PDEFoamDistr& ); Copy constructor. void Initialize(); Initialisation of binary search tree.; Set dimension and create new BinarySearchTree. void FillBinarySearchTree(const TMVA::Event* ev, TMVA::EFoamType ft, Bool_t NoNegWeights = kFALSE); This method creates an TMVA::Event and inserts it into the; binary search tree. If 'NoNegWeights' is true, an event with negative weight will; not be filled into the foam. (Default value: false). Double_t Density(Double_t* Xarg, Double_t& event_density); This function is needed during the foam buildup.; It return a certain density depending on the selected classification; or regression option",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__PDEFoamDistr.html:5609,log,logger,5609,root/html528/TMVA__PDEFoamDistr.html,https://root.cern,https://root.cern/root/html528/TMVA__PDEFoamDistr.html,1,['log'],['logger']
Testability,"p; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TProofOutputFile::EStatusBitskOutputFileNameSet; static TProofOutputFile::ETypeOptkOverwrite; static TObject::(anonymous)TObject::kOverwrite; static TProofOutputFile::ETypeOptkRegister; static TProofOutputFile::ETypeOptkRemote; static TProofOutputFile::EStatusBitskRetrieve; static TObject::(anonymous)TObject::kSingleKey; static TProofOutputFile::EStatusBitskSwapFile; static TProofOutputFile::ETypeOptkVerify; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TFileCollection*fDataSetInstance of the file collection in 'dataset' mode; TStringfDirname of the directory to be exported; TStringfFileName; Bool_tfIsLocalkTRUE if the file is in the sandbox; TStringfLocalHostHost where the file was created; Bool_tfMergeHistosOneGoIf true merge histos in one go (argument to TFileMerger); Bool_tfMerged; TFileMerger*fMergerInstance of the file merger in 'merge' mode; TStringfOptionsAnchoroptions and anchor string including delimiters, e.g. ""?myopts#myanchor""; TStringfOutputFileName; TStringfRawDirname of the local directory where to create the file; TProofOutputFile::ERunTypefRunTypeType of run (see enum ERunType); UInt_tfTypeOptOption (see enum ETypeOpt); TStringfWorkerOrdinal. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofOutputFile(const char* path, TProofOutputFile::ERunType type, UInt_t opt = kRemote, const char* dsname = 0); Main constructor. TProofOutputFile(const char* path, const char* option = ""M"", const char* dsname = 0); Constructor with the old signature, kept for convenience and backard compatibility.; Options:; 'M' merge: finally merge the created files; 'L' local: copy locally the files before merging (implies 'M'); 'D'",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofOutputFile.html:7963,sandbox,sandbox,7963,root/html602/TProofOutputFile.html,https://root.cern,https://root.cern/root/html602/TProofOutputFile.html,2,['sandbox'],['sandbox']
Testability,"pMessage ; (; const TString & ; datasetname, . const TString & ; methodTitle = """" . ); const. Print predefined help message of classifier. ; Iterate over methods and test. ; Definition at line 1333 of file Factory.cxx. ◆ RootBaseDir(). TDirectory * TMVA::Factory::RootBaseDir ; (; ). inline . Definition at line 149 of file Factory.h. ◆ SetInputTreesFromEventAssignTrees(). void TMVA::Factory::SetInputTreesFromEventAssignTrees ; (; ). private . ◆ SetVerbose(). void TMVA::Factory::SetVerbose ; (; Bool_t ; v = kTRUE). Definition at line 343 of file Factory.cxx. ◆ Streamer(). virtual void TMVA::Factory::Streamer ; (; TBuffer & ; R__b). virtual . Stream an object of class TObject. ; Reimplemented from TMVA::Configurable. ◆ StreamerNVirtual(). void TMVA::Factory::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 227 of file Factory.h. ◆ TestAllMethods(). void TMVA::Factory::TestAllMethods ; (; ). Evaluates all booked methods on the testing data and adds the output to the Results in the corresponiding DataSet. ; Definition at line 1271 of file Factory.cxx. ◆ TrainAllMethods(). void TMVA::Factory::TrainAllMethods ; (; ). Iterates through all booked methods and calls training. ; Definition at line 1114 of file Factory.cxx. ◆ TrainAllMethodsForClassification(). void TMVA::Factory::TrainAllMethodsForClassification ; (; void ; ). inline . Definition at line 115 of file Factory.h. ◆ TrainAllMethodsForRegression(). void TMVA::Factory::TrainAllMethodsForRegression ; (; void ; ). inline . Definition at line 116 of file Factory.h. ◆ Verbose(). Bool_t TMVA::Factory::Verbose ; (; void ; ); const. inline . Definition at line 134 of file Factory.h. ◆ WriteDataInformation(). void TMVA::Factory::WriteDataInformation ; (; DataSetInfo & ; fDataSetInfo). private . Definition at line 602 of file Factory.cxx. Friends And Related Symbol Documentation. ◆ CrossValidation. friend class CrossValidation. friend . Definition at line 81 of file Factory.h. Member ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Factory.html:34861,test,testing,34861,doc/master/classTMVA_1_1Factory.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Factory.html,1,['test'],['testing']
Testability,"pTV]_pseudo_dh) Summation contains a RooNLLVar, using its error level; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0 cHl3=0 cHq3=-0.0202918; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.213672 cHl3=1.97898 cHq3=0.00773174; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.0861399 cHl3=-9.50561 cHq3=0.0801661; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:9200,log,log,9200,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['log'],['log']
Testability,"pY1 . ). This function sets the following fitting parameters of peaks: . sigmaX - initial value of sigma x parameter; fixSigmaX - logical value of sigma x parameter, which allows to fix the parameter (not to fit); sigmaY - initial value of sigma y parameter; fixSigmaY - logical value of sigma y parameter, which allows to fix the parameter (not to fit); ro - initial value of ro parameter (correlation coefficient); fixRo - logical value of ro parameter, which allows to fix the parameter (not to fit); positionInitX - array of initial values of peaks x positions; fixPositionX - array of logical values which allow to fix appropriate x positions (not fit). However they are present in the estimated functional.; positionInitY - array of initial values of peaks y positions; fixPositionY - array of logical values which allow to fix appropriate y positions (not fit). However they are present in the estimated functional.; ampInit - array of initial values of 2D peaks amplitudes; fixAmp - array of logical values which allow to fix appropriate amplitudes of 2D peaks (not fit). However they are present in the estimated functional; ampInitX1 - array of initial values of amplitudes of 1D ridges in x direction; fixAmpX1 - array of logical values which allow to fix appropriate amplitudes of 1D ridges in x direction (not fit). However they are present in the estimated functional; ampInitY1 - array of initial values of amplitudes of 1D ridges in y direction; fixAmpY1 - array of logical values which allow to fix appropriate amplitudes of 1D ridges in y direction (not fit). However they are present in the estimated functional . Definition at line 5583 of file TSpectrum2Fit.cxx. ◆ SetTailParameters(). void TSpectrum2Fit::SetTailParameters ; (; Double_t ; tInitXY, . Bool_t ; fixTxy, . Double_t ; tInitX, . Bool_t ; fixTx, . Double_t ; tInitY, . Bool_t ; fixTy, . Double_t ; bInitX, . Bool_t ; fixBx, . Double_t ; bInitY, . Bool_t ; fixBy, . Double_t ; sInitXY, . Bool_t ; fixSxy, . Double_t ; sI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2Fit.html:73370,log,logical,73370,doc/master/classTSpectrum2Fit.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2Fit.html,1,['log'],['logical']
Testability,"p_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.213672 cHl3=1.97898 cHq3=0.00773174; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.0861399 cHl3=-9.50561 cHq3=0.0801661; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=-0.675078, denominator=wrap_pdf_Int[pTV]=86190.2; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=-0.675078, denominator=wrap_pdf_Int[pTV]=86190.2; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=-0.675078, denominator=wrap_pdf_Int[pTV]=86190.2; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=-0.675078, denominator=wrap_pdf_Int[pTV]=86190.2; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.186765 cHl3=8.8591 cHq3=-0.971282; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:9993,log,log,9993,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['log'],['log']
Testability,"pa(2,1,2)"");; The number of “Nodes” can be changed with n(nodesx,nodesy). Example:; h2->Draw(""SPEC n(40,40)"");; Sometimes the displayed region is rather large. When displaying all channels the pictures become very dense and complicated. It is very difficult to understand the overall shape of data. “n(nx,ny)” allows to change the density of displayed channels. Only the channels coinciding with given nodes are displayed.; The visualization “Angles” can be changed with “a(alpha,beta,view)”: “alpha” is the angle between the bottom horizontal screen line and the displayed space on the right side of the picture and “beta” on the left side, respectively. One can rotate the 3-d space around the vertical axis using the “view” parameter. Allowed values are 0, 90, 180 and 270 degrees.; h2->Draw(""SPEC n(40,40) dm(0,1) a(30,30,0)"");; The operator “zs(scale)” changes the scale of the Z-axis. The possible values are:. 0 = Linear (default),; 1 = Log,; 2 = Sqrt. If gPad->SetLogz() has been set, the log scale on Z-axis is set automatically, i.e. there is no need for using the zs() operator. Note that the X and Y axis are always linear.; The operator “ci(r,g,b)” defines the colors increments (r, g and b are floats). For sophisticated shading (Light, Height and LightHeight Display Modes Groups) the color palette starts from the basic pen color (see pa() function). There is a predefined number of color levels (256). Color in every level is calculated by adding the increments of the r , g , b components to the previous level. Using this function one can change the color increments between two neighboring color levels. The function does not apply on the Simple Display Modes Group. The default values are: (1,1,1).; The operator “ca(color_algorithm)” allows to choose the Color Algorithm. To define the colors one can use one of the following color algorithms (RGB, CMY, CIE, YIQ, HVS models). When the level of a component reaches the limit value one can choose either smooth transition (by dec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:103950,log,log,103950,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['log'],['log']
Testability,"pace &w, const std::string &, const RooArgList &Vars, double, double);  Create the list of RooRealVar parameters which scale the height of histogram bins. ;  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static void verboseDirty (bool flag);  Activate verbose messaging related to dirty flag propagation. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Versi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classParamHistFunc.html:47437,log,logEvalError,47437,doc/master/classParamHistFunc.html,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html,3,['log'],"['logEvalError', 'logging']"
Testability,"pad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tTPad::fGLDevice! OpenGL off-screen pixmap identifier; Bool_tTPad::fGridxSet to true if grid along X; Bool_tTPad::fGridySet to true if grid along Y; Double_tTPad::fHNDCHeight of pad along Y in NDC; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTPad::fLogx(=0 if X linear scale, =1 if log scale); Int_tTPad::fLogy(=0 if Y linear scale, =1 if log scale); Int_tTPad::fLogz(=0 if Z linear scale, =1 if log scale); Bool_tTPad::fModifiedSet to true when pad is modified; TPad*TPad::fMother! pointer to mother of the list; TStringTPad::fNamePad name; Int_tTPad::fNumberpad number identifier; Int_tTPad::fPadPaintSet to 1 while painting the pad; TObject*TPad::fPadPointer! free pointer; TObject*TPad::fPadView3D! 3D View of this TPad; Double_tTPad::fPhiphi angle to view as lego/surface; Double_tTPad::fPixeltoXxworld = fPixeltoXk + fPixeltoX*xpixel; Double_tTPad::fPixeltoXkConversion coefficient for pixel to X World; Double_tTPad::fPixeltoYyworld = fPixeltoYk + fPixeltoY*ypixel; Double_tTPad::fPixeltoYkConversion coefficient for pixel to Y World; Int_tTPad::fPixmapID! Off-screen pixmap identifier; TList*TPad::fPrimitives->List of primitives (subpads); Bool_tTVirtualPad::fResizing!true when resizing the pad; Float_tTAttPad::fRightMarginRightMargin; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Double_tTPad::fThetatheta angle to view as lego/surface; Int_tTPad::fTickxSet to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEvePad.html:24914,log,log,24914,root/html528/TEvePad.html,https://root.cern,https://root.cern/root/html528/TEvePad.html,6,['log'],['log']
Testability,"pad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tTPad::fGLDevice! OpenGL off-screen pixmap identifier; Bool_tTPad::fGridxSet to true if grid along X; Bool_tTPad::fGridySet to true if grid along Y; Double_tTPad::fHNDCHeight of pad along Y in NDC; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTPad::fLogx(=0 if X linear scale, =1 if log scale); Int_tTPad::fLogy(=0 if Y linear scale, =1 if log scale); Int_tTPad::fLogz(=0 if Z linear scale, =1 if log scale); Double_tfMaximumSlider maximum value in [0,1]; TStringfMethodcommand to be executed when slider is changed; Double_tfMinimumSlider minimum value in [0,1]; Bool_tTPad::fModifiedSet to true when pad is modified; TPad*TPad::fMother! pointer to mother of the list; TStringTPad::fNamePad name; Int_tTPad::fNumberpad number identifier; TObject*fObject!Pointer to associated object; Int_tTPad::fPadPaintSet to 1 while painting the pad; TObject*TPad::fPadPointer! free pointer; TObject*TPad::fPadView3D! 3D View of this TPad; Double_tTPad::fPhiphi angle to view as lego/surface; Double_tTPad::fPixeltoXxworld = fPixeltoXk + fPixeltoX*xpixel; Double_tTPad::fPixeltoXkConversion coefficient for pixel to X World; Double_tTPad::fPixeltoYyworld = fPixeltoYk + fPixeltoY*ypixel; Double_tTPad::fPixeltoYkConversion coefficient for pixel to Y World; Int_tTPad::fPixmapID! Off-screen pixmap identifier; TList*TPad::fPrimitives->List of primitives (subpads); Bool_tTVirtualPad::fResizing!true when resizing ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSlider.html:27369,log,log,27369,root/html528/TSlider.html,https://root.cern,https://root.cern/root/html528/TSlider.html,6,['log'],['log']
Testability,"pad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tTPad::fGLDevice! OpenGL off-screen pixmap identifier; Bool_tTPad::fGridxSet to true if grid along X; Bool_tTPad::fGridySet to true if grid along Y; Double_tTPad::fHNDCHeight of pad along Y in NDC; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTPad::fLogx(=0 if X linear scale, =1 if log scale); Int_tTPad::fLogy(=0 if Y linear scale, =1 if log scale); Int_tTPad::fLogz(=0 if Z linear scale, =1 if log scale); TStringTButton::fMethodMethod to be executed by this button; Bool_tTPad::fModifiedSet to true when pad is modified; TPad*TPad::fMother! pointer to mother of the list; TStringTPad::fNamePad name; Int_tTPad::fNumberpad number identifier; Int_tTPad::fPadPaintSet to 1 while painting the pad; TObject*TPad::fPadPointer! free pointer; TObject*TPad::fPadView3D! 3D View of this TPad; Double_tTPad::fPhiphi angle to view as lego/surface; Double_tTPad::fPixeltoXxworld = fPixeltoXk + fPixeltoX*xpixel; Double_tTPad::fPixeltoXkConversion coefficient for pixel to X World; Double_tTPad::fPixeltoYyworld = fPixeltoYk + fPixeltoY*ypixel; Double_tTPad::fPixeltoYkConversion coefficient for pixel to Y World; Int_tTPad::fPixmapID! Off-screen pixmap identifier; TList*TPad::fPrimitives->List of primitives (subpads); Bool_tTVirtualPad::fResizing!true when resizing the pad; Float_tTAttPad::fRightMarginRightMargin; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Short_tTAttText::fT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGroupButton.html:26281,log,log,26281,root/html528/TGroupButton.html,https://root.cern,https://root.cern/root/html528/TGroupButton.html,6,['log'],['log']
Testability,"pad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tTPad::fGLDevice! OpenGL off-screen pixmap identifier; Bool_tTPad::fGridxSet to true if grid along X; Bool_tTPad::fGridySet to true if grid along Y; Double_tTPad::fHNDCHeight of pad along Y in NDC; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTPad::fLogx(=0 if X linear scale, =1 if log scale); Int_tTPad::fLogy(=0 if Y linear scale, =1 if log scale); Int_tTPad::fLogz(=0 if Z linear scale, =1 if log scale); TStringfMethodMethod to be executed by this button; Bool_tTPad::fModifiedSet to true when pad is modified; TPad*TPad::fMother! pointer to mother of the list; TStringTPad::fNamePad name; Int_tTPad::fNumberpad number identifier; Int_tTPad::fPadPaintSet to 1 while painting the pad; TObject*TPad::fPadPointer! free pointer; TObject*TPad::fPadView3D! 3D View of this TPad; Double_tTPad::fPhiphi angle to view as lego/surface; Double_tTPad::fPixeltoXxworld = fPixeltoXk + fPixeltoX*xpixel; Double_tTPad::fPixeltoXkConversion coefficient for pixel to X World; Double_tTPad::fPixeltoYyworld = fPixeltoYk + fPixeltoY*ypixel; Double_tTPad::fPixeltoYkConversion coefficient for pixel to Y World; Int_tTPad::fPixmapID! Off-screen pixmap identifier; TList*TPad::fPrimitives->List of primitives (subpads); Bool_tTVirtualPad::fResizing!true when resizing the pad; Float_tTAttPad::fRightMarginRightMargin; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Short_tTAttText::fTextAlignT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TButton.html:27930,log,log,27930,root/html526/TButton.html,https://root.cern,https://root.cern/root/html526/TButton.html,7,['log'],['log']
Testability,"pad). void Pan(Int_t px, Int_t py); User's moving mouse cursor, with middle mouse button pressed (for pad).; Calculate 3d shift related to 2d mouse movement. void AddOption(const TString& stringOption); Additional options for surfaces. void ProcessEvent(Int_t event, Int_t px, Int_t py); Remove all profiles/sections. void InitGL() const; Initialize some OpenGL state variables. void DeInitGL() const; Initialize some OpenGL state variables. void SetNormals(); One normal per vertex;; this normal is average of; neighbouring triangles normals. void SetSurfaceColor() const; Set color for surface. void DrawPlot() const; Draw surf/surf1/surf2/surf4. Bool_t InitGeometryCartesian(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. Bool_t InitGeometryPolar(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. Bool_t InitGeometryCylindrical(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. Bool_t InitGeometrySpherical(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. void DrawProjections() const; Draw projections. void DrawSectionXOZ() const; Draw section X. void DrawSectionYOZ() const; Draw section Y. void DrawSectionXOY() const; Draw section Z. void ClampZ(Double_t& zVal) const; Clamp z value. char * WindowPointTo3DPoint(Int_t px, Int_t py) const; Find 3d coords using mouse cursor coords.; if (!MakeGLContextCurrent()) {; static char err[] = { ""Apocalipshit!"" };; return err;; }. Bool_t PreparePalette() const; Generate palette. void GenTexMap() const; Find texture coordinates. void DrawC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLSurfacePainter.html:5494,log,logarithmic,5494,root/html528/TGLSurfacePainter.html,https://root.cern,https://root.cern/root/html528/TGLSurfacePainter.html,6,['log'],['logarithmic']
Testability,"pad=new TPad(""newpad"",""Transparent pad"",0,0,1,1);; root[] newpad->SetFillStyle(4000);; root[] newpad->Draw();; root[] newpad->cd();; root[] // create some primitives, etc; 9.3.7 Setting the Log Scale; Setting the scale to logarithmic or linear is an attribute of the pad, not the axis or the histogram. The scale is an attribute of the pad because you may want to draw the same histogram in linear scale in one pad and in log scale in another pad. Frequently, we see several histograms on top of each other in the same pad. It would be very inconvenient to set the scale attribute for each histogram in a pad.; Furthermore, if the logic was set in the histogram class (or each object) the scale setting in each Paint method of all objects should be tested.; If you have a pad with a histogram, a right-click on the pad, outside of the histograms frame will convince you. The SetLogx(), SetLogy() and SetLogz() methods are there. As you see, TPad defines log scale for the two directions x and y plus z if you want to draw a 3D representation of some function or histogram.; The way to set log scale in the x direction for the active pad is:; root[] gPad->SetLogx(1); To reset log in the z direction:; root[] gPad->SetLogz(0); If you have a divided pad, you need to set the scale on each of the sub-pads. Setting it on the containing pad does not automatically propagate to the sub-pads. Here is an example of how to set the log scale for the x-axis on a canvas with four sub-pads:; root[] TCanvas MyCanvas(""MyCanvas"",""My Canvas""); root[] MyCanvas->Divide(2,2); root[] MyCanvas->cd(1); root[] gPad->SetLogx(); root[] MyCanvas->cd(2); root[] gPad->SetLogx(); root[] MyCanvas->cd(3); root[] gPad->SetLogx(); 9.3.8 WaitPrimitive method; When the TPad::WaitPrimitive() method is called with no arguments, it will wait until a double click or any key pressed is executed in the canvas. A call to gSystem->Sleep(10) has been added in the loop to avoid consuming at all the CPU. This new option is convenient",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:317421,log,log,317421,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['log'],['log']
Testability,"page lists a number of ROOT tutorials and courses. Some are made by third parties others by the ROOT team.; Basic. ROOT Basic Course (CERN Technical Training: register here) ; CERN Summer Students' Introductory Tutorial (2018 2017, 2016, 2015 ); First Steps With ROOT; Introductory Tutorials (approx 2 hours); Lectures at the CERN School of Computing (CSC); Bill Seligman's ROOT Tutorial. Intermediate; These are general ROOT tutorials covering the basics of ROOT like Histograms, Trees, I/O, PROOF and Fitting. They are made by the ROOT team and consists of slides and a series of exercises described in corresponding TWIKI pages. ROOT tutorial at JRC-IRMM, Belgium, Feb 2014; ROOT tutorial at Gridka School, Aug 2013 (Slides, Exercises) ; ROOT 6 Analysis Workshop (GridKA 2014); ROOT Tree-I/O tutorial at Desy C++ School, Nov 2013 (Slides, Exercises) ; ROOT tutorial at La Plata (ULP), Nov 2013 . RooFit/RooStats tutorials. RooFit/RooStats tutorial for INFN School of statistics 2013 (Slides, Exercises); RooFit/RooStats tutorial for Desy School of Statistics 2015 (RooFit slides, RooStats slides, Exercises). Older but still very valuable resources. BaBar tutorials; FNAL tutorials; Minos tutorials. Preparing ROOT courses for the CERN technical training. ROOT courses proposal; Working document for the courses. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/courses.html:3725,test,tests,3725,d/courses.html,https://root.cern,https://root.cern/d/courses.html,1,['test'],['tests']
Testability,"pal Component Analysis.; Determine \(\mathbf{P}^\prime\) as before.; Determine \(\mathbf{x}^\prime\) as before.; Use the result of the fit to determine \(\mathbf{Q}^\prime\).; Transform back to \(\mathbf{P}\) from \(\mathbf{Q}^\prime\), using the result from the Principal Component Analysis. Testing the parameterization; The class also provides functionality for testing the, over the training sample, found parameterization (TMultiDimFit::Fit). This is done by passing the class a test sample of \( M_t\) tuples of the form \((\mathbf{x}_{t,j},D_{t,j}, E_{t,j})\), where \(\mathbf{x}_{t,j}\) are the independent variables, \( D_{t,j}\) the known, dependent quantity, and \( E_{t,j}\) is the square error in \( D_{t,j}\) (TMultiDimFit::AddTestRow).; The parameterization is then evaluated at every \(\mathbf{x}_t\) in the test sample, and ; \[; S_t \equiv \sum_{j=1}^{M_t} \left(D_{t,j} -; D_p\left(\mathbf{x}_{t,j}\right)\right)^2; \]. is evaluated. The relative error over the test sample ; \[; R_t = \frac{S_t}{\sum_{j=1}^{M_t} D_{t,j}^2}; \]. should not be to low or high compared to \( R\) from the training sample. Also, multiple correlation coefficient from both samples should be fairly close, otherwise one of the samples is not representative of the problem. A large difference in the reduced \( \chi^2\) over the two samples indicate an over fit, and the maximum number of terms in the parameterisation should be reduced.; It's possible to use 4 to further improve the fit, using the test sample.; Christian Holm. Bibliography. Philip R. Bevington and D. Keith Robinson. Data Reduction and Error Analysis for the Physical Sciences. McGraw-Hill, 2 edition, 1992.; R. Brun et al. Long writeup DD/75-23, CERN, 1980.; Gene H. Golub and Charles F. van Loan. Matrix Computations. John Hopkins University Press, Baltimore, 3 edition, 1996.; F. James. Minuit. Long writeup D506, CERN, 1998.; H. Wind. Function parameterization. Proceedings of the 1972 CERN Computing and Data Processing School, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiDimFit.html:16505,test,test,16505,doc/master/classTMultiDimFit.html,https://root.cern,https://root.cern/doc/master/classTMultiDimFit.html,1,['test'],['test']
Testability,"par = 0, const double *params = nullptr, unsigned int dataSize = 0, int fitType = 0);; 348 ; 349 /**; 350 Perform a fit with the previously set FCN function. Require SetFCN before; 351 */; 352 bool FitFCN();; 353 ; 354 /**; 355 Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN; 356 */; 357 bool EvalFCN();; 358 ; 359 ; 360 ; 361 /**; 362 Set the fitted function (model function) from a parametric function interface; 363 */; 364 void SetFunction(const IModelFunction & func, bool useGradient = false);; 365 ; 366 /**; 367 Set the fitted function (model function) from a vectorized parametric function interface; 368 */; 369#ifdef R__HAS_VECCORE; 370 template <class NotCompileIfScalarBackend = std::enable_if<!(std::is_same<double, ROOT::Double_v>::value)>>; 371 void SetFunction(const IModelFunction_v &func, bool useGradient = false);; 372 ; 373 template <class NotCompileIfScalarBackend = std::enable_if<!(std::is_same<double, ROOT::Double_v>::value)>>; 374 void SetFunction(const IGradModelFunction_v &func, bool useGradient = true);; 375#endif; 376 /**; 377 Set the fitted function from a parametric 1D function interface; 378 */; 379 void SetFunction(const IModel1DFunction & func, bool useGradient = false);; 380 ; 381 /**; 382 Set the fitted function (model function) from a parametric gradient function interface; 383 */; 384 void SetFunction(const IGradModelFunction & func, bool useGradient = true);; 385 /**; 386 Set the fitted function from 1D gradient parametric function interface; 387 */; 388 void SetFunction(const IGradModel1DFunction & func, bool useGradient = true);; 389 ; 390 ; 391 /**; 392 get fit result; 393 */; 394 const FitResult & Result() const {; 395 assert( fResult.get() );; 396 return *fResult;; 397 }; 398 ; 399 ; 400 /**; 401 perform an error analysis on the result using the Hessian; 402 Errors are obtained from the inverse of the Hessian matrix; 403 To be called only after fitting and when a minimizer supporting the H",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8h_source.html:16057,assert,assert,16057,doc/master/Fitter_8h_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html,1,['assert'],['assert']
Testability,"par, Double_t value); Fix the value of a parameter; The specified value will be used in a fit operation. TF1 * GetCurrent(); Static function returning the current function being processed. TH1 * GetHistogram() const; Return a pointer to the histogram used to vusualize the function. Double_t GetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Return the maximum value of the function; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx.; This way, the step size can be controlled via the SetNpx() function.; If the function is unimodal or if its extrema are far apart, setting; the fNpx to a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetMaximumX and TF1::GetX. Double_t GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Return the X value corresponding to the maximum value of the function; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx.; This way, the step size can be controlled via the SetNpx() function.; If the function is unimodal or if its extrema are far apart, setting; the fNpx to a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TF1.html:39784,log,logx,39784,root/html528/TF1.html,https://root.cern,https://root.cern/root/html528/TF1.html,12,['log'],"['log', 'logx']"
Testability,param a scalar quantity of type a; 477 \return a new mathcoreLorentzVector q = v / a same type as v; 478 */; 479 LorentzVector<CoordSystem> operator / ( const Scalar & a) const {; 480 LorentzVector<CoordSystem> tmp(*this);; 481 tmp /= a;; 482 return tmp;; 483 }; 484 ; 485 /**; 486 Negative of a LorentzVector (q = - v ); 487 \return a new LorentzVector with opposite direction and time; 488 */; 489 LorentzVector operator - () const {; 490 //LorentzVector<CoordinateType> v(*this);; 491 //v.Negate();; 492 return operator*( Scalar(-1) );; 493 }; 494 LorentzVector operator + () const {; 495 return *this;; 496 }; 497 ; 498 // ---- Relativistic Properties ----; 499 ; 500 /**; 501 Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]; 502 */; 503 Scalar Rapidity() const {; 504 // TODO - It would be good to check that E > Pz and use the Throw(); 505 // mechanism or at least load a NAN if not.; 506 // We should then move the code to a .cpp file.; 507 const Scalar ee = E();; 508 const Scalar ppz = Pz();; 509 using std::log;; 510 return Scalar(0.5) * log((ee + ppz) / (ee - ppz));; 511 }; 512 ; 513 /**; 514 Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]; 515 */; 516 Scalar ColinearRapidity() const {; 517 // TODO - It would be good to check that E > P and use the Throw(); 518 // mechanism or at least load a NAN if not.; 519 const Scalar ee = E();; 520 const Scalar pp = P();; 521 using std::log;; 522 return Scalar(0.5) * log((ee + pp) / (ee - pp));; 523 }; 524 ; 525 /**; 526 Determine if momentum-energy can represent a physical massive particle; 527 */; 528 bool isTimelike( ) const {; 529 Scalar ee = E(); Scalar pp = P(); return ee*ee > pp*pp;; 530 }; 531 ; 532 /**; 533 Determine if momentum-energy can represent a massless particle; 534 */; 535 bool isLightlike( Scalar tolerance; 536 = 100*std::numeric_limits<Scalar>::epsilon() ) const {; 537 Scalar ee = E(); Scalar pp = P(); Scalar delta = ee-pp;; 538 if ( ee==0 ) return pp==0;; 539 return delta*delta < to,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:16443,log,log,16443,doc/master/GenVector_2LorentzVector_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html,1,['log'],['log']
Testability,"parameter (not to fit); -ayInit - initial value of ay parameter; -fixAy - logical value of ay parameter, which allows to fix the parameter (not to fit). void SetTailParameters(Double_t tInitXY, Bool_t fixTxy, Double_t tInitX, Bool_t fixTx, Double_t tInitY, Bool_t fixTy, Double_t bInitX, Bool_t fixBx, Double_t bInitY, Bool_t fixBy, Double_t sInitXY, Bool_t fixSxy, Double_t sInitX, Bool_t fixSx, Double_t sInitY, Bool_t fixSy). SETTER FUNCTION. This function sets the following fitting parameters of tails of peaks; -tInitXY - initial value of txy parameter; -fixTxy - logical value of txy parameter, which allows to fix the parameter (not to fit); -tInitX - initial value of tx parameter; -fixTx - logical value of tx parameter, which allows to fix the parameter (not to fit); -tInitY - initial value of ty parameter; -fixTy - logical value of ty parameter, which allows to fix the parameter (not to fit); -bInitX - initial value of bx parameter; -fixBx - logical value of bx parameter, which allows to fix the parameter (not to fit); -bInitY - initial value of by parameter; -fixBy - logical value of by parameter, which allows to fix the parameter (not to fit); -sInitXY - initial value of sxy parameter; -fixSxy - logical value of sxy parameter, which allows to fix the parameter (not to fit); -sInitX - initial value of sx parameter; -fixSx - logical value of sx parameter, which allows to fix the parameter (not to fit); -sInitY - initial value of sy parameter; -fixSy - logical value of sy parameter, which allows to fix the parameter (not to fit). void GetPositions(Double_t* positionsX, Double_t* positionsY, Double_t* positionsX1, Double_t* positionsY1). GETTER FUNCTION. This function gets the positions of fitted 2D peaks and 1D ridges; -positionX - gets vector of x positions of 2D peaks; -positionY - gets vector of y positions of 2D peaks; -positionX1 - gets vector of x positions of 1D ridges; -positionY1 - gets vector of y positions of 1D ridges. void GetPositionErrors(Double_t* po",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrum2Fit.html:68265,log,logical,68265,root/html602/TSpectrum2Fit.html,https://root.cern,https://root.cern/root/html602/TSpectrum2Fit.html,16,['log'],['logical']
Testability,"parameter (not to fit); -ayInit - initial value of ay parameter; -fixAy - logical value of ay parameter, which allows to fix the parameter (not to fit). void SetTailParameters(Double_t tInitXY, Bool_t fixTxy, Double_t tInitX, Bool_t fixTx, Double_t tInitY, Bool_t fixTy, Double_t bInitX, Bool_t fixBx, Double_t bInitY, Bool_t fixBy, Double_t sInitXY, Bool_t fixSxy, Double_t sInitX, Bool_t fixSx, Double_t sInitY, Bool_t fixSy). SETTER FUNCTION. This function sets the following fitting parameters of tails of peaks; -tInitXY - initial value of txy parameter; -fixTxy - logical value of txy parameter, which allows to fix the parameter (not to fit); -tInitX - initial value of tx parameter; -fixTx - logical value of tx parameter, which allows to fix the parameter (not to fit); -tInitY - initial value of ty parameter; -fixTy - logical value of ty parameter, which allows to fix the parameter (not to fit); -bInitX - initial value of bx parameter; -fixBx - logical value of bx parameter, which allows to fix the parameter (not to fit); -bInitY - initial value of by parameter; -fixBy - logical value of by parameter, which allows to fix the parameter (not to fit); -sInitXY - initial value of sxy parameter; -fixSxy - logical value of sxy parameter, which allows to fix the parameter (not to fit); -sInitX - initial value of sx parameter; -fixSx - logical value of sx parameter, which allows to fix the parameter (not to fit); -sInitY - initial value of sy parameter; -fixSy - logical value of sy parameter, which allows to fix the parameter (not to fit). void GetPositions(Float_t* positionsX, Float_t* positionsY, Float_t* positionsX1, Float_t* positionsY1). GETTER FUNCTION. This function gets the positions of fitted 2D peaks and 1D ridges; -positionX - gets vector of x positions of 2D peaks; -positionY - gets vector of y positions of 2D peaks; -positionX1 - gets vector of x positions of 1D ridges; -positionY1 - gets vector of y positions of 1D ridges. void GetPositionErrors(Float_t* positio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2Fit.html:67162,log,logical,67162,root/html528/TSpectrum2Fit.html,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html,32,['log'],['logical']
Testability,"parameter constraint terms, only apply constraints to given subset of parameters; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood; GlobalObservables(const RooArgSet&) -- Define the set of normalization observables to be used for the constraint terms.; If none are specified the constrained parameters are used; GlobalObservablesTag(const char* tagName) -- Define the set of normalization observables to be used for the constraint terms by a string attribute; associated with pdf observables that match he given tagName; Verbose(Bool_t flag) -- Constrols RooFit informational messages in likelihood construction; CloneData(Bool flag) -- Use clone of dataset in NLL (default is true); Offset(Bool_t) -- Offset likelihood by initial value (so that starting value of FCN in minuit is zero). This; can improve numeric stability in simultaneously fits with components with large likelihood values. RooAbsReal* createNLL(RooAbsData& data, const RooLinkedList& cmdList); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. See RooAbsPdf::createNLL(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; comman",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsPdf.html:52832,log,log,52832,root/html534/RooAbsPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html,1,['log'],['log']
Testability,parameter(backgroud is; estimated as a0+ax*x+ay*y); �� Double_t�; fAxCalc;����������������������� //calculated value of background ax parameter; �� Double_t�; fAxErr;������������������������ //error value of background ax parameter; �� Double_t�; fAyInit;����������������������� //initial value of background ay; parameter(backgroud is estimated as a0+ax*x+ay*y); �� Double_t�; fAyCalc;����������������������� //calculated value of background ay parameter; �� Double_t� fAyErr;������������������������; error value of background ay parameter�� ; �� Bool_t��; *fFixPositionX;����������������� //[fNPeaks] array of logical values which; allow to fix appropriate x positions of 2D peaks (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixPositionY;����������������� //[fNPeaks] array of logical values which; allow to fix appropriate y positions of 2D peaks (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixPositionX1;������������ ����//[fNPeaks] array of logical values which; allow to fix appropriate x positions of 1D ridges (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixPositionY1;���������������� //[fNPeaks] array of logical values which; allow to fix appropriate y positions of 1D ridges (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixAmp;����������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 2D peaks (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixAmpX1;��������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 1D ridges in x direction (not fit).; However they are present in the estimated functional; �� Bool_t��; *fFixAmpY1;��������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 1D ridges in y direction (not fit).; However they are present in the estimated function,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2Fit.html:47769,log,logical,47769,root/html528/TSpectrum2Fit.html,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html,6,['log'],['logical']
Testability,"parameters for DNN layout)*; ; note that in case of only dense layer the input layout could be omitted but it is required when defining more; complex architectures; ; - **layer layout** string defining the layer architecture. The syntax is; - layer type (e.g. DENSE, CONV, RNN); - layer parameters (e.g. number of units); - activation function (e.g TANH, RELU,...); ; *the different layers are separated by the ``"",""`` *; ; #### 2. Define Training Strategy; ; We define here the training strategy parameters for the DNN. The parameters are separated by the ``"",""`` separator.; One can then concatenate different training strategy with different parameters. The training strategy are separated by; the ``""|""`` separator.; ; - Optimizer; - Learning rate; - Momentum (valid for SGD and RMSPROP); - Regularization and Weight Decay; - Dropout; - Max number of epochs; - Convergence steps. if the test error will not decrease after that value the training will stop; - Batch size (This value must be the same specified in the input layout); - Test Repetitions (the interval when the test error will be computed); ; ; #### 3. Define general DNN options; ; We define the general DNN options concatenating in the final string the previously defined layout and training strategy.; Note we use the ``"":""`` separator to separate the different higher level options, as in the other TMVA methods.; In addition to input layout, batch layout and training strategy we add now:; ; - Type of Loss function (e.g. CROSSENTROPY); - Weight Initizalization (e.g XAVIER, XAVIERUNIFORM, NORMAL ); - Variable Transformation; - Type of Architecture (e.g. CPU, GPU, Standard); ; We can then book the DL method using the built option string; ; ***/; ; if (useDL) {; ; bool useDLGPU = false;; #ifdef R__HAS_TMVAGPU; useDLGPU = true;; #endif; ; // Define DNN layout; TString inputLayoutString = ""InputLayout=1|1|7"";; TString batchLayoutString= ""BatchLayout=1|128|7"";; TString layoutString (""Layout=DENSE|64|TANH,DENSE|64|TANH,DENSE|6",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:64779,test,test,64779,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,2,['test'],['test']
Testability,"parsing += fClingInput + ""\n}"";; 886 gCling->ProcessLine(triggerAutoparsing);; 887 ; 888 // add pragma for optimization of the formula; 889 fClingInput = TString(""#pragma cling optimize(2)\n"") + fClingInput;; 890 ; 891 // Now that all libraries and headers are loaded, Declare() a performant version; 892 // of the same code:; 893 gCling->Declare(fClingInput);; 894 fClingInitialized = PrepareEvalMethod();; 895 if (!fClingInitialized) Error(""InputFormulaIntoCling"",""Error compiling formula expression in Cling"");; 896 }; 897}; 898 ; 899////////////////////////////////////////////////////////////////////////////////; 900/// Fill structures with default variables, constants and function shortcuts; 901 ; 902void TFormula::FillDefaults(); 903{; 904 const TString defvars[] = { ""x"",""y"",""z"",""t""};; 905 const pair<TString, Double_t> defconsts[] = {{""pi"", TMath::Pi()},; 906 {""sqrt2"", TMath::Sqrt2()},; 907 {""infinity"", TMath::Infinity()},; 908 {""e"", TMath::E()},; 909 {""ln10"", TMath::Ln10()},; 910 {""loge"", TMath::LogE()},; 911 {""c"", TMath::C()},; 912 {""g"", TMath::G()},; 913 {""h"", TMath::H()},; 914 {""k"", TMath::K()},; 915 {""sigma"", TMath::Sigma()},; 916 {""r"", TMath::R()},; 917 {""eg"", TMath::EulerGamma()},; 918 {""true"", 1},; 919 {""false"", 0}};; 920 // const pair<TString,Double_t> defconsts[] = { {""pi"",TMath::Pi()}, {""sqrt2"",TMath::Sqrt2()},; 921 // {""infinity"",TMath::Infinity()}, {""ln10"",TMath::Ln10()},; 922 // {""loge"",TMath::LogE()}, {""true"",1},{""false"",0} };; 923 const pair<TString,TString> funShortcuts[] =; 924 { {""sin"",""TMath::Sin"" },; 925 {""cos"",""TMath::Cos"" }, {""exp"",""TMath::Exp""}, {""log"",""TMath::Log""}, {""log10"",""TMath::Log10""},; 926 {""tan"",""TMath::Tan""}, {""sinh"",""TMath::SinH""}, {""cosh"",""TMath::CosH""},; 927 {""tanh"",""TMath::TanH""}, {""asin"",""TMath::ASin""}, {""acos"",""TMath::ACos""},; 928 {""atan"",""TMath::ATan""}, {""atan2"",""TMath::ATan2""}, {""sqrt"",""TMath::Sqrt""},; 929 {""ceil"",""TMath::Ceil""}, {""floor"",""TMath::Floor""}, {""pow"",""TMath::Power""},; 930 {""binomial"",""TMath::Binomial""},{""abs"",""TMa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFormula_8cxx_source.html:32923,log,loge,32923,doc/master/TFormula_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html,1,['log'],['loge']
Testability,"passed to the RooAbsData::plotOn() call. See that function for allowed options. PyROOT; The RooMCStudy::plotError() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArg of the function. . Definition at line 986 of file RooMCStudy.cxx. ◆ plotError() [2/2]. RooPlot * RooMCStudy::plotError ; (; const RooRealVar & ; param, . double ; lo, . double ; hi, . Int_t ; nbins = 100 . ). Create a RooPlot of the distribution of the fitted errors of the given parameter. ; The frame is created with a range [lo,hi] and plotted data will be binned in 'nbins' bins ; Definition at line 1213 of file RooMCStudy.cxx. ◆ plotNLL() [1/2]. RooMCStudy::plotNLL ; (; const RooCmdArg & ; arg1 = {}, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ). Plot the distribution of the -log(L) values on a newly created frame. . Optional arguments . FrameRange(double lo, double hi) Set range of frame to given specification . FrameBins(int bins) Set default number of bins of frame to given number . Frame() Pass supplied named arguments to RooAbsRealLValue::frame() function. See there for list of allowed arguments . If no frame specifications are given, the AutoRange() feature will be used to set the range. Any other named argument is passed to the RooAbsData::plotOn() call. See that function for allowed options. PyROOT; The RooMCStudy::plotNLL() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArg of the function. . Definition at line 962 of file RooMCStudy.cxx. ◆ plotNLL() [2/2]. RooPlot * RooMCStudy::plotNLL ; (; double ; lo, . double ; hi, . Int_t ; nBins = 100 . ). Create a RooPlot of the -log(L) distribution in the range lo-hi with 'nBins' bins. ; Definition at line 1199 of file RooMCStudy.cxx. ◆ plotParam() [1/2]. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMCStudy.html:30939,log,log,30939,doc/master/classRooMCStudy.html,https://root.cern,https://root.cern/doc/master/classRooMCStudy.html,1,['log'],['log']
Testability,"pa}}\). \( \gamma = 0.5772156649\dots\) is Euler's constant.; For the class VavilovAccurate, Pdf returns the Vavilov distribution as function of Landau's parameter \(\lambda_L = \lambda_V/\kappa - \ln \kappa\), which is the convention used in the CERNLIB routines, and in the tables by S.M. Seltzer and M.J. Berger: Energy loss stragglin of protons and mesons: Tabulation of the Vavilov distribution, pp 187-203 in: National Research Council (U.S.), Committee on Nuclear Science: Studies in penetration of charged particles in matter, Nat. Akad. Sci. Publication 1133, Nucl. Sci. Series Report No. 39, Washington (Nat. Akad. Sci.) 1964, 388 pp. Available from Google books; Therefore, for small values of \(\kappa < 0.01\), pdf approaches the Landau distribution.; For values \(\kappa > 10\), the Gauss approximation should be used with \(\mu\) and \(\sigma\) given by Vavilov::mean(kappa, beta2) and sqrt(Vavilov::variance(kappa, beta2).; The original Vavilov pdf is obtained by v.Pdf(lambdaV/kappa-log(kappa))/kappa.; For detailed description see B. Schorr, Programs for the Landau and the Vavilov distributions and the corresponding random numbers, Computer Phys. Comm. 7 (1974) 215-224, which has been implemented in CERNLIB (G116).; The class stores coefficients needed to calculate \(p(\lambda; \kappa, \beta^2)\) for fixed values of \(\kappa\) and \(\beta^2\). Changing these values is computationally expensive.; The parameter \(\kappa\) should be in the range \(0.01 \le \kappa \le 10\). In contrast to the CERNLIB implementation, all values of \(\kappa \ge 0.001\) may be used, but may result in slower running and/or inaccurate results.; The parameter \(\beta^2\) must be in the range \(0 \le \beta^2 \le 1\).; Two parameters which are fixed in the CERNLIB implementation may be set by the user:; epsilonPM corresponds to \(\epsilon^+ = \epsilon^-\) in Eqs. (2.1) and (2.2) of Schorr's paper. epsilonPM gives an estimate on the integral of the cumulative distribution function outside the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1VavilovAccurate.html:1978,log,log,1978,doc/master/classROOT_1_1Math_1_1VavilovAccurate.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1VavilovAccurate.html,1,['log'],['log']
Testability,"pdateViewers is true (default), the viewers using this scene; will be tagged as changed. If sceneChanged is true the; updateViewers should be true as well, unless you take care of; the viewers elsewhere or in some other way. void UpdateLogical(TObject* logid); Drop display-lists for the logical (assume TGLObject/direct rendering).; Re-calculate the bounding box (also for all physicals). void UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); Reposition/recolor physical shape. void UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). UInt_t BeginSmartRefresh(); Moves logicals that support smart-refresh to intermediate cache.; Destroys the others and returns the number of destroyed ones. void EndSmartRefresh(); Wipes logicals in refresh-cache. TGLLogicalShape * FindLogicalSmartRefresh(TObject* ID) const; Find and return logical shape identified by unqiue 'ID' in refresh-cache.; Returns 0 if not found. UInt_t SizeOfScene() const; Return memory cost of scene.; Warning: NOT CORRECT at present - doesn't correctly calculate size.; of logical shapes with dynamic internal contents. void DumpMapSizes() const; Print sizes of logical nad physical-shape maps. void RGBAFromColorIdx(Float_t* rgba, Color_t ci, Char_t transp = 0); Fill rgba color from ROOT color-index ci and transparency (0->100). Bool_t IsOutside(const TGLBoundingBox& box, const TGLPlaneSet_t& planes); Check if box is outside of all planes. TGLScene(const TGLScene& ). TGLScene& operator=(const TGLScene& ). TSceneInfo* CreateSceneInfo(TGLViewerBase* view). LogicalShapeMap_t& RefLogicalShapes(); Temporary expo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLScene.html:13508,log,logicals,13508,root/html528/TGLScene.html,https://root.cern,https://root.cern/root/html528/TGLScene.html,4,['log'],['logicals']
Testability,"pdateViewers is true (default), the viewers using this scene; will be tagged as changed. If sceneChanged is true the; updateViewers should be true as well, unless you take care of; the viewers elsewhere or in some other way. void UpdateLogical(TObject* logid); Drop display-lists for the logical (assume TGLObject/direct rendering).; Re-calculate the bounding box (also for all physicals). void UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); Reposition/recolor physical shape. void UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). UInt_t BeginSmartRefresh(); Moves logicals that support smart-refresh to intermediate cache.; Destroys the others and returns the number of destroyed ones. void EndSmartRefresh(); Wipes logicals in refresh-cache. TGLLogicalShape * FindLogicalSmartRefresh(TObject* ID) const; Find and return logical shape identified by unqiue 'ID' in refresh-cache.; Returns 0 if not found. UInt_t SizeOfScene() const; Return memory cost of scene.; Warning: NOT CORRECT at present - doesn't correctly calculate size.; of logical shapes with dynamic internal contents. void DumpMapSizes() const; Print sizes of logical nad physical-shape maps. void RGBAFromColorIdx(Float_t[4] rgba, Color_t ci, Char_t transp = 0); Fill rgba color from ROOT color-index ci and transparency (0->100). Bool_t IsOutside(const TGLBoundingBox& box, const TGLPlaneSet_t& planes); Check if box is outside of all planes. TGLScene(const TGLScene& ). TGLScene& operator=(const TGLScene& ). TSceneInfo* CreateSceneInfo(TGLViewerBase* view). LogicalShapeMap_t& RefLogicalShapes(); Temporary ex",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLScene.html:14145,log,logicals,14145,root/html602/TGLScene.html,https://root.cern,https://root.cern/root/html602/TGLScene.html,2,['log'],['logicals']
Testability,"pe = MinimizerType::fSteepest,; 905 double _learningRate = 1e-5, double _momentum = 0.3, int _repetitions = 3,; 906 bool _useMultithreading = true); 907 : Settings (name, _convergenceSteps, _batchSize, _testRepetitions, _factorWeightDecay,; 908 _regularization, _eMinimizerType, _learningRate, _momentum, _repetitions, _useMultithreading); 909 , m_ams (); 910 , m_sumOfSigWeights (0); 911 , m_sumOfBkgWeights (0); 912 , m_scaleToNumEvents (_scaleToNumEvents); 913 , m_cutValue (10.0); 914 , m_pResultPatternContainer(nullptr); 915 , m_fileNameResult (); 916 , m_fileNameNetConfig (); 917 {; 918 }; 919 ; 920 /*! \brief d'tor; 921 *; 922 *; 923 */; 924 virtual ~ClassificationSettings (); 925 {; 926 }; 927 ; 928 void startTrainCycle ();; 929 void endTrainCycle (double /*error*/);; 930 void testIteration () { if (fMonitoring) fMonitoring->ProcessEvents (); }; 931 ; 932 ; 933 /* void createHistograms () */; 934 /* { */; 935 /* std::cout << ""is hist ROC existing?"" << std::endl; */; 936 /* if (m_histROC) */; 937 /* { */; 938 /* std::cout << ""--> yes"" << std::endl; */; 939 /* fMonitoring->ProcessEvents (); */; 940 /* return; */; 941 /* } */; 942 ; 943 /* std::cout << ""create histograms"" << std::endl; */; 944 /* TCanvas* canvas = fMonitoring->GetCanvas (); */; 945 /* if (canvas) */; 946 /* { */; 947 /* std::cout << ""canvas divide"" << std::endl; */; 948 /* canvas->cd (); */; 949 /* canvas->Divide (2,2); */; 950 /* } */; 951 /* if (!m_histROC) */; 952 /* { */; 953 /* m_histROC = new TH2F (""ROC"",""ROC"", 1000, 0, 1.0, 1000, 0, 1.0); m_histROC->SetDirectory (0); */; 954 /* m_histROC->SetLineColor (kBlue); */; 955 /* } */; 956 /* if (!m_histSignificance) */; 957 /* { */; 958 /* m_histSignificance = new TH2F (""Significance"", ""Significance"", 1000, 0,1.0, 5, 0.0, 2.0); */; 959 /* m_histSignificance->SetDirectory (0); */; 960 /* m_histSignificance->SetBit (TH1::kCanRebin); */; 961 /* m_histROC->SetLineColor (kRed); */; 962 /* } */; 963 /* if (!m_histError) */; 964 /* { */; 965 /* m_histError =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:34401,test,testIteration,34401,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['test'],['testIteration']
Testability,"pe:; Double_t fcn(Double_t *x, Double_t *params). This constructor is called for functions of type C by CINT. WARNING! A function created with this constructor cannot be Cloned. TF1(const char *name,Double_t (*fcn)(Double_t *, Double_t *), Double_t xmin, Double_t xmax, Int_t npar); F1 constructor using a pointer to a real function. npar is the number of free parameters used by the function. This constructor creates a function of type C when invoked; with the normal C++ compiler. see test program test/stress.cxx (function stress1) for an example.; note the interface with an intermediate pointer. WARNING! A function created with this constructor cannot be Cloned. TF1(const char *name,Double_t (*fcn)(const Double_t *, const Double_t *), Double_t xmin, Double_t xmax, Int_t npar); F1 constructor using a pointer to real function. npar is the number of free parameters used by the function. This constructor creates a function of type C when invoked; with the normal C++ compiler. see test program test/stress.cxx (function stress1) for an example.; note the interface with an intermediate pointer. WARNING! A function created with this constructor cannot be Cloned. TF1(const char* name, ROOT::Math::ParamFunctor f, Double_t xmin = 0, Double_t xmax = 1, Int_t npar = 0); F1 constructor using the Functor class. xmin and xmax define the plotting range of the function; npar is the number of free parameters used by the function. This constructor can be used only in compiled code. WARNING! A function created with this constructor cannot be Cloned. void CreateFromFunctor(const char* name, Int_t npar); Internal Function to Create a TF1 using a Functor. Used by the template constructors. TF1& operator=(const TF1& rhs); Operator =. ~TF1(); TF1 default destructor. TF1(const TF1& f1); Constuctor. void AbsValue(Bool_t reject = kTRUE); Static function: set the fgAbsValue flag.; By default TF1::Integral uses the original function value to compute the integral; However, TF1::Moment, CentralMomen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF1.html:32877,test,test,32877,root/html602/TF1.html,https://root.cern,https://root.cern/root/html602/TF1.html,2,['test'],['test']
Testability,"pecified colormap. ;  ; virtual Bool_t PointInRegion (Int_t x, Int_t y, Region_t reg);  Returns kTRUE if the point [x, y] is contained in the region reg. ;  ; virtual Region_t PolygonRegion (Point_t *points, Int_t np, Bool_t winding);  Returns a region for the polygon defined by the points array. ;  ; virtual void PutImage (Drawable_t id, GContext_t gc, Drawable_t img, Int_t dx, Int_t dy, Int_t x, Int_t y, UInt_t w, UInt_t h);  Combines an image with a rectangle of the specified drawable. ;  ; virtual void PutPixel (Drawable_t id, Int_t x, Int_t y, ULong_t pixel);  Overwrites the pixel in the image with the specified pixel value. ;  ; virtual void QueryColor (Colormap_t cmap, ColorStruct_t &color);  Returns the current RGB value for the pixel in the ""color"" structure. ;  ; virtual void QueryPointer (Int_t &ix, Int_t &iy);  Returns the pointer position. ;  ; virtual void QueryPointer (Window_t id, Window_t &rootw, Window_t &childw, Int_t &root_x, Int_t &root_y, Int_t &win_x, Int_t &win_y, UInt_t &mask);  Returns the root window the pointer is logically on and the pointer coordinates relative to the root window's origin. ;  ; virtual void RaiseWindow (Window_t id);  Raises the specified window to the top of the stack so that no sibling window obscures it. ;  ; virtual Pixmap_t ReadGIF (Int_t x0, Int_t y0, const char *file, Window_t id=0);  If id is NULL - loads the specified gif file at position [x0,y0] in the current window. ;  ; virtual Bool_t ReadPictureDataFromFile (const char *filename, char ***ret_data);  Reads picture data from file ""filename"" and store it in ""ret_data"". ;  ; virtual void RemoveWindow (ULongptr_t qwid);  Removes the created by Qt window ""qwid"". ;  ; virtual void ReparentWindow (Window_t id, Window_t pid, Int_t x, Int_t y);  If the specified window is mapped, ReparentWindow automatically performs an UnmapWindow request on it, removes it from its current position in the hierarchy, and inserts it as the child of the specified parent. ;  ; virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualX.html:21783,log,logically,21783,doc/master/classTVirtualX.html,https://root.cern,https://root.cern/doc/master/classTVirtualX.html,1,['log'],['logically']
Testability,"pectrumFit::fChi. protected . here the fitting functions return resulting chi square ; Definition at line 29 of file TSpectrumFit.h. ◆ fFitTaylor. Int_t TSpectrumFit::fFitTaylor. protected . order of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function. ; Definition at line 27 of file TSpectrumFit.h. ◆ fFixA0. Bool_t TSpectrumFit::fFixA0. protected . logical value of a0 parameter, which allows to fix the parameter (not to fit). ; Definition at line 65 of file TSpectrumFit.h. ◆ fFixA1. Bool_t TSpectrumFit::fFixA1. protected . logical value of a1 parameter, which allows to fix the parameter (not to fit). ; Definition at line 66 of file TSpectrumFit.h. ◆ fFixA2. Bool_t TSpectrumFit::fFixA2. protected . logical value of a2 parameter, which allows to fix the parameter (not to fit). ; Definition at line 67 of file TSpectrumFit.h. ◆ fFixAmp. Bool_t* TSpectrumFit::fFixAmp. protected . [fNPeaks] array of logical values which allow to fix appropriate amplitudes (not fit). However they are present in the estimated functional ; Definition at line 60 of file TSpectrumFit.h. ◆ fFixB. Bool_t TSpectrumFit::fFixB. protected . logical value of b parameter, which allows to fix the parameter (not to fit). ; Definition at line 63 of file TSpectrumFit.h. ◆ fFixPosition. Bool_t* TSpectrumFit::fFixPosition. protected . [fNPeaks] array of logical values which allow to fix appropriate positions (not fit). However they are present in the estimated functional ; Definition at line 59 of file TSpectrumFit.h. ◆ fFixS. Bool_t TSpectrumFit::fFixS. protected . logical value of s parameter, which allows to fix the parameter (not to fit). ; Definition at line 64 of file TSpectrumFit.h. ◆ fFixSigma. Bool_t TSpectrumFit::fFixSigma. protected . logical value of sigma parameter, which allows to fix the parameter (not to fit). ; Definition at line 61 of file TSpectrumFit.h. ◆ fFixT. Bool_t TSpectrumFit::fFixT. protected . logical value of t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrumFit.html:53541,log,logical,53541,doc/master/classTSpectrumFit.html,https://root.cern,https://root.cern/doc/master/classTSpectrumFit.html,1,['log'],['logical']
Testability,"pedName, std::ostream &output);  Write down the sources. ;  ; void WriteReadRawRuleFunc (SchemaRuleMap_t &rule, int index, std::string &mappedName, MembersTypeMap_t &members, std::ostream &output);  Write the conversion function for ReadRaw rule, the function name is being written to rule[""funcname""]. ;  ; void WriteReadRuleFunc (SchemaRuleMap_t &rule, int index, std::string &mappedName, MembersTypeMap_t &members, std::ostream &output);  Write the conversion function for Read rule, the function name is being written to rule[""funcname""]. ;  ; void WriteSchemaList (std::list< SchemaRuleMap_t > &rules, const std::string &listName, std::ostream &output);  Write schema rules. ;  . Variables; R__EXTERN TVirtualRWMutex * gCoreMutex = nullptr;  ; R__EXTERN SchemaRuleClassMap_t gReadRawRules;  ; R__EXTERN SchemaRuleClassMap_t gReadRules;  ; struct ROOT::RQt5CreatorReg newRQt5CreatorReg;  ; struct ROOT::RQt6CreatorReg newRQt6CreatorReg;  . Detailed Description; This file contains a specialised ROOT message handler to test for diagnostic in unit tests. ; Class RooRealSumFunc implements a PDF constructed from a sum of functions:; Namespace for new ROOT classes and functions.; VSD Structures.; tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7; AuthorStephan Hageboeck steph.nosp@m.an.h.nosp@m.agebo.nosp@m.eck@.nosp@m.cern..nosp@m.ch; Sum(i=1,n-1) coef_i * func_i(x) + [ 1 - (Sum(i=1,n-1) coef_i ] * func_n(x); pdf(x) = ------------------------------------------------------------------------------; Sum(i=1,n-1) coef_i * Int(func_i)dx + [ 1 - (Sum(i=1,n-1) coef_i ] * Int(func_n)dx; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; where coef_i and func_i are RooAbsReal objects, and x is the collection of dependents. In the present version coef_i may not depend on x, but this limitation may be removed in the future. Difference between RooAddPdf / RooRe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v630/namespaceROOT.html:19216,test,test,19216,doc/v630/namespaceROOT.html,https://root.cern,https://root.cern/doc/v630/namespaceROOT.html,2,['test'],"['test', 'tests']"
Testability,"pedef void ( * GSLFdfPointer ) ( double, void *, double *, double *);; 47 ; 48 ; 49/**; 50 Wrapper class to the gsl_function C structure.; 51 This class to fill the GSL C structure gsl_function with; 52 the C++ function objcet.; 53 Use the class ROOT::Math::GSLFunctionAdapter to adapt the; 54 C++ function object to the right signature (function pointer type); 55 requested by GSL; 56*/; 57class GSLFunctionWrapper {; 58 ; 59public:; 60 ; 61 GSLFunctionWrapper(); 62 {; 63 fFunc.function = nullptr;; 64 fFunc.params = nullptr;; 65 }; 66 ; 67 /// set in the GSL C struct the pointer to the function evaluation; 68 void SetFuncPointer( GSLFuncPointer f) { fFunc.function = f; }; 69 ; 70 /// set in the GSL C struct the extra-object pointer; 71 void SetParams ( void * p) { fFunc.params = p; }; 72 ; 73 /// fill the GSL C struct from a generic C++ callable object; 74 /// implementing operator(); 75 template<class FuncType>; 76 void SetFunction(const FuncType &f) {; 77 const void * p = &f;; 78 assert (p != nullptr);; 79 SetFuncPointer(&GSLFunctionAdapter<FuncType >::F);; 80 SetParams(const_cast<void *>(p));; 81 }; 82 ; 83 gsl_function * GetFunc() { return &fFunc; }; 84 ; 85 GSLFuncPointer FunctionPtr() { return fFunc.function; }; 86 ; 87 // evaluate the function; 88 double operator() (double x) { return GSL_FN_EVAL(&fFunc, x); }; 89 ; 90 /// check if function is valid (has been set); 91 bool IsValid() {; 92 return (fFunc.function != nullptr) ? true : false;; 93 }; 94 ; 95private:; 96 gsl_function fFunc;; 97 ; 98 ; 99};; 100 ; 101 ; 102 /**; 103 class to wrap a gsl_function_fdf (with derivatives); 104 */; 105 class GSLFunctionDerivWrapper {; 106 ; 107 public:; 108 ; 109 GSLFunctionDerivWrapper(); 110 {; 111 fFunc.f = nullptr;; 112 fFunc.df = nullptr;; 113 fFunc.fdf = nullptr;; 114 fFunc.params = nullptr;; 115 }; 116 ; 117 ; 118 void SetFuncPointer( GSLFuncPointer f) { fFunc.f = f; }; 119 void SetDerivPointer( GSLFuncPointer f) { fFunc.df = f; }; 120 void SetFdfPointer( GSLFdfPointe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GSLFunctionWrapper_8h_source.html:2797,assert,assert,2797,doc/master/GSLFunctionWrapper_8h_source.html,https://root.cern,https://root.cern/doc/master/GSLFunctionWrapper_8h_source.html,1,['assert'],['assert']
Testability,per.h;  GSLMultiFit.h;  GSLMultiFitFunctionAdapter.h;  GSLMultiFitFunctionWrapper.h;  GSLMultiMinFunctionAdapter.h;  GSLMultiMinFunctionWrapper.h;  GSLMultiMinimizer.h;  GSLMultiRootFinder.cxx;  GSLMultiRootFunctionAdapter.h;  GSLMultiRootFunctionWrapper.h;  GSLMultiRootSolver.h;  GSLNLSMinimizer.cxx;  GSLQRngWrapper.h;  GSLQuasiRandom.cxx;  GSLRndmEngines.cxx;  GSLRngWrapper.h;  GSLRootFdFSolver.h;  GSLRootFinder.cxx;  GSLRootFinderDeriv.cxx;  GSLRootFSolver.h;  GSLRootHelper.cxx;  GSLSimAnMinimizer.cxx;  GSLSimAnnealing.cxx;  Interpolator.cxx;  KelvinFunctions.cxx;  MCParameters.cxx;  MultiNumGradFunction.cxx;  PdfFuncMathMore.cxx;  Polynomial.cxx;  QuantFuncMathMore.cxx;  RootFinderAlgorithms.cxx;  SpecFuncMathMore.cxx;  Vavilov.cxx;  VavilovAccurate.cxx;  VavilovAccurateCdf.cxx;  VavilovAccuratePdf.cxx;  VavilovAccurateQuantile.cxx;  VavilovFast.cxx;  zsolve_cubic.cxx;  ► test;  piRandom.C;  pirndm.C;  simanTSP.cxx;  testChebyshev.cxx;  testDerivation.cxx;  testFunctor.cxx;  testGSLIntegration.cxx;  testGSLRootFinder.cxx;  testInterpolation.cxx;  testMCIntegration.cxx;  testMinimization1D.cxx;  testMultiRootFinder.cxx;  testPermute.cxx;  testQuasiRandom.cxx;  testRandom.cxx;  testRandomDist.cxx;  testSpecFunc.cxx;  testStatFunc.cxx;  testVavilov.cxx;  UnuRanDist.h;  VavilovTest.cxx;  VavilovTest.h;  ► matrix;  ► inc;  LinkDef.h;  TDecompBase.h;  TDecompBK.h;  TDecompChol.h;  TDecompLU.h;  TDecompQRH.h;  TDecompSparse.h;  TDecompSVD.h;  TMatrix.h;  TMatrixD.h;  TMatrixDBase.h;  TMatrixDBasefwd.h;  TMatrixDEigen.h;  TMatrixDfwd.h;  TMatrixDLazy.h;  TMatrixDSparse.h;  TMatrixDSparsefwd.h;  TMatrixDSym.h;  TMatrixDSymEigen.h;  TMatrixDSymfwd.h;  TMatrixDUtils.h;  TMatrixDUtilsfwd.h;  TMatrixF.h;  TMatrixFBase.h;  TMatrixFBasefwd.h;  TMatrixFfwd.h;  TMatrixFLazy.h;  TMatrixFSparse.h;  TMatrixFSparsefwd.h;  TMatrixFSym.h;  TMatrixFSymfwd.h;  TMatrixFUtils.h;  TMatrixFUtilsfwd.h;  TMatrixT.h;  TMatrixTBase.h;  TMatrixTCramerInv.h;  TMatrixTLazy.h;  TMatrixTSparse.h;  TM,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/files.html:48839,test,testGSLIntegration,48839,root/html606/files.html,https://root.cern,https://root.cern/root/html606/files.html,1,['test'],['testGSLIntegration']
Testability,"perftree.root"", . Bool_t ; withWrks = kFALSE . ). Enable/Disable saving of the performance tree. ; Definition at line 12624 of file TProof.cxx. ◆ SetPlayer(). void TProof::SetPlayer ; (; TVirtualProofPlayer * ; player). protected . Set a new PROOF player. ; Definition at line 10199 of file TProof.cxx. ◆ SetPrintProgress(). void TProof::SetPrintProgress ; (; PrintProgress_t ; pp). inline . Definition at line 1046 of file TProof.h. ◆ SetProgressDialog(). void TProof::SetProgressDialog ; (; Bool_t ; on = kTRUE). Enable/Disable the graphic progress dialog. ; By default the dialog is enabled ; Definition at line 12509 of file TProof.cxx. ◆ SetQueryMode(). void TProof::SetQueryMode ; (; EQueryMode ; mode). Change query running mode to the one specified by 'mode'. ; Definition at line 6107 of file TProof.cxx. ◆ SetRealTimeLog(). void TProof::SetRealTimeLog ; (; Bool_t ; on = kTRUE). Switch ON/OFF the real-time logging facility. ; When this option is ON, log messages from processing are sent back as they come, instead of being sent back at the end in one go. This may help debugging or monitoring in some cases, but, depending on the amount of log, it may have significant consequencies on the load over the network, so it must be used with care. ; Definition at line 7096 of file TProof.cxx. ◆ SetRunStatus(). void TProof::SetRunStatus ; (; ERunStatus ; rst). inlineprivate . Definition at line 672 of file TProof.h. ◆ SetupWorkersEnv(). void TProof::SetupWorkersEnv ; (; TList * ; wrks, . Bool_t ; increasingpool = kFALSE . ). protected . Set up packages, loaded macros, include and lib paths ... ; Definition at line 1528 of file TProof.cxx. ◆ ShowCache(). void TProof::ShowCache ; (; Bool_t ; all = kFALSE). virtual . List contents of file cache. ; If all is true show all caches also on slaves. If everything is ok all caches are to be the same. ; Reimplemented in TProofLite.; Definition at line 7691 of file TProof.cxx. ◆ ShowData(). void TProof::ShowData ; (; ). virtual . List conten",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:147134,log,log,147134,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['log'],['log']
Testability,"perimental.Distributed.Dask.RDataFrame; 725 ; 726# In a Python script the Dask client needs to be initalized in a context; 727# Jupyter notebooks / Python session don't need this; 728if __name__ == ""__main__"":; 729 # With an already setup cluster that exposes a Dask scheduler endpoint; 730 client = Client(""dask_scheduler.domain.com:8786""); 731 ; 732 # The Dask RDataFrame constructor accepts the Dask Client object as an optional argument; 733 df = RDataFrame(""mytree"",""myfile.root"", daskclient=client); 734 # Proceed as usual; 735 df.Define(""x"",""someoperation"").Histo1D((""name"", ""title"", 10, 0, 10), ""x""); 736~~~; 737 ; 738If an instance of [distributed.Client](http://distributed.dask.org/en/stable/api.html#distributed.Client) is not; 739provided to the RDataFrame object, it will be created for you and it will run the computations in the local machine; 740using all cores available.; 741 ; 742### Choosing the number of distributed tasks; 743 ; 744A distributed RDataFrame has internal logic to define in how many chunks the input dataset will be split before sending; 745tasks to the distributed backend. Each task reads and processes one of said chunks. The logic is backend-dependent, but; 746generically tries to infer how many cores are available in the cluster through the connection object. The number of; 747tasks will be equal to the inferred number of cores. There are cases where the connection object of the chosen backend; 748doesn't have information about the actual resources of the cluster. An example of this is when using Dask to connect to; 749a batch system. The client object created at the beginning of the application does not automatically know how many cores; 750will be available during distributed execution, since the jobs are submitted to the batch system after the creation of; 751the connection. In such cases, the logic is to default to process the whole dataset in 2 tasks.; 752 ; 753The number of tasks submitted for distributed execution can be also set progr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:42846,log,logic,42846,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['log'],['logic']
Testability,"perimental.Distributed.Dask.RDataFrame; 765 ; 766# In a Python script the Dask client needs to be initalized in a context; 767# Jupyter notebooks / Python session don't need this; 768if __name__ == ""__main__"":; 769 # With an already setup cluster that exposes a Dask scheduler endpoint; 770 client = Client(""dask_scheduler.domain.com:8786""); 771 ; 772 # The Dask RDataFrame constructor accepts the Dask Client object as an optional argument; 773 df = RDataFrame(""mytree"",""myfile.root"", daskclient=client); 774 # Proceed as usual; 775 df.Define(""x"",""someoperation"").Histo1D((""name"", ""title"", 10, 0, 10), ""x""); 776~~~; 777 ; 778If an instance of [distributed.Client](http://distributed.dask.org/en/stable/api.html#distributed.Client) is not; 779provided to the RDataFrame object, it will be created for you and it will run the computations in the local machine; 780using all cores available.; 781 ; 782### Choosing the number of distributed tasks; 783 ; 784A distributed RDataFrame has internal logic to define in how many chunks the input dataset will be split before sending; 785tasks to the distributed backend. Each task reads and processes one of said chunks. The logic is backend-dependent, but; 786generically tries to infer how many cores are available in the cluster through the connection object. The number of; 787tasks will be equal to the inferred number of cores. There are cases where the connection object of the chosen backend; 788doesn't have information about the actual resources of the cluster. An example of this is when using Dask to connect to; 789a batch system. The client object created at the beginning of the application does not automatically know how many cores; 790will be available during distributed execution, since the jobs are submitted to the batch system after the creation of; 791the connection. In such cases, the logic is to default to process the whole dataset in 2 tasks.; 792 ; 793The number of tasks submitted for distributed execution can be also set progr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:44486,log,logic,44486,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['log'],['logic']
Testability,perimpl.h;  intrinsics.h;  limits.h;  macros.h;  mask.h;  math.h;  shuffle.h;  sorthelper.h;  types.h;  undomacros.h;  vector.h;  vectorhelper.h;  writemaskedvector.h;  ► common;  aliasingentryhelper.h;  bitscanintrinsics.h;  deinterleave.h;  exponential.h;  fix_clang_emmintrin.h;  iif.h;  interleavedmemory.h;  logarithm.h;  macros.h;  memory.h;  memorybase.h;  memoryfwd.h;  operand.h;  operators.h;  storage.h;  support.h;  trigonometric.h;  types.h;  undomacros.h;  vectortuple.h;  windows_fix_intrin.h;  ► internal;  namespace.h;  ► scalar;  helperimpl.h;  limits.h;  macros.h;  mask.h;  math.h;  types.h;  undomacros.h;  vector.h;  writemaskedvector.h;  ► sse;  casts.h;  const.h;  const_data.h;  debug.h;  helperimpl.h;  intrinsics.h;  limits.h;  macros.h;  mask.h;  math.h;  shuffle.h;  types.h;  undomacros.h;  vector.h;  vectorhelper.h;  cpuid.h;  global.h;  support.h;  vector.h;  version.h;  ► src;  avx_sorthelper.cpp;  const.cpp;  cpuid.cpp;  support.cpp;  trigonometric.cpp;  ► tests;  arithmetics.cpp;  casts.cpp;  const.h;  convert-sincos-reference.cpp;  deinterleave.cpp;  expandandmerge.cpp;  gather.cpp;  implicit_type_conversion.cpp;  implicit_type_conversion_failures.cpp;  linkTest0.cpp;  linkTest1.cpp;  linkTestLib0.cpp;  linkTestLib1.cpp;  linkTestLib2.cpp;  linkTestLib3.cpp;  load.cpp;  mask.cpp;  math.cpp;  memory.cpp;  scalaraccess.cpp;  scatter.cpp;  sse_blend.cpp;  stlcontainer.cpp;  store.cpp;  supportfunctions.cpp;  swizzles.cpp;  ulp.h;  unittest.h;  utils.cpp;  vectormemoryhelper.h;  makeTest.py;  ► vdt;  ► include;  ► vdt;  asin.h;  atan.h;  atan2.h;  cos.h;  exp.h;  inv.h;  log.h;  sin.h;  sincos.h;  sqrt.h;  tan.h;  vdtcore_common.h;  vdtMath.h;  ► tests;  stressVdt.cxx;  ► misc;  ► memstat;  ► inc;  LinkDef.h;  TMemStat.h;  TMemStatBacktrace.h;  TMemStatDef.h;  TMemStatHelpers.h;  TMemStatHook.h;  TMemStatMng.h;  ► src;  TMemStat.cxx;  TMemStatBacktrace.cxx;  TMemStatHelpers.cxx;  TMemStatHook.cxx;  TMemStatMng.cxx;  ► test;  leak_test.C;  run.C;,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/files.html:59149,test,tests,59149,root/html606/files.html,https://root.cern,https://root.cern/root/html606/files.html,1,['test'],['tests']
Testability,"pes::EMVA method) const; TMVA::Types::EMVAGetMethodType(const TString& method) const; static TMVA::Types&Instance(); TMVA::Types&operator=(const TMVA::Types&); TMVA::TypesTypes(const TMVA::Types&). private:. TMVA::MsgLogger&Log() const; TMVA::TypesTypes(). Data Members; public:. enum EMVA { kVariable; kCuts; kLikelihood; kPDERS; kHMatrix; kFisher; kKNN; kCFMlpANN; kTMlpANN; kBDT; kDT; kRuleFit; kSVM; kMLP; kBayesClassifier; kFDA; kCommittee; kBoost; kPDEFoam; kLD; kPlugins; kCategory; kMaxMethod; };; enum EVariableTransform { kIdentity; kDecorrelated; kNormalized; kPCA; kGaussDecorr; kGauss; kUniform; kMaxVariableTransform; };; enum EAnalysisType { kClassification; kRegression; kMulticlass; kNoAnalysisType; kMaxAnalysisType; };; enum ESBType { kSignal; kBackground; kSBBoth; kMaxSBType; kTrueType; };; enum ETreeType { kTraining; kTesting; kMaxTreeType; kValidation; kTrainingOriginal; };; enum EBoostStage { kBoostProcBegin; kBeforeTraining; kBeforeBoosting; kAfterBoosting; kBoostValidation; kBoostProcEnd; };. private:. TMVA::MsgLogger*fLoggermessage logger; map<TString,TMVA::Types::EMVA>fStr2typetypes-to-text map; static TMVA::Types*fgTypesPtr. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Types(); constructor. ~Types(); destructor. TMVA::Types& Instance(); the the single instance of ""Types"" if existin already, or create it (Signleton). void DestroyInstance(); ""destructor"" of the single instance. Bool_t AddTypeMapping(TMVA::Types::EMVA method, const TString& methodname). TString GetMethodName(TMVA::Types::EMVA method) const. Types::EMVA GetMethodType(const TString& method) const. Types(). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: Types.h 37399 2010-12-08 15:22:07Z evt $ » Last generated: 2010-12-08 16:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__Types.html:1515,log,logger,1515,root/html528/TMVA__Types.html,https://root.cern,https://root.cern/root/html528/TMVA__Types.html,1,['log'],['logger']
Testability,ph.cxx;  TGraph2D.cxx;  TGraph2DErrors.cxx;  TGraphAsymmErrors.cxx;  TGraphBentErrors.cxx;  TGraphDelaunay.cxx;  TGraphDelaunay2D.cxx;  TGraphErrors.cxx;  TGraphSmooth.cxx;  TGraphTime.cxx;  TH1.cxx;  TH1K.cxx;  TH1Merger.cxx;  TH1Merger.h;  TH2.cxx;  TH2Poly.cxx;  TH3.cxx;  THLimitsFinder.cxx;  THn.cxx;  THnBase.cxx;  THnChain.cxx;  THnSparse.cxx;  THStack.cxx;  TKDE.cxx;  TLimit.cxx;  TLimitDataSource.cxx;  TMultiDimFit.cxx;  TMultiGraph.cxx;  TPolyMarker.cxx;  TPrincipal.cxx;  TProfile.cxx;  TProfile2D.cxx;  TProfile2Poly.cxx;  TProfile3D.cxx;  TProfileHelper.h;  TSpline.cxx;  TSVDUnfold.cxx;  TVirtualFitter.cxx;  TVirtualGraphPainter.cxx;  TVirtualHistPainter.cxx;  WrappedTF1.cxx;  ► test;  test_tprofile2poly.cxx;  ► v7;  ► inc;  ► ROOT;  TAxis.hxx;  THist.hxx;  THistBinIter.hxx;  THistBufferedFill.hxx;  THistConcurrentFill.hxx;  THistData.hxx;  THistDrawable.hxx;  THistDrawOptions.hxx;  THistImpl.hxx;  THistUtils.hxx;  THistView.hxx;  ► src;  TAxis.cxx;  THistDrawable.cxx;  ► test;  speedtest.cxx;  ► histpainter;  ► inc;  Hoption.h;  Hparam.h;  TGraph2DPainter.h;  TGraphPainter.h;  THistPainter.h;  TLego.h;  TPainter3dAlgorithms.h;  TPaletteAxis.h;  ► src;  TGraph2DPainter.cxx;  TGraphPainter.cxx;  THistPainter.cxx;  TPainter3dAlgorithms.cxx;  TPaletteAxis.cxx;  ► v7;  ► src;  THistPainter.cxx;  ► spectrum;  ► inc;  TSpectrum.h;  TSpectrum2.h;  TSpectrum2Fit.h;  TSpectrum2Transform.h;  TSpectrum3.h;  TSpectrumFit.h;  TSpectrumTransform.h;  ► src;  TSpectrum.cxx;  TSpectrum2.cxx;  TSpectrum2Fit.cxx;  TSpectrum2Transform.cxx;  TSpectrum3.cxx;  TSpectrumFit.cxx;  TSpectrumTransform.cxx;  ► spectrumpainter;  ► inc;  TSpectrum2Painter.h;  ► src;  TSpectrum2Painter.cxx;  ► unfold;  ► inc;  TUnfold.h;  TUnfoldBinning.h;  TUnfoldBinningXML.h;  TUnfoldDensity.h;  TUnfoldSys.h;  ► src;  TUnfold.cxx;  TUnfoldBinning.cxx;  TUnfoldBinningXML.cxx;  TUnfoldDensity.cxx;  TUnfoldSys.cxx;  ► html;  ► doc;  ► macros;  testmacro.C;  ► inc;  TClassDocOutput.h;  TDocDirective.h;  TDo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:34984,test,test,34984,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['test'],['test']
Testability,"ph2D::GetXaxisTAxis * GetXaxis() constGet x axis of the graph.Definition TGraph2D.cxx:885; TGraph2D::GetZDouble_t * GetZ() constDefinition TGraph2D.h:125; TGraph2D::SetNpxvoid SetNpx(Int_t npx=40)Sets the number of bins along X used to draw the function.Definition TGraph2D.cxx:1669; TGraphDelaunay2DTGraphDelaunay2D generates a Delaunay triangulation of a TGraph2D.Definition TGraphDelaunay2D.h:32; TGraphDelaunay2D::Classstatic TClass * Class(); TGraphDelaunay2D::SetMarginBinsContentvoid SetMarginBinsContent(Double_t z=0.)Definition TGraphDelaunay2D.h:63; TGraphDelaunayTGraphDelaunay generates a Delaunay triangulation of a TGraph2D.Definition TGraphDelaunay.h:30; TGraphDelaunay::Classstatic TClass * Class(); TGraphDelaunay::SetMarginBinsContentvoid SetMarginBinsContent(Double_t z=0.)Sets the histogram bin height for points lying outside the convex hull ie: the bins in the margin.Definition TGraphDelaunay.cxx:943; TGraphDelaunay::SetMaxItervoid SetMaxIter(Int_t n=100000)Defines the number of triangles tested for a Delaunay triangle (number of iterations) before abandoni...Definition TGraphDelaunay.cxx:932; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideCompute distance from point px,py to a line.Definition TH1.cxx:2823; TH1::SetTitlevoid SetTitle(const char *title) overrideChange/set the title.Definition TH1.cxx:6718; TH1::kNoStats@ kNoStatsDon't draw stats box.Definition TH1.h:165; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::GetPainterTVirtualHistPainter * GetPainter(Option_t *option="""")Return pointer to painter.Definition TH1.cxx:4511; TH1::GetMaximumvirtual Double_t GetMaximum(Double_t maxval=FLT_MAX) constReturn maximum value smaller than maxval of bins in the range, unless the value has been overridden ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph2D_8cxx_source.html:75239,test,tested,75239,doc/master/TGraph2D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html,1,['test'],['tested']
Testability,"phA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::Drawvoid Draw(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:831; TGraph::GetXaxisTAxis * GetXaxis() constGet x axis of the graph.Definition TGraph.cxx:1566; TGraph::GetYaxisTAxis * GetYaxis() constGet y axis of the graph.Definition TGraph.cxx:1575; TPadThe most important graphics class in the ROOT system.Definition TPad.h:28; TPad::SetGridxvoid SetGridx(Int_t value=1) overrideDefinition TPad.h:336; TPad::SetLogyvoid SetLogy(Int_t value=1) overrideSet Lin/Log scale for Y.Definition TPad.cxx:6100; TPad::SetGridyvoid SetGridy(Int_t value=1) overrideDefinition TPad.h:337; TPad::cdTVirtualPad * cd(Int_t subpadnumber=0) overrideSet Current pad.Definition TPad.cxx:693; TPad::Drawvoid Draw(Option_t *option="""") overrideDraw Pad in Current pad (re-parent pad if necessary).Definition TPad.cxx:1364; TPad::SetLogxvoid SetLogx(Int_t value=1) overrideSet Lin/Log scale for X.Definition TPad.cxx:6086; TPaveLabelA Pave (see TPave) with a text centered in the Pave.Definition TPaveLabel.h:20; TPaveLabel::Drawvoid Draw(Option_t *option="""") overrideDraw this pavelabel with its current attributes.Definition TPaveLabel.cxx:88; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; TPaveText::AddTextvirtual TText * AddText(Double_t x1, Double_t y1, const char *label)Add a new Text line to this pavetext at given coordinates.Definition TPaveText.cxx:191; TPaveText::Drawvoid Draw(Option_t *option="""") overrideDraw this pavetext with its current attributes.Definition TPaveText.cxx:242; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; f1TF1 * f1Definition legend1.C:11; AuthorOlivier Couet ; Definition in file logscales.C. tutorialshistlogscales.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/logscales_8C.html:7229,log,logscales,7229,doc/master/logscales_8C.html,https://root.cern,https://root.cern/doc/master/logscales_8C.html,1,['log'],['logscales']
Testability,"phaOptimal ;  ; Double_t * fAmpCalc;  [fNPeaks] array of calculated values of fitted amplitudes, output parameters ;  ; Double_t * fAmpErr;  [fNPeaks] array of amplitude errors ;  ; Double_t * fAmpInit;  [fNPeaks] array of initial values of peaks amplitudes, input parameters ;  ; Double_t * fArea;  [fNPeaks] array of calculated areas of peaks ;  ; Double_t * fAreaErr;  [fNPeaks] array of errors of peak areas ;  ; Double_t fBCalc;  calculated value of b parameter ;  ; Double_t fBErr;  error value of b parameter ;  ; Double_t fBInit;  initial value of b parameter (slope), for details see html manual and references ;  ; Double_t fChi;  here the fitting functions return resulting chi square ;  ; Int_t fFitTaylor;  order of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function. ;  ; Bool_t fFixA0;  logical value of a0 parameter, which allows to fix the parameter (not to fit). ;  ; Bool_t fFixA1;  logical value of a1 parameter, which allows to fix the parameter (not to fit). ;  ; Bool_t fFixA2;  logical value of a2 parameter, which allows to fix the parameter (not to fit). ;  ; Bool_t * fFixAmp;  [fNPeaks] array of logical values which allow to fix appropriate amplitudes (not fit). However they are present in the estimated functional ;  ; Bool_t fFixB;  logical value of b parameter, which allows to fix the parameter (not to fit). ;  ; Bool_t * fFixPosition;  [fNPeaks] array of logical values which allow to fix appropriate positions (not fit). However they are present in the estimated functional ;  ; Bool_t fFixS;  logical value of s parameter, which allows to fix the parameter (not to fit). ;  ; Bool_t fFixSigma;  logical value of sigma parameter, which allows to fix the parameter (not to fit). ;  ; Bool_t fFixT;  logical value of t parameter, which allows to fix the parameter (not to fit). ;  ; Int_t fNPeaks;  number of peaks present in fit, input parameter, it should be > 0 ;  ; Int_t fNumberIterations; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrumFit.html:19448,log,logical,19448,doc/master/classTSpectrumFit.html,https://root.cern,https://root.cern/doc/master/classTSpectrumFit.html,1,['log'],['logical']
Testability,"pha_optim; // optimization of convergence coefficients, possible values; // FIT2_ALPHA_HALVING, FIT2_ALPHA_OPTIMAL; int power; // possible values FIT21_FIT_POWER2,4,6,8,10,12; int fit_taylor; // order of Taylor expansion, possible values; // FIT2_TAYLOR_ORDER_FIRST,; // FIT2_TAYLOR_ORDER_SECOND; double position_init_x[MAX_NUMBER_OF_PEAKS2]; // initial values of x; // positions of 2D peaks, input parameters; double position_calc_x[MAX_NUMBER_OF_PEAKS2]; // calculated values; // of fitted x positions of 2D peaks, output parameters; double position_err_x[MAX_NUMBER_OF_PEAKS2]; // x position errors of 2D peaks; bool fix_position_x[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate; // x positions of 2D peaks (not fit).; // However they are present in the estimated functional; double position_init_y[MAX_NUMBER_OF_PEAKS2]; // initial values of y; // positions of 2D peaks, input parameters; double position_calc_y[MAX_NUMBER_OF_PEAKS2]; // calculated values; // of fitted y positions of 2D peaks, output parameters; double position_err_y[MAX_NUMBER_OF_PEAKS2]; // y position errors of 2D peaks; bool fix_position_y[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate; // y positions of 2D peaks (not fit).; // However they are present in the estimated functional; double position_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of x; // positions of 1D ridges, input parameters; double position_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of; // fitted x positions of 1D ridges, output parameters; double position_err_x1[MAX_NUMBER_OF_PEAKS2]; // x position errors of 1D ridges; bool fix_position_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate; // x positions of 1D ridges (not fit).; // However they are present in the estimated functional; double position_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of y; // positions of 1D ridges, input parameters; double position_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calcu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/spectrum/Spectrum.html:47482,log,logical,47482,root/html534/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html,1,['log'],['logical']
Testability,"pies(); Double_tGetSpread() const; virtual Bool_tHasConverged(Int_t steps = 10, Double_t ratio = 0.1); voidInit(); virtual TClass*IsA() const; virtual Double_tNewFitness(Double_t oldValue, Double_t newValue); voidSetMakeCopies(Bool_t s); voidSetSpread(Double_t s); virtual voidShowMembers(TMemberInspector& insp); virtual Double_tSpreadControl(Int_t steps, Int_t ofSteps, Double_t factor); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. TMVA::MsgLogger&Log() const. Data Members; public:. Int_tfConvCounterconverging? ... keeps track of the number of improvements. protected:. Double_tfBestFitness; Double_tfConvValuekeeps track of the quantity of improvement; Bool_tfFirstTimeif true its the first time, so no evolution yet; TMVA::IFitterTarget&fFitterTargetthe fitter target; Double_tfLastResultremembers the last obtained result (for internal use); TMVA::MsgLogger*fLoggermessage logger; Bool_tfMakeCopiesif true, the population will make copies of the first individuals; Bool_tfMirrornew values for mutation are mirror-mapped if outside of constraints; TMVA::GeneticPopulationfPopulationcontains and controls the ""individual""; Int_tfPopulationSizethe size of the population; const vector<TMVA::Interval*>&fRangesparameter ranges; Double_tfSpreadregulates the spread of the value change at mutation (sigma); deque<Int_t>fSuccessListto adjust the stepSize . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GeneticAlgorithm(TMVA::IFitterTarget& target, Int_t populationSize, const vector<TMVA::Interval*>& ranges, UInt_t seed = 0); Constructor; Parameters:; int populationSize : defines the number of ""Individuals"" which are created and tested; within one Generation (Iteration of the Evolution); vector<TMVA::Interval*> ranges : Interval holds the information of an interval, where the GetMin; gets the low and GetMax gets the high constraint of the variable; the size of ""ranges"" is the number of coefficients which are op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__GeneticAlgorithm.html:1688,log,logger,1688,root/html528/TMVA__GeneticAlgorithm.html,https://root.cern,https://root.cern/root/html528/TMVA__GeneticAlgorithm.html,3,['log'],['logger']
Testability,"ping window, the order of the clipping; filter, to include smoothing, to set width of smoothing window and to include; the estimation of Compton edges. On successful completion it returns 0. On; error it returns pointer to the string describing error.; Parameters:. spectrum: pointer to the vector of source spectrum; ssize: length of the spectrum vector; numberIterations: maximal width of clipping window,; direction: direction of change of clipping window.; Possible values: kBackIncreasingWindow, kBackDecreasingWindow; filterOrder: order of clipping filter.; Possible values: kBackOrder2, kBackOrder4, kBackOrder6, kBackOrder8; smoothing: logical variable whether the smoothing operation in the; estimation of background will be included.; Possible values: kFALSE, kTRUE; smoothWindow: width of smoothing window.; Possible values: kBackSmoothing3, kBackSmoothing5, kBackSmoothing7,; kBackSmoothing9, kBackSmoothing11, kBackSmoothing13, kBackSmoothing15.; compton: logical variable whether the estimation of Compton edge will be; included. Possible values: kFALSE, kTRUE. References:. C. G Ryan et al.: SNIP, a statistics-sensitive background treatment for the; quantitative analysis of PIXE spectra in geoscience applications. NIM, B34; (1988), 396-402.; M. Morh�č, J. Kliman, V. Matou�ek, M. Veselsk�, I. Turzo:; Background elimination methods for multidimensional gamma-ray spectra. NIM,; A401 (1997) 113-132.; D. D. Burgess, R. J. Tervo: Background estimation for gamma-ray; spectroscopy. NIM 214 (1983), 431-434. Example 1 script Background_incr.c:. Figure 1 Example of the estimation of background for number of iterations=6.; Original spectrum is shown in black color, estimated background in red color. Script:. // Example to illustrate the background estimator (class TSpectrum).; // To execute this example, do; // root > .x Background_incr.C; #include ; void Background_incr() {; Int_t i;; Double_t nbins = 256;; Double_t xmin = 0;; Double_t xmax = (Double_t)nbins;; Float_t * source = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum.html:14742,log,logical,14742,root/html528/TSpectrum.html,https://root.cern,https://root.cern/root/html528/TSpectrum.html,4,['log'],['logical']
Testability,"ping window, the order of the clipping; filter, to include smoothing, to set width of smoothing window and to include; the estimation of Compton edges. On successful completion it returns 0. On; error it returns pointer to the string describing error.; Parameters:. spectrum: pointer to the vector of source spectrum; ssize: length of the spectrum vector; numberIterations: maximal width of clipping window,; direction: direction of change of clipping window.; Possible values: kBackIncreasingWindow, kBackDecreasingWindow; filterOrder: order of clipping filter.; Possible values: kBackOrder2, kBackOrder4, kBackOrder6, kBackOrder8; smoothing: logical variable whether the smoothing operation in the; estimation of background will be included.; Possible values: kFALSE, kTRUE; smoothWindow: width of smoothing window.; Possible values: kBackSmoothing3, kBackSmoothing5, kBackSmoothing7,; kBackSmoothing9, kBackSmoothing11, kBackSmoothing13, kBackSmoothing15.; compton: logical variable whether the estimation of Compton edge will be; included. Possible values: kFALSE, kTRUE. References:. C. G Ryan et al.: SNIP, a statistics-sensitive background treatment for the; quantitative analysis of PIXE spectra in geoscience applications. NIM, B34; (1988), 396-402.; M. Morh�č, J. Kliman, V. Matou�ek, M. Veselsk�, I. Turzo:; Background elimination methods for multidimensional gamma-ray spectra. NIM,; A401 (1997) 113-132.; D. D. Burgess, R. J. Tervo: Background estimation for gamma-ray; spectroscopy. NIM 214 (1983), 431-434. Example 1 script Background_incr.c:. Figure 1 Example of the estimation of background for number of iterations=6.; Original spectrum is shown in black color, estimated background in red color. Script:. // Example to illustrate the background estimator (class TSpectrum).; // To execute this example, do; // root > .x Background_incr.C; #include ; void Background_incr() {; Int_t i;; Double_t nbins = 256;; Double_t xmin = 0;; Double_t xmax = nbins;; Double_t * source = new Doubl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrum.html:15941,log,logical,15941,root/html602/TSpectrum.html,https://root.cern,https://root.cern/root/html602/TSpectrum.html,2,['log'],['logical']
Testability,"place.C Test the TMath::LaplaceDist and TMath::LaplaceDistI functions ;  mathmoreIntegration.C Example on the usage of the adaptive 1D integration algorithm of MathMore it calculates the numerically cumulative integral of a distribution (like in this case the BreitWigner) to execute the macro type it (you need to compile with AClic) ;  mathStudent.C Tutorial illustrating the use of the Student and F distributions ;  multidimSampling.C Example of sampling a multi-dim distribution using the DistSampler class NOTE: This tutorial must be run with ACLIC ;  normalDist.C Tutorial illustrating the new statistical distributions functions (pdf, cdf and quantile) ;  permute.C Tutorial illustrating the use of TMath::Permute can be run with: ;  principal.C Principal Components Analysis (PCA) example ;  quantiles.C Demo for quantiles ;  quasirandom.C Example of generating quasi-random numbers ;  Rolke.C Example of the usage of the TRolke class The TRolke class computes the profile likelihood confidence limits for 7 different model assumptions on systematic/statistical uncertainties ;  testrandom.C Performance test of all the ROOT random generator (TRandom, TRandom1, TRandom2 and TRandom3) Tests the generator TRandom3 against some ref values and creates a timing table against TRandom, TRandom1 and TRandom2 ;  tStudent.C Example macro describing the student t distribution ;  TSVDUnfoldExample.C Data unfolding using Singular Value Decomposition ;  vavilov.C Test of the TMath::Vavilov distribution ;  ► matrix;  invertMatrix.C This macro shows several ways to invert a matrix ;  solveLinear.C This macro shows several ways to perform a linear least-squares analysis ;  ► mc;  CompareMasses.CMacro to compare masses in ROOT data base to the values from pdg pdg ;  ► memstat;  memstatExample.CScript post-processing the file generated by TMemStat (default memstat.root) ;  ► mlp;  mlpHiggs.C Example of a Multi Layer Perceptron For a LEP search for invisible Higgs boson, a neural network was us",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:132375,test,testrandom,132375,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,2,['test'],['testrandom']
Testability,"place.C Test the TMath::LaplaceDist and TMath::LaplaceDistI functions ;  mathmoreIntegration.C Example on the usage of the adaptive 1D integration algorithm of MathMore it calculates the numerically cumulative integral of a distribution (like in this case the BreitWigner) to execute the macro type it (you need to compile with AClic) ;  mathStudent.C Tutorial illustrating the use of the Student and F distributions ;  multidimSampling.C Example of sampling a multi-dim distribution using the DistSampler class NOTE: This tutorial must be run with ACLIC ;  normalDist.C Tutorial illustrating the new statistical distributions functions (pdf, cdf and quantile) ;  permute.C Tutorial illustrating the use of TMath::Permute can be run with: ;  principal.C Principal Components Analysis (PCA) example ;  quantiles.C Demo for quantiles ;  quasirandom.C Example of generating quasi-random numbers ;  Rolke.C Example of the usage of the TRolke class The TRolke class computes the profile likelihood confidence limits for 7 different model assumptions on systematic/statistical uncertainties ;  testrandom.C Performance test of all the ROOT random generator (TRandom, TRandom1, TRandom2 and TRandom3) Tests the generator TRandom3 against some ref values and creates a timing table against TRandom, TRandom1 and TRandom2 ;  testUnfold1.C Test program for the classes TUnfold and related ;  testUnfold2.C Test program as an example for a user specific regularisation scheme ;  testUnfold3.C Simple Test program for the class TUnfoldDensity ;  testUnfold4.C Test program for the class TUnfoldSys ;  testUnfold5a.C Version 17.0 example for multi-dimensional unfolding ;  testUnfold5b.C ;  testUnfold5c.C Version 17.0 example for multi-dimensional unfolding ;  testUnfold5d.C Version 17.0 example for multi-dimensional unfolding ;  tStudent.C Example macro describing the student t distribution ;  TSVDUnfoldExample.C Data unfolding using Singular Value Decomposition ;  vavilov.C Test of the TMath::Vavilov dist",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:130643,test,testrandom,130643,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,1,['test'],['testrandom']
Testability,"plate arguments of the; 8858/// function template described by ft_info.; 8859 ; 8860UInt_t TCling::FuncTempInfo_TemplateMinReqArgs(FuncTempInfo_t *ft_info) const; 8861{; 8862 if (!ft_info) return 0;; 8863 const clang::FunctionTemplateDecl *ft = (clang::FunctionTemplateDecl*)ft_info;; 8864 return ft->getTemplateParameters()->getMinRequiredArguments();; 8865}; 8866 ; 8867////////////////////////////////////////////////////////////////////////////////; 8868/// Return the property of the function template.; 8869 ; 8870Long_t TCling::FuncTempInfo_Property(FuncTempInfo_t *ft_info) const; 8871{; 8872 if (!ft_info) return 0;; 8873 ; 8874 long property = 0L;; 8875 property |= kIsCompiled;; 8876 ; 8877 const clang::FunctionTemplateDecl *ft = (clang::FunctionTemplateDecl*)ft_info;; 8878 ; 8879 switch (ft->getAccess()) {; 8880 case clang::AS_public:; 8881 property |= kIsPublic;; 8882 break;; 8883 case clang::AS_protected:; 8884 property |= kIsProtected;; 8885 break;; 8886 case clang::AS_private:; 8887 property |= kIsPrivate;; 8888 break;; 8889 case clang::AS_none:; 8890 if (ft->getDeclContext()->isNamespace()); 8891 property |= kIsPublic;; 8892 break;; 8893 default:; 8894 // IMPOSSIBLE; 8895 assert(false && ""Unexpected value for the access property value in Clang"");; 8896 break;; 8897 }; 8898 ; 8899 const clang::FunctionDecl *fd = ft->getTemplatedDecl();; 8900 if (const clang::CXXMethodDecl *md =; 8901 llvm::dyn_cast<clang::CXXMethodDecl>(fd)) {; 8902 if (md->getMethodQualifiers().hasConst()) {; 8903 property |= kIsConstant | kIsConstMethod;; 8904 }; 8905 if (md->isVirtual()) {; 8906 property |= kIsVirtual;; 8907 }; 8908 if (md->isPureVirtual()) {; 8909 property |= kIsPureVirtual;; 8910 }; 8911 if (const clang::CXXConstructorDecl *cd =; 8912 llvm::dyn_cast<clang::CXXConstructorDecl>(md)) {; 8913 if (cd->isExplicit()) {; 8914 property |= kIsExplicit;; 8915 }; 8916 }; 8917 else if (const clang::CXXConversionDecl *cd =; 8918 llvm::dyn_cast<clang::CXXConversionDecl>(md)) {; 8919 if ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:345832,assert,assert,345832,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['assert'],['assert']
Testability,"ple Test. ;  ; void KolmogorovSmirnovTest (Double_t &pvalue, Double_t &testStat) const;  Kolmogorov-Smirnov 1-Sample Test. ;  ; void operator() (ETestType test, Double_t &pvalue, Double_t &testStat) const;  The class's unary functions performing the gif test according to the ETestType provided. ;  ; Double_t operator() (ETestType test=kAD, const Char_t *option=""p"") const;  Returns default Anderson Darling 1-Sample Test and default p-value; option ""t"" returns the test statistic value specific to the test type. ;  ; void SetDistribution (EDistribution dist, const std::vector< double > &distParams={});  Sets the distribution for the predefined distribution types and optionally its parameters for 1-sample tests. ;  ; void SetUserCDF (const IGenFunction &cdf, Double_t xmin=1, Double_t xmax=0);  Specialization to set the user input distribution as a cumulative distribution function for 1-sample tests. ;  ; template<class Dist > ; void SetUserCDF (Dist &cdf, Double_t xmin=1, Double_t xmax=0);  Sets the user input distribution as a cumulative distribution function for 1-sample tests. ;  ; void SetUserDistribution (const IGenFunction &dist, GoFTest::EUserDistribution userDist=kPDF, Double_t xmin=1, Double_t xmax=0);  Sets the user input distribution function for 1-sample test using the ROOT::Math::IGenFunction interface. ;  ; template<class Dist > ; void SetUserDistribution (Dist &dist, EUserDistribution userDist=kPDF, Double_t xmin=1, Double_t xmax=0);  Sets the user input distribution function for 1-sample test as a generic functor object. ;  ; void SetUserPDF (const IGenFunction &pdf, Double_t xmin=1, Double_t xmax=0);  Specialization to set the user input distribution as a probability density function for 1-sample tests using the ROOT::Math::IGenFunction interface. ;  ; template<class Dist > ; void SetUserPDF (Dist &pdf, Double_t xmin=1, Double_t xmax=0);  Sets the user input distribution as a probability density function for 1-sample tests. ;  . Static Public Member Fun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GoFTest.html:4804,test,tests,4804,doc/master/classROOT_1_1Math_1_1GoFTest.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GoFTest.html,1,['test'],['tests']
Testability,"ple writes a tree with objects of the class Event ;  treefriend.C Illustrates how to use Tree friends: ;  treegetval.C Illustrates how to retrieve TTree variables in arrays ;  tv3.C;  tvdemo.C;  ► unuran;  unuranDemo.CExample macro to show unuran capabilities The results are compared with what is obtained using TRandom or TF1::GetRandom The macro is divided in 3 parts: ;  unuranFoamTest.CThis program must be compiled and executed with Aclic as follows ;  ► v7;  concurrentfill.cxx;  draw.cxx;  histops.cxx;  histspeedtest.cxx;  perf.cxx;  perfcomp.cxx;  simple.cxx;  ► xml;  DOMParsePerson.C ROOT implementation of a XML DOM Parser ;  DOMRecursive.C ROOT implementation of a XML DOM Parser ;  SAXHandler.C ROOT implementation of a simple SAX Handler ;  xmlnewfile.C Example to create a new xml file with the TXMLEngine class ;  xmlreadfile.C Example to read and parse any xml file, supported by TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ;  benchmarks.CThis macro run several tests and produces an benchmark report ;  demos.CThis macro shows a control bar to run some of the ROOT tutorials ;  demoshelp.CThis macro shows help on running the Demos ;  geant3tasks.CThis script is a representation using TTasks of the Geant3 simulation program This example uses directly TTask objects ;  hsimple.C This program creates : ;  htmlex.CThis file demonstrates how THtml can document sources ;  MyTasks.cxxA set of classes deriving from TTask ;  regexp.CA regular expression, often called a pattern, is an expression that describes a set of strings ;  regexp_pme.CClass TPMERegexp - API similar to PME - PCRE Made Easy Tries to be as close as possible to PERL syntax and functionality ;  rootalias.CDefines aliases: ;  rootenv.CProduce a picture of the ROOT environment ;  rootlogoff.CExample of rootlogoff.C ;  rootlogon.CExample of rootlogon.C ;  rootmarks.CPrints a summary of all ROOT benchmarks (must be run bef",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:158540,benchmark,benchmarks,158540,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,1,['benchmark'],['benchmarks']
Testability,plementation of the generator context specific for RooSimultaneous PDFs when generating more than one of the component pdfs. More...;  ; class  RooSimultaneous;  Facilitates simultaneous fitting of multiple PDFs to subsets of a given dataset. More...;  ; class  RooStringVar;  A RooAbsArg implementing string values. More...;  ; class  RooStudyManager;  Utility class to manage studies that consist of repeated applications of generate-and-fit operations on a workspace. More...;  ; class  RooStudyPackage;  Utility class to manage studies that consist of repeated applications of generate-and-fit operations on a workspace. More...;  ; class  RooSubsidiaryL;  Calculates the sum of the -(log) likelihoods of a set of RooAbsPdf objects that represent subsidiary or constraint functions. More...;  ; class  RooFit::TestStatistics::RooSumL;  Likelihood class that sums over multiple -log components. More...;  ; class  RooSuperCategory;  Joins several RooAbsCategoryLValue objects into a single category. More...;  ; class  RooTable;  Abstract interface for table objects. More...;  ; class  RooTemplateProxy< T >;  ; class  RooThresholdCategory;  A real-to-category mapping defined by a series of thresholds. More...;  ; class  RooTrace;  Controls the memory tracing hooks in all RooFit objects. More...;  ; class  RooTreeDataStore;  TTree-backed data storage. More...;  ; class  RooTruthModel;  Implements a RooResolution model that corresponds to a delta function. More...;  ; class  RooUnbinnedL;  A -log(likelihood) calculation from a dataset (assumed to be unbinned) and a PDF. More...;  ; class  RooUniformBinning;  Implementation of RooAbsBinning that provides a uniform binning in 'n' bins between the range end points. More...;  ; class  RooVectorDataStore;  Uses std::vector to store data columns. More...;  ; class  RooWorkspace;  Persistable container for RooFit projects. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Roofitcore.html:20277,log,log,20277,doc/master/group__Roofitcore.html,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html,1,['log'],['log']
Testability,"plemented from TProof.; Definition at line 2002 of file TProofLite.cxx. ◆ SetProofServEnv(). Int_t TProofLite::SetProofServEnv ; (; const char * ; ord). private . Create environment files for worker 'ord'. ; Definition at line 684 of file TProofLite.cxx. ◆ SetQueryRunning(). void TProofLite::SetQueryRunning ; (; TProofQueryResult * ; pq). protected . Set query in running state. ; Definition at line 1025 of file TProofLite.cxx. ◆ SetupWorkers(). Int_t TProofLite::SetupWorkers ; (; Int_t ; opt = 0, . TList * ; wrks = 0 . ). protected . Start up PROOF workers. ; Definition at line 489 of file TProofLite.cxx. ◆ ShowCache(). void TProofLite::ShowCache ; (; Bool_t ; all = kFALSE). overridevirtual . List contents of file cache. ; If all is true show all caches also on slaves. If everything is ok all caches are to be the same. ; Reimplemented from TProof.; Definition at line 1508 of file TProofLite.cxx. ◆ ShowData(). void TProofLite::ShowData ; (; ). overridevirtual . List contents of the data directory in the sandbox. ; This is the place where files produced by the client queries are kept ; Reimplemented from TProof.; Definition at line 2479 of file TProofLite.cxx. ◆ ShowDataDir(). void TProofLite::ShowDataDir ; (; const char * ; dirname). private . List contents of the data directory 'dirname'. ; Definition at line 2495 of file TProofLite.cxx. ◆ ShowDataSetCache(). void TProofLite::ShowDataSetCache ; (; const char * ; dataset = 0). overridevirtual . Display the content of the dataset cache, if any (matching 'dataset', if defined). ; Reimplemented from TProof.; Definition at line 2292 of file TProofLite.cxx. ◆ ShowDataSets(). void TProofLite::ShowDataSets ; (; const char * ; uri = """", . const char * ; opt = 0 . ). overridevirtual . Shows datasets in locations that match the uri By default shows the user's datasets and global ones. ; Reimplemented from TProof.; Definition at line 2070 of file TProofLite.cxx. ◆ Streamer(). void TProofLite::Streamer ; (; TBuffer & ; R__b). ov",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:66636,sandbox,sandbox,66636,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['sandbox'],['sandbox']
Testability,"pler!; const RooArgSet*fNuisancePars; const RooArgSet*fObservables; const RooArgSet*fParametersForTestStat; RooAbsPdf*fPdfmodel (can be alt or null); RooAbsPdf*fPriorNuisanceprior pdf for nuisance parameters; RooStats::ProofConfig*fProofConfig!; const RooDataSet*fProtoDatain dev; stringfSamplingDistNamename of the model; Double_tfSize; vector<TestStatistic*>fTestStatistics; Double_tfToysInTails; Bool_tfUseMultiGenUse PrepareMultiGen?; static Bool_tfgAlwaysUseMultiGenUse PrepareMultiGen always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetAlwaysUseMultiGen(Bool_t flag); { fgAlwaysUseMultiGen = flag ; }. ToyMCSampler(); Proof constructor. Do not use. ToyMCSampler(RooStats::TestStatistic& ts, Int_t ntoys). ~ToyMCSampler(). Bool_t CheckConfig(void); only checks, no guessing/determination (do this in calculators,; e.g. using ModelConfig::GuessObsAndNuisance(...)). RooArgList* EvaluateAllTestStatistics(RooAbsData& data, const RooArgSet& poi); Evaluate all test statistics, returning result and any detailed output.; PDF parameter values are saved in case they are modified by; TestStatistic::Evaluate (eg. SimpleLikelihoodRatioTestStat). const RooArgList* EvaluateAllTestStatistics(RooAbsData& data, const RooArgSet& poi, RooStats::DetailedOutputAggregator& detOutAgg). SamplingDistribution* GetSamplingDistribution(RooArgSet& paramPoint). RooDataSet* GetSamplingDistributions(RooArgSet& paramPoint); Use for serial and parallel runs. RooDataSet* GetSamplingDistributionsSingleWorker(RooArgSet& paramPoint); This is the main function for serial runs. It is called automatically; from inside GetSamplingDistribution when no ProofConfig is given.; You should not call this function yourself. This function should; be used by ToyMCStudy on the workers (ie. when you explicitly want; a serial run although ProofConfig is present). void GenerateGlobalObservables(RooAbsPdf& pdf) const. RooAbsData* GenerateToyData(RooArgSet& paramPoint, double&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__ToyMCSampler.html:5665,test,test,5665,root/html534/RooStats__ToyMCSampler.html,https://root.cern,https://root.cern/root/html534/RooStats__ToyMCSampler.html,1,['test'],['test']
Testability,"ples for the training and testing of the TMVA classifiers in categorisation mode ;  TMVAClassificationCategoryApplication.C This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  TMVACrossValidation.C This macro provides an example of how to use TMVA for k-folds cross evaluation ;  TMVACrossValidationApplication.C This macro provides an example of how to use TMVA for k-folds cross evaluation in application ;  TMVACrossValidationRegression.C This macro provides an example of how to use TMVA for k-folds cross evaluation ;  TMVAGAexample.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAGAexample2.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAMinimalClassification.C Minimal self-contained example for setting up TMVA with binary classification ;  TMVAMulticlass.C This macro provides a simple example for the training and testing of the TMVA multiclass classification ;  TMVAMulticlassApplication.C This macro provides a simple example on how to use the trained multiclass classifiers within an analysis module ;  TMVAMultipleBackgroundExample.C This example shows the training of signal with three different backgrounds Then in the application a tree is created with all signal and background events where the true class ID and the three classifier outputs are added finally with the application tree, the significance is maximized with the help of the TMVA genetic algrorithm ;  TMVARegression.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVARegressionApplication.C This macro provides a simple example on how to use the trained regression MVAs within an analysis module ;  ► tree;  basic.C Read data from an ascii file and create a root file with an histogram and an ntuple ;  basic2.C Create can ntuple reading data from an ascii file ;  bill.C Benchmark comparing row-wise and colum",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:159644,test,testing,159644,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,2,['test'],['testing']
Testability,"plicationServer::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TApplicationServer::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TApplicationServer::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 94 of file TApplicationServer.h. ◆ DeclFileName(). static const char * TApplicationServer::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 94 of file TApplicationServer.h. ◆ ErrorHandler(). void TApplicationServer::ErrorHandler ; (; Int_t ; level, . Bool_t ; abort, . const char * ; location, . const char * ; msg . ). staticprotected . The error handler function. ; It prints the message on stderr and if abort is set it aborts the application. ; Definition at line 1088 of file TApplicationServer.cxx. ◆ ExecLogon(). void TApplicationServer::ExecLogon ; (; ). private . Execute logon macro's. ; There are three levels of logon macros that will be executed: the system logon etc/system.rootlogon.C, the global user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward compatibility also the logon macro as specified by the Rint.Logon environment setting, by default ./rootlogon.C, will be executed. No logon macros will be executed when the system is started with the -n option. ; Definition at line 1277 of file TApplicationServer.cxx. ◆ GetHost(). const char * TApplicationServer::GetHost ; (; ); const. inline . Definition at line 73 of file TApplicationServer.h. ◆ GetOptions(). void TApplicationServer::GetOptions ; (; Int_t * ; argc, . char ** ; argv . ). overridevirtual . Get and handle command line options. ; Fixed format: ""protocol url"" ; Reimplemented from TApplication.; Definition at line 449 of file TApplicationServer.cxx. ◆ GetPort(). Int_t TApplicationServer::GetPort ; (; ); const. inline . Definition at line 71 of file TApplicationServer.h. ◆ GetProt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplicationServer.html:25230,log,logon,25230,doc/master/classTApplicationServer.html,https://root.cern,https://root.cern/doc/master/classTApplicationServer.html,1,['log'],['logon']
Testability,"plitlevel = 2, one top level branch is created for each array element.; if, in turn, one of the array elements is a TCollection, one top level; branch will be created for each element of this collection. In case a collection element is a TClonesArray, the special Tree constructor; for TClonesArray is called.; The collection itself cannot be a TClonesArray. The function returns the total number of branches created. If name is given, all branch names will be prefixed with name_. IMPORTANT NOTE1: This function should not be called with splitlevel < 1. IMPORTANT NOTE2: The branches created by this function will have names; corresponding to the collection or object names. It is important; to give names to collections to avoid misleading branch names or; identical branch names. By default collections have a name equal to; the corresponding class name, eg the default name for a TList is ""TList"". Example--------------------------------------------------------------:. {; TTree T(""T"",""test list"");; TList *l = new TList();. TObjArray *a1 = new TObjArray();; a1->SetName(""a1"");; l->Add(a1);; TH1F *ha1a = new TH1F(""ha1a"",""ha1"",100,0,1);; TH1F *ha1b = new TH1F(""ha1b"",""ha1"",100,0,1);; a1->Add(ha1a);; a1->Add(ha1b);; TObjArray *b1 = new TObjArray();; b1->SetName(""b1"");; l->Add(b1);; TH1F *hb1a = new TH1F(""hb1a"",""hb1"",100,0,1);; TH1F *hb1b = new TH1F(""hb1b"",""hb1"",100,0,1);; b1->Add(hb1a);; b1->Add(hb1b);. TObjArray *a2 = new TObjArray();; a2->SetName(""a2"");; l->Add(a2);; TH1S *ha2a = new TH1S(""ha2a"",""ha2"",100,0,1);; TH1S *ha2b = new TH1S(""ha2b"",""ha2"",100,0,1);; a2->Add(ha2a);; a2->Add(ha2b);. T.Branch(l,16000,2);; T.Print();; }. Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); Create one branch for each element in the folder.; Returns the total number of branches created. TBranch* Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000); Create a new TTree Branch. This Branch constructor is provided to support non-objects in; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:42975,test,test,42975,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,2,['test'],['test']
Testability,"point, const Double_t *dir) const override;  ; virtual Double_t GetDX () const;  ; virtual Double_t GetDY () const;  ; virtual Double_t GetDZ () const;  ; virtual Double_t GetFacetArea (Int_t index=0) const;  ; Int_t GetFittingBox (const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override;  ; virtual const Double_t * GetOrigin () const;  ; virtual Bool_t GetPointsOnFacet (Int_t index, Int_t npoints, Double_t *array) const;  ; virtual Bool_t IsNullBox () const;  ; Bool_t IsValidBox () const override;  ; void SetBoxDimensions (Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ; void SetBoxPoints (Double_t *points) const;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoShape;  TGeoShape ();  Default constructor. ;  ;  TGeoShape (const char *name);  Default constructor. ;  ;  ~TGeoShape () override;  Destructor. ;  ; void CheckShape (Int_t testNo, Int_t nsamples=10000, Option_t *option="""");  Test for shape navigation methods. ;  ; virtual void ClearThreadData () const;  ; virtual void CreateThreadData (Int_t);  ; void Draw (Option_t *option="""") override;  Draw this shape. ;  ; void ExecuteEvent (Int_t event, Int_t px, Int_t py) override;  Execute mouse actions on this shape. ;  ; Int_t GetId () const;  ; const char * GetName () const override;  Get the shape name. ;  ; const char * GetPointerName () const;  Provide a pointer name containing uid. ;  ; void InvertShapeBit (UInt_t f);  ; TClass * IsA () const override;  ; virtual Bool_t IsAssembly () const;  ; virtual Bool_t IsComposite () const;  ; virtual Bool_t IsReflected () const;  ; Bool_t IsRunTimeShape () const;  ; Bool_t IsValid () const;  ; virtual Bool_t IsVecGeom () const;  ; void Paint (Option_t *option="""") override;  Paint this shape. ;  ; void ResetShapeBit (UInt_t f);  ; void SetId (Int_t id);  ; void SetRuntime (Bool_t flag=kTRUE);  ; void SetShapeBit (UInt_t f);  ; void SetShapeBit (U",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoConeSeg.html:5807,test,testNo,5807,doc/master/classTGeoConeSeg.html,https://root.cern,https://root.cern/doc/master/classTGeoConeSeg.html,1,['test'],['testNo']
Testability,"point, const Double_t *dir) const override;  ; virtual Double_t GetDX () const;  ; virtual Double_t GetDY () const;  ; virtual Double_t GetDZ () const;  ; virtual Double_t GetFacetArea (Int_t index=0) const;  ; Int_t GetFittingBox (const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override;  ; virtual const Double_t * GetOrigin () const;  ; virtual Bool_t GetPointsOnFacet (Int_t index, Int_t npoints, Double_t *array) const;  ; virtual Bool_t IsNullBox () const;  ; Bool_t IsValidBox () const override;  ; void SetBoxDimensions (Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ; void SetBoxPoints (Double_t *points) const;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoShape;  TGeoShape ();  Default constructor. ;  ;  TGeoShape (const char *name);  Default constructor. ;  ;  ~TGeoShape () override;  Destructor. ;  ; void CheckShape (Int_t testNo, Int_t nsamples=10000, Option_t *option="""");  Test for shape navigation methods. ;  ; virtual void ClearThreadData () const;  ; virtual void CreateThreadData (Int_t);  ; void Draw (Option_t *option="""") override;  Draw this shape. ;  ; void ExecuteEvent (Int_t event, Int_t px, Int_t py) override;  Execute mouse actions on this shape. ;  ; Int_t GetId () const;  ; const char * GetName () const override;  Get the shape name. ;  ; const char * GetPointerName () const;  Provide a pointer name containing uid. ;  ; void InvertShapeBit (UInt_t f);  ; virtual Bool_t IsAssembly () const;  ; virtual Bool_t IsComposite () const;  ; virtual Bool_t IsReflected () const;  ; Bool_t IsRunTimeShape () const;  ; Bool_t IsValid () const;  ; virtual Bool_t IsVecGeom () const;  ; void Paint (Option_t *option="""") override;  Paint this shape. ;  ; void ResetShapeBit (UInt_t f);  ; void SetId (Int_t id);  ; void SetRuntime (Bool_t flag=kTRUE);  ; void SetShapeBit (UInt_t f);  ; void SetShapeBit (UInt_t f, Bool_t set);  Equivalent o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCtub.html:8745,test,testNo,8745,doc/master/classTGeoCtub.html,https://root.cern,https://root.cern/doc/master/classTGeoCtub.html,2,['test'],['testNo']
Testability,"pointer to this object's name. ; This can be used for fast name comparisons. like if (namePtr() == other.namePtr()). NoteTNamed::GetName() will return a pointer that's different for each object, but namePtr() always points to a unique instance. ; Definition at line 535 of file RooAbsArg.h. ◆ numCaches(). Int_t RooAbsArg::numCaches ; (; ); const. Return number of registered caches. ; Definition at line 2136 of file RooAbsArg.cxx. ◆ numProxies(). Int_t RooAbsArg::numProxies ; (; ); const. Return the number of registered proxies. ; Definition at line 1457 of file RooAbsArg.cxx. ◆ observableOverlaps() [1/2]. bool RooAbsArg::observableOverlaps ; (; const RooAbsData * ; dset, . const RooAbsArg & ; testArg . ); const. Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ; Definition at line 914 of file RooAbsArg.cxx. ◆ observableOverlaps() [2/2]. bool RooAbsArg::observableOverlaps ; (; const RooArgSet * ; depList, . const RooAbsArg & ; testArg . ); const. Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ; Definition at line 924 of file RooAbsArg.cxx. ◆ operator=(). RooAbsArg & RooAbsArg::operator= ; (; const RooAbsArg & ; other). delete . ◆ operator==(). virtual bool RooAbsArg::operator== ; (; const RooAbsArg & ; other); const. pure virtual . Implemented in RooAbsCategory, RooAbsReal, and RooStringVar. ◆ operMode(). OperMode RooAbsArg::operMode ; (; ); const. inline . Query the operation mode of this node. ; Definition at line 456 of file RooAbsArg.h. ◆ operModeHook(). virtual void RooAbsArg::operModeHook ; (; ). inlineprotectedvirtual . Reimplemented in RooCachedReal, and RooGenProdProj.; Definition at line 562 of file RooAbsArg.h. ◆ optimizeCacheMode() [1/2]. void RooAbsArg::optimizeCacheMode ; (; const RooArgSet & ; observables). virtual . Activate cache mode optimization with given definition of observables. ; The cache operation mode of all",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:77149,test,testArg,77149,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['test'],['testArg']
Testability,"polarSize());; 507 }; 508 if (theta == 0 || theta ==TMath::Pi()) {; 509 gPad->PaintLine(1-GetTickpolarSize(),0,1+GetTickpolarSize(),0);; 510 gPad->PaintLine(-1+GetTickpolarSize(),0,-1-GetTickpolarSize(),0);; 511 }; 512 }; 513 TAttLine::SetLineStyle(1);; 514 TAttLine::Modify();; 515 gPad->PaintLine(0.,0.,costheta,sintheta);; 516 // Add minor lines w/o text.; 517 Int_t oldLineStyle = GetLineStyle();; 518 TAttLine::SetLineStyle(2); //Minor lines always in this style.; 519 TAttLine::Modify(); //Changes line attributes apart from style.; 520 for (j=1; j<ndivMinor; j++) {; 521 Double_t thetamin = theta+j*2*TMath::Pi()/(ndivMajor*ndivMinor);; 522 gPad->PaintLine(0.,0.,TMath::Cos(thetamin),TMath::Sin(thetamin));; 523 }; 524 TAttLine::SetLineStyle(oldLineStyle);; 525 TAttLine::Modify();; 526 }; 527 } else {; 528 Int_t big = (Int_t)fRwtmax;; 529 Int_t test= 1;; 530 while (big >= 10) {; 531 big = big/10;; 532 test++;; 533 }; 534 for (i=1; i<=test; i++) {; 535 Double_t txtval = pow((double)10,(double)(i-1));; 536 Double_t theta = (i-1)*2*TMath::Pi()/(double)(test);; 537 Double_t costheta = TMath::Cos(theta);; 538 Double_t sintheta = TMath::Sin(theta);; 539 Double_t tantheta = TMath::Tan(theta);; 540 Double_t costhetas = (1+fPolarOffset)*costheta;; 541 Double_t sinthetas = (1+fPolarOffset)*sintheta;; 542 Double_t corr = 0.01;; 543 ; 544 TLatex textangular;; 545 textangular.SetTextColor(GetPolarColorLabel());; 546 textangular.SetTextFont(GetPolarLabelFont());; 547 ; 548 TString form = "" "";; 549 TGaxis axis;; 550 ; 551 if (TestBit(TGraphPolargram::kLabelOrtho)) {; 552 if(!fPolarLabels && optionLabels){; 553 // Polar numbers are aligned with their axis.; 554 form.Form(""%5.3g"",txtval);; 555 axis.LabelsLimits(form.Data(),first,last);; 556 TString s = form;; 557 if (first != 0) s.Remove(0, first);; 558 textangular.SetTextAlign(FindAlign(theta));; 559 textangular.PaintLatex(costhetas,; 560 sinthetas, FindTextAngle(theta), GetPolarLabelSize(), s);; 561 }; 562 else if (fPolarLabels){; 56",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html:17665,test,test,17665,doc/master/TGraphPolargram_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html,4,['test'],['test']
Testability,"ponding source file (for example fit1.C). Once you are done, and want to quit the ROOT session, you can do so by typing .q.; root[] .x demos.C; root[] .q; 20.2 $ROOTSYS/test; The test directory contains a set of examples that represent all areas of the framework. When a new release is cut, the examples in this directory are compiled and run to test the new release’s backward compatibility.; We see these source files:. Makefile; Makefile to build all test programs. hsimple.cxx; Simple test program that creates and saves some histograms. MainEvent.cxx; Simple test program that creates a ROOT Tree object and fills it with some simple structures but also with complete histograms. This program uses the files Event.cxx, EventCint.cxx and Event.h. An example of a procedure to link this program is in bind_Event. Note that the Makefile invokes the rootcling utility to generate the Cling interface EventCint.cxx. Event.cxx; Implementation for classes Event and Track. minexam.cxx; Simple test program for data fitting. tcollex.cxx; Example usage of the ROOT collection classes. tcollbm.cxx; Benchmarks of ROOT collection classes. ctorture.cxx; Test program for the class TComplex. tstring.cxx; Example usage of the ROOT string class. vmatrix.cxx; Verification program for the TMatrix class. vvector.cxx; Verification program for the TVectorclass. vlazy.cxx; Verification program for lazy matrices. hworld.cxx; Small program showing basic graphics. guitest.cxx; Example usage of the ROOT GUI classes. gui viewer .cxx; Another ROOT GUI example program. Hello.cxx; Dancing text example. Aclock.cxx; Analog clock (a la X11 xclock). Tetris.cxx; The known Tetris game based on the ROOT graphics. stress.cxx; Important ROOT stress testing program. stress*.cxx; Stress testing of different ROOT classes. bench.cxx; STL and ROOT container test and benchmarking program. QpRandomDriver.cx x; Verification program for Quadratic programming classes in Quadp library. DrawTest.sh; Entry script to extensive TTr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1075988,test,test,1075988,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['test'],['test']
Testability,"ponent Analysis (using; TPrincipal), and use; to get a linear transformation; ; , so that; ; are constrained and linear independent. Perform a Principal Component Analysis on; ; , to get linear; indenpendent (among themselves, but not independent of; ; ) quantities . For each component ; make a mutlidimensional fit,; using ; as the variables, thus determing a set of; coefficents ; . To process data, using this parameterisation, do. Test wether the observation ; within the domain of; the parameterization, using the result from the Principal Component; Analysis. Determine ; as before. Detetmine ; as before. Use the result of the fit to determind ; . Transform back to ; from ; , using; the result from the Principal Component Analysis. Testing the parameterization. The class also provides functionality for testing the, over the; training sample, found parameterization; (TMultiDimFit::Fit). This is done by passing; the class a test sample of tuples of the form ; , where ; are the independent; variables, the known, dependent quantity, and is; the square error in ; (TMultiDimFit::AddTestRow). The parameterization is then evaluated at every ; in the; test sample, and. is evaluated. The relative error over the test sample. should not be to low or high compared to from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representive of; the problem. A large difference in the reduced over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced. It's possible to use Minuit; [4] to further improve the fit, using the test sample. Christian Holm; November 2000, NBI. Bibliography; 1. Philip R. Bevington and D. Keith Robinson.; Data Reduction and Error Analysis for the Physical Sciences.; McGraw-Hill, 2 edition, 1992.; 2. René Brun et al.; Mudifi.; Long writeup DD/75-23, CERN, 1980.; 3. Gene H. Golub and Charles F. van Loan.; Matrix Comput",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiDimFit.html:11834,test,test,11834,root/html528/TMultiDimFit.html,https://root.cern,https://root.cern/root/html528/TMultiDimFit.html,3,['test'],['test']
Testability,ponents of internal clone of input function; RooAbsReal*_funcInt! Function integral; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooNumIntConfig_intConfigNumeric integrator configuration for integration of function over bin; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_t_integrateIs integration over the bin volume requested; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*RooAbsOptTestStatistic::_normSetPointer to set with observables used for normalization; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooAbsOptTestStatistic::_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*RooAbsOptTestStatistic::_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; TListRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; RooArgSet_rrvArgsSet of real-valued observables; TIterator*_rrvIter! Iterator over set of real-valued observables; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooXYChi2Var.html:34580,test,test,34580,root/html528/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html528/RooXYChi2Var.html,2,['test'],['test']
Testability,"ported rotation type (see gv_detail::convert ); 99 */; 100 template <class OtherRotation>; 101 Quaternion & operator=( OtherRotation const & r ) {; 102 gv_detail::convert(r,*this);; 103 return *this;; 104 }; 105 ; 106 // ======== Components ==============; 107 ; 108 /**; 109 Set the four components given an iterator to the start of; 110 the desired data, and another to the end (4 past start).; 111 */; 112 template<class IT>; 113 void SetComponents(IT begin, IT end) {; 114 fU = *begin++;; 115 fI = *begin++;; 116 fJ = *begin++;; 117 fK = *begin++;; 118 (void)end;; 119 assert (end==begin);; 120 }; 121 ; 122 /**; 123 Get the components into data specified by an iterator begin; 124 and another to the end of the desired data (4 past start).; 125 */; 126 template<class IT>; 127 void GetComponents(IT begin, IT end) const {; 128 *begin++ = fU;; 129 *begin++ = fI;; 130 *begin++ = fJ;; 131 *begin++ = fK;; 132 (void)end;; 133 assert (end==begin);; 134 }; 135 ; 136 /**; 137 Get the components into data specified by an iterator begin; 138 */; 139 template<class IT>; 140 void GetComponents(IT begin ) const {; 141 *begin++ = fU;; 142 *begin++ = fI;; 143 *begin++ = fJ;; 144 *begin = fK;; 145 }; 146 ; 147 /**; 148 Set the components based on four Scalars. The sum of the squares of; 149 these Scalars should be 1; no checking is done.; 150 */; 151 void SetComponents(Scalar u, Scalar i, Scalar j, Scalar k) {; 152 fU=u; fI=i; fJ=j; fK=k;; 153 }; 154 ; 155 /**; 156 Get the components into four Scalars.; 157 */; 158 void GetComponents(Scalar & u, Scalar & i, Scalar & j, Scalar & k) const {; 159 u=fU; i=fI; j=fJ; k=fK;; 160 }; 161 ; 162 /**; 163 Access to the four quaternion components:; 164 U() is the coefficient of the identity Pauli matrix,; 165 I(), J() and K() are the coefficients of sigma_x, sigma_y, sigma_z; 166 */; 167 Scalar U() const { return fU; }; 168 Scalar I() const { return fI; }; 169 Scalar J() const { return fJ; }; 170 Scalar K() const { return fK; }; 171 ; 172 // ==========",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2Quaternion_8h_source.html:3903,assert,assert,3903,doc/master/GenVector_2Quaternion_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2Quaternion_8h_source.html,1,['assert'],['assert']
Testability,"ports using lambda expressions in the formula. This allows, by using a full C++ syntax the full power of lambda functions and still maintain the capability of storing the function in a file which cannot be done with function pointer or lambda written not as expression, but as code (see items below).; Example on how using lambda to define a sum of two functions. Note that is necessary to provide the number of parameters; TF1 f1(""f1"",""sin(x)"",0,10);; TF1 f2(""f2"",""cos(x)"",0,10);; TF1 fsum(""f1"",""[&](double *x, double *p){ return p[0]*f1(x) + p[1]*f2(x); }"",0,10,2);; TF11-Dim function classDefinition TF1.h:233; f1TF1 * f1Definition legend1.C:11. 4 - A general C function with parameters; Consider the macro myfunc.C below:; // Macro myfunc.C; Double_t myfunction(Double_t *x, Double_t *par); {; Float_t xx =x[0];; Double_t f = TMath::Abs(par[0]*sin(par[1]*xx)/xx);; return f;; }; void myfunc(); {; auto f1 = new TF1(""myfunc"",myfunction,0,10,2);; f1->SetParameters(2,1);; f1->SetParNames(""constant"",""coefficient"");; f1->Draw();; }; void myfit(); {; auto h1 = new TH1F(""h1"",""test"",100,0,10);; h1->FillRandom(""myfunc"",20000);; TF1 *f1 = (TF1 *)gROOT->GetFunction(""myfunc"");; f1->SetParameters(800,1);; h1->Fit(""myfunc"");; }; f#define f(i)Definition RSha256.hxx:104; Float_tfloat Float_tDefinition RtypesCore.h:57; gROOT#define gROOTDefinition TROOT.h:406; TF1::SetParNamesvirtual void SetParNames(const char *name0="""", const char *name1="""", const char *name2="""", const char *name3="""", const char *name4="""", const char *name5="""", const char *name6="""", const char *name7="""", const char *name8="""", const char *name9="""", const char *name10="""")Set up to 10 parameter names.Definition TF1.cxx:3463; TF1::Drawvoid Draw(Option_t *option="""") overrideDraw this function with its current attributes.Definition TF1.cxx:1333; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:677; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::Fill",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1.html:3783,test,test,3783,doc/master/classTF1.html,https://root.cern,https://root.cern/doc/master/classTF1.html,1,['test'],['test']
Testability,"powerlaw);; ; // To get rid of the binning effects in the general case, one can use the; // IntegrateBins() command argument. Now, the pdf is not evaluated at the; // bin centers, but numerically integrated over each bin and divided by the; // bin width. The parameter for IntegrateBins() is the required precision; // for the numeric integrals. This is computationally expensive, but the; // bias is now not a problem anymore.; std::unique_ptr<RooFitResult> fit5{; powerlaw.fitTo(*powerlawData, IntegrateBins(1e-3), Save(), PrintLevel(-1), SumW2Error(false))};; fit5->Print();; ; // Improving numerical stability; // -----------------------------; ; // There is one more problem with binned fits that is related to the binning; // effects because often, a binned fit is affected by both problems.; //; // The issue is numerical stability for fits with a greatly different number; // of events in each bin. For each bin, you have a term \f[n\log(p)\f] in; // the NLL, where \f[n\f] is the number of observations in the bin, and; // \f[p\f] the predicted probability to have an event in that bin. The; // difference in the logarithms for each bin is small, but the difference in; // \f[n\f] can be orders of magnitudes! Therefore, when summing these terms,; // lots of numerical precision is lost for the bins with less events.; ; // We can study this with the example of an exponential plus a Gaussian. The; // Gaussian is only a faint signal in the tail of the exponential where; // there are not so many events. And we can't afford any precision loss for; // these bins, otherwise we can't fit the Gaussian.; ; x.setBins(100); // It's not about binning effects anymore, so reset the number of bins.; ; RooRealVar mu{""mu"", ""mu"", 3.0, 0.1, 5.1};; RooRealVar sigma{""sigma"", ""sigma"", 0.5, 0.01, 5.0};; RooGaussian gauss{""gauss"", ""gauss"", x, mu, sigma};; ; RooRealVar nsig{""nsig"", ""nsig"", 10000, 0, 1e9};; RooRealVar nbkg{""nbkg"", ""nbkg"", 10000000, 0, 1e9};; RooRealVar frac{""frac"", ""frac"", nsig.getVal() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:6202,log,log,6202,doc/master/rf614__binned__fit__problems_8C.html,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html,1,['log'],['log']
Testability,"ppa, Double_t beta2)Returns the value of the Vavilov probability density function.Definition TMath.cxx:2778; TMath::BinomialDouble_t Binomial(Int_t n, Int_t k)Calculates the binomial coefficient n over k.Definition TMath.cxx:2111; TMath::NormalizeFloat_t Normalize(Float_t v[3])Normalize a vector v in place.Definition TMath.cxx:518; TMath::NaUncertaintyconstexpr Double_t NaUncertainty()Avogadro constant (Avogadro's Number) uncertainty.Definition TMath.h:291; TMath::ProbDouble_t Prob(Double_t chi2, Int_t ndf)Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf...Definition TMath.cxx:637; TMath::IsInsideBool_t IsInside(T xp, T yp, Int_t np, T *x, T *y)Function which returns kTRUE if point xp,yp lies inside the polygon defined by the np points in array...Definition TMath.h:1233; TMath::ASinDouble_t ASin(Double_t)Returns the principal value of the arc sine of x, expressed in radians.Definition TMath.h:624; TMath::Log2Double_t Log2(Double_t x)Returns the binary (base-2) logarithm of x.Definition TMath.cxx:107; TMath::BesselK1Double_t BesselK1(Double_t x)Modified Bessel function I_1(x)Definition TMath.cxx:1529; TMath::MedianDouble_t Median(Long64_t n, const T *a, const Double_t *w=nullptr, Long64_t *work=nullptr)Same as RMS.Definition TMath.h:1272; TMath::BubbleHighvoid BubbleHigh(Int_t Narr, Double_t *arr1, Int_t *arr2)Bubble sort variant to obtain the order of an array's elements into an index in order to do more usef...Definition TMath.cxx:1314; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::BesselI1Double_t BesselI1(Double_t x)Modified Bessel function K_0(x)Definition TMath.cxx:1494; TMath::ErfDouble_t Erf(Double_t x)Computation of the error function erf(x).Definition TMath.cxx:190; TMath::PermuteBool_t Permute(Int_t n, Int_t *a)Simple recursive algorithm to find the permutations of n natural numbers, not necessarily all dist",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8h_source.html:58669,log,logarithm,58669,doc/master/TMath_8h_source.html,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html,1,['log'],['logarithm']
Testability,"pper value for the parameter; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t i); return Sum(log(i) i=0,n; used by log likelihood fits. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). void PrintResults(Int_t level, Double_t amin) const; Print fit results. void ReleaseParameter(Int_t ipar); Release parameter ipar. void SetFCN(void* fcn); Specify the address of the fitting algorithm (from the interpreter). void SetFCN(void(*)(Int_t&,Double_t*,Double_t&,Double_t*,Int_t) fcn); Specify the address of the fitting algorithm. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFitter.html:15466,log,loglikelihood,15466,root/html602/TFitter.html,https://root.cern,https://root.cern/root/html602/TFitter.html,2,['log'],['loglikelihood']
Testability,"pplicationsList of available applications. private:. Bool_tfCaughtExceptionTRint just caught an exception or signal; TStringfDefaultPromptdefault prompt: ""root [%d] ""; TFileHandler*fInputHandlerterminal input handler; Bool_tfInterruptif true macro execution will be stopped; Int_tfNcmdcommand history number; charfPrompt[64]interpreter prompt. Class Charts. Inheritance Chart:. TObject. TQObject. ←; TApplication. ←; TRint. Function documentation; TRint(const char* appClassName, int* argc, char** argv, void* options = 0, int numOptions = 0, Bool_t noLogo = kFALSE); Create an application environment. The TRint environment provides an; interface to the WM manager functionality and eventloop via inheritance; of TApplication and in addition provides interactive access to; the CINT C++ interpreter via the command line. ~TRint(); Destructor. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. void Run(Bool_t retrn = kFALSE); Main application eventloop. First process files given on the command; line and then go into the main application event loop, unless the -q; command line option was specfied in which case the program terminates.; When retrun is true this method returns even when -q was specified. When QuitOpt is true and retrn is false, terminate the application with; an error code equal to either the ProcessLine error (if any) or the; return value of the command casted to a long. void PrintLogo(Bool_t lite = kFALSE); Print the ROOT logo on standard output. char * GetPrompt(); Get prompt from interpreter. Either ""root [n]"" or ""end with '}'"". const char * SetPrompt(const char* newPrompt); Set ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TRint.html:13955,log,logon,13955,root/html604/TRint.html,https://root.cern,https://root.cern/root/html604/TRint.html,1,['log'],['logon']
Testability,"pq = 0); Sends all objects from the given list to the specified socket. void ProcessNext(TString* slb = 0); process the next query from the queue of submitted jobs.; to be called on the top master only. Int_t RegisterDataSets(TList* in, TList* out, TDataSetManager* dsm, TString& e); Register TFileCollections in 'out' as datasets according to the rules in 'in'. void HandleQueryList(TMessage* mess); Handle request for list of queries. void HandleRemove(TMessage* mess, TString* slb = 0); Handle remove request. void HandleRetrieve(TMessage* mess, TString* slb = 0); Handle retrieve request. void HandleLibIncPath(TMessage* mess); Handle lib, inc search paths modification request. void HandleCheckFile(TMessage* mess, TString* slb = 0); Handle file checking request. Int_t HandleCache(TMessage* mess, TString* slb = 0); Handle here all cache and package requests. Int_t HandleWorkerLists(TMessage* mess); Handle here all requests to modify worker lists. FILE * SetErrorHandlerFile(FILE* ferr); Set the file stream where to log (default stderr).; If ferr == 0 the default is restored.; Returns current setting. void ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); The PROOF error handler function. It prints the message on fgErrorHandlerFile and; if abort is set it aborts the application. Int_t CopyFromCache(const char* name, Bool_t cpbin); Retrieve any files related to 'macro' from the cache directory.; If 'cpbin' is true, the associated binaries are retrieved as well.; Returns 0 on success, -1 otherwise. Int_t CopyToCache(const char* name, Int_t opt = 0); Copy files related to 'macro' to the cache directory.; Action depends on 'opt':. opt = 0 copy 'macro' to cache and delete from cache any binary; related to name; e.g. if macro = bla.C, the binaries are; bla_C.so, bla_C.rootmap, ...; opt = 1 copy the binaries related to macro to the cache. Returns 0 on success, -1 otherwise. void MakePlayer(); Make player instance. void DeletePlayer(); Delete player in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofServ.html:28447,log,log,28447,root/html602/TProofServ.html,https://root.cern,https://root.cern/root/html602/TProofServ.html,1,['log'],['log']
Testability,"pression tree headed by this object. Bool_t checkObservables(const RooArgSet* nset) const; Overloadable function in which derived classes can implement; consistency checks of the variables. If this function returns; true, indicating an error, the fitter or generator will abort. Bool_t recursiveCheckObservables(const RooArgSet* nset) const; Recursively call checkObservables on all nodes in the expression tree. Bool_t dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) any object in the; specified collection. Uses the dependsOn(RooAbsArg&) member function. Bool_t dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) the specified object.; Note that RooAbsArg objects are considered equivalent if they have; the same name. Bool_t overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; Test if any of the nodes of tree are shared with that of the given tree. Bool_t observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables); overlaps with those of the testArg. Bool_t observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables); overlaps with those of the testArg. void setValueDirty(const RooAbsArg* source) const; Mark this object as having changed its value, and propagate this status; change to all of our clients. If the object is not in automatic dirty; state propagation mode, this call has no effect. void setShapeDirty(const RooAbsArg* source) const; Mark this object as having changed its shape, and propagate this status; change to all of our clients. Bool_t redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsArg.html:23363,test,testArg,23363,root/html528/RooAbsArg.html,https://root.cern,https://root.cern/root/html528/RooAbsArg.html,6,['test'],['testArg']
Testability,"processing block many vary greatly thereby distributing the workload rather unevenly.; If interleave is set to true, the interleave partitioning strategy is used where each partition; i takes all bins for which (ibin % ncpu == i) which is more likely to result in an even workload.; If splitCutRange is true, a different rangeName constructed as rangeName_{catName} will be used; as range definition for each index state of a RooSimultaneous. RooAbsTestStatistic(const RooAbsTestStatistic& other, const char* name = 0); Copy constructor. ~RooAbsTestStatistic(); Destructor. Double_t evaluate() const; Calculates and return value of test statistic. If the test statistic; is calculated from on a RooSimultaneous, the test statistic calculation; is performed separately on each simultaneous p.d.f component and associated; data and then combined. If the test statistic calculation is parallelized; partitions are calculated in nCPU processes and a posteriori combined. Bool_t initialize(); One-time initialization of the test statistic. Setup; infrastructure for simultaneous p.d.f processing and/or; parallelized processing if requested. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Forward server redirect calls to component test statistics. void printCompactTreeHook(ostream& os, const char* indent = """"); Add extra information on component test statistics when printing; itself as part of a tree structure. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Forward constant term optimization management calls to component; test statistics. void setMPSet(Int_t setNum, Int_t numSets); Set MultiProcessor set number identification of this instance. void initMPMode(RooAbsReal* real, RooAbsData* data, const RooArgSet* projDeps, const char* rangeName, const char* addCoefRangeName); Initialize multi-processor calculation mode. Create component test statistics in separ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsTestStatistic.html:43184,test,test,43184,root/html602/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html602/RooAbsTestStatistic.html,2,['test'],['test']
Testability,"produced; if filename contains .root, a Root file is produced; if filename contains .xml, a XML file is produced. See comments in TPad::Print for the Postscript formats. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitives in this pad on the C++ source file out. void SetFixedAspectRatio(Bool_t fixed = kTRUE); Fix pad aspect ratio to current value if fixed is true. void SetEditable(Bool_t mode = kTRUE); Set pad editable yes/no; If a pad is not editable:; - one cannot modify the pad and its objects via the mouse.; - one cannot add new objects to the pad. void SetFillStyle(Style_t fstyle); Overrride TAttFill::FillStyle for TPad because we want to handle style=0; as style 4000. void SetLogx(Int_t value = 1); Set Lin/Log scale for X; value = 0 X scale will be linear; value = 1 X scale will be logarithmic (base 10); value > 1 reserved for possible support of base e or other. void SetLogy(Int_t value = 1); Set Lin/Log scale for Y; value = 0 Y scale will be linear; value = 1 Y scale will be logarithmic (base 10); value > 1 reserved for possible support of base e or other. void SetLogz(Int_t value = 1); Set Lin/Log scale for Z. void SetPad(Double_t xlow, Double_t ylow, Double_t xup, Double_t yup); Set canvas range for pad and resize the pad. If the aspect ratio; was fixed before the call it will be un-fixed. void SetPad(const char* name, const char* title, Double_t xlow, Double_t ylow, Double_t xup, Double_t yup, Color_t color = 35, Short_t bordersize = 5, Short_t bordermode = -1); Set all pad parameters. void SetView(TView* view = 0); Set the current TView. Delete previous view if view=0. void SetAttFillPS(Color_t color, Style_t style); Set postscript fill area attributes. void SetAttLinePS(Color_t color, Style_t style, Width_t lwidth); Set postscript line attributes. void SetAttMarkerPS(Color_t color, Style_t style, Size_t msize); Set postscript marker attributes. void SetAttTextPS(Int_t align, Float_t angle, Color_t color, Style_t font, Float_t tsize); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPad.html:56999,log,logarithmic,56999,root/html528/TPad.html,https://root.cern,https://root.cern/root/html528/TPad.html,6,['log'],['logarithmic']
Testability,"producer script ;  hserv.CServer program which waits for two clients to connect ;  hserv2.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  hserv2bonj.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  LDAPExample.C;  parallelMergeClient.CClient program which creates and fills 2 histograms and a TTree ;  parallelMergeServer.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  parallelMergeTest.C;  pclient.CClient program to test parallel sockets ;  pserv.CServer program to test parallel sockets ;  spy.CClient program which allows the snooping of objects from a spyserv process ;  spyserv.CServer program which allows clients, ""spies"", to connect and snoop objects ;  TestAuth.CMacro test authentication methods stand alone ;  testTUDPSocket.CAs test echo server use udpserver.c in the same directory ;  treeClient.CClient program which creates and fills 2 histograms and a TTree ;  TUriTest.CRudimentary TUri test macro ;  udpserver.c;  ► physics;  PhaseSpace.C Example of use of TGenPhaseSpace ;  ► proof;  EmptyInclude.hEmpty file to test TProof::Load in runProof.C and StressProof.cxx in conjunction with ProcFileElements and ProofEventProc ;  finalizeProof.CMacro to finalize queries run with the macro tutorials/runProof ;  getProof.CAttaches to a PROOF session, possibly at the indicated URL ;  ProcFileElements.CClass to hold information about the processed elements of a file ;  ProcFileElements.hClass to hold information about the processed elements of a file ;  ProofAux.CSelector used for auxiliary actions in the PROOF tutorials ;  ProofAux.hSelector used for auxiliary actions in the PROOF tutorials ;  ProofEvent.CSelector for generic processing with Event ;  ProofEvent.hSelector for generic processing with Event ;  ProofEventProc.CSelector t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:135199,test,test,135199,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,5,['test'],['test']
Testability,"producing confidence intervals); RooStats::NumEventsTestStat ; RooStats::NumberCountingPdfFactory A factory specific to common number counting problems.; RooStats::NumberCountingUtils ; RooStats::PdfProposal ; RooStats::PointSetInterval Concrete implementation of ConfInterval for simple 1-D intervals in the form [a,b]; RooStats::ProfileLikelihoodCalculator A concrete implementation of CombinedCalculator that uses the ProfileLikelihood ratio.; RooStats::ProfileLikelihoodTestStat implements the profile likelihood ratio as a test statistic to be used with several tools; RooStats::ProposalFunction Interface for the proposal function used with Markov Chain Monte Carlo; RooStats::ProposalHelper ; RooStats::SPlot Class used for making sPlots; RooStats::SamplingDistPlot Class containing the results of the HybridCalculator; RooStats::SamplingDistribution Class containing the results of the HybridCalculator; RooStats::SamplingSummary A summary of acceptance regions for confidence belt; RooStats::SamplingSummaryLookup A simple class used by ConfidenceBelt; RooStats::SimpleInterval Concrete implementation of ConfInterval for simple 1-D intervals in the form [a,b]; RooStats::TestStatSampler Interface for tools setting limits (producing confidence intervals); RooStats::TestStatistic Interface for tools setting limits (producing confidence intervals); RooStats::ToyMCSampler A simple implementation of the TestStatSampler interface; RooStats::UniformProposal A concrete implementation of ProposalFunction, that uniformly samples the parameter space.; RooStats::UpperLimitMCSModule MCStudy module to calculate upperlimit of a given poi; RooStepFunction Step Function; RooStreamParser Utility class that parses iostream data into tokens; RooStringVar String-valued variable ; RooStudyManager A general purpose workspace oriented parallelizing study manager; RooStudyPackage A general purpose workspace oriented parallelizing study manager; RooSuperCategory Lvalue product operator for catategory ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ClassIndex.html:44938,test,test,44938,root/html526/ClassIndex.html,https://root.cern,https://root.cern/root/html526/ClassIndex.html,1,['test'],['test']
Testability,"program for the TMatrix class. vvector.cxx; Verification program for the TVectorclass. vlazy.cxx; Verification program for lazy matrices. hworld.cxx; Small program showing basic graphics. guitest.cxx; Example usage of the ROOT GUI classes. gui viewer .cxx; Another ROOT GUI example program. Hello.cxx; Dancing text example. Aclock.cxx; Analog clock (a la X11 xclock). Tetris.cxx; The known Tetris game based on the ROOT graphics. stress.cxx; Important ROOT stress testing program. stress*.cxx; Stress testing of different ROOT classes. bench.cxx; STL and ROOT container test and benchmarking program. QpRandomDriver.cx x; Verification program for Quadratic programming classes in Quadp library. DrawTest.sh; Entry script to extensive TTree query test suite. dt_*; Scripts used by DrawTest.sh. The $ROOTSYS/test directory is a gold mine of root-wisdom nuggets, and we encourage you to explore and exploit it. These instructions will compile all programs in $ROOTSYS/test:; If you do not have write permission in the $ROOTSYS/test directory, copy the entire $ROOTSYS/test directory to your area. The Makefile is a useful example of how ROOT applications are linked and built. Edit the Makefile to specify your architecture by changing the ARCH variable, for example, on an SGI machine type:ARCH = sgikcc.; Now compile all programs:; % gmake; This will build several applications and shared libraries. We are especially interested in Event, stress, and guitest.; 20.2.1 Event - An Example of a ROOT Application; Event is created by compiling MainEvent.cxx, and Event.cxx. It creates a ROOT file with a tree and two histograms. When running Event we have four optional arguments with defaults:. Argument; Default. 1; Number of Events (1 … n); 400. 2; Compression level:; 0: no compression at all.; 1: If the split level is set to zero, everything is compressed according to the gzip level 1. If split level is set to 1, leaves that are not floating point numbers are compressed using the gzip level 1.; 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1077225,test,test,1077225,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,3,['test'],['test']
Testability,"protected . Training sample, error in quantity. ; Definition at line 29 of file TMultiDimFit.h. ◆ fSumSqAvgQuantity. Double_t TMultiDimFit::fSumSqAvgQuantity. protected . Sum of squares away from mean. ; Definition at line 34 of file TMultiDimFit.h. ◆ fSumSqQuantity. Double_t TMultiDimFit::fSumSqQuantity. protected . SumSquare of dependent quantity. ; Definition at line 33 of file TMultiDimFit.h. ◆ fSumSqResidual. Double_t TMultiDimFit::fSumSqResidual. protected . Sum of Square residuals. ; Definition at line 77 of file TMultiDimFit.h. ◆ fTestCorrelationCoeff. Double_t TMultiDimFit::fTestCorrelationCoeff. protected . Multi Correlation coefficient. ; Definition at line 94 of file TMultiDimFit.h. ◆ fTestError. Double_t TMultiDimFit::fTestError. protected . Error from test. ; Definition at line 89 of file TMultiDimFit.h. ◆ fTestPrecision. Double_t TMultiDimFit::fTestPrecision. protected . Relative precision of test. ; Definition at line 91 of file TMultiDimFit.h. ◆ fTestQuantity. TVectorD TMultiDimFit::fTestQuantity. protected . Test sample, dependent quantity. ; Definition at line 44 of file TMultiDimFit.h. ◆ fTestSampleSize. Int_t TMultiDimFit::fTestSampleSize. protected . Size of test sample. ; Definition at line 48 of file TMultiDimFit.h. ◆ fTestSqError. TVectorD TMultiDimFit::fTestSqError. protected . Test sample, Error in quantity. ; Definition at line 45 of file TMultiDimFit.h. ◆ fTestVariables. TVectorD TMultiDimFit::fTestVariables. protected . Test sample, independent variables. ; Definition at line 46 of file TMultiDimFit.h. ◆ fVariables. TVectorD TMultiDimFit::fVariables. protected . Training sample, independent variables. ; Definition at line 36 of file TMultiDimFit.h. Libraries for TMultiDimFit:. [legend]; The documentation for this class was generated from the following files:; hist/hist/inc/TMultiDimFit.h; hist/hist/src/TMultiDimFit.cxx. TMultiDimFit. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:00 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiDimFit.html:69356,test,test,69356,doc/master/classTMultiDimFit.html,https://root.cern,https://root.cern/doc/master/classTMultiDimFit.html,1,['test'],['test']
Testability,"prune a decision tree using the expected error (C4.5) method. ; Uses an upper limit on the error made by the classification done by each node. If the \( \frac{S}{S+B} \) of the node is \( f \), then according to the training sample, the error rate (fraction of misclassified events by this node) is \( (1-f) \). Now \( f \) has a statistical error according to the binomial distribution hence the error on \( f \) can be estimated (same error as the binomial error for efficiency calculations \( (\sigma = \sqrt{\frac{(eff(1-eff)}{nEvts}}) \); This tool prunes branches from a tree if the expected error of a node is less than that of the sum of the error in its descendants. ; Definition at line 54 of file ExpectedErrorPruneTool.h. Public Member Functions;  ExpectedErrorPruneTool ();  ; virtual ~ExpectedErrorPruneTool ();  ; virtual PruningInfo * CalculatePruningInfo (DecisionTree *dt, const IPruneTool::EventSample *testEvents=nullptr, Bool_t isAutomatic=kFALSE);  ; void SetPruneStrengthIncrement (Double_t dalpha);  ;  Public Member Functions inherited from TMVA::IPruneTool;  IPruneTool ();  ; virtual ~IPruneTool ();  ; Double_t GetPruneStrength () const;  ; Bool_t IsAutomatic () const;  ; void SetAutomatic ();  ; void SetPruneStrength (Double_t alpha);  . Private Member Functions; Int_t CountNodes (DecisionTreeNode *node, Int_t icount=0);  ; void FindListOfNodes (DecisionTreeNode *node);  recursive pruning of nodes using the Expected Error Pruning (EEP) ;  ; Double_t GetNodeError (DecisionTreeNode *node) const;  Calculate an UPPER limit on the error made by the classification done by this node. ;  ; Double_t GetSubTreeError (DecisionTreeNode *node) const;  calculate the expected statistical error on the subtree below ""node"" which is used in the expected error pruning ;  ; MsgLogger & Log () const;  . Private Attributes; Double_t fDeltaPruneStrength;  ! the stepsize for optimizing the pruning strength parameter ;  ; MsgLogger * fLogger;  ! message logger ;  ; Double_t fNodeP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1ExpectedErrorPruneTool.html:1249,test,testEvents,1249,doc/master/classTMVA_1_1ExpectedErrorPruneTool.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1ExpectedErrorPruneTool.html,1,['test'],['testEvents']
Testability,"ps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooPolyVar&operator=(const RooPolyVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooPolyVar.html:19516,test,testArg,19516,root/html602/RooPolyVar.html,https://root.cern,https://root.cern/root/html602/RooPolyVar.html,2,['test'],['testArg']
Testability,"ps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooPullVar&operator=(const RooPullVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooPullVar.html:19656,test,testArg,19656,root/html602/RooPullVar.html,https://root.cern,https://root.cern/root/html602/RooPullVar.html,2,['test'],['testArg']
Testability,"ps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRealVar&operator=(const RooRealVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealVar.html:23447,test,testArg,23447,root/html602/RooRealVar.html,https://root.cern,https://root.cern/root/html602/RooRealVar.html,2,['test'],['testArg']
Testability,psed time for evaluation of 9000 events: 0.0918 sec ; : Create variable histograms; : Create regression target histograms; : Create regression average deviation; : Results created; Factory : Test method: LD for Regression performance; : ; : Dataset[datasetreg] : Create results for testing; : Dataset[datasetreg] : Evaluation of LD on testing sample; : Dataset[datasetreg] : Elapsed time for evaluation of 9000 events: 0.00483 sec ; : Create variable histograms; : Create regression target histograms; : Create regression average deviation; : Results created; Factory : Test method: DNN_CPU for Regression performance; : ; : Dataset[datasetreg] : Create results for testing; : Dataset[datasetreg] : Evaluation of DNN_CPU on testing sample; : Dataset[datasetreg] : Elapsed time for evaluation of 9000 events: 0.231 sec ; : Create variable histograms; : Create regression target histograms; : Create regression average deviation; : Results created; Factory : Test method: BDTG for Regression performance; : ; : Dataset[datasetreg] : Create results for testing; : Dataset[datasetreg] : Evaluation of BDTG on testing sample; : Dataset[datasetreg] : Elapsed time for evaluation of 9000 events: 2.1 sec ; : Create variable histograms; : Create regression target histograms; : Create regression average deviation; : Results created; Factory : ␛[1mEvaluate all methods␛[0m; : Evaluate regression method: PDEFoam; : TestRegression (testing); : Calculate regression for all events; : Elapsed time for evaluation of 9000 events: 0.0447 sec ; : TestRegression (training); : Calculate regression for all events; : Elapsed time for evaluation of 1000 events: 0.00684 sec ; TFHandler_PDEFoam : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 3.3352 1.1893 [ 0.00020069 5.0000 ]; : var2: 2.4860 1.4342 [ 0.00071490 5.0000 ]; : fvalue: 163.91 83.651 [ 1.6186 394.84 ]; : -----------------------------------------------------------; : Evaluate regression method: KN,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:128763,test,testing,128763,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,2,['test'],['testing']
Testability,"pt calculates the bandwidth for filling and retrieving bin contents (in million entries per second) for these two histogramming techniques, where ""seconds"" is CPU and real time.; The first line of the plots contains the bandwidth based on the CPU time (THnSpase, TH1/2/3/nF*, ratio), the second line shows the plots for real time, and the third line shows the fraction of filled bins and memory used by THnSparse vs. TH1/2/3/nF.; The timing depends on the distribution and the amount of entries in the histograms; here, a Gaussian distribution (center is contained in the histograms) is used to fill each histogram with 1000 entries. The filling and reading is repeated until enough statistics have been collected.; tutorials/tree/drawsparse.C shows an example for visualizing a THnSparse. It creates a TTree which is then drawn using TParallelCoord.; This macro should be run in compiled mode due to the many nested loops that force CLING to disable its optimization. If run interpreted one would not benchmark THnSparse but CLING.; Run as: root[0] .L $ROOTSYS/tutorials/hist/sparsehist.C+; root[1] sparsehist(); ; #include ""TH1.h""; #include ""TH2.h""; #include ""TH3.h""; #include ""THn.h""; #include ""THnSparse.h""; #include ""TStopwatch.h""; #include ""TRandom.h""; #include ""TCanvas.h""; #include ""TFile.h""; #include ""TStyle.h""; #include ""TSystem.h""; ; #ifndef INT_MAX; #define INT_MAX std::numeric_limits<int>::max(); #endif; ; class TTimeHists {; public:; enum EHist { kHist, kSparse, kNumHist };; enum ETime { kReal, kCPU, kNumTime };; TTimeHists(Int_t dim, Int_t bins, Long_t num):; fValue(nullptr), fDim(dim), fBins(bins), fNum(num),; fSparse(nullptr), fHist(nullptr), fHn(nullptr) {}; ~TTimeHists();; bool Run();; Double_t GetTime(EHist hist, ETime time) const {; if (time == kReal) return fTime[hist][0];; return fTime[hist][1]; }; static void SetDebug(Int_t lvl) { fgDebug = lvl; }; THnSparse* GetSparse() const { return fSparse; }; ; protected:; void Fill(EHist hist);; Double_t Check(EHist hist);;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/sparsehist_8C.html:1340,benchmark,benchmark,1340,doc/master/sparsehist_8C.html,https://root.cern,https://root.cern/doc/master/sparsehist_8C.html,1,['benchmark'],['benchmark']
Testability,"ption ""t"" returns the test statistic value specific to the test type. ; Definition at line 225 of file GoFTest.cxx. ◆ operator=(). GoFTest ROOT::Math::GoFTest::operator= ; (; GoFTest & ; gof). private . Disallowed assign operator. . ◆ PValueAD1Sample(). Double_t ROOT::Math::GoFTest::PValueAD1Sample ; (; Double_t ; A2); const. private . Computation of the 1-Sample Anderson-Darling Test's p-value. ; Definition at line 483 of file GoFTest.cxx. ◆ PValueADKSamples(). Double_t ROOT::Math::GoFTest::PValueADKSamples ; (; size_t ; nsamples, . Double_t ; A2 . ). static . Computation of the K-Sample Anderson-Darling Test's p-value as described in (1) ; Definition at line 353 of file GoFTest.cxx. ◆ SetCDF(). void ROOT::Math::GoFTest::SetCDF ; (; ). private . Definition at line 244 of file GoFTest.cxx. ◆ SetDistribution(). void ROOT::Math::GoFTest::SetDistribution ; (; EDistribution ; dist, . const std::vector< double > & ; distParams = {} . ). Sets the distribution for the predefined distribution types and optionally its parameters for 1-sample tests. ; Definition at line 124 of file GoFTest.cxx. ◆ SetDistributionFunction(). void ROOT::Math::GoFTest::SetDistributionFunction ; (; const IGenFunction & ; cdf, . Bool_t ; isPDF, . Double_t ; xmin, . Double_t ; xmax . ). private . Definition at line 267 of file GoFTest.cxx. ◆ SetParameters(). void ROOT::Math::GoFTest::SetParameters ; (; const std::vector< double > & ; params). private . Sets the distribution parameters. ; Definition at line 204 of file GoFTest.cxx. ◆ SetSamples(). void ROOT::Math::GoFTest::SetSamples ; (; std::vector< const Double_t * > ; samples, . const std::vector< size_t > ; samplesSizes . ). private . set a vector of samples ; Definition at line 181 of file GoFTest.cxx. ◆ SetUserCDF() [1/2]. void ROOT::Math::GoFTest::SetUserCDF ; (; const IGenFunction & ; cdf, . Double_t ; xmin = 1, . Double_t ; xmax = 0 . ). inline . Specialization to set the user input distribution as a cumulative distribution function for 1-s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GoFTest.html:17716,test,tests,17716,doc/master/classROOT_1_1Math_1_1GoFTest.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GoFTest.html,1,['test'],['tests']
Testability,"ption ""t"" returns the test statistic value specific to the test type. ;  ; void SetDistribution (EDistribution dist, const std::vector< double > &distParams={});  Sets the distribution for the predefined distribution types and optionally its parameters for 1-sample tests. ;  ; void SetUserCDF (const IGenFunction &cdf, Double_t xmin=1, Double_t xmax=0);  Specialization to set the user input distribution as a cumulative distribution function for 1-sample tests. ;  ; template<class Dist > ; void SetUserCDF (Dist &cdf, Double_t xmin=1, Double_t xmax=0);  Sets the user input distribution as a cumulative distribution function for 1-sample tests. ;  ; void SetUserDistribution (const IGenFunction &dist, GoFTest::EUserDistribution userDist=kPDF, Double_t xmin=1, Double_t xmax=0);  Sets the user input distribution function for 1-sample test using the ROOT::Math::IGenFunction interface. ;  ; template<class Dist > ; void SetUserDistribution (Dist &dist, EUserDistribution userDist=kPDF, Double_t xmin=1, Double_t xmax=0);  Sets the user input distribution function for 1-sample test as a generic functor object. ;  ; void SetUserPDF (const IGenFunction &pdf, Double_t xmin=1, Double_t xmax=0);  Specialization to set the user input distribution as a probability density function for 1-sample tests using the ROOT::Math::IGenFunction interface. ;  ; template<class Dist > ; void SetUserPDF (Dist &pdf, Double_t xmin=1, Double_t xmax=0);  Sets the user input distribution as a probability density function for 1-sample tests. ;  . Static Public Member Functions; static void AndersonDarling2SamplesTest (const ROOT::Fit::BinData &data1, const ROOT::Fit::BinData &data2, Double_t &pvalue, Double_t &testStat);  Compute the 2-Sample Anderson Darling test for binned data assuming equal data are present at the bin center values. ;  ; static Double_t PValueADKSamples (size_t nsamples, Double_t A2);  Computation of the K-Sample Anderson-Darling Test's p-value as described in (1) ;  . Private Member Fun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GoFTest.html:5243,test,test,5243,doc/master/classROOT_1_1Math_1_1GoFTest.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GoFTest.html,1,['test'],['test']
Testability,"ption = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetEpsilon(Double_t eps); voidSetEta(Double_t eta); voidSetEtaDecay(Double_t ed); voidSetEventWeight(const char*); voidSetLearningMethod(TMultiLayerPerceptron::ELearningMethod method); static voidTObject::SetObjectStat(Bool_t stat); voidSetReset(Int_t reset); voidSetTau(Double_t tau); voidSetTestDataSet(TEventList* test); voidSetTestDataSet(const char* test); voidSetTrainingDataSet(TEventList* train); voidSetTrainingDataSet(const char* train); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TMultiLayerPerceptron(); TMultiLayerPerceptron(const char* layout, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); TMultiLayerPerceptron(const char* layout, TTree* data, TEventList* training, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data, TEventList* training, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); voidTrain(Int_t nEpoch, Option_t* option = ""text"", Double_t minE = 0); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMultiLayerPerceptron.html:14385,test,test,14385,root/html602/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html602/TMultiLayerPerceptron.html,2,['test'],['test']
Testability,"ption = 0, Int_t bufsize = 0) const; voidWriteOptionsToStream(ostream& o, const TString& prefix) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidEnableLooseOptions(Bool_t b = kTRUE); const TString&GetReferenceFile() const; TMVA::MsgLogger&Log() const; Bool_tLooseOptionCheckingEnabled() const; voidTObject::MakeZombie(); voidResetSetFlag(); voidWriteOptionsReferenceToFile(). private:. voidSplitOptions(const TString& theOpt, TList& loo) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TStringfConfigDescriptiondescription of this configurable; TStringfConfigNamethe name of this configurable; TMVA::OptionBase*fLastDeclaredOption! last declared option; TListfListOfOptions! option list; TMVA::MsgLogger*fLogger! message logger; Bool_tfLooseOptionCheckingEnabled! checker for option string; TStringfOptions! options string; TStringfReferenceFilereference file for options writing. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Configurable(const TString& theOption = """"); constructor. ~Configurable(); default destructur. void SplitOptions(const TString& theOpt, TList& loo) const; splits the option string at ':' and fills the list 'loo' with the primitive strings. void ResetSetFlag(); resets the IsSet falg for all declare options; to be called before options are read from stream. void ParseOptions(); options parser. void CheckForUnusedOptions() const; checks for unused options in option string. void PrintOptions() const; prints out the options set in the options string and the defaults. void WriteOptionsToStream(ostream& o, const TString& prefix) const; write options to output stream (e.g. in writing the MVA weight files. void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__Configurable.html:6122,log,logger,6122,root/html528/TMVA__Configurable.html,https://root.cern,https://root.cern/root/html528/TMVA__Configurable.html,4,['log'],['logger']
Testability,ption.cxx;  TExec.cxx;  TFileCollection.cxx;  TFileInfo.cxx;  TFolder.cxx;  TGuiFactory.cxx;  TInetAddress.cxx;  TInspectorImp.cxx;  TListOfTypes.cxx;  TListOfTypes.h;  TMacro.cxx;  TMathBase.cxx;  TMD5.cxx;  TMemberInspector.cxx;  TMessageHandler.cxx;  TNamed.cxx;  TObject.cxx;  TObjectSpy.cxx;  TObjString.cxx;  TParameter.cxx;  TPluginManager.cxx;  TPRegexp.cxx;  TProcessID.cxx;  TProcessUUID.cxx;  TQCommand.cxx;  TQConnection.cxx;  TQObject.cxx;  TRef.cxx;  TRefCnt.cxx;  TRegexp.cxx;  TRemoteObject.cxx;  TROOT.cxx;  TStopwatch.cxx;  TStorage.cxx;  TString.cxx;  TStringLong.cxx;  TStyle.cxx;  TSysEvtHandler.cxx;  TSystem.cxx;  TSystemDirectory.cxx;  TSystemFile.cxx;  TTask.cxx;  TTime.cxx;  TTimer.cxx;  TTimeStamp.cxx;  TUri.cxx;  TUrl.cxx;  TUUID.cxx;  TVirtualFFT.cxx;  TVirtualGL.cxx;  TVirtualMonitoring.cxx;  TVirtualMutex.cxx;  TVirtualPad.cxx;  TVirtualPadEditor.cxx;  TVirtualPadPainter.cxx;  TVirtualPerfStats.cxx;  TVirtualPS.cxx;  TVirtualViewer3D.cxx;  TVirtualX.cxx;  ► test;  TNamedTests.cxx;  TQObjectTests.cxx;  ► v7;  ► inc;  ► ROOT;  impl_tuple_apply.hxx;  RTupleApply.hxx;  TDirectory.hxx;  TDirectoryEntry.hxx;  TDrawable.hxx;  TIndexIter.hxx;  TLogger.hxx;  ► src;  TDrawable.cxx;  TLogger.cxx;  ► cont;  ► inc;  ► ROOT;  TSeq.hxx;  TArray.h;  TArrayC.h;  TArrayD.h;  TArrayF.h;  TArrayI.h;  TArrayL.h;  TArrayL64.h;  TArrayS.h;  TBits.h;  TBtree.h;  TClassTable.h;  TClonesArray.h;  TCollection.h;  TCollectionProxyInfo.h;  TExMap.h;  THashList.h;  THashTable.h;  TIterator.h;  TList.h;  TMap.h;  TObjArray.h;  TObjectTable.h;  TOrdCollection.h;  TRefArray.h;  TRefTable.h;  TSeqCollection.h;  TSortedList.h;  TVirtualCollectionProxy.h;  ► src;  TArray.cxx;  TArrayC.cxx;  TArrayD.cxx;  TArrayF.cxx;  TArrayI.cxx;  TArrayL.cxx;  TArrayL64.cxx;  TArrayS.cxx;  TBits.cxx;  TBtree.cxx;  TClassTable.cxx;  TClonesArray.cxx;  TCollection.cxx;  TExMap.cxx;  THashList.cxx;  THashTable.cxx;  TIterator.cxx;  TList.cxx;  TMap.cxx;  TObjArray.cxx;  TObjectTable.cxx;  TOrdColl,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:5387,test,test,5387,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['test'],['test']
Testability,"ption; function members; data members; class charts. ROOT; » GUI; » RECORDER; » TRecExtraEvent. class TRecExtraEvent: public TRecEvent. ROOT EVENT RECORDING SYSTEM. TRecorder class provides interface for recording and replaying; events in ROOT.; Recorded events are:; - Commands typed by user in commandline ('new TCanvas'); - GUI events (mouse movement, button clicks, ...). All the recorded events from one session are stored in one TFile; and can be replayed again anytime. Recording. 1] To start recording. TRecorder r(const char *filename, ""NEW""); TRecorder r(const char *filename, ""RECREATE""). or:. TRecorder *recorder = new TRecorder;; recorder->Start(const char *filename, ...). -filename Name of ROOT file in which to save; recorded events. 2] To stop recording. recorder->Stop(). IMPORTANT:; State capturing is part of recording. It means that if you want to; record events for some object (window), creation of this object; must be also recorded. Example:. t = new TRecorder(); // Create a new recorder; t->Start(""logfile.root""); // ! Start recording first. c = new TCanvas(); // ! Then, create an object; c->Dump(); // Work with that object. t->Stop(); // Stop recording. It is strongly recommended to start recording with empty ROOT; environment, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows dur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRecExtraEvent.html:1171,log,logfile,1171,root/html528/TRecExtraEvent.html,https://root.cern,https://root.cern/root/html528/TRecExtraEvent.html,6,['log'],['logfile']
Testability,"ption_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; RooAbsReal&nll(); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& te",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HistFactory__RooBarlowBeestonLL.html:18658,test,testArg,18658,root/html534/RooStats__HistFactory__RooBarlowBeestonLL.html,https://root.cern,https://root.cern/root/html534/RooStats__HistFactory__RooBarlowBeestonLL.html,1,['test'],['testArg']
Testability,"ption_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; RooAbsReal&nll(); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooStats::HistFactory::RooBarlowBeestonLL&operator=(const RooStats::HistFactory::RooBarlowBeestonLL&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HistFactory__RooBarlowBeestonLL.html:18653,test,testArg,18653,root/html602/RooStats__HistFactory__RooBarlowBeestonLL.html,https://root.cern,https://root.cern/root/html602/RooStats__HistFactory__RooBarlowBeestonLL.html,2,['test'],['testArg']
Testability,"ption_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); virtual Int_tnumBins(const char* rangeName = 0) const; virtual Int_tnumBins(const RooAbsBinning& binning) const; Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual RooAbsArg&operator=(const RooAbsReal& other); virtual RooAbsArg&operator=(Double_t newValue); virtual RooAbsArg&operator=(Int_t ival); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsRealLValue.html:21929,test,testArg,21929,root/html534/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html534/RooAbsRealLValue.html,1,['test'],['testArg']
Testability,"ption_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); virtual Int_tnumBins(const char* rangeName = 0) const; virtual Int_tnumBins(const RooAbsBinning& binning) const; Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual RooAbsArg&operator=(const RooAbsReal& other); virtual RooAbsArg&operator=(Double_t newValue); virtual RooAbsArg&operator=(Int_t ival); RooAbsRealLValue&operator=(const RooAbsRealLValue&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsRealLValue.html:21927,test,testArg,21927,root/html602/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html602/RooAbsRealLValue.html,2,['test'],['testArg']
Testability,"ptionsReferenceToFile(). private:. virtual voidDeclareOptions(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTMVA::FitterBase::fClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&TMVA::FitterBase::fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*TMVA::FitterBase::fLoggermessage logger; Int_tTMVA::FitterBase::fNparsnumber of parameters; const vector<TMVA::Interval*>TMVA::FitterBase::fRangesallowed intervals. private:. Double_tfAdaptiveSpeedhow fast temperature change in adaptive (in adaptive two variables describe; Double_tfEpsrelative required FCN accuracy at minimum; Double_tfInitialTemperatureinitial temperature (depends on FCN); TStringfKernelTemperatureSstring just to set fKernelTemperature; Int_tfMaxCallsmax number of FCN calls; Double_tfMinTemperatureminimum temperature before SA quit; Double_tfTemperatureAdaptiveStepused to calculate InitialTemperature if fUseDefaultTemperature; Double_tfTemperatureScalehow fast temperature change; Bool_tfUseDefaultScaleif TRUE, SA calculates its own TemperatureScale; Bool_tfUseDefaultTemperatureif TRUE, SA calculates its own InitialTemperature (MinTemperautre). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimulatedAnnealingFitter(TMVA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__SimulatedAnnealingFitter.html:8189,log,logger,8189,root/html602/TMVA__SimulatedAnnealingFitter.html,https://root.cern,https://root.cern/root/html602/TMVA__SimulatedAnnealingFitter.html,2,['log'],['logger']
Testability,"ptionsReferenceToFile(). private:. virtual voidDeclareOptions(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTMVA::FitterBase::fClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&TMVA::FitterBase::fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*TMVA::FitterBase::fLoggermessage logger; Int_tTMVA::FitterBase::fNparsnumber of parameters; const vector<TMVA::Interval*>TMVA::FitterBase::fRangesallowed intervals. private:. Double_tfConvCritimprovements bigger than fConvCrit are counted as ""improvement""; Int_tfCyclesnumber of (nearly) independent calculation cycles; Int_tfNstepsconvergence criteria: if no improvements > fConvCrit was achieved within the last fNsteps: cycle has ""converged""; Int_tfPopSizenumber of individuals to start with; Double_tfSC_factor... with fSC_factor; if there were less improvements: divide by that factor; if there were exactly fSC_rate improvements, dont change anything; Int_tfSC_rate... fSC_rate improvements, than multiply the sigma of the gaussion which defines how the random numbers are generated ...; Int_tfSC_stepsregulates how strong the mutations for the coordinates are: if within fSC_steps there were more than...; Int_tfSaveBestFromCyclestore the best individuals from one cycle (these are inclu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__GeneticFitter.html:7983,log,logger,7983,root/html602/TMVA__GeneticFitter.html,https://root.cern,https://root.cern/root/html602/TMVA__GeneticFitter.html,2,['log'],['logger']
Testability,"ptionsReferenceToFile(). private:. virtual voidDeclareOptions(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTMVA::FitterBase::fClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&TMVA::FitterBase::fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*TMVA::FitterBase::fLoggermessage logger; Int_tTMVA::FitterBase::fNparsnumber of parameters; const vector<TMVA::Interval*>TMVA::FitterBase::fRangesallowed intervals. private:. Int_tfSamplesnumber of MC samples; UInt_tfSeedSeed for the random generator (0 takes random seeds); Double_tfSigmanew samples are generated randomly with a gaussian probability with fSigma around the current best value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MCFitter(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*>& ranges, const TString& theOption); constructor. void DeclareOptions(); Declare MCFitter options. void SetParameters(Int_t cycles); set MC fitter configuration parameters. Double_t Run(vector<Double_t>& pars); Execute fitting. MCFitter(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*>& ranges, const TString& theOption); {}. » Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Hel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MCFitter.html:7804,log,logger,7804,root/html602/TMVA__MCFitter.html,https://root.cern,https://root.cern/root/html602/TMVA__MCFitter.html,2,['log'],['logger']
Testability,"ptor(). Int_t AddAt(const void* c). void AddAt(const void* c, Int_t i). void AddAt(const tableDescriptor_st& element, const char* comment, Int_t indx). void AddAt(TDataSet* dataset, Int_t idx = 0). TString CreateLeafList() const. void LearnTable(const TTable* parentTable). void LearnTable(TClass* classPtr). Int_t ColumnByName(const Char_t* columnName = 0) const. UInt_t Offset(Int_t column) const. UInt_t ColumnSize(Int_t column) const. UInt_t TypeSize(Int_t column) const. UInt_t Dimensions(Int_t column) const. Int_t Sizeof() const. Int_t UpdateOffsets(const TTableDescriptor* newDesciptor). TTableDescriptor * MakeDescriptor(const char* structName). TDataSet * MakeCommentField(Bool_t createFlag = kTRUE). TTableDescriptor * GetDescriptorPointer() const. void SetDescriptorPointer(TTableDescriptor* list). TTableDescriptor(); {SetType(""tableDescriptor_st"");}. TTableDescriptor(const char* name); {SetType(""tableDescriptor_st"");}. TTableDescriptor(Int_t n); {SetType(""tableDescriptor_st"");}. TTableDescriptor(const char* name, Int_t n); {SetType(""tableDescriptor_st"");}. tableDescriptor_st * GetTable(Int_t i = 0) const; { return ((tableDescriptor_st *)GetArray())+i;}. tableDescriptor_st & operator[](Int_t i); { assert(i>=0 && i < GetNRows()); return *GetTable(i); }. const tableDescriptor_st & operator[](Int_t i) const; { assert(i>=0 && i < GetNRows()); return *((const tableDescriptor_st *)(GetTable(i))); }. tableDescriptor_st * begin() const; { return GetNRows()? GetTable(0):0;}. tableDescriptor_st * end() const; {Long_t i = GetNRows(); return i? GetTable(i):0;}. const char * TableDictionary(). » Author: Valery Fine 09/08/99 (E-mail: fine@bnl.gov) » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/table:$Id: TTableDescriptor.h 27157 2009-01-15 14:05:12Z brun $ » Last generated: 2010-09-23 20:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTableDescriptor.html:18328,assert,assert,18328,root/html528/TTableDescriptor.html,https://root.cern,https://root.cern/root/html528/TTableDescriptor.html,2,['assert'],['assert']
Testability,"ptor(). Int_t AddAt(const void* c). void AddAt(const void* c, Int_t i). void AddAt(const tableDescriptor_st& element, const char* comment, Int_t indx). void AddAt(TDataSet* dataset, Int_t idx = 0). TString CreateLeafList() const. void LearnTable(const TTable* parentTable). void LearnTable(TClass* classPtr). Int_t ColumnByName(const Char_t* columnName = 0) const. UInt_t Offset(Int_t column) const. UInt_t ColumnSize(Int_t column) const. UInt_t TypeSize(Int_t column) const. UInt_t Dimensions(Int_t column) const. Int_t Sizeof() const. Int_t UpdateOffsets(const TTableDescriptor* newDesciptor). TTableDescriptor * MakeDescriptor(const char* structName). TDataSet * MakeCommentField(Bool_t createFlag = kTRUE). TTableDescriptor * GetDescriptorPointer() const. void SetDescriptorPointer(TTableDescriptor* list). TTableDescriptor(); {SetType(""tableDescriptor_st"");}. TTableDescriptor(const char* name); {SetType(""tableDescriptor_st"");}. TTableDescriptor(Int_t n); {SetType(""tableDescriptor_st"");}. TTableDescriptor(const char* name, Int_t n); {SetType(""tableDescriptor_st"");}. tableDescriptor_st * GetTable(Int_t i = 0) const; { return ((tableDescriptor_st *)GetArray())+i;}. tableDescriptor_st & operator[](Int_t i); { assert(i>=0 && i < GetNRows()); return *GetTable(i); }. const tableDescriptor_st & operator[](Int_t i) const; { assert(i>=0 && i < GetNRows()); return *((const tableDescriptor_st *)(GetTable(i))); }. tableDescriptor_st * begin() const; { return GetNRows()? GetTable(0):0;}. tableDescriptor_st * end() const; {Long_t i = GetNRows(); return i? GetTable(i):0;}. const char * TableDictionary(). » Author: Valery Fine 09/08/99 (E-mail: fine@bnl.gov) » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/table:$Id: TTableDescriptor.h 27157 2009-01-15 14:05:12Z brun $ » Last generated: 2011-07-04 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTableDescriptor.html:18430,assert,assert,18430,root/html530/TTableDescriptor.html,https://root.cern,https://root.cern/root/html530/TTableDescriptor.html,2,['assert'],['assert']
Testability,"ptor(). Int_t AddAt(const void* c). void AddAt(const void* c, Int_t i). void AddAt(const tableDescriptor_st& element, const char* comment, Int_t indx). void AddAt(TDataSet* dataset, Int_t idx = 0). TString CreateLeafList() const. void LearnTable(const TTable* parentTable). void LearnTable(TClass* classPtr). Int_t ColumnByName(const Char_t* columnName = 0) const. UInt_t Offset(Int_t column) const. UInt_t ColumnSize(Int_t column) const. UInt_t TypeSize(Int_t column) const. UInt_t Dimensions(Int_t column) const. Int_t Sizeof() const. Int_t UpdateOffsets(const TTableDescriptor* newDesciptor). TTableDescriptor * MakeDescriptor(const char* structName). TDataSet * MakeCommentField(Bool_t createFlag = kTRUE). TTableDescriptor * GetDescriptorPointer() const. void SetDescriptorPointer(TTableDescriptor* list). TTableDescriptor(); {SetType(""tableDescriptor_st"");}. TTableDescriptor(const char* name); {SetType(""tableDescriptor_st"");}. TTableDescriptor(Int_t n); {SetType(""tableDescriptor_st"");}. TTableDescriptor(const char* name, Int_t n); {SetType(""tableDescriptor_st"");}. tableDescriptor_st * GetTable(Int_t i = 0) const; { return ((tableDescriptor_st *)GetArray())+i;}. tableDescriptor_st & operator[](Int_t i); { assert(i>=0 && i < GetNRows()); return *GetTable(i); }. const tableDescriptor_st & operator[](Int_t i) const; { assert(i>=0 && i < GetNRows()); return *((const tableDescriptor_st *)(GetTable(i))); }. tableDescriptor_st * begin() const; { return GetNRows()? GetTable(0):0;}. tableDescriptor_st * end() const; {Long_t i = GetNRows(); return i? GetTable(i):0;}. const char * TableDictionary(). » Author: Valery Fine 09/08/99 (E-mail: fine@bnl.gov) » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/table:$Id: TTableDescriptor.h 27157 2009-01-15 14:05:12Z brun $ » Last generated: 2011-11-03 20:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTableDescriptor.html:18430,assert,assert,18430,root/html532/TTableDescriptor.html,https://root.cern,https://root.cern/root/html532/TTableDescriptor.html,2,['assert'],['assert']
Testability,"ptr) const;  ; void ForceNetworkCalculations ();  calculate input values to each neuron ;  ; void ForceNetworkInputs (const Event *ev, Int_t ignoreIndex=-1);  force the input values of the input neurons force the value for each input neuron ;  ; TNeuron * GetInputNeuron (Int_t index);  ; Double_t GetNetworkOutput ();  ; TNeuron * GetOutputNeuron (Int_t index=0);  ; Int_t NumCycles ();  ; std::vector< Int_t > * ParseLayoutString (TString layerSpec);  parse layout specification string and return a vector, each entry containing the number of neurons to go in each successive layer ;  ; void PrintMessage (TString message, Bool_t force=kFALSE) const;  print messages, turn off printing by setting verbose and debug flag appropriately ;  ; void WaitForKeyboard ();  wait for keyboard input, for debugging ;  ;  Protected Member Functions inherited from TMVA::MethodBase; virtual std::vector< Double_t > GetDataMvaValues (DataSet *data=nullptr, Long64_t firstEvt=0, Long64_t lastEvt=-1, Bool_t logProgress=false);  get all the MVA values for the events of the given Data type ;  ; const TString & GetInternalVarName (Int_t ivar) const;  ; virtual std::vector< Double_t > GetMvaValues (Long64_t firstEvt=0, Long64_t lastEvt=-1, Bool_t logProgress=false);  get all the MVA values for the events of the current Data type ;  ; const TString & GetOriginalVarName (Int_t ivar) const;  ; const TString & GetWeightFileDir () const;  ; Bool_t HasTrainingTree () const;  ; Bool_t Help () const;  ; Bool_t IgnoreEventsWithNegWeightsInTraining () const;  ; Bool_t IsConstructedFromWeightFile () const;  ; Bool_t IsNormalised () const;  ; virtual void MakeClassSpecificHeader (std::ostream &, const TString &="""") const;  ; void NoErrorCalc (Double_t *const err, Double_t *const errUpper);  ; void SetNormalised (Bool_t norm);  ; void SetWeightFileDir (TString fileDir);  set directory of weight file ;  ; void SetWeightFileName (TString);  set the weight file name (depreciated) ;  ; void Statistics (Types::ETree",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html:28722,log,logProgress,28722,doc/master/classTMVA_1_1MethodMLP.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html,1,['log'],['logProgress']
Testability,"ptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Private Member Functions; void AddLogFile (TProofQueryResult *pq);  Add part of log file concerning TQueryResult pq to its macro container. ;  . Private Attributes; TStopwatch fCompute;  ; Int_t fDrawQueries;  ; Int_t fKeptQueries;  ; TProofLockPath * fLock;  ; FILE * fLogFile;  ; TList * fPreviousQueries;  ; TList * fQueries;  ; TString fQueryDir;  ; Int_t fSeqNum;  ; TString fSessionDir;  ; TString fSessionTag;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQueryResultManager.html:10882,log,log,10882,doc/master/classTQueryResultManager.html,https://root.cern,https://root.cern/doc/master/classTQueryResultManager.html,1,['log'],['log']
Testability,"ptr<RooAbsReal> igauss{gauss.createIntegral(x)};; igauss->Print();; ; // Print streams configuration in verbose, which also shows inactive streams; cout << endl;; RooMsgService::instance().Print();; cout << endl;; ; // Remove stream; RooMsgService::instance().getStream(1).removeTopic(Integration);; ; // E x a m p l e s o f p d f v a l u e t r a c i n g s t r e a m; // -----------------------------------------------------------------------; ; // Show DEBUG level message on function tracing, trace RooGaussian only; RooMsgService::instance().addStream(DEBUG, Topic(Tracing), ClassName(""RooGaussian""));; ; // Perform a fit to generate some tracing messages; model.fitTo(*data, Verbose(true));; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; ; // Show DEBUG level message on function tracing on all objects, redirect output to file; RooMsgService::instance().addStream(DEBUG, Topic(Tracing), OutputFile(""rf506_debug.log""));; ; // Perform a fit to generate some tracing messages; model.fitTo(*data, Verbose(true));; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; ; // E x a m p l e o f a n o t h e r d e b u g g i n g s t r e a m; // ---------------------------------------------------------------------; ; // Show DEBUG level messages on client/server link state management; RooMsgService::instance().addStream(DEBUG, Topic(LinkStateMgmt));; RooMsgService::instance().Print(""v"");; ; // Clone composite pdf g to trigger some link state management activity; RooAbsArg *gprime = gauss.cloneTree();; gprime->Print();; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; }; DEBUG#define DEBUGDefinition Polynomial.cxx:40; f#define f(i)Definition RSha256.hxx:104; RooAddPdf.h; RooDataSet.h; RooGaussian.h; RooMsgService.h; RooPlot.h; RooPolynomial.h; RooRealVar.h; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf506__msgservice_8C.html:2821,log,log,2821,doc/master/rf506__msgservice_8C.html,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html,1,['log'],['log']
Testability,"public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*fAlpha[fDim] Internal parameters of the hyperrectangle; TMVA::PDEFoamCell**fCells[fNCells] Array of ALL cells; TMVA::EDTSeparationfDTSeparationBACKWARDS COMPATIBILITY: split cells according to decision tree logic; Int_tfDimDimension of the integration/simulation space; TMVA::PDEFoamDensityBase*fDistr! distribution of training events; Int_tfEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tfFillFoamWithOrigWeightsBACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights; TMVA::EFoamTypefFoamTypeBACKWARDS COMPATIBILITY: type of foam; TObjArray*fHistEdgHistograms of wt, one for each cell edge; Int_t*fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tfLastCeIndex of the last cell; TMVA::MsgLogger*fLogger! message logger; Int_t*fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tfMaxDepthmaximum depth of cell tree; Int_tfNBinNo. of bins in the edge histogram for cell MC exploration; Int_tfNCellsMaximum number of cells; UInt_tfNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tfNSamplNo. of MC events, when dividing (exploring) cell; TStringfNameName of a given instance of the FOAM class; UInt_tfNminminimal number of events in cell to split cell; Int_tfNoActNumber of acti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__PDEFoam.html:9972,log,logic,9972,root/html602/TMVA__PDEFoam.html,https://root.cern,https://root.cern/root/html602/TMVA__PDEFoam.html,2,['log'],['logic']
Testability,"put parameters ;  ; Double_t * fAmpErr;  [fNPeaks] array of amplitude errors ;  ; Double_t * fAmpInit;  [fNPeaks] array of initial values of peaks amplitudes, input parameters ;  ; Double_t * fArea;  [fNPeaks] array of calculated areas of peaks ;  ; Double_t * fAreaErr;  [fNPeaks] array of errors of peak areas ;  ; Double_t fBCalc;  calculated value of b parameter ;  ; Double_t fBErr;  error value of b parameter ;  ; Double_t fBInit;  initial value of b parameter (slope), for details see html manual and references ;  ; Double_t fChi;  here the fitting functions return resulting chi square ;  ; Int_t fFitTaylor;  order of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function. ;  ; Bool_t fFixA0;  logical value of a0 parameter, which allows to fix the parameter (not to fit). ;  ; Bool_t fFixA1;  logical value of a1 parameter, which allows to fix the parameter (not to fit). ;  ; Bool_t fFixA2;  logical value of a2 parameter, which allows to fix the parameter (not to fit). ;  ; Bool_t * fFixAmp;  [fNPeaks] array of logical values which allow to fix appropriate amplitudes (not fit). However they are present in the estimated functional ;  ; Bool_t fFixB;  logical value of b parameter, which allows to fix the parameter (not to fit). ;  ; Bool_t * fFixPosition;  [fNPeaks] array of logical values which allow to fix appropriate positions (not fit). However they are present in the estimated functional ;  ; Bool_t fFixS;  logical value of s parameter, which allows to fix the parameter (not to fit). ;  ; Bool_t fFixSigma;  logical value of sigma parameter, which allows to fix the parameter (not to fit). ;  ; Bool_t fFixT;  logical value of t parameter, which allows to fix the parameter (not to fit). ;  ; Int_t fNPeaks;  number of peaks present in fit, input parameter, it should be > 0 ;  ; Int_t fNumberIterations;  number of iterations in fitting procedure, input parameter, it should be > 0 ;  ; Double_t * fPosit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrumFit.html:19548,log,logical,19548,doc/master/classTSpectrumFit.html,https://root.cern,https://root.cern/doc/master/classTSpectrumFit.html,1,['log'],['logical']
Testability,"put parameters; double position_err_y[MAX_NUMBER_OF_PEAKS2]; // y position errors of 2D peaks; bool fix_position_y[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate; // y positions of 2D peaks (not fit).; // However they are present in the estimated functional; double position_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of x; // positions of 1D ridges, input parameters; double position_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of; // fitted x positions of 1D ridges, output parameters; double position_err_x1[MAX_NUMBER_OF_PEAKS2]; // x position errors of 1D ridges; bool fix_position_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate; // x positions of 1D ridges (not fit).; // However they are present in the estimated functional; double position_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of y; // positions of 1D ridges, input parameters; double position_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values; // of fitted y positions of 1D ridges, output parameters; double position_err_y1[MAX_NUMBER_OF_PEAKS2]; // y position errors of 1D ridges; bool fix_position_y1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix; // appropriate y positions of 1D ridges (not fit).; // However they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS2]; // initial values of 2D peaks; // amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS2]; // calculated values of; // fitted amplitudes of 2D peaks, output parameters; double amp_err[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 2D peaks; bool fix_amp[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows; // to fix appropriate amplitudes of 2D peaks (not fit).; // However they are present in the estimated functional; double amp_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D; // ridges amplitudes, input parameters; double amp_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of; // fitted amplitudes of 1D ridges, o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/spectrum/Spectrum.html:48513,log,logical,48513,root/html534/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html,1,['log'],['logical']
Testability,"put redirection options. OutputFile(const char*) -- Send output to file with given name. Multiple streams can write to same file.; OutputStream(ostream&) -- Send output to given C++ stream. Multiple message streams can write to same c++ stream. The return value is the unique ID code of the defined stream. void deleteStream(Int_t id); Delete stream with given unique ID code. void setStreamStatus(Int_t id, Bool_t active); (De)Activate stream with given unique ID. Bool_t getStreamStatus(Int_t id) const; Get activation status of stream with given unique ID. RooMsgService& instance(); Return reference to singleton instance. void saveState(); Save current state of message service. void restoreState(); Restore last saved state of message service. Bool_t isActive(const RooAbsArg* self, RooFit::MsgTopic topic, RooFit::MsgLevel level); Check if logging is active for given object/topic/RooFit::MsgLevel combination. Bool_t isActive(const TObject* self, RooFit::MsgTopic topic, RooFit::MsgLevel level); Check if logging is active for given object/topic/RooFit::MsgLevel combination. Int_t activeStream(const RooAbsArg* self, RooFit::MsgTopic topic, RooFit::MsgLevel level); Find appropriate logging stream for message from given object with given topic and message level. Int_t activeStream(const TObject* self, RooFit::MsgTopic topic, RooFit::MsgLevel level); Find appropriate logging stream for message from given object with given topic and message level. ostream& log(const RooAbsArg* self, RooFit::MsgLevel level, RooFit::MsgTopic topic, Bool_t skipPrefix); Log error message associated with RooAbsArg object self at given level and topic. If skipPrefix; is true the standard RooMsgService prefix is not added. ostream& log(const TObject* self, RooFit::MsgLevel level, RooFit::MsgTopic topic, Bool_t skipPrefix); Log error message associated with TObject object self at given level and topic. If skipPrefix; is true the standard RooMsgService prefix is not added. void Print(Option_t* options =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMsgService.html:10464,log,logging,10464,root/html526/RooMsgService.html,https://root.cern,https://root.cern/root/html526/RooMsgService.html,1,['log'],['logging']
Testability,"putDataFile(TString& dataFile); Int_tTProof::RemoveWorkers(TList* wrks); static Int_tTProof::SaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidTProof::SaveWorkerInfo(); Int_tTProof::SendFile(const char* file, Int_t opt = (kBinary|kForward|kCp|kCpBin), const char* rfile = 0, TSlave* sl = 0); static Int_tTProof::SendInputData(TQueryResult* qr, TProof* p, TString& emsg); voidTProof::SetDSet(TDSet* dset); voidTProof::SetPlayer(TVirtualProofPlayer* player); voidSetQueryRunning(TProofQueryResult* pq); Int_tSetupWorkers(Int_t opt = 0, TList* wrks = 0); static void*TProof::SlaveStartupThread(void* arg); virtual Bool_tTProof::StartSlaves(Bool_t attach = kFALSE); static voidTProof::SystemCmd(const char* cmd, Int_t fdout); voidTProof::UpdateDialog(); virtual voidTProof::ValidateDSet(TDSet* dset). private:. TProofLite(const TProofLite&); Int_tCleanupSandbox(); Int_tCreateSandbox(); Int_tInitDataSetManager(); voidNotifyStartUp(const char* action, Int_t done, Int_t tot); voidoperator=(const TProofLite&); voidResolveKeywords(TString& s, const char* logfile); virtual voidSendInputDataFile(); Int_tSetProofServEnv(const char* ord). Data Members; public:. enum TProof::EStatusBits { kUsingSessionGui; kNewInputData; kIsClient; kIsMaster; kIsTopMaster; kUseProgressDialog; };; enum TProof::EQueryMode { kSync; kAsync; };; enum TProof::EUploadOpt { kAppend; kOverwriteDataSet; kNoOverwriteDataSet; kOverwriteAllFiles; kOverwriteNoFiles; kAskUser; };; enum TProof::ERegisterOpt { kFailIfExists; kOverwriteIfExists; kMergeIfExists; };; enum TProof::EUploadDataSetAnswer { kError; kDataSetExists; kFail; };; enum TProof::EUploadPackageOpt { kUntar; kRemoveOld; };; enum TProof::ERunStatus { kRunning; kStopped; kAborted; };; enum TProof::ESubMerger { kOutputSize; kSendOutput; kBeMerger; kMergerDown; kStopMerging; kOutputSent; };; enum TProof::ESlaves { kAll; kActive; kUnique; kAllUnique; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReference",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofLite.html:21168,log,logfile,21168,root/html528/TProofLite.html,https://root.cern,https://root.cern/root/html528/TProofLite.html,1,['log'],['logfile']
Testability,"putGrow (Bool_t finished=false);  Overridden function of PDEFoam to avoid native foam output. ;  ; Long_t PeekMax ();  Internal subprogram used by Create. ;  ; void SetCellElement (PDEFoamCell *cell, UInt_t i, Double_t value);  Set cell element i of cell to value. ;  ; template<typename T > ; T Sqr (T x) const;  ; void Varedu (Double_t[5], Int_t &, Double_t &, Double_t &);  Internal subprogram used by Create. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; UInt_t fTarget;  ;  Protected Attributes inherited from TMVA::PDEFoam; Double_t * fAlpha;  [fDim] Internal parameters of the hyperrectangle ;  ; PDEFoamCell ** fCells;  [fNCells] Array of ALL cells ;  ; Int_t fDim;  Dimension of the integration/simulation space. ;  ; PDEFoamDensityBase * fDistr;  ! distribution of training events ;  ; EDTSeparation fDTSeparation;  BACKWARDS COMPATIBILITY: split cells according to decision tree logic. ;  ; Int_t fEvPerBin;  Maximum number of effective (wt=1) events per bin. ;  ; Bool_t fFillFoamWithOrigWeights;  BACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights. ;  ; EFoamType fFoamType;  BACKWARDS COMPATIBILITY: type of foam. ;  ; TObjArray * fHistEdg;  Histograms of wt, one for each cell edge. ;  ; Int_t * fInhiDiv;  ! [fDim] Flags for inhibiting cell division ;  ; Int_t fLastCe;  Index of the last cell. ;  ; MsgLogger * fLogger;  ! message logger ;  ; Int_t * fMaskDiv;  ! [fDim] Dynamic Mask for cell division ;  ; UInt_t fMaxDepth;  maximum depth of cell tree ;  ; TString fName;  Name of a given instance of the FOAM class. ;  ; Int_t fNBin;  No. of bins in the edge histogram for cell MC exploration. ;  ; Int_t fNCells;  Maximum number of cells. ;  ; UInt_t fNElements;  BACKWARDS COMPATIBILITY: number of variables in every cell. ;  ; UInt_t fNmin;  minimal number of events in c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1PDEFoamTarget.html:16740,log,logic,16740,doc/master/classTMVA_1_1PDEFoamTarget.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1PDEFoamTarget.html,1,['log'],['logic']
Testability,"putSupresseddisable the output globaly (used by generic booster); static const stringfgPrefixthe prefix of the source name; static const stringfgSuffixsuffix following source name; static map<EMsgType,std::string>*fgTypeMapmatches output types with strings. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void InhibitOutput(); { fgInhibitOutput = kTRUE; }. void EnableOutput(). { fgInhibitOutput = kFALSE; }. MsgLogger(const TObject* source, TMVA::EMsgType minType = kINFO); constructor. MsgLogger(const string& source, TMVA::EMsgType minType = kINFO); constructor. MsgLogger( EMsgType minType ); constructor. MsgLogger( const MsgLogger& parent ); copy constructor. ~MsgLogger(); destructor. TMVA::MsgLogger& operator=(const TMVA::MsgLogger& parent); assingment operator. std::string GetFormattedSource() const; make sure the source name is no longer than fgMaxSourceSize:. std::string GetPrintedSource() const; the full logger prefix. void Send(); activates the logger writer. void WriteMsg(TMVA::EMsgType type, const string& line) const; putting the output string, the message type, and the color; switcher together into a single string. TMVA::MsgLogger& Endmsg(TMVA::MsgLogger& logger); end line. void InitMaps(); Create the message type and color maps. void SetSource(const string& source); Accessors. { fStrSource = source; }. EMsgType GetMinType() const; { return fMinType; }. void SetMinType(TMVA::EMsgType minType); { fMinType = minType; }. std::string GetSource() const; { return fStrSource; }. UInt_t GetMaxSourceSize(); { return (UInt_t)fgMaxSourceSize; }. MsgLogger& operator<<( MsgLogger& ( *_f )( MsgLogger& ) ); Accept stream modifiers. MsgLogger& operator<<( std::ostream& ( *_f )( std::ostream& ) ). » Author: Attila Krasznahorkay » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MsgLogger.h 36966 2010-11-26 09:50:13Z evt $ » Last generated: 2010-11-26 14:27; This page has been automatically generated. For comments or suggestions",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MsgLogger.html:11245,log,logger,11245,root/html528/TMVA__MsgLogger.html,https://root.cern,https://root.cern/root/html528/TMVA__MsgLogger.html,1,['log'],['logger']
Testability,"putSupresseddisable the output globaly (used by generic booster); static const stringfgPrefixthe prefix of the source name; static const stringfgSuffixsuffix following source name; static map<EMsgType,std::string>*fgTypeMapmatches output types with strings. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void InhibitOutput(); { fgInhibitOutput = kTRUE; }. void EnableOutput(). { fgInhibitOutput = kFALSE; }. MsgLogger(const TObject* source, TMVA::EMsgType minType = kINFO); constructor. MsgLogger(const string& source, TMVA::EMsgType minType = kINFO); constructor. MsgLogger( EMsgType minType ); constructor. MsgLogger( const MsgLogger& parent ); copy constructor. ~MsgLogger(); destructor. TMVA::MsgLogger& operator=(const TMVA::MsgLogger& parent); assingment operator. std::string GetFormattedSource() const; make sure the source name is no longer than fgMaxSourceSize:. std::string GetPrintedSource() const; the full logger prefix. void Send(); activates the logger writer. void WriteMsg(TMVA::EMsgType type, const string& line) const; putting the output string, the message type, and the color; switcher together into a single string. TMVA::MsgLogger& Endmsg(TMVA::MsgLogger& logger); end line. void InitMaps(); Create the message type and color maps. void SetSource(const string& source); Accessors. { fStrSource = source; }. EMsgType GetMinType() const; { return fMinType; }. void SetMinType(TMVA::EMsgType minType); { fMinType = minType; }. std::string GetSource() const; { return fStrSource; }. UInt_t GetMaxSourceSize(); { return (UInt_t)fgMaxSourceSize; }. MsgLogger& operator<<( MsgLogger& ( *_f )( MsgLogger& ) ); Accept stream modifiers. MsgLogger& operator<<( std::ostream& ( *_f )( std::ostream& ) ). » Author: Attila Krasznahorkay, Andreas Hoecker, Joerg Stelzer, Eckhard von Toerne » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id$ » Last generated: 2015-03-14 16:44; This page has been automatically generated. For comments or",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MsgLogger.html:11333,log,logger,11333,root/html534/TMVA__MsgLogger.html,https://root.cern,https://root.cern/root/html534/TMVA__MsgLogger.html,1,['log'],['logger']
Testability,"putSupresseddisable the output globaly (used by generic booster); static const stringfgPrefixthe prefix of the source name; static const stringfgSuffixsuffix following source name; static map<EMsgType,std::string>*fgTypeMapmatches output types with strings. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void InhibitOutput(); { fgInhibitOutput = kTRUE; }. void EnableOutput(). { fgInhibitOutput = kFALSE; }. MsgLogger(const TObject* source, TMVA::EMsgType minType = kINFO); constructor. MsgLogger(const string& source, TMVA::EMsgType minType = kINFO); constructor. MsgLogger( EMsgType minType ); constructor. MsgLogger( const MsgLogger& parent ); copy constructor. ~MsgLogger(); destructor. TMVA::MsgLogger& operator=(const TMVA::MsgLogger& parent); assingment operator. std::string GetFormattedSource() const; make sure the source name is no longer than fgMaxSourceSize:. std::string GetPrintedSource() const; the full logger prefix. void Send(); activates the logger writer. void WriteMsg(TMVA::EMsgType type, const string& line) const; putting the output string, the message type, and the color; switcher together into a single string. TMVA::MsgLogger& Endmsg(TMVA::MsgLogger& logger); end line. void InitMaps(); Create the message type and color maps. void SetSource(const string& source); Accessors. { fStrSource = source; }. EMsgType GetMinType() const; { return fMinType; }. void SetMinType(TMVA::EMsgType minType); { fMinType = minType; }. std::string GetSource() const; { return fStrSource; }. UInt_t GetMaxSourceSize(); { return (UInt_t)fgMaxSourceSize; }. MsgLogger& operator<<( MsgLogger& ( *_f )( MsgLogger& ) ); Accept stream modifiers. MsgLogger& operator<<( std::ostream& ( *_f )( std::ostream& ) ). » Author: Attila Krasznahorkay, Andreas Hoecker, Joerg Stelzer, Eckhard von Toerne » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id: MsgLogger.h 39395 2011-05-26 10:05:54Z moneta $ » Last generated: 2011-07-04 15:34; This page h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MsgLogger.html:11314,log,logger,11314,root/html530/TMVA__MsgLogger.html,https://root.cern,https://root.cern/root/html530/TMVA__MsgLogger.html,1,['log'],['logger']
Testability,"putSupresseddisable the output globaly (used by generic booster); static const stringfgPrefixthe prefix of the source name; static const stringfgSuffixsuffix following source name; static map<EMsgType,std::string>*fgTypeMapmatches output types with strings. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void InhibitOutput(); { fgInhibitOutput = kTRUE; }. void EnableOutput(). { fgInhibitOutput = kFALSE; }. MsgLogger(const TObject* source, TMVA::EMsgType minType = kINFO); constructor. MsgLogger(const string& source, TMVA::EMsgType minType = kINFO); constructor. MsgLogger( EMsgType minType ); constructor. MsgLogger( const MsgLogger& parent ); copy constructor. ~MsgLogger(); destructor. TMVA::MsgLogger& operator=(const TMVA::MsgLogger& parent); assingment operator. std::string GetFormattedSource() const; make sure the source name is no longer than fgMaxSourceSize:. std::string GetPrintedSource() const; the full logger prefix. void Send(); activates the logger writer. void WriteMsg(TMVA::EMsgType type, const string& line) const; putting the output string, the message type, and the color; switcher together into a single string. TMVA::MsgLogger& Endmsg(TMVA::MsgLogger& logger); end line. void InitMaps(); Create the message type and color maps. void SetSource(const string& source); Accessors. { fStrSource = source; }. EMsgType GetMinType() const; { return fMinType; }. void SetMinType(TMVA::EMsgType minType); { fMinType = minType; }. std::string GetSource() const; { return fStrSource; }. UInt_t GetMaxSourceSize(); { return (UInt_t)fgMaxSourceSize; }. MsgLogger& operator<<( MsgLogger& ( *_f )( MsgLogger& ) ); Accept stream modifiers. MsgLogger& operator<<( std::ostream& ( *_f )( std::ostream& ) ). » Author: Attila Krasznahorkay, Andreas Hoecker, Joerg Stelzer, Eckhard von Toerne » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id: MsgLogger.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:19; This page ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__MsgLogger.html:11314,log,logger,11314,root/html532/TMVA__MsgLogger.html,https://root.cern,https://root.cern/root/html532/TMVA__MsgLogger.html,1,['log'],['logger']
Testability,"put_iterator;; 834 }; 835 }; 836 }; 837 ++itBatch;; 838 }; 839 ; 840 }; 841 else; 842 {; 843 std::vector<double> output;; 844 //for (auto it = begin (testPattern), itEnd = end (testPattern); it != itEnd; ++it); 845 {; 846 //const Pattern& p = (*it);; 847 //double weight = p.weight ();; 848 //Batch batch (it, it+1);; 849 Batch batch (begin (testPattern), end (testPattern));; 850 output.clear ();; 851 pass_through_type passThrough (settings, batch, dropContainerTest);; 852 double testPatternError = (*this) (passThrough, weights, ModeOutput::FETCH, output);; 853 if (output.size() == (outputSize() - 1) * batch.size()); 854 {; 855 auto output_iterator = output.begin();; 856 for (auto pattern_it = batch.begin(); pattern_it != batch.end(); ++pattern_it); 857 {; 858 for (size_t output_index = 1; output_index < outputSize(); ++output_index); 859 {; 860 settings.testSample (0, *output_iterator, (*pattern_it).output ().at (0),; 861 (*pattern_it).weight ());; 862 ++output_iterator;; 863 }; 864 }; 865 }; 866 testError += testPatternError; /// batch.size ();; 867 }; 868 // testError /= testPattern.size ();; 869 }; 870 settings.endTestCycle ();; 871// testError /= weightSum;; 872 ; 873 settings.computeResult (*this, weights);; 874 ; 875 hasConverged = settings.hasConverged (testError);; 876 if (!hasConverged && !isWeightsForDrop); 877 {; 878 dropOutWeightFactor (weights, dropFractions, true); // inverse; 879 isWeightsForDrop = true;; 880 }; 881 }; 882 ++testCycleCount;; 883 ++dropOutChangeCount;; 884 ; 885 ; 886// settings.resetPlot (""errors"");; 887 settings.addPoint (""trainErrors"", cycleCount, trainError);; 888 settings.addPoint (""testErrors"", cycleCount, testError);; 889 settings.plot (""trainErrors"", ""C"", 1, kBlue);; 890 settings.plot (""testErrors"", ""C"", 1, kMagenta);; 891 ; 892 ; 893 // setup error plots and progress bar variables for JsMVA; 894 if (fInteractive){; 895 fInteractive->AddPoint(cycleCount, trainError, testError);; 896 if (*fExitFromTraining) break;; 897 *fIPyCurren",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8icc_source.html:26250,test,testError,26250,doc/master/NeuralNet_8icc_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8icc_source.html,2,['test'],"['testError', 'testPatternError']"
Testability,"px() function. If the function is unimodal or if its extrema are far apart, setting the fNpx to a small value speeds the algorithm up many times. Then, Brent's method is applied on the bracketed interval.; @param maxIter maximum number of iterations. @param absTol desired absolute error in the minimum position. @param absTol desired relative error in the minimum position. ; Implements ROOT::Math::IRootFinderMethod.; Definition at line 66 of file BrentRootFinder.cxx. ◆ Status(). int ROOT::Math::BrentRootFinder::Status ; (; ); const. inlineoverridevirtual . Returns status of last estimate. ; If = 0 is OK ; Implements ROOT::Math::IRootFinderMethod.; Definition at line 101 of file BrentRootFinder.h. Member Data Documentation. ◆ fFunction. const IGenFunction* ROOT::Math::BrentRootFinder::fFunction. private . Pointer to the function. ; Definition at line 124 of file BrentRootFinder.h. ◆ fLogScan. bool ROOT::Math::BrentRootFinder::fLogScan. private . flag to control usage of a log scan ; Definition at line 125 of file BrentRootFinder.h. ◆ fNIter. int ROOT::Math::BrentRootFinder::fNIter. private . Number of iterations needed for the last estimation. ; Definition at line 126 of file BrentRootFinder.h. ◆ fNpx. int ROOT::Math::BrentRootFinder::fNpx. private . Number of points to bracket root with initial grid (def is 100) ; Definition at line 127 of file BrentRootFinder.h. ◆ fRoot. double ROOT::Math::BrentRootFinder::fRoot. private . Current estimation of the function root. ; Definition at line 131 of file BrentRootFinder.h. ◆ fStatus. int ROOT::Math::BrentRootFinder::fStatus. private . Status of code of the last estimate. ; Definition at line 128 of file BrentRootFinder.h. ◆ fXMax. double ROOT::Math::BrentRootFinder::fXMax. private . Upper bound of the search interval. ; Definition at line 130 of file BrentRootFinder.h. ◆ fXMin. double ROOT::Math::BrentRootFinder::fXMin. private . Lower bound of the search interval. ; Definition at line 129 of file BrentRootFinder.h. Librarie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1BrentRootFinder.html:8801,log,log,8801,doc/master/classROOT_1_1Math_1_1BrentRootFinder.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1BrentRootFinder.html,1,['log'],['log']
Testability,"py This tutorial shows how a TTree can be quickly converted to a numpy array or a pandas.DataFrame ;  pyroot003_prettyPrinting.py This tutorial illustrates the pretty printing feature of PyROOT, which reveals the content of the object if a string representation is requested, e.g., by Python's print statement ;  qtexample.pyQt example ;  ratioplot.py Display two histograms and their ratio ;  rootmarks.pyPrints a summary of all ROOT benchmarks (must be run before) The ROOTMARK number printed is by reference to a Pentium IV 2.4 Ghz (with 512 MBytes memory and 120 GBytes IDE disk) taken by definition as 600 ROOTMARKS in batch mode in executing python benchmarks.py ;  shapes.py Draw the geometry using the x3d viewver ;  staff.py example of macro to read data from an ascii file and create a root file with a Tree ;  surfaces.py Surfaces example ;  test.py ;  tornado.pyTornado example ;  tree.py This macro displays the Tree data structures ;  zdemo.py This macro is an example of graphs in log scales with annotations ;  ► pythia;  pythia8.CPythia8 basic example ;  pythiaExample.CUsing Pythia6 with ROOT ;  ► quadp;  portfolio.C This macro shows in detail the use of the quadratic programming package quadp ;  Quad.cxx;  Quad.h;  ► r;  DataFrame.C ;  example.C Simple example on how to use ROOT-R interface ;  Function.C ;  Functor.C Example to create class Functor ;  GlobalMinimization.C Example based in http://cran.r-project.org/web/packages/DEoptim/DEoptim.pdf Please install the R package DEoptim before run this example ;  Integration.C Numerical integration using R passing the function from ROOT ;  Interpolation.C More Information for R interpolation in http://stat.ethz.ch/R-manual/R-patched/library/stats/html/approxfun.html NOTE: this example illustrates an interpolation with random points given from ROOT and procedures made in R's environment ;  Minimization.C Example based in http://root.cern.ch/root/html/tutorials/fit/NumericalMinimization.C.html http://stat.ethz.ch/R-manua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:146932,log,log,146932,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['log'],['log']
Testability,"pyBefore executing this macro, the file makegeometry.C must have been executed ;  na49view.pyThis macro generates two views of the NA49 detector ;  na49visible.pySet visibility attributes for the NA49 geometry Set Shape attributes ;  ntuple1.py Ntuple drawing example ;  numberEntry.py;  parse_CSV_file_with_TTree_ReadStream.pyThis function provides an example of how one might massage a csv data file to read into a ROOT TTree via TTree::ReadStream ;  pyroot001_arrayInterface.py This tutorial illustrates the conversion of STL vectors and TVec to numpy arrays without copying the data ;  pyroot002_TTreeAsMatrix.py This tutorial shows how a TTree can be quickly converted to a numpy array or a pandas.DataFrame ;  qtexample.pyQt example ;  ratioplot.py Display two histograms and their ratio ;  rootmarks.pyPrints a summary of all ROOT benchmarks (must be run before) The ROOTMARK number printed is by reference to a Pentium IV 2.4 Ghz (with 512 MBytes memory and 120 GBytes IDE disk) taken by definition as 600 ROOTMARKS in batch mode in executing python benchmarks.py ;  shapes.py Draw the geometry using the x3d viewver ;  staff.py example of macro to read data from an ascii file and create a root file with a Tree ;  surfaces.py Surfaces example ;  test.py ;  tornado.pyTornado example ;  tree.py This macro displays the Tree data structures ;  zdemo.py This macro is an example of graphs in log scales with annotations ;  ► pythia;  pythia8.CPythia8 basic example ;  pythiaExample.CUsing Pythia6 with ROOT ;  ► quadp;  portfolio.C This macro shows in detail the use of the quadratic programming package quadp ;  Quad.cxx;  Quad.h;  ► r;  DataFrame.C ;  example.C Simple example on how to use ROOT-R interface ;  Function.C ;  Functor.C Example to create class Functor ;  GlobalMinimization.C Example based in http://cran.r-project.org/web/packages/DEoptim/DEoptim.pdf Please install the R package DEoptim before run this example ;  Integration.C Numerical integration using R passing the funct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:144192,benchmark,benchmarks,144192,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,1,['benchmark'],['benchmarks']
Testability,"pyMacroToCache(const char* macro, Int_t headerRequired = 0, TSelector** selector = 0, Int_t opt = 0); TSlave*TProof::CreateSlave(const char* url, const char* ord, Int_t perf, const char* image, const char* workdir); TSlave*TProof::CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd); Int_tCreateSymLinks(TList* files); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; static Bool_tTProof::GetFileInCmd(const char* cmd, TString& fn); static Int_tTProof::GetInputData(TList* input, const char* cachedir, TString& emsg); TList*TProof::GetListOfActiveSlaves() const; TVirtualProofPlayer*TProof::GetPlayer() const; TPluginHandler*TProof::GetProgressDialog() const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTProof::HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tInit(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidTProof::InitMembers(); virtual TVirtualProofPlayer*TProof::MakePlayer(const char* player = 0, TSocket* s = 0); TProofQueryResult*MakeQueryResult(Long64_t nent, const char* opt, Long64_t fst, TDSet* dset, const char* selec); voidTObject::MakeZombie(); voidTProof::PrepareInputDataFile(TString& dataFile); Int_tTProof::RemoveWorkers(TList* wrks); static Int_tTProof::SaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidTProof::SaveWorkerInfo(); Int_tTProof::SendFile(const char* file, Int_t opt = (kBinary|kForward|kCp|kCpBin), const char* rfile = 0, TSlave* sl = 0); static Int_tTProof::SendInputData(TQueryResult* qr, TProof* p, TString& emsg); voidTProof::SetDSet(TDSet* dset); voidTProof::SetPlayer(TVirtualProofPlayer* player); voidSetQueryRunning(TProofQueryResult* pq); Int_tSetupWorkers(Int_t opt = 0, TList* wrks = 0); static void*TProof::SlaveStartupThread(void* arg); virtual Bool_tTProof::StartSlaves(Bool_t attach = kFALSE); s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofLite.html:19776,log,loglevel,19776,root/html528/TProofLite.html,https://root.cern,https://root.cern/root/html528/TProofLite.html,1,['log'],['loglevel']
Testability,"pyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char cnameDefinition TGWin32VirtualXProxy.cxx:230; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; namechar name[80]Definition TGX11.cxx:110; TGraphAsymmErrors.h; TH1.h; hi#define hiDefinition THbookFile.cxx:128; TList.h; TMath.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; Printfvoid Printf(const char *fmt,...)Formats a string in a circular formatting buffer and prints the string.Definition TString.cxx:2503; TVirtualFitter.h; TF11-Dim function classDefinition TF1.h:233; TF1::RejectPointstatic void RejectPoint(Bool_t reject=kTRUE)Static function to set the global flag to reject points the fgRejectPoint global flag is tested by al...Definition TF1.cxx:3683; TF1::Derivativevirtual Double_t Derivative(Double_t x, Double_t *params=nullptr, Double_t epsilon=0.001) constReturns the first derivative of the function at point x, computed by Richardson's extrapolation metho...Definition TF1.cxx:1113; TF1::GetNparvirtual Int_t GetNpar() constDefinition TF1.h:509; TF1::Integralvirtual Double_t Integral(Double_t a, Double_t b, Double_t epsrel=1.e-12)IntegralOneDim or analytical integral.Definition TF1.cxx:2531; TF1::SetNumberFitPointsvirtual void SetNumberFitPoints(Int_t npfits)Definition TF1.h:652; TF1::InitArgsvirtual void InitArgs(const Double_t *x, const Double_t *params)Initialize parameters addresses.Definition TF1.cxx:2482; TF1::EvalParvirtual Double_t EvalPar(const Double_t *x, const Double_t *params=nullptr)Evaluate function with given coordinates and parameters.Definition TF1.cxx:1468; TF1::RejectedPointstatic Bool_t RejectedPoint(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFumili_8cxx_source.html:67468,test,tested,67468,doc/master/TFumili_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html,1,['test'],['tested']
Testability,"q = 0); Sends all objects from the given list to the specified socket. void ProcessNext(TString* slb = 0); process the next query from the queue of submitted jobs.; to be called on the top master only. Int_t RegisterDataSets(TList* in, TList* out, TDataSetManager* dsm, TString& e); Register TFileCollections in 'out' as datasets according to the rules in 'in'. void HandleQueryList(TMessage* mess); Handle request for list of queries. void HandleRemove(TMessage* mess, TString* slb = 0); Handle remove request. void HandleRetrieve(TMessage* mess, TString* slb = 0); Handle retrieve request. Int_t HandleLibIncPath(TMessage* mess); Handle lib, inc search paths modification request. void HandleCheckFile(TMessage* mess, TString* slb = 0); Handle file checking request. Int_t HandleCache(TMessage* mess, TString* slb = 0); Handle here all cache and package requests. Int_t HandleWorkerLists(TMessage* mess); Handle here all requests to modify worker lists. FILE * SetErrorHandlerFile(FILE* ferr); Set the file stream where to log (default stderr).; If ferr == 0 the default is restored.; Returns current setting. void ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); The PROOF error handler function. It prints the message on fgErrorHandlerFile and; if abort is set it aborts the application. Int_t CopyFromCache(const char* name, Bool_t cpbin); Retrieve any files related to 'macro' from the cache directory.; If 'cpbin' is true, the associated binaries are retrieved as well.; Returns 0 on success, -1 otherwise. Int_t CopyToCache(const char* name, Int_t opt = 0); Copy files related to 'macro' to the cache directory.; Action depends on 'opt':. opt = 0 copy 'macro' to cache and delete from cache any binary; related to name; e.g. if macro = bla.C, the binaries are; bla_C.so, bla_C.rootmap, ...; opt = 1 copy the binaries related to macro to the cache. Returns 0 on success, -1 otherwise. void MakePlayer(); Make player instance. void DeletePlayer(); Delete player in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofServ.html:27702,log,log,27702,root/html534/TProofServ.html,https://root.cern,https://root.cern/root/html534/TProofServ.html,2,['log'],['log']
Testability,"q, const Double_t* probSum); virtual Double_tTF2::GetRandom(); virtual Double_tTF2::GetRandom(Double_t xmin, Double_t xmax); virtual voidTF2::GetRandom2(Double_t& xrandom, Double_t& yrandom); virtual voidGetRandom3(Double_t& xrandom, Double_t& yrandom, Double_t& zrandom); virtual voidGetRange(Double_t& xmin, Double_t& xmax) const; virtual voidGetRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; virtual voidGetRange(Double_t& xmin, Double_t& ymin, Double_t& zmin, Double_t& xmax, Double_t& ymax, Double_t& zmax) const; virtual Double_tGetSave(const Double_t* x); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Double_tTF1::GetX(Double_t y, Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.0E-10, Int_t maxiter = 100, Bool_t logx = false) const; TAxis*TF1::GetXaxis() const; virtual Double_tTF1::GetXmax() const; virtual Double_tTF1::GetXmin() const; TAxis*TF1::GetYaxis() const; virtual Double_tTF2::GetYmax() const; virtual Double_tTF2::GetYmin() const; TAxis*TF1::GetZaxis() const; virtual Double_tGetZmax() const; virtual Double_tGetZmin() const; virtual Double_tTF1::GradientPar(Int_t ipar, const Double_t* x, Double_t eps = 0.01); virtual voidTF1::GradientPar(const Double_t* x, Double_t* grad, Double_t eps = 0.01); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTF1::InitArgs(const Double_t* x, const Double_t* params); static voidTF1::InitStandardFunctions(); virtual voidTObject::Inspect() constMENU ; virtual Double_tIntegral(Double_t ax, Double_t bx, Double_t ay, Double_t by, Double_t az, Double_t bz, Double_t epsrel = 9.9999999999999995E-7); virtual Double_tTF1::IntegralError(Double_t a, Double_t b, const Double_t* params = 0, const Double_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF3.html:8156,log,logx,8156,root/html602/TF3.html,https://root.cern,https://root.cern/root/html602/TF3.html,1,['log'],['logx']
Testability,qlcreatedb.CCreate a runcatalog table in a MySQL test database ;  sqlcreatedb.py Create a runcatalog table in a MySQL test database ;  sqlfilldb.CFill run catalog with nfiles entries ;  sqlfilldb.py Fill run catalog with nfiles entries ;  sqlselect.CQuery example to MySQL test database ;  sqlselect.py Query example to MySQL test database ;  sqltables.CThis is an example illustrating how the TSQLFile class can be used ;  ► thread;  stressThreadPool.CUsage: ;  threadPool.CUsage: ;  threads.CExample of a simple script creating 3 threads ;  threadsh1.CExample of a simple script creating 3 threads ;  threadsh2.CExample of a simple script creating 2 threads each with one canvas ;  ► tmva;  ► envelope;  classification.C;  ► keras;  ApplicationClassificationKeras.py;  ApplicationRegressionKeras.py;  ClassificationKeras.py;  GenerateModel.py;  MulticlassKeras.py;  RegressionKeras.py;  createData.CPlot the variables ;  TMVAClassification.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVAClassificationApplication.C This macro provides a simple example on how to use the trained classifiers within an analysis module ;  TMVAClassificationCategory.C This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode ;  TMVAClassificationCategoryApplication.C This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  TMVACrossValidation.C This macro provides an example of how to use TMVA for k-folds cross evaluation ;  TMVACrossValidationApplication.C This macro provides an example of how to use TMVA for k-folds cross evaluation in application ;  TMVACrossValidationRegression.C This macro provides an example of how to use TMVA for k-folds cross evaluation ;  TMVAGAexample.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAGAexample2.C This exectutable gives an example of a very simple use of the gen,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:158427,test,testing,158427,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,1,['test'],['testing']
Testability,"quantities. We have shown how to retrieve the data arrays from the branches of the tree in the previous section, and you could just write that program from scratch. Since this is a very common task, ROOT provides a utility that generates a skeleton class designed to loop over the entries of the tree.; This is the TTree::MakeClass method. We will now go through the steps of using MakeClass with a simplified example. The methods used here obviously work for complex event loop calculations.; These are our assumptions: we would like to do selective plotting and loop through each entry of the tree and tracks. We chose a simple example: we want to plot fPx of the first 100 tracks of each entry. We have a ROOT tree with a branch for each data member in the “Event” object. To build this file and tree follow the instructions on how to build the examples in $ROOTSYS/test. Execute Event and instruct it to split the object with this command (from the UNIX command line).; > $ROOTSYS/test/Event 400 1 2 1; This creates an Event.root file with 400 events, compressed, split, and filled.; See $ROOTSYS/test/MainEvent.cxx for more info.; The person who designed the tree makes a shared library available to you, which defines the classes needed. In this case, the classes are Event, EventHeader, and Track and they are defined in the shared library libEvent.so. The designer also gives you the Event.h file to see the definition of the classes. You can locate Event.h in $ROOTSYS/test, and if you have not yet built libEvent.so, please see the instructions of how to build it (typing make in $ROOTSYS/test is enough). If you have already built it, you can now use it again.; 12.21.1 Creating a Class with MakeClass; First, we load the shared library and open Event.root.; root[] .L libEvent.so; root[] TFile *f = new TFile(""Event.root"");; root[] f->ls();; TFile** Event.root TTree benchmark ROOT file; TFile* Event.root TTree benchmark ROOT file; KEY: TH1F htime;1 Real-Time to write versus time; KEY: T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:635011,test,test,635011,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['test'],['test']
Testability,"que ID. RooMsgService& instance(); Return reference to singleton instance. void saveState(); Save current state of message service. void restoreState(); Restore last saved state of message service. Bool_t isActive(const RooAbsArg* self, RooFit::MsgTopic topic, RooFit::MsgLevel level); Check if logging is active for given object/topic/RooFit::MsgLevel combination. Bool_t isActive(const TObject* self, RooFit::MsgTopic topic, RooFit::MsgLevel level); Check if logging is active for given object/topic/RooFit::MsgLevel combination. Int_t activeStream(const RooAbsArg* self, RooFit::MsgTopic topic, RooFit::MsgLevel level); Find appropriate logging stream for message from given object with given topic and message level. Int_t activeStream(const TObject* self, RooFit::MsgTopic topic, RooFit::MsgLevel level); Find appropriate logging stream for message from given object with given topic and message level. ostream& log(const RooAbsArg* self, RooFit::MsgLevel level, RooFit::MsgTopic topic, Bool_t skipPrefix); Log error message associated with RooAbsArg object self at given level and topic. If skipPrefix; is true the standard RooMsgService prefix is not added. ostream& log(const TObject* self, RooFit::MsgLevel level, RooFit::MsgTopic topic, Bool_t skipPrefix); Log error message associated with TObject object self at given level and topic. If skipPrefix; is true the standard RooMsgService prefix is not added. void Print(Option_t* options = 0) const; Print configuration of message service. If ""v"" option is given also; inactive streams are listed. StreamConfig& getStream(Int_t id); { return _streams[id] ; }. Int_t numStreams() const; { return _streams.size() ; }. void reset(); { cleanup() ; }. void setGlobalKillBelow(RooFit::MsgLevel level); { _globMinLevel = level ; }. RooFit::MsgLevel globalKillBelow() const; { return _globMinLevel ; }. void showPid(Bool_t flag); { _showPid = flag ; }. Bool_t silentMode() const; Print level support for RooFit-related messages that are not routed t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMsgService.html:10920,log,log,10920,root/html526/RooMsgService.html,https://root.cern,https://root.cern/root/html526/RooMsgService.html,1,['log'],['log']
Testability,"que object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static TProofMgr * Create (const char *url, Int_t loglevel=-1, const char *alias=0, Bool_t xpd=kTRUE);  Static method returning the appropriate TProofMgr object using the plugin manager. ;  ; static const char * DeclFileName ();  ; static TList * GetListOfManagers ();  Extract pointers to PROOF managers from TROOT::fProofs. ;  ; static Int_t Ping (const char *url, Bool_t checkxrd=kFALSE);  Non-blocking check for a PROOF (or Xrootd, if checkxrd) service at 'url' Return 0 if a XProofd (or Xrootd, if checkxrd) daemon is listening at 'url' -1 if nothing is listening on the port (connection cannot be open) 1 if something is listening but not XProofd (or not Xrootd, if checkxrd) ;  ; static void SetTXProofMgrHook (TProofMgr_t pmh);  Set hook to TXProofMgr ctor. ;  ; static TFileCollection * UploadFiles (const char *txtfile, const char *mss, const char *dest=0);  Upload to 'mss' the files listed in the text file 'srcfiles' or contained in the directory 'srcfiles'. ;  ; static TFileCollection * UploadFiles (TLis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofMgr.html:13522,log,loglevel,13522,doc/master/classTProofMgr.html,https://root.cern,https://root.cern/doc/master/classTProofMgr.html,1,['log'],['loglevel']
Testability,"r != ez ); 166 {; 167 fCoordErrorsPtr.resize( 3 );; 168 ; 169 fCoordErrorsPtr[0] = ex;; 170 fCoordErrorsPtr[1] = ey;; 171 fCoordErrorsPtr[2] = ez;; 172 ; 173 fErrorType = kCoordError;; 174 }; 175 }; 176 else; 177 {; 178 fErrorType = kNoError;; 179 }; 180 ; 181 fpTmpCoordErrorVector = new double [ fDim ];; 182 ComputeSums();; 183 }; 184 ; 185 /**; 186 destructor; 187 */; 188 BinData::~BinData(); 189 {; 190 assert( fMaxPoints == 0 || fWrapped == fData.empty() );; 191 ; 192 assert( kValueError == fErrorType || kCoordError == fErrorType ||; 193 kAsymError == fErrorType || kNoError == fErrorType );; 194 assert( fMaxPoints == 0 || fDataError.empty() || &fDataError.front() == fDataErrorPtr );; 195 assert( fMaxPoints == 0 || fDataErrorHigh.empty() || &fDataErrorHigh.front() == fDataErrorHighPtr );; 196 assert( fMaxPoints == 0 || fDataErrorLow.empty() || &fDataErrorLow.front() == fDataErrorLowPtr );; 197 assert( fMaxPoints == 0 || fDataErrorLow.empty() == fDataErrorHigh.empty() );; 198 assert( fMaxPoints == 0 || fData.empty() || &fData.front() == fDataPtr );; 199 ; 200 for ( unsigned int i=0; i < fDim; i++ ); 201 {; 202 assert( fCoordErrors.empty() || &fCoordErrors[i].front() == fCoordErrorsPtr[i] );; 203 }; 204 ; 205 if ( fpTmpBinEdgeVector ); 206 {; 207 delete[] fpTmpBinEdgeVector;; 208 fpTmpBinEdgeVector= nullptr;; 209 }; 210 ; 211 if ( fpTmpCoordErrorVector ); 212 {; 213 delete[] fpTmpCoordErrorVector;; 214 fpTmpCoordErrorVector = nullptr;; 215 }; 216 }; 217 ; 218 /**; 219 copy constructors; 220 */; 221 BinData::BinData(const BinData &rhs); 222 : FitData(rhs),; 223 fDataPtr(nullptr),; 224 fDataErrorPtr(nullptr), fDataErrorHighPtr(nullptr), fDataErrorLowPtr(nullptr),; 225 fpTmpCoordErrorVector(nullptr), fpTmpBinEdgeVector(nullptr); 226 {; 227 *this = rhs;; 228 }; 229 ; 230 BinData & BinData::operator= ( const BinData & rhs ); 231 {; 232 FitData::operator=( rhs );; 233 ; 234 if ( fpTmpBinEdgeVector ); 235 {; 236 assert(HasBinEdges());; 237 ; 238 delete[] fpTmpBinEdgeVector;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:5679,assert,assert,5679,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['assert'],['assert']
Testability,"r ) :; 26 FitData( maxpoints, dim ),; 27 fErrorType( err ),; 28 fDataPtr( nullptr ),; 29 fDataErrorPtr( nullptr ), fDataErrorHighPtr( nullptr ), fDataErrorLowPtr( nullptr ),; 30 fpTmpCoordErrorVector( nullptr ), fpTmpBinEdgeVector( nullptr ); 31 {; 32 InitializeErrors();; 33 InitDataVector( );; 34 }; 35 ; 36 ; 37 /**; 38 constructor from option and default range; 39 */; 40 BinData::BinData (const DataOptions & opt, unsigned int maxpoints,; 41 unsigned int dim, ErrorType err ) :; 42 FitData( opt, maxpoints, dim ),; 43 fErrorType( err ),; 44 fDataPtr( nullptr ),; 45 fDataErrorPtr( nullptr ), fDataErrorHighPtr( nullptr ), fDataErrorLowPtr( nullptr ),; 46 fpTmpCoordErrorVector( nullptr ), fpTmpBinEdgeVector( nullptr ); 47 {; 48 InitializeErrors();; 49 InitDataVector( );; 50 }; 51 ; 52 /**; 53 constructor from options and range; 54 efault is 1D and value errors; 55 */; 56 BinData::BinData (const DataOptions & opt, const DataRange & range,; 57 unsigned int maxpoints, unsigned int dim, ErrorType err ) :; 58 FitData( opt, range, maxpoints, dim ),; 59 fErrorType( err ),; 60 fDataPtr( nullptr ),; 61 fDataErrorPtr( nullptr ), fDataErrorHighPtr( nullptr ), fDataErrorLowPtr( nullptr ),; 62 fpTmpCoordErrorVector( nullptr ), fpTmpBinEdgeVector( nullptr ); 63 {; 64 InitializeErrors();; 65 InitDataVector( );; 66 }; 67 ; 68 /** constructors using external data */; 69 ; 70 /**; 71 constructor from external data for 1D with errors on coordinate and value; 72 */; 73 BinData::BinData (unsigned int n, const double * dataX, const double * val,; 74 const double * ex , const double * eval ) :; 75 FitData( n, dataX ),; 76 fDataPtr( nullptr ),; 77 fDataErrorPtr( nullptr ), fDataErrorHighPtr( nullptr ), fDataErrorLowPtr( nullptr ),; 78 fpTmpCoordErrorVector( nullptr ), fpTmpBinEdgeVector( nullptr ); 79 {; 80 assert( val );; 81 fDataPtr = val;; 82 ; 83 if ( nullptr != eval ); 84 {; 85 fDataErrorPtr = eval;; 86 ; 87 fErrorType = kValueError;; 88 ; 89 if ( nullptr != ex ); 90 {; 91 fCoordErrorsPtr.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:2572,assert,assert,2572,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['assert'],['assert']
Testability,r ); 243 {; 244 delete[] fpTmpCoordErrorVector;; 245 fpTmpCoordErrorVector = nullptr;; 246 }; 247 ; 248 fDataPtr = nullptr;; 249 fDataErrorPtr= fDataErrorHighPtr= fDataErrorLowPtr= nullptr;; 250 ; 251 fErrorType = rhs.fErrorType;; 252 fRefVolume = rhs.fRefVolume;; 253 fBinEdge = rhs.fBinEdge;; 254 ; 255 if ( fWrapped ); 256 {; 257 fData.clear();; 258 fCoordErrors.clear();; 259 fDataError.clear();; 260 fDataErrorHigh.clear();; 261 fDataErrorLow.clear();; 262 ; 263 fDataPtr = rhs.fDataPtr;; 264 fCoordErrorsPtr = rhs.fCoordErrorsPtr;; 265 fDataErrorPtr = rhs.fDataErrorPtr;; 266 fDataErrorHighPtr = rhs.fDataErrorHighPtr;; 267 fDataErrorLowPtr = rhs.fDataErrorLowPtr;; 268 }; 269 else; 270 {; 271 // copy data vector and set correct pointer; 272 fData = rhs.fData;; 273 if ( !fData.empty() ); 274 fDataPtr = &fData.front();; 275 ; 276 // copy coordinate errors and set correct pointers; 277 fCoordErrors = rhs.fCoordErrors;; 278 if (!fCoordErrors.empty()) {; 279 assert(kCoordError == fErrorType || kAsymError == fErrorType);; 280 fCoordErrorsPtr.resize(fDim);; 281 for (unsigned int i = 0; i < fDim; i++) {; 282 fCoordErrorsPtr[i] = fCoordErrors[i].empty() ? nullptr : &fCoordErrors[i].front();; 283 }; 284 }; 285 // copy data error; 286 fDataError = rhs.fDataError;; 287 if (!fDataError.empty()) {; 288 assert(kValueError == fErrorType || kCoordError == fErrorType);; 289 fDataErrorPtr = &fDataError.front();; 290 }; 291 // copy the asymmetric data error; 292 fDataErrorHigh = rhs.fDataErrorHigh;; 293 fDataErrorLow = rhs.fDataErrorLow;; 294 // both error low and high should be empty or not; 295 assert( fDataErrorLow.empty() == fDataErrorHigh.empty()) ;; 296 if (!fDataErrorHigh.empty() && !fDataErrorLow.empty()) {; 297 assert(kAsymError == fErrorType);; 298 fDataErrorHighPtr = &fDataErrorHigh.front();; 299 fDataErrorLowPtr = &fDataErrorLow.front();; 300 }; 301 }; 302 ; 303 fpTmpCoordErrorVector= new double[ fDim ];; 304 ; 305 if ( HasBinEdges() ); 306 fpTmpBinEdgeVector = new double[ fD,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:7732,assert,assert,7732,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['assert'],['assert']
Testability,"r ); 269 {; 270 assert( !fDataErrorPtr && !fDataErrorHighPtr && !fDataErrorLowPtr );; 271 assert( fDataError.empty() && fDataErrorHigh.empty() && fDataErrorLow.empty() );; 272 return 1.0;; 273 }; 274 ; 275 if ( fErrorType == kValueError ) // need to invert (inverror is stored); 276 {; 277 assert( fDataErrorPtr && !fDataErrorHighPtr && !fDataErrorLowPtr );; 278 assert( fDataErrorHigh.empty() && fDataErrorLow.empty() );; 279 assert( fDataError.empty() || &fDataError.front() == fDataErrorPtr );; 280 ; 281 double eval = fDataErrorPtr[ ipoint ];; 282 ; 283 if (fWrapped); 284 return eval;; 285 else; 286 return (eval != 0.0) ? 1.0/eval : 0.0;; 287 }; 288 ; 289 if ( fErrorType == kAsymError ); 290 { // return 1/2(el + eh); 291 assert( !fDataErrorPtr && fDataErrorHighPtr && fDataErrorLowPtr );; 292 assert( fDataError.empty() );; 293 assert( fDataErrorHigh.empty() || &fDataErrorHigh.front() == fDataErrorHighPtr );; 294 assert( fDataErrorLow.empty() || &fDataErrorLow.front() == fDataErrorLowPtr );; 295 assert( fDataErrorLow.empty() == fDataErrorHigh.empty() );; 296 ; 297 double eh = fDataErrorHighPtr[ ipoint ];; 298 double el = fDataErrorLowPtr[ ipoint ];; 299 ; 300 return (el+eh) / 2.0;; 301 }; 302 ; 303 assert( fErrorType == kCoordError );; 304 return fDataErrorPtr[ ipoint ];; 305 }; 306 ; 307 void GetAsymError( unsigned int ipoint, double& lowError, double& highError ) const; 308 {; 309 assert( fErrorType == kAsymError );; 310 assert( !fDataErrorPtr && fDataErrorHighPtr && fDataErrorLowPtr );; 311 assert( fDataError.empty() );; 312 assert( fDataErrorHigh.empty() || &fDataErrorHigh.front() == fDataErrorHighPtr );; 313 assert( fDataErrorLow.empty() || &fDataErrorLow.front() == fDataErrorLowPtr );; 314 assert( fDataErrorLow.empty() == fDataErrorHigh.empty() );; 315 ; 316 lowError = fDataErrorLowPtr[ ipoint ];; 317 highError = fDataErrorHighPtr[ ipoint ];; 318 }; 319 ; 320 /**; 321 Return the inverse of error on the value for the given fit point; 322 useful when error in the co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8h_source.html:10213,assert,assert,10213,doc/master/BinData_8h_source.html,https://root.cern,https://root.cern/doc/master/BinData_8h_source.html,1,['assert'],['assert']
Testability,"r );; 459 assert( !fCoordErrors.empty() && fCoordErrors.size() == 1 );; 460 assert( !fCoordErrorsPtr.empty() && fCoordErrorsPtr.size() == 1 && fCoordErrorsPtr[0] );; 461 assert( &fCoordErrors[0].front() == fCoordErrorsPtr[0] );; 462 ; 463 fData[ fNPoints ] = y;; 464 fCoordErrors[0][ fNPoints ] = ex;; 465 fDataError[ fNPoints ] = ey;; 466 ; 467 FitData::Add( x );; 468 fSumContent += y;; 469 if (y != 0 || ey != 1.0) fSumError2 += ey*ey;; 470 // set the weight flag checking if error^2 != y; 471 if (!fIsWeighted); 472 if (y != 0 && std::abs( ey*ey/y - 1.0) > 1.E-12) fIsWeighted = true;; 473 }; 474 ; 475 /**; 476 add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); 477 in this case store the y errors and not the inverse; 478 */; 479 void BinData::Add( double x, double y, double ex, double eyl, double eyh ); 480 {; 481 assert( kAsymError == fErrorType );; 482 assert( !fData.empty() && fDataPtr );; 483 assert( !fDataErrorHigh.empty() && fDataErrorHighPtr );; 484 assert( !fDataErrorLow.empty() && fDataErrorLowPtr );; 485 assert( fDataError.empty() && !fDataErrorPtr );; 486 assert( !fCoordErrors.empty() && fCoordErrors.size() == 1 );; 487 assert( !fCoordErrorsPtr.empty() && fCoordErrorsPtr.size() == 1 && fCoordErrorsPtr[0] );; 488 assert( &fCoordErrors[0].front() == fCoordErrorsPtr[0] );; 489 ; 490 fData[ fNPoints ] = y;; 491 fCoordErrors[0][ fNPoints ] = ex;; 492 fDataErrorHigh[ fNPoints ] = eyh;; 493 fDataErrorLow[ fNPoints ] = eyl;; 494 ; 495 FitData::Add( x );; 496 fSumContent += y;; 497 if (y != 0 || eyl != 1.0 || eyh != 1.0) fSumError2 += (eyl+eyh)*(eyl+eyh)/4;; 498 ; 499 }; 500 ; 501 /**; 502 add multi-dim coordinate data with only value; 503 */; 504 void BinData::Add( const double* x, double val ); 505 {; 506 assert( kNoError == fErrorType );; 507 ; 508 assert( !fData.empty() && fDataPtr );; 509 assert( fDataErrorHigh.empty() && !fDataErrorHighPtr );; 510 assert( fDataErrorLow.empty() && !fDataErrorLowPtr );; 511 assert( fDataErro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:14586,assert,assert,14586,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['assert'],['assert']
Testability,"r * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Private Member Functions;  DataSetInfo (const DataSetInfo &)=delete;  ; MsgLogger & Log () const;  ; DataSetInfo & operator= (const DataSetInfo &)=delete;  ; void PrintCorrelationMatrix (TTree *theTree);  ; void SetDataSetManager (DataSetManager *dsm);  . Private Attributes; std::vector< ClassInfo * > fClasses;  name and other infos of the classes ;  ; DataSet * fDataSet;  dataset, owned by this datasetinfo object ;  ; TMVA::DataSetManager * fDataSetManager;  ; MsgLogger * fLogger;  ! message logger ;  ; TString fName;  name of the dataset info object ;  ; Bool_t fNeedsRebuilding;  flag if rebuilding of dataset is needed (after change of cuts, vars, etc.) ;  ; TString fNormalization;  ; TDirectory * fOwnRootDir;  ROOT output dir. ;  ; UInt_t fSignalClass;  index of the class with the name signal ;  ; std::vector< VariableInfo > fSpectators;  list of spectators expressions/internal names ;  ; TString fSplitOptions;  ; std::vector< VariableInfo > fTargets;  list of targets expressions/internal names ;  ; std::vector< Float_t > * fTargetsForMulticlass;  -> all targets 0 except the one with index==classNumber ;  ; Double_t fTestingSumBackgrWeights;  ; Double_t fTestingSumSignalWeights;  ; Double_t fTrainingSumBackgrWeights;  ; Double_t fTrainingSumSignalWeights;  ; std::map< TString, int > fVarArrays;  ; std::vector< VariableInfo > fVariables;  list of variable expressions/internal names ;  ; Bool_t fVerbose;  Verbosity. ;  . Friends; clas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DataSetInfo.html:15154,log,logger,15154,doc/master/classTMVA_1_1DataSetInfo.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DataSetInfo.html,1,['log'],['logger']
Testability,"r += std::get<0>(result) / batches.size ();; 823 std::vector<double> output = std::get<1>(result);; 824 if (output.size() == (outputSize() - 1) * itBatch->size()); 825 {; 826 auto output_iterator = output.begin();; 827 for (auto pattern_it = itBatch->begin(); pattern_it != itBatch->end(); ++pattern_it); 828 {; 829 for (size_t output_index = 1; output_index < outputSize(); ++output_index); 830 {; 831 settings.testSample (0, *output_iterator, (*pattern_it).output ().at (0),; 832 (*pattern_it).weight ());; 833 ++output_iterator;; 834 }; 835 }; 836 }; 837 ++itBatch;; 838 }; 839 ; 840 }; 841 else; 842 {; 843 std::vector<double> output;; 844 //for (auto it = begin (testPattern), itEnd = end (testPattern); it != itEnd; ++it); 845 {; 846 //const Pattern& p = (*it);; 847 //double weight = p.weight ();; 848 //Batch batch (it, it+1);; 849 Batch batch (begin (testPattern), end (testPattern));; 850 output.clear ();; 851 pass_through_type passThrough (settings, batch, dropContainerTest);; 852 double testPatternError = (*this) (passThrough, weights, ModeOutput::FETCH, output);; 853 if (output.size() == (outputSize() - 1) * batch.size()); 854 {; 855 auto output_iterator = output.begin();; 856 for (auto pattern_it = batch.begin(); pattern_it != batch.end(); ++pattern_it); 857 {; 858 for (size_t output_index = 1; output_index < outputSize(); ++output_index); 859 {; 860 settings.testSample (0, *output_iterator, (*pattern_it).output ().at (0),; 861 (*pattern_it).weight ());; 862 ++output_iterator;; 863 }; 864 }; 865 }; 866 testError += testPatternError; /// batch.size ();; 867 }; 868 // testError /= testPattern.size ();; 869 }; 870 settings.endTestCycle ();; 871// testError /= weightSum;; 872 ; 873 settings.computeResult (*this, weights);; 874 ; 875 hasConverged = settings.hasConverged (testError);; 876 if (!hasConverged && !isWeightsForDrop); 877 {; 878 dropOutWeightFactor (weights, dropFractions, true); // inverse; 879 isWeightsForDrop = true;; 880 }; 881 }; 882 ++testCycleCount;; 883",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8icc_source.html:25722,test,testPatternError,25722,doc/master/NeuralNet_8icc_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8icc_source.html,1,['test'],['testPatternError']
Testability,r 1 :Event : Event/I *; *Entries : 10000 : Total Size= 40712 bytes File Size = 11231 *; *Baskets : 1 : Basket Size= 32000 bytes Compression= 2.85 *; *............................................................................*; *Br 2 :x : x/F *; *Entries : 10000 : Total Size= 40684 bytes File Size = 27116 *; *Baskets : 1 : Basket Size= 32000 bytes Compression= 1.18 *; *............................................................................*; *Br 3 :y : y/F *; *Entries : 10000 : Total Size= 40684 bytes File Size = 27035 *; *Baskets : 1 : Basket Size= 32000 bytes Compression= 1.18 *; *............................................................................*; *Br 4 :z : z/F *; *Entries : 10000 : Total Size= 40684 bytes File Size = 29174 *; *Baskets : 1 : Basket Size= 32000 bytes Compression= 1.10 *; *............................................................................*; ******************************************************************************; *Tree :TF : test friend trees *; *Entries : 8460 : Total = 375780 bytes File Size = 128536 *; * : : Tree compression factor = 1.69 *; ******************************************************************************; *Br 0 :Run : Run/I *; *Entries : 8460 : Total Size= 34463 bytes File Size = 374 *; *Baskets : 2 : Basket Size= 32000 bytes Compression= 90.84 *; *............................................................................*; *Br 1 :Event : Event/I *; *Entries : 8460 : Total Size= 34475 bytes File Size = 12152 *; *Baskets : 2 : Basket Size= 32000 bytes Compression= 2.80 *; *............................................................................*; *Br 2 :x : x/F *; *Entries : 8460 : Total Size= 34451 bytes File Size = 28849 *; *Baskets : 2 : Basket Size= 32000 bytes Compression= 1.18 *; *............................................................................*; *Br 3 :y : y/F *; *Entries : 8460 : Total Size= 34451 bytes File Size = 28757 *; *Baskets : 2 : Basket Size= 32000 bytes Compression,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/treefriend_8C.html:2260,test,test,2260,doc/master/treefriend_8C.html,https://root.cern,https://root.cern/doc/master/treefriend_8C.html,1,['test'],['test']
Testability,"r Classification ...; : Rebuilding Dataset Category_Likelihood_1_dsi; : Building event vectors for type 2 Signal; : Dataset[Category_Likelihood_1_dsi] : create input formulas for tree TreeS; : Building event vectors for type 2 Background; : Dataset[Category_Likelihood_1_dsi] : create input formulas for tree TreeB; <HEADER> DataSetFactory : [Category_Likelihood_1_dsi] : Number of events in input trees; : Dataset[Category_Likelihood_1_dsi] : Signal requirement: ""abs(eta)<=1.3""; : Dataset[Category_Likelihood_1_dsi] : Signal -- number of events passed: 5123 / sum of weights: 5123 ; : Dataset[Category_Likelihood_1_dsi] : Signal -- efficiency : 0.5123; : Dataset[Category_Likelihood_1_dsi] : Background requirement: ""abs(eta)<=1.3""; : Dataset[Category_Likelihood_1_dsi] : Background -- number of events passed: 5134 / sum of weights: 5134 ; : Dataset[Category_Likelihood_1_dsi] : Background -- efficiency : 0.5134; : Dataset[Category_Likelihood_1_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.5123 preselection efficiency); : Dataset[Category_Likelihood_1_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.5134 preselection efficiency); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 2561; : Signal -- testing events : 2561; : Signal -- training and testing events: 5122; : Dataset[Category_Likelihood_1_dsi] : Signal -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.5123; : Background -- training events : 2567; : Background -- testing events : 2567; : Background -- training and testing events: 5134; : Dataset[Category_Likelihood_1_dsi] : Background -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.5134; : ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassificationCategory_8C.html:14009,test,testing,14009,doc/master/TMVAClassificationCategory_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html,1,['test'],['testing']
Testability,"r Classifiers.. void TrainMethod(). void GetRegressionDeviation(UInt_t tgtNum, TMVA::Types::ETreeType type, Double_t& stddev, Double_t& stddev90Percent) const. void AddRegressionOutput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void AddMulticlassOutput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void NoErrorCalc(Double_t *const err, Double_t *const errUpper). Double_t GetMvaValue(const TMVA::Event *const ev, Double_t* err = 0, Double_t* errUpper = 0). Bool_t IsSignalLike(). Bool_t IsSignalLike(Double_t mvaVal). void AddClassifierOutput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void AddClassifierOutputProb(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); calculate <sum-of-deviation-squared> of regression output versus ""true"" value from test sample. bias = average deviation; dev = average absolute deviation; rms = rms of deviation. void TestMulticlass(); test multiclass classification. void TestClassification(); initialization. void WriteStateToStream(ostream& tf) const; general method used in writing the header of the weight files where; the used variables, variable transformation type etc. is specified. void AddInfoItem(void* gi, const TString& name, const TString& value) const; xml writing. void AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType). void WriteStateToXML(void* parent) const; general method used in writing the header of the weight files where; the used variables, variable transformation type etc. is specified. void ReadStateFromStream(TFile& rf); write reference MVA distributions (and other information); to a ROOT type weight file. void WriteSt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodBase.html:23436,test,test,23436,root/html530/TMVA__MethodBase.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodBase.html,2,['test'],['test']
Testability,"r Double_t TMath::Ccgs ();  \( cm s^{-1} \) ;  ; Double_t TMath::Ceil (Double_t x);  Rounds x upward, returning the smallest integral value that is not less than x. ;  ; Int_t TMath::CeilNint (Double_t x);  Returns the nearest integer of TMath::Ceil(x). ;  ; Double_t TMath::ChisquareQuantile (Double_t p, Double_t ndf);  Evaluate the quantiles of the chi-squared probability distribution function. ;  ; Double_t TMath::Cos (Double_t);  Returns the cosine of an angle of x radians. ;  ; Double_t TMath::CosH (Double_t);  Returns the hyperbolic cosine of x. ;  ; template<typename T > ; T * TMath::Cross (const T v1[3], const T v2[3], T out[3]);  Calculates the Cross Product of two vectors: out = [v1 x v2]. ;  ; constexpr Double_t TMath::CUncertainty ();  Speed of light uncertainty. ;  ; constexpr Double_t TMath::DegToRad ();  Conversion from degree to radian: \( \frac{\pi}{180} \). ;  ; Double_t TMath::DiLog (Double_t x);  Modified Struve functions of order 1. ;  ; constexpr Double_t TMath::E ();  Base of natural log: \( e \). ;  ; Double_t TMath::Erf (Double_t x);  Computation of the error function erf(x). ;  ; Double_t TMath::Erfc (Double_t x);  Computes the complementary error function erfc(x). ;  ; Double_t TMath::ErfcInverse (Double_t x);  Returns the inverse of the complementary error function. ;  ; Double_t TMath::ErfInverse (Double_t x);  Returns the inverse error function. ;  ; constexpr Double_t TMath::EulerGamma ();  Euler-Mascheroni Constant. ;  ; Double_t TMath::Exp (Double_t x);  Returns the base-e exponential function of x, which is e raised to the power x. ;  ; Double_t TMath::Factorial (Int_t i);  Computes factorial(n). ;  ; Double_t TMath::FDist (Double_t F, Double_t N, Double_t M);  Computes the density function of F-distribution (probability function, integral of density, is computed in FDistI). ;  ; Double_t TMath::FDistI (Double_t F, Double_t N, Double_t M);  Calculates the cumulative distribution function of F-distribution (see ROOT::Math::fdistributi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8h.html:5398,log,log,5398,doc/master/TMath_8h.html,https://root.cern,https://root.cern/doc/master/TMath_8h.html,1,['log'],['log']
Testability,"r Functions inherited from RooAbsCachedReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static void verboseDirty (bool flag);  Activate verbose messaging related to dirty flag propagation. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Versi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedReal.html:46873,log,logEvalError,46873,doc/master/classRooCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooCachedReal.html,9,['log'],"['logEvalError', 'logging']"
Testability,"r Functions inherited from RooAbsHiddenReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static void verboseDirty (bool flag);  Activate verbose messaging related to dirty flag propagation. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Versi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooUnblindCPAsymVar.html:47353,log,logEvalError,47353,doc/master/classRooUnblindCPAsymVar.html,https://root.cern,https://root.cern/doc/master/classRooUnblindCPAsymVar.html,12,['log'],"['logEvalError', 'logging']"
Testability,"r GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TCanvasThe Canvas class.Definition TCanvas.h:23; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TViewSee TView3D.Definition TView.h:25; TView::CreateViewstatic TView * CreateView(Int_t system=1, const Double_t *rmin=nullptr, const Double_t *rmax=nullptr)Create a concrete default 3-d view via the plug-in manager.Definition TView.cxx:27; TView::SetRangevirtual void SetRange(const Double_t *min, const Double_t *max)=0; double; int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; lTLine lDefinition textangle.C:4. TPolyLine3D is a basic graphics primitive which ignores the fact the current pad has logarithmic scale(s). It simply draws the 3D line in the current user coordinates. If logarithmic scale is set along one of the three axis, the logarithm of vector coordinates along this axis should be use. Alternatively and higher level class, knowing about logarithmic scales, might be used. For instance TGraph2D with option L. ; Definition at line 32 of file TPolyLine3D.h. Public Member Functions;  TPolyLine3D ();  3-D polyline default constructor. ;  ;  TPolyLine3D (const TPolyLine3D &polylin);  3-D polyline copy ctor. ;  ;  TPolyLine3D (Int_t n, Double_t const *p, Option_t *option="""");  3-D polyline normal constructor. ;  ;  TPolyLine3D (Int_t n, Double_t const *x, Double_t const *y, Double_t const *z, Option_t *option="""");  3-D polyline normal constructor. ;  ;  TPolyLine3D (Int_t n, Float_t const *p, Option_t *option="""");  3-D polyline normal constructor. ;  ;  TPolyLine3D (Int_t n, Float_t const *x, Float_t const *y, Float_t const *z, Option_t *op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPolyLine3D.html:2766,log,logarithmic,2766,doc/master/classTPolyLine3D.html,https://root.cern,https://root.cern/doc/master/classTPolyLine3D.html,1,['log'],['logarithmic']
Testability,"r GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::Smoothvirtual void Smooth(Int_t ntimes=1, Option_t *option="""")Smooth bin contents of this histogram.Definition TH1.cxx:6879; TH1::GetStdDevvirtual Double_t GetStdDev(Int_t axis=1) constReturns the Standard Deviation (Sigma).Definition TH1.cxx:7607; TH1::GetMeanvirtual Double_t GetMean(Int_t axis=1) constFor axis = 1,2 or 3 returns the mean value of the histogram along X,Y or Z axis.Definition TH1.cxx:7535; TH1::Resetvirtual void Reset(Option_t *option="""")Reset this histogram: contents, errors, etc.Definition TH1.cxx:7103; TH1::Integralvirtual Double_t Integral(Option_t *option="""") constReturn integral of bin contents.Definition TH1.cxx:7941; TH1::GetEntriesvirtual Double_t GetEntries() constReturn the current number of entries.Definition TH1.cxx:4423; TH1::KolmogorovTestvirtual Double_t KolmogorovTest(const TH1 *h2, Option_t *option="""") constStatistical test of compatibility in shape between this histogram and h2, using Kolmogorov test.Definition TH1.cxx:8178; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; IMPORTANT NOTE: The returned values for GetMean and GetStdDev depend on how the histogram statistics are calculated. By default, if no range has been set, the returned values are the (unbinned) ones calculated at fill time. If a range has been set, however, the values are calculated using the bins in range; THIS IS TRUE EVEN IF THE RANGE INCLUDES ALL BINS–use TAxis::SetRange(0, 0) to unset the range. To ensure that the returned values are always those of the binned data stored in the histogram, call TH1::ResetStats. See TH1::GetStats. ; Definition at line 59 of file TH1.h. Public Types; enum  { ;   kNoAxis = 0; , kXaxis = (1ULL << ( 0 )); , kYaxis = (1ULL << ( 1 )); , kZaxis = (1ULL << ( 2 )); , ;   kAllAxes = kXaxis | kYaxis | kZaxis. };  Enumeration specifying which axes can be extended. More...;  ; enum ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:22029,test,test,22029,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,2,['test'],['test']
Testability,"r Iterative Peak (SNIP) clipping algorithm.; new value in the channel ""i"" is calculated. \[; v_p(i) = min \left\{ v_{p-1}(i)^{\frac{\left[v_{p-1}(i+p)+v_{p-1}(i-p)\right]}{2}} \right\}; \]. where p = 1, 2, ..., numberIterations. In fact it represents second order difference filter (-1,2,-1).; One can also change the direction of the change of the clipping window, the order of the clipping filter, to include smoothing, to set width of smoothing window and to include the estimation of Compton edges. On successful completion it returns 0. On error it returns pointer to the string describing error.; Parameters:. spectrum: pointer to the vector of source spectrum; ssize: length of the spectrum vector; numberIterations: maximal width of clipping window,; direction: direction of change of clipping window. Possible values: kBackIncreasingWindow, kBackDecreasingWindow; filterOrder: order of clipping filter. Possible values: kBackOrder2, kBackOrder4, kBackOrder6, kBackOrder8; smoothing: logical variable whether the smoothing operation in the estimation of background will be included. Possible values: kFALSE, kTRUE; smoothWindow: width of smoothing window. Possible values: kBackSmoothing3, kBackSmoothing5, kBackSmoothing7, kBackSmoothing9, kBackSmoothing11, kBackSmoothing13, kBackSmoothing15.; compton: logical variable whether the estimation of Compton edge will be included. Possible values: kFALSE, kTRUE. References:. C. G Ryan et al.: SNIP, a statistics-sensitive background treatment for the quantitative analysis of PIXE spectra in geoscience applications. NIM, B34 (1988), 396-402.; M. Morhac;, J. Kliman, V. Matouoek, M. Veselsky, I. Turzo: Background elimination methods for multidimensional gamma-ray spectra. NIM, A401 (1997) 113-132.; D. D. Burgess, R. J. Tervo: Background estimation for gamma-ray spectroscopy. NIM 214 (1983), 431-434. Example 1 script Background_incr.C:; Example of the estimation of background for number of iterations=6. Original spectrum is shown in black",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum.html:20558,log,logical,20558,doc/master/classTSpectrum.html,https://root.cern,https://root.cern/doc/master/classTSpectrum.html,1,['log'],['logical']
Testability,"r an directory of the local file system; THtml::TFileSysEntry an entry of the local file system; THtml::TFileSysRoot an root directory of the local file system; THtml::THelperBase a helper object's base class; THtml::TModuleDefinition helper class to determine a class's module; THtml::TPathDefinition helper class to determine directory layouts; TImage Abstract image class; TImageDump create image in batch mode; TImagePalette Color Palette for value -> color conversion; TImagePlugin base class for different image format handlers(plugins); TIndArray ; TIndexTable ""Index"" array for TTable object; TIndexTable::iterator ; TInetAddress Represents an Internet Protocol (IP) address; TInspectCanvas The canvas Inspector; TInspectorImp GUI independent inspector abc; TInterpreter ABC defining interface to generic interpreter; TIsAProxy ; TIter Iterator wrapper; TIterator Iterator abstract base class; TKDEFGT FGT based kernel density estimator.; TKDTree<int,double> KD tree; TKDTree<int,float> KD tree; TKey Header description of a logical record on file.; TKeyMapFile Utility class for browsing TMapFile objects.; TKeySQL a special TKey for SQL data base; TKeyXML a special TKey for XML files ; TLatex The Latex-style text processor class; TLeaf Leaf: description of a Branch data type; TLeafB A TLeaf for an 8 bit Integer data type.; TLeafC A TLeaf for a variable length string.; TLeafD A TLeaf for a 64 bit floating point data type.; TLeafElement A TLeaf for a general object derived from TObject.; TLeafF A TLeaf for a 32 bit floating point data type.; TLeafI A TLeaf for an Integer data type.; TLeafL A TLeaf for a 64 bit Integer data type.; TLeafO A TLeaf for an 8 bit Integer data type.; TLeafObject A TLeaf for a general object derived from TObject.; TLeafS A TLeaf for a 16 bit Integer data type.; TLegend Legend of markers/lines/boxes to represent obj's; TLegendEntry Storage class for one entry of a TLegend; TLibraryDocInfo documentation for a library; TLimit Class to compute 95% CL limi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:91281,log,logical,91281,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,1,['log'],['logical']
Testability,r component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooArgSet*_normSetPointer to set with observables used for normalization; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_optimized!; RooAbsData*_origDataOriginal data ; RooAbsReal*_origFuncOriginal function ; Bool_t_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; TRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_t_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooA,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsOptTestStatistic.html:35398,test,test,35398,root/html532/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html532/RooAbsOptTestStatistic.html,3,['test'],['test']
Testability,"r configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsOptTestStatistic.html:35476,test,test,35476,root/html526/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html526/RooAbsOptTestStatistic.html,3,['test'],['test']
Testability,"r each bin and divided by the; // bin width. The parameter for IntegrateBins() is the required precision; // for the numeric integrals. This is computationally expensive, but the; // bias is now not a problem anymore.; std::unique_ptr<RooFitResult> fit5{; powerlaw.fitTo(*powerlawData, IntegrateBins(1e-3), Save(), PrintLevel(-1), SumW2Error(false))};; fit5->Print();; ; // Improving numerical stability; // -----------------------------; ; // There is one more problem with binned fits that is related to the binning; // effects because often, a binned fit is affected by both problems.; //; // The issue is numerical stability for fits with a greatly different number; // of events in each bin. For each bin, you have a term \f[n\log(p)\f] in; // the NLL, where \f[n\f] is the number of observations in the bin, and; // \f[p\f] the predicted probability to have an event in that bin. The; // difference in the logarithms for each bin is small, but the difference in; // \f[n\f] can be orders of magnitudes! Therefore, when summing these terms,; // lots of numerical precision is lost for the bins with less events.; ; // We can study this with the example of an exponential plus a Gaussian. The; // Gaussian is only a faint signal in the tail of the exponential where; // there are not so many events. And we can't afford any precision loss for; // these bins, otherwise we can't fit the Gaussian.; ; x.setBins(100); // It's not about binning effects anymore, so reset the number of bins.; ; RooRealVar mu{""mu"", ""mu"", 3.0, 0.1, 5.1};; RooRealVar sigma{""sigma"", ""sigma"", 0.5, 0.01, 5.0};; RooGaussian gauss{""gauss"", ""gauss"", x, mu, sigma};; ; RooRealVar nsig{""nsig"", ""nsig"", 10000, 0, 1e9};; RooRealVar nbkg{""nbkg"", ""nbkg"", 10000000, 0, 1e9};; RooRealVar frac{""frac"", ""frac"", nsig.getVal() / (nsig.getVal() + nbkg.getVal()), 0.0, 1.0};; ; RooAddPdf model{""model"", ""model"", {gauss, expo}, {nsig, nbkg}};; ; std::unique_ptr<RooAbsData> modelData{model.generateBinned(x)};; ; // Set the starting values ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:6382,log,logarithms,6382,doc/master/rf614__binned__fit__problems_8C.html,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html,1,['log'],['logarithms']
Testability,"r each neuron, separated by comas. Hidden layers are just described by the number of neurons. The layers are separated by colons. In addition, input/output layer formulas can be preceded by '@' (e.g ""@out"") if one wants to also normalize the data from the TTree. Input and outputs are taken from the TTree given as second argument. Expressions are evaluated as for TTree::Draw(), arrays are expended in distinct neurons, one for each index. This can only be done for fixed-size arrays. If the formula ends with ""!"", softmax functions are used for the output layer. One defines the training and test datasets by TEventLists.; Example: TMultiLayerPerceptron(""x,y:10:5:f"",inputTree);; TMultiLayerPerceptron::TMultiLayerPerceptronTMultiLayerPerceptron()Default constructor.Definition TMultiLayerPerceptron.cxx:264; Both the TTree and the TEventLists can be defined in the constructor, or later with the suited setter method. The lists used for training and test can be defined either explicitly, or via a string containing the formula to be used to define them, exactly as for a TCut.; The learning method is defined using the TMultiLayerPerceptron::SetLearningMethod() . Learning methods are :. TMultiLayerPerceptron::kStochastic,; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS. A weight can be assigned to events, either in the constructor, either with TMultiLayerPerceptron::SetEventWeight(). In addition, the TTree weight is taken into account.; Finally, one starts the training with TMultiLayerPerceptron::Train(Int_t nepoch, Option_t* options). The first argument is the number of epochs while option is a string that can contain: ""text"" (simple text output) , ""graph"" (evoluting graphical training curves), ""update=X"" (step for the text/graph output update) or ""+"" (will skip the randomisation and start from the previous values). All combinations are availabl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:7296,test,test,7296,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,1,['test'],['test']
Testability,"r for 1D ridges in y direction (slope), for details see html manual and references ;  ; Double_t fChi;  here the fitting functions return resulting chi square ;  ; Int_t fFitTaylor;  order of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function. ;  ; Bool_t fFixA0;  logical value of a0 parameter, which allows to fix the parameter (not to fit). ;  ; Bool_t * fFixAmp;  [fNPeaks] array of logical values which allow to fix appropriate amplitudes of 2D peaks (not fit). However they are present in the estimated functional ;  ; Bool_t * fFixAmpX1;  [fNPeaks] array of logical values which allow to fix appropriate amplitudes of 1D ridges in x direction (not fit). However they are present in the estimated functional ;  ; Bool_t * fFixAmpY1;  [fNPeaks] array of logical values which allow to fix appropriate amplitudes of 1D ridges in y direction (not fit). However they are present in the estimated functional ;  ; Bool_t fFixAx;  logical value of ax parameter, which allows to fix the parameter (not to fit). ;  ; Bool_t fFixAy;  logical value of ay parameter, which allows to fix the parameter (not to fit). ;  ; Bool_t fFixBx;  logical value of b parameter for 1D ridges in x direction, which allows to fix the parameter (not to fit). ;  ; Bool_t fFixBy;  logical value of b parameter for 1D ridges in y direction, which allows to fix the parameter (not to fit). ;  ; Bool_t * fFixPositionX;  [fNPeaks] array of logical values which allow to fix appropriate x positions of 2D peaks (not fit). However they are present in the estimated functional ;  ; Bool_t * fFixPositionX1;  [fNPeaks] array of logical values which allow to fix appropriate x positions of 1D ridges (not fit). However they are present in the estimated functional ;  ; Bool_t * fFixPositionY;  [fNPeaks] array of logical values which allow to fix appropriate y positions of 2D peaks (not fit). However they are present in the estimated functional ;  ; Bool_t * fF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2Fit.html:26520,log,logical,26520,doc/master/classTSpectrum2Fit.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2Fit.html,1,['log'],['logical']
Testability,"r for vectorized; 818template <class T>; 819T TF1::EvalPar(const T *x, const Double_t *params); 820{; 821 if (fType == EFType::kTemplVec || fType == EFType::kTemplScalar) {; 822 return EvalParTempl(x, params);; 823 } else if (fType == EFType::kFormula) {; 824 return fFormula->EvalPar(x, params);; 825 } else; 826 return TF1::EvalPar((double *)x, params);; 827}; 828 ; 829////////////////////////////////////////////////////////////////////////////////; 830/// Eval for vectorized functions; 831// template <class T>; 832// T TF1::Eval(T x, T y, T z, T t) const; 833// {; 834// if (fType == EFType::kFormula); 835// return fFormula->Eval(x, y, z, t);; 836 ; 837// T xx[] = {x, y, z, t};; 838// Double_t *pp = (Double_t *)fParams->GetParameters();; 839// return ((TF1 *)this)->EvalPar(xx, pp);; 840// }; 841 ; 842// Internal to TF1. Evaluates Templated interfaces; 843template <class T>; 844inline T TF1::EvalParTempl(const T *data, const Double_t *params); 845{; 846 assert(fType == EFType::kTemplScalar || fType == EFType::kTemplVec);; 847 if (!params) params = (Double_t *)fParams->GetParameters();; 848 if (fFunctor); 849 return ((TF1FunctorPointerImpl<T> *)fFunctor.get())->fImpl(data, params);; 850 ; 851 // this should throw an error; 852 // we nned to implement a vectorized GetSave(x); 853 return TMath::SignalingNaN();; 854}; 855 ; 856#ifdef R__HAS_VECCORE; 857// Internal to TF1. Evaluates Vectorized TF1 on data of type Double_v; 858inline double TF1::EvalParVec(const Double_t *data, const Double_t *params); 859{; 860 assert(fType == EFType::kTemplVec);; 861 std::vector<ROOT::Double_v> d(fNdim);; 862 ROOT::Double_v res;; 863 ; 864 for(auto i=0; i<fNdim; i++) {; 865 d[i] = ROOT::Double_v(data[i]);; 866 }; 867 ; 868 if (fFunctor) {; 869 res = ((TF1FunctorPointerImpl<ROOT::Double_v> *) fFunctor.get())->fImpl(d.data(), params);; 870 } else {; 871 // res = GetSave(x);; 872 return TMath::SignalingNaN();; 873 }; 874 return vecCore::Get<ROOT::Double_v>(res, 0);; 875}; 876#endif; 877 ; 87",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8h_source.html:36208,assert,assert,36208,doc/master/TF1_8h_source.html,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html,1,['assert'],['assert']
Testability,"r from GSL based on the ROOT::Math::GSLMinimizer. Available algorithms are:; 66 /// - BFGS2 (default); 67 /// - BFGS; 68 /// - ConjugateFR; 69 /// - ConjugatePR; 70 /// - SteepestDescent; 71 /// - GSLMultiFit Minimizer based on GSL for minimizing only non linear least-squared functions (using an approximation similar to Fumili). See ROOT::Math::GSLMultiFit.; 72 /// - GSLSimAn Simulated annealing minimizer from GSL (see ROOT::Math::GSLSimAnMinimizer). It is a stochastic minimization algorithm using only function values and not the gradient.; 73 /// - Genetic Genetic minimization algorithms (see TMVA::Genetic); 74 ///; 75 static void SetDefaultMinimizer(const char *type, const char *algo = nullptr);; 76 ; 77 /// Set the default level for computing the parameter errors.; 78 /// For example for 1-sigma parameter errors; 79 /// - up = 1 for a chi-squared function; 80 /// - up = 0.5 for a negative log-likelihood function; 81 ///; 82 /// The value will be used also by Minos when computing the confidence interval; 83 static void SetDefaultErrorDef(double up);; 84 ; 85 /// Set the Minimization tolerance.; 86 /// The Default value for Minuit and Minuit2 is 0.01; 87 static void SetDefaultTolerance(double tol);; 88 ; 89 /// Set the default Minimizer precision.; 90 /// (used only by MInuit and Minuit2); 91 /// It is used to specify the numerical precision used for computing the; 92 /// objective function. It should be left to the default value found by the Minimizer; 93 /// (typically double precision); 94 static void SetDefaultPrecision(double prec);; 95 ; 96 /// Set the maximum number of function calls.; 97 static void SetDefaultMaxFunctionCalls(int maxcall);; 98 ; 99 /// Set the maximum number of iterations.; 100 /// Used by the GSL minimizers and Genetic. Not used by Minuit,Minuit2.; 101 static void SetDefaultMaxIterations(int maxiter);; 102 ; 103 /// Set the default strategy.; 104 /// The strategy is a parameter used only by Minuit and Minuit2.; 105 /// Possible values are:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MinimizerOptions_8h_source.html:3447,log,log-likelihood,3447,doc/master/MinimizerOptions_8h_source.html,https://root.cern,https://root.cern/doc/master/MinimizerOptions_8h_source.html,1,['log'],['log-likelihood']
Testability,"r from standard ROOT representation, that is color index; + transparency in range [0, 100]. void SetupGLColors(TGLRnrCtx& rnrCtx, const Float_t* color = 0) const; Setup colors - avoid setting things not required; for current draw flags. void Draw(TGLRnrCtx& rnrCtx) const; Draw physical shape, using LOD flags, potential from display list cache. void CalculateShapeLOD(TGLRnrCtx& rnrCtx, Float_t& pixSize, Short_t& shapeLOD) const; Calculate shape-lod, suitible for use under; projection defined by 'rnrCtx', taking account of which local; axes of the shape support LOD adjustment, and the global; 'sceneFlags' passed. Returned shapeLOD component is from 0 (kLODPixel - lowest; quality) to 100 (kLODHigh - highest quality). Scene flags are not used. LOD quantization is not done. RnrCtx; is not modified as this is called via lodification stage of; rendering. void QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD, Short_t& quantLOD) const; Factor in scene/vierer LOD and Quantize ... forward to; logical shape. void InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; Request creation of context menu on shape, attached to 'menu' at screen position; 'x' 'y'. TGLVector3 GetScale() const. TGLVertex3 GetTranslation() const. void SetTransform(const TGLMatrix& transform). void SetTransform(const Double_t* vals). void SetTranslation(const TGLVertex3& translation). void Translate(const TGLVector3& vect). void Scale(const TGLVector3& scale). void Rotate(const TGLVertex3& pivot, const TGLVector3& axis, Double_t angle). TGLPhysicalShape(const TGLPhysicalShape& ). TGLPhysicalShape& operator=(const TGLPhysicalShape& ). UInt_t ID() const; { return fID; }. const TGLLogicalShape * GetLogical() const; { return fLogicalShape; }. const TGLPhysicalShape * GetNextPhysical() const; { return fNextPhysical; }. EManip GetManip() const; Modification and manipulation. { return fManip; }. void SetManip(TGLPhysicalShape::EManip manip); { fManip = manip; }. Bool_t IsModified() const; { return fMo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLPhysicalShape.html:7266,log,logical,7266,root/html528/TGLPhysicalShape.html,https://root.cern,https://root.cern/root/html528/TGLPhysicalShape.html,4,['log'],['logical']
Testability,"r from standard ROOT representation, that is color index; + transparency in range [0, 100]. void SetupGLColors(TGLRnrCtx& rnrCtx, const Float_t* color = 0) const; Setup colors - avoid setting things not required; for current draw flags. void Draw(TGLRnrCtx& rnrCtx) const; Draw physical shape, using LOD flags, potential from display list cache. void CalculateShapeLOD(TGLRnrCtx& rnrCtx, Float_t& pixSize, Short_t& shapeLOD) const; Calculate shape-lod, suitible for use under; projection defined by 'rnrCtx', taking account of which local; axes of the shape support LOD adjustment, and the global; 'sceneFlags' passed. Returned shapeLOD component is from 0 (kLODPixel - lowest; quality) to 100 (kLODHigh - highest quality). Scene flags are not used. LOD quantization is not done. RnrCtx; is not modified as this is called via lodification stage of; rendering. void QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD, Short_t& quantLOD) const; Factor in scene/vierer LOD and Quantize ... forward to; logical shape. void InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; Request creation of context menu on shape, attached to 'menu' at screen position; 'x' 'y'. TGLVector3 GetScale() const. TGLVertex3 GetTranslation() const. void SetTransform(const TGLMatrix& transform). void SetTransform(const Double_t[16] vals). void SetTranslation(const TGLVertex3& translation). void Translate(const TGLVector3& vect). void Scale(const TGLVector3& scale). void Rotate(const TGLVertex3& pivot, const TGLVector3& axis, Double_t angle). TGLPhysicalShape(const TGLPhysicalShape& ). TGLPhysicalShape& operator=(const TGLPhysicalShape& ). UInt_t ID() const; { return fID; }. const TGLLogicalShape * GetLogical() const; { return fLogicalShape; }. const TGLPhysicalShape * GetNextPhysical() const; { return fNextPhysical; }. EManip GetManip() const; Modification and manipulation. { return fManip; }. void SetManip(TGLPhysicalShape::EManip manip); { fManip = manip; }. Bool_t IsModified() const; { return ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLPhysicalShape.html:7741,log,logical,7741,root/html602/TGLPhysicalShape.html,https://root.cern,https://root.cern/root/html602/TGLPhysicalShape.html,2,['log'],['logical']
Testability,"r if you're lucky even more. What about getting much more data crunched in the same time, or reducing the arrival time of your analysis results by factors?; TSelector; ROOT offers Proof lite - multiple ROOT processes ""hacking away"" on the same analysis. For that to work your analysis must be written using the TSelector interface: it must publicly derive from it and implement SlaveBegin() where you create the histograms, Process(Long64_t entry) to process the data, and Terminate() to do fits etc. You can find an example for using a TTreeReader within a TSelector here; try to adapt to to our tree and our efficiency determination.; TChain; Proof lite will run the TSelector on several input files in parallel - actually, it chunks the input (even of one file) and sends these chunks to worker processes. You can combine TTrees from multiple files (if they have the same name and structure) using a TChain:; TChain* chain = new TChain(""MyTree"");; chain->AddFile(""http://root.cern.ch/root/files/tutorials/mockupx.root"");; chain->AddFile(""http://root.cern.ch/root/files/tutorials/mockupx_1.root"");; chain->AddFile(""http://root.cern.ch/root/files/tutorials/mockupx_2.root"");; chain->AddFile(""http://root.cern.ch/root/files/tutorials/mockupx_3.root"");; chain->Process(""MySelector.C+""); // if you have put your selector from above into MySelector.C. The last line will run the selector on the whole chain. O - but that takes ages! We need to:; Enable Proof Lite; There are two parts to using Proof lite: you need to create an instance and you need to tell the chain to use that instance:; // Create a Proof-lite instance:; TProof::Open("""");; // tell the chain that we want to use PROOF; chain->SetProof();; // And this will now use all your cores!; chain->Process(""MySelector.C+"");. Spoiler: here is the solution!; . ‹ 9. Fitting By Coding; up; TutorialSelector.C ›. Navigate through this book; 0. Setting up ROOT; 1. Extracting an object from a TFile; 2. Running code in ROOT; 4. Histogramming; 3. Ex",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/10-go-parallel.html:3143,mock,mockupx,3143,d/10-go-parallel.html,https://root.cern,https://root.cern/d/10-go-parallel.html,1,['mock'],['mockupx']
Testability,"r is needed. ; Definition at line 1584 of file TF1.cxx. ◆ GetLinearPart(). virtual const TObject * TF1::GetLinearPart ; (; Int_t ; i); const. inlinevirtual . Definition at line 493 of file TF1.h. ◆ GetMaximum(). Double_t TF1::GetMaximum ; (; Double_t ; xmin = 0, . Double_t ; xmax = 0, . Double_t ; epsilon = 1.E-10, . Int_t ; maxiter = 100, . Bool_t ; logx = false . ); const. virtual . Returns the maximum value of the function. ; Method: First, the grid search is used to bracket the maximum with the step size = (xmax-xmin)/fNpx. This way, the step size can be controlled via the SetNpx() function. If the function is unimodal or if its extrema are far apart, setting the fNpx to a small value speeds the algorithm up many times. Then, Brent's method is applied on the bracketed interval epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ) and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number of iteration of the Brent algorithm If the flag logx is set the grid search is done in log step size This is done automatically if the log scale is set in the current Pad; NOTE: see also TF1::GetMaximumX and TF1::GetX ; Reimplemented in TF2.; Definition at line 1614 of file TF1.cxx. ◆ GetMaximumStored(). virtual Double_t TF1::GetMaximumStored ; (; ); const. inlinevirtual . Definition at line 501 of file TF1.h. ◆ GetMaximumX(). Double_t TF1::GetMaximumX ; (; Double_t ; xmin = 0, . Double_t ; xmax = 0, . Double_t ; epsilon = 1.E-10, . Int_t ; maxiter = 100, . Bool_t ; logx = false . ); const. virtual . Returns the X value corresponding to the maximum value of the function. ; Method: First, the grid search is used to bracket the maximum with the step size = (xmax-xmin)/fNpx. This way, the step size can be controlled via the SetNpx() function. If the function is unimodal or if its extrema are far apart, setting the fNpx to a small value speeds the algorithm up many times. Then, Brent's method is applied on the bracketed interval epsilon (defa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1.html:75249,log,logx,75249,doc/master/classTF1.html,https://root.cern,https://root.cern/doc/master/classTF1.html,3,['log'],"['log', 'logx']"
Testability,"r is set to an empty string (the default), it is assumed that the Tree descriptor is given in the first line of the file with a syntax like: A/D:Table[2]/F:Ntracks/I:astring/C.; Otherwise branchDescriptor must be specified with the above syntax.Lines in the input file starting with “#” are ignored. A TBranch object is created for each variable in the expression. The total number of rows read from the file is returned.; 12.19 Trees in Analysis; The methods TTree::Draw, TTree::MakeClass and TTree::MakeSelector are available for data analysis using trees. The TTree::Draw method is a powerful yet simple way to look and draw the trees contents. It enables you to plot a variable (a leaf) with just one line of code. However, the Draw method falls short once you want to look at each entry and design more sophisticated acceptance criteria for your analysis. For these cases, you can use TTree::MakeClass. It creates a class that loops over the trees entries one by one. You can then expand it to do the logic of your analysis.; The TTree::MakeSelector is the recommended method for ROOT data analysis. It is especially important for large data set in a parallel processing configuration where the analysis is distributed over several processors and you can specify which entries to send to each processor. With MakeClass the user has control over the event loop, with MakeSelectorthe tree is in control of the event loop.; 12.20 Simple Analysis Using TTree::Draw; We will use the tree in cernstaff.root that was made by the macro in $ROOTSYS/tutorials/tree/staff.C.; First, open the file and lists its contents.; root[] TFile f (""cernstaff.root""); root[] f.ls(); TFile** cernstaff.root; TFile* cernstaff.root; KEY: TTree T;1 staff data from ascii file; We can see the TTree“T” in the file. We will use it to experiment with the TTree::Draw method, so let’s create a pointer to it:; root[] TTree *MyTree = T; Cling allows us to get simply the object by using it. Here we define a pointer to a TTree ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:584446,log,logic,584446,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['log'],['logic']
Testability,r log follows.; Parameter values: Abkg=0.024352 Asig=0.0100451 p_ph_sig2_gamma_bin_0=0.351536 p_ph_sig2_gamma_bin_1=0.352649 p_ph_sig2_gamma_bin_10=0.342736 p_ph_sig2_gamma_bin_11=0.36962 p_ph_sig2_gamma_bin_12=0.383863 p_ph_sig2_gamma_bin_13=0.366897 p_ph_sig2_gamma_bin_14=0.358549 p_ph_sig2_gamma_bin_15=0.358659 p_ph_sig2_gamma_bin_16=0.3674 p_ph_sig2_gamma_bin_17=0.356318 p_ph_sig2_gamma_bin_18=0.362267 p_ph_sig2_gamma_bin_19=0.340116 p_ph_sig2_gamma_bin_2=0.350595 p_ph_sig2_gamma_bin_20=0.352431 p_ph_sig2_gamma_bin_21=0.351643 p_ph_sig2_gamma_bin_22=0.35167 p_ph_sig2_gamma_bin_23=0.344542 p_ph_sig2_gamma_bin_24=0.365744 p_ph_sig2_gamma_bin_3=0.355252 p_ph_sig2_gamma_bin_4=0.34783 p_ph_sig2_gamma_bin_5=0.348683 p_ph_sig2_gamma_bin_6=0.357671 p_ph_sig2_gamma_bin_7=0.351115 p_ph_sig2_gamma_bin_8=0.342731 p_ph_sig2_gamma_bin_9=0.357348; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=0.327407 Asig=0.267678 p_ph_sig2_gamma_bin_0=0.638805 p_ph_sig2_gamma_bin_1=0.639545 p_ph_sig2_gamma_bin_10=0.632932 p_ph_sig2_gamma_bin_11=0.650729 p_ph_sig2_gamma_bin_12=0.659993 p_ph_sig2_gamma_bin_13=0.648946 p_ph_sig2_gamma_bin_14=0.643452 p_ph_sig2_gamma_bin_15=0.643524 p_ph_sig2_gamma_bin_16=0.649276 p_ph_sig2_gamma_bin_17=0.641977 p_ph_sig2_gamma_bin_18=0.645904 p_ph_sig2_gamma_bin_19=0.631174 p_ph_sig2_gamma_bin_2=0.638179 p_ph_sig2_gamma_bin_20=0.6394 p_ph_sig2_gamma_bin_21=0.638876 p_ph_sig2_gamma_bin_22=0.638894 p_ph_sig2_gamma_bin_23=0.634141 p_ph_sig2_gamma_bin_24=0.648189 p_ph_sig2_gamma_bin_3=0.641271 p_ph_sig2_gamma_bin_4=0.636338 p_ph_sig2_gamma_bin_5=0.636906 p_ph_sig2_gamma_bin_6=0.642872 p_ph_sig2_gamma_bin_7=0.638525 p_ph_sig2_gamma_bin_8=0.632929 p_ph_sig2_gamma_bin_9=0.642658; ; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -2291.45108203063683; Edm = 0.000217118570047712786; Nfcn = 1108; Abkg = 0.0614871 +/- 0.00221998 ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:37510,log,log,37510,doc/master/rf709__BarlowBeeston_8C.html,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html,2,['log'],['log']
Testability,"r more master branches contain subbranches with identical names, one must add a ""."" (dot) character at the end of the master branch name. This will force the name of the subbranches to be of the form master.subbranch instead of simply subbranch. This situation happens when the top level object has two or more members referencing the same class. For example, if a Tree has two branches B1 and B2 corresponding to objects of the same class MyClass, one can do: tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; Example: {; TTree T(""T"",""test list"");; TList *list = new TList();; ; TObjArray *a1 = new TObjArray();; a1->SetName(""a1"");; list->Add(a1);; TH1F *ha1a = new TH1F(""ha1a"",""ha1"",100,0,1);; TH1F *ha1b = new TH1F(""ha1b"",""ha1"",100,0,1);; a1->Add(ha1a);; a1->Add(ha1b);; TObjArray *b1 = new TObjArray();; b1->SetName(""b1"");; list->Add(b1);; TH1F *hb1a = new TH1F(""hb1a"",""hb1"",100,0,1);; TH1F *hb1b = new TH1F(""hb1b"",""hb1"",100,0,1);; b1->Add(hb1a);; b1->Add(hb1b);; ; TObjArray *a2 = new TObjArray();; a2->SetName(""a2"");; list->Add(a2);; TH1S *ha2a = new TH1S(""ha2a"",""ha2"",100,0,1);; TH1S *ha2b = new TH1S(""ha2b"",""ha2"",100,0,1);; a2->Add(ha2a);; a2->Add(ha2b);; ; T.Branch(list,16000,2);; T.Print();; }; TCollection::SetNamevoid SetName(const char *name)Definition TCollection.h:206; TH1S1-D histogram with a short per channel (see TH1 documentation)Definition TH1.h:498; TListA doubly linked list.Definition TList.h:38; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68. Reimplemented in TTreeSQL.; Definition at line 1833 of file TTree.cxx. ◆ Branch() [13/13]. Int_t TTree::Branch ; (; TList * ; list, . Int_t ; bufsize = 32000, . Int_t ; splitlevel = 99 . ). virtual . Deprecated function. U",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:89213,test,test,89213,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['test'],['test']
Testability,"r more master branches contain subbranches with identical names, one must add a ""."" (dot) character at the end of the master branch name. This will force the name of the subbranches to be of the form master.subbranch instead of simply subbranch. This situation happens when the top level object has two or more members referencing the same class. For example, if a Tree has two branches B1 and B2 corresponding to objects of the same class MyClass, one can do: tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; Example: {; TTree T(""T"",""test list"");; TList *list = new TList();; ; TObjArray *a1 = new TObjArray();; a1->SetName(""a1"");; list->Add(a1);; TH1F *ha1a = new TH1F(""ha1a"",""ha1"",100,0,1);; TH1F *ha1b = new TH1F(""ha1b"",""ha1"",100,0,1);; a1->Add(ha1a);; a1->Add(ha1b);; TObjArray *b1 = new TObjArray();; b1->SetName(""b1"");; list->Add(b1);; TH1F *hb1a = new TH1F(""hb1a"",""hb1"",100,0,1);; TH1F *hb1b = new TH1F(""hb1b"",""hb1"",100,0,1);; b1->Add(hb1a);; b1->Add(hb1b);; ; TObjArray *a2 = new TObjArray();; a2->SetName(""a2"");; list->Add(a2);; TH1S *ha2a = new TH1S(""ha2a"",""ha2"",100,0,1);; TH1S *ha2b = new TH1S(""ha2b"",""ha2"",100,0,1);; a2->Add(ha2a);; a2->Add(ha2b);; ; T.Branch(list,16000,2);; T.Print();; }; TCollection::SetNamevoid SetName(const char *name)Definition TCollection.h:206; TH1S1-D histogram with a short per channel (see TH1 documentation)Definition TH1.h:499; TListA doubly linked list.Definition TList.h:38; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68. Reimplemented in TTreeSQL.; Definition at line 1833 of file TTree.cxx. ◆ Branch() [13/13]. Int_t TTree::Branch ; (; TList * ; list, . Int_t ; bufsize = 32000, . Int_t ; splitlevel = 99 . ). virtual . Deprecated function. U",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:89386,test,test,89386,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,1,['test'],['test']
Testability,"r node to the local node. returns a ""master"" pointer if transformation has been found; otherwise 0;. void Paint(Option_t* option = """"); -*-*-*-*-*-*-*-*Paint Referenced node with current parameters; *-* ==============================================; -; *-* vis = 1 (default) shape is drawn; *-* vis = 0 shape is not drawn but its sons may be not drawn; *-* vis = -1 shape is not drawn. Its sons are not drawn; *-* vis = -2 shape is drawn. Its sons are not drawn; -; *. It draw the TVolumeView layers from the iFirst one (form the zero) till; iLast one reached. restrict the levels for ""range"" option. void PaintShape(Option_t* option); Paint shape of the node; To be called from the TObject::Paint method only. TString PathP() const; return the full path of this data set. void SavePrimitive(ostream& out, Option_t* option = """"); to be documented. void SetLineAttributes(); to be documented. void SetVisibility(Int_t vis = 1); to be documented. void Sizeof3D() const; -*-*-*-*Return total size of this 3-D Node with its attributes; *-* ==========================================================. void Add(TDataSet* dataset); { assert(0);}. void Add(TVolumeView* node); { TDataSet::Add(node);}. Bool_t IsMarked() const; { return TestBit(kMark); }. TList * GetListOfShapes() const; {return fListOfShapes;}. TShape * GetShape() const; {return fListOfShapes ? (TShape *)fListOfShapes->First():0;}. Int_t GetVisibility() const; {return GetNode() ? GetNode()->GetVisibility():0;}. TVolumeView(TVolumeView& viewNode). TVolumePosition * GetPosition() const; { return (TVolumePosition *)GetObject();}. Bool_t Is3D() const; {return kTRUE;}. TList * Nodes(); { return GetList();}. » Author: Valery Fine(fine@bnl.gov) 25/12/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/table:$Id$ » Last generated: 2015-03-15 16:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVolumeView.html:17328,assert,assert,17328,root/html534/TVolumeView.html,https://root.cern,https://root.cern/root/html534/TVolumeView.html,1,['assert'],['assert']
Testability,"r node to the local node. returns a ""master"" pointer if transformation has been found; otherwise 0;. void Paint(Option_t* option = """"); -*-*-*-*-*-*-*-*Paint Referenced node with current parameters; *-* ==============================================; -; *-* vis = 1 (default) shape is drawn; *-* vis = 0 shape is not drawn but its sons may be not drawn; *-* vis = -1 shape is not drawn. Its sons are not drawn; *-* vis = -2 shape is drawn. Its sons are not drawn; -; *. It draw the TVolumeView layers from the iFirst one (form the zero) till; iLast one reached. restrict the levels for ""range"" option. void PaintShape(Option_t* option); Paint shape of the node; To be called from the TObject::Paint method only. TString PathP() const; return the full path of this data set. void SavePrimitive(ostream& out, Option_t* option = """"); to be documented. void SetLineAttributes(); to be documented. void SetVisibility(Int_t vis = 1); to be documented. void Sizeof3D() const; -*-*-*-*Return total size of this 3-D Node with its attributes; *-* ==========================================================. void Add(TDataSet* dataset); { assert(0);}. void Add(TVolumeView* node); { TDataSet::Add(node);}. Bool_t IsMarked() const; { return TestBit(kMark); }. TList * GetListOfShapes() const; {return fListOfShapes;}. TShape * GetShape() const; {return fListOfShapes ? (TShape *)fListOfShapes->First():0;}. Int_t GetVisibility() const; {return GetNode() ? GetNode()->GetVisibility():0;}. TVolumeView(TVolumeView& viewNode). TVolumePosition * GetPosition() const; { return (TVolumePosition *)GetObject();}. Bool_t Is3D() const; {return kTRUE;}. TList * Nodes(); { return GetList();}. » Author: Valery Fine(fine@bnl.gov) 25/12/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/table:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TVolumeView.html:18274,assert,assert,18274,root/html604/TVolumeView.html,https://root.cern,https://root.cern/root/html604/TVolumeView.html,1,['assert'],['assert']
Testability,"r node to the local node. returns a ""master"" pointer if transformation has been found; otherwise 0;. void Paint(Option_t* option = """"); -*-*-*-*-*-*-*-*Paint Referenced node with current parameters; *-* ==============================================; -; *-* vis = 1 (default) shape is drawn; *-* vis = 0 shape is not drawn but its sons may be not drawn; *-* vis = -1 shape is not drawn. Its sons are not drawn; *-* vis = -2 shape is drawn. Its sons are not drawn; -; *. It draw the TVolumeView layers from the iFirst one (form the zero) till; iLast one reached. restrict the levels for ""range"" option. void PaintShape(Option_t* option); Paint shape of the node; To be called from the TObject::Paint method only. TString PathP() const; return the full path of this data set. void SavePrimitive(ostream& out, Option_t* option = """"); to be documented. void SetLineAttributes(); to be documented. void SetVisibility(Int_t vis = 1); to be documented. void Sizeof3D() const; -*-*-*-*Return total size of this 3-D Node with its attributes; *-* ==========================================================. void Add(TDataSet* dataset); { assert(0);}. void Add(TVolumeView* node); { TDataSet::Add(node);}. Bool_t IsMarked() const; { return TestBit(kMark); }. TList * GetListOfShapes() const; {return fListOfShapes;}. TShape * GetShape() const; {return fListOfShapes ? (TShape *)fListOfShapes->First():0;}. Int_t GetVisibility() const; {return GetNode() ? GetNode()->GetVisibility():0;}. TVolumeView(TVolumeView& viewNode). TVolumePosition * GetPosition() const; { return (TVolumePosition *)GetObject();}. Bool_t Is3D() const; {return kTRUE;}. TList * Nodes(); { return GetList();}. » Author: Valery Fine(fine@bnl.gov) 25/12/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/table:$Id$ » Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVolumeView.html:18274,assert,assert,18274,root/html602/TVolumeView.html,https://root.cern,https://root.cern/root/html602/TVolumeView.html,1,['assert'],['assert']
Testability,"r objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsOptTestStatistic(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t splitCutRange = kFALSE, Bool_t cloneInputData = kTRUE); Constructor taking function (real), a dataset (data), a set of projected observables (projSet). If; rangeName is not null, only events in the dataset inside the range will be used in the test; statistic calculation. If addCoefRangeName is not null, all RooAddPdf component of 'real' will be; instructed to fix their fraction definitions to the given named range. If nCPU is greater than; 1 the test statistic calculation will be paralellized over multiple processes. By default the data; is split with 'bulk' partitioning (each process calculates a contigious block of fraction 1/nCPU; of the data). For binned data this approach may be suboptimal as the number of bins with >0 entries; in each processing block many vary greatly thereby distributing the workload rather unevenly.; If interleave is set to true, the interleave partitioning strategy is used where each partition; i takes all bins for which (ibin % ncpu == i) which is more likely to result in an even workload.; If splitCutRange is true, a different rangeName constructed as rangeName_{catName} will be used; as range definition for each index state of a RooSimultaneous. RooAbsOptTestStat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsOptTestStatistic.html:44015,test,test,44015,root/html602/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html,2,['test'],['test']
Testability,"r of 3rd divisions. e.g.:; ndiv=0 --> no tick marks.; ndiv=2 --> 2 divisions, one tick mark in the middle of the axis. chopt : Drawing options (see below).; gridlength: grid length on main tick marks. It should be noted that func is not defined in the user's coordinate space, but in the new TGaxis space. If x is the original axis, w the new axis, and w = f(x) (for example, f is a calibration function converting ADC channels x to energy w), then func must be supplied as f^{-1}(w).; Examples:; {; TCanvas *c2 = new TCanvas(""c2"",""c2"",10,10,700,500);; ; gPad->DrawFrame(0.,-2.,10.,2);; ; TF1 *f1=new TF1(""f1"",""-x"",-10,10);; TGaxis *A1 = new TGaxis(0,2,10,2,""f1"",510,""-"");; A1->SetTitle(""axis with decreasing values"");; A1->Draw();; ; TF1 *f2=new TF1(""f2"",""exp(x)"",0,2);; TGaxis *A2 = new TGaxis(1,1,9,1,""f2"");; A2->SetTitle(""exponential axis"");; A2->SetLabelSize(0.03);; A2->SetTitleSize(0.03);; A2->SetTitleOffset(1.2);; A2->Draw();; ; TF1 *f3=new TF1(""f3"",""log10(x)"",1,1000);; TGaxis *A3 = new TGaxis(2,-2,2,0,""f3"",505,"""");; A3->SetTitle(""logarithmic axis"");; A3->SetLabelSize(0.02);; A3->SetTitleSize(0.03);; A3->SetTitleOffset(0.); // Axis title automatically placed; A3->Draw();; }; gPad#define gPadDefinition TVirtualPad.h:308; TF11-Dim function classDefinition TF1.h:233; TGaxisThe axis painter class.Definition TGaxis.h:24; TGaxis::SetTitleOffsetvoid SetTitleOffset(Float_t titleoffset=1)Definition TGaxis.h:128; TGaxis::SetTitleSizevoid SetTitleSize(Float_t titlesize)Definition TGaxis.h:129; TGaxis::SetTitlevirtual void SetTitle(const char *title="""")Change the title of the axis.Definition TGaxis.cxx:2942; TGaxis::SetLabelSizevoid SetLabelSize(Float_t labelsize)Definition TGaxis.h:107; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; f1TF1 * f1Definition legend1.C:11; c2return c2Definition legend2.C:14. Note that this functionality has some limitations and does not follow all the TGaxis setting. In particular the nu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGaxis.html:5873,log,logarithmic,5873,doc/master/classTGaxis.html,https://root.cern,https://root.cern/doc/master/classTGaxis.html,1,['log'],['logarithmic']
Testability,"r of function evaluations in calculating the integralDefinition AdaptiveIntegratorMultiDim.h:152; ROOT::Math::AdaptiveIntegratorMultiDim::RelErrordouble RelError() constreturn relative errorDefinition AdaptiveIntegratorMultiDim.h:137; ROOT::Math::BrentMinimizer1DUser class for performing function minimization.Definition BrentMinimizer1D.h:62; ROOT::Math::BrentMinimizer1D::SetFunctionvoid SetFunction(const ROOT::Math::IGenFunction &f, double xlow, double xup)Sets function to be minimized.Definition BrentMinimizer1D.cxx:48; ROOT::Math::BrentMinimizer1D::Minimizebool Minimize(int maxIter, double absTol=1.E-8, double relTol=1.E-10) overrideFind minimum position iterating until convergence specified by the absolute and relative tolerance or...Definition BrentMinimizer1D.cxx:76; ROOT::Math::BrentMinimizer1D::SetNpxvoid SetNpx(int npx)Set the number of point used to bracket root using a grid.Definition BrentMinimizer1D.h:116; ROOT::Math::BrentMinimizer1D::SetLogScanvoid SetLogScan(bool on)Set a log grid scan (default is equidistant bins) will work only if xlow > 0.Definition BrentMinimizer1D.h:122; ROOT::Math::BrentMinimizer1D::XMinimumdouble XMinimum() const overrideReturn current estimate of the position of the minimum.Definition BrentMinimizer1D.h:75; ROOT::Math::BrentMinimizer1D::FValMinimumdouble FValMinimum() const overrideReturn function value at current estimate of the minimum.Definition BrentMinimizer1D.cxx:67; ROOT::Math::BrentRootFinderClass for finding the root of a one dimensional function using the Brent algorithm.Definition BrentRootFinder.h:51; ROOT::Math::BrentRootFinder::SetFunctionbool SetFunction(const ROOT::Math::IGenFunction &f, double xlow, double xup) overrideSets the function for the rest of the algorithms.Definition BrentRootFinder.cxx:42; ROOT::Math::BrentRootFinder::Solvebool Solve(int maxIter=100, double absTol=1E-8, double relTol=1E-10) overrideReturns the X value corresponding to the function value fy for (xmin<x<xmax).Definition BrentRootFin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:155628,log,log,155628,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['log'],['log']
Testability,"r of nodes can be change with n(nodesx, nodesy). Example:. h2->Draw(""SPEC n(40,40)"");. Sometimes the displayed region is rather large. When displaying all; channels pictures become very dense and complicated. It is very difficult; to understand the overall shape of data. ""n(nx,ny)"" allows to change the; density of displayed channels. Only the channels coinciding with given; nodes are displayed. * * *. The visualization angles can be changed with a(alpha, beta, view).; Example:. h2->Draw(""SPEC n(40,40) dm(0,1) a(30,30,0)"");. Alpha defines the angle between bottom horizontal screen line and the; displayed space on the right side of the picture and beta on the left; side, respectively. One can rotate the 3-d space around vertical axis; going through the center of it employing the view parameter. Allowed; values are 0, 90, 180 and 270 degrees. * * *. zs(scale) changes the scale of the Z-axis Possible values are:. 0 = Linear (default); 1 = Log; 2 = Sqrt. If gPad->SetLogz() has been set, log scale on Z-axis is set automatically.; No need to use the zs() operator. Note that the X and Y axis are always; linear. * * *. ci(r,g,b), were r,g and b are floats defines the colors increments.; For sophisticated shading (Light, Height and LightHeight Display Modes; Groups) the color palette starts from the basic pen color (see pa(); function). There is a predefined number of color levels (256). Color in; every level is calculated by adding the increments of the r, g, b; components to the previous level. Using this function one can change the; color increments between two neighboring color levels. The function does; not apply dor the Simple Display Modes Group. The default values are:; (1,1,1). * * *. ca(color_algorithm) allows to choose the Color Algorithm.; To define the colors one can employ one of the following color algorithms; (RGB, CMY, CIE, YIQ, HVS models). When the level of a component reaches; the limit value one can choose either smooth transition (by decreasing; the limit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2Painter.html:39758,log,log,39758,root/html528/TSpectrum2Painter.html,https://root.cern,https://root.cern/root/html528/TSpectrum2Painter.html,6,['log'],['log']
Testability,"r of total parameters. ;  ; ROOT::Math::IMultiGenFunction * GetObjFunction () const;  Return a pointer to the objective function (FCN) If fitting directly using TBackCompFitter the pointer is managed by the class, which has been set previously when calling SetObjFunction or SetFCN Otherwise if the class is used in the backward compatible mode (e.g. ;  ; Double_t GetParameter (Int_t ipar) const override;  Parameter value. ;  ; Int_t GetParameter (Int_t ipar, char *name, Double_t &value, Double_t &verr, Double_t &vlow, Double_t &vhigh) const override;  Get all parameter info (name, value, errors) ;  ; Double_t GetParError (Int_t ipar) const override;  Parameter error. ;  ; const char * GetParName (Int_t ipar) const override;  Return name of parameter ipar. ;  ; Int_t GetStats (Double_t &amin, Double_t &edm, Double_t &errdef, Int_t &nvpar, Int_t &nparx) const override;  Get fit statistical information. ;  ; Double_t GetSumLog (Int_t i) override;  Sum of log (un-needed) ;  ; TFitResult * GetTFitResult () const;  Get a copy of the Fit result returning directly a new TFitResult. ;  ; TClass * IsA () const override;  ; Bool_t IsFixed (Int_t ipar) const override;  Query if parameter ipar is fixed. ;  ; void PrintResults (Int_t level, Double_t amin) const override;  Print the fit result. ;  ; void ReCreateMinimizer ();  Recreate a minimizer instance using the function and data set objective function in minimizers function to re-create FCN from stored data object and fit options. ;  ; void ReleaseParameter (Int_t ipar) override;  Release a fit parameter. ;  ; bool Scan (unsigned int ipar, TGraph *gr, double xmin=0, double xmax=0);  Scan parameter ipar between value of xmin and xmax A graph must be given which will be on return filled with the scan resul If the graph size is zero, a default size n = 40 will be used. ;  ; void SetFCN (void(*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t)) override;  Override setFCN to use the Adapter to Minuit2 FCN interface To set the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBackCompFitter.html:6574,log,log,6574,doc/master/classTBackCompFitter.html,https://root.cern,https://root.cern/doc/master/classTBackCompFitter.html,1,['log'],['log']
Testability,r over _clientListValue ; RooAbsData*_dataPointer to original input dataset; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*_funcPointer to original input function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxy_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; const RooArgSet*_projDepsPointer to set with projected observables; TListRooAbsArg::_proxyListlist of proxies; string_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_t_simCountTotal number of component p.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsTestStatistic.html:33384,test,test,33384,root/html528/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html528/RooAbsTestStatistic.html,4,['test'],['test']
Testability,r over _clientListValue; RooAbsData*_dataPointer to original input dataset; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Bool_t_doOffsetApply interval value offset to control numeric precision?; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_evalCarry! carry of Kahan sum in evaluatePartition; Int_t_extSet! Number of designated set to calculated extended term; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*_funcPointer to original input function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; pRooAbsTestStatistic*_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpMode_gofOpModeOperation mode of test statistic instance; vector<RooFit::MPSplit>_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_init! Is object initialized; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; pRooRealMPFE*_mpfeArray! Array of parallel execution frond ends; RooFit::MPSplit_mpinterlUse interleaving strategy rather than N-wise split for partioning of dataset for multiprocessor-split; Int_t_nCPUNumber of processors to use in parallel calculation mode; Int_t_nEventsTotal number of events in test statistic calculation; Int_t_nGofNumber of sub-contexts; static Int,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsTestStatistic.html:37816,test,test,37816,root/html602/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html602/RooAbsTestStatistic.html,2,['test'],['test']
Testability,"r pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:35366,test,test,35366,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,6,['test'],['test']
Testability,"r points; TGLViewer::EPushActionTGLViewer::fPushAction; TGLRedrawTimer*TGLViewer::fRedrawTimer! timer for triggering redraws; Bool_tTGLViewer::fReferenceOn! reference marker on?; TGLVertex3TGLViewer::fReferencePos! reference position; Bool_tTGLViewer::fResetCamerasOnNextUpdatereposition camera on next update; Bool_tTGLViewer::fResetCamerasOnUpdatereposition camera on each update; Bool_tTGLViewerBase::fResetSceneInfosOnRenderRequest rebuild of view-specific scene data.; TGLRnrCtx*TGLViewerBase::fRnrCtx; list<TGLSceneInfo*>TGLViewerBase::fScenesRegistered scenes.; TGLSelectRecordTGLViewer::fSecSelRec! select record from last secondary select (should go to context); TGLSelectRecordTGLViewer::fSelRec! select record from last select (should go to context); TGLManipSet*TGLViewer::fSelectedPShapeRef!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTGLViewer::fSmartRefresh! cache logicals during scene rebuilds, use TAtt3D time-stamp to determine if they are still valid; Bool_tTGLViewer::fSmoothLines! smooth line edge rendering; Bool_tTGLViewer::fSmoothPoints! smooth point edge rendering; Bool_tTGLViewer::fStereo! use stereo rendering; Float_tTGLViewer::fStereoEyeOffsetFac!; Float_tTGLViewer::fStereoFrustumAsymFac!; Float_tTGLViewer::fStereoZeroParallax! position of zero-parallax plane: 0 - near clipping plane, 1 - far clipping plane; Short_tTGLViewerBase::fStyleViewer-style for rendering.; TGLRectTGLViewer::fViewport! viewport - drawn area; vector<TGLSceneInfo*>TGLViewerBase::fVisScenesVisible scenes.; Float_tTGLViewerBase::fWFLineWOptional override of scene wire-frame line-width; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TGLColorSetTGLViewer::fgDefaultColorSet! a shared, default color-set; static Bool_tTGLViewer::fgUseDefaultColorSetForNewViewers! name says it all. private:. Int_tfBorder; TGCompositeFrame*fFrame. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLEmbeddedViewer.html:23314,log,logicals,23314,root/html528/TGLEmbeddedViewer.html,https://root.cern,https://root.cern/root/html528/TGLEmbeddedViewer.html,1,['log'],['logicals']
Testability,"r should be also replayed; TTimer*fTimerTimer used for replaying; Bool_tfWaitingForWindowSignalizes that we wait for a window to be registered in order; ULong64_tfWinWindow ID being currenty mapped; TTree*fWinTreeTTree with recorded windows (=registered during recording); Int_tfWinTreeEntriesNumber of registered windows during _recording_; TList*fWindowListList of TRecWinPair objects. Mapping of window IDs is stored here. Class Charts. Inheritance Chart:. TRecorderState. ←; TRecorderReplaying. Function documentation; TRecorderReplaying(const char* filename); Allocates all necessary data structures used for replaying; What is allocated here is deleted in destructor. ~TRecorderReplaying(); Closes all signal-slot connections; Frees all memory allocated in contructor. Bool_t Initialize(TRecorder* r, Bool_t showMouseCursor, TRecorder::EReplayModes mode); Initialization of data structures for replaying.; Start of replaying. Return value:; - kTRUE = everything is OK and replaying has begun; - kFALSE = non existing or invalid log file, replaying has not started. void RegisterWindow(Window_t w); Creates mapping for the newly registered window w and adds this; mapping to fWindowList. Called by signal whenever a new window is registered during replaying. The new window ID is mapped to the old one with the same number in the; list of registered windows.; It means that 1st new window is mapped to the 1st original,; 2nd to the 2nd, Nth new to the Nth original. Bool_t RemapWindowReferences(); All references to the old windows (IDs) in fNextEvent are replaced by; new ones according to the mappings in fWindowList. Bool_t FilterEvent(TRecGuiEvent* e). Bool_t PrepareNextEvent(); Finds the next event in log file to replay and sets it to fNextEvent. Reads both from CmdTree and GuiTree and chooses that event that becomes; earlier; - fCmdTreeCounter determines actual position in fCmdTree; - fGuiTreeCounter determines actual position in fCmdTree. If GUI event should be replayed, we must fir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRecorderReplaying.html:4073,log,log,4073,root/html602/TRecorderReplaying.html,https://root.cern,https://root.cern/root/html602/TRecorderReplaying.html,2,['log'],['log']
Testability,"r specified distribution implementing the ROOT::Math::IGenFunction interface. ;  ; template<class Dist > ;  GoFTest (size_t sampleSize, const Double_t *sample, Dist &dist, EUserDistribution userDist=kPDF, Double_t xmin=1, Double_t xmax=0);  Templated constructor for 1-sample tests with a user specified distribution as a functor object implementing double operator()(double x). ;  ;  GoFTest (size_t sampleSize, const Double_t *sample, EDistribution dist=kUndefined, const std::vector< double > &distParams={});  Constructor for 1-sample tests with a specified distribution. ;  ; virtual ~GoFTest ();  ; Double_t AndersonDarling2SamplesTest (const Char_t *option=""p"") const;  Anderson-Darling 2-Sample Test. ;  ; void AndersonDarling2SamplesTest (Double_t &pvalue, Double_t &testStat) const;  Performs the Anderson-Darling 2-Sample Test. ;  ; Double_t AndersonDarlingTest (const Char_t *option=""p"") const;  Anderson-Darling 2-Sample Test. ;  ; void AndersonDarlingTest (Double_t &pvalue, Double_t &testStat) const;  Performs the Anderson-Darling 1-Sample Test. ;  ; Double_t KolmogorovSmirnov2SamplesTest (const Char_t *option=""p"") const;  Kolmogorov-Smirnov 2-Samples Test. ;  ; void KolmogorovSmirnov2SamplesTest (Double_t &pvalue, Double_t &testStat) const;  Kolmogorov-Smirnov 2-Samples Test. ;  ; Double_t KolmogorovSmirnovTest (const Char_t *option=""p"") const;  Kolmogorov-Smirnov 1-Sample Test. ;  ; void KolmogorovSmirnovTest (Double_t &pvalue, Double_t &testStat) const;  Kolmogorov-Smirnov 1-Sample Test. ;  ; void operator() (ETestType test, Double_t &pvalue, Double_t &testStat) const;  The class's unary functions performing the gif test according to the ETestType provided. ;  ; Double_t operator() (ETestType test=kAD, const Char_t *option=""p"") const;  Returns default Anderson Darling 1-Sample Test and default p-value; option ""t"" returns the test statistic value specific to the test type. ;  ; void SetDistribution (EDistribution dist, const std::vector< double > &distParams={}); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GoFTest.html:3324,test,testStat,3324,doc/master/classROOT_1_1Math_1_1GoFTest.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GoFTest.html,1,['test'],['testStat']
Testability,"r suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static Pixmap_tTGScrollBar::fgBckgndPixmap; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Int_tTGScrollBar::fgScrollBarWidth; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGVScrollBar(const TGWindow* p = 0, UInt_t w = 2, UInt_t h = 4, UInt_t options = kVerticalFrame, Pixel_t back = GetDefaultFrameBackground()); Create a vertical scrollbar. void Layout(); Layout and move vertical scrollbar components. Bool_t HandleButton(Event_t* event); Handle mouse button event in vertical scrollbar. Bool_t HandleMotion(Event_t* event); Handle mouse motion in a vertical scrollbar. void SetRange(Int_t range, Int_t page_size); Set range of vertical scrollbar. void SetPosition(Int_t pos); Set logical slider position of vertical scrollbar. void SavePrimitive(ostream& out, Option_t* option = """"); Save an vertical scrollbar as a C++ statement(s) on output stream out. TGDimension GetDefaultSize() const; { return TGDimension(fWidth, GetScrollBarWidth()); }. virtual ~TGVScrollBar(); { }. » Author: Fons Rademakers 10/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGVScrollBar.html:20810,log,logical,20810,root/html534/TGVScrollBar.html,https://root.cern,https://root.cern/root/html534/TGVScrollBar.html,1,['log'],['logical']
Testability,"r the contour (for 2D) or function (in 1D); Style_tfFillStylefill style for contours; RooStats::LikelihoodInterval*fInterval; Color_tfLineColorline color for the interval (1D) or for other contours (2D); Double_tfMaximumfunction maximum; Int_tfNPointsnumber of points used to scan the PL; Int_tfNdimPlot; RooArgSet*fParamsPlot; TObject*fPlotObjectplotted object; Double_tfPrecisionRooCurve precision; Double_tfXmax; Double_tfXmin; Double_tfYmax; Double_tfYmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; LikelihoodIntervalPlot(); LikelihoodIntervalPlot default constructor; with default parameters. LikelihoodIntervalPlot(LikelihoodInterval* theInterval); LikelihoodIntervalPlot copy constructor. ~LikelihoodIntervalPlot(); LikelihoodIntervalPlot destructor. void SetLikelihoodInterval(RooStats::LikelihoodInterval* theInterval). void SetPlotParameters(const RooArgSet* params). void Draw(const Option_t* options = 0); draw the log of the profiled likelihood function in 1D with the interval or; as a 2D plot with the contours.; Higher dimensionals intervals cannot be drawn. One needs to call; SetPlotParameters to project interval in 1 or 2dim. Options for drawing 1D interals. For 1D problem the log of the profiled likelihood function is drawn bby default in a RooPlot as a; RooCurve; The plotting range (default is the full parameter range) and the precision of the RooCurve; can be specified by using SetRange(x1,x2) and SetPrecision(eps).; SetNPoints(npoints) can also be used (default is npoints=100); Optionally the function can be drawn as a TF1 (option=""tf1"") obtained by sampling the given npoints; in the given range. Options for drawing 2D intervals. For 2D case, a contour and optionally the profiled likelihood function is drawn by sampling npoints in; the given range. A 2d histogram of nbinsX=nbinsY = sqrt(npoints) is used for sampling the profiled likelihood.; The contour can be obtained by using Minuit or by the sampled histogram,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__LikelihoodIntervalPlot.html:9639,log,log,9639,root/html602/RooStats__LikelihoodIntervalPlot.html,https://root.cern,https://root.cern/root/html602/RooStats__LikelihoodIntervalPlot.html,2,['log'],['log']
Testability,"r the regression tree; ; TTree *regTree = (TTree*)input->Get(""TreeR"");; ; // global event weights per tree (see below for setting event-wise weights); Double_t regWeight = 1.0;; ; // You can add an arbitrary number of regression trees; dataloader->AddRegressionTree( regTree, regWeight );; ; // This would set individual event weights (the variables defined in the; // expression need to exist in the original TTree); dataloader->SetWeightExpression( ""var1"", ""Regression"" );; ; // Apply additional cuts on the signal and background samples (can be different); TCut mycut = """"; // for example: TCut mycut = ""abs(var1)<0.5 && abs(var2-0.5)<1"";; ; // tell the DataLoader to use all remaining events in the trees after training for testing:; dataloader->PrepareTrainingAndTestTree( mycut,; ""nTrain_Regression=1000:nTest_Regression=0:SplitMode=Random:NormMode=NumEvents:!V"" );; //; // dataloader->PrepareTrainingAndTestTree( mycut,; // ""nTrain_Regression=0:nTest_Regression=0:SplitMode=Random:NormMode=NumEvents:!V"" );; ; // If no numbers of events are given, half of the events in the tree are used; // for training, and the other half for testing:; //; // dataloader->PrepareTrainingAndTestTree( mycut, ""SplitMode=random:!V"" );; ; // Book MVA methods; //; // Please lookup the various method configuration options in the corresponding cxx files, eg:; // src/MethoCuts.cxx, etc, or here: http://tmva.sourceforge.net/old_site/optionRef.html; // it is possible to preset ranges in the option string in which the cut optimisation should be done:; // ""...:CutRangeMin[2]=-1:CutRangeMax[2]=1""..."", where [2] is the third input variable; ; // PDE - RS method; if (Use[""PDERS""]); factory->BookMethod( dataloader, TMVA::Types::kPDERS, ""PDERS"",; ""!H:!V:NormTree=T:VolumeRangeMode=Adaptive:KernelEstimator=Gauss:GaussSigma=0.3:NEventsMin=40:NEventsMax=60:VarTransform=None"" );; // And the options strings for the MinMax and RMS methods, respectively:; //; // ""!H:!V:VolumeRangeMode=MinMax:DeltaFrac=0.2:KernelEstim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:140650,test,testing,140650,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,2,['test'],['testing']
Testability,"r to obtain the posterior function. ; By using the Markov-Chain Monte Carlo methods this calculator can work with model which require the integration of a large number of parameters.; MCMCCalculator is a concrete implementation of IntervalCalculator. It uses a MetropolisHastings object to construct a Markov Chain of data points in the parameter space. From this Markov Chain, this class can generate a MCMCInterval as per user specification.; The interface allows one to pass the model, data, and parameters via a workspace and then specify them with names.; After configuring the calculator, one only needs to ask GetInterval(), which will return an ConfInterval (MCMCInterval in this case). ; Definition at line 31 of file MCMCCalculator.h. Public Member Functions;  MCMCCalculator ();  default constructor ;  ;  MCMCCalculator (RooAbsData &data, const ModelConfig &model);  Constructor for automatic configuration with basic settings and a ModelConfig. ;  ; double ConfidenceLevel () const override;  Get the Confidence level for the test. ;  ; MCMCInterval * GetInterval () const override;  Main interface to get a ConfInterval. ;  ; TClass * IsA () const override;  ; virtual void SetAxes (RooArgList &axes);  set which variables to put on each axis ;  ; virtual void SetChainParameters (const RooArgSet &set);  specify the parameters to store in the Markov chain By default all the parameters are stored ;  ; virtual void SetConditionalObservables (const RooArgSet &set);  set the conditional observables which will be used when creating the NLL so the pdf's will not be normalized on the conditional observables when computing the NLL ;  ; void SetConfidenceLevel (double cl) override;  set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval) ;  ; void SetData (RooAbsData &data) override;  Set the DataSet if not already there. ;  ; virtual void SetGlobalObservables (const RooArgSet &set);  set the global observables which will be used when creating the NLL so t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1MCMCCalculator.html:1547,test,test,1547,doc/master/classRooStats_1_1MCMCCalculator.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1MCMCCalculator.html,1,['test'],['test']
Testability,r values: a0=0.713661 a1=-0.606754 mean=5.02862 nbkg=142.583 nsig=145.399 sig1frac=0.623944; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-861.002) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.744046 a1=-0.311529 mean=5.09799 nbkg=161.409 nsig=148.884 sig1frac=0.512806; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 660; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 650; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 640; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 630; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 620; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 610; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-809.027) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.719517 a1=-0.347533 mean=5.00927 nbkg=127.977 nsig=152.559 sig1frac=0.917291; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 600; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 590; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 580; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-869.586) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.621299 a1=-0.442393 mean=5.13262 nbkg=131.7 nsig=167.982 sig1frac=0.776177; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 570; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 560; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 550; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 540; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 530; RooAbsMinimizerFcn:,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf801__mcstudy_8C.html:16600,log,log,16600,doc/master/rf801__mcstudy_8C.html,https://root.cern,https://root.cern/doc/master/rf801__mcstudy_8C.html,2,['log'],['log']
Testability,"r writer. ; // NOTE: The RNTuple classes are experimental at this point.; // Functionality, interface, and data format is still subject to changes.; // Do not use for real data!; ; #include <ROOT/RNTupleModel.hxx>; #include <ROOT/RNTupleReader.hxx>; #include <ROOT/RNTupleWriter.hxx>; ; #include <TCanvas.h>; #include <TH1I.h>; #include <TROOT.h>; #include <TString.h>; ; #include <cassert>; #include <cstdio>; #include <fstream>; #include <iostream>; #include <memory>; #include <string>; #include <sstream>; #include <utility>; ; // Import classes from experimental namespace for the time being; using RNTupleModel = ROOT::Experimental::RNTupleModel;; using RNTupleReader = ROOT::Experimental::RNTupleReader;; using RNTupleWriter = ROOT::Experimental::RNTupleWriter;; ; constexpr char const* kNTupleFileName = ""ntpl001_staff.root"";; ; void Ingest() {; // The input file cernstaff.dat is a copy of the CERN staff data base from 1988; ifstream fin(gROOT->GetTutorialDir() + ""/tree/cernstaff.dat"");; assert(fin.is_open());; ; // We create a unique pointer to an empty data model; auto model = RNTupleModel::Create();; ; // To define the data model, we create fields with a given C++ type and name. Fields are roughly TTree branches.; // MakeField returns a shared pointer to a memory location that we can populate to fill the ntuple with data; auto fldCategory = model->MakeField<int>(""Category"");; auto fldFlag = model->MakeField<unsigned int>(""Flag"");; auto fldAge = model->MakeField<int>(""Age"");; auto fldService = model->MakeField<int>(""Service"");; auto fldChildren = model->MakeField<int>(""Children"");; auto fldGrade = model->MakeField<int>(""Grade"");; auto fldStep = model->MakeField<int>(""Step"");; auto fldHrweek = model->MakeField<int>(""Hrweek"");; auto fldCost = model->MakeField<int>(""Cost"");; auto fldDivision = model->MakeField<std::string>(""Division"");; auto fldNation = model->MakeField<std::string>(""Nation"");; ; // We hand-over the data model to a newly created ntuple of name ""Staff"", st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ntpl001__staff_8C.html:1488,assert,assert,1488,doc/master/ntpl001__staff_8C.html,https://root.cern,https://root.cern/doc/master/ntpl001__staff_8C.html,1,['assert'],['assert']
Testability,"r"",""number of parameters computed (%d) is not same as the stored parameters (%d)"",fNpar,int(parValues.size()) );; 3753 Print(""v"");; 3754 }; 3755 if (v > 11 && fNdim != ndim) {; 3756 Error(""Streamer"",""number of dimension computed (%d) is not same as the stored value (%d)"",fNdim, ndim );; 3757 Print(""v"");; 3758 }; 3759 }; 3760 else {; 3761 // we also delay the initialization of lamda expressions; 3762 if (!fLazyInitialization) {; 3763 bool ret = InitLambdaExpression(fFormula);; 3764 if (ret) {; 3765 fClingInitialized = true;; 3766 }; 3767 }else {; 3768 fReadyToExecute = true;; 3769 }; 3770 }; 3771 assert(fNpar == (int) parValues.size() );; 3772 std::copy( parValues.begin(), parValues.end(), fClingParameters.begin() );; 3773 // restore parameter names and order; 3774 if (fParams.size() != paramMap.size() ) {; 3775 Warning(""Streamer"",""number of parameters list found (%zu) is not same as the stored one (%zu) - use re-created list"",fParams.size(),paramMap.size()) ;; 3776 //Print(""v"");; 3777 }; 3778 else; 3779 //assert(fParams.size() == paramMap.size() );; 3780 fParams = paramMap;; 3781 ; 3782 // input formula into Cling; 3783 // need to replace in cling the name of the pointer of this object; 3784 // TString oldClingName = fClingName;; 3785 // fClingName.Replace(fClingName.Index(""_0x"")+1,fClingName.Length(), TString::Format(""%p"",this) );; 3786 // fClingInput.ReplaceAll(oldClingName, fClingName);; 3787 // InputFormulaIntoCling();; 3788 ; 3789 if (!TestBit(kNotGlobal)) {; 3790 R__LOCKGUARD(gROOTMutex);; 3791 gROOT->GetListOfFunctions()->Add(this);; 3792 }; 3793 if (!fReadyToExecute ) {; 3794 Error(""Streamer"",""Formula read from file is NOT ready to execute"");; 3795 Print(""v"");; 3796 }; 3797 //std::cout << ""reading 2 npar = "" << GetNpar() << std::endl;; 3798 ; 3799 return;; 3800 }; 3801 else {; 3802 Error(""Streamer"",""Reading version %d is not supported"",v);; 3803 return;; 3804 }; 3805 }; 3806 else {; 3807 // case of writing; 3808 b.WriteClassBuffer(TFormula::Class(), this);; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFormula_8cxx_source.html:143593,assert,assert,143593,doc/master/TFormula_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html,1,['assert'],['assert']
Testability,"r& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsSelfCachedPdf&operator=(const RooAbsSelfCachedPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsSelfCachedPdf.html:24218,test,testArg,24218,root/html602/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsSelfCachedPdf.html,2,['test'],['testArg']
Testability,"r& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooMultiVarGaussian&operator=(const RooMultiVarGaussian&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMultiVarGaussian.html:23293,test,testArg,23293,root/html602/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html602/RooMultiVarGaussian.html,2,['test'],['testArg']
Testability,"r(""njets >= 1"");; ; return ret;; };; ; const Double_t dxbin = (0.17 - 0.13) / 40; // Bin-width; ; Double_t fdm5(Double_t *xx, Double_t *par); {; Double_t x = xx[0];; if (x <= 0.13957); return 0;; Double_t xp3 = (x - par[3]) * (x - par[3]);; Double_t res =; dxbin * (par[0] * pow(x - 0.13957, par[1]) + par[2] / 2.5066 / par[4] * exp(-xp3 / 2 / par[4] / par[4]));; return res;; }; ; Double_t fdm2(Double_t *xx, Double_t *par); {; static const Double_t sigma = 0.0012;; Double_t x = xx[0];; if (x <= 0.13957); return 0;; Double_t xp3 = (x - 0.1454) * (x - 0.1454);; Double_t res = dxbin * (par[0] * pow(x - 0.13957, 0.25) + par[1] / 2.5066 / sigma * exp(-xp3 / 2 / sigma / sigma));; return res;; }; ; void FitAndPlotHdmd(TH1 &hdmd); {; // create the canvas for the h1analysis fit; gStyle->SetOptFit();; auto c1 = new TCanvas(""c1"", ""h1analysis analysis"", 10, 10, 800, 600);; ; hdmd.GetXaxis()->SetTitleOffset(1.4);; ; auto hdraw = (TH1 *) hdmd.DrawClone();; ; // fit histogram hdmd with function f5 using the loglikelihood option; auto f5 = new TF1(""f5"", fdm5, 0.139, 0.17, 5);; f5->SetParameters(1000000, .25, 2000, .1454, .001);; hdraw->Fit(""f5"", ""lr"");; }; ; void FitAndPlotH2(TH2 &h2); {; // create the canvas for tau d0; auto c2 = new TCanvas(""c2"", ""tauD0"", 100, 100, 800, 600);; ; c2->SetGrid();; c2->SetBottomMargin(0.15);; ; // Project slices of 2-d histogram h2 along X , then fit each slice; // with function f2 and make a histogram for each fit parameter; // Note that the generated histograms are added to the list of objects; // in the current directory.; auto f2 = new TF1(""f2"", fdm2, 0.139, 0.17, 2);; f2->SetParameters(10000, 10);; h2.FitSlicesX(f2, 0, -1, 1, ""qln"");; ; // See TH2::FitSlicesX documentation why h2_1 name is used; auto h2_1 = (TH1D *)gDirectory->Get(""h2_1"");; h2_1->SetDirectory(nullptr);; h2_1->GetXaxis()->SetTitle(""#tau [ps]"");; h2_1->SetMarkerStyle(21);; h2_1->Draw();; c2->Update();; ; auto line = new TLine(0, 0, 0, c2->GetUymax());; line->Draw();; }; ; void df101_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df101__h1Analysis_8C.html:2144,log,loglikelihood,2144,doc/master/df101__h1Analysis_8C.html,https://root.cern,https://root.cern/doc/master/df101__h1Analysis_8C.html,1,['log'],['loglikelihood']
Testability,"r(). double HybridResult::CLsplusbError ; (; ); const. The error on the ""confidence level"" of the alternative hypothesis. ; Returns an estimate of the error on \(CL_{s+b}\) assuming a binomial error on \(CL_{s+b}\):. \[; \sigma_{CL_{s+b}} = \sqrt{CL_{s+b} \left( 1 - CL_{s+b} \right) / n_{toys}}; \]. Definition at line 194 of file HybridResult.cxx. ◆ DeclFileName(). static const char * RooStats::HybridResult::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 88 of file HybridResult.h. ◆ GetPlot(). HybridPlot * HybridResult::GetPlot ; (; const char * ; name, . const char * ; title, . int ; n_bins . ). prepare a plot showing a result and return a pointer to a HybridPlot object the needed arguments are: an object name, a title and the number of bins in the plot ; Definition at line 251 of file HybridResult.cxx. ◆ GetTestStat_b(). std::vector< double > RooStats::HybridResult::GetTestStat_b ; (; ). inline . Get test statistics values for the b model. ; Definition at line 56 of file HybridResult.h. ◆ GetTestStat_data(). double RooStats::HybridResult::GetTestStat_data ; (; ). inline . Get test statistics value for data. ; Definition at line 59 of file HybridResult.h. ◆ GetTestStat_sb(). std::vector< double > RooStats::HybridResult::GetTestStat_sb ; (; ). inline . Get test statistics values for the sb model. ; Definition at line 53 of file HybridResult.h. ◆ IsA(). TClass * RooStats::HybridResult::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 88 of file HybridResult.h. ◆ NullPValue(). double HybridResult::NullPValue ; (; ); const. overridevirtual . Returns \(1 - CL_{b}\) : the B p-value. ; Reimplemented from RooStats::HypoTestResult.; Definition at line 117 of file HybridResult.cxx. ◆ PrintMore(). void HybridResult::PrintMore ; (; const char * ; options). Print out some information about the results. ; Definition at line 282 of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1HybridResult.html:21268,test,test,21268,doc/master/classRooStats_1_1HybridResult.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1HybridResult.html,1,['test'],['test']
Testability,"r(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TMVA::MsgLogger&Log() const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfAbsTolabsolute tolerance deviation; Double_t (*)(Double_t)fGetRootVal; TMVA::MsgLogger*fLogger! message logger; Int_tfMaxItermaximum number of iterations; Double_tfRootMaxmaximum root value; Double_tfRootMinminimum root value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RootFinder(Double_t (*)(Double_t) rootVal, Double_t rootMin, Double_t rootMax, Int_t maxIterations = 100, Double_t absTolerance = 0.0); constructor. ~RootFinder( void ); destructor. Double_t Root(Double_t refValue); Root finding using Brents algorithm; taken from CERNLIB function RZERO. RootFinder(Double_t (*)(Double_t) rootVal, Double_t rootMin, Double_t rootMax, Int_t maxIterations = 100, Double_t absTolerance = 0.0). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: RootFinder.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__RootFinder.html:5430,log,logger,5430,root/html532/TMVA__RootFinder.html,https://root.cern,https://root.cern/root/html532/TMVA__RootFinder.html,1,['log'],['logger']
Testability,"r(i) > 0) par.SetStepSize( fResult->Error(i) );; 867 }; 868}; 869 ; 870int Fitter::GetNCallsFromFCN() {; 871 // retrieve ncalls from the fit method functions; 872 // this function is called when minimizer does not provide a way of returning the number of function calls; 873 int ncalls = 0;; 874 if (!fUseGradient) {; 875 const ROOT::Math::FitMethodFunction * fcn = dynamic_cast<const ROOT::Math::FitMethodFunction *>(fObjFunction.get());; 876 if (fcn) ncalls = fcn->NCalls();; 877 }; 878 else {; 879 const ROOT::Math::FitMethodGradFunction * fcn = dynamic_cast<const ROOT::Math::FitMethodGradFunction*>(fObjFunction.get());; 880 if (fcn) ncalls = fcn->NCalls();; 881 }; 882 return ncalls;; 883}; 884 ; 885 ; 886bool Fitter::ApplyWeightCorrection(const ROOT::Math::IMultiGenFunction & loglw2, bool minimizeW2L) {; 887 // apply correction for weight square; 888 // Compute Hessian of the loglikelihood function using the sum of the weight squared; 889 // This method assumes:; 890 // - a fit has been done before and a covariance matrix exists; 891 // - the objective function is a likelihood function and Likelihood::UseSumOfWeightSquare(); 892 // has been called before; 893 ; 894 if (fMinimizer == nullptr) {; 895 MATH_ERROR_MSG(""Fitter::ApplyWeightCorrection"",""Must perform first a fit before applying the correction"");; 896 return false;; 897 }; 898 ; 899 unsigned int n = loglw2.NDim();; 900 // correct errors for weight squared; 901 std::vector<double> cov(n*n);; 902 bool ret = fMinimizer->GetCovMatrix(&cov[0] );; 903 if (!ret) {; 904 MATH_ERROR_MSG(""Fitter::ApplyWeightCorrection"",""Previous fit has no valid Covariance matrix"");; 905 return false;; 906 }; 907 // need to use new obj function computed with weight-square; 908 std::shared_ptr<ROOT::Math::IMultiGenFunction> objFunc(loglw2.Clone());; 909 fObjFunction.swap( objFunc );; 910 ; 911 // need to re-initialize the minimizer for the changes applied in the; 912 // objective functions; 913 if (!DoInitMinimizer()) return false;; 914 ; 9",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8cxx_source.html:34705,log,loglikelihood,34705,doc/master/Fitter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html,1,['log'],['loglikelihood']
Testability,"r) ||; 3488 strstr(filename, ""/usr/bin/cyg"")); 3489 return;; 3490#elif defined(R__WIN32); 3491 if (strstr(filename, ""/Windows/"")); 3492 return;; 3493#elif defined (R__LINUX); 3494 if (strstr(filename, ""/ld-linux""); 3495 || strstr(filename, ""linux-gnu/""); 3496 || strstr(filename, ""/libstdc++.""); 3497 || strstr(filename, ""/libgcc""); 3498 || strstr(filename, ""/libc.""); 3499 || strstr(filename, ""/libdl.""); 3500 || strstr(filename, ""/libm."")); 3501 return;; 3502#endif; 3503 // Update string of available libraries.; 3504 if (!fSharedLibs.IsNull()) {; 3505 fSharedLibs.Append("" "");; 3506 }; 3507 fSharedLibs.Append(filename);; 3508}; 3509 ; 3510////////////////////////////////////////////////////////////////////////////////; 3511/// Load a library file in cling's memory.; 3512/// if 'system' is true, the library is never unloaded.; 3513/// Return 0 on success, -1 on failure.; 3514 ; 3515Int_t TCling::Load(const char* filename, Bool_t system); 3516{; 3517 assert(!IsFromRootCling() && ""Trying to load library from rootcling!"");; 3518 ; 3519 // Used to return 0 on success, 1 on duplicate, -1 on failure, -2 on ""fatal"".; 3520 R__LOCKGUARD_CLING(gInterpreterMutex);; 3521 cling::DynamicLibraryManager* DLM = fInterpreter->getDynamicLibraryManager();; 3522 std::string canonLib = DLM->lookupLibrary(filename);; 3523 cling::DynamicLibraryManager::LoadLibResult res; 3524 = cling::DynamicLibraryManager::kLoadLibNotFound;; 3525 if (!canonLib.empty()) {; 3526 if (system); 3527 res = DLM->loadLibrary(filename, system, true);; 3528 else {; 3529 // For the non system libs, we'd like to be able to unload them.; 3530 // FIXME: Here we lose the information about kLoadLibAlreadyLoaded case.; 3531 cling::Interpreter::CompilationResult compRes;; 3532 HandleInterpreterException(GetMetaProcessorImpl(), Form("".L %s"", canonLib.c_str()), compRes, /*cling::Value*/nullptr);; 3533 if (compRes == cling::Interpreter::kSuccess); 3534 res = cling::DynamicLibraryManager::kLoadLibSuccess;; 3535 }; 3536 }; 3537 ; 3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:136660,assert,assert,136660,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['assert'],['assert']
Testability,"r* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::Exe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCategoryLValue.html:3336,test,testArg,3336,root/html526/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html526/RooAbsCategoryLValue.html,21,['test'],['testArg']
Testability,"r* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsReal&model() const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumConvPdf.html:22748,test,testArg,22748,root/html526/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html526/RooNumConvPdf.html,1,['test'],['testArg']
Testability,"r, Double_t x). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Event*fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&fDsi; TMVA::DataSetInfo*fDsiOutput; TMVA::VariableTransformBase::VectorOfCharAndIntfGetget variables/targets/spectators; TMVA::MsgLogger*fLogger! message logger; TMVA::VariableTransformBase::VectorOfCharAndIntfPutput variables/targets/spectators; TMVA::TMVAVersion_tfTMVAVersion; TMVA::Event*fTransformedEventholds the current transformed event. private:. Bool_tfCreatedhas been created; Bool_tfEnabledhas been enabled; UInt_tfNSpectatorsnumber of spectators to be transformed; UInt_tfNTargetsnumber of targets to be transformed; UInt_tfNVariablesnumber of variables to be transformed; UInt_tfNVarsnumber of variables; Bool_tfNormalisenormalise input variables; Bool_tfSortGetif true, sort the variables into the order as defined by the user at the var definition; vector<TMVA::VariableInfo>fSpectatorsevent spectators [saved to weight file --> TODO ]; vector<TMVA::VariableInfo>fTargetsevent targets [saved to weight file --> TODO ]; TStringfTransformNamename of transformation; Bool_tfUseSignalTransformtrue if transformation bases on signal data; TMVA::Types::EVariableTransformfVariableTransformDecorrelation, PCA, etc.; B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__VariableTransformBase.html:8395,log,logger,8395,root/html602/TMVA__VariableTransformBase.html,https://root.cern,https://root.cern/root/html602/TMVA__VariableTransformBase.html,2,['log'],['logger']
Testability,"r, but through volumes (a node points to a volume, which at its turn points to a list of nodes):; NodeTop VolTop NodeA VolA ...; One can therefore talk about ""the node or volume hierarchy"", but in fact, an element is made by a pair volume-node. In the line above is represented just a single branch, but of course from any volume other branches can also emerge. The index of a node in such a branch (counting only nodes) is called depth. The top node have always depth=0.; Volumes need to have their daughter nodes defined when the geometry is closed. They will build additional structures (called voxels ) in order to fasten-up the search algorithms. Finally, nodes can be regarded as bi-directional links between containers and contained volumes.; The structure defined in this way is a graph structure since volumes are replicable (same volume can become daughter node of several other volumes), every volume becoming a branch in this graph. Any volume in the logical graph can become the actual top volume at run time (see TGeoManager::SetTopVolume()). All functionalities of the modeller will behave in this case as if only the corresponding branch starting from this volume is the active geometry. A geometry hierarchy in memory; Nodes are never instantiated directly by users, but created as a result of volume operations. Adding a volume named A with a given user id inside a volume B will create a node named A_id. This will be added to the list of nodes stored by B. In addition, when applying a division operation in N slices to a volume A, a list of nodes B_1, B_2, ... , B_N is also created. A node B_i does not represent a unique object in the geometry because its container A might be at its turn positioned as node inside several other volumes. Only when a complete branch of nodes is fully defined up to the top node in the geometry, a given path:/TOP_1/.../A_3/B_7 will represent a unique object. Its global transformation matrix can be computed as the pile-up of all local transfor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:20719,log,logical,20719,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['log'],['logical']
Testability,"r, but through volumes (a node points to a volume, which at its turn points to a list of nodes):; NodeTop VolTop NodeA VolA ...; One can therefore talk about “the node or volume hierarchy”, but in fact, an element is made by a pair volume-node. In the line above is represented just a single branch, but of course from any volume other branches can also emerge. The index of a node in such a branch (counting only nodes) is called depth. The top node have always depth=0.; Volumes need to have their daughter nodes defined when the geometry is closed. They will build additional structures (called voxels ) in order to fasten-up the search algorithms. Finally, nodes can be regarded as bi-directional links between containers and contained volumes.; The structure defined in this way is a graph structure since volumes are replicable (same volume can become daughter node of several other volumes), every volume becoming a branch in this graph. Any volume in the logical graph can become the actual top volume at run time (see TGeoManager::SetTopVolume()). All functionalities of the modeller will behave in this case as if only the corresponding branch starting from this volume is the active geometry. A geometry hierarchy in memory. Nodes are never instantiated directly by users, but created as a result of volume operations. Adding a volume named A with a given user id inside a volume B will create a node named A_id. This will be added to the list of nodes stored by B. In addition, when applying a division operation in N slices to a volume A, a list of nodes B_1, B_2, … , B_N is also created. A node B_i does not represent a unique object in the geometry because its container A might be at its turn positioned as node inside several other volumes. Only when a complete branch of nodes is fully defined up to the top node in the geometry, a given path:/TOP_1/…/A_3/B_7 will represent a unique object. Its global transformation matrix can be computed as the pile-up of all local transformati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:931248,log,logical,931248,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['log'],['logical']
Testability,"r, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMinuit*minuit(); RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); RooAbsReal&nll(); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; Int_tnumEval() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooProfileLL.html:17829,test,testArg,17829,root/html530/RooProfileLL.html,https://root.cern,https://root.cern/root/html530/RooProfileLL.html,2,['test'],['testArg']
Testability,"r, const char* slot); TSlave*CreateSlave(const char* url, const char* ord, Int_t perf, const char* image, const char* workdir); TSlave*CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TList*GetEnabledPackages() const; static Bool_tGetFileInCmd(const char* cmd, TString& fn); static Int_tGetInputData(TList* input, const char* cachedir, TString& emsg); TList*GetListOfActiveSlaves() const; TVirtualProofPlayer*GetPlayer() const; TPluginHandler*GetProgressDialog() const; Int_tGetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidHandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tHandleOutputOptions(TString& opt, TString& target, Int_t action); Int_tInit(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidInitMembers(); virtual TVirtualProofPlayer*MakePlayer(const char* player = 0, TSocket* s = 0); voidTObject::MakeZombie(); virtual Int_tPollForNewWorkers(); voidPrepareInputDataFile(TString& dataFile); Int_tRemoveWorkers(TList* wrks); static Int_tSaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidSaveWorkerInfo(); Int_tSendFile(const char* file, Int_t opt = (kBinary|kForward|kCp|kCpBin), const char* rfile = 0, TSlave* sl = 0); static Int_tSendInputData(TQueryResult* qr, TProof* p, TString& emsg); virtual voidSendInputDataFile(); voidSetDSet(TDSet* dset); voidSetFeedback(TString& opt, TString& optfb, Int_t action); voidSetPlayer(TVirtualProofPlayer* player); voidSetupWorkersEnv(TList* wrks, Bool_t increasingpool = kFALSE); static void*SlaveStartupThread(void* arg); virtual Bool_tStartSlaves(Bool_t attach = kFALSE); static voidSystemCmd(const char* cmd, Int_t fdout); voidUpdateDialog(); virtual voidValidateDSet(TDSet* dset); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:20466,log,loglevel,20466,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,1,['log'],['loglevel']
Testability,"r, or later with the suited setter method. ; Definition at line 446 of file TMultiLayerPerceptron.cxx. ◆ TMultiLayerPerceptron() [3/6]. TMultiLayerPerceptron::TMultiLayerPerceptron ; (; const char * ; layout, . const char * ; weight, . TTree * ; data = nullptr, . const char * ; training = ""Entry$%2==0"", . const char * ; test = """", . TNeuron::ENeuronType ; type = TNeuron::kSigmoid, . const char * ; extF = """", . const char * ; extD = """" . ). The network is described by a simple string: The input/output layers are defined by giving the branch names separated by comas. ; Hidden layers are just described by the number of neurons. The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be normalized. The output can be followed by '!' to use Softmax neurons for the output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument. training and test are two cuts (see TTreeFormula) defining events to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor, or later with the suited setter method. ; Definition at line 524 of file TMultiLayerPerceptron.cxx. ◆ TMultiLayerPerceptron() [4/6]. TMultiLayerPerceptron::TMultiLayerPerceptron ; (; const char * ; layout, . TTree * ; data, . TEventList * ; training, . TEventList * ; test, . TNeuron::ENeuronType ; type = TNeuron::kSigmoid, . const char * ; extF = """", . const char * ; extD = """" . ). The network is described by a simple string: The input/output layers are defined by giving the branch names separated by comas. ; Hidden layers are just described by the number of neurons. The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be normalized. The output can be followed by '!' to use Softmax neurons for the output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are tak",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:30986,test,test,30986,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,2,['test'],"['test', 'testing']"
Testability,"r->EvaluateMVA( ""FDA_GA method"" ) );; if (Use[""Category"" ]) histCat ->Fill( reader->EvaluateMVA( ""Category method"" ) );; if (Use[""Plugin"" ]) histPBdt ->Fill( reader->EvaluateMVA( ""P_BDT method"" ) );; ; // Retrieve also per-event error; if (Use[""PDEFoam""]) {; Double_t val = reader->EvaluateMVA( ""PDEFoam method"" );; Double_t err = reader->GetMVAError();; histPDEFoam ->Fill( val );; histPDEFoamErr->Fill( err );; if (err>1.e-50) histPDEFoamSig->Fill( val/err );; }; ; // Retrieve probability instead of MVA output; if (Use[""Fisher""]) {; probHistFi ->Fill( reader->GetProba ( ""Fisher method"" ) );; rarityHistFi->Fill( reader->GetRarity( ""Fisher method"" ) );; }; }; ; // Get elapsed time; sw.Stop();; std::cout << ""--- End of event loop: ""; sw.Print();; ; // Get efficiency for cuts classifier; if (Use[""CutsGA""]) std::cout << ""--- Efficiency for CutsGA method: "" << double(nSelCutsGA)/theTree->GetEntries(); << "" (for a required signal efficiency of "" << effS << "")"" << std::endl;; ; if (Use[""CutsGA""]) {; ; // test: retrieve cuts for particular signal efficiency; TMVA::MethodCuts* mcuts = dynamic_cast<TMVA::MethodCuts*>(reader->FindMVA( ""CutsGA method"" ));; ; if (mcuts) {; std::vector<Double_t> cutsMin;; std::vector<Double_t> cutsMax;; mcuts->GetCuts( 0.7, cutsMin, cutsMax );; std::cout << ""--- -------------------------------------------------------------"" << std::endl;; std::cout << ""--- Retrieve cut values for signal efficiency of 0.7 from Reader"" << std::endl;; for (UInt_t ivar=0; ivar<cutsMin.size(); ivar++) {; std::cout << ""... Cut: ""; << cutsMin[ivar]; << "" < \""""; << mcuts->GetInputVar(ivar); << ""\"" <= ""; << cutsMax[ivar] << std::endl;; }; std::cout << ""--- -------------------------------------------------------------"" << std::endl;; }; }; ; // Write histograms; ; TFile *target = new TFile( ""TMVApp.root"",""RECREATE"" );; if (Use[""Likelihood"" ]) histLk ->Write();; if (Use[""LikelihoodD"" ]) histLkD ->Write();; if (Use[""LikelihoodPCA""]) histLkPCA ->Write();; if (Use[""LikelihoodKDE""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassificationApplication_8C.html:20140,test,test,20140,doc/master/TMVAClassificationApplication_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html,1,['test'],['test']
Testability,r. Bool_t TGScrollBar::fGrabPointer. protected . grab pointer when dragging ; Definition at line 71 of file TGScrollBar.h. ◆ fgScrollBarWidth. Int_t TGScrollBar::fgScrollBarWidth = kDefaultScrollBarWidth. staticprotected . Definition at line 90 of file TGScrollBar.h. ◆ fHead. TGScrollBarElement* TGScrollBar::fHead. protected . head button of scrollbar ; Definition at line 78 of file TGScrollBar.h. ◆ fHeadPic. const TGPicture* TGScrollBar::fHeadPic. protected . picture in head (up or left arrow) ; Definition at line 81 of file TGScrollBar.h. ◆ fHighColor. Pixel_t TGScrollBar::fHighColor. protected . highlight color ; Definition at line 87 of file TGScrollBar.h. ◆ fPos. Int_t TGScrollBar::fPos. protected . logical current position ; Definition at line 74 of file TGScrollBar.h. ◆ fPsize. Int_t TGScrollBar::fPsize. protected . logical page size of scrollbar ; Definition at line 73 of file TGScrollBar.h. ◆ fRange. Int_t TGScrollBar::fRange. protected . logical upper range of scrollbar ; Definition at line 72 of file TGScrollBar.h. ◆ fRepeat. TTimer* TGScrollBar::fRepeat. protected . repeat rate timer (when mouse stays pressed) ; Definition at line 83 of file TGScrollBar.h. ◆ fSlider. TGScrollBarElement* TGScrollBar::fSlider. protected . slider ; Definition at line 80 of file TGScrollBar.h. ◆ fSliderRange. Int_t TGScrollBar::fSliderRange. protected . logical slider range ; Definition at line 76 of file TGScrollBar.h. ◆ fSliderSize. Int_t TGScrollBar::fSliderSize. protected . logical slider size ; Definition at line 75 of file TGScrollBar.h. ◆ fSmallInc. Int_t TGScrollBar::fSmallInc. protected . Small Increment in the sliding algorithm. ; Definition at line 77 of file TGScrollBar.h. ◆ fSubw. Window_t TGScrollBar::fSubw. protected . sub window in which mouse is pressed ; Definition at line 84 of file TGScrollBar.h. ◆ fTail. TGScrollBarElement* TGScrollBar::fTail. protected . tail button of scrollbar ; Definition at line 79 of file TGScrollBar.h. ◆ fTailPic. const TGPicture*,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGScrollBar.html:39136,log,logical,39136,doc/master/classTGScrollBar.html,https://root.cern,https://root.cern/doc/master/classTGScrollBar.html,1,['log'],['logical']
Testability,"r. Does not vectorise.; 261 ///; 262 /// Based on KahanIncrement from:; 263 /// Y. Tian, S. Tatikonda and B. Reinwald, ""Scalable and Numerically Stable Descriptive Statistics in SystemML,"" 2012 IEEE 28th International Conference on Data Engineering, 2012, pp. 1351-1359, doi: 10.1109/ICDE.2012.12.; 264 /// Note that while Tian et al. add the carry in the first step, we subtract; 265 /// the carry, in accordance with the Add(Indexed) implementation(s) above.; 266 /// This is purely an implementation choice that has no impact on performance.; 267 ///; 268 /// \note Take care when using += (and -=) to add other KahanSums into a zero-initialized; 269 /// KahanSum. The operator behaves correctly in this case, but the result may be slightly; 270 /// off if you expect 0 + x to yield exactly x (where 0 is the zero-initialized KahanSum; 271 /// and x another KahanSum). In particular, x's carry term may get lost. This doesn't; 272 /// just happen with zero-initialized KahanSums; see the SubtractWithABitTooSmallCarry; 273 /// test case in the testKahan unittest for other examples. This behavior is internally; 274 /// consistent: the carry also gets lost if you switch the operands and it also happens with; 275 /// other KahanSum operators.; 276 template<typename U, unsigned int M>; 277 KahanSum<T, N>& operator+=(const KahanSum<U, M>& other) {; 278 U corrected_arg_sum = other.Sum() - (fCarry[0] + other.Carry());; 279 U sum = fSum[0] + corrected_arg_sum;; 280 U correction = (sum - fSum[0]) - corrected_arg_sum;; 281 fSum[0] = sum;; 282 fCarry[0] = correction;; 283 return *this;; 284 }; 285 ; 286 /// Subtract other KahanSum. Does not vectorise.; 287 ///; 288 /// Based on KahanIncrement from: Tian et al., 2012 (see operator+= documentation).; 289 template<typename U, unsigned int M>; 290 KahanSum<T, N>& operator-=(KahanSum<U, M> const& other) {; 291 U corrected_arg_sum = -other.Sum() - (fCarry[0] - other.Carry());; 292 U sum = fSum[0] + corrected_arg_sum;; 293 U correction = (sum - f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Util_8h_source.html:10960,test,test,10960,doc/master/Util_8h_source.html,https://root.cern,https://root.cern/doc/master/Util_8h_source.html,2,['test'],"['test', 'testKahan']"
Testability,"r. TMySQLServer. MySQL server plugin implementing the TSQLServer interface. To open a connection to a server use the static method Connect().; The db argument of Connect() is of the form:; mysql://<host>[:<port>][/<database>], e.g.; mysql://pcroot.cern.ch:3456/test. As an example of connecting to mysql we assume that the server is; running on the local host and that you have access to a database; named ""test"" by connecting using an account that has a username and; password of ""tuser"" and ""tpass"". You can set up this account; by using the ""mysql"" program to connect to the server as the MySQL; root user and issuing the following statement:. mysql> GRANT ALL ON test.* TO 'tuser'@'localhost' IDENTIFIED BY 'tpass';. If the test database does not exist, create it with this statement:. mysql> CREATE DATABASE test;. If you want to use a different server host, username, password,; or database name, just substitute the appropriate values.; To connect do:. TSQLServer *db = TSQLServer::Connect(""mysql://localhost/test"", ""tuser"", ""tpass"");. Function Members (Methods); public:. TMySQLServer(const TMySQLServer&); TMySQLServer(const char* db, const char* uid, const char* pw); virtual~TMySQLServer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Bool_tCommit(); virtual Int_tTObject::Compare(const TObject* obj) const; static TSQLServer*TSQLServer::Connect(const char* db, const char* uid, const char* pw); virtual voidTObject::Copy(TObject& object) const; virtual Int_tCreateDataBase(const char* dbname); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMySQLServer.html:1313,test,test,1313,root/html528/TMySQLServer.html,https://root.cern,https://root.cern/root/html528/TMySQLServer.html,4,['test'],['test']
Testability,"r. TMySQLServer. MySQL server plugin implementing the TSQLServer interface. To open a connection to a server use the static method Connect().; The db argument of Connect() is of the form:; mysql://<host>[:<port>][/<database>], e.g.; mysql://pcroot.cern.ch:3456/test. As an example of connecting to mysql we assume that the server is; running on the local host and that you have access to a database; named ""test"" by connecting using an account that has a username and; password of ""tuser"" and ""tpass"". You can set up this account; by using the ""mysql"" program to connect to the server as the MySQL; root user and issuing the following statement:. mysql> GRANT ALL ON test.* TO 'tuser'@'localhost' IDENTIFIED BY 'tpass';. If the test database does not exist, create it with this statement:. mysql> CREATE DATABASE test;. If you want to use a different server host, username, password,; or database name, just substitute the appropriate values.; To connect do:. TSQLServer *db = TSQLServer::Connect(""mysql://localhost/test"", ""tuser"", ""tpass"");. Function Members (Methods); public:. virtual~TMySQLServer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Bool_tCommit(); virtual Int_tTObject::Compare(const TObject* obj) const; static TSQLServer*TSQLServer::Connect(const char* db, const char* uid, const char* pw); virtual voidTObject::Copy(TObject& object) const; virtual Int_tCreateDataBase(const char* dbname); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMySQLServer.html:1313,test,test,1313,root/html602/TMySQLServer.html,https://root.cern,https://root.cern/root/html602/TMySQLServer.html,2,['test'],['test']
Testability,"r.cxx. ◆ Log(). void TPackMgr::Log ; (; const char * ; msg). private . Wrapper to notofuer / logger. ; Definition at line 73 of file TPackMgr.cxx. ◆ operator=(). TPackMgr & TPackMgr::operator= ; (; const TPackMgr & ; ). private . ◆ ReadMD5(). TMD5 * TPackMgr::ReadMD5 ; (; const char * ; pack). Read MD5 checksum of the PAR file from the PROOF-INF/md5.txt file. ; Returns a pointer to a TMD5 object, transferring ownership to the caller ; Definition at line 708 of file TPackMgr.cxx. ◆ RegisterGlobalPath(). Int_t TPackMgr::RegisterGlobalPath ; (; const char * ; paths). static . Parse one or more paths as possible sources of packages Returns number of paths added; or -1 in case of problems. ; Definition at line 872 of file TPackMgr.cxx. ◆ Remove(). Int_t TPackMgr::Remove ; (; const char * ; pack = 0, . Bool_t ; dolock = kTRUE . ). Remove package 'pack' If 'pack' is null or empty all packages are cleared. ; Definition at line 593 of file TPackMgr.cxx. ◆ SetLogger(). void TPackMgr::SetLogger ; (; TPackMgrLog_t ; logger). inline . Definition at line 67 of file TPackMgr.h. ◆ SetName(). void TPackMgr::SetName ; (; const char * ; name). inlineoverridevirtual . Set the name of the TNamed. ; WARNING: if the object is a member of a THashTable or THashList container the container must be Rehash()'ed after SetName(). For example the list of objects in the current directory is a THashList. ; Reimplemented from TNamed.; Definition at line 62 of file TPackMgr.h. ◆ SetPrefix(). void TPackMgr::SetPrefix ; (; const char * ; pfx). inline . Definition at line 68 of file TPackMgr.h. ◆ Show(). void TPackMgr::Show ; (; const char * ; title = 0). Show available packages. ; Definition at line 548 of file TPackMgr.cxx. ◆ ShowEnabled(). void TPackMgr::ShowEnabled ; (; const char * ; title = 0). Show enabled packages. ; Definition at line 662 of file TPackMgr.cxx. ◆ Streamer(). void TPackMgr::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPackMgr.html:22629,log,logger,22629,doc/master/classTPackMgr.html,https://root.cern,https://root.cern/doc/master/classTPackMgr.html,1,['log'],['logger']
Testability,r.cxx;  GSLMultiRootFunctionAdapter.h;  GSLMultiRootFunctionWrapper.h;  GSLMultiRootSolver.h;  GSLNLSMinimizer.cxx;  GSLQRngWrapper.h;  GSLQuasiRandom.cxx;  GSLRndmEngines.cxx;  GSLRngROOTWrapper.h;  GSLRngWrapper.h;  GSLRootFdFSolver.h;  GSLRootFinder.cxx;  GSLRootFinderDeriv.cxx;  GSLRootFSolver.h;  GSLRootHelper.cxx;  GSLSimAnMinimizer.cxx;  GSLSimAnnealing.cxx;  Interpolator.cxx;  KelvinFunctions.cxx;  MCParameters.cxx;  MultiNumGradFunction.cxx;  PdfFuncMathMore.cxx;  Polynomial.cxx;  QuantFuncMathMore.cxx;  RootFinderAlgorithms.cxx;  SpecFuncMathMore.cxx;  Vavilov.cxx;  VavilovAccurate.cxx;  VavilovAccurateCdf.cxx;  VavilovAccuratePdf.cxx;  VavilovAccurateQuantile.cxx;  VavilovFast.cxx;  zsolve_cubic.cxx;  ► test;  piRandom.C;  pirndm.C;  simanTSP.cxx;  testChebyshev.cxx;  testDerivation.cxx;  testFunctor.cxx;  testGSLIntegration.cxx;  testGSLRootFinder.cxx;  testInterpolation.cxx;  testMCIntegration.cxx;  testMinimization1D.cxx;  testMultiRootFinder.cxx;  testPermute.cxx;  testQuasiRandom.cxx;  testRandom.cxx;  testRandomDist.cxx;  testSpecFunc.cxx;  testStatFunc.cxx;  testVavilov.cxx;  UnuRanDist.h;  VavilovTest.cxx;  VavilovTest.h;  ► matrix;  ► inc;  LinkDef.h;  TDecompBase.h;  TDecompBK.h;  TDecompChol.h;  TDecompLU.h;  TDecompQRH.h;  TDecompSparse.h;  TDecompSVD.h;  TMatrix.h;  TMatrixD.h;  TMatrixDBase.h;  TMatrixDBasefwd.h;  TMatrixDEigen.h;  TMatrixDfwd.h;  TMatrixDLazy.h;  TMatrixDSparse.h;  TMatrixDSparsefwd.h;  TMatrixDSym.h;  TMatrixDSymEigen.h;  TMatrixDSymfwd.h;  TMatrixDUtils.h;  TMatrixDUtilsfwd.h;  TMatrixF.h;  TMatrixFBase.h;  TMatrixFBasefwd.h;  TMatrixFfwd.h;  TMatrixFLazy.h;  TMatrixFSparse.h;  TMatrixFSparsefwd.h;  TMatrixFSym.h;  TMatrixFSymfwd.h;  TMatrixFUtils.h;  TMatrixFUtilsfwd.h;  TMatrixT.h;  TMatrixTBase.h;  TMatrixTCramerInv.h;  TMatrixTLazy.h;  TMatrixTSparse.h;  TMatrixTSym.h;  TMatrixTSymCramerInv.h;  TMatrixTUtils.h;  TVector.h;  TVectorD.h;  TVectorDfwd.h;  TVectorF.h;  TVectorFfwd.h;  TVectorfwd.h;  TVectorT.h;  ► src;  T,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:49373,test,testQuasiRandom,49373,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,1,['test'],['testQuasiRandom']
Testability,r.cxx;  GSLMultiRootFunctionAdapter.h;  GSLMultiRootFunctionWrapper.h;  GSLMultiRootSolver.h;  GSLNLSMinimizer.cxx;  GSLQRngWrapper.h;  GSLQuasiRandom.cxx;  GSLRndmEngines.cxx;  GSLRngROOTWrapper.h;  GSLRngWrapper.h;  GSLRootFdFSolver.h;  GSLRootFinder.cxx;  GSLRootFinderDeriv.cxx;  GSLRootFSolver.h;  GSLRootHelper.cxx;  GSLSimAnMinimizer.cxx;  GSLSimAnnealing.cxx;  Interpolator.cxx;  KelvinFunctions.cxx;  MCParameters.cxx;  MultiNumGradFunction.cxx;  PdfFuncMathMore.cxx;  Polynomial.cxx;  QuantFuncMathMore.cxx;  RootFinderAlgorithms.cxx;  SpecFuncMathMore.cxx;  Vavilov.cxx;  VavilovAccurate.cxx;  VavilovAccurateCdf.cxx;  VavilovAccuratePdf.cxx;  VavilovAccurateQuantile.cxx;  VavilovFast.cxx;  zsolve_cubic.cxx;  ► test;  piRandom.C;  pirndm.C;  simanTSP.cxx;  testChebyshev.cxx;  testDerivation.cxx;  testFunctor.cxx;  testGSLIntegration.cxx;  testGSLRootFinder.cxx;  testInterpolation.cxx;  testMCIntegration.cxx;  testMinimization1D.cxx;  testMultiRootFinder.cxx;  testPermute.cxx;  testQuasiRandom.cxx;  testRandom.cxx;  testRandomDist.cxx;  testSpecFunc.cxx;  testStatFunc.cxx;  testVavilov.cxx;  UnuRanDist.h;  VavilovTest.cxx;  VavilovTest.h;  ► matrix;  ► inc;  TDecompBase.h;  TDecompBK.h;  TDecompChol.h;  TDecompLU.h;  TDecompQRH.h;  TDecompSparse.h;  TDecompSVD.h;  TMatrix.h;  TMatrixD.h;  TMatrixDBase.h;  TMatrixDBasefwd.h;  TMatrixDEigen.h;  TMatrixDfwd.h;  TMatrixDLazy.h;  TMatrixDSparse.h;  TMatrixDSparsefwd.h;  TMatrixDSym.h;  TMatrixDSymEigen.h;  TMatrixDSymfwd.h;  TMatrixDUtils.h;  TMatrixDUtilsfwd.h;  TMatrixF.h;  TMatrixFBase.h;  TMatrixFBasefwd.h;  TMatrixFfwd.h;  TMatrixFLazy.h;  TMatrixFSparse.h;  TMatrixFSparsefwd.h;  TMatrixFSym.h;  TMatrixFSymfwd.h;  TMatrixFUtils.h;  TMatrixFUtilsfwd.h;  TMatrixT.h;  TMatrixTBase.h;  TMatrixTCramerInv.h;  TMatrixTLazy.h;  TMatrixTSparse.h;  TMatrixTSym.h;  TMatrixTSymCramerInv.h;  TMatrixTUtils.h;  TVector.h;  TVectorD.h;  TVectorDfwd.h;  TVectorF.h;  TVectorFfwd.h;  TVectorfwd.h;  TVectorT.h;  ► src;  TDecompBase.c,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:47951,test,testQuasiRandom,47951,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['test'],['testQuasiRandom']
Testability,r.h;  GSLMultiFitFunctionWrapper.h;  GSLMultiMinFunctionAdapter.h;  GSLMultiMinFunctionWrapper.h;  GSLMultiMinimizer.h;  GSLMultiRootFinder.cxx;  GSLMultiRootFunctionAdapter.h;  GSLMultiRootFunctionWrapper.h;  GSLMultiRootSolver.h;  GSLNLSMinimizer.cxx;  GSLQRngWrapper.h;  GSLQuasiRandom.cxx;  GSLRndmEngines.cxx;  GSLRngWrapper.h;  GSLRootFdFSolver.h;  GSLRootFinder.cxx;  GSLRootFinderDeriv.cxx;  GSLRootFSolver.h;  GSLRootHelper.cxx;  GSLSimAnMinimizer.cxx;  GSLSimAnnealing.cxx;  Interpolator.cxx;  KelvinFunctions.cxx;  MCParameters.cxx;  MultiNumGradFunction.cxx;  PdfFuncMathMore.cxx;  Polynomial.cxx;  QuantFuncMathMore.cxx;  RootFinderAlgorithms.cxx;  SpecFuncMathMore.cxx;  Vavilov.cxx;  VavilovAccurate.cxx;  VavilovAccurateCdf.cxx;  VavilovAccuratePdf.cxx;  VavilovAccurateQuantile.cxx;  VavilovFast.cxx;  zsolve_cubic.cxx;  ► test;  piRandom.C;  pirndm.C;  simanTSP.cxx;  testChebyshev.cxx;  testDerivation.cxx;  testFunctor.cxx;  testGSLIntegration.cxx;  testGSLRootFinder.cxx;  testInterpolation.cxx;  testMCIntegration.cxx;  testMinimization1D.cxx;  testMultiRootFinder.cxx;  testPermute.cxx;  testQuasiRandom.cxx;  testRandom.cxx;  testRandomDist.cxx;  testSpecFunc.cxx;  testStatFunc.cxx;  testVavilov.cxx;  UnuRanDist.h;  VavilovTest.cxx;  VavilovTest.h;  ► matrix;  ► inc;  LinkDef.h;  TDecompBase.h;  TDecompBK.h;  TDecompChol.h;  TDecompLU.h;  TDecompQRH.h;  TDecompSparse.h;  TDecompSVD.h;  TMatrix.h;  TMatrixD.h;  TMatrixDBase.h;  TMatrixDBasefwd.h;  TMatrixDEigen.h;  TMatrixDfwd.h;  TMatrixDLazy.h;  TMatrixDSparse.h;  TMatrixDSparsefwd.h;  TMatrixDSym.h;  TMatrixDSymEigen.h;  TMatrixDSymfwd.h;  TMatrixDUtils.h;  TMatrixDUtilsfwd.h;  TMatrixF.h;  TMatrixFBase.h;  TMatrixFBasefwd.h;  TMatrixFfwd.h;  TMatrixFLazy.h;  TMatrixFSparse.h;  TMatrixFSparsefwd.h;  TMatrixFSym.h;  TMatrixFSymfwd.h;  TMatrixFUtils.h;  TMatrixFUtilsfwd.h;  TMatrixT.h;  TMatrixTBase.h;  TMatrixTCramerInv.h;  TMatrixTLazy.h;  TMatrixTSparse.h;  TMatrixTSym.h;  TMatrixTSymCramerInv.h;  TMatrixTU,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/files.html:48888,test,testInterpolation,48888,root/html606/files.html,https://root.cern,https://root.cern/root/html606/files.html,1,['test'],['testInterpolation']
Testability,"r/replayer interface for a user.Definition TRecorder.h:266; TRecorder::Stopvoid Stop(Bool_t guiCommand=kFALSE)Stopps recording events.Definition TRecorder.cxx:230; TRecorder::Startvoid Start(const char *filename, Option_t *option=""RECREATE"", Window_t *w=nullptr, Int_t winCount=0)Starts recording events.Definition TRecorder.cxx:221; TStyle::SetPalettevoid SetPalette(Int_t ncolors=kBird, Int_t *colors=nullptr, Float_t alpha=1.)See TColor::SetPalette.Definition TStyle.cxx:1888; c1return c1Definition legend1.C:41; h1TH1F * h1Definition legend1.C:5; c2return c2Definition legend2.C:14; Note: The previous commands should be copy/pasted into a ROOT session, not executed as a macro. The interactive editing shows. Object editing using object editors; Direct editing on the graphics canvas; Saving PS and bitmap files.; Saving as a .C file: C++ code corresponding to the modifications is saved. The sketch of the recorded actions is; On the canvas c1. Open View/Editor; Select histogram; Change fill style; Change fill color; Move stat box; Change fill color; Move title; Change fill color using wheel color; Select Y axis; Change axis title; Select X axis; Change axis title; Select histogram; Go in binning; Change range; Move range; On the canvas menu set grid Y; On the canvas menu set grid X; On the canvas menu set log Y; Increase the range; Close View/Editor; Open the Tool Bar; Create a text ""Comment""; Create an arrow; Change the arrow size; Close the Tool Bar; Save as PS file; Save as C file; Close c1 On the canvas c2. Open View/Editor; Select histogram; Select COL; Select Palette; Move Stats; Select Overflows; Select histogram; Select 3D; Select SURF1; Rotate Surface; Go in binning; Change X range; Change Y range; Close View/Editor; Save as GIF file; Save as C file; Close c2 AuthorOlivier Couet . Definition in file graph_edit_playback.C. tutorialsgraphicsgraph_edit_playback.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/graph__edit__playback_8C.html:3510,log,log,3510,doc/master/graph__edit__playback_8C.html,https://root.cern,https://root.cern/doc/master/graph__edit__playback_8C.html,1,['log'],['log']
Testability,r::SetScanOfPosterior ; (; int ; nbin = 100). inline . use directly the approximate posterior function obtained by binning it in nbins by default the cdf is used by integrating the posterior if a value of nbin <= 0 the cdf function will be used ; Definition at line 126 of file BayesianCalculator.h. ◆ SetShortestInterval(). void RooStats::BayesianCalculator::SetShortestInterval ; (; ). inline . set the Bayesian calculator to compute the shortest interval (default is central interval) to switch off SetLeftSideTailFraction to the right value ; Definition at line 118 of file BayesianCalculator.h. ◆ SetTestSize(). void RooStats::BayesianCalculator::SetTestSize ; (; double ; size). inlineoverridevirtual . set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval) ; Implements RooStats::IntervalCalculator.; Definition at line 99 of file BayesianCalculator.h. ◆ Size(). double RooStats::BayesianCalculator::Size ; (; ); const. inlineoverridevirtual . Get the size of the test (eg. rate of Type I error) ; Implements RooStats::IntervalCalculator.; Definition at line 106 of file BayesianCalculator.h. ◆ Streamer(). void RooStats::BayesianCalculator::Streamer ; (; TBuffer & ; ). overridevirtual . Reimplemented from RooStats::IntervalCalculator. ◆ StreamerNVirtual(). void RooStats::BayesianCalculator::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 194 of file BayesianCalculator.h. Member Data Documentation. ◆ fApproxPosterior. TF1* RooStats::BayesianCalculator::fApproxPosterior. mutableprivate . TF1 representing the scanned posterior function. ; Definition at line 179 of file BayesianCalculator.h. ◆ fBrfPrecision. double RooStats::BayesianCalculator::fBrfPrecision. private . root finder precision ; Definition at line 185 of file BayesianCalculator.h. ◆ fConditionalObs. RooArgSet RooStats::BayesianCalculator::fConditionalObs. private . conditional observables ; Definition at line 170 of file BayesianCalculato,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1BayesianCalculator.html:35070,test,test,35070,doc/master/classRooStats_1_1BayesianCalculator.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1BayesianCalculator.html,1,['test'],['test']
Testability,"r; 2399///; 2400/// The formula was taken from ""Engineering Statistics Handbook"" on site; 2401/// http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm; 2402/// Implementation using ROOT::Math::lognormal_pdf; 2403///; 2404/// Begin_Macro; 2405/// {; 2406/// TCanvas *c1 = new TCanvas(""c1"", ""c1"", 700, 500);; 2407///; 2408/// c1->SetLogy();; 2409/// c1->SetGridx();; 2410/// c1->SetGridy();; 2411///; 2412/// TF1 *logn = new TF1(""logn"", ""TMath::LogNormal(x, [0], [1], [2])"", 0, 5);; 2413/// logn->SetMinimum(1e-3);; 2414///; 2415/// logn->SetParameters(0.5, 0., 1.);; 2416/// logn->SetLineColor(2);; 2417/// TF1 *logn1 = logn->DrawCopy(""L"");; 2418/// logn->SetParameters(1.0, 0., 1.);; 2419/// logn->SetLineColor(3);; 2420/// TF1 *logn2 = logn->DrawCopy(""LSAME"");; 2421/// logn->SetParameters(2.0, 0., 1.);; 2422/// logn->SetLineColor(4);; 2423/// TF1 *logn3 = logn->DrawCopy(""LSAME"");; 2424/// logn->SetParameters(5.0, 0., 1.);; 2425/// logn->SetLineColor(6);; 2426/// TF1 *logn4 = logn->DrawCopy(""LSAME"");; 2427///; 2428/// auto legend = new TLegend(0.15, 0.15, 0.5, 0.35);; 2429/// legend->AddEntry(logn1, ""sigma = 0.5, theta = 0, m = 1"", ""L"");; 2430/// legend->AddEntry(logn2, ""sigma = 1.0, theta = 0, m = 1"", ""L"");; 2431/// legend->AddEntry(logn3, ""sigma = 2.0, theta = 0, m = 1"", ""L"");; 2432/// legend->AddEntry(logn4, ""sigma = 5.0, theta = 0, m = 1"", ""L"");; 2433/// legend->Draw();; 2434/// }; 2435/// End_Macro; 2436 ; 2437Double_t TMath::LogNormal(Double_t x, Double_t sigma, Double_t theta, Double_t m); 2438{; 2439 if ((x<theta) || (sigma<=0) || (m<=0)) {; 2440 Error(""TMath::Lognormal"", ""illegal parameter values"");; 2441 return 0;; 2442 }; 2443 // lognormal_pdf uses same definition of http://en.wikipedia.org/wiki/Log-normal_distribution; 2444 // where mu = log(m); 2445 ; 2446 return ::ROOT::Math::lognormal_pdf(x, TMath::Log(m), sigma, theta);; 2447 ; 2448}; 2449 ; 2450////////////////////////////////////////////////////////////////////////////////; 2451/// Computes quant",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8cxx_source.html:82706,log,logn,82706,doc/master/TMath_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html,2,['log'],['logn']
Testability,r; Float_tfEffSessionsEffective Number of PROOF sessions on the assigned machines; TList*fEnabledPackageslist of enabled packages; Bool_tfEndMastertrue for a master in direct contact only with workers; THashList*fGlobalPackageDirListlist of directories containing global packages libs; TStringfGroupgroup the user belongs to; Int_tfGroupIdslave unique id in the active slave group; Int_tfGroupPrioritypriority of group the user belongs to (0 - 100); Int_tfGroupSizesize of the active slave group; Long64_tfHWMBoxSizeHigh-Water-Mark on the sandbox size; Bool_tfIdleTRUE if idle; TIdleTOTimer*fIdleTOTimerTimer used to control children state; TStringfImageimage name of the session; Int_tfInflateFactorFactor in 1/1000 to inflate the CPU time; TFileHandler*fInputHandlerInput socket handler; Bool_tfInterruptif true macro execution will be stopped; TStopwatchfLatencymeasures latency of packet requests; FILE*fLogFilelog file; Int_tfLogFileDeslog file descriptor; Long64_tfLogFileMaxSizemax size for log files (enabled if > 0); Int_tfLogLeveldebug logging level; Bool_tfMasterServtrue if we are a master server; Long64_tfMaxBoxSizeMax size of the sandbox; Int_tfMaxQueriesMax number of queries fully kept; Int_tfMergedWorkersNumber of workers merged; TMonitor*fMergingMonitorMonitor for merging sockets; TServerSocket*fMergingSocketSocket used for merging outputs if submerger; Long64_tfMsgSizeHWMHigh-Water-Mark on the size of messages with results; Int_tfNcmdcommand history number; TStringfOrdinalslave ordinal number; TStringfPackageDirdirectory containing packages and user libs; TProofLockPath*fPackageLockpackage dir locker; TVirtualProofPlayer*fPlayeractual player; TStringfPrefixPrefix identifying the node; TProof*fProofPROOF talking to slave servers; Int_tfProtocolprotocol version number; TQueryResultManager*fQMgrQuery-result manager; TMutex*fQMtxTo protect async msg queue; TStringfQueryDirdirectory containing query results and status; TProofLockPath*fQueryLockquery dir locker; Int_tfQu,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofServ.html:18166,log,log,18166,root/html530/TProofServ.html,https://root.cern,https://root.cern/root/html530/TProofServ.html,2,['log'],['log']
Testability,"r;  CLikelihoodAux;  CLikelihoodAux< double >;  CBasicFCNBasicFCN class: base class for the objective functions used in the fits It has a reference to the data and th emodel function used in the fit ;  CBinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y values and error on coordinates The dimension of the coordinate is free There are 4 different options: ;  CChi2FCNChi2FCN class for binnned fits using the least square methods ;  CDataOptionsDataOptions : simple structure holding the options on how the data are filled ;  CDataRangeClass describing the range in the coordinates it supports multiple range in a coordinate ;  CDummyDeleter;  CFcnAdapter;  CFitConfigClass describing the configuration of the fit, options and parameter settings using the ROOT::Fit::ParameterSettings class ;  CFitDataBase class for all the fit data types: Stores the coordinates and the DataOptions ;  CFitResultClass containg the result of the fit and all the related information (fitted parameter values, error, covariance matrix and minimizer result information) Contains a pointer also to the fitted (model) function, modified with the fit parameter values ;  CFitterFitter class, entry point for performing all type of fits ;  CLogLikelihoodFCNLogLikelihoodFCN class for likelihood fits ;  CParameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to set/retrieve values, step sizes, limits and fix the parameters ;  CPoissonLikelihoodFCNClass evaluating the log likelihood for binned Poisson likelihood fits it is template to distinguish gradient and non-gradient case ;  CSparseData;  CUnBinDataClass describing the unbinned data sets (just x coordinates values) of any dimensions ;  ►NInternal;  ►NExecutorUtils;  CResultCaster;  CResultCaster< TObject *, F >;  ►NRDF;  ►NGraphDrawing;  CGraphCreatorHelper;  CGraphNode;  CDisplayHelper;  CPassAsVecHelper;  CPassAsVecHelper< std::index_sequence< N.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:26822,log,log,26822,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['log'],['log']
Testability,"r< CoordSystem >::py ; (; ); const. inline . Definition at line 647 of file LorentzVector.h. ◆ Pz(). template<class CoordSystem > . Scalar ROOT::Math::LorentzVector< CoordSystem >::Pz ; (; ); const. inline . spatial Z component ; Definition at line 289 of file LorentzVector.h. ◆ pz(). template<class CoordSystem > . Scalar ROOT::Math::LorentzVector< CoordSystem >::pz ; (; ); const. inline . Definition at line 648 of file LorentzVector.h. ◆ R(). template<class CoordSystem > . Scalar ROOT::Math::LorentzVector< CoordSystem >::R ; (; ); const. inline . return the spatial (3D) magnitude ( sqrt(X**2 + Y**2 + Z**2) ) ; Definition at line 310 of file LorentzVector.h. ◆ r(). template<class CoordSystem > . Scalar ROOT::Math::LorentzVector< CoordSystem >::r ; (; ); const. inline . Definition at line 650 of file LorentzVector.h. ◆ Rapidity(). template<class CoordSystem > . Scalar ROOT::Math::LorentzVector< CoordSystem >::Rapidity ; (; ); const. inline . Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. ; Definition at line 503 of file LorentzVector.h. ◆ Rho(). template<class CoordSystem > . Scalar ROOT::Math::LorentzVector< CoordSystem >::Rho ; (; ); const. inline . Definition at line 325 of file LorentzVector.h. ◆ rho(). template<class CoordSystem > . Scalar ROOT::Math::LorentzVector< CoordSystem >::rho ; (; ); const. inline . Definition at line 653 of file LorentzVector.h. ◆ SetCoordinates() [1/3]. template<class CoordSystem > . LorentzVector< CoordSystem > & ROOT::Math::LorentzVector< CoordSystem >::SetCoordinates ; (; const Scalar ; src[]). inline . Set internal data based on an array of 4 Scalar numbers. ; Definition at line 177 of file LorentzVector.h. ◆ SetCoordinates() [2/3]. template<class CoordSystem > . template<class IT > . LorentzVector< CoordSystem > & ROOT::Math::LorentzVector< CoordSystem >::SetCoordinates ; (; IT ; begin, . IT ; end . ). inline . Set internal data based on 4 Scalars at *begin to *end. ; Definition at line 194 of file LorentzVector.h. ◆ Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1LorentzVector.html:28407,log,log,28407,doc/master/classROOT_1_1Math_1_1LorentzVector.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1LorentzVector.html,1,['log'],['log']
Testability,"r<<() [1/5]. MsgLogger & TMVA::MsgLogger::operator<< ; (; EMsgType ; type). inline . Definition at line 141 of file MsgLogger.h. ◆ operator<<() [2/5]. MsgLogger & TMVA::MsgLogger::operator<< ; (; MsgLogger &(*)(MsgLogger &) ; _f). inline . Definition at line 124 of file MsgLogger.h. ◆ operator<<() [3/5]. MsgLogger & TMVA::MsgLogger::operator<< ; (; std::ios &(*)(std::ios &) ; _f). inline . Definition at line 135 of file MsgLogger.h. ◆ operator<<() [4/5]. MsgLogger & TMVA::MsgLogger::operator<< ; (; std::ostream &(*)(std::ostream &) ; _f). inline . Definition at line 129 of file MsgLogger.h. ◆ operator<<() [5/5]. template<class T > . MsgLogger & TMVA::MsgLogger::operator<< ; (; T ; arg). inline . Definition at line 92 of file MsgLogger.h. ◆ operator=(). TMVA::MsgLogger & TMVA::MsgLogger::operator= ; (; const MsgLogger & ; parent). assignment operator ; Definition at line 128 of file MsgLogger.cxx. ◆ Send(). void TMVA::MsgLogger::Send ; (; ). private . activates the logger writer ; Definition at line 185 of file MsgLogger.cxx. ◆ SetMinType(). void TMVA::MsgLogger::SetMinType ; (; EMsgType ; minType). inline . Definition at line 70 of file MsgLogger.h. ◆ SetSource(). void TMVA::MsgLogger::SetSource ; (; const std::string & ; source). inline . Definition at line 68 of file MsgLogger.h. ◆ Streamer(). virtual void TMVA::MsgLogger::Streamer ; (; TBuffer & ; R__b). virtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TMVA::MsgLogger::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 121 of file MsgLogger.h. ◆ WriteMsg(). void TMVA::MsgLogger::WriteMsg ; (; EMsgType ; type, . const std::string & ; line . ); const. private . putting the output string, the message type, and the color switcher together into a single string ; Definition at line 220 of file MsgLogger.cxx. Member Data Documentation. ◆ fActiveType. EMsgType TMVA::MsgLogger::fActiveType. private . active type ; Definition at l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MsgLogger.html:16344,log,logger,16344,doc/master/classTMVA_1_1MsgLogger.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MsgLogger.html,1,['log'],['logger']
Testability,"r<std::string> FIXMEModules = {""Hist""};; 1230 clang::CompilerInstance &CI = *clingInterp.getCI();; 1231 clang::Preprocessor &PP = CI.getPreprocessor();; 1232 ModuleMap &MMap = PP.getHeaderSearchInfo().getModuleMap();; 1233 if (MMap.findModule(""RInterface"")); 1234 FIXMEModules.push_back(""RInterface"");; 1235 ; 1236 LoadModules(FIXMEModules, clingInterp);; 1237 ; 1238 GlobalModuleIndex *GlobalIndex = nullptr;; 1239 loadGlobalModuleIndex(clingInterp);; 1240 // FIXME: The ASTReader still calls loadGlobalIndex and loads the file; 1241 // We should investigate how to suppress it completely.; 1242 GlobalIndex = CI.getASTReader()->getGlobalIndex();; 1243 ; 1244 llvm::StringSet<> KnownModuleFileNames;; 1245 if (GlobalIndex); 1246 GlobalIndex->getKnownModuleFileNames(KnownModuleFileNames);; 1247 ; 1248 std::vector<std::string> PendingModules;; 1249 PendingModules.reserve(256);; 1250 for (auto I = MMap.module_begin(), E = MMap.module_end(); I != E; ++I) {; 1251 clang::Module *M = I->second;; 1252 assert(M);; 1253 ; 1254 // We want to load only already created modules.; 1255 std::string FullASTFilePath;; 1256 if (!HasASTFileOnDisk(M, PP, &FullASTFilePath)); 1257 continue;; 1258 ; 1259 if (GlobalIndex && KnownModuleFileNames.count(FullASTFilePath)); 1260 continue;; 1261 ; 1262 if (M->IsUnimportable); 1263 continue;; 1264 ; 1265 if (GlobalIndex); 1266 LoadModule(M->Name, clingInterp);; 1267 else {; 1268 // FIXME: We may be able to remove those checks as cling::loadModule; 1269 // checks if a module was alredy loaded.; 1270 if (std::find(CoreModules.begin(), CoreModules.end(), M->Name) != CoreModules.end()); 1271 continue; // This is a core module which was already loaded.; 1272 ; 1273 // Load system modules now and delay the other modules after we have; 1274 // loaded all system ones.; 1275 if (M->IsSystem); 1276 LoadModule(M->Name, clingInterp);; 1277 else; 1278 PendingModules.push_back(M->Name);; 1279 }; 1280 }; 1281 LoadModules(PendingModules, clingInterp);; 1282 }; 1283 ; 1284 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:45403,assert,assert,45403,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['assert'],['assert']
Testability,"r<string>& totSystTermNames); add variables for all the relative overall uncertainties we expect; range is set using defined macro (see top of the page); string range=""[0,-1,1]"";. void MakeTotalExpected(RooWorkspace* proto, string totName, string , string , int lowBin, int highBin, vector<string>& syst_x_expectedPrefixNames, vector<string>& normByNames); for ith bin calculate totN_i = lumi * sum_j expected_j * syst_j. void AddPoissonTerms(RooWorkspace* proto, string prefix, string obsPrefix, string expPrefix, int lowBin, int highBin, vector<string>& likelihoodTermNames). Relate observables to expected for each bin; later modify variable named expPrefix_i to be product of terms. void SetObsToExpected(RooWorkspace* proto, string obsPrefix, string expPrefix, int lowBin, int highBin). set observed to expected. void Customize(RooWorkspace* proto, const char* pdfNameChar, map<string,string> renameMap). void EditSyst(RooWorkspace* proto, const char* pdfNameChar, map<string,double> gammaSyst, map<string,double> uniformSyst, map<string,double> logNormSyst); cout << ""in edit, gammamap.size = "" << gammaSyst.size() << "", unimap.size = "" << uniformSyst.size() << endl;. void PrintCovarianceMatrix(RooFitResult* result, RooArgSet* params, string filename); FILE * pFile;. RooWorkspace* MakeSingleChannelModel(vector<RooStats::HistFactory::EstimateSummary> summary, vector<string> systToFix, bool doRatio = false). RooWorkspace* MakeCombinedModel(vector<string> , vector<RooWorkspace*> ). void FitModel(RooWorkspace* , string , string , string , bool = false). void FormatFrameForLikelihood(RooPlot* frame, string XTitle = std::string(""#sigma / #sigma_{SM}""), string YTitle = std::string(""-log likelihood"")). TDirectory * Makedirs(TDirectory* file, vector<string> names). TDirectory * Mkdir(TDirectory* file, string name). HistoToWorkspaceFactory(string , string , vector<string> , double = 200, double = 20, int = 0, int = 6, TFile* = 0). » Author: Kyle Cranmer, Akira Shibata » Copyright (C) 1995",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HistFactory__HistoToWorkspaceFactory.html:10938,log,logNormSyst,10938,root/html602/RooStats__HistFactory__HistoToWorkspaceFactory.html,https://root.cern,https://root.cern/root/html602/RooStats__HistFactory__HistoToWorkspaceFactory.html,2,['log'],['logNormSyst']
Testability,"r<string>& totSystTermNames); add variables for all the relative overall uncertainties we expect; range is set using defined macro (see top of the page); string range=""[0,-1,1]"";. void MakeTotalExpected(RooWorkspace* proto, string totName, string , string , int lowBin, int highBin, vector<string>& syst_x_expectedPrefixNames, vector<string>& normByNames); for ith bin calculate totN_i = lumi * sum_j expected_j * syst_j. void AddPoissonTerms(RooWorkspace* proto, string prefix, string obsPrefix, string expPrefix, int lowBin, int highBin, vector<string>& likelihoodTermNames). Relate observables to expected for each bin; later modify variable named expPrefix_i to be product of terms. void SetObsToExpected(RooWorkspace* proto, string obsPrefix, string expPrefix, int lowBin, int highBin). set observed to expected. void Customize(RooWorkspace* proto, const char* pdfNameChar, map<string,string> renameMap). void EditSyst(RooWorkspace* proto, const char* pdfNameChar, map<string,double> gammaSyst, map<string,double> uniformSyst, map<string,double> logNormSyst); cout << ""in edit, gammamap.size = "" << gammaSyst.size() << "", unimap.size = "" << uniformSyst.size() << endl;. void PrintCovarianceMatrix(RooFitResult* result, RooArgSet* params, string filename); FILE * pFile;. RooWorkspace* MakeSingleChannelModel(vector<RooStats::HistFactory::EstimateSummary> summary, vector<string> systToFix, bool doRatio = false). RooWorkspace* MakeCombinedModel(vector<string> , vector<RooWorkspace*> ). void FitModel(RooWorkspace* , string , string , string , bool = false). void FormatFrameForLikelihood(RooPlot* frame, string XTitle = string(""#sigma / #sigma_{SM}""), string YTitle = string(""-log likelihood"")). TDirectory * Makedirs(TDirectory* file, vector<string> names). TDirectory * Mkdir(TDirectory* file, string name). » Author: Kyle Cranmer, Akira Shibata » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: cranmer $ » Last generated: 2010-12-08 11:25; This ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__HistFactory__HistoToWorkspaceFactory.html:10209,log,logNormSyst,10209,root/html528/RooStats__HistFactory__HistoToWorkspaceFactory.html,https://root.cern,https://root.cern/root/html528/RooStats__HistFactory__HistoToWorkspaceFactory.html,1,['log'],['logNormSyst']
Testability,"r<string>& totSystTermNames); add variables for all the relative overall uncertainties we expect; range is set using defined macro (see top of the page); string range=""[0,-1,1]"";. void MakeTotalExpected(RooWorkspace* proto, string totName, string , string , int lowBin, int highBin, vector<string>& syst_x_expectedPrefixNames, vector<string>& normByNames); for ith bin calculate totN_i = lumi * sum_j expected_j * syst_j. void AddPoissonTerms(RooWorkspace* proto, string prefix, string obsPrefix, string expPrefix, int lowBin, int highBin, vector<string>& likelihoodTermNames). Relate observables to expected for each bin; later modify variable named expPrefix_i to be product of terms. void SetObsToExpected(RooWorkspace* proto, string obsPrefix, string expPrefix, int lowBin, int highBin). set observed to expected. void Customize(RooWorkspace* proto, const char* pdfNameChar, map<string,string> renameMap). void EditSyst(RooWorkspace* proto, const char* pdfNameChar, map<string,double> gammaSyst, map<string,double> uniformSyst, map<string,double> logNormSyst); cout << ""in edit, gammamap.size = "" << gammaSyst.size() << "", unimap.size = "" << uniformSyst.size() << endl;. void PrintCovarianceMatrix(RooFitResult* result, RooArgSet* params, string filename); FILE * pFile;. RooWorkspace* MakeSingleChannelModel(vector<RooStats::HistFactory::EstimateSummary> summary, vector<string> systToFix, bool doRatio = false). RooWorkspace* MakeCombinedModel(vector<string> , vector<RooWorkspace*> ). void FitModel(RooWorkspace* , string , string , string , bool = false). void FormatFrameForLikelihood(RooPlot* frame, string XTitle = string(""#sigma / #sigma_{SM}""), string YTitle = string(""-log likelihood"")). TDirectory * Makedirs(TDirectory* file, vector<string> names). TDirectory * Mkdir(TDirectory* file, string name). » Author: Kyle Cranmer, Akira Shibata » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: cranmer $ » Last generated: 2011-07-04 15:24; This ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__HistFactory__HistoToWorkspaceFactory.html:10274,log,logNormSyst,10274,root/html530/RooStats__HistFactory__HistoToWorkspaceFactory.html,https://root.cern,https://root.cern/root/html530/RooStats__HistFactory__HistoToWorkspaceFactory.html,2,['log'],['logNormSyst']
Testability,"r<string>& totSystTermNames); add variables for all the relative overall uncertainties we expect; range is set using defined macro (see top of the page); string range=""[0,-1,1]"";. void MakeTotalExpected(RooWorkspace* proto, string totName, string , string , int lowBin, int highBin, vector<string>& syst_x_expectedPrefixNames, vector<string>& normByNames); for ith bin calculate totN_i = lumi * sum_j expected_j * syst_j. void AddPoissonTerms(RooWorkspace* proto, string prefix, string obsPrefix, string expPrefix, int lowBin, int highBin, vector<string>& likelihoodTermNames). Relate observables to expected for each bin; later modify variable named expPrefix_i to be product of terms. void SetObsToExpected(RooWorkspace* proto, string obsPrefix, string expPrefix, int lowBin, int highBin). set observed to expected. void Customize(RooWorkspace* proto, const char* pdfNameChar, map<string,string> renameMap). void EditSyst(RooWorkspace* proto, const char* pdfNameChar, map<string,double> gammaSyst, map<string,double> uniformSyst, map<string,double> logNormSyst); cout << ""in edit, gammamap.size = "" << gammaSyst.size() << "", unimap.size = "" << uniformSyst.size() << endl;. void PrintCovarianceMatrix(RooFitResult* result, RooArgSet* params, string filename); FILE * pFile;. RooWorkspace* MakeSingleChannelModel(vector<RooStats::HistFactory::EstimateSummary> summary, vector<string> systToFix, bool doRatio = false). RooWorkspace* MakeCombinedModel(vector<string> , vector<RooWorkspace*> ). void FitModel(RooWorkspace* , string , string , string , bool = false). void FormatFrameForLikelihood(RooPlot* frame, string XTitle = string(""#sigma / #sigma_{SM}""), string YTitle = string(""-log likelihood"")). TDirectory * Makedirs(TDirectory* file, vector<string> names). TDirectory * Mkdir(TDirectory* file, string name). » Author: Kyle Cranmer, Akira Shibata » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: cranmer $ » Last generated: 2011-12-02 14:27; This ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__HistFactory__HistoToWorkspaceFactory.html:10266,log,logNormSyst,10266,root/html532/RooStats__HistFactory__HistoToWorkspaceFactory.html,https://root.cern,https://root.cern/root/html532/RooStats__HistFactory__HistoToWorkspaceFactory.html,1,['log'],['logNormSyst']
Testability,"r<string>& totSystTermNames); add variables for all the relative overall uncertainties we expect; range is set using defined macro (see top of the page); string range=""[0,-1,1]"";. void MakeTotalExpected(RooWorkspace* proto, string totName, string , string , int lowBin, int highBin, vector<string>& syst_x_expectedPrefixNames, vector<string>& normByNames); for ith bin calculate totN_i = lumi * sum_j expected_j * syst_j. void AddPoissonTerms(RooWorkspace* proto, string prefix, string obsPrefix, string expPrefix, int lowBin, int highBin, vector<string>& likelihoodTermNames). Relate observables to expected for each bin; later modify variable named expPrefix_i to be product of terms. void SetObsToExpected(RooWorkspace* proto, string obsPrefix, string expPrefix, int lowBin, int highBin). set observed to expected. void Customize(RooWorkspace* proto, const char* pdfNameChar, map<string,string> renameMap). void EditSyst(RooWorkspace* proto, const char* pdfNameChar, map<string,double> gammaSyst, map<string,double> uniformSyst, map<string,double> logNormSyst, map<string,double> noSyst). void PrintCovarianceMatrix(RooFitResult* result, RooArgSet* params, string filename); FILE * pFile;. RooWorkspace* MakeSingleChannelModel(vector<RooStats::HistFactory::EstimateSummary> summary, vector<string> systToFix, bool doRatio = false); to time the macro. void GuessObsNameVec(TH1* hist). RooWorkspace* MakeCombinedModel(vector<string> , vector<RooWorkspace*> ). void FitModel(RooWorkspace* , string , string , string , bool = false). void FormatFrameForLikelihood(RooPlot* frame, string XTitle = string(""#sigma / #sigma_{SM}""), string YTitle = string(""-log likelihood"")). TH1* MakeAbsolUncertaintyHist(const string& Name, const TH1* Hist). TH1* MakeScaledUncertaintyHist(const string& Name, vector<std::pair<TH1*,TH1*> > HistVec). RooArgList createStatConstraintTerms(RooWorkspace* proto, vector<string>& constraintTerms, ParamHistFunc& paramHist, TH1* uncertHist, RooStats::HistFactory::EstimateSumma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__HistFactory__HistoToWorkspaceFactoryFast.html:10974,log,logNormSyst,10974,root/html532/RooStats__HistFactory__HistoToWorkspaceFactoryFast.html,https://root.cern,https://root.cern/root/html532/RooStats__HistFactory__HistoToWorkspaceFactoryFast.html,1,['log'],['logNormSyst']
Testability,"r=(const RooStats::TestStatSampler&); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetGlobalObservables(const RooArgSet&); virtual voidSetNuisanceParameters(const RooArgSet&); virtual voidSetObservables(const RooArgSet&); virtual voidSetParametersForTestStat(const RooArgSet&); virtual voidSetPdf(RooAbsPdf&); virtual voidSetPriorNuisance(RooAbsPdf*); virtual voidSetSamplingDistName(const char* name); virtual voidSetTestSize(Double_t size); virtual voidSetTestStatistic(RooStats::TestStatistic* testStatistic); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TestStatSampler(); TestStatSampler();. {}. SamplingDistribution* GetSamplingDistribution(RooArgSet& paramsOfInterest); Main interface to get a ConfInterval, pure virtual. Double_t EvaluateTestStatistic(RooAbsData& data, RooArgSet& paramsOfInterest); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetTestStatistic() const; Get the TestStatistic. Double_t ConfidenceLevel() const; Get the Confidence level for the test. void Initialize(RooAbsArg& testStatistic, RooArgSet& paramsOfInterest, RooArgSet& nuisanceParameters); Common Initialization. void SetPdf(RooAbsPdf& ); Set the Pdf, add to the the workspace if not already there. void SetPriorNuisance(RooAbsPdf* ); How to randomize the prior. Set to NULL to deactivate randomization. void SetParametersForTestStat(const RooArgSet& ); specify the values of parameters used when evaluating test statistic. void SetNuisanceParameters(const RooArgSet& ); REMOVE THIS; specify the parameters of interest in the interval; virtual void SetParameters(const RooArgSet&) = 0;; specify the nuisance parameters (eg. the rest of the parameters). void SetObservables(const RooArgSet& ); specify the observables in the dataset (needed to evaluate the test statistic). void Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__TestStatSampler.html:2221,test,test,2221,root/html534/RooStats__TestStatSampler.html,https://root.cern,https://root.cern/root/html534/RooStats__TestStatSampler.html,1,['test'],['test']
Testability,"r=wrap_pdf_Int[pTV]=242.998; ... (remaining 14 messages suppressed); ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=-3.35967 cHl3=-9.58704 cHq3=-6.27461; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.154263 cHl3=2.95902 cHq3=-2.78828; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=59.1285, denominator=wrap_pdf_Int[pTV]=200921; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.338546 cHl3=0.879879 cHq3=-1.35856; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=14.3535, denominator=wrap_pdf_Int[pTV]=34082.1; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=14.3535, denominator=wrap_pdf_Int[pTV]=34082.1; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=14.3535, denominator=wrap_pdf_Int[pTV]=34082.1; getLogVal() top-level p.d.f evaluates to NaN @ num",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:15002,log,log,15002,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['log'],['log']
Testability,"rAutoAdd);; 2448 copy->fStreamerFunc = fStreamerFunc;; 2449 copy->fConvStreamerFunc = fConvStreamerFunc;; 2450 if (fStreamer) {; 2451 copy->AdoptStreamer(fStreamer->Generate());; 2452 }; 2453 // If IsZombie is true, something went wrong and we will not be; 2454 // able to properly copy the collection proxy; 2455 if (fCollectionProxy && !copy->IsZombie()) {; 2456 copy->CopyCollectionProxy(*fCollectionProxy);; 2457 }; 2458 copy->SetClassSize(fSizeof);; 2459 if (fRefProxy) {; 2460 copy->AdoptReferenceProxy( fRefProxy->Clone() );; 2461 }; 2462 TClass::AddClass(const_cast<TClass*>(this));; 2463 return copy;; 2464}; 2465 ; 2466////////////////////////////////////////////////////////////////////////////////; 2467/// Replaces the collection proxy for this class. The provided object is cloned; 2468/// and the copy is then owned by `TClass`.; 2469 ; 2470void TClass::CopyCollectionProxy(const TVirtualCollectionProxy &orig); 2471{; 2472// // This code was used too quickly test the STL Emulation layer; 2473// Int_t k = TClassEdit::IsSTLCont(GetName());; 2474// if (k==1||k==-1) return;; 2475 ; 2476 delete fCollectionProxy;; 2477 fCollectionProxy = orig.Generate();; 2478}; 2479 ; 2480////////////////////////////////////////////////////////////////////////////////; 2481/// Draw detailed class inheritance structure.; 2482/// If a class B inherits from a class A, the description of B is drawn; 2483/// on the right side of the description of A.; 2484/// Member functions overridden by B are shown in class A with a blue line; 2485/// erasing the corresponding member function; 2486 ; 2487void TClass::Draw(Option_t *option); 2488{; 2489 if (!HasInterpreterInfo()) return;; 2490 ; 2491 TVirtualPad::TContext ctxt(kTRUE);; 2492 ; 2493 // Should we create a new canvas?; 2494 TString opt = option;; 2495 if (!ctxt.GetSaved() || !opt.Contains(""same"")) {; 2496 TVirtualPad *padclass = (TVirtualPad*)(gROOT->GetListOfCanvases())->FindObject(""R__class"");; 2497 if (!padclass) {; 2498 gROOT->ProcessLine",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:93020,test,test,93020,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['test'],['test']
Testability,"rAutoAdd);; 2515 copy->fStreamerFunc = fStreamerFunc;; 2516 copy->fConvStreamerFunc = fConvStreamerFunc;; 2517 if (fStreamer) {; 2518 copy->AdoptStreamer(fStreamer->Generate());; 2519 }; 2520 // If IsZombie is true, something went wrong and we will not be; 2521 // able to properly copy the collection proxy; 2522 if (fCollectionProxy && !copy->IsZombie()) {; 2523 copy->CopyCollectionProxy(*fCollectionProxy);; 2524 }; 2525 copy->SetClassSize(fSizeof);; 2526 if (fRefProxy) {; 2527 copy->AdoptReferenceProxy( fRefProxy->Clone() );; 2528 }; 2529 TClass::AddClass(const_cast<TClass*>(this));; 2530 return copy;; 2531}; 2532 ; 2533////////////////////////////////////////////////////////////////////////////////; 2534/// Replaces the collection proxy for this class. The provided object is cloned; 2535/// and the copy is then owned by `TClass`.; 2536 ; 2537void TClass::CopyCollectionProxy(const TVirtualCollectionProxy &orig); 2538{; 2539// // This code was used too quickly test the STL Emulation layer; 2540// Int_t k = TClassEdit::IsSTLCont(GetName());; 2541// if (k==1||k==-1) return;; 2542 ; 2543 delete fCollectionProxy;; 2544 fCollectionProxy = orig.Generate();; 2545}; 2546 ; 2547////////////////////////////////////////////////////////////////////////////////; 2548/// Draw detailed class inheritance structure.; 2549/// If a class B inherits from a class A, the description of B is drawn; 2550/// on the right side of the description of A.; 2551/// Member functions overridden by B are shown in class A with a blue line; 2552/// erasing the corresponding member function; 2553 ; 2554void TClass::Draw(Option_t *option); 2555{; 2556 if (!HasInterpreterInfo()) return;; 2557 ; 2558 TVirtualPad::TContext ctxt(kTRUE);; 2559 ; 2560 // Should we create a new canvas?; 2561 TString opt = option;; 2562 if (!ctxt.GetSaved() || !opt.Contains(""same"")) {; 2563 TVirtualPad *padclass = (TVirtualPad*)(gROOT->GetListOfCanvases())->FindObject(""R__class"");; 2564 if (!padclass) {; 2565 gROOT->ProcessLine",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:95771,test,test,95771,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['test'],['test']
Testability,"rCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout); Do full rendering of scene. First draw the opaques, then the transparents. For each we do; the number of passes required by draw mode and clipping setup. void RenderElements(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout, const TGLPlaneSet_t* clipPlanes = 0); Render DrawElements in elementVec with given timeout.; If clipPlanes is non-zero, test each element against its; clipping planes. Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); Process selection record rec.; 'curIdx' is the item position where the scene should start; its processing.; Return TRUE if an object has been identified or FALSE otherwise.; The scene-info member of the record is already set by the caller. void CalcBoundingBox() const; Encapsulates all physical shapes bounding box with axes aligned box.; Validity checked in the base-class. void AdoptLogical(TGLLogicalShape& shape); Adopt dynamically created logical 'shape' - add to internal map; and take responsibility for deleting. Bool_t DestroyLogical(TObject* logid, Bool_t mustFind = kTRUE); Destroy logical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. If mustFind is true, an error is reported if the logical is not; found. Int_t DestroyLogicals(); Destroy all logical shapes in scene.; Return number of destroyed logicals. TGLLogicalShape * FindLogical(TObject* logid) const; Find and return logical shape identified by unqiue logid.; Returns 0 if not found. void AdoptPhysical(TGLPhysicalShape& shape); Adopt dynamically created physical 'shape' - add to internal map and take; responsibility for deleting. void DestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); Virtual function to destroy a physical. Sub-classes might have; special checks to perform.; Caller should also invalidate the draw-list. Bool_t DestroyPhysical(UInt_t phid); Destroy physical shape defined by unique 'ID'.; Returns kTRUE if ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLScene.html:10716,log,logical,10716,root/html528/TGLScene.html,https://root.cern,https://root.cern/root/html528/TGLScene.html,6,['log'],['logical']
Testability,"rName(0, ""NSignal"");; 60 for (int i = 2; i < f_sum->GetNpar(); ++i); 61 f_sum->SetParName(i, fnorm_exp_cb->GetParName(i));; 62 ; 63 // GENERATE HISTOGRAM TO FIT ..............................................................; 64 TStopwatch w;; 65 w.Start();; 66 TH1D *h_sum = new TH1D(""h_ExpCB"", ""Exponential Bkg + CrystalBall function"", nBins, -5., 5.);; 67 h_sum->FillRandom(""fsum"", nEvents);; 68 printf(""Time to generate %d events: "", nEvents);; 69 w.Print();; 70 ; 71 // need to scale histogram with width since we are fitting a density; 72 h_sum->Sumw2();; 73 h_sum->Scale(1., ""width"");; 74 ; 75 // fit - use Minuit2 if available; 76 ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""Minuit2"");; 77 new TCanvas(""Fit"", ""Fit"", 800, 1000);; 78 // do a least-square fit of the spectrum; 79 auto result = h_sum->Fit(""fsum"", ""SQ"");; 80 result->Print();; 81 h_sum->Draw();; 82 printf(""Time to fit using ROOT TF1Normsum: "");; 83 w.Print();; 84 ; 85 // test if parameters are fine; 86 std::vector<double> pref = {nsig, nbkg, signal_mean};; 87 for (unsigned int i = 0; i < pref.size(); ++i) {; 88 if (!TMath::AreEqualAbs(pref[i], f_sum->GetParameter(i), f_sum->GetParError(i) * 10.)); 89 Error(""testFitNormSum"", ""Difference found in fitted %s - difference is %g sigma"", f_sum->GetParName(i),; 90 (f_sum->GetParameter(i) - pref[i]) / f_sum->GetParError(i));; 91 }; 92 ; 93 gStyle->SetOptStat(0);; 94 // add parameters; 95 auto t1 = new TLatex(; 96 -2.5, 300000, TString::Format(""%s = %8.0f #pm %4.0f"", ""NSignal"", f_sum->GetParameter(0), f_sum->GetParError(0)));; 97 auto t2 = new TLatex(; 98 -2.5, 270000, TString::Format(""%s = %8.0f #pm %4.0f"", ""Nbackgr"", f_sum->GetParameter(1), f_sum->GetParError(1)));; 99 t1->Draw();; 100 t2->Draw();; 101}; MinimizerOptions.h; TCanvas.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; TF1NormSum.h; TF1.h; TFitResult.h; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; resultOption_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/fitNormSum_8C_source.html:3062,test,test,3062,doc/master/fitNormSum_8C_source.html,https://root.cern,https://root.cern/doc/master/fitNormSum_8C_source.html,1,['test'],['test']
Testability,"rOptions().SetPrintLevel(0);; 899 ; 900 // more; 901 if (fitOption.More) fitConfig.SetMinimizer(""Minuit"",""MigradImproved"");; 902 ; 903 // chech if Minos or more options; 904 if (fitOption.Errors) {; 905 // run Hesse and Minos; 906 fitConfig.SetParabErrors(true);; 907 fitConfig.SetMinosErrors(true);; 908 }; 909 // use weight correction; 910 if ( (fitOption.Like & 2) == 2); 911 fitConfig.SetWeightCorrection(true);; 912 ; 913 bool extended = (fitOption.Like & 1) == 1;; 914 ; 915 bool fitok = false;; 916 fitok = fitter->LikelihoodFit(fitdata, extended, fitOption.ExecPolicy);; 917 if ( !fitok && !fitOption.Quiet ); 918 Warning(""UnBinFit"",""Abnormal termination of minimization."");; 919 ; 920 const ROOT::Fit::FitResult & fitResult = fitter->Result();; 921 // one could set directly the fit result in TF1; 922 int iret = fitResult.Status();; 923 if (!fitResult.IsEmpty() ) {; 924 // set in fitfunc the result of the fit; 925 fitfunc->SetNDF(fitResult.Ndf() );; 926 fitfunc->SetNumberFitPoints(fitdata->Size() );; 927 ; 928 assert( (Int_t)fitResult.Parameters().size() >= fitfunc->GetNpar() );; 929 fitfunc->SetParameters( const_cast<double*>(&(fitResult.Parameters().front())));; 930 if ( int( fitResult.Errors().size()) >= fitfunc->GetNpar() ); 931 fitfunc->SetParErrors( &(fitResult.Errors().front()) );; 932 ; 933 }; 934 ; 935 // store fitting result in the backward compatible TVirtualFitter object; 936 // lock in case running in a multi-thread enabled mode; 937 {; 938 R__LOCKGUARD(gROOTMutex);; 939 TVirtualFitter * lastFitter = TVirtualFitter::GetFitter();; 940 TBackCompFitter * bcfitter = new TBackCompFitter(fitter, fitdata);; 941 // cannot use anymore now fitdata (given away ownership); 942 fitdata = nullptr;; 943 bcfitter->SetFitOption(fitOption);; 944 bcfitter->SetUserFunc(fitfunc);; 945 // delete previous fitter and replace with the new one; 946 if (lastFitter) delete lastFitter;; 947 TVirtualFitter::SetFitter( bcfitter );; 948 ; 949 // print results; 950 if (fitOption.Verbose) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/HFitImpl_8cxx_source.html:34722,assert,assert,34722,doc/master/HFitImpl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/HFitImpl_8cxx_source.html,1,['assert'],['assert']
Testability,"rPointer > fFunctor! Functor object to wrap any C++ callable objectDefinition TF1.h:287; TF1::GetMinimumXvirtual Double_t GetMinimumX(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the X value corresponding to the minimum value of the function on the (xmin,...Definition TF1.cxx:1823; TF1::GetMinimumvirtual Double_t GetMinimum(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the minimum value of the function on the (xmin, xmax) interval.Definition TF1.cxx:1696; TF1::GetXmaxvirtual Double_t GetXmax() constDefinition TF1.h:584; TF1::ReleaseParametervirtual void ReleaseParameter(Int_t ipar)Release parameter number ipar during a fit operation.Definition TF1.cxx:3151; TF1::SetParErrorvirtual void SetParError(Int_t ipar, Double_t error)Set error for parameter number ipar.Definition TF1.cxx:3479; TF1::RejectPointstatic void RejectPoint(Bool_t reject=kTRUE)Static function to set the global flag to reject points the fgRejectPoint global flag is tested by al...Definition TF1.cxx:3683; TF1::EAddToListEAddToListAdd to list behavior.Definition TF1.h:240; TF1::EAddToList::kDefault@ kDefault; TF1::EAddToList::kNo@ kNo; TF1::EAddToList::kAdd@ kAdd; TF1::Derivativevirtual Double_t Derivative(Double_t x, Double_t *params=nullptr, Double_t epsilon=0.001) constReturns the first derivative of the function at point x, computed by Richardson's extrapolation metho...Definition TF1.cxx:1113; TF1::GetNumbervirtual Int_t GetNumber() constDefinition TF1.h:526; TF1::GetNDFvirtual Int_t GetNDF() constReturn the number of degrees of freedom in the fit the fNDF parameter has been previously computed du...Definition TF1.cxx:1889; TF1::fParErrorsstd::vector< Double_t > fParErrorsArray of errors of the fNpar parameters.Definition TF1.h:274; TF1::fNdimInt_t fNdimFunction dimension.Definition TF1.h:266; TF1::CalcGaussLegendreSamplingPointsstatic void CalcGaussLegendreSamplingPoints",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:174730,test,tested,174730,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['test'],['tested']
Testability,"rPointer > fFunctor! Functor object to wrap any C++ callable objectDefinition TF1.h:287; TF1::GetMinimumXvirtual Double_t GetMinimumX(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the X value corresponding to the minimum value of the function on the (xmin,...Definition TF1.cxx:1823; TF1::GetMinimumvirtual Double_t GetMinimum(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the minimum value of the function on the (xmin, xmax) interval.Definition TF1.cxx:1696; TF1::GetXmaxvirtual Double_t GetXmax() constDefinition TF1.h:584; TF1::ReleaseParametervirtual void ReleaseParameter(Int_t ipar)Release parameter number ipar during a fit operation.Definition TF1.cxx:3151; TF1::SetParErrorvirtual void SetParError(Int_t ipar, Double_t error)Set error for parameter number ipar.Definition TF1.cxx:3479; TF1::RejectPointstatic void RejectPoint(Bool_t reject=kTRUE)Static function to set the global flag to reject points the fgRejectPoint global flag is tested by al...Definition TF1.cxx:3683; TF1::EAddToListEAddToListAdd to list behavior.Definition TF1.h:240; TF1::EAddToList::kDefault@ kDefault; TF1::EAddToList::kNo@ kNo; TF1::EAddToList::kAdd@ kAdd; TF1::Meanvirtual Double_t Mean(Double_t a, Double_t b, const Double_t *params=nullptr, Double_t epsilon=0.000001)Definition TF1.h:733; TF1::Derivativevirtual Double_t Derivative(Double_t x, Double_t *params=nullptr, Double_t epsilon=0.001) constReturns the first derivative of the function at point x, computed by Richardson's extrapolation metho...Definition TF1.cxx:1113; TF1::GetParErrorsvirtual const Double_t * GetParErrors() constDefinition TF1.h:566; TF1::GetNumbervirtual Int_t GetNumber() constDefinition TF1.h:526; TF1::GetNDFvirtual Int_t GetNDF() constReturn the number of degrees of freedom in the fit the fNDF parameter has been previously computed du...Definition TF1.cxx:1889; TF1::fParErrorsstd::vector< Doubl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8h_source.html:47346,test,tested,47346,doc/master/TF1_8h_source.html,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html,1,['test'],['tested']
Testability,"rRef->SetBufferOffset(0);; 373 Streamer(*fBufferRef); //write key itself again; 374 memcpy(fBuffer,fBufferRef->Buffer(),fKeylen);; 375 delete fBufferRef; fBufferRef = 0;; 376 } else {; 377 fBuffer = fBufferRef->Buffer();; 378 Create(fObjlen);; 379 fBufferRef->SetBufferOffset(0);; 380 Streamer(*fBufferRef); //write key itself again; 381 }; 382}; 383 ; 384////////////////////////////////////////////////////////////////////////////////; 385/// Method used in all TKey constructor to initialize basic data fields.; 386///; 387/// The member filepos is used to calculate correct version number of key; 388/// if filepos==-1, end of file position is used.; 389 ; 390void TKey::Build(TDirectory* motherDir, const char* classname, Long64_t filepos); 391{; 392 fMotherDir = motherDir;; 393 ; 394 fPidOffset = 0;; 395 fNbytes = 0;; 396 fBuffer = 0;; 397 fKeylen = 0;; 398 fObjlen = 0;; 399 fBufferRef = 0;; 400 fCycle = 0;; 401 fSeekPdir = 0;; 402 fSeekKey = 0;; 403 fLeft = 0;; 404 ; 405 fClassName = classname;; 406 //the following test required for forward and backward compatibility; 407 if (fClassName == ""TDirectoryFile"") SetBit(kIsDirectoryFile);; 408 ; 409 fVersion = TKey::Class_Version();; 410 ; 411 if ((filepos==-1) && GetFile()) filepos = GetFile()->GetEND();; 412 if (filepos > TFile::kStartBigFile) fVersion += 1000;; 413 ; 414 if (fTitle.Length() > kTitleMax) fTitle.Resize(kTitleMax);; 415 ; 416 if (GetFile() && GetFile()->TestBit(TFile::kReproducible)); 417 SetBit(TKey::kReproducible);; 418}; 419 ; 420////////////////////////////////////////////////////////////////////////////////; 421/// Read object from disk and call its Browse() method.; 422///; 423/// If object with same name already exist in memory delete it (like; 424/// TDirectoryFile::Get() is doing), except when the key references a; 425/// folder in which case we don't want to re-read the folder object; 426/// since it might contain new objects not yet saved.; 427 ; 428void TKey::Browse(TBrowser *b); 429{; 430 if (fMo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TKey_8cxx_source.html:14744,test,test,14744,doc/master/TKey_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html,1,['test'],['test']
Testability,"rSettings(settings);; 849 ptrSettings->setMonitoring (0);; 850 Log() << kINFO; 851 << ""Training with learning rate = "" << ptrSettings->learningRate (); 852 << "", momentum = "" << ptrSettings->momentum (); 853 << "", repetitions = "" << ptrSettings->repetitions (); 854 << Endl;; 855 ; 856 ptrSettings->setProgressLimits ((idxSetting)*100.0/(fSettings.size ()),; 857 (idxSetting+1)*100.0/(fSettings.size ()));; 858 ; 859 const std::vector<double>& dropConfig = ptrSettings->dropFractions ();; 860 if (!dropConfig.empty ()) {; 861 Log () << kINFO << ""Drop configuration"" << Endl; 862 << "" drop repetitions = "" << ptrSettings->dropRepetitions(); 863 << Endl;; 864 }; 865 ; 866 int idx = 0;; 867 for (auto f : dropConfig) {; 868 Log () << kINFO << "" Layer "" << idx << "" = "" << f << Endl;; 869 ++idx;; 870 }; 871 Log () << kINFO << Endl;; 872 ; 873 DNN::Steepest minimizer(ptrSettings->learningRate(),; 874 ptrSettings->momentum(),; 875 ptrSettings->repetitions());; 876 net.train(weights, trainPattern, testPattern, minimizer, *ptrSettings.get());; 877 ptrSettings.reset();; 878 Log () << kINFO << Endl;; 879 idxSetting++;; 880 }; 881 size_t weightIndex = 0;; 882 for (size_t l = 0; l < fNet.GetDepth(); l++) {; 883 auto & layerWeights = fNet.GetLayer(l).GetWeights();; 884 for (Int_t j = 0; j < layerWeights.GetNcols(); j++) {; 885 for (Int_t i = 0; i < layerWeights.GetNrows(); i++) {; 886 layerWeights(i,j) = weights[weightIndex];; 887 weightIndex++;; 888 }; 889 }; 890 auto & layerBiases = fNet.GetLayer(l).GetBiases();; 891 if (l == 0) {; 892 for (Int_t i = 0; i < layerBiases.GetNrows(); i++) {; 893 layerBiases(i,0) = weights[weightIndex];; 894 weightIndex++;; 895 }; 896 } else {; 897 for (Int_t i = 0; i < layerBiases.GetNrows(); i++) {; 898 layerBiases(i,0) = 0.0;; 899 }; 900 }; 901 }; 902 if (!fExitFromTraining) fIPyMaxIter = fIPyCurrentIter;; 903 ExitFromTraining();; 904}; 905 ; 906////////////////////////////////////////////////////////////////////////////////; 907 ; 908void TMVA::MethodDN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:31371,test,testPattern,31371,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['test'],['testPattern']
Testability,"rTarget&fFitterTargetthe fitter target; Double_tfLastResultremembers the last obtained result (for internal use); TMVA::MsgLogger*fLoggermessage logger; Bool_tfMakeCopiesif true, the population will make copies of the first individuals; Bool_tfMirrornew values for mutation are mirror-mapped if outside of constraints; TMVA::GeneticPopulationfPopulationcontains and controls the ""individual""; Int_tfPopulationSizethe size of the population; const vector<TMVA::Interval*>&fRangesparameter ranges; Double_tfSpreadregulates the spread of the value change at mutation (sigma); deque<Int_t>fSuccessListto adjust the stepSize . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GeneticAlgorithm(TMVA::IFitterTarget& target, Int_t populationSize, const vector<TMVA::Interval*>& ranges, UInt_t seed = 0); Constructor; Parameters:; int populationSize : defines the number of ""Individuals"" which are created and tested; within one Generation (Iteration of the Evolution); vector<TMVA::Interval*> ranges : Interval holds the information of an interval, where the GetMin; gets the low and GetMax gets the high constraint of the variable; the size of ""ranges"" is the number of coefficients which are optimised; Purpose:; Creates a random population with individuals of the size ranges.size(). ~GeneticAlgorithm(); destructor; deletes fLogger. void Init(); calls evolution, but if it is not the first time.; If it's the first time, the random population created by the; constructor is still not evaluated, .. therefore we wait for the; second time init is called. Double_t NewFitness(Double_t oldValue, Double_t newValue); if the ""fitnessFunction"" is called multiple times for one set of; factors (because i.e. each event of a TTree has to be assessed with; each set of Factors proposed by the Genetic Algorithm) the value; of the current calculation has to be added(? or else) to the value; obtained up to now.; example: some chi-square is calculated for every event,; afte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__GeneticAlgorithm.html:2486,test,tested,2486,root/html528/TMVA__GeneticAlgorithm.html,https://root.cern,https://root.cern/root/html528/TMVA__GeneticAlgorithm.html,3,['test'],['tested']
Testability,"rTesting.end(), DeleteFunctor<Event>() );; 1351 eventVectorTesting.erase(eventVectorTesting.begin()+requestedTesting,eventVectorTesting.end());; 1352 }; 1353 }; 1354 }; 1355 ; 1356 TMVA::DataSetFactory::RenormEvents( dsi, tmpEventVector, eventCounts, normMode );; 1357 ; 1358 Int_t trainingSize = 0;; 1359 Int_t testingSize = 0;; 1360 ; 1361 // sum up number of training and testing events; 1362 for( UInt_t cls = 0; cls < dsi.GetNClasses(); ++cls ){; 1363 trainingSize += tmpEventVector[Types::kTraining].at(cls).size();; 1364 testingSize += tmpEventVector[Types::kTesting].at(cls).size();; 1365 }; 1366 ; 1367 // --- collect all training (testing) events into the training (testing) eventvector; 1368 ; 1369 // create event vectors reserve enough space; 1370 EventVector* trainingEventVector = new EventVector();; 1371 EventVector* testingEventVector = new EventVector();; 1372 ; 1373 trainingEventVector->reserve( trainingSize );; 1374 testingEventVector->reserve( testingSize );; 1375 ; 1376 ; 1377 // collect the events; 1378 ; 1379 // mixing of kTraining and kTesting data sets; 1380 Log() << kDEBUG << "" MIXING ============= "" << Endl;; 1381 ; 1382 if( mixMode == ""ALTERNATE"" ){; 1383 // Inform user if he tries to use alternate mixmode for; 1384 // event classes with different number of events, this works but the alternation stops at the last event of the smaller class; 1385 for( UInt_t cls = 1; cls < dsi.GetNClasses(); ++cls ){; 1386 if (tmpEventVector[Types::kTraining].at(cls).size() != tmpEventVector[Types::kTraining].at(0).size()){; 1387 Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""Training sample: You are trying to mix events in alternate mode although the classes have different event numbers. This works but the alternation stops at the last event of the smaller class.""<<Endl;; 1388 }; 1389 if (tmpEventVector[Types::kTesting].at(cls).size() != tmpEventVector[Types::kTesting].at(0).size()){; 1390 Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""Testi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataSetFactory_8cxx_source.html:61304,test,testing,61304,doc/master/DataSetFactory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html,5,['test'],"['testing', 'testingEventVector', 'testingSize']"
Testability,"rType );; 527 assert( !fData.empty() && fDataPtr );; 528 assert( fDataErrorHigh.empty() && !fDataErrorHighPtr );; 529 assert( fDataErrorLow.empty() && !fDataErrorLowPtr );; 530 assert( !fDataError.empty() && fDataErrorPtr );; 531 assert( fCoordErrors.empty() && fCoordErrorsPtr.empty() );; 532 ; 533 fData[ fNPoints ] = val;; 534 fDataError[ fNPoints ] = (eval != 0.0) ? 1.0/eval : 0.0;; 535 ; 536 FitData::Add( x );; 537 fSumContent += val;; 538 if (val != 0 || eval != 1.0) fSumError2 += eval*eval;; 539 if (!fIsWeighted); 540 if (val != 0 && std::abs( eval*eval/val - 1.0) > 1.E-12) fIsWeighted = true;; 541 }; 542 ; 543 /**; 544 add multi-dim coordinate data with both error in coordinates and value; 545 */; 546 void BinData::Add( const double* x, double val, const double* ex, double eval ); 547 {; 548 assert( kCoordError == fErrorType );; 549 assert( !fData.empty() && fDataPtr );; 550 assert( !fDataError.empty() && fDataErrorPtr );; 551 assert( fDataErrorHigh.empty() && !fDataErrorHighPtr );; 552 assert( fDataErrorLow.empty() && !fDataErrorLowPtr );; 553 assert( fCoordErrors.size() == fDim );; 554 assert( fCoordErrorsPtr.size() == fDim );; 555 ; 556 fData[ fNPoints ] = val;; 557 ; 558 for( unsigned int i=0; i<fDim; i++ ); 559 {; 560 assert( &fCoordErrors[i].front() == fCoordErrorsPtr[i] );; 561 ; 562 fCoordErrors[i][ fNPoints ] = ex[i];; 563 }; 564 // in this case we store the y error and not the inverse; 565 fDataError[ fNPoints ] = eval;; 566 ; 567 FitData::Add( x );; 568 fSumContent += val;; 569 if (val != 0 || eval != 1.0) fSumError2 += eval*eval;; 570 if (!fIsWeighted); 571 if (val != 0 && std::abs( eval*eval/val - 1.0) > 1.E-12) fIsWeighted = true;; 572 }; 573 ; 574 /**; 575 add multi-dim coordinate data with both error in coordinates and value; 576 */; 577 void BinData::Add( const double* x, double val, const double* ex, double elval, double ehval ); 578 {; 579 assert( kAsymError == fErrorType );; 580 ; 581 assert( !fData.empty() && fDataPtr );; 582 assert( !fDat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:17041,assert,assert,17041,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['assert'],['assert']
Testability,"rValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tmaxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCBShape.html:22186,test,testArg,22186,root/html534/RooCBShape.html,https://root.cern,https://root.cern/root/html534/RooCBShape.html,4,['test'],['testArg']
Testability,"rValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tmaxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCBShape&operator=(const RooCBShape&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCBShape.html:21970,test,testArg,21970,root/html602/RooCBShape.html,https://root.cern,https://root.cern/root/html602/RooCBShape.html,2,['test'],['testArg']
Testability,"rValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tmaxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooFFTConvPdf&operator=(const RooFFTConvPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinke",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFFTConvPdf.html:26886,test,testArg,26886,root/html602/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html602/RooFFTConvPdf.html,2,['test'],['testArg']
Testability,"rValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tmaxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooHistPdf&operator=(const RooHistPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooHistPdf.html:22228,test,testArg,22228,root/html602/RooHistPdf.html,https://root.cern,https://root.cern/root/html602/RooHistPdf.html,2,['test'],['testArg']
Testability,"rValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tmaxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooKeysPdf&operator=(const RooKeysPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooKeysPdf.html:22690,test,testArg,22690,root/html602/RooKeysPdf.html,https://root.cern,https://root.cern/root/html602/RooKeysPdf.html,2,['test'],['testArg']
Testability,"r_t * RooAbsArg::makeLegacyIterator ; (; const RefCountList_t & ; list); const. private . Definition at line 2464 of file RooAbsArg.cxx. ◆ namePtr(). const TNamed * RooAbsArg::namePtr ; (; ); const. inline . De-duplicated pointer to this object's name. ; This can be used for fast name comparisons. like if (namePtr() == other.namePtr()). NoteTNamed::GetName() will return a pointer that's different for each object, but namePtr() always points to a unique instance. ; Definition at line 535 of file RooAbsArg.h. ◆ numCaches(). Int_t RooAbsArg::numCaches ; (; ); const. Return number of registered caches. ; Definition at line 2136 of file RooAbsArg.cxx. ◆ numProxies(). Int_t RooAbsArg::numProxies ; (; ); const. Return the number of registered proxies. ; Definition at line 1457 of file RooAbsArg.cxx. ◆ observableOverlaps() [1/2]. bool RooAbsArg::observableOverlaps ; (; const RooAbsData * ; dset, . const RooAbsArg & ; testArg . ); const. Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ; Definition at line 914 of file RooAbsArg.cxx. ◆ observableOverlaps() [2/2]. bool RooAbsArg::observableOverlaps ; (; const RooArgSet * ; depList, . const RooAbsArg & ; testArg . ); const. Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ; Definition at line 924 of file RooAbsArg.cxx. ◆ operator=(). RooAbsArg & RooAbsArg::operator= ; (; const RooAbsArg & ; other). delete . ◆ operator==(). virtual bool RooAbsArg::operator== ; (; const RooAbsArg & ; other); const. pure virtual . Implemented in RooAbsCategory, RooAbsReal, and RooStringVar. ◆ operMode(). OperMode RooAbsArg::operMode ; (; ); const. inline . Query the operation mode of this node. ; Definition at line 456 of file RooAbsArg.h. ◆ operModeHook(). virtual void RooAbsArg::operModeHook ; (; ). inlineprotectedvirtual . Reimplemented in RooCachedReal, and RooGenProdProj.; Definition at line 562 of file RooAbsA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:76971,test,testArg,76971,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['test'],['testArg']
Testability,"r_t dict = gClassTable->GetDict(proto->GetName());; 1782 if (!dict) {; 1783 ::Error(""TCling::LoadPCM"", ""Inconsistent TClassTable for %s"", proto->GetName());; 1784 } else {; 1785 // This will replace the existing TClass.; 1786 TClass *ncl = (*dict)();; 1787 if (ncl); 1788 ncl->PostLoadCheck();; 1789 }; 1790 }; 1791 }; 1792 }; 1793 ; 1794 protoClasses->Clear(); // Ownership was transfered to TClassTable.; 1795 delete protoClasses;; 1796 }; 1797 ; 1798 TObjArray *dataTypes;; 1799 pcmFile.GetObject(""__Typedefs"", dataTypes);; 1800 if (dataTypes) {; 1801 for (auto typedf : *dataTypes); 1802 gROOT->GetListOfTypes()->Add(typedf);; 1803 dataTypes->Clear(); // Ownership was transfered to TListOfTypes.; 1804 delete dataTypes;; 1805 }; 1806}; 1807 ; 1808////////////////////////////////////////////////////////////////////////////////; 1809/// Tries to load a rdict PCM, issues diagnostics if it fails.; 1810 ; 1811void TCling::LoadPCM(std::string pcmFileNameFullPath); 1812{; 1813 SuspendAutoLoadingRAII autoloadOff(this);; 1814 SuspendAutoParsing autoparseOff(this);; 1815 assert(!pcmFileNameFullPath.empty());; 1816 assert(llvm::sys::path::is_absolute(pcmFileNameFullPath));; 1817 ; 1818 // Easier to work with the ROOT interfaces.; 1819 TString pcmFileName = pcmFileNameFullPath;; 1820 ; 1821 // Prevent the ROOT-PCMs hitting this during auto-load during; 1822 // JITting - which will cause recursive compilation.; 1823 // Avoid to call the plugin manager at all.; 1824 R__InitStreamerInfoFactory();; 1825 ; 1826 TDirectory::TContext ctxt;; 1827 llvm::SaveAndRestore<Int_t> SaveGDebug(gDebug);; 1828 if (gDebug > 5) {; 1829 gDebug -= 5;; 1830 ::Info(""TCling::LoadPCM"", ""Loading ROOT PCM %s"", pcmFileName.Data());; 1831 } else {; 1832 gDebug = 0;; 1833 }; 1834 ; 1835 if (llvm::sys::fs::is_symlink_file(pcmFileNameFullPath)); 1836 pcmFileNameFullPath = ROOT::TMetaUtils::GetRealPath(pcmFileNameFullPath);; 1837 ; 1838 auto pendingRdict = fPendingRdicts.find(pcmFileNameFullPath);; 1839 if (pendingRdi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:68220,assert,assert,68220,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['assert'],['assert']
Testability,"ra instead.; [legend]; Member Enumeration Documentation. ◆ EQueryStatus. enum TQueryResult::EQueryStatus. EnumeratorkAborted ; kSubmitted ; kRunning ; kStopped ; kCompleted . Definition at line 52 of file TQueryResult.h. Constructor & Destructor Documentation. ◆ TQueryResult() [1/2]. TQueryResult::TQueryResult ; (; Int_t ; seqnum, . const char * ; opt, . TList * ; inlist, . Long64_t ; entries, . Long64_t ; first, . const char * ; selec . ). protected . Main constructor. ; Definition at line 37 of file TQueryResult.cxx. ◆ TQueryResult() [2/2]. TQueryResult::TQueryResult ; (; ). inline . Definition at line 109 of file TQueryResult.h. ◆ ~TQueryResult(). TQueryResult::~TQueryResult ; (; ). override . Destructor. ; Definition at line 109 of file TQueryResult.cxx. Member Function Documentation. ◆ AddInput(). void TQueryResult::AddInput ; (; TObject * ; obj). protected . Add obj to the input list. ; Definition at line 294 of file TQueryResult.cxx. ◆ AddLogLine(). void TQueryResult::AddLogLine ; (; const char * ; logline). protected . Fill log file. ; Definition at line 285 of file TQueryResult.cxx. ◆ Browse(). void TQueryResult::Browse ; (; TBrowser * ; b = nullptr). overridevirtual . To support browsing of the results. ; Reimplemented from TObject.; Definition at line 419 of file TQueryResult.cxx. ◆ Class(). static TClass * TQueryResult::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TQueryResult::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TQueryResult::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 156 of file TQueryResult.h. ◆ CloneInfo(). TQueryResult * TQueryResult::CloneInfo ; (; ). protected . Return an instance of TQueryResult containing only the local info fields, i.e. ; no outputlist, liblist, dset, selectors, etc.. Used for fast retrieve of information about existing queries and their status. ; Definition a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQueryResult.html:16635,log,logline,16635,doc/master/classTQueryResult.html,https://root.cern,https://root.cern/doc/master/classTQueryResult.html,1,['log'],['logline']
Testability,"racks=1000000, Double_t radius=-1.);  Check pushes and pulls needed to cross the next boundary with respect to the position given by FindNextBoundary. ;  ; void CheckBoundaryReference (Int_t icheck=-1);  Check the boundary errors reference file created by CheckBoundaryErrors method. ;  ; void CheckGeometry (Option_t *option="""");  Perform last checks on the geometry. ;  ; void CheckGeometryFull (Int_t ntracks=1000000, Double_t vx=0., Double_t vy=0., Double_t vz=0., Option_t *option=""ob"");  Geometry checking. ;  ; void CheckOverlaps (Double_t ovlp=0.1, Option_t *option="""");  Check all geometry for illegal overlaps within a limit OVLP. ;  ; Bool_t CheckPath (const char *path) const;  Check if a geometry path is valid without changing the state of the current navigator. ;  ; void CheckPoint (Double_t x=0, Double_t y=0, Double_t z=0, Option_t *option="""", Double_t safety=0.);  Classify a given point. See TGeoChecker::CheckPoint(). ;  ; void CheckShape (TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option);  Test for shape navigation methods. ;  ; void CleanGarbage ();  Clean temporary volumes and shapes from garbage collection. ;  ; void ClearAttributes ();  Reset all attributes to default ones. ;  ; void ClearNavigators ();  Clear all navigators. ;  ; void ClearOverlaps ();  Clear the list of overlaps. ;  ; void ClearPhysicalNodes (Bool_t mustdelete=kFALSE);  Clear the current list of physical nodes, so that we can start over with a new list. ;  ; void ClearShape (const TGeoShape *shape);  Remove a shape from the list of shapes. ;  ; void ClearThreadData () const;  ; void ClearTracks ();  ; void CloseGeometry (Option_t *option=""d"");  Closing geometry implies checking the geometry validity, fixing shapes with negative parameters (run-time shapes)building the cache manager, voxelizing all volumes, counting the total number of physical nodes and registering the manager class to the browser. ;  ; void ConvertReflections ();  Convert all reflections in geometry to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:23549,test,testNo,23549,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['test'],['testNo']
Testability,racle;  ► inc;  LinkDef.h;  TOracleResult.h;  TOracleRow.h;  TOracleServer.h;  TOracleStatement.h;  ► src;  TOracleResult.cxx;  TOracleRow.cxx;  TOracleServer.cxx;  TOracleStatement.cxx;  ► pgsql;  ► inc;  LinkDef.h;  TPgSQLResult.h;  TPgSQLRow.h;  TPgSQLServer.h;  TPgSQLStatement.h;  ► src;  TPgSQLResult.cxx;  TPgSQLRow.cxx;  TPgSQLServer.cxx;  TPgSQLStatement.cxx;  ► sapdb;  ► inc;  LinkDef.h;  TSapDBResult.h;  TSapDBRow.h;  TSapDBServer.h;  ► src;  TSapDBResult.cxx;  TSapDBRow.cxx;  TSapDBServer.cxx;  ► sqlite;  ► inc;  LinkDef.h;  TSQLiteResult.h;  TSQLiteRow.h;  TSQLiteServer.h;  TSQLiteStatement.h;  ► src;  TSQLiteResult.cxx;  TSQLiteRow.cxx;  TSQLiteServer.cxx;  TSQLiteStatement.cxx;  ► tmva;  ► pymva;  ► inc;  ► TMVA;  MethodPyAdaBoost.h;  MethodPyGTB.h;  MethodPyKeras.h;  MethodPyRandomForest.h;  PyMethodBase.h;  LinkDef.h;  ► src;  MethodPyAdaBoost.cxx;  MethodPyGTB.cxx;  MethodPyKeras.cxx;  MethodPyRandomForest.cxx;  PyMethodBase.cxx;  ► test;  Classification.C;  testPyKerasClassification.C;  testPyKerasRegression.C;  ► rmva;  ► inc;  ► TMVA;  MethodC50.h;  MethodRSNNS.h;  MethodRSVM.h;  MethodRXGB.h;  RMethodBase.h;  LinkDef.h;  ► src;  MethodC50.cxx;  MethodRSNNS.cxx;  MethodRSVM.cxx;  MethodRXGB.cxx;  RMethodBase.cxx;  ► test;  Classification.C;  ► tmva;  ► inc;  ► TMVA;  ► DNN;  ► Architectures;  ► Cpu;  Blas.h;  CpuBuffer.h;  CpuMatrix.h;  ► Cuda;  CudaBuffers.h;  CudaMatrix.h;  Device.h;  Cpu.h;  Cuda.h;  Reference.h;  DataLoader.h;  Functions.h;  Layer.h;  Minimizers.h;  Net.h;  BDTEventWrapper.h;  BinarySearchTree.h;  BinarySearchTreeNode.h;  BinaryTree.h;  CCPruner.h;  CCTreeWrapper.h;  ClassifierFactory.h;  ClassInfo.h;  Config.h;  Configurable.h;  ConvergenceTest.h;  CostComplexityPruneTool.h;  CrossEntropy.h;  CrossValidation.h;  DataInputHandler.h;  DataLoader.h;  DataSet.h;  DataSetFactory.h;  DataSetInfo.h;  DataSetManager.h;  DecisionTree.h;  DecisionTreeNode.h;  Envelope.h;  Event.h;  ExpectedErrorPruneTool.h;  Factory.h;  FitterBase.h;  ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:87083,test,testPyKerasClassification,87083,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,1,['test'],['testPyKerasClassification']
Testability,rac{1.}{\pi}\f$; 65constexpr Double_t InvPi(); 66{; 67 return 1.0 / Pi();; 68}; 69 ; 70////////////////////////////////////////////////////////////////////////////////; 71/// Conversion from radian to degree: \f$ \frac{180}{\pi} \f$; 72constexpr Double_t RadToDeg(); 73{; 74 return 180.0 / Pi();; 75}; 76 ; 77////////////////////////////////////////////////////////////////////////////////; 78/// Conversion from degree to radian: \f$ \frac{\pi}{180} \f$; 79constexpr Double_t DegToRad(); 80{; 81 return Pi() / 180.0;; 82}; 83 ; 84////////////////////////////////////////////////////////////////////////////////; 85/// \f$ \sqrt{2} \f$; 86constexpr Double_t Sqrt2(); 87{; 88 return 1.4142135623730950488016887242097;; 89}; 90 ; 91////////////////////////////////////////////////////////////////////////////////; 92/// Base of natural log: \f$ e \f$; 93constexpr Double_t E(); 94{; 95 return 2.71828182845904523536;; 96}; 97 ; 98////////////////////////////////////////////////////////////////////////////////; 99/// Natural log of 10 (to convert log to ln); 100constexpr Double_t Ln10(); 101{; 102 return 2.30258509299404568402;; 103}; 104 ; 105////////////////////////////////////////////////////////////////////////////////; 106/// Base-10 log of e (to convert ln to log); 107constexpr Double_t LogE(); 108{; 109 return 0.43429448190325182765;; 110}; 111 ; 112////////////////////////////////////////////////////////////////////////////////; 113/// Velocity of light in \f$ m s^{-1} \f$; 114constexpr Double_t C(); 115{; 116 return 2.99792458e8;; 117}; 118 ; 119////////////////////////////////////////////////////////////////////////////////; 120/// \f$ cm s^{-1} \f$; 121constexpr Double_t Ccgs(); 122{; 123 return 100.0 * C();; 124}; 125 ; 126////////////////////////////////////////////////////////////////////////////////; 127/// Speed of light uncertainty.; 128constexpr Double_t CUncertainty(); 129{; 130 return 0.0;; 131}; 132 ; 133//////////////////////////////////////////////////////////,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8h_source.html:3075,log,log,3075,doc/master/TMath_8h_source.html,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html,2,['log'],['log']
Testability,rac{180}{\pi} \f$; 72constexpr Double_t RadToDeg(); 73{; 74 return 180.0 / Pi();; 75}; 76 ; 77////////////////////////////////////////////////////////////////////////////////; 78/// Conversion from degree to radian: \f$ \frac{\pi}{180} \f$; 79constexpr Double_t DegToRad(); 80{; 81 return Pi() / 180.0;; 82}; 83 ; 84////////////////////////////////////////////////////////////////////////////////; 85/// \f$ \sqrt{2} \f$; 86constexpr Double_t Sqrt2(); 87{; 88 return 1.4142135623730950488016887242097;; 89}; 90 ; 91////////////////////////////////////////////////////////////////////////////////; 92/// Base of natural log: \f$ e \f$; 93constexpr Double_t E(); 94{; 95 return 2.71828182845904523536;; 96}; 97 ; 98////////////////////////////////////////////////////////////////////////////////; 99/// Natural log of 10 (to convert log to ln); 100constexpr Double_t Ln10(); 101{; 102 return 2.30258509299404568402;; 103}; 104 ; 105////////////////////////////////////////////////////////////////////////////////; 106/// Base-10 log of e (to convert ln to log); 107constexpr Double_t LogE(); 108{; 109 return 0.43429448190325182765;; 110}; 111 ; 112////////////////////////////////////////////////////////////////////////////////; 113/// Velocity of light in \f$ m s^{-1} \f$; 114constexpr Double_t C(); 115{; 116 return 2.99792458e8;; 117}; 118 ; 119////////////////////////////////////////////////////////////////////////////////; 120/// \f$ cm s^{-1} \f$; 121constexpr Double_t Ccgs(); 122{; 123 return 100.0 * C();; 124}; 125 ; 126////////////////////////////////////////////////////////////////////////////////; 127/// Speed of light uncertainty.; 128constexpr Double_t CUncertainty(); 129{; 130 return 0.0;; 131}; 132 ; 133////////////////////////////////////////////////////////////////////////////////; 134/// Gravitational constant in: \f$ m^{3} kg^{-1} s^{-2} \f$; 135constexpr Double_t G(); 136{; 137 // use 2018 value from NIST (https://physics.nist.gov/cgi-bin/cuu/Value?bg|search_for=G); 1,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8h_source.html:3293,log,log,3293,doc/master/TMath_8h_source.html,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html,2,['log'],['log']
Testability,"raining data into training and validation set; 1140 const std::vector<Event *> &allData = GetEventCollection(Types::kTraining);; 1141 const std::vector<Event *> trainingInputData =; 1142 std::vector<Event *>(allData.begin(), allData.begin() + nTrainingSamples);; 1143 const std::vector<Event *> testInputData =; 1144 std::vector<Event *>(allData.begin() + nTrainingSamples, allData.end());; 1145 ; 1146 if (trainingInputData.size() != nTrainingSamples) {; 1147 Log() << kFATAL << ""Inconsistent training sample size"" << Endl;; 1148 }; 1149 if (testInputData.size() != nTestSamples) {; 1150 Log() << kFATAL << ""Inconsistent test sample size"" << Endl;; 1151 }; 1152 ; 1153 size_t nThreads = 1;; 1154 TMVAInput_t trainingTuple = std::tie(trainingInputData, DataInfo());; 1155 TMVAInput_t testTuple = std::tie(testInputData, DataInfo());; 1156 DataLoader_t trainingData(trainingTuple, nTrainingSamples,; 1157 net.GetBatchSize(), net.GetInputWidth(),; 1158 net.GetOutputWidth(), nThreads);; 1159 DataLoader_t testData(testTuple, nTestSamples, testNet.GetBatchSize(),; 1160 net.GetInputWidth(), net.GetOutputWidth(),; 1161 nThreads);; 1162 DNN::TGradientDescent<TCpu<>> minimizer(settings.learningRate,; 1163 settings.convergenceSteps,; 1164 settings.testInterval);; 1165 ; 1166 std::vector<TNet<TCpu<>>> nets{};; 1167 std::vector<TBatch<TCpu<>>> batches{};; 1168 nets.reserve(nThreads);; 1169 for (size_t i = 0; i < nThreads; i++) {; 1170 nets.push_back(net);; 1171 for (size_t j = 0; j < net.GetDepth(); j++); 1172 {; 1173 auto &masterLayer = net.GetLayer(j);; 1174 auto &layer = nets.back().GetLayer(j);; 1175 TCpu<>::Copy(layer.GetWeights(),; 1176 masterLayer.GetWeights());; 1177 TCpu<>::Copy(layer.GetBiases(),; 1178 masterLayer.GetBiases());; 1179 }; 1180 }; 1181 ; 1182 bool converged = false;; 1183 size_t stepCount = 0;; 1184 size_t batchesInEpoch = nTrainingSamples / net.GetBatchSize();; 1185 ; 1186 std::chrono::time_point<std::chrono::system_clock> start, end;; 1187 start = std::chrono::syste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:41895,test,testData,41895,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,3,['test'],"['testData', 'testNet', 'testTuple']"
Testability,"ral returned; 361/// by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; 362/// to return a normalized answer.; 363 ; 364double RooAbsPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName) const; 365{; 366 cxcoutD(Eval) << ""RooAbsPdf::analyticalIntegralWN("" << GetName() << "") code = "" << code << "" normset = "" << (normSet?*normSet:RooArgSet()) << endl ;; 367 ; 368 ; 369 if (code==0) return getVal(normSet) ;; 370 if (normSet) {; 371 return analyticalIntegral(code,rangeName) / getNorm(normSet) ;; 372 } else {; 373 return analyticalIntegral(code,rangeName) ;; 374 }; 375}; 376 ; 377 ; 378 ; 379////////////////////////////////////////////////////////////////////////////////; 380/// Check that passed value is positive and not 'not-a-number'. If; 381/// not, print an error, until the error counter reaches its set; 382/// maximum.; 383 ; 384bool RooAbsPdf::traceEvalPdf(double value) const; 385{; 386 // check for a math error or negative value; 387 bool error(false) ;; 388 if (TMath::IsNaN(value)) {; 389 logEvalError(Form(""p.d.f value is Not-a-Number (%f), forcing value to zero"",value)) ;; 390 error=true ;; 391 }; 392 if (value<0) {; 393 logEvalError(Form(""p.d.f value is less than zero (%f), forcing value to zero"",value)) ;; 394 error=true ;; 395 }; 396 ; 397 // do nothing if we are no longer tracing evaluations and there was no error; 398 if(!error) return error ;; 399 ; 400 // otherwise, print out this evaluations input values and result; 401 if(++_errorCount <= 10) {; 402 cxcoutD(Tracing) << ""*** Evaluation Error "" << _errorCount << "" "";; 403 if(_errorCount == 10) cxcoutD(Tracing) << ""(no more will be printed) "";; 404 }; 405 else {; 406 return error ;; 407 }; 408 ; 409 Print() ;; 410 return error ;; 411}; 412 ; 413 ; 414////////////////////////////////////////////////////////////////////////////////; 415/// Get normalisation term needed to normalise the raw values returned by; 416/// getVal(). Note that `g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:14502,log,logEvalError,14502,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['log'],['logEvalError']
Testability,"ral, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction1PdfBinding<double,int>&operator=(const RooCFunction1PdfBinding<double,int>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction1PdfBinding_double_int_.html:23698,test,testArg,23698,root/html602/RooCFunction1PdfBinding_double_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction1PdfBinding_double_int_.html,2,['test'],['testArg']
Testability,"rallelCoordVar::SetHistogramBinning ; (; Int_t ; n = 100). Set the histogram binning. ; Definition at line 882 of file TParallelCoordVar.cxx. ◆ SetHistogramHeight(). void TParallelCoordVar::SetHistogramHeight ; (; Double_t ; h = 0). Set the height of the bar histogram. ; Definition at line 892 of file TParallelCoordVar.cxx. ◆ SetHistogramLineWidth(). void TParallelCoordVar::SetHistogramLineWidth ; (; Int_t ; lw = 2). inline . Definition at line 101 of file TParallelCoordVar.h. ◆ SetInitMax(). void TParallelCoordVar::SetInitMax ; (; Double_t ; max). inline . Definition at line 108 of file TParallelCoordVar.h. ◆ SetInitMin(). void TParallelCoordVar::SetInitMin ; (; Double_t ; min). inline . Definition at line 107 of file TParallelCoordVar.h. ◆ SetLiveRangesUpdate(). void TParallelCoordVar::SetLiveRangesUpdate ; (; bool ; on). If true, the pad is updated while the motion of a dragged range. ; Definition at line 945 of file TParallelCoordVar.cxx. ◆ SetLogScale(). void TParallelCoordVar::SetLogScale ; (; bool ; log). Set the axis in log scale. ; Definition at line 955 of file TParallelCoordVar.cxx. ◆ SetTitle(). void TParallelCoordVar::SetTitle ; (; const char * ; title). inlineoverridevirtual . Set the title of the TNamed. ; Reimplemented from TNamed.; Definition at line 111 of file TParallelCoordVar.h. ◆ SetValues(). void TParallelCoordVar::SetValues ; (; Long64_t ; length, . Double_t * ; val . ). Set the variable values. ; Definition at line 977 of file TParallelCoordVar.cxx. ◆ SetX(). void TParallelCoordVar::SetX ; (; Double_t ; x, . bool ; gl . ). Set the X position of the axis in the case of a vertical axis. ; and rotate the axis if it was horizontal. ; Definition at line 992 of file TParallelCoordVar.cxx. ◆ SetY(). void TParallelCoordVar::SetY ; (; Double_t ; y, . bool ; gl . ). Set the Y position of the axis in the case of a horizontal axis. ; and rotate the axis if it was vertical. ; Definition at line 1011 of file TParallelCoordVar.cxx. ◆ Streamer(). void TPara",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTParallelCoordVar.html:29949,log,log,29949,doc/master/classTParallelCoordVar.html,https://root.cern,https://root.cern/doc/master/classTParallelCoordVar.html,1,['log'],['log']
Testability,ram class; TProfile3D Profile3D histogram class; TProof PROOF control class; TProofChain TChain proxy for running chains on PROOF; TProofCondor PROOF control class for slaves allocated by condor; TProofDebug ; TProofDesc Small class describing a proof session; TProofDraw Tree drawing selector for PROOF; TProofDrawEntryList A Selectoor to fill a TEntryList from TTree::Draw; TProofDrawEventList Tree drawing selector for PROOF; TProofDrawGraph Tree drawing selector for PROOF; TProofDrawHist Tree drawing selector for PROOF; TProofDrawListOfGraphs Tree drawing selector for PROOF; TProofDrawListOfGraphs::Point3D_t ; TProofDrawListOfPolyMarkers3D Tree drawing selector for PROOF; TProofDrawListOfPolyMarkers3D::Point4D_t ; TProofDrawPolyMarker3D Tree drawing selector for PROOF; TProofDrawProfile Tree drawing selector for PROOF; TProofDrawProfile2D Tree drawing selector for PROOF; TProofLimitsFinder Find and communicate best axis limits; TProofLite PROOF control class; TProofLog PROOF session log handler; TProofLogElem PROOF session log element; TProofMgr Abstract PROOF manager interface; TProofMgrLite XrdProofd PROOF manager interface; TProofNodeInfo Class describing a PROOF node; TProofOutputFile Wrapper class to steer the merging of files produced on workers; TProofPlayer Basic PROOF player; TProofPlayerLite PROOF player running in PROOF-Lite; TProofPlayerLocal PROOF player running on client; TProofPlayerRemote PROOF player running on master server; TProofPlayerSlave PROOF player running on slave server; TProofPlayerSuperMaster PROOF player running on super master; TProofProgressDialog PROOF progress dialog; TProofProgressInfo Progress information; TProofProgressLog Class implementing a log graphic box; TProofProgressMemoryPlot PROOF progress memory plots; TProofProgressStatus Proof progress status class; TProofQueryResult Class describing a PROOF query; TProofResources Abstract class describing PROOF resources; TProofResourcesStatic Class to handle PROOF static config; TP,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ClassIndex.html:111011,log,log,111011,root/html526/ClassIndex.html,https://root.cern,https://root.cern/root/html526/ClassIndex.html,1,['log'],['log']
Testability,ram class; TProfile3D Profile3D histogram class; TProof PROOF control class; TProofChain TChain proxy for running chains on PROOF; TProofCondor PROOF control class for slaves allocated by condor; TProofDebug ; TProofDesc Small class describing a proof session; TProofDraw Tree drawing selector for PROOF; TProofDrawEntryList A Selectoor to fill a TEntryList from TTree::Draw; TProofDrawEventList Tree drawing selector for PROOF; TProofDrawGraph Tree drawing selector for PROOF; TProofDrawHist Tree drawing selector for PROOF; TProofDrawListOfGraphs Tree drawing selector for PROOF; TProofDrawListOfGraphs::Point3D_t ; TProofDrawListOfPolyMarkers3D Tree drawing selector for PROOF; TProofDrawListOfPolyMarkers3D::Point4D_t ; TProofDrawPolyMarker3D Tree drawing selector for PROOF; TProofDrawProfile Tree drawing selector for PROOF; TProofDrawProfile2D Tree drawing selector for PROOF; TProofLimitsFinder Find and communicate best axis limits; TProofLite PROOF control class; TProofLog PROOF session log handler; TProofLogElem PROOF session log element; TProofMgr Abstract PROOF manager interface; TProofMgrLite XrdProofd PROOF manager interface; TProofNodeInfo Class describing a PROOF node; TProofOutputFile Wrapper class to steer the merging of files produced on workers; TProofPlayer Basic PROOF player; TProofPlayerLite PROOF player running in PROOF-Lite; TProofPlayerLocal PROOF player running on client; TProofPlayerRemote PROOF player running on master server; TProofPlayerSlave PROOF player running on slave server; TProofPlayerSuperMaster PROOF player running on super master; TProofProgressDialog PROOF progress dialog; TProofProgressLog Class implementing a log graphic box; TProofProgressMemoryPlot PROOF progress memory plots; TProofProgressStatus Proof progress status class; TProofQueryResult Class describing a PROOF query; TProofResources Abstract class describing PROOF resources; TProofResourcesStatic Class to handle PROOF static config; TProofServ PROOF Server Application Interfa,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:109065,log,log,109065,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,1,['log'],['log']
Testability,"ramFunction.h:108; double; xDouble_t x[n]Definition legend1.C:17; HFit::FitTFitResultPtr Fit(FitObject *h1, TF1 *f1, Foption_t &option, const ROOT::Math::MinimizerOptions &moption, const char *goption, ROOT::Fit::DataRange &range)Definition HFitImpl.cxx:133; ROOT::Fit::PoissonLLGradFunctionPoissonLikelihoodFCN< ROOT::Math::IMultiGradFunction, ROOT::Math::IParamMultiFunction > PoissonLLGradFunctionDefinition PoissonLikelihoodFCN.h:215; ROOT::Fit::PoissonLLFunctionPoissonLikelihoodFCN< ROOT::Math::IMultiGenFunction, ROOT::Math::IParamMultiFunction > PoissonLLFunctionDefinition PoissonLikelihoodFCN.h:214; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::EExecutionPolicyEExecutionPolicyDefinition EExecutionPolicy.hxx:5; ROOT::EExecutionPolicy::kSequential@ kSequential; ROOT::Fit::FitUtil::Evaluate::EvalPoissonBinPdfstatic double EvalPoissonBinPdf(const IModelFunctionTempl< double > &func, const BinData &data, const double *p, unsigned int i, double *g, double *h, bool hasGrad, bool fullHessian)evaluate the pdf (Poisson) contribution to the logl (return actually log of pdf) and its gradientDefinition FitUtil.h:1447; ROOT::Fit::FitUtil::Evaluate::EvalPoissonLogLGradientstatic void EvalPoissonLogLGradient(const IModelFunctionTempl< double > &func, const BinData &data, const double *p, double *g, unsigned int &nPoints, ::ROOT::EExecutionPolicy executionPolicy=::ROOT::EExecutionPolicy::kSequential, unsigned nChunks=0)Definition FitUtil.h:1456; ROOT::Fit::FitUtil::Evaluate::EvalPoissonLogLstatic double EvalPoissonLogL(const IModelFunctionTempl< double > &func, const BinData &data, const double *p, int iWeight, bool extended, unsigned int &nPoints, ::ROOT::EExecutionPolicy executionPolicy, unsigned nChunks=0)Definition FitUtil.h:1420. mathmathcoreincFitPoissonLikelihoodFCN.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:40 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/PoissonLikelihoodFCN_8h_source.html:16118,log,logl,16118,doc/master/PoissonLikelihoodFCN_8h_source.html,https://root.cern,https://root.cern/doc/master/PoissonLikelihoodFCN_8h_source.html,2,['log'],"['log', 'logl']"
Testability,"rame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. TGCompositeFrame(TGClient* c, Window_t id, const TGWindow* parent = 0); TGCompositeFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = 0, Pixel_t back = GetDefaultFrameBackground()); virtual~TGCompositeFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidAddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidChangeOptions(UInt_t options); virtual voidChangeSubframesBackground(Pixel_t back); stat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGCompositeFrame.html:1364,log,logically,1364,root/html528/TGCompositeFrame.html,https://root.cern,https://root.cern/root/html528/TGCompositeFrame.html,4,['log'],['logically']
Testability,"rame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. TGFrame(TGClient* c, Window_t id, const TGWindow* parent = 0); TGFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = 0, Pixel_t back = GetDefaultFrameBackground()); virtual~TGFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidActivate(Bool_t); voidAddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGFrame.html:1355,log,logically,1355,root/html528/TGFrame.html,https://root.cern,https://root.cern/root/html528/TGFrame.html,4,['log'],['logically']
Testability,"rame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. TGGroupFrame(const TGWindow* p, TGString* title, UInt_t options = kVerticalFrame, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), Pixel_t back = GetDefaultFrameBackground()); TGGroupFrame(const TGWindow* p = 0, const char* title = 0, UInt_t options = kVerticalFrame, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), Pixel_t back = GetDefaultFrameBackground()); virtual~TGGroupFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGGroupFrame.html:1361,log,logically,1361,root/html528/TGGroupFrame.html,https://root.cern,https://root.cern/root/html528/TGGroupFrame.html,4,['log'],['logically']
Testability,"rame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. TGHeaderFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); ~TGHeaderFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGHeaderFrame.html:1365,log,logically,1365,root/html528/TGHeaderFrame.html,https://root.cern,https://root.cern/root/html528/TGHeaderFrame.html,4,['log'],['logically']
Testability,"rame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. TGHorizontalFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); ~TGHorizontalFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Cla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGHorizontalFrame.html:1376,log,logically,1376,root/html528/TGHorizontalFrame.html,https://root.cern,https://root.cern/root/html528/TGHorizontalFrame.html,4,['log'],['logically']
Testability,"rame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. TGMainFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kVerticalFrame); virtual~TGMainFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tBindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGMainFrame.html:1358,log,logically,1358,root/html528/TGMainFrame.html,https://root.cern,https://root.cern/root/html528/TGMainFrame.html,4,['log'],['logically']
Testability,"rame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. TGTransientFrame(const TGWindow* p = 0, const TGWindow* main = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kVerticalFrame); ~TGTransientFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidCenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGTransientFrame.html:1368,log,logically,1368,root/html528/TGTransientFrame.html,https://root.cern,https://root.cern/root/html528/TGTransientFrame.html,4,['log'],['logically']
Testability,"rame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. TGVerticalFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); ~TGVerticalFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGVerticalFrame.html:1370,log,logically,1370,root/html528/TGVerticalFrame.html,https://root.cern,https://root.cern/root/html528/TGVerticalFrame.html,4,['log'],['logically']
Testability,"rame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. virtual~TGCompositeFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidAddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidChangeOptions(UInt_t options); virtual voidChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidCleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGCompositeFrame.html:1364,log,logically,1364,root/html602/TGCompositeFrame.html,https://root.cern,https://root.cern/root/html602/TGCompositeFrame.html,2,['log'],['logically']
Testability,"rame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. virtual~TGFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidActivate(Bool_t); voidAddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGFrame.html:1355,log,logically,1355,root/html602/TGFrame.html,https://root.cern,https://root.cern/root/html602/TGFrame.html,2,['log'],['logically']
Testability,"rame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. virtual~TGGroupFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGGroupFrame.html:1361,log,logically,1361,root/html602/TGGroupFrame.html,https://root.cern,https://root.cern/root/html602/TGGroupFrame.html,2,['log'],['logically']
Testability,"rame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. virtual~TGHeaderFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGHeaderFrame.html:1365,log,logically,1365,root/html602/TGHeaderFrame.html,https://root.cern,https://root.cern/root/html602/TGHeaderFrame.html,2,['log'],['logically']
Testability,"rame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. virtual~TGHorizontalFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """");",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGHorizontalFrame.html:1376,log,logically,1376,root/html602/TGHorizontalFrame.html,https://root.cern,https://root.cern/root/html602/TGHorizontalFrame.html,2,['log'],['logically']
Testability,"rame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. virtual~TGMainFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tBindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGMainFrame.html:1358,log,logically,1358,root/html602/TGMainFrame.html,https://root.cern,https://root.cern/root/html602/TGMainFrame.html,2,['log'],['logically']
Testability,"rame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. virtual~TGTransientFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidCenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGTransientFrame.html:1368,log,logically,1368,root/html602/TGTransientFrame.html,https://root.cern,https://root.cern/root/html602/TGTransientFrame.html,2,['log'],['logically']
Testability,"rame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. virtual~TGVerticalFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGVerticalFrame.html:1370,log,logically,1370,root/html602/TGVerticalFrame.html,https://root.cern,https://root.cern/root/html602/TGVerticalFrame.html,2,['log'],['logically']
Testability,"rameter (not to fit). ; Definition at line 112 of file TSpectrum2Fit.h. ◆ fFixPositionX. Bool_t* TSpectrum2Fit::fFixPositionX. protected . [fNPeaks] array of logical values which allow to fix appropriate x positions of 2D peaks (not fit). However they are present in the estimated functional ; Definition at line 95 of file TSpectrum2Fit.h. ◆ fFixPositionX1. Bool_t* TSpectrum2Fit::fFixPositionX1. protected . [fNPeaks] array of logical values which allow to fix appropriate x positions of 1D ridges (not fit). However they are present in the estimated functional ; Definition at line 97 of file TSpectrum2Fit.h. ◆ fFixPositionY. Bool_t* TSpectrum2Fit::fFixPositionY. protected . [fNPeaks] array of logical values which allow to fix appropriate y positions of 2D peaks (not fit). However they are present in the estimated functional ; Definition at line 96 of file TSpectrum2Fit.h. ◆ fFixPositionY1. Bool_t* TSpectrum2Fit::fFixPositionY1. protected . [fNPeaks] array of logical values which allow to fix appropriate y positions of 1D ridges (not fit). However they are present in the estimated functional ; Definition at line 98 of file TSpectrum2Fit.h. ◆ fFixRo. Bool_t TSpectrum2Fit::fFixRo. protected . logical value of correlation coefficient, which allows to fix the parameter (not to fit). ; Definition at line 104 of file TSpectrum2Fit.h. ◆ fFixSigmaX. Bool_t TSpectrum2Fit::fFixSigmaX. protected . logical value of sigma x parameter, which allows to fix the parameter (not to fit). ; Definition at line 102 of file TSpectrum2Fit.h. ◆ fFixSigmaY. Bool_t TSpectrum2Fit::fFixSigmaY. protected . logical value of sigma y parameter, which allows to fix the parameter (not to fit). ; Definition at line 103 of file TSpectrum2Fit.h. ◆ fFixSx. Bool_t TSpectrum2Fit::fFixSx. protected . logical value of s parameter for 1D ridges in x direction, which allows to fix the parameter (not to fit). ; Definition at line 109 of file TSpectrum2Fit.h. ◆ fFixSxy. Bool_t TSpectrum2Fit::fFixSxy. protected . logi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2Fit.html:85462,log,logical,85462,doc/master/classTSpectrum2Fit.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2Fit.html,1,['log'],['logical']
Testability,"rameters, vector<Double_t>& oldParameters, Double_t currentTemperature); voidGenerateNewTemperature(Double_t& currentTemperature, Int_t Iter); TMVA::MsgLogger&Log() const; voidReWriteParameters(vector<Double_t>& from, vector<Double_t>& to); voidSetDefaultScale(); Bool_tShouldGoIn(Double_t currentFit, Double_t localFit, Double_t currentTemperature). Data Members; private:. Double_tfAdaptiveSpeedhow fast temperature change in adaptive (in adaptive two variables describe; Double_tfEpsepsilon; TMVA::IFitterTarget&fFitterTargetthe fitter target; Double_tfInitialTemperatureinitial temperature; enum EKernelTemperaturefKernelTemperature; TMVA::MsgLogger*fLoggermessage logger; Int_tfMaxCallsmaximum number of minimisation calls; Double_tfMinTemperaturemimimum temperature; Double_tfProgress; TRandom*fRandomrandom generator; const vector<TMVA::Interval*>&fRangesparameter ranges; Double_tfTemperatureAdaptiveStepused to calculate InitialTemperature if fUseDefaultTemperature; Double_tfTemperatureScalehow fast temperature change; Bool_tfUseDefaultScaleif TRUE, SA calculates its own TemperatureScale; Bool_tfUseDefaultTemperatureif TRUE, SA calculates its own InitialTemperature (MinTemperautre); static TMVA::SimulatedAnnealing::EKernelTemperaturekDecreasingAdaptive; static TMVA::SimulatedAnnealing::EKernelTemperaturekGeo; static TMVA::SimulatedAnnealing::EKernelTemperaturekHomo; static TMVA::SimulatedAnnealing::EKernelTemperaturekIncreasingAdaptive; static TMVA::SimulatedAnnealing::EKernelTemperaturekLog; static TMVA::SimulatedAnnealing::EKernelTemperaturekSin; static TMVA::SimulatedAnnealing::EKernelTemperaturekSqrt. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimulatedAnnealing(TMVA::IFitterTarget& target, const vector<TMVA::Interval*>& ranges); constructor. void SetOptions(Int_t maxCalls, Double_t initialTemperature, Double_t minTemperature, Double_t eps, TString kernelTemperatureS, Double_t temperatureScale, Double_t adaptiveSpeed, Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__SimulatedAnnealing.html:2323,log,logger,2323,root/html602/TMVA__SimulatedAnnealing.html,https://root.cern,https://root.cern/root/html602/TMVA__SimulatedAnnealing.html,2,['log'],['logger']
Testability,"rametersForTestStat(const RooArgSet&); virtual voidSetPdf(RooAbsPdf&); virtual voidSetPriorNuisance(RooAbsPdf*); virtual voidSetSamplingDistName(const char* name); virtual voidSetTestSize(Double_t size); virtual voidSetTestStatistic(RooStats::TestStatistic* testStatistic); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TestStatSampler(); TestStatSampler();. {}. SamplingDistribution* GetSamplingDistribution(RooArgSet& paramsOfInterest); Main interface to get a ConfInterval, pure virtual. Double_t EvaluateTestStatistic(RooAbsData& data, RooArgSet& paramsOfInterest); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetTestStatistic() const; Get the TestStatistic. Double_t ConfidenceLevel() const; Get the Confidence level for the test. void Initialize(RooAbsArg& testStatistic, RooArgSet& paramsOfInterest, RooArgSet& nuisanceParameters); Common Initialization. void SetPdf(RooAbsPdf& ); Set the Pdf, add to the the workspace if not already there. void SetPriorNuisance(RooAbsPdf* ); How to randomize the prior. Set to NULL to deactivate randomization. void SetParametersForTestStat(const RooArgSet& ); specify the values of parameters used when evaluating test statistic. void SetNuisanceParameters(const RooArgSet& ); REMOVE THIS; specify the parameters of interest in the interval; virtual void SetParameters(const RooArgSet&) = 0;; specify the nuisance parameters (eg. the rest of the parameters). void SetObservables(const RooArgSet& ); specify the observables in the dataset (needed to evaluate the test statistic). void SetGlobalObservables(const RooArgSet& ); specify the conditional observables. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). void SetConfidenceLevel(Double_t cl); set the confidence level for th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__TestStatSampler.html:2393,test,testStatistic,2393,root/html528/RooStats__TestStatSampler.html,https://root.cern,https://root.cern/root/html528/RooStats__TestStatSampler.html,3,['test'],['testStatistic']
Testability,"ramsOfInterest); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetTestStatistic() const; Get the TestStatistic. Double_t ConfidenceLevel() const; Get the Confidence level for the test. void Initialize(RooAbsArg& testStatistic, RooArgSet& paramsOfInterest, RooArgSet& nuisanceParameters); Common Initialization. void SetPdf(RooAbsPdf& ); Set the Pdf, add to the the workspace if not already there. void SetPriorNuisance(RooAbsPdf* ); How to randomize the prior. Set to NULL to deactivate randomization. void SetParametersForTestStat(const RooArgSet& ); specify the values of parameters used when evaluating test statistic. void SetNuisanceParameters(const RooArgSet& ); REMOVE THIS; specify the parameters of interest in the interval; virtual void SetParameters(const RooArgSet&) = 0;; specify the nuisance parameters (eg. the rest of the parameters). void SetObservables(const RooArgSet& ); specify the observables in the dataset (needed to evaluate the test statistic). void SetGlobalObservables(const RooArgSet& ); specify the conditional observables. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). void SetTestStatistic(RooStats::TestStatistic* testStatistic); Set the TestStatistic (want the argument to be a function of the data & parameter points. void SetSamplingDistName(const char* name); Set the name of the sampling distribution used for plotting. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: TestStatSampler.h 34109 2010-06-24 15:00:16Z moneta $ » Last generated: 2010-09-23 20:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__TestStatSampler.html:3288,test,test,3288,root/html528/RooStats__TestStatSampler.html,https://root.cern,https://root.cern/root/html528/RooStats__TestStatSampler.html,2,['test'],"['test', 'testStatistic']"
Testability,"ramsOfInterest); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetTestStatistic() const; Get the TestStatistic. Double_t ConfidenceLevel() const; Get the Confidence level for the test. void Initialize(RooAbsArg& testStatistic, RooArgSet& paramsOfInterest, RooArgSet& nuisanceParameters); Common Initialization. void SetPdf(RooAbsPdf& ); Set the Pdf, add to the the workspace if not already there. void SetPriorNuisance(RooAbsPdf* ); How to randomize the prior. Set to NULL to deactivate randomization. void SetParametersForTestStat(const RooArgSet& ); specify the values of parameters used when evaluating test statistic. void SetNuisanceParameters(const RooArgSet& ); REMOVE THIS; specify the parameters of interest in the interval; virtual void SetParameters(const RooArgSet&) = 0;; specify the nuisance parameters (eg. the rest of the parameters). void SetObservables(const RooArgSet& ); specify the observables in the dataset (needed to evaluate the test statistic). void SetGlobalObservables(const RooArgSet& ); specify the conditional observables. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). void SetTestStatistic(RooStats::TestStatistic* testStatistic); Set the TestStatistic (want the argument to be a function of the data & parameter points. void SetSamplingDistName(const char* name); Set the name of the sampling distribution used for plotting. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: TestStatSampler.h 39391 2011-05-26 09:51:59Z moneta $ » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__TestStatSampler.html:3290,test,test,3290,root/html530/RooStats__TestStatSampler.html,https://root.cern,https://root.cern/root/html530/RooStats__TestStatSampler.html,2,['test'],"['test', 'testStatistic']"
Testability,"ramsOfInterest); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetTestStatistic() const; Get the TestStatistic. Double_t ConfidenceLevel() const; Get the Confidence level for the test. void Initialize(RooAbsArg& testStatistic, RooArgSet& paramsOfInterest, RooArgSet& nuisanceParameters); Common Initialization. void SetPdf(RooAbsPdf& ); Set the Pdf, add to the the workspace if not already there. void SetPriorNuisance(RooAbsPdf* ); How to randomize the prior. Set to NULL to deactivate randomization. void SetParametersForTestStat(const RooArgSet& ); specify the values of parameters used when evaluating test statistic. void SetNuisanceParameters(const RooArgSet& ); REMOVE THIS; specify the parameters of interest in the interval; virtual void SetParameters(const RooArgSet&) = 0;; specify the nuisance parameters (eg. the rest of the parameters). void SetObservables(const RooArgSet& ); specify the observables in the dataset (needed to evaluate the test statistic). void SetGlobalObservables(const RooArgSet& ); specify the conditional observables. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). void SetTestStatistic(RooStats::TestStatistic* testStatistic); Set the TestStatistic (want the argument to be a function of the data & parameter points. void SetSamplingDistName(const char* name); Set the name of the sampling distribution used for plotting. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: TestStatSampler.h 39391 2011-05-26 09:51:59Z moneta $ » Last generated: 2011-11-03 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__TestStatSampler.html:3290,test,test,3290,root/html532/RooStats__TestStatSampler.html,https://root.cern,https://root.cern/root/html532/RooStats__TestStatSampler.html,2,['test'],"['test', 'testStatistic']"
Testability,"range [firstxbin,lastxbin],[firstybin,lastybin] for a 2-D histogram By default the integral is computed as the sum of bin contents in the range. ;  ; virtual Double_t Integral (Int_t, Int_t, Int_t, Int_t, Int_t, Int_t, Option_t *="""") const;  ; Double_t Integral (Option_t *option="""") const override;  Return integral of bin contents. ;  ; virtual Double_t IntegralAndError (Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2, Double_t &err, Option_t *option="""") const;  Return integral of bin contents in range [firstxbin,lastxbin],[firstybin,lastybin] for a 2-D histogram. ;  ; Double_t Interpolate (Double_t x, Double_t y) const override;  Given a point P(x,y), Interpolate approximates the value via bilinear interpolation based on the four nearest bin centers see Wikipedia, Bilinear Interpolation Andy Mastbaum 10/8/2008 vaguely based on R.Raja 6-Sep-2008. ;  ; Double_t Interpolate (Double_t x, Double_t y, Double_t z) const override;  illegal for a TH2 ;  ; Double_t KolmogorovTest (const TH1 *h2, Option_t *option="""") const override;  Statistical test of compatibility in shape between THIS histogram and h2, using Kolmogorov test. ;  ; TProfile * ProfileX (const char *name=""_pfx"", Int_t firstybin=1, Int_t lastybin=-1, Option_t *option="""") const;  Project a 2-D histogram into a profile histogram along X. ;  ; TProfile * ProfileY (const char *name=""_pfy"", Int_t firstxbin=1, Int_t lastxbin=-1, Option_t *option="""") const;  Project a 2-D histogram into a profile histogram along Y. ;  ; TH1D * ProjectionX (const char *name=""_px"", Int_t firstybin=0, Int_t lastybin=-1, Option_t *option="""") const;  Project a 2-D histogram into a 1-D histogram along X. ;  ; TH1D * ProjectionY (const char *name=""_py"", Int_t firstxbin=0, Int_t lastxbin=-1, Option_t *option="""") const;  Project a 2-D histogram into a 1-D histogram along Y. ;  ; TH1D * QuantilesX (Double_t prob=0.5, const char *name=""_qx"") const;  Compute the X distribution of quantiles in the other variable Y name is the name of the retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile2D.html:16754,test,test,16754,doc/master/classTProfile2D.html,https://root.cern,https://root.cern/doc/master/classTProfile2D.html,2,['test'],['test']
Testability,"range [firstxbin,lastxbin],[firstybin,lastybin] for a 2-D histogram By default the integral is computed as the sum of bin contents in the range. ;  ; virtual Double_t Integral (Int_t, Int_t, Int_t, Int_t, Int_t, Int_t, Option_t *="""") const;  ; Double_t Integral (Option_t *option="""") const override;  Return integral of bin contents. ;  ; virtual Double_t IntegralAndError (Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2, Double_t &err, Option_t *option="""") const;  Return integral of bin contents in range [firstxbin,lastxbin],[firstybin,lastybin] for a 2-D histogram. ;  ; Double_t Interpolate (Double_t x, Double_t y) const override;  Given a point P(x,y), Interpolate approximates the value via bilinear interpolation based on the four nearest bin centers see Wikipedia, Bilinear Interpolation Andy Mastbaum 10/8/2008 vaguely based on R.Raja 6-Sep-2008. ;  ; Double_t Interpolate (Double_t x, Double_t y, Double_t z) const override;  illegal for a TH2 ;  ; Double_t KolmogorovTest (const TH1 *h2, Option_t *option="""") const override;  Statistical test of compatibility in shape between THIS histogram and h2, using Kolmogorov test. ;  ; TProfile * ProfileX (const char *name=""_pfx"", Int_t firstybin=1, Int_t lastybin=-1, Option_t *option="""") const;  Project a 2-D histogram into a profile histogram along X. ;  ; TProfile * ProfileY (const char *name=""_pfy"", Int_t firstxbin=1, Int_t lastxbin=-1, Option_t *option="""") const;  Project a 2-D histogram into a profile histogram along Y. ;  ; TH1D * ProjectionX (const char *name=""_px"", Int_t firstybin=0, Int_t lastybin=-1, Option_t *option="""") const;  Project a 2-D histogram into a 1-D histogram along X. ;  ; TH1D * ProjectionY (const char *name=""_py"", Int_t firstxbin=0, Int_t lastxbin=-1, Option_t *option="""") const;  Project a 2-D histogram into a 1-D histogram along Y. ;  ; void PutStats (Double_t *stats) override;  Replace current statistics with the values in array stats. ;  ; TH1D * QuantilesX (Double_t prob=0.5, const char *name=""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2C.html:7451,test,test,7451,doc/master/classTH2C.html,https://root.cern,https://root.cern/doc/master/classTH2C.html,12,['test'],['test']
Testability,"ranging from firstybin to lastybin included.; By default, bins 1 to ny are included; When all bins are included, the number of entries in the projection; is set to the number of entries of the 2-D histogram, otherwise; the number of entries is incremented by 1 for all non empty cells. if option ""d"" is specified, the profile is drawn in the current pad. if option ""o"" original axis range of the target axes will be; kept, but only bins inside the selected range will be filled. The option can also be used to specify the projected profile error type.; Values which can be used are 's', 'i', or 'g'. See TProfile::BuildOptions for details. Using a TCutG object, it is possible to select a sub-range of a 2-D histogram.; One must create a graphical cut (mouse or C++) and specify the name; of the cut between [] in the option.; For example, with a TCutG named ""cutg"", one can call:; myhist->ProfileX("" "",firstybin,lastybin,""[cutg]"");; To invert the cut, it is enough to put a ""-"" in front of its name:; myhist->ProfileX("" "",firstybin,lastybin,""[-cutg]"");; It is possible to apply several cuts ("","" means logical AND):; myhist->ProfileX("" "",firstybin,lastybin,""[cutg1,cutg2]"");. NOTE that if a TProfile named ""name"" exists in the current directory or pad with; a compatible axis the profile is reset and filled again with the projected contents of the TH2.; In the case of axis incompatibility an error is reported and a NULL pointer is returned. NOTE that the X axis attributes of the TH2 are copied to the X axis of the profile. NOTE that the default under- / overflow behavior differs from what ProjectionX; does! Profiles take the bin center into account, so here the under- and overflow; bins are ignored by default. TProfile * ProfileY(const char* name = ""_pfy"", Int_t firstxbin = 1, Int_t lastxbin = -1, Option_t* option = """") const; *-*-*-*-*Project a 2-D histogram into a profile histogram along Y*-*-*-*-*-*; *-* ========================================================. The projection is made",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH2.html:46857,log,logical,46857,root/html534/TH2.html,https://root.cern,https://root.cern/root/html534/TH2.html,1,['log'],['logical']
Testability,"ranging from firstybin to lastybin included.; By default, bins 1 to ny are included; When all bins are included, the number of entries in the projection; is set to the number of entries of the 2-D histogram, otherwise; the number of entries is incremented by 1 for all non empty cells. if option ""d"" is specified, the profile is drawn in the current pad. if option ""o"" original axis range of the target axes will be; kept, but only bins inside the selected range will be filled. The option can also be used to specify the projected profile error type.; Values which can be used are 's', 'i', or 'g'. See TProfile::BuildOptions for details. Using a TCutG object, it is possible to select a sub-range of a 2-D histogram.; One must create a graphical cut (mouse or C++) and specify the name; of the cut between [] in the option.; For example, with a TCutG named ""cutg"", one can call:; myhist->ProfileX("" "",firstybin,lastybin,""[cutg]"");; To invert the cut, it is enough to put a ""-"" in front of its name:; myhist->ProfileX("" "",firstybin,lastybin,""[-cutg]"");; It is possible to apply several cuts ("","" means logical AND):; myhist->ProfileX("" "",firstybin,lastybin,""[cutg1,cutg2]"");. NOTE that if a TProfile named ""name"" exists in the current directory or pad with; a compatible axis the profile is reset and filled again with the projected contents of the TH2.; In the case of axis incompatibility an error is reported and a NULL pointer is returned. NOTE that the X axis attributes of the TH2 are copied to the X axis of the profile. NOTE that the default under- / overflow behavior differs from what ProjectionX; does! Profiles take the bin center into account, so here the under- and overflow; bins are ignored by default. TProfile * ProfileY(const char* name = ""_pfy"", Int_t firstxbin = 1, Int_t lastxbin = -1, Option_t* option = """") const; Project a 2-D histogram into a profile histogram along Y. The projection is made from the channels along the X axis; ranging from firstxbin to lastxbin included.;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH2.html:48432,log,logical,48432,root/html602/TH2.html,https://root.cern,https://root.cern/root/html602/TH2.html,2,['log'],['logical']
Testability,"ransform(const Double_t* vals); voidSetTranslation(const TGLVertex3& translation); voidSetupGLColors(TGLRnrCtx& rnrCtx, const Float_t* color = 0) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTranslate(const TGLVector3& vect). private:. TGLPhysicalShape(const TGLPhysicalShape&); voidInitColor(const Float_t* rgba); TGLPhysicalShape&operator=(const TGLPhysicalShape&); voidUpdateBoundingBox(). Data Members; public:. enum EManip { kTranslateX; kTranslateY; kTranslateZ; kTranslateAll; kScaleX; kScaleY; kScaleZ; kScaleAll; kRotateX; kRotateY; kRotateZ; kRotateAll; kManipAll; };. private:. TGLBoundingBoxfBoundingBox! bounding box of the physical (transformed); Float_tfColor[17]! GL color array; TGLPShapeRef*fFirstPSRef! pointer to first reference; UInt_tfID! unique physical ID within containing scene; Bool_tfInvertedWind! face winding TODO: can get directly from fTransform?; const TGLLogicalShape*fLogicalShape! the associated logical shape; TGLPhysicalShape::EManipfManip! permitted manipulation bitflags - see EManip; Bool_tfModified! has been modified - retain across scene rebuilds; TGLPhysicalShape*fNextPhysical! pointer to next replica; UChar_tfSelected! selected state; TGLMatrixfTransform! transform (placement) of physical instance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const TGLMatrix& transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; ID - unique drawable id.; logicalShape - bound logical shape; transform - transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const double* transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLPhysicalShape.html:3982,log,logical,3982,root/html528/TGLPhysicalShape.html,https://root.cern,https://root.cern/root/html528/TGLPhysicalShape.html,3,['log'],['logical']
Testability,"ransform?; Bool_tfIsScaleForRnr! cache ; const TGLLogicalShape*fLogicalShape! the associated logical shape; TGLPhysicalShape::EManipfManip! permitted manipulation bitflags - see EManip; Bool_tfModified! has been modified - retain across scene rebuilds; TGLPhysicalShape*fNextPhysical! pointer to next replica; UChar_tfSelected! selected state; TGLMatrixfTransform! transform (placement) of physical instance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const TGLMatrix& transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; ID - unique drawable id.; logicalShape - bound logical shape; transform - transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const double* transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; id - unique drawable id.; logicalShape - bound logical shape; transform - 16 Double_t component transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. ~TGLPhysicalShape(); Destroy the physical shape. void AddReference(TGLPShapeRef* ref); Add reference ref. void RemoveReference(TGLPShapeRef* ref); Remove reference ref. void Modified(); Call this after modifying the physical so that the information; can be propagated to the object referencing it. void UpdateBoundingBox(); Update our internal bounding box (in global frame). void InitColor(const Float_t* rgba); Initialise the colors, using basic RGBA diffuse material color supplied. void SetColor(const Float_t* rgba); Set full color attributes - see OpenGL material documentation; for full description.; 0->3 diffuse, 4->7 ambient, 8->11 specular, 12->15 emission, 16 shininess.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLPhysicalShape.html:4889,log,logicalShape,4889,root/html534/TGLPhysicalShape.html,https://root.cern,https://root.cern/root/html534/TGLPhysicalShape.html,1,['log'],['logicalShape']
Testability,"raph2DErrors, TH2; TH3 TH3. Double_t* GetCovarianceMatrix() const; get the error matrix in a pointer to a NxN array.; excluding the fixed parameters. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; get error matrix element. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; get fit errors. Int_t GetNumberTotalParameters() const; number of total parameters. Int_t GetNumberFreeParameters() const; number of variable parameters. Double_t GetParError(Int_t ipar) const; parameter error. Double_t GetParameter(Int_t ipar) const; parameter value. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; get all parameter info (name, value, errors). const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; get fit statistical information. Double_t GetSumLog(Int_t i); sum of log . Un-needed. Bool_t IsFixed(Int_t ipar) const; query if parameter ipar is fixed. void PrintResults(Int_t level, Double_t amin) const; print the fit result; use PrintResults function in case of Minuit for old -style printing. void ReleaseParameter(Int_t ipar); release a fit parameter. void SetFitMethod(const char* name); set fit method (i.e. chi2 or likelihood); according to the method the appropriate FCN function will be created. Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set (add) a new fit parameter passing initial value, step size (verr) and parametr limits; if vlow > vhigh the parameter is unbounded; if the stepsize (verr) == 0 the parameter is treated as fixed. void ReCreateMinimizer(); Recreate a minimizer instance using the function and data; set objective function in minimizers function to re-create FCN from stored data object and fit options. void SetFCN(void (*fcn)(Int_t &, Double_t *,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBackCompFitter.html:15450,log,log,15450,root/html526/TBackCompFitter.html,https://root.cern,https://root.cern/root/html526/TBackCompFitter.html,1,['log'],['log']
Testability,"raphViz representation of the expression tree headed by this RooAbsArg object to the given ostream. ;  ; bool hasClients () const;  ; bool hasDataToken () const;  ; virtual bool hasRange (const char *) const;  ; virtual bool importWorkspaceHook (RooWorkspace &ws);  ; virtual bool inRange (const char *) const;  ; virtual bool isCategory () const;  ; bool isConstant () const;  Check if the ""Constant"" attribute is set. ;  ; virtual bool isReducerNode () const;  ; bool IsSortable () const override;  ; bool localNoDirtyInhibit () const;  ; const TNamed * namePtr () const;  De-duplicated pointer to this object's name. ;  ; Int_t numProxies () const;  Return the number of registered proxies. ;  ; bool observableOverlaps (const RooAbsData *dset, const RooAbsArg &testArg) const;  Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ;  ; bool observableOverlaps (const RooArgSet *depList, const RooAbsArg &testArg) const;  Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ;  ; RooAbsArg & operator= (const RooAbsArg &other)=delete;  ; bool overlaps (const RooAbsArg &testArg, bool valueOnly=false) const;  Test if any of the nodes of tree are shared with that of the given tree. ;  ; const RooArgSet * ownedComponents () const;  ; void Print (Option_t *options=nullptr) const override;  Print the object to the defaultPrintStream(). ;  ; void printAddress (std::ostream &os) const override;  Print address of this RooAbsArg. ;  ; void printArgs (std::ostream &os) const override;  Print object arguments, ie its proxies. ;  ; void printClassName (std::ostream &os) const override;  Print object class name. ;  ; void printCompactTree (const char *indent="""", const char *fileName=nullptr, const char *namePat=nullptr, RooAbsArg *client=nullptr);  Print tree structure of expression tree on stdout, or to file if filename is specified. ;  ; void printCompactTree (std::o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChi2Var.html:30883,test,testArg,30883,doc/master/classRooChi2Var.html,https://root.cern,https://root.cern/doc/master/classRooChi2Var.html,4,['test'],['testArg']
Testability,"raphics from many threads Three different canvases in three different threads are started and regularly updated ;  draw_rh1.cxxThis macro generates a small V7 TH1D, fills it and draw it in a V7 canvas ;  draw_subpads.cxx;  draw_v6.cxx;  fitpanel.cxx;  histops.cxx;  line.cxxThis ROOT 7 example demonstrates how to create a ROOT 7 canvas (RCanvas) and draw ROOT 7 lines in it (RLine) ;  lineStyle.cxx;  lineWidth.cxx;  markerStyle.cxx;  pad.cxx;  perf.cxx;  perfcomp.cxx;  simple.cxx;  text.cxx;  ► vecops;  vo001_AdoptOrOwnMemory.C In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo001_AdoptOrOwnMemory.py In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo002_VectorCalculations.C In this tutorial we learn how the RVec class can be used to express easily mathematical operations involving arrays and scalars ;  vo003_LogicalOperations.C In this tutorial we learn how the RVec class can be used to express logical operations ;  vo004_SortAndSelect.C In this tutorial we learn how elements of an RVec can be easily sorted and selected ;  vo004_SortAndSelect.py In this tutorial we learn how elements of an RVec can be easily sorted and selected ;  vo005_Combinations.C In this tutorial we learn how combinations of RVecs can be build ;  vo005_Combinations.py In this tutorial we learn how combinations of RVecs can be build ;  vo006_IndexManipulation.C In this tutorial we demonstrate RVec helpers for index manipulation ;  ► xml;  DOMParsePerson.C ROOT implementation of a XML DOM Parser ;  DOMRecursive.C ROOT implementation of a XML DOM Parser ;  SAXHandler.C ROOT implementation of a simple SAX Handler ;  xmlmodifyfile.C Example to read, modify and store xml file, using TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ;  xmlnewfile.C Example to create a new xml file with the TXMLEngine class ;  xmlread",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:172547,log,logical,172547,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['log'],['logical']
Testability,"rary. The plotting options start with GL keyword.; In addition, in order to inform canvases that OpenGL should be used to render; 3D representations, the following option should be set:. gStyle->SetCanvasPreferGL(true);. General information: plot types and supported options; The following types of plots are provided:; For lego plots the supported options are:. ""GLLEGO""; Draw a lego plot. It works also for TH2Poly. ""GLLEGO2; Bins with color levels. ""GLLEGO3; Cylindrical bars. Lego painter in cartesian supports logarithmic scales for X, Y, Z.; In polar only Z axis can be logarithmic, in cylindrical only Y.; For surface plots (TF2 and TH2) the supported options are:. ""GLSURF"" ; Draw a surface. ""GLSURF1""; Surface with color levels. ""GLSURF2""; The same as ""GLSURF1"" but without polygon outlines. ""GLSURF3""; Color level projection on top of plot (works only in cartesian coordinate; system). ""GLSURF4""; Same as ""GLSURF"" but without polygon outlines. The surface painting in cartesian coordinates supports logarithmic scales along; X, Y, Z axis. In polar coordinates only the Z axis can be logarithmic,; in cylindrical coordinates only the Y axis.; Additional options to SURF and LEGO - Coordinate systems:. "" ""; Default, cartesian coordinates system. ""POL""; Polar coordinates system. ""CYL""; Cylindrical coordinates system. ""SPH""; Spherical coordinates system. TH3 as boxes (spheres); The supported options are:. GLBOX"" ; TH3 as a set of boxes, size of box is proportional to bin content. GLBOX1""; The same as ""glbox"", but spheres are drawn instead of boxes. TH3 as iso-surface(s); The supported option is:. ""GLISO"" ; TH3 is drawn using iso-surfaces. TF3 (implicit function); The supported option is:. GLTF3"" ; Draw a TF3. Parametric surfaces; $ROOTSYS/tutorials/gl/glparametric.C shows how to create parametric; equations and visualize the surface.; Interaction with the plots; All the interactions are implemented via standard methods; DistancetoPrimitive() and ExecuteEvent(). That's why all the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THistPainter.html:70099,log,logarithmic,70099,root/html528/THistPainter.html,https://root.cern,https://root.cern/root/html528/THistPainter.html,3,['log'],['logarithmic']
Testability,"rary. The plotting options start with GL keyword.; In addition, in order to inform canvases that OpenGL should be used to render; 3D representations, the following option should be set:. gStyle->SetCanvasPreferGL(true);. General information: plot types and supported options; The following types of plots are provided:; For lego plots the supported options are:. ""GLLEGO""; Draw a lego plot. It works also for TH2Poly. ""GLLEGO2; Bins with color levels. ""GLLEGO3; Cylindrical bars. Lego painter in cartesian supports logarithmic scales for X, Y, Z.; In polar only Z axis can be logarithmic, in cylindrical only Y.; For surface plots (TF2 and TH2) the supported options are:. ""GLSURF"" ; Draw a surface. ""GLSURF1""; Surface with color levels. ""GLSURF2""; The same as ""GLSURF1"" but without polygon outlines. ""GLSURF3""; Color level projection on top of plot (works only in cartesian coordinate; system). ""GLSURF4""; Same as ""GLSURF"" but without polygon outlines. The surface painting in cartesian coordinates supports logarithmic scales along; X, Y, Z axis. In polar coordinates only the Z axis can be logarithmic,; in cylindrical coordinates only the Y axis.; Additional options to SURF and LEGO - Coordinate systems:. "" ""; Default, cartesian coordinates system. ""POL""; Polar coordinates system. ""CYL""; Cylindrical coordinates system. ""SPH""; Spherical coordinates system. TH3 as color boxes; The supported option is:. ""GLCOL"" ; H3 is drawn using semi-transparent colored boxes.; See $ROOTSYS/tutorials/gl/glvox1.C. TH3 as boxes (spheres); The supported options are:. ""GLBOX"" ; TH3 as a set of boxes, size of box is proportional to bin content. ""GLBOX1""; The same as ""glbox"", but spheres are drawn instead of boxes. TH3 as iso-surface(s); The supported option is:. ""GLISO"" ; TH3 is drawn using iso-surfaces. TF3 (implicit function); The supported option is:. ""GLTF3"" ; Draw a TF3. Parametric surfaces; $ROOTSYS/tutorials/gl/glparametric.C shows how to create parametric; equations and visualize the surface.; I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/THistPainter.html:79629,log,logarithmic,79629,root/html604/THistPainter.html,https://root.cern,https://root.cern/root/html604/THistPainter.html,1,['log'],['logarithmic']
Testability,"rary. The plotting options start with GL keyword.; In addition, in order to inform canvases that OpenGL should be used to render; 3D representations, the following option should be set:. gStyle->SetCanvasPreferGL(true);. General information: plot types and supported options; The following types of plots are provided:; For lego plots the supported options are:. ""GLLEGO""; Draw a lego plot. It works also for TH2Poly. ""GLLEGO2; Bins with color levels. ""GLLEGO3; Cylindrical bars. Lego painter in cartesian supports logarithmic scales for X, Y, Z.; In polar only Z axis can be logarithmic, in cylindrical only Y.; For surface plots (TF2 and TH2) the supported options are:. ""GLSURF"" ; Draw a surface. ""GLSURF1""; Surface with color levels. ""GLSURF2""; The same as ""GLSURF1"" but without polygon outlines. ""GLSURF3""; Color level projection on top of plot (works only in cartesian coordinate; system). ""GLSURF4""; Same as ""GLSURF"" but without polygon outlines. The surface painting in cartesian coordinates supports logarithmic scales along; X, Y, Z axis. In polar coordinates only the Z axis can be logarithmic,; in cylindrical coordinates only the Y axis.; Additional options to SURF and LEGO - Coordinate systems:. "" ""; Default, cartesian coordinates system. ""POL""; Polar coordinates system. ""CYL""; Cylindrical coordinates system. ""SPH""; Spherical coordinates system. TH3 as color boxes; The supported option is:. ""GLCOL"" ; H3 is drawn using semi-transparent colored boxes.; See $ROOTSYS/tutorials/gl/glvox1.C. TH3 as boxes (spheres); The supported options are:. GLBOX"" ; TH3 as a set of boxes, size of box is proportional to bin content. GLBOX1""; The same as ""glbox"", but spheres are drawn instead of boxes. TH3 as iso-surface(s); The supported option is:. ""GLISO"" ; TH3 is drawn using iso-surfaces. TF3 (implicit function); The supported option is:. GLTF3"" ; Draw a TF3. Parametric surfaces; $ROOTSYS/tutorials/gl/glparametric.C shows how to create parametric; equations and visualize the surface.; Inte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THistPainter.html:75301,log,logarithmic,75301,root/html534/THistPainter.html,https://root.cern,https://root.cern/root/html534/THistPainter.html,2,['log'],['logarithmic']
Testability,"rating demoProjectDict.cxx; compiles demoProjectDict.cxx into demoProjectDict.o; generates a shared lib demo.so; dynamically links the shared lib demo.so to the executable If only the option ""+"" had been specified, one can still link the shared lib to the current executable module with: gSystem->load(""demo/demo.so"");; The following feature is not yet enabled: One can restrict the list of classes to be generated by using expressions like: classes = ""Ali*"" generate code only for classes starting with Ali; classes = ""myClass"" generate code for class MyClass only.; . Reimplemented from TFile.; Definition at line 78 of file TXMLFile.h. ◆ Map() [1/2]. void TXMLFile::Map ; (; ). inlinefinalvirtual . Reimplemented from TFile.; Definition at line 80 of file TXMLFile.h. ◆ Map() [2/2]. void TXMLFile::Map ; (; Option_t * ; opt). inlinefinalvirtual . List the contents of a file sequentially. ; For each logical record found, it prints: Date/Time Record_Adress Logical_Record_Length ClassName CompressionFactor; Example of output 20010404/150437 At:64 N=150 TFile; 20010404/150440 At:214 N=28326 TBasket CX = 1.13; 20010404/150440 At:28540 N=29616 TBasket CX = 1.08; 20010404/150440 At:58156 N=29640 TBasket CX = 1.08; 20010404/150440 At:87796 N=29076 TBasket CX = 1.10; 20010404/150440 At:116872 N=10151 TBasket CX = 3.15; 20010404/150441 At:127023 N=28341 TBasket CX = 1.13; 20010404/150441 At:155364 N=29594 TBasket CX = 1.08; 20010404/150441 At:184958 N=29616 TBasket CX = 1.08; 20010404/150441 At:214574 N=29075 TBasket CX = 1.10; 20010404/150441 At:243649 N=9583 TBasket CX = 3.34; 20010404/150442 At:253232 N=28324 TBasket CX = 1.13; 20010404/150442 At:281556 N=29641 TBasket CX = 1.08; 20010404/150442 At:311197 N=29633 TBasket CX = 1.08; 20010404/150442 At:340830 N=29091 TBasket CX = 1.10; 20010404/150442 At:369921 N=10341 TBasket CX = 3.09; 20010404/150442 At:380262 N=509 TH1F CX = 1.93; 20010404/150442 At:380771 N=1769 TH2F CX = 4.32; 20010404/150442 At:382540 N=1849 TProfile CX = 1.65;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLFile.html:61222,log,logical,61222,doc/master/classTXMLFile.html,https://root.cern,https://root.cern/doc/master/classTXMLFile.html,1,['log'],['logical']
Testability,"rator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:7246,assert,assert,7246,root/html528/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,106,['assert'],['assert']
Testability,"rator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooMinuit&operator=(const RooMinuit&); voidoptimizeConst(Bool_t flag); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); RooFitResult*save(const char* name = 0, const char* title = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); Int_tseek(); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidsetEps(Double_t eps); voidsetErrorLevel(Double_t level); voidsetEvalErrorWall(Bool_t flag); Bool_tsetLogFile(const char* logfile = 0); voidsetNoWarn(); static voidTObject::SetObjectStat(Bool_t stat); voidsetPrintEvalErrors(Int_t numEvalErrors); Int_tsetPrintLevel(Int_t newLevel); voidsetProfile(Bool_t flag = kTRUE); voidsetStrategy(Int_t strat); virtual voidTObject::SetUniqueID(UInt_t uid); voidsetVerbose(Bool_t flag = kTRUE); Int_tsetWarnLevel(Int_t newLevel); virtual voidShowMembers(TMemberInspector& insp); Int_tsimplex(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidzeroEvalCount().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooMinuit.html:5415,log,logfile,5415,root/html530/RooMinuit.html,https://root.cern,https://root.cern/root/html530/RooMinuit.html,1,['log'],['logfile']
Testability,"rator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsString::createFundamental(const char* newname = 0) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::Exe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStringVar.html:3009,test,testArg,3009,root/html532/RooStringVar.html,https://root.cern,https://root.cern/root/html532/RooStringVar.html,1,['test'],['testArg']
Testability,"rator=(const TProofMgr&). Data Members; public:. enum EServType { kProofd; kXProofd; kProofLite; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSignalHandler*fIntHandlerInterrupt signal handler (ctrl-c); TStringTNamed::fNameobject identifier; Int_tfRemoteProtocolProtocol number run by the daemon server; TProofMgr::EServTypefServTypeType of server: old-proofd, XrdProofd; TList*fSessionsPROOF session managed by this server; TStringTNamed::fTitleobject title; TUrlfUrlServer URL; static TListfgListOfManagersSub-list of TROOT::ListOfProofs for managers. private:. static TProofMgr_tfgTXProofMgrHookConstructor hooks for TXProofMgr. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofMgr(const char* url, Int_t loglevel = -1, const char* alias = """"); Create a PROOF manager for the standard (old) environment. ~TProofMgr(); Destroy a TProofMgr instance. TProof * AttachSession(Int_t , Bool_t = kFALSE); Dummy version provided for completeness. Just returns a pointer to; existing session 'id' (as shown by TProof::QuerySessions) or 0 if 'id' is; not valid. The boolena 'gui' should be kTRUE when invoked from the GUI. TProof * AttachSession(TProofDesc* , Bool_t = kFALSE); Dummy version provided for completeness. Just returns a pointer to; existing session 'id' (as shown by TProof::QuerySessions) or 0 if 'id' is; not valid. void DetachSession(Int_t , Option_t* = """"); Detach session with 'id' from its proofserv. The 'id' is the number; shown by QuerySessions. The correspondent TProof object is deleted.; If id == 0 all the known sessions are detached.; Option opt=""S"" or ""s"" forces session shutdown. void DetachSession(TProof* , Option_t* = """"); Detach session 'p' from its proofserv. The instance 'p' is invalidated; and shou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofMgr.html:8455,log,loglevel,8455,root/html528/TProofMgr.html,https://root.cern,https://root.cern/root/html528/TProofMgr.html,3,['log'],['loglevel']
Testability,"rator=wrap_pdf=-0.675078, denominator=wrap_pdf_Int[pTV]=86190.2; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=-0.675078, denominator=wrap_pdf_Int[pTV]=86190.2; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=-0.675078, denominator=wrap_pdf_Int[pTV]=86190.2; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=-0.675078, denominator=wrap_pdf_Int[pTV]=86190.2; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.186765 cHl3=8.8591 cHq3=-0.971282; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=-6.32705, denominator=wrap_pdf_Int[pTV]=46316; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.218731 cHl3=0.37397 cHq3=-2.08166; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=3.22694 cHl3=-7.04051 cHq3=0.54016; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ nume",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:11219,log,log,11219,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['log'],['log']
Testability,rawHist Tree drawing selector for PROOF; TProofDrawListOfGraphs Tree drawing selector for PROOF; TProofDrawListOfGraphs::Point3D_t ; TProofDrawListOfPolyMarkers3D Tree drawing selector for PROOF; TProofDrawListOfPolyMarkers3D::Point4D_t ; TProofDrawPolyMarker3D Tree drawing selector for PROOF; TProofDrawProfile Tree drawing selector for PROOF; TProofDrawProfile2D Tree drawing selector for PROOF; TProofLimitsFinder Find and communicate best axis limits; TProofLite PROOF control class; TProofLog PROOF session log handler; TProofLogElem PROOF session log element; TProofMgr Abstract PROOF manager interface; TProofMgrLite XrdProofd PROOF manager interface; TProofNodeInfo Class describing a PROOF node; TProofOutputFile Wrapper class to steer the merging of files produced on workers; TProofPlayer Basic PROOF player; TProofPlayerLite PROOF player running in PROOF-Lite; TProofPlayerLocal PROOF player running on client; TProofPlayerRemote PROOF player running on master server; TProofPlayerSlave PROOF player running on slave server; TProofPlayerSuperMaster PROOF player running on super master; TProofProgressDialog PROOF progress dialog; TProofProgressLog Class implementing a log graphic box; TProofProgressMemoryPlot PROOF progress memory plots; TProofProgressStatus Proof progress status class; TProofQueryResult Class describing a PROOF query; TProofResources Abstract class describing PROOF resources; TProofResourcesStatic Class to handle PROOF static config; TProofServ PROOF Server Application Interface; TProofServLite Local worker PROOF Server Application Interface; TProofSuperMaster PROOF control class for making submasters; TProofVectorContainer<TProofDrawListOfGraphs::Point3D_t> Class describing a vector container; TProofVectorContainer<TProofDrawListOfPolyMarkers3D::Point4D_t> Class describing a vector container; TPyDispatcher Python dispatcher class; TPyReturn Python morphing return object; TPySelector Python equivalent base class for PROOF; TPythia6 Interface to Pythia6.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:109735,log,log,109735,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,1,['log'],['log']
Testability,"rawOption() const; static Long_tTObject::GetDtorOnly(); virtual TStringTFormula::GetExpFormula(Option_t* option = """") const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TH1*GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*TFormula::GetLinearPart(Int_t i); virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual Double_tGetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tGetMaximumStored() const; virtual Double_tGetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; TMethodCall*GetMethodCall() const; virtual Double_tGetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tGetMinimumStored() const; virtual Double_tGetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual const char*TNamed::GetName() const; virtual Int_tGetNDF() const; virtual Int_tTFormula::GetNdim() const; virtual Int_tTFormula::GetNpar() const; virtual Int_tGetNpx() const; virtual Int_tTFormula::GetNumber() const; virtual Int_tGetNumberFitPoints() const; virtual Int_tGetNumberFreeParameters() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tTFormula::GetParameter(Int_t ipar) const; Double_tTFormula::GetParameter(const char* name) const; virtual Double_t*TFormula::GetParameters() const; virtual voidTFormula::GetParameters(Double_t* params); TObject*GetPa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TF1.html:9899,log,logx,9899,root/html534/TF1.html,https://root.cern,https://root.cern/root/html534/TF1.html,1,['log'],['logx']
Testability,"ray of Z planes positions . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ClearThreadData() const. void CreateThreadData(Int_t nthreads); Create thread data for n threads max. TGeoPgon(); dummy ctor. TGeoPgon(Double_t phi, Double_t dphi, Int_t nedges, Int_t nz); Default constructor. TGeoPgon(const char* name, Double_t phi, Double_t dphi, Int_t nedges, Int_t nz); Default constructor. TGeoPgon(Double_t* params); Default constructor in GEANT3 style; param[0] = phi1; param[1] = dphi; param[2] = nedges; param[3] = nz. param[4] = z1; param[5] = Rmin1; param[6] = Rmax1. ~TGeoPgon(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a polygone; Check if the sections are in increasing Z order. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this shape; check total z range. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the polygone; first find out in which Z section the point is in. void LocatePhi(const Double_t* point, Int_t& ipsec) const; Locates index IPSEC of the phi sector containing POINT. Int_t GetPhiCrossList(const Double_t* point, const Double_t* dir, Int_t istart, Double_t* sphi, Int_t* iphi, Double_t stepmax = TGeoShape::Big()) const; Returns lists of PGON phi crossings for a ray starting from POINT. Bool_t SliceCrossingInZ(const Double_t* point, const Double_t* dir, Int_t nphi, Int_t* iphi, Double_t* sphi, Double_t& snext, Double_t stepmax) const; Performs ray propagation between Z segments. Bool_t SliceCrossingZ(const Double_t* point, const Double_t* dir, Int_t nphi, Int_t* iphi, Double_t* sphi, Double_t& snext, Double_t stepmax) const; Performs ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPgon.html:16195,test,test,16195,root/html534/TGeoPgon.html,https://root.cern,https://root.cern/root/html534/TGeoPgon.html,1,['test'],['test']
Testability,"ray of errors of peak areas; Double_tfBCalccalculated value of b parameter; Double_tfBErrerror value of b parameter; Double_tfBInitinitial value of b parameter (slope), for details see html manual and references; Double_tfChihere the fitting functions return resulting chi square; Int_tfFitTaylororder of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function.; Bool_tfFixA0logical value of a0 parameter, which allows to fix the parameter (not to fit).; Bool_tfFixA1logical value of a1 parameter, which allows to fix the parameter (not to fit).; Bool_tfFixA2logical value of a2 parameter, which allows to fix the parameter (not to fit).; Bool_t*fFixAmp[fNPeaks] array of logical values which allow to fix appropriate amplitudes (not fit). However they are present in the estimated functional; Bool_tfFixBlogical value of b parameter, which allows to fix the parameter (not to fit).; Bool_t*fFixPosition[fNPeaks] array of logical values which allow to fix appropriate positions (not fit). However they are present in the estimated functional; Bool_tfFixSlogical value of s parameter, which allows to fix the parameter (not to fit).; Bool_tfFixSigmalogical value of sigma parameter, which allows to fix the parameter (not to fit).; Bool_tfFixTlogical value of t parameter, which allows to fix the parameter (not to fit).; Int_tfNPeaksnumber of peaks present in fit, input parameter, it should be > 0; TStringTNamed::fNameobject identifier; Int_tfNumberIterationsnumber of iterations in fitting procedure, input parameter, it should be > 0; Double_t*fPositionCalc[fNPeaks] array of calculated values of fitted positions, output parameters; Double_t*fPositionErr[fNPeaks] array of position errors; Double_t*fPositionInit[fNPeaks] array of initial values of peaks positions, input parameters; Int_tfPowerpossible values kFitPower2,4,6,8,10,12, for details see references. It applies only for Awmi fitting function.; Double_tfSCalccalculate",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrumFit.html:12133,log,logical,12133,root/html602/TSpectrumFit.html,https://root.cern,https://root.cern/root/html602/TSpectrumFit.html,2,['log'],['logical']
Testability,ray of longs; TArrayL64 Array of long64s; TArrayS Array of shorts; TArrow An arrow (line with a arrowhead); TArrowEditor GUI for editing arrow attributes; TAtomicCount ; TAtt3D 3D attributes; TAttAxis Axis attributes; TAttBBox Helper for management of bounding-box information; TAttBBox2D 2D bounding box attributes; TAttCanvas Canvas attributes; TAttFill Fill area attributes; TAttFillEditor GUI for editing fill attributes; TAttImage Image attributes; TAttLine Line attributes; TAttLineEditor GUI for editing line attributes; TAttMarker Marker attributes; TAttMarkerEditor GUI for editing marker attributes; TAttPad Pad attributes; TAttParticle Particle definition; TAttText Text attributes; TAttTextEditor GUI for editing text attributes; TAuthenticate Class providing remote authentication service; TAxis Axis class; TAxis3D 3-D ruler painting class; TAxisEditor axis editor; TBRIK TBRIK shape; TBackCompFitter Class providing backward compatibility for fitting by implementing the TVirtualFitter interface; TBase64 Base64 encoding/decoding; TBaseClass Description of a base class; TBasket the TBranch buffers; TBasketSQL the TBranch buffers; TBenchmark ROOT utility to help benchmarking applications; TBinomialEfficiencyFitter Binomial Fitter for the division of two histograms; TBits Bit container; TBits::TReference ; TBox Box class; TBranch Branch descriptor; TBranchClones Branch in case of an array of clone objects; TBranchElement Branch in case of an object; TBranchObject Branch in case of an object; TBranchRef to support referenced objects on other branches; TBranchSTL Branch handling STL collection of pointers; TBrowser ROOT Object Browser; TBrowserImp ABC describing browser implementation protocol; TBrowserPlugin basic plugin description class; TBtree A B-tree; TBtreeIter B-tree iterator; TBuffer Buffer base class used for serializing objects; TBuffer3D 3D primitives description; TBufferFile concrete implementation of TBuffer for writing/reading to/from a ROOT file or socket.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:54968,benchmark,benchmarking,54968,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,3,['benchmark'],['benchmarking']
Testability,"ray}; \right|\]; It describes a so-called active rotation, i.e. a rotation of objects inside a static system of coordinates. In case you want to rotate the frame and want to know the coordinates of objects in the rotated system, you should apply the inverse rotation to the objects. If you want to transform coordinates from the rotated frame to the original frame you have to apply the direct transformation. A rotation around a specified axis means counterclockwise rotation around the positive direction of the axis.; 17.3.1 Declaration, Access, Comparisons; TRotation r; // r initialized as identity; TRotation m(r); // m = r; There is no direct way to set the matrix elements - to ensure that a TRotation always describes a real rotation. But you can get the values by with the methods XX()..ZZ() or the (,) operator:; Double_t xx = r.XX(); // the same as xx=r(0,0); xx = r(0,0);; if (r==m) {...} // test for equality; if (r!=m) {..} // test for inequality; if (r.IsIdentity()) {...} // test for identity; 17.3.2 Rotation around Axes; The following matrices describe counter-clockwise rotations around the coordinate axes and are implemented in: RotateX(),RotateY() and RotateZ():; \[; Rx(a) = \left|; \begin{array}{ccc}; 1 & 0 & 0 \\; 0 & cos(a) & -sin(a) \\; 0 & sin(a) & cos(a); \end{array}; \right|; Ry(a) = \left|; \begin{array}{ccc}; cos(a) & 0 & sin(a) \\; 0 & 1 & 0 \\; -sin(a) & 0 & cos(a); \end{array}; \right|; Rz(a) = \left|; \begin{array}{ccc}; cos(a) & -sin(a) & 0 \\; sin(a) & cos(a) & 0 \\; 0 & 0 & 1; \end{array}; \right|; \]; r.RotateX(TMath::Pi()); // rotation around the x-axis; 17.3.3 Rotation around Arbitrary Axis; The Rotate() method allows you to rotate around an arbitrary vector (not necessary a unit one) and returns the result.; r.Rotate(TMath::Pi()/3,TVector3(3,4,5));; It is possible to find a unit vector and an angle, which describe the same rotation as the current one:; Double_t angle;; TVector3 axis;; r.GetAngleAxis(angle,axis);; 17.3.4 Rotation of Local Axes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:863836,test,test,863836,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['test'],['test']
Testability,"ray}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j). read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j). read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](int j); { return (*fMat)(fRow,j); }. const T & operator[](int j); { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivot",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:6926,assert,assert,6926,root/html526/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,15,['assert'],['assert']
Testability,rce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*RooAbsOptTestStatistic::_funcClonePointer to internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcCloneSetSet owning all components of internal clone of input function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*RooAbsOptTestStatistic::_normSetPointer to set with observables used for normalization; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooAbsOptTestStatistic::_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgSetRooAbsOptTestStatistic::_ownedDataObs! Dataset observables we've agreed to own; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*RooAbsOptTestStatistic::_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; TListRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TStringRooAbsOptTestStatistic::_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_tRooAbsOptTestStatistic::_sealedIs test statistic sealed -- i.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooDataWeightedAverage.html:34740,test,test,34740,root/html530/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html530/RooDataWeightedAverage.html,6,['test'],['test']
Testability,"rce:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::Tools. class TMVA::Tools. Function Members (Methods); public:. ~Tools(); voidAddAttr(void* node, const char* attrname, const char* value); voidAddAttr<const char *>(void* node, const char* attrname, const char*const& value, Int_t precision = 16); void*AddChild(void* parent, const char* childname, const char* content = 0, bool isRootNode = false); Bool_tAddComment(void* node, const char* comment); Bool_tAddRawLine(void* node, const char* raw); vector<TMatrixDSym*>*CalcCovarianceMatrices(const vector<TMVA::Event*>& events, Int_t maxCls, TMVA::VariableTransformBase* transformBase = 0); vector<TMatrixDSym*>*CalcCovarianceMatrices(const vector<const TMVA::Event*>& events, Int_t maxCls, TMVA::VariableTransformBase* transformBase = 0); Bool_tCheckForSilentOption(const TString&) const; Bool_tCheckForVerboseOption(const TString&) const; Bool_tCheckSplines(const TH1*, const TSpline*); const TString&Color(const TString&); voidComputeStat(const vector<TMVA::Event*>&, vector<Float_t>*, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Int_t signalClass, Bool_t norm = kFALSE); Double_tComputeVariance(Double_t sumx2, Double_t sumx, Int_t nx); Bool_tContainsRegularExpression(const TString& s); static voidDestroyInstance(); voidFormattedOutput(const TMatrixD&, const vector<TString>&, TMVA::MsgLogger& logger); voidFormattedOutput(const TMatrixD&, const vector<TString>& vert, const vector<TString>& horiz, TMVA::MsgLogger& logger); voidFormattedOutput(const vector<Double_t>&, const vector<TString>&, const TString titleVars, const TString titleValues, TMVA::MsgLogger& logger, TString format = ""%+1.3f""); void*GetChild(void* parent, const char* childname = 0); const char*GetContent(void* node); const TMatrixD*GetCorrelationMatrix(const TMatrixD* covMat); Double_tGetCorrelationRatio(const TH2F&); TH1*GetCumulativeDist",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__Tools.html:1565,log,logger,1565,root/html602/TMVA__Tools.html,https://root.cern,https://root.cern/root/html602/TMVA__Tools.html,3,['log'],['logger']
Testability,"rce . ). Multiply target by the source, element-by-element. ; Definition at line 2032 of file TVectorT.cxx. ◆ ElementMult() [4/4]. template<class Element > . TVectorT< Element > & TMatrixTAutoloadOps::ElementMult ; (; TVectorT< Element > & ; target, . const TVectorT< Element > & ; source, . const TVectorT< Element > & ; select . ). Multiply target by the source, element-by-element only where select[i] != 0.0. ; Definition at line 2052 of file TVectorT.cxx. ◆ Mult(). template<class Element1 , class Element2 , class Element3 > . Element1 TMatrixTAutoloadOps::Mult ; (; const TVectorT< Element1 > & ; v1, . const TMatrixT< Element2 > & ; m, . const TVectorT< Element3 > & ; v2 . ). Perform v1 * M * v2, a scalar result. ; Definition at line 1542 of file TVectorT.cxx. ◆ operator!=() [1/3]. template<class Element > . TMatrixT< Element > TMatrixTAutoloadOps::operator!= ; (; const TMatrixT< Element > & ; source1, . const TMatrixT< Element > & ; source2 . ). logical operation source1 != source2 ; Definition at line 2842 of file TMatrixT.cxx. ◆ operator!=() [2/3]. template<class Element > . TMatrixT< Element > TMatrixTAutoloadOps::operator!= ; (; const TMatrixT< Element > & ; source1, . const TMatrixTSym< Element > & ; source2 . ). logical operation source1 != source2 ; Definition at line 2870 of file TMatrixT.cxx. ◆ operator!=() [3/3]. template<class Element > . TMatrixT< Element > TMatrixTAutoloadOps::operator!= ; (; const TMatrixTSym< Element > & ; source1, . const TMatrixT< Element > & ; source2 . ). logical operation source1 != source2 ; Definition at line 2898 of file TMatrixT.cxx. ◆ operator&&() [1/3]. template<class Element > . TMatrixT< Element > TMatrixTAutoloadOps::operator&& ; (; const TMatrixT< Element > & ; source1, . const TMatrixT< Element > & ; source2 . ). Logical AND. ; Definition at line 2466 of file TMatrixT.cxx. ◆ operator&&() [2/3]. template<class Element > . TMatrixT< Element > TMatrixTAutoloadOps::operator&& ; (; const TMatrixT< Element > & ; source1, . c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMatrixTAutoloadOps.html:26438,log,logical,26438,doc/master/namespaceTMatrixTAutoloadOps.html,https://root.cern,https://root.cern/doc/master/namespaceTMatrixTAutoloadOps.html,1,['log'],['logical']
Testability,"rclone [-r <repo>] <project> <local-name>. where rclone is defined in cet-chg:export:unix-admin/profile.d/rclone.sh ; Basic log information.>; git log []. Important tip: log messages have an optional structure, since many git commands only look at the first line. Get into the habit of putting only a short synopsis on the first line of a log message and putting more detailed information on subsequent lines. You can omit the -m option entirely and an editor (as specified with VISUAL or EDITOR) will be started.; This command is extremely versatile. You may want to have a couple of aliases defined in your .gitconfig file (see attached gitconfig for ideas). Working in your local repository. Obtain differences with; git status. Move files from one part of your directory tree to another:; git mv <old-path> <new-path>. Delete unwanted tracked files:; git rm <path>. Add un-tracked files:; git add <un-tracked-file>. Stage a modified file for commit:; git add <file>. Commit currently-staged files:; git commit -m <log-message>. Commit only specific files (regardless of what is staged):; git commit -m <log-message>. Commit all modified files:; git commit -a -m <log-message>. Un-stage a previously staged (but not yet committed) file:; git reset HEAD <file>. Examine a representation of your change tree with log files and patch descriptions:; gitk. Get differences with respect to the committed (or staged) version of a file:; git diff <file>. Get differences between local file and committed version:; git diff --cached <file>. Basic interaction with local branches. Create (but do not switch to) a new local branch based on the current branch:; git branch <new-branch>. Create and switch to a local branch based on the current branch:; git checkout -b <new-branch>. Change to an existing local branch:; git checkout <branch>. Examine the list of commits in the current branch not reflected in another branch:; git cherry -v <branch>. Merge another branch into the current one:; git merge <bran",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/git-tips-and-tricks.html:7798,log,log-message,7798,d/git-tips-and-tricks.html,https://root.cern,https://root.cern/d/git-tips-and-tricks.html,1,['log'],['log-message']
Testability,"rdErrorsPtr[1] = ey;; 171 fCoordErrorsPtr[2] = ez;; 172 ; 173 fErrorType = kCoordError;; 174 }; 175 }; 176 else; 177 {; 178 fErrorType = kNoError;; 179 }; 180 ; 181 fpTmpCoordErrorVector = new double [ fDim ];; 182 ComputeSums();; 183 }; 184 ; 185 /**; 186 destructor; 187 */; 188 BinData::~BinData(); 189 {; 190 assert( fMaxPoints == 0 || fWrapped == fData.empty() );; 191 ; 192 assert( kValueError == fErrorType || kCoordError == fErrorType ||; 193 kAsymError == fErrorType || kNoError == fErrorType );; 194 assert( fMaxPoints == 0 || fDataError.empty() || &fDataError.front() == fDataErrorPtr );; 195 assert( fMaxPoints == 0 || fDataErrorHigh.empty() || &fDataErrorHigh.front() == fDataErrorHighPtr );; 196 assert( fMaxPoints == 0 || fDataErrorLow.empty() || &fDataErrorLow.front() == fDataErrorLowPtr );; 197 assert( fMaxPoints == 0 || fDataErrorLow.empty() == fDataErrorHigh.empty() );; 198 assert( fMaxPoints == 0 || fData.empty() || &fData.front() == fDataPtr );; 199 ; 200 for ( unsigned int i=0; i < fDim; i++ ); 201 {; 202 assert( fCoordErrors.empty() || &fCoordErrors[i].front() == fCoordErrorsPtr[i] );; 203 }; 204 ; 205 if ( fpTmpBinEdgeVector ); 206 {; 207 delete[] fpTmpBinEdgeVector;; 208 fpTmpBinEdgeVector= nullptr;; 209 }; 210 ; 211 if ( fpTmpCoordErrorVector ); 212 {; 213 delete[] fpTmpCoordErrorVector;; 214 fpTmpCoordErrorVector = nullptr;; 215 }; 216 }; 217 ; 218 /**; 219 copy constructors; 220 */; 221 BinData::BinData(const BinData &rhs); 222 : FitData(rhs),; 223 fDataPtr(nullptr),; 224 fDataErrorPtr(nullptr), fDataErrorHighPtr(nullptr), fDataErrorLowPtr(nullptr),; 225 fpTmpCoordErrorVector(nullptr), fpTmpBinEdgeVector(nullptr); 226 {; 227 *this = rhs;; 228 }; 229 ; 230 BinData & BinData::operator= ( const BinData & rhs ); 231 {; 232 FitData::operator=( rhs );; 233 ; 234 if ( fpTmpBinEdgeVector ); 235 {; 236 assert(HasBinEdges());; 237 ; 238 delete[] fpTmpBinEdgeVector;; 239 fpTmpBinEdgeVector= nullptr;; 240 }; 241 ; 242 if ( fpTmpCoordErrorVector ); 243 {; 244 de",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:5816,assert,assert,5816,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['assert'],['assert']
Testability,"rdinates( IT begin, IT end ); 203 { IT a = begin; IT b = ++begin; IT c = ++begin;; 204 (void)end;; 205 assert (++begin==end);; 206 SetCoordinates (*a,*b,*c);; 207 return *this;; 208 }; 209 ; 210 /**; 211 get internal data into 3 Scalar numbers; 212 */; 213 void GetCoordinates( Scalar& a, Scalar& b, Scalar& c ) const; 214 { fCoordinates.GetCoordinates(a, b, c); }; 215 ; 216 /**; 217 get internal data into a C-style array of 3 Scalar numbers; 218 */; 219 void GetCoordinates( Scalar dest[] ) const; 220 { fCoordinates.GetCoordinates(dest); }; 221 ; 222 /**; 223 get internal data into 3 Scalars at *begin to *end (3 past begin); 224 */; 225 template <class IT>; 226 void GetCoordinates( IT begin, IT end ) const; 227 { IT a = begin; IT b = ++begin; IT c = ++begin;; 228 (void)end;; 229 assert (++begin==end);; 230 GetCoordinates (*a,*b,*c);; 231 }; 232 /**; 233 get internal data into 3 Scalars starting at *begin; 234 */; 235 template <class IT>; 236 void GetCoordinates( IT begin) const {; 237 Scalar a = Scalar(0);; 238 Scalar b = Scalar(0);; 239 Scalar c = Scalar(0);; 240 GetCoordinates(a, b, c);; 241 *begin++ = a;; 242 *begin++ = b;; 243 *begin = c;; 244 }; 245 ; 246 /**; 247 set the values of the vector from the cartesian components (x,y,z); 248 (if the vector is held in polar or cylindrical eta coordinates,; 249 then (x, y, z) are converted to that form); 250 */; 251 DisplacementVector3D<CoordSystem, Tag>& SetXYZ (Scalar a, Scalar b, Scalar c) {; 252 fCoordinates.SetXYZ(a, b, c);; 253 return *this;; 254 }; 255 ; 256 // ------------------- Equality -----------------; 257 ; 258 /**; 259 Exact equality; 260 */; 261 bool operator==(const DisplacementVector3D & rhs) const {; 262 return fCoordinates==rhs.fCoordinates;; 263 }; 264 bool operator!= (const DisplacementVector3D & rhs) const {; 265 return !(operator==(rhs));; 266 }; 267 ; 268 // ------ Individual element access, in various coordinate systems ------; 269 ; 270 /**; 271 Dimension; 272 */; 273 unsigned int Dimension() con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html:7463,assert,assert,7463,doc/master/GenVector_2DisplacementVector3D_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html,1,['assert'],['assert']
Testability,"re TMVA will store ntuples, histograms, etc.; TString outfileName(""TMVARegCv.root"");; TFile * outputFile = TFile::Open(outfileName, ""RECREATE"");; ; TString infileName(""./files/tmva_reg_example.root"");; TFile * inputFile = getDataFile(infileName);; ; TMVA::DataLoader *dataloader=new TMVA::DataLoader(""datasetcvreg"");; ; dataloader->AddVariable(""var1"", ""Variable 1"", ""units"", 'F');; dataloader->AddVariable(""var2"", ""Variable 2"", ""units"", 'F');; ; // Add the variable carrying the regression target; dataloader->AddTarget(""fvalue"");; ; TTree * regTree = (TTree*)inputFile->Get(""TreeR"");; dataloader->AddRegressionTree(regTree, 1.0);; ; // Individual events can be weighted; // dataloader->SetWeightExpression(""weight"", ""Regression"");; ; std::cout << ""--- TMVACrossValidationRegression: Using input file: "" << inputFile->GetName() << std::endl;; ; // Bypasses the normal splitting mechanism, CV uses a new system for this.; // Unfortunately the old system is unhappy if we leave the test set empty so; // we ensure that there is at least one event by placing the first event in; // it.; // You can with the selection cut place a global cut on the defined; // variables. Only events passing the cut will be using in training/testing.; // Example: `TCut selectionCut = ""var1 < 1"";`; TCut selectionCut = """";; dataloader->PrepareTrainingAndTestTree(selectionCut, ""nTest_Regression=1""; "":SplitMode=Block""; "":NormMode=NumEvents""; "":!V"");; ; // --------------------------------------------------------------------------; ; //; // This sets up a CrossValidation class (which wraps a TMVA::Factory; // internally) for 2-fold cross validation. The data will be split into the; // two folds randomly if `splitExpr` is `""""`.; //; // One can also give a deterministic split using spectator variables. An; // example would be e.g. `""int(fabs([spec1]))%int([NumFolds])""`.; //; UInt_t numFolds = 2;; TString analysisType = ""Regression"";; TString splitExpr = """";; ; TString cvOptions = Form(""!V""; "":!Silent""; "":ModelPersi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidationRegression_8C.html:16917,test,test,16917,doc/master/TMVACrossValidationRegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidationRegression_8C.html,1,['test'],['test']
Testability,"re also special since they can; potentially be analytically integrated and generated. RooArgSet* getParameters(const RooAbsData* data, Bool_t stripDisconnected=kTRUE). RooArgSet* getParameters(const RooAbsData& data, Bool_t stripDisconnected=kTRUE); Return the parameters of this p.d.f when used in conjuction with dataset 'data'. RooArgSet* getObservables(const RooArgSet& set, Bool_t valueOnly=kTRUE); Return the observables of _this_ pdf given a set of observables. return getObservables(&set,valueOnly). RooArgSet* getDependents(const RooArgSet& set); --- Obsolete functions for backward compatibility. { return getObservables(set) ; }. RooArgSet* getDependents(const RooAbsData* set); { return getObservables(set) ; }. RooArgSet* getDependents(const RooArgSet* depList); { return getObservables(depList) ; }. Bool_t dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg); { return observableOverlaps(dset,testArg) ; }. Bool_t dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg); { return observableOverlaps(depList, testArg) ; }. Bool_t checkDependents(const RooArgSet* nset) const; { return checkObservables(nset) ; }. Bool_t recursiveCheckDependents(const RooArgSet* nset) const; --- End obsolete functions for backward compatibility. { return recursiveCheckObservables(nset) ; }. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); I/O streaming interface (machine readable). void writeToStream(ostream& os, Bool_t compact) const. void Print(Option_t* options = 0) const; Printing interface (human readable). void printMetaArgs(ostream& ) const; {}. const std::set<std::string>& attributes() const; Returns set of names of boolean attributes defined. const std::map<std::string,std::string>& stringAttributes() const; Returns map<string,string> with all string attributes defined. const std::set<std::string>& transientAttributes() const; Return set of transient boolean attributes. Bool_t isConstant() const; Returns true if 'Constant' ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsArg.html:38233,test,testArg,38233,root/html526/RooAbsArg.html,https://root.cern,https://root.cern/root/html526/RooAbsArg.html,2,['test'],['testArg']
Testability,"re shown stacked:. The first histogram is paint.; The the sum of the first and second, etc... If the option ""NOSTACK"" is specified, the histograms are all paint in; the same pad as if the option ""SAME"" had been specified. This allows to; compute X and Y scales common to all the histograms, like; TMultiGraph does for graphs.; If the option ""PADS"" is specified, the current pad/canvas is; subdivided into a number of pads equal to the number of histograms and each; histogram is paint into a separate pad.; The following example shows various types of stacks. Picture; Source. TCanvas *hstack() {; // Example of stacked histograms: class THStack; //; // Author: Rene Brun. THStack *hs = new THStack(""hs"",""Stacked 1D histograms"");; //create three 1-d histograms; TH1F *h1st = new TH1F(""h1st"",""test hstack"",100,-4,4);; h1st->FillRandom(""gaus"",20000);; h1st->SetFillColor(kRed);; h1st->SetMarkerStyle(21);; h1st->SetMarkerColor(kRed);; hs->Add(h1st);; TH1F *h2st = new TH1F(""h2st"",""test hstack"",100,-4,4);; h2st->FillRandom(""gaus"",15000);; h2st->SetFillColor(kBlue);; h2st->SetMarkerStyle(21);; h2st->SetMarkerColor(kBlue);; hs->Add(h2st);; TH1F *h3st = new TH1F(""h3st"",""test hstack"",100,-4,4);; h3st->FillRandom(""gaus"",10000);; h3st->SetFillColor(kGreen);; h3st->SetMarkerStyle(21);; h3st->SetMarkerColor(kGreen);; hs->Add(h3st);. TCanvas *cst = new TCanvas(""cst"",""stacked hists"",10,10,700,700);; cst->SetFillColor(41);; cst->Divide(2,2);; // in top left pad, draw the stack with defaults; cst->cd(1);; hs->Draw();; // in top right pad, draw the stack in non-stack mode; // and errors option; cst->cd(2);; gPad->SetGrid();; hs->Draw(""nostack,e1p"");; //in bottom left, draw in stack mode with ""lego1"" option; cst->cd(3);; gPad->SetFrameFillColor(17);; gPad->SetTheta(3.77);; gPad->SetPhi(2.9);; hs->Draw(""lego1"");. cst->cd(4);; //create two 2-D histograms and draw them in stack mode; gPad->SetFrameFillColor(17);; THStack *a = new THStack(""a"",""Stacked 2D histograms"");; TF2 *f1 = new TF2(""f1"",; ""xygaus",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THistPainter.html:72288,test,test,72288,root/html602/THistPainter.html,https://root.cern,https://root.cern/root/html602/THistPainter.html,6,['test'],['test']
Testability,"re then follow the instructions on how to report a bug with JIRA.; When you submit a bug, please follow these guidelines:. If you submit a problem, always indicate your ROOT version number (e.g. 6.02.00, 5.34.22) and the platform you are running on (e.g. Ubuntu 14 gcc49, SLC6 clang35).; The bug title subject line should clearly identify the problem.; If you use a non recent version of ROOT, try to test your problem with newer version. If this is too difficult, consult the release and development notes to check if your problem has not already been solved.; Try to quickly search the internet and look in the forum if your problem has been already solved.; Try to share the maximum amount of information. A bug report which only says ""My macro crashes when running on kubuntu but on windows works"" is much less likely to be solved quickly than a complete message with a gdb stacktrace and a reproducer (see next item).; Send a minimal program or macro reproducing the problem. Make sure that your script can be executed directly. If it uses a data file, send the smallest possible data file as a mail attachment, or indicate how to get this file.; If for some reason it is not possible to share a minimal reproducer, try to make sure that your explanations are sufficient to speed up the whole fixing procedure. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/guidelines-submitting-bug.html:4163,test,tests,4163,d/guidelines-submitting-bug.html,https://root.cern,https://root.cern/d/guidelines-submitting-bug.html,1,['test'],['tests']
Testability,"re we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the fID logical ID member of; TBuffer3D. If repeated addition of the same fID is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can; also perform internal GL specific caching with considerable performance gains; in these cases.; For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalMaster transform and the; fColor and fTransparency attributes, which can be varied for each physical; object.; As a minimum requirement all clients must be capable of filling the raw tessellation; of the object buffer, in the master reference frame. Conversely viewers must; always be capable of displaying the object described by this buffer. Scene Rebuilds; It should be understood that AddObject is not an explicit command to the viewer; - it may for various reasons decide to ignore it:. It already has the object internally cached .; The object falls outside; some 'interest' limits of the viewer camera.; The object is too small to; be worth drawing. In all these cases AddObject() returns kNone, as it does for successful addition,; simply indicating it does not require you to provide further information about; this object. You should; not try to make any assumptions about what the viewer did with it.; This enables the viewer to be connected to a client which sends potentially",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBuffer3D.html:5907,log,logical,5907,root/html526/TBuffer3D.html,https://root.cern,https://root.cern/root/html526/TBuffer3D.html,26,['log'],['logical']
Testability,"re); 6997{; 6998 if (!cls || !*cls); 6999 return {};; 7000 ; 7001 using namespace clang;; 7002 if (const Decl *D = LH.findScope(cls, cling::LookupHelper::NoDiagnostics,; 7003 /*type*/ nullptr, /*instantiate*/ false)) {; 7004 if (!D->isFromASTFile()) {; 7005 if (gDebug > 5); 7006 Warning(""GetClassSharedLibsForModule"", ""Decl found for %s is not part of a module"", cls);; 7007 return {};; 7008 }; 7009 class ModuleCollector : public ConstDeclVisitor<ModuleCollector> {; 7010 llvm::DenseSet<Module *> &m_TopLevelModules;; 7011 ; 7012 public:; 7013 ModuleCollector(llvm::DenseSet<Module *> &TopLevelModules) : m_TopLevelModules(TopLevelModules) {}; 7014 void Collect(const Decl *D) { Visit(D); }; 7015 ; 7016 void VisitDecl(const Decl *D); 7017 {; 7018 // FIXME: Such case is described ROOT-7765 where; 7019 // ROOT_GENERATE_DICTIONARY does not contain the list of headers.; 7020 // They are specified as #includes in the LinkDef file. This leads to; 7021 // generation of incomplete modulemap files and this logic fails to; 7022 // compute the corresponding module of D.; 7023 // FIXME: If we want to support such a case, we should not rely on; 7024 // the contents of the modulemap but mangle D and look it up in the; 7025 // .so files.; 7026 if (!D->hasOwningModule()); 7027 return;; 7028 if (Module *M = D->getOwningModule()->getTopLevelModule()); 7029 m_TopLevelModules.insert(M);; 7030 }; 7031 ; 7032 void VisitTemplateArgument(const TemplateArgument &TA); 7033 {; 7034 switch (TA.getKind()) {; 7035 case TemplateArgument::Null:; 7036 case TemplateArgument::Integral:; 7037 case TemplateArgument::Pack:; 7038 case TemplateArgument::NullPtr:; 7039 case TemplateArgument::StructuralValue:; 7040 case TemplateArgument::Expression:; 7041 case TemplateArgument::Template:; 7042 case TemplateArgument::TemplateExpansion: return;; 7043 case TemplateArgument::Type:; 7044 if (const TagType *TagTy = dyn_cast<TagType>(TA.getAsType())); 7045 return Visit(TagTy->getDecl());; 7046 return;; 7047 case Template",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:274526,log,logic,274526,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['log'],['logic']
Testability,re*fBaseIconbase list tree icon picture; Bool_tfBusyKTRUE if busy i.e : connecting; TGPopupMenu*fCascadeMenuoptions menu entry; Bool_tfChangePicKTRUE if animation active; TStringfConfigFileconfiguration file name; TGHProgressBar*fConnectProgconnection progress bar; TContextMenu*fContextMenuinput/output objects context menu; time_tfElapsedtime of connection; TGPopupMenu*fFileMenufile menu entry; TGPopupMenu*fHelpMenuhelp menu entry; TGHorizontalFrame*fHf; TSessionInputFrame*fInputFrameinput frame; const TGPicture*fLocallocal session icon picture; TSessionLogView*fLogWindowexternal log window; TGMenuBar*fMenuBarapplication main menu bar; TGPopupMenu*fOptionsMenuoptions menu entry; TSessionOutputFrame*fOutputFrameoutput frame; TGPopupMenu*fPopupQryquery related popup menu; TGPopupMenu*fPopupSrvserver related popup menu; const TGPicture*fProofConconnected server icon picture; const TGPicture*fProofDiscondisconnected server icon picture; const TGPicture*fQueryConconnected(?) query icon picture; const TGPicture*fQueryDiscondisconnected(?) query icon picture; TSessionQueryFrame*fQueryFrameright side query frame; TGPopupMenu*fQueryMenuquery menu entry; TGIcon*fRightIconassociated picture; TGPicture*fRightIconPicturelower bottom left icon used to show connection status; TSessionServerFrame*fServerFrameright side server frame; TSessionFrame*fSessionFrameright side session frame; TGListTree*fSessionHierarchymain sessions/queries hierarchy list tree; TGListTreeItem*fSessionItembase (main) session list tree item; TGPopupMenu*fSessionMenusession menu entry; TList*fSessionslist of sessions; time_tfStart; TGStatusBar*fStatusBarbottom status bar; TTimer*fTimertimer used to change icon picture; TGToolBar*fToolBarapplication tool bar; TGCanvas*fTreeViewmain right sessions/queries tree view; UserGroup_t*fUserGroupuser connected to session; TGVerticalFrame*fV1; TGVerticalFrame*fV2; TEnv*fViewerEnvviewer's configuration. Class Charts. Inheritance; Inherited Members; Includes; Libraries. ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSessionViewer.html:23933,log,log,23933,root/html528/TSessionViewer.html,https://root.cern,https://root.cern/root/html528/TSessionViewer.html,4,['log'],['log']
Testability,"re. ; Definition at line 1176 of file TGWin32.cxx. ◆ QueryPointer() [1/2]. void TGWin32::QueryPointer ; (; Int_t & ; ix, . Int_t & ; iy . ). overridevirtual . Query pointer position. ; ix : X coordinate of pointer iy : Y coordinate of pointer (both coordinates are relative to the origin of the root window) ; Reimplemented from TVirtualX.; Definition at line 2262 of file TGWin32.cxx. ◆ QueryPointer() [2/2]. void TGWin32::QueryPointer ; (; Window_t ; id, . Window_t & ; rootw, . Window_t & ; childw, . Int_t & ; root_x, . Int_t & ; root_y, . Int_t & ; win_x, . Int_t & ; win_y, . UInt_t & ; mask . ). overridevirtual . Returns the root window the pointer is logically on and the pointer coordinates relative to the root window's origin. ; The pointer coordinates returned to win_x and win_y are relative to the origin of the specified window. In this case, QueryPointer returns the child that contains the pointer, if any, or else kNone to childw. QueryPointer returns the current logical state of the keyboard buttons and the modifier keys in mask. ; Reimplemented from TVirtualX.; Definition at line 7017 of file TGWin32.cxx. ◆ RaiseWindow(). void TGWin32::RaiseWindow ; (; Window_t ; id). overridevirtual . Put window on top of window stack. ; Reimplemented from TVirtualX.; Definition at line 4695 of file TGWin32.cxx. ◆ ReadGIF(). Pixmap_t TGWin32::ReadGIF ; (; Int_t ; x0, . Int_t ; y0, . const char * ; file, . Window_t ; id = 0 . ). overridevirtual . If id is NULL - loads the specified gif file at position [x0,y0] in the current window. ; Otherwise creates pixmap from gif file ; Reimplemented from TVirtualX.; Definition at line 4526 of file TGWin32.cxx. ◆ ReadPictureDataFromFile(). Bool_t TGWin32::ReadPictureDataFromFile ; (; const char * ; filename, . char *** ; ret_data . ). overridevirtual . Read picture data from file and store in ret_data. ; Returns kTRUE in case of success, kFALSE otherwise. ; Reimplemented from TVirtualX.; Definition at line 5673 of file TGWin32.cxx. ◆ Rem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32.html:98090,log,logical,98090,doc/master/classTGWin32.html,https://root.cern,https://root.cern/doc/master/classTGWin32.html,1,['log'],['logical']
Testability,"re: ""saw-like"" polygon (bins == teeth).; ; //Includes for ACLiC.; #include <cassert>; #include <vector>; ; #include ""TRandom.h""; #include ""TCanvas.h""; #include ""Rtypes.h""; #include ""TNamed.h""; ; class PolyTest2 : public TNamed, public TAttLine, public TAttFill {; public:; PolyTest2();; ; void Paint(const Option_t *notUsed) override;; ; private:; enum TestSize {; kNSawPoints = 10000; };; ; //Part 1.; std::vector<Double_t> fXs1;; std::vector<Double_t> fYs1;; //Part 2.; ; std::vector<Double_t> fXs2;; std::vector<Double_t> fYs2;; };; ; //_____________________________________________________________; PolyTest2::PolyTest2(); : TNamed(""polygon_compression_test2"", ""polygon_compression_test2""); {; //Polygon 1, n of points is 10003, after 'compression' : 1897; //Polygon 2, n of points is 10003, after 'compression' : 2093; ; //Some canvas must already exist by this point.; assert(gPad != nullptr && ""PolyTest2, gPad is null"");; //We need a gRandom to exist.; assert(gRandom != nullptr && ""PolyTest2, gRandom is null"");; ; Double_t xMin = 0., xMax = 0., yMin = 0., yMax = 0.;; gPad->GetRange(xMin, yMin, xMax, yMax);; assert(xMax - xMin > 0 && yMax - yMin > 0 && ""PolyTest2, invalid canvas' ranges"");; ; ; // .(0/the last)--------.(1); // | /; // | \; // | /; // .(kNSawPoints + 1)--.(kNSawPoints); ; const unsigned nVertices = 3 + kNSawPoints;; ; {; //Polygon 1, ""vertical saw"":; fXs1.resize(nVertices);; fYs1.resize(nVertices);; ; fXs1[0] = 0.;; fYs1[0] = 0.;; ; const Double_t w1 = 0.2 * (xMax - xMin);; const Double_t saw1ToothSize = 0.1 * w1;; const Double_t yStep = (yMax - yMin) / (kNSawPoints - 1);; ; for (unsigned i = 1; i <= kNSawPoints; ++i) {; fXs1[i] = w1 + gRandom->Rndm() * saw1ToothSize;; fYs1[i] = yMin + yStep * (i - 1);; }; ; fXs1[nVertices - 2] = 0.;; fYs1[nVertices - 2] = yMax;; //Let's close it.; fXs1[nVertices - 1] = fXs1[0];; fYs1[nVertices - 1] = fYs1[0];; ; }; ; //Polygon 2, ""horizontal saw"":; ; {; const Double_t x2Min = xMin + 0.25 * (xMax - xMin);; const Double_t h2 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/polytest2_8C.html:1532,assert,assert,1532,doc/master/polytest2_8C.html,https://root.cern,https://root.cern/doc/master/polytest2_8C.html,1,['assert'],['assert']
Testability,"ready to send output (in control output sending mode); static TPluginHandler*fgLogViewerLog dialog box plugin; static TList*fgProofEnvListList of TNameds defining environment. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProof(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); Create a PROOF environment. Starting PROOF involves either connecting; to a master server, which in turn will start a set of slave servers, or; directly starting as master server (if master = """"). Masterurl is of; the form: [proof[s]://]host[:port]. Conffile is the name of the config; file describing the remote PROOF cluster (this argument alows you to; describe different cluster configurations).; The default is proof.conf. Confdir is the directory where the config; file and other PROOF related files are (like motd and noproof files).; Loglevel is the log level (default = 1). User specified custom config; files will be first looked for in $HOME/.conffile. TProof(); Protected constructor to be used by classes deriving from TProof; (they have to call Init themselves and override StartSlaves; appropriately). This constructor simply closes any previous gProof and sets gProof; to this instance. void InitMembers(); Default initializations. ~TProof(); Clean up PROOF environment. Int_t Init(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); Start the PROOF environment. Starting PROOF involves either connecting; to a master server, which in turn will start a set of slave servers, or; directly starting as master server (if master = """"). For a description; of the arguments see the TProof ctor. Returns the number of started; master or slave servers, returns 0 in case of error, in which case; fValid remains false. Int_t GetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); Set th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:35728,log,log,35728,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,1,['log'],['log']
Testability,"reak;; 1428 }else{; 1429 itTarget += cls+1;; 1430 testingEventVector->insert( itTarget, (*itEvent) ); // fill event; 1431 }; 1432 }; 1433 }; 1434 }else{; 1435 for( UInt_t cls = 0; cls < dsi.GetNClasses(); ++cls ){; 1436 trainingEventVector->insert( trainingEventVector->end(), tmpEventVector[Types::kTraining].at(cls).begin(), tmpEventVector[Types::kTraining].at(cls).end() );; 1437 testingEventVector->insert ( testingEventVector->end(), tmpEventVector[Types::kTesting].at(cls).begin(), tmpEventVector[Types::kTesting].at(cls).end() );; 1438 }; 1439 }; 1440 // delete the tmpEventVector (but not the events therein); 1441 tmpEventVector[Types::kTraining].clear();; 1442 tmpEventVector[Types::kTesting].clear();; 1443 ; 1444 tmpEventVector[Types::kMaxTreeType].clear();; 1445 ; 1446 if (mixMode == ""RANDOM"") {; 1447 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""shuffling events""<<Endl;; 1448 ; 1449 std::shuffle(trainingEventVector->begin(), trainingEventVector->end(), rndm);; 1450 std::shuffle(testingEventVector->begin(), testingEventVector->end(), rndm);; 1451 }; 1452 ; 1453 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""trainingEventVector "" << trainingEventVector->size() << Endl;; 1454 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""testingEventVector "" << testingEventVector->size() << Endl;; 1455 ; 1456 // create dataset; 1457 DataSet* ds = new DataSet(dsi);; 1458 ; 1459 // Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""Create internal training tree"" << Endl;; 1460 ds->SetEventCollection(trainingEventVector, Types::kTraining );; 1461 // Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""Create internal testing tree"" << Endl;; 1462 ds->SetEventCollection(testingEventVector, Types::kTesting );; 1463 ; 1464 ; 1465 if (ds->GetNTrainingEvents() < 1){; 1466 Log() << kFATAL << ""Dataset "" << std::string(dsi.GetName()) << "" does not have any training events, I better stop here and let you fix that one first "" << Endl;; 1467 }; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataSetFactory_8cxx_source.html:65925,test,testingEventVector,65925,doc/master/DataSetFactory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html,2,['test'],['testingEventVector']
Testability,"ream &os, const char *delimiter=""\n"", bool useTitle=false, bool useLatex=false);  Write the GraphViz representation of the expression tree headed by this RooAbsArg object to the given ostream. ;  ; bool hasClients () const;  ; bool hasDataToken () const;  ; virtual bool importWorkspaceHook (RooWorkspace &ws);  ; virtual bool isCategory () const;  ; bool isConstant () const;  Check if the ""Constant"" attribute is set. ;  ; virtual bool isReducerNode () const;  ; bool IsSortable () const override;  ; bool localNoDirtyInhibit () const;  ; const TNamed * namePtr () const;  De-duplicated pointer to this object's name. ;  ; Int_t numProxies () const;  Return the number of registered proxies. ;  ; bool observableOverlaps (const RooAbsData *dset, const RooAbsArg &testArg) const;  Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ;  ; bool observableOverlaps (const RooArgSet *depList, const RooAbsArg &testArg) const;  Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ;  ; RooAbsArg & operator= (const RooAbsArg &other)=delete;  ; bool overlaps (const RooAbsArg &testArg, bool valueOnly=false) const;  Test if any of the nodes of tree are shared with that of the given tree. ;  ; const RooArgSet * ownedComponents () const;  ; void Print (Option_t *options=nullptr) const override;  Print the object to the defaultPrintStream(). ;  ; void printAddress (std::ostream &os) const override;  Print address of this RooAbsArg. ;  ; void printArgs (std::ostream &os) const override;  Print object arguments, ie its proxies. ;  ; void printClassName (std::ostream &os) const override;  Print object class name. ;  ; void printCompactTree (const char *indent="""", const char *fileName=nullptr, const char *namePat=nullptr, RooAbsArg *client=nullptr);  Print tree structure of expression tree on stdout, or to file if filename is specified. ;  ; void printCompactTree (std::o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealVar.html:35881,test,testArg,35881,doc/master/classRooRealVar.html,https://root.cern,https://root.cern/doc/master/classRooRealVar.html,2,['test'],['testArg']
Testability,"reate or obtain the current viewer handle via the method:; TVirtualViewer3D * v = gPad->GetViewer3D(""type"");; Here the “type” string defines the viewer type - currently one of:. “ogl” : External GL viewer; “x3d”: External X3D viewer; “pad”: Pad viewer. If no type is passed (null string), and there is no current viewer, then the type is defaulted to “pad”. If no type is passed and there is a current viewer, then this is returned - hence once a viewer is created it can be obtained elsewhere by:; TVirtualViewer3D * v = gPad->GetViewer3D();; 9.13.4.2 Opening / Closing Scenes; Objects must be added to viewer between BeginScene() and EndScene() calls e.g.; viewer->BeginScene();; // Add objects; viewer ->EndScene();; These calls enable the viewer to suspend redraws, and perform internal caching/setup. If the object you attach to the pad derives from TAtt3D, then the pad will take responsibility for calling BeginScene() and EndScene() for you. You can always test if the scene is already open for object addition with:; viewer->BuildingScene();. Overview of 3D viewer architecture. Note: the x3d viewer does not support rebuilding of scenes - objects added after the first Open/Close Scene pair will be ignored.; 9.13.4.3 Describing Objects - Filling TBuffer3D; The viewers behind the TVirtualViewer3D interface differ greatly in their capabilities e.g. Some support native shape (e.g. spheres/tubes in OpenGL) and can draw these based on an abstract description. Others always require a tessellation description based on TBuffer3D’s kRaw / kRawSizes points/lines/segments sections.; Some need the 3D object positions in the master (world) frame, others can cope with local frames and a translation matrix to place the object.; Some require bounding boxes for objects - others do not. Similarly some viewer clients are only capable of providing positions in master frame, cannot provide bounding boxes etc. Additionally we do not want to incur the cost of expensive tessellation operations if t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:405337,test,test,405337,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['test'],['test']
Testability,"reate regression average deviation; : Results created; : Creating xml weight file: datasetcvreg/weights/TMVACrossValidationRegression_BDTG_fold2.weights.xml; <HEADER> Factory : Test all methods; <HEADER> Factory : Test method: BDTG_fold2 for Regression performance; : ; : Dataset[datasetcvreg] : Create results for testing; : Dataset[datasetcvreg] : Evaluation of BDTG_fold2 on testing sample; : Dataset[datasetcvreg] : Elapsed time for evaluation of 4999 events: 0.209 sec ; : Create variable histograms; : Create regression target histograms; : Create regression average deviation; : Results created; <HEADER> Factory : Evaluate all methods; : Evaluate regression method: BDTG_fold2; : TestRegression (testing); : Calculate regression for all events; : Elapsed time for evaluation of 4999 events: 0.208 sec ; : TestRegression (training); : Calculate regression for all events; : Elapsed time for evaluation of 5000 events: 0.208 sec ; : ; : Evaluation results ranked by smallest RMS on test sample:; : (""Bias"" quotes the mean deviation of the regression from true target.; : ""MutInf"" is the ""Mutual Information"" between regression and target.; : Indicated by ""_T"" are the corresponding ""truncated"" quantities ob-; : tained when removing events deviating more than 2sigma from average.); : --------------------------------------------------------------------------------------------------; : --------------------------------------------------------------------------------------------------; : datasetcvreg BDTG_fold2 : -0.0428 -0.0362 2.33 1.72 | 3.109 3.188; : --------------------------------------------------------------------------------------------------; : ; : Evaluation results ranked by smallest RMS on training sample:; : (overtraining check); : --------------------------------------------------------------------------------------------------; : DataSet Name: MVA Method: <Bias> <Bias_T> RMS RMS_T | MutInf MutInf_T; : ------------------------------------------------------------------",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidationRegression_8C.html:7953,test,test,7953,doc/master/TMVACrossValidationRegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidationRegression_8C.html,1,['test'],['test']
Testability,"reate"");; TTree* t2 = t1->Clone(0);; for (Int_t i = 0; i < 10; ++i) {; t1->GetEntry(i);; t2->Fill();; }; t2->Write(); delete f2;; f2 = 0;; delete f1;; f1 = 0;; f#define f(i)Definition RSha256.hxx:104; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TNamed::CloneTObject * Clone(const char *newname="""") const overrideMake a clone of an object using the Streamer facility.Definition TNamed.cxx:74; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::Fillvirtual Int_t Fill()Fill all branches.Definition TTree.cxx:4603; TTree::WriteInt_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0) overrideWrite this object to the current directory.Definition TTree.cxx:9753; int; f1TF1 * f1Definition legend1.C:11; t1auto * t1Definition textangle.C:20; An example of a branch with an object allocated by us, but owned by the caller: TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = 0;; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TBranchElementA Branch for the case of an object.Definition TBranchElement.h:39; TBranch::TTreefriend class TTreeDefinition TBranch.h:99; TBranch::FillInt_t Fill()Definition TBranch.h:205; forfor(Int_t i=0;i< n;i++)Definition legend1.C:18; Notice that the only difference between this example and the following example is that the event pointer is zero when the branch is created.; An example of a branch with an object allocated and owned by the caller: TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", """,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchElement.html:68871,test,test,68871,doc/master/classTBranchElement.html,https://root.cern,https://root.cern/doc/master/classTBranchElement.html,1,['test'],['test']
Testability,"reateCorrelationMatrixHist(const TMatrixD *m, const TString &hName, const TString &hTitle) constDefinition DataSetInfo.cxx:429; TMVA::DataSetInfo::GetListOfVariablesstd::vector< TString > GetListOfVariables() constreturns list of variablesDefinition DataSetInfo.cxx:406; TMVA::DataSetInfo::GetClassInfoClassInfo * GetClassInfo(Int_t clNum) constDefinition DataSetInfo.cxx:146; TMVA::DataSetInfo::GetCutconst TCut & GetCut(Int_t i) constDefinition DataSetInfo.h:168; TMVA::DataSetInfo::GetVariableInfoVariableInfo & GetVariableInfo(Int_t i)Definition DataSetInfo.h:105; TMVA::DataSetInfo::IsSignalBool_t IsSignal(const Event *ev) constDefinition DataSetInfo.cxx:167; TMVA::DataSetInfo::GetDataSetManagerDataSetManager * GetDataSetManager()Definition DataSetInfo.h:194; TMVA::DataSetManager::DataInputDataInputHandler & DataInput()Definition DataSetManager.h:76; TMVA::DataSetClass that contains all the data information.Definition DataSet.h:58; TMVA::DataSet::GetNEvtSigTestLong64_t GetNEvtSigTest()return number of signal test events in datasetDefinition DataSet.cxx:427; TMVA::DataSet::GetTreeTTree * GetTree(Types::ETreeType type)create the test/trainings tree with all the variables, the weights, the classes, the targets,...Definition DataSet.cxx:609; TMVA::DataSet::GetEventconst Event * GetEvent() constreturns event without transformationsDefinition DataSet.cxx:202; TMVA::DataSet::GetNEventsLong64_t GetNEvents(Types::ETreeType type=Types::kMaxTreeType) constDefinition DataSet.h:206; TMVA::DataSet::GetResultsResults * GetResults(const TString &, Types::ETreeType type, Types::EAnalysisType analysistype)Definition DataSet.cxx:265; TMVA::DataSet::GetNTrainingEventsLong64_t GetNTrainingEvents() constDefinition DataSet.h:68; TMVA::DataSet::SetCurrentTypevoid SetCurrentType(Types::ETreeType type) constDefinition DataSet.h:89; TMVA::DataSet::GetEventCollectionconst std::vector< Event * > & GetEventCollection(Types::ETreeType type=Types::kMaxTreeType) constDefinition DataSet.h:216; TMVA::Da",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:118531,test,test,118531,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['test'],['test']
Testability,"reated by event generators ;  CTPrincipalPrincipal Components Analysis (PCA) ;  CTProcessEventTimer;  CTProcessIDA TProcessID identifies a ROOT job in a unique way in time and space ;  CTProcessUUIDThis class is a specialized TProcessID managing the list of UUIDs ;  CTProfileProfile Histogram ;  CTProfile2DProfile2D histograms are used to display the mean value of Z and its RMS for each cell in X,Y ;  CTProfile2Poly;  CTProfile2PolyBin;  CTProfile3DProfile3D histograms are used to display the mean value of T and its RMS for each cell in X,Y,Z ;  CTProfileHelper;  ►CTProofThis class controls a Parallel ROOT Facility, PROOF, cluster ;  CMD5Mod_t;  CTProofBenchSteering class for PROOF benchmarks ;  CTProofBenchDataSetHandle operations on datasets used by ProofBench ;  CTProofBenchRunAbstract base class for PROOF benchmark runs ;  CTProofBenchRunCPUCPU-intensive PROOF benchmark test generates events and fill 1, 2, or 3-D histograms ;  CTProofBenchRunDataReadI/O-intensive PROOF benchmark test reads in event files distributed on the cluster ;  CTProofChain;  CTProofCondor;  CTProofDebug;  CTProofDesc;  CTProofDrawImplement Tree drawing using PROOF ;  CTProofDrawEntryList;  CTProofDrawEventList;  CTProofDrawGraph;  CTProofDrawHist;  ►CTProofDrawListOfGraphs;  CPoint3D_t;  ►CTProofDrawListOfPolyMarkers3D;  CPoint4D_t;  CTProofDrawPolyMarker3D;  CTProofDrawProfile;  CTProofDrawProfile2D;  CTProofInputHandler;  CTProofInterruptHandler;  CTProofLimitsFinderClass to find axis limits and synchronize them between workers ;  CTProofLiteThis class starts a PROOF session on the local machine: no daemons, client and master merged, communications via UNIX-like sockets ;  CTProofLockPath;  CTProofLockPathGuard;  CTProofLogImplementation of the PROOF session log handler ;  CTProofLogElem;  CTProofMergePrg;  CTProofMgrThe PROOF manager interacts with the PROOF server coordinator to create or destroy a PROOF session, attach to or detach from existing one, and to monitor any client activity",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:186609,test,test,186609,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,1,['test'],['test']
Testability,"reated physical 'shape' - add to internal map and take responsibility for deleting. ;  ; UInt_t BeginSmartRefresh ();  Moves logicals that support smart-refresh to intermediate cache. ;  ; virtual Bool_t BeginUpdate ();  Put scene in update mode, return true if lock acquired. ;  ; void CalcBoundingBox () const override;  Encapsulates all physical shapes bounding box with axes aligned box. ;  ; TSceneInfo * CreateSceneInfo (TGLViewerBase *view) override;  Create a scene-info instance appropriate for this scene class. ;  ; virtual Bool_t DestroyLogical (TObject *logid, Bool_t mustFind=kTRUE);  Destroy logical shape defined by unique 'ID'. ;  ; virtual Int_t DestroyLogicals ();  Destroy all logical shapes in scene. ;  ; virtual Bool_t DestroyPhysical (UInt_t phid);  Destroy physical shape defined by unique 'ID'. ;  ; virtual Int_t DestroyPhysicals ();  Destroy physical shapes. ;  ; void DumpMapSizes () const;  Print sizes of logical and physical-shape maps. ;  ; void EndSmartRefresh ();  Wipes logicals in refresh-cache. ;  ; virtual void EndUpdate (Bool_t minorChange=kTRUE, Bool_t sceneChanged=kTRUE, Bool_t updateViewers=kTRUE);  Exit scene update mode. ;  ; TGLLogicalShape * FindLogical (TObject *logid) const override;  Find and return logical shape identified by unique logid. ;  ; TGLLogicalShape * FindLogicalSmartRefresh (TObject *ID) const;  Find and return logical shape identified by unique 'ID' in refresh-cache. ;  ; virtual TGLPhysicalShape * FindPhysical (UInt_t phid) const;  Find and return physical shape identified by unique 'ID'. ;  ; TGLContextIdentity * GetGLCtxIdentity () const;  ; virtual UInt_t GetMaxPhysicalID ();  Returns the maximum used physical id. ;  ; void LodifySceneInfo (TGLRnrCtx &rnrCtx) override;  Setup LOD-dependant values in scene-info. ;  ; void PostDraw (TGLRnrCtx &rnrCtx) override;  Called after the rendering is finished. ;  ; void PreDraw (TGLRnrCtx &rnrCtx) override;  Initialize rendering. ;  ; void RebuildSceneInfo (TGLRnrCtx &rnrCtx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLScenePad.html:12296,log,logicals,12296,doc/master/classTGLScenePad.html,https://root.cern,https://root.cern/doc/master/classTGLScenePad.html,1,['log'],['logicals']
Testability,"rectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); const RooArgList&lowList() const; virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEva",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooJeffreysPrior.html:19777,log,logEvalError,19777,root/html532/RooJeffreysPrior.html,https://root.cern,https://root.cern/root/html532/RooJeffreysPrior.html,1,['log'],['logEvalError']
Testability,"rectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsReal&model() const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorIt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNumConvPdf.html:22140,log,logEvalError,22140,root/html532/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html532/RooNumConvPdf.html,1,['log'],['logEvalError']
Testability,"rectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsAnaConvPdf.html:22348,log,logEvalError,22348,root/html532/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsAnaConvPdf.html,9,['log'],['logEvalError']
Testability,"rectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual voidnormLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooResolutionModel.html:22153,log,logEvalError,22153,root/html532/RooResolutionModel.html,https://root.cern,https://root.cern/root/html532/RooResolutionModel.html,1,['log'],['logEvalError']
Testability,"rectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsSelfCachedPdf.html:20700,log,logEvalError,20700,root/html532/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsSelfCachedPdf.html,54,['log'],['logEvalError']
Testability,"rectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual voidRooResolutionModel::normLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCache",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAddModel.html:21163,log,logEvalError,21163,root/html532/RooAddModel.html,https://root.cern,https://root.cern/root/html532/RooAddModel.html,4,['log'],['logEvalError']
Testability,"rectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tminDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tmustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsPdf.html:23652,log,logEvalError,23652,root/html532/RooAbsPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsPdf.html,1,['log'],['logEvalError']
Testability,"rectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tmaxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooHistPdf.html:20575,log,logEvalError,20575,root/html532/RooHistPdf.html,https://root.cern,https://root.cern/root/html532/RooHistPdf.html,1,['log'],['logEvalError']
Testability,"rectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tmaxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEval",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCBShape.html:19762,log,logEvalError,19762,root/html532/RooCBShape.html,https://root.cern,https://root.cern/root/html532/RooCBShape.html,2,['log'],['logEvalError']
Testability,"rection. BernsteinCorrection is a utility in RooStats to augment a nominal PDF with a polynomial ; correction term. This is useful for incorporating systematic variations to the nominal PDF. ; The Bernstein basis polynomails are particularly appropriate because they are positive definite. . This tool was inspired by the work of Glen Cowan together with Stephan Horner, Sascha Caron, ; Eilam Gross, and others. ; The initial implementation is independent work. The major step forward in the approach was ; to provide a well defined algorithm that specifies the order of polynomial to be included ; in the correction. This is an emperical algorithm, so in addition to the nominal model it ; needs either a real data set or a simulated one. In the early work, the nominal model was taken; to be a histogram from Monte Carlo simulations, but in this implementation it is generalized to an; arbitrary PDF (which includes a RooHistPdf). The algorithm basically consists of a ; hypothesis test of an nth-order correction (null) against a n+1-th order correction (alternate). ; The quantity q = -2 log LR is used to determine whether the n+1-th order correction is a major ; improvement to the n-th order correction. The distribution of q is expected to be roughly ; \chi^2 with one degree of freedom if the n-th order correction is a good model for the data. ; Thus, one only moves to the n+1-th order correction of q is relatively large. The chance that ; one moves from the n-th to the n+1-th order correction when the n-th order correction ; (eg. a type 1 error) is sufficient is given by the Prob(\chi^2_1 > threshold). The constructor ; of this class allows you to directly set this tolerance (in terms of probability that the n+1-th; term is added unnecessarily). To do:; Add another method to the utility that will make the sampling distribution for -2 log lambda ; for various m vs. m+1 order corrections using a nominal model and perhaps having two ways of ; generating the toys (either via a hist",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__BernsteinCorrection.html:1313,test,test,1313,root/html526/RooStats__BernsteinCorrection.html,https://root.cern,https://root.cern/root/html526/RooStats__BernsteinCorrection.html,7,['test'],['test']
Testability,"red with:; Event *event = 0;; // event must be null or point to a valid object;; // it must be initialized; T.SetBranchAddress(""event"",&event);; When reading the Tree, one can choose one of these 3 options:; Option 1:; for (Int_t i = 0; i<nentries; i++) {; T.GetEntry(i);; //the object event has been filled at this point; }; This is the default and recommended way to create an object of the class Event.It will be pointed by event.; At the following entries, event will be overwritten by the new data. All internal members that are TObject* are automatically deleted. It is important that these members be in a valid state when GetEntry is called. Pointers must be correctly initialized. However these internal members will not be deleted if the characters “->” are specified as the first characters in the comment field of the data member declaration.; The pointer member is read via the pointer->Streamer(buf) if “->” is specified. In this case, it is assumed that the pointer is never null (see pointer TClonesArray *fTracks in the $ROOTSYS/test/Event example). If “->” is not specified, the pointer member is read via buf >> pointer. In this case the pointer may be null. Note that the option with “->” is faster to read or write and it also consumes less space in the file.; Option 2 - the option AutoDelete is set:; TBranch *branch = T.GetBranch(""event"");; branch->SetAddress(&event);; branch->SetAutoDelete(kTRUE);; for (Int_t i=0; i<nentries; i++) {; T.GetEntry(i); // the object event has been filled at this point; }; At any iteration, the GetEntry deletes the object event and a new instance of Event is created and filled.; Option 3 - same as option 1, but you delete the event yourself:; for (Int_t i=0; i<nentries; i++) {; delete event;; event = 0; //EXTREMELY IMPORTANT; T.GetEntry(i);; // the objrect event has been filled at this point; }; It is strongly recommended to use the default option 1. It has the additional advantage that functions like TTree::Draw (internally calling TT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:557549,test,test,557549,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['test'],['test']
Testability,"redirection options. OutputFile(const char*) -- Send output to file with given name. Multiple streams can write to same file.; OutputStream(ostream&) -- Send output to given C++ stream. Multiple message streams can write to same c++ stream. The return value is the unique ID code of the defined stream. void deleteStream(Int_t id); Delete stream with given unique ID code. void setStreamStatus(Int_t id, Bool_t active); (De)Activate stream with given unique ID. Bool_t getStreamStatus(Int_t id) const; Get activation status of stream with given unique ID. RooMsgService& instance(); Return reference to singleton instance. void saveState(); Save current state of message service. void restoreState(); Restore last saved state of message service. Bool_t isActive(const RooAbsArg* self, RooFit::MsgTopic facility, RooFit::MsgLevel level); Check if logging is active for given object/topic/RooFit::MsgLevel combination. Bool_t isActive(const TObject* self, RooFit::MsgTopic facility, RooFit::MsgLevel level); Check if logging is active for given object/topic/RooFit::MsgLevel combination. Int_t activeStream(const RooAbsArg* self, RooFit::MsgTopic facility, RooFit::MsgLevel level); Find appropriate logging stream for message from given object with given topic and message level. Int_t activeStream(const TObject* self, RooFit::MsgTopic facility, RooFit::MsgLevel level); Find appropriate logging stream for message from given object with given topic and message level. ostream& log(const RooAbsArg* self, RooFit::MsgLevel level, RooFit::MsgTopic facility, Bool_t forceSkipPrefix = kFALSE); Log error message associated with RooAbsArg object self at given level and topic. If skipPrefix; is true the standard RooMsgService prefix is not added. ostream& log(const TObject* self, RooFit::MsgLevel level, RooFit::MsgTopic facility, Bool_t forceSkipPrefix = kFALSE); Log error message associated with TObject object self at given level and topic. If skipPrefix; is true the standard RooMsgService prefix is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooMsgService.html:10585,log,logging,10585,root/html528/RooMsgService.html,https://root.cern,https://root.cern/root/html528/RooMsgService.html,6,['log'],['logging']
Testability,"reeType treeType, const TString& theVarName, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&); Bool_tTMVA::MethodBase::TxtWeightsOnly() const; Bool_tTMVA::MethodBase::Verbose() const; voidTMVA::Configurable::WriteOptionsReferenceToFile(). private:. virtual voidDeclareOptions(); voidGetCov_BetweenClass(); voidGetCov_Full(); voidGetCov_WithinClass(); voidGetDiscrimPower(); voidGetFisherCoeff(); voidGetMean(); virtual voidInit(); voidInitMatrices(); voidPrintCoefficients(); virtual voidProcessOptions(). Data Members; public:. enum EFisherMethod { kFisher; kMahalanobis; };; enum TMVA::MethodBase::EWeightFileType { kROOT; kTEXT; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. TMatrixD*fBetwbetween",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodFisher.html:17516,test,testing,17516,root/html530/TMVA__MethodFisher.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodFisher.html,2,['test'],['testing']
Testability,"reeType treeType, const TString& theVarName, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&); Bool_tTMVA::MethodBase::TxtWeightsOnly() const; Bool_tTMVA::MethodBase::Verbose() const; voidTMVA::Configurable::WriteOptionsReferenceToFile(). private:. virtual voidDeclareOptions(); voidGetCov_BetweenClass(); voidGetCov_Full(); voidGetCov_WithinClass(); voidGetDiscrimPower(); voidGetFisherCoeff(); voidGetMean(); virtual voidInit(); voidInitMatrices(); voidPrintCoefficients(); virtual voidProcessOptions(). Data Members; public:. enum EFisherMethod { kFisher; kMahalanobis; };; enum TMVA::MethodBase::EWeightFileType { kROOT; kTEXT; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in representative histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. TMatrixD*fBetwbetween-class matrix; TMatrixD*fCovfull covariance matrix; vector<Double_t>*fDiscrimPo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodFisher.html:16975,test,testing,16975,root/html528/TMVA__MethodFisher.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodFisher.html,1,['test'],['testing']
Testability,"reeType) const;  ; const TTree * GetEventCollectionAsTree ();  ; Long64_t GetNClassEvents (Int_t type, UInt_t classNumber);  ; Long64_t GetNEvents (Types::ETreeType type=Types::kMaxTreeType) const;  ; Long64_t GetNEvtBkgdTest ();  return number of background test events in dataset ;  ; Long64_t GetNEvtBkgdTrain ();  return number of background training events in dataset ;  ; Long64_t GetNEvtSigTest ();  return number of signal test events in dataset ;  ; Long64_t GetNEvtSigTrain ();  return number of signal training events in dataset ;  ; UInt_t GetNSpectators () const;  access the number of targets through the datasetinfo ;  ; UInt_t GetNTargets () const;  access the number of targets through the datasetinfo ;  ; Long64_t GetNTestEvents () const;  ; Long64_t GetNTrainingEvents () const;  ; UInt_t GetNVariables () const;  access the number of variables through the datasetinfo ;  ; Results * GetResults (const TString &, Types::ETreeType type, Types::EAnalysisType analysistype);  ; const Event * GetTestEvent (Long64_t ievt) const;  ; const Event * GetTrainingEvent (Long64_t ievt) const;  ; TTree * GetTree (Types::ETreeType type);  create the test/trainings tree with all the variables, the weights, the classes, the targets, the spectators, the MVA outputs ;  ; Bool_t HasNegativeEventWeights () const;  ; void IncrementNClassEvents (Int_t type, UInt_t classNumber);  ; void InitSampling (Float_t fraction, Float_t weight, UInt_t seed=0);  initialize random or importance sampling ;  ; virtual TClass * IsA () const;  ; void MoveTrainingBlock (Int_t blockInd, Types::ETreeType dest, Bool_t applyChanges=kTRUE);  move training block ;  ; void SetCurrentEvent (Long64_t ievt) const;  ; void SetCurrentType (Types::ETreeType type) const;  ; void SetEventCollection (std::vector< Event * > *, Types::ETreeType, Bool_t deleteEvents=true);  Sets the event collection (by DataSetFactory) ;  ; void SetVerbose (Bool_t);  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DataSet.html:2823,test,test,2823,doc/master/classTMVA_1_1DataSet.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DataSet.html,1,['test'],['test']
Testability,"ref counting; Bool_tTGLLogicalShape::fRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*TGLLogicalShape::fScene! scene where object is stored (can be zero!). private:. UInt_tfNbPols; vector<Double_t>fNormals; vector<Int_t>fPolyDesc; vector<Double_t>fVertices; static Bool_tfgEnforceTriangles. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLFaceSet(const TBuffer3D& buffer); constructor. void SetFromMesh(const RootCsg::TBaseMesh* m); Should only be done on an empty faceset object. void EnforceTriangles(); Use GLU tesselator to replace all polygons with N > 3 with triangles.; After this call polygon descriptions are changed.; New vertices are not expected -- exception is thrown if this is; requested by the triangulator. Support for adding of new vertices can be; provided. void DirectDraw(TGLRnrCtx& rnrCtx) const; Debug tracing. Int_t CheckPoints(const Int_t* source, Int_t* dest) const; CheckPoints. Bool_t Eq(const Double_t* p1, const Double_t* p2); test equality. void CalculateNormals(); CalculateNormals. Bool_t GetEnforceTriangles(); Get current state of static flag EnforceTriangles. void SetEnforceTriangles(Bool_t e); Set state of static flag EnforceTriangles.; When this is set, all tesselations will be automatically converted into; triangle-only meshes.; This is needed to export TGeo shapes and CSG meshes to external; triangle-mesh libraries that can not handle arbitrary polygons. std::vector<Double_t>& GetVertices(); { return fVertices; }. std::vector<Double_t>& GetNormals(); { return fNormals; }. std::vector<Int_t>& GetPolyDesc(); { return fPolyDesc; }. UInt_t GetNbPols(); { return fNbPols; }. void GLDrawPolys() const. » Author: Timur Pocheptsov 03/08/2004 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLFaceSet.h 37192 2010-12-02 15:54:26Z matevz $ » Last generated: 2010-12-02 22:33; This page has been automatically generated. For comments or suggestions regardi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLFaceSet.html:4641,test,test,4641,root/html528/TGLFaceSet.html,https://root.cern,https://root.cern/root/html528/TGLFaceSet.html,1,['test'],['test']
Testability,"ref counting; Bool_tTGLLogicalShape::fRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*TGLLogicalShape::fScene! scene where object is stored (can be zero!). private:. UInt_tfNbPols; vector<Double_t>fNormals; vector<Int_t>fPolyDesc; vector<Double_t>fVertices; static Bool_tfgEnforceTriangles. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLFaceSet(const TBuffer3D& buffer); constructor. void SetFromMesh(const RootCsg::TBaseMesh* m); Should only be done on an empty faceset object. void EnforceTriangles(); Use GLU tesselator to replace all polygons with N > 3 with triangles.; After this call polygon descriptions are changed.; New vertices are not expected -- exception is thrown if this is; requested by the triangulator. Support for adding of new vertices can be; provided. void DirectDraw(TGLRnrCtx& rnrCtx) const; Debug tracing. Int_t CheckPoints(const Int_t* source, Int_t* dest) const; CheckPoints. Bool_t Eq(const Double_t* p1, const Double_t* p2); test equality. void CalculateNormals(); CalculateNormals. Bool_t GetEnforceTriangles(); Get current state of static flag EnforceTriangles. void SetEnforceTriangles(Bool_t e); Set state of static flag EnforceTriangles.; When this is set, all tesselations will be automatically converted into; triangle-only meshes.; This is needed to export TGeo shapes and CSG meshes to external; triangle-mesh libraries that can not handle arbitrary polygons. std::vector<Double_t>& GetVertices(); { return fVertices; }. std::vector<Double_t>& GetNormals(); { return fNormals; }. std::vector<Int_t>& GetPolyDesc(); { return fPolyDesc; }. UInt_t GetNbPols(); { return fNbPols; }. void GLDrawPolys() const. » Author: Timur Pocheptsov 03/08/2004 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLFaceSet.h 37192 2010-12-02 15:54:26Z matevz $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regardi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGLFaceSet.html:4641,test,test,4641,root/html530/TGLFaceSet.html,https://root.cern,https://root.cern/root/html530/TGLFaceSet.html,1,['test'],['test']
Testability,"ref counting; Bool_tTGLLogicalShape::fRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*TGLLogicalShape::fScene! scene where object is stored (can be zero!). private:. UInt_tfNbPols; vector<Double_t>fNormals; vector<Int_t>fPolyDesc; vector<Double_t>fVertices; static Bool_tfgEnforceTriangles. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLFaceSet(const TBuffer3D& buffer); constructor. void SetFromMesh(const RootCsg::TBaseMesh* m); Should only be done on an empty faceset object. void EnforceTriangles(); Use GLU tesselator to replace all polygons with N > 3 with triangles.; After this call polygon descriptions are changed.; New vertices are not expected -- exception is thrown if this is; requested by the triangulator. Support for adding of new vertices can be; provided. void DirectDraw(TGLRnrCtx& rnrCtx) const; Debug tracing. Int_t CheckPoints(const Int_t* source, Int_t* dest) const; CheckPoints. Bool_t Eq(const Double_t* p1, const Double_t* p2); test equality. void CalculateNormals(); CalculateNormals. Bool_t GetEnforceTriangles(); Get current state of static flag EnforceTriangles. void SetEnforceTriangles(Bool_t e); Set state of static flag EnforceTriangles.; When this is set, all tesselations will be automatically converted into; triangle-only meshes.; This is needed to export TGeo shapes and CSG meshes to external; triangle-mesh libraries that can not handle arbitrary polygons. std::vector<Double_t>& GetVertices(); { return fVertices; }. std::vector<Double_t>& GetNormals(); { return fNormals; }. std::vector<Int_t>& GetPolyDesc(); { return fPolyDesc; }. UInt_t GetNbPols(); { return fNbPols; }. void GLDrawPolys() const. » Author: Timur Pocheptsov 03/08/2004 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLFaceSet.h 37192 2010-12-02 15:54:26Z matevz $ » Last generated: 2011-11-03 20:14; This page has been automatically generated. For comments or suggestions regardi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLFaceSet.html:4641,test,test,4641,root/html532/TGLFaceSet.html,https://root.cern,https://root.cern/root/html532/TGLFaceSet.html,1,['test'],['test']
Testability,"ref=""http://www.cplusplus.com/reference/random/ranlux48/"">std::ranlux48</a>). The drawback of this generator is its; 58slow generation time.; 59- TRandom2 is based on the Tausworthe generator of L'Ecuyer, and it has the advantage; 60of being fast and using only 3 words (of 32 bits) for the state. The period however is not impressively long, it is; 6110**26.; 62 ; 63Using the template TRandomGen class (template on the contained Engine type), it is possible to add any generator based; 64on the standard C++ random library (see the C++ <a href=""http://www.cplusplus.com/reference/random/"">random</a>; 65documentation.) or different variants of the MIXMAX generator using the ROOT::Math::MixMaxEngine. Some of the listed; 66generator above (e.g. TRandomMixMax256 or TRandomMT64) are convenient typedef's of generator built using the template; 67TRandomGen class.; 68 ; 69Please note also that this class (TRandom) implements also a very simple generator (linear congruential) with period =; 70\f$10^9\f$, known to have defects (the lower random bits are correlated) and it is failing the majority of the random; 71number generator tests. Therefore it should NOT be used in any statistical study.; 72 ; 73The following table shows some timings (in nanoseconds/call); 74for the random numbers obtained using a macbookpro 2.6 GHz Intel Core i7 CPU:; 75 ; 76 ; 77- TRandom 3 ns/call (but this is a very BAD Generator, not to be used); 78- TRandom2 5 ns/call; 79- TRandom3 5 ns/call; 80- ::TRandomMixMax 6 ns/call; 81- ::TRandomMixMax17 6 ns/call; 82- ::TRandomMT64 9 ns/call; 83- ::TRandomMixMax256 10 ns/call; 84- ::TRandomRanluxpp 14 ns/call; 85- ::TRandom1 80 ns/call; 86- ::TRandomRanlux48 250 ns/call; 87 ; 88The following methods are provided to generate random numbers distributed according to some basic distributions:; 89 ; 90- Exp(Double_t tau); 91- Integer(UInt_t imax); 92- Gaus(Double_t mean, Double_t sigma); 93- Rndm(); 94- Uniform(Double_t); 95- Landau(Double_t mean, Double_t sigma); 96-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRandom_8cxx_source.html:5579,test,tests,5579,doc/master/TRandom_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TRandom_8cxx_source.html,1,['test'],['tests']
Testability,"relative to the means of their own class (within-class matrix), and relative to the overall sample means (between-class matrix). The Fisher coefficients, \( F_i \), are then given by. \[; F_i = \frac{\sqrt{N_s N_b}}{N_s + N_b} \sum_{j=1}^{N_{SB}} W_{ij}^{-1} (\bar{X}_{Sj} - \bar{X}_{Bj}); \]. where in TMVA is set \( N_S = N_B \), so that the factor in front of the sum simplifies to \( \frac{1}{2}\). The Fisher discriminant then reads. \[; X_{Fi} = F_0 + \sum_{i=1}^{N_{SB}} F_i X_i; \]. The offset \( F_0 \) centers the sample mean of \( x_{Fi} \) at zero. Instead of using the within-class matrix, the Mahalanobis variant determines the Fisher coefficients as follows:. \[; F_i = \frac{\sqrt{N_s N_b}}{N_s + N_b} \sum_{j=1}^{N_{SB}} (W + B)_{ij}^{-1} (\bar{X}_{Sj} - \bar{X}_{Bj}); \]. with resulting \( x_{Ma} \) that are very similar to the \( x_{Fi} \).; TMVA provides two outputs for the ranking of the input variables:. Fisher test: the Fisher analysis aims at simultaneously maximising the between-class separation, while minimising the within-class dispersion. A useful measure of the discrimination power of a variable is hence given by the diagonal quantity: \( \frac{B_{ii}}{W_{ii}} \) .; Discrimination power: the value of the Fisher coefficient is a measure of the discriminating power of a variable. The discrimination power of set of input variables can therefore be measured by the scalar. \[; \lambda = \frac{\sqrt{N_s N_b}}{N_s + N_b} \sum_{j=1}^{N_{SB}} F_i (\bar{X}_{Sj} - \bar{X}_{Bj}); \]. The corresponding numbers are printed on standard output. ; Definition at line 54 of file MethodFisher.h. Public Types; enum  EFisherMethod { kFisher; , kMahalanobis; };  ;  Public Types inherited from TMVA::MethodBase; enum  EWeightFileType { kROOT =0; , kTEXT; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1UL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodFisher.html:2520,test,test,2520,doc/master/classTMVA_1_1MethodFisher.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodFisher.html,1,['test'],['test']
Testability,"rement bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TRandom3Random number generator class based on M.Definition TRandom3.h:27; TRandom::Rannorvirtual void Rannor(Float_t &a, Float_t &b)Return 2 numbers distributed following a gaussian with mean=0 and sigma=1.Definition TRandom.cxx:507; TStyle::SetOptTitlevoid SetOptTitle(Int_t tit=1)Definition TStyle.h:334; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; double; int; h1TH1F * h1Definition legend1.C:5; . ; void thstackpalettecolor(); {; auto hs = new THStack(""hs"",""Stacked 1D histograms colored using kOcean palette"");; ; gStyle->SetPalette(kOcean);; ; // Create three 1-d histograms and add them in the stack; auto h1st = new TH1F(""h1st"",""test hstack"",100,-4,4);; h1st->FillRandom(""gaus"",20000);; hs->Add(h1st);; ; auto h2st = new TH1F(""h2st"",""test hstack"",100,-4,4);; h2st->FillRandom(""gaus"",15000);; hs->Add(h2st);; ; auto h3st = new TH1F(""h3st"",""test hstack"",100,-4,4);; h3st->FillRandom(""gaus"",10000);; hs->Add(h3st);; ; // draw the stack; hs->Draw(""pfc nostack"");; }; kOcean@ kOceanDefinition TColor.h:119; THStackThe Histogram stack class.Definition THStack.h:40; TStyle::SetPalettevoid SetPalette(Int_t ncolors=kBird, Int_t *colors=nullptr, Float_t alpha=1.)See TColor::SetPalette.Definition TStyle.cxx:1888; . ; void thstack2palettecolor() ; {; gStyle->SetPalette(1);; auto h1 = new TH2F(""h1"",""h1"",20,0,6,20,-4,4);; auto h2 = new TH2F(""h2"",""h2"",20,0,6,20,-4,4);; auto h3 = new TH2F(""h3"",""h3"",20,0,6,20,-4,4);; auto h4 = new TH2F(""h4"",""h4"",20,0,6,20,-4,4);; auto h5 = new TH2F(""h5"",""h5"",20,0,6,20,-4,4);; h2->Fill(2.,0.,5);; h3->Fill(3.,0.,10);; h4->Fill(4.,0.,15);; h5->Fill(5.,0.,20);; auto hs = new THStack(""hs"",""Test of palette colored lego stack"");; hs->Add(h1);; hs->Add(h2);; hs->Add(h3);; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:19902,test,test,19902,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,3,['test'],['test']
Testability,"rence Guide ; .  . Loading...; Searching...; No Matches. Files ; Net tutorialsTutorials. ; Examples showing the net classes. . Files; file  authclient.C;  This macro should be run together with authserv.C to test authentication between two remote ROOT sessions. ;  ; file  authserv.C;  This macro should be run together with authclient.C to test authentication between two remote ROOT sessions. ;  ; file  fastMergeServer.C;  This script shows how to make a simple iterative server that can receive TMemFile from multiple clients and merge them into a single file without block. ;  ; file  hclient.C;  Client program which creates and fills a histogram. ;  ; file  hcons.C;  Histogram consumer script. ;  ; file  hprod.C;  Histogram producer script. ;  ; file  hserv.C;  Server program which waits for two clients to connect. ;  ; file  hserv2.C;  This script shows how to make a simple iterative server that can accept connections while handling currently open connections. ;  ; file  parallelMergeClient.C;  Client program which creates and fills 2 histograms and a TTree. ;  ; file  parallelMergeServer.C;  This script shows how to make a simple iterative server that can accept connections while handling currently open connections. ;  ; file  parallelMergeTest.C;  ; file  pclient.C;  Client program to test parallel sockets. ;  ; file  pserv.C;  Server program to test parallel sockets. ;  ; file  spy.C;  Client program which allows the snooping of objects from a spyserv process. ;  ; file  spyserv.C;  Server program which allows clients, ""spies"", to connect and snoop objects. ;  ; file  TestAuth.C;  Macro test authentication methods stand alone. ;  ; file  testTUDPSocket.C;  As test echo server use udpserver.c in the same directory. ;  ; file  treeClient.C;  Client program which creates and fills 2 histograms and a TTree. ;  ; file  TUriTest.C;  Rudimentary TUri test macro. ;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:34 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__net.html:1355,test,test,1355,doc/master/group__tutorial__net.html,https://root.cern,https://root.cern/doc/master/group__tutorial__net.html,6,['test'],"['test', 'testTUDPSocket']"
Testability,"rence Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Private Member Functions |; Private Attributes |; List of all members ; TMVA::MethodPyTorch Class Reference. . Definition at line 34 of file MethodPyTorch.h. Public Member Functions;  MethodPyTorch (const TString &jobName, const TString &methodTitle, DataSetInfo &dsi, const TString &theOption="""");  ;  MethodPyTorch (DataSetInfo &dsi, const TString &theWeightFile);  ;  ~MethodPyTorch ();  ; virtual void AddWeightsXMLTo (void *) const;  ; const Ranking * CreateRanking ();  ; void DeclareOptions ();  ; void GetHelpMessage () const;  ; std::vector< Float_t > & GetMulticlassValues ();  ; Double_t GetMvaValue (Double_t *errLower, Double_t *errUpper);  ; std::vector< Double_t > GetMvaValues (Long64_t firstEvt, Long64_t lastEvt, Bool_t logProgress);  get all the MVA values for the events of the current Data type ;  ; std::vector< Float_t > & GetRegressionValues ();  ; Bool_t HasAnalysisType (Types::EAnalysisType type, UInt_t numberClasses, UInt_t);  ; void Init ();  ; void ProcessOptions ();  ; void ReadModelFromFile ();  ; virtual void ReadWeightsFromStream (std::istream &);  ; virtual void ReadWeightsFromStream (TFile &);  ; virtual void ReadWeightsFromXML (void *);  ; virtual void TestClassification ();  initialization ;  ; void Train ();  ;  Public Member Functions inherited from TMVA::PyMethodBase;  PyMethodBase (const TString &jobName, Types::EMVA methodType, const TString &methodTitle, DataSetInfo &dsi, const TString &theOption="""");  ;  PyMethodBase (Types::EMVA methodType, DataSetInfo &dsi, const TString &weightFile);  ; virtual ~PyMethodBase ();  ; PyObject * Eval (TString code);  Evaluate Python code. ;  ; virtual TClass * IsA () const;  ; virtual void Streamer (TBuffer &);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TMVA::MethodBase;  MethodBase (const TString &jobName, Types::EMVA methodType, co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodPyTorch.html:914,log,logProgress,914,doc/master/classTMVA_1_1MethodPyTorch.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodPyTorch.html,1,['log'],['logProgress']
Testability,"rence frame. After; building the full geometry tree, the geometry must be closed; (see TGeoManager::CloseGeometry()). Voxelization can be redone per volume after; this process. Below is the general scheme of the manager class. /*. */. An interactive session. Provided that a geometry was successfully built and closed (for instance the; previous example $ROOTSYS/tutorials/geom/rootgeom.C ), the manager class will register; itself to ROOT and the logical/physical structures will become immediately browsable.; The ROOT browser will display starting from the geometry folder : the list of; transformations and media, the top volume and the top logical node. These last; two can be fully expanded, any intermediate volume/node in the browser being subject; of direct access context menu operations (right mouse button click). All user; utilities of classes TGeoManager, TGeoVolume and TGeoNode can be called via the; context menu. /*. */. --- Drawing the geometry. Any logical volume can be drawn via TGeoVolume::Draw() member function.; This can be direcly accessed from the context menu of the volume object; directly from the browser.; There are several drawing options that can be set with; TGeoManager::SetVisOption(Int_t opt) method :; opt=0 - only the content of the volume is drawn, N levels down (default N=3).; This is the default behavior. The number of levels to be drawn can be changed; via TGeoManager::SetVisLevel(Int_t level) method. /*. */. opt=1 - the final leaves (e.g. daughters with no containment) of the branch; starting from volume are drawn down to the current number of levels.; WARNING : This mode is memory consuming; depending of the size of geometry, so drawing from top level within this mode; should be handled with care for expensive geometries. In future there will be; a limitation on the maximum number of nodes to be visualized. /*. */. opt=2 - only the clicked volume is visualized. This is automatically set by; TGeoVolume::DrawOnly() method; opt=3 - only a giv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoManager.html:7888,log,logical,7888,root/html528/TGeoManager.html,https://root.cern,https://root.cern/root/html528/TGeoManager.html,6,['log'],['logical']
Testability,"renced enum valueTObject; kIsSortedX enum valueTGraph; kMustCleanup enum valueTObject; kNoContextMenu enum valueTObject; kNoStats enum valueTGraph; kNotDeleted enum valueTObject; kNotEditable enum valueTGraph; kObjInCanvas enum valueTObject; kOnlyPrepStep enum valueTObjectprotected; kOverwrite enum valueTObject; kResetHisto enum valueTGraph; kSingleKey enum valueTObject; kWriteDelete enum valueTObject; kZombie enum valueTObject; LeastSquareFit(Int_t m, Double_t *a, Double_t xmin=0, Double_t xmax=0)TGraphvirtual; LeastSquareLinearFit(Int_t n, Double_t &a0, Double_t &a1, Int_t &ifail, Double_t xmin=0, Double_t xmax=0)TGraphvirtual; ls(Option_t *option="""") const overrideTNamedvirtual; MakeZombie()TObjectinlineprotected; MayNotUse(const char *method) constTObject; Merge(TCollection *list) overrideTGraphErrorsvirtual; TAttLine::Modify()TAttLinevirtual; TAttFill::Modify()TAttFillvirtual; TAttMarker::Modify()TAttMarkervirtual; MovePoints(Double_t dx, Double_t dy, Bool_t logx=kFALSE, Bool_t logy=kFALSE)TGraphvirtual; Notify()TObjectvirtual; Obsolete(const char *method, const char *asOfVers, const char *removedFromVers) constTObject; operator delete(void *ptr)TObject; operator delete(void *ptr, void *vp)TObject; operator delete[](void *ptr)TObject; operator delete[](void *ptr, void *vp)TObject; operator new(size_t sz)TObjectinline; operator new(size_t sz, void *vp)TObjectinline; operator new[](size_t sz)TObjectinline; operator new[](size_t sz, void *vp)TObjectinline; operator=(const TGraphErrors &gr)TGraphErrors; TGraph::operator=(const TGraph &)TGraph; TNamed::operator=(const TNamed &rhs)TNamed; TObject::operator=(const TObject &rhs)TObjectinline; Paint(Option_t *chopt="""") overrideTGraphvirtual; PaintGraph(Int_t npoints, const Double_t *x, const Double_t *y, Option_t *chopt)TGraph; PaintGrapHist(Int_t npoints, const Double_t *x, const Double_t *y, Option_t *chopt)TGraph; PaintStats(TF1 *fit)TGraphvirtual; Pop()TObjectvirtual; Print(Option_t *chopt="""") const overrideTGraphErr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphErrors-members.html:9461,log,logy,9461,doc/master/classTGraphErrors-members.html,https://root.cern,https://root.cern/doc/master/classTGraphErrors-members.html,2,['log'],['logy']
Testability,"repCheckCmdcheckbox active if piping; TGCheckButton*fGrepCheckInvcheckbox active if inverting; TGLabel*fGrepLabellabel indicating if grepping or piping; TGTextEntry*fGrepTexttext to grep for in the logs; TGNumberEntry*fLinesFromstarting line; TGNumberEntry*fLinesToending line; TGListBox*fLogListlist of workers; TGTextButton*fLogNewdisplay logs button; TProofLog*fProofLogthe log; TGCheckButton*fRawLinesdisplay raw lines button; TGTextButton*fSavesave button; TGNumberEntry*fSessNumrelative index of the session to get; Int_tfSessionIdx; TStringfSessionUrl; TGTextView*fTexttext widget; Int_tfTextTypeType of retrieval; TGTextButton*fUrlButtonrebuild button; TGTextEntry*fUrlTexturl to connect to; TGVerticalFrame*fVworkersVertical frame; static TProofProgressLog::ETextTypekGrep; static TProofProgressLog::ETextTypekRaw; static TProofProgressLog::ETextTypekStd. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressLog(TProofProgressDialog* d, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. TProofProgressLog(const char* url = 0, Int_t sessionidx = 0, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. void Init(Int_t w = 700, Int_t h = 600); Init window frame for log messages. ~TProofProgressLog(); Destructor. void Popup(); Show log window. void Clear(Option_t* = 0); Clear log window. void LoadBuffer(const char* buffer); Load a text buffer in the window. void LoadFile(const char* file); Load a file in the window. void AddBuffer(const char* buffer); Add text to the window. void CloseWindow(); Handle close button or when closed via window manager action. void BuildLogList(Bool_t create = kFALSE); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void DoLog(Bool_t grep = kFALSE); Display logs. 'grep' is set to kTRUE if it is invoked by pressing the; 'Filter' button. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the lo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofProgressLog.html:25025,log,log,25025,root/html602/TProofProgressLog.html,https://root.cern,https://root.cern/root/html602/TProofProgressLog.html,2,['log'],['log']
Testability,"representing.; 2884/// and return ROOT::kNotSTL if it is not representing an STL collection.; 2885 ; 2886ROOT::ESTLType TClass::GetCollectionType() const; 2887{; 2888 auto proxy = GetCollectionProxy();; 2889 if (proxy) return (ROOT::ESTLType)proxy->GetCollectionType();; 2890 return ROOT::kNotSTL;; 2891}; 2892 ; 2893 ; 2894////////////////////////////////////////////////////////////////////////////////; 2895/// Return the proxy describing the collection (if any).; 2896 ; 2897TVirtualCollectionProxy *TClass::GetCollectionProxy() const; 2898{; 2899 // Use assert, so that this line (slow because of the TClassEdit) is completely; 2900 // removed in optimized code.; 2901 //assert(TestBit(kLoading) || !TClassEdit::IsSTLCont(fName) || fCollectionProxy || 0 == ""The TClass for the STL collection has no collection proxy!"");; 2902 if (gThreadTsd && fCollectionProxy) {; 2903 TClassLocalStorage *local = TClassLocalStorage::GetStorage(this);; 2904 if (local == nullptr) return fCollectionProxy;; 2905 if (local->fCollectionProxy==nullptr) local->fCollectionProxy = fCollectionProxy->Generate();; 2906 return local->fCollectionProxy;; 2907 }; 2908 return fCollectionProxy;; 2909}; 2910 ; 2911////////////////////////////////////////////////////////////////////////////////; 2912/// Return the Streamer Class allowing streaming (if any).; 2913 ; 2914TClassStreamer *TClass::GetStreamer() const; 2915{; 2916 if (gThreadTsd && fStreamer) {; 2917 TClassLocalStorage *local = TClassLocalStorage::GetStorage(this);; 2918 if (local==nullptr) return fStreamer;; 2919 if (local->fStreamer==nullptr) {; 2920 local->fStreamer = fStreamer->Generate();; 2921 const std::type_info &orig = ( typeid(*fStreamer) );; 2922 if (!local->fStreamer) {; 2923 Warning(""GetStreamer"",""For %s, the TClassStreamer (%s) passed's call to Generate failed!"",GetName(),orig.name());; 2924 } else {; 2925 const std::type_info &copy = ( typeid(*local->fStreamer) );; 2926 if (strcmp(orig.name(),copy.name())!=0) {; 2927 Warning(""GetStream",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:108314,assert,assert,108314,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['assert'],['assert']
Testability,"representing.; 2951/// and return ROOT::kNotSTL if it is not representing an STL collection.; 2952 ; 2953ROOT::ESTLType TClass::GetCollectionType() const; 2954{; 2955 auto proxy = GetCollectionProxy();; 2956 if (proxy) return (ROOT::ESTLType)proxy->GetCollectionType();; 2957 return ROOT::kNotSTL;; 2958}; 2959 ; 2960 ; 2961////////////////////////////////////////////////////////////////////////////////; 2962/// Return the proxy describing the collection (if any).; 2963 ; 2964TVirtualCollectionProxy *TClass::GetCollectionProxy() const; 2965{; 2966 // Use assert, so that this line (slow because of the TClassEdit) is completely; 2967 // removed in optimized code.; 2968 //assert(TestBit(kLoading) || !TClassEdit::IsSTLCont(fName) || fCollectionProxy || 0 == ""The TClass for the STL collection has no collection proxy!"");; 2969 if (gThreadTsd && fCollectionProxy) {; 2970 TClassLocalStorage *local = TClassLocalStorage::GetStorage(this);; 2971 if (local == nullptr) return fCollectionProxy;; 2972 if (local->fCollectionProxy==nullptr) local->fCollectionProxy = fCollectionProxy->Generate();; 2973 return local->fCollectionProxy;; 2974 }; 2975 return fCollectionProxy;; 2976}; 2977 ; 2978////////////////////////////////////////////////////////////////////////////////; 2979/// Return the Streamer Class allowing streaming (if any).; 2980 ; 2981TClassStreamer *TClass::GetStreamer() const; 2982{; 2983 if (gThreadTsd && fStreamer) {; 2984 TClassLocalStorage *local = TClassLocalStorage::GetStorage(this);; 2985 if (local==nullptr) return fStreamer;; 2986 if (local->fStreamer==nullptr) {; 2987 local->fStreamer = fStreamer->Generate();; 2988 const std::type_info &orig = ( typeid(*fStreamer) );; 2989 if (!local->fStreamer) {; 2990 Warning(""GetStreamer"",""For %s, the TClassStreamer (%s) passed's call to Generate failed!"",GetName(),orig.name());; 2991 } else {; 2992 const std::type_info &copy = ( typeid(*local->fStreamer) );; 2993 if (strcmp(orig.name(),copy.name())!=0) {; 2994 Warning(""GetStream",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:111065,assert,assert,111065,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['assert'],['assert']
Testability,"res.; New tutorials and code examples have been provided. The simplest example showing the integration of ROOT with the notebook technology can be found here and many more snippets here.; Support for capturing large outputs (stderr/stdout) coming from C++ libraries has been added.; JavaScript ROOT. support registered in THttpServer commands with arguments.; provide workaround for websites using require.js and older jquery-ui; support custom requests to remote objects, demonstrated in httptextlog.C tutorial; rewrite draw.htm (page for individual object drawing) to support all custom features as main gui does; See also the JSRoot 3.9 examples page and the JSRoot 3.9 release notes. Class Reference Guide; The ROOT reference guide is moving to the Doxygen system. Doxygen is the de-facto standard for code documentation. It offers many nice features we are now exploring and trying to get the best of them. Having MathJax rendered math formula is one of them. The documentation can be structured in a more logical way using groups. Still there is a lot to do but big progresses have been done. We developed also a Doxygen filter allowing to execute macros given as examples in the documentation and show the resulting picture directly in the documentation.; Tutorials; The tutorials in $ROOTSYS/tutorials are also presented on the web thanks to Doxygen. They are now part of the reference guide allowing nice cross-referencing with the classes documentation. Here also a filter has been developed to generate the resulting picture.; Build, Configuration and Testing Infrastructure; ROOT uses the CMake cross-platform build-generator tool as a primary build system. CMake does not build the project, it generates the files needed by your build tool (GNU make, Ninja, Visual Studio, etc) for building ROOT. The classic build with configure/make is is still available but it will not be evolving with the new features of ROOT.; We added full support for C++14.; Minor changes in the build system:. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:23065,log,logical,23065,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['log'],['logical']
Testability,"resentative histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Int_tfAverageEvtPerBinaverage events per bin; used to calculate fNbins; Int_t*fAverageEvtPerBinVarBaverage events per bin; used to calculate fNbins; Int_t*fAverageEvtPerBinVarSaverage events per bin; used to calculate fNbins; TStringfBorderMethodStringthe method to take care about ""border"" effects (string); TMVA::PDF*fDefaultPDFLikpdf that contains default definitions; Int_tfDropVariablefor ranking test; Double_tfEpsilonminimum number of likelihood (to avoid zero); vector<TH1*>*fHistBgdbackground PDFs (histograms); vector<TH1*>*fHistBgd_smoothbackground PDFs (smoothed histograms); vector<TH1*>*fHistSigsignal PDFs (histograms); vector<TH1*>*fHistSig_smoothsignal PDFs (smoothed histograms); TString*fInterpolateStringwhich interpolation method used for reference histograms (individual for each variable); Float_tfKDEfineFactorfine tuning factor for Adaptive KDE; TStringfKDEiterStringNumber of iterations (string); TStringfKDEtypeStringKernel type to use for KDE (string); Int_tfNsmoothnumber of smooth passes; Int_t*fNsmoothVarBnumber of smooth passes; Int_t*fNsmoothVarSnumber of smooth passes; vector<PDF*>*fPDFBgdlist of PDFs (background); vector<PDF*>*fPDFSiglist of PDFs (signal) ; Bool_tfTransformLikelihoodOutputlikelihood output is sigmoid-transformed. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodLikelihood(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); standard constructor. MethodLikelihood(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodLikelihood.html:18176,test,test,18176,root/html528/TMVA__MethodLikelihood.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodLikelihood.html,1,['test'],['test']
Testability,"resize (all others). The expected values are: . Implements TVirtualPad.; Definition at line 6350 of file TPad.cxx. ◆ StartEditing(). virtual void TPad::StartEditing ; (; ). inlinevirtual . Definition at line 417 of file TPad.h. ◆ Streamer(). void TPad::Streamer ; (; TBuffer & ; b). overridevirtual . Stream a class object. ; Reimplemented from TObject.; Reimplemented in TSlider.; Definition at line 6713 of file TPad.cxx. ◆ StreamerNVirtual(). void TPad::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 419 of file TPad.h. ◆ Update(). void TPad::Update ; (; ). overridevirtual . Update pad. ; Implements TVirtualPad.; Definition at line 2935 of file TPad.cxx. ◆ UpdateAsync(). void TPad::UpdateAsync ; (; ). overridevirtual . Asynchronous pad update. ; In case of web-based canvas triggers update of the canvas on the client side, but does not wait that real update is completed. Avoids blocking of caller thread. Have to be used if called from other web-based widget to avoid logical dead-locks. In case of normal canvas just canvas->Update() is performed. ; Implements TVirtualPad.; Definition at line 2947 of file TPad.cxx. ◆ UseCurrentStyle(). void TPad::UseCurrentStyle ; (; ). overridevirtual . Force a copy of current style for all objects in pad. ; Reimplemented from TObject.; Definition at line 6927 of file TPad.cxx. ◆ UtoAbsPixel(). Int_t TPad::UtoAbsPixel ; (; Double_t ; u); const. overridevirtual . Convert X NDC to absolute pixel. ; Implements TVirtualPad.; Definition at line 7459 of file TPad.cxx. ◆ UtoPixel(). Int_t TPad::UtoPixel ; (; Double_t ; u); const. overridevirtual . Convert X NDC to pixel. ; Implements TVirtualPad.; Definition at line 7433 of file TPad.cxx. ◆ VtoAbsPixel(). Int_t TPad::VtoAbsPixel ; (; Double_t ; v); const. overridevirtual . Convert Y NDC to absolute pixel. ; Implements TVirtualPad.; Definition at line 7467 of file TPad.cxx. ◆ VtoPixel(). Int_t TPad::VtoPixel ; (; Double_t ; v); const. overridevirtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPad.html:127599,log,logical,127599,doc/master/classTPad.html,https://root.cern,https://root.cern/doc/master/classTPad.html,1,['log'],['logical']
Testability,"ressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); TSlave*TProof::CreateSlave(const char* url, const char* ord, Int_t perf, const char* image, const char* workdir); TSlave*TProof::CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd, Int_t nwk = 1); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; static Bool_tTProof::GetFileInCmd(const char* cmd, TString& fn); static Int_tTProof::GetInputData(TList* input, const char* cachedir, TString& emsg); TStringGetJobAd(); TList*TProof::GetListOfActiveSlaves() const; TVirtualProofPlayer*TProof::GetPlayer() const; TPluginHandler*TProof::GetProgressDialog() const; Int_tTProof::GetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTProof::HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tTProof::HandleOutputOptions(TString& opt, TString& target, Int_t action); Int_tTProof::Init(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidTProof::InitMembers(); virtual TVirtualProofPlayer*TProof::MakePlayer(const char* player = 0, TSocket* s = 0); voidTObject::MakeZombie(); voidTProof::PrepareInputDataFile(TString& dataFile); Int_tTProof::RemoveWorkers(TList* wrks); static Int_tTProof::SaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidTProof::SaveWorkerInfo(); Int_tTProof::SendFile(const char* file, Int_t opt = (kBinary | kForward | kCp | kCpBin), const char* rfile = 0, TSlave* sl = 0); static Int_tTProof::SendInputData(TQueryResult* qr, TProof* p, TString& emsg); virtual voidTProof::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofCondor.html:21952,assert,assert,21952,root/html602/TProofCondor.html,https://root.cern,https://root.cern/root/html602/TProofCondor.html,1,['assert'],['assert']
Testability,"ression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. private:. TStringfDefaultPromptdefault prompt: ""root [%d] ""; TFileHandler*fInputHandlerterminal input handler; Bool_tfInterruptif true macro execution will be stopped; Int_tfNcmdcommand history number; charfPrompt[64]interpreter prompt. Class Charts. Inheritance Chart:. TObject. TQObject. ←; TApplication. ←; TRint. Function documentation; TRint(const char* appClassName, int* argc, char** argv, void* options = 0, int numOptions = 0, Bool_t noLogo = kFALSE); Create an application environment. The TRint environment provides an; interface to the WM manager functionality and eventloop via inheritance; of TApplication and in addition provides interactive access to; the CINT C++ interpreter via the command line. ~TRint(); Destructor. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. void Run(Bool_t retrn = kFALSE); Main application eventloop. First process files given on the command; line and then go into the main application event loop, unless the -q; command line option was specfied in which case the program terminates.; When retrun is true this method returns even when -q was specified. When QuitOpt is true and retrn is false, terminate the application with; an error code equal to either the ProcessLine error (if any) or the; return value of the command casted to a long. void PrintLogo(Bool_t lite = kFALSE); Print the ROOT logo on standard output. char * GetPrompt(); Get prompt from interpreter. Either ""root [n]""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRint.html:13796,log,logon,13796,root/html602/TRint.html,https://root.cern,https://root.cern/root/html602/TRint.html,2,['log'],['logon']
Testability,"ressminimum value; maxProgressmaximum value . Definition at line 790 of file NeuralNet.h. ◆ startTestCycle(). virtual void TMVA::DNN::Settings::startTestCycle ; (; ). inlinevirtual . callback for monitoring and loggging ; Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 804 of file NeuralNet.h. ◆ startTrainCycle(). virtual void TMVA::DNN::Settings::startTrainCycle ; (; ). inlinevirtual . Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 782 of file NeuralNet.h. ◆ startTraining(). virtual void TMVA::DNN::Settings::startTraining ; (; ). inlinevirtual . Definition at line 795 of file NeuralNet.h. ◆ testIteration(). virtual void TMVA::DNN::Settings::testIteration ; (; ). inlinevirtual . callback for monitoring and loggging ; Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 806 of file NeuralNet.h. ◆ testRepetitions(). size_t TMVA::DNN::Settings::testRepetitions ; (; ); const. inline . how often is the test data tested ; Definition at line 768 of file NeuralNet.h. ◆ testSample(). virtual void TMVA::DNN::Settings::testSample ; (; double ; , . double ; , . double ; , . double ;  . ). inlinevirtual . virtual function to be used for monitoring (callback) ; Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 781 of file NeuralNet.h. ◆ useMultithreading(). bool TMVA::DNN::Settings::useMultithreading ; (; ); const. inline . is multithreading turned on? ; Definition at line 815 of file NeuralNet.h. Member Data Documentation. ◆ count_dE. size_t TMVA::DNN::Settings::count_dE. Definition at line 843 of file NeuralNet.h. ◆ count_E. size_t TMVA::DNN::Settings::count_E. Definition at line 842 of file NeuralNet.h. ◆ count_mb_dE. size_t TMVA::DNN::Settings::count_mb_dE. Definition at line 845 of file NeuralNet.h. ◆ count_mb_E. size_t TMVA::DNN::Settings::count_mb_E. Definition at line 844 of file NeuralNet.h. ◆ fLearningRate. double TMVA::DNN::Settings::fLearningRate. Definition at line 852 of file N",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html:12549,test,test,12549,doc/master/classTMVA_1_1DNN_1_1Settings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html,2,['test'],"['test', 'tested']"
Testability,"return tanh(x); }. Double_t ASin(Double_t x). Double_t ACos(Double_t x). Double_t ATan(Double_t x); { return atan(x); }. Double_t ATan2(Double_t y, Double_t x). Double_t Sqrt(Double_t x); { return sqrt(x); }. Double_t Ceil(Double_t x); { return ceil(x); }. Int_t CeilNint(Double_t x); { return TMath::Nint(ceil(x)); }. Double_t Floor(Double_t x); { return floor(x); }. Int_t FloorNint(Double_t x); { return TMath::Nint(floor(x)); }. Int_t Nint(T x); Round to nearest integer. Rounds half integers to the nearest; even integer. Double_t Exp(Double_t x); { return exp(x); }. Double_t Ldexp(Double_t x, Int_t exp); { return ldexp(x, exp); }. LongDouble_t Power(LongDouble_t x, LongDouble_t y); { return std::pow(x,y); }. LongDouble_t Power(LongDouble_t x, Long64_t y); { return std::pow(x,(LongDouble_t)y); }. LongDouble_t Power(Long64_t x, Long64_t y); { return std::pow(x,y); }. Double_t Power(Double_t x, Double_t y); { return pow(x, y); }. Double_t Power(Double_t x, Int_t y). Double_t Log(Double_t x); { return log(x); }. Double_t Log10(Double_t x); { return log10(x); }. Int_t Finite(Double_t x); { return isfinite(x); }. Int_t IsNaN(Double_t x); from math.h. { return ::isnan(x); }. Double_t QuietNaN(); --------wrapper to numeric_limits. Double_t SignalingNaN(). Double_t Infinity(); returns an infinity as defined by the IEEE standard. template <typename T> inline T NormCross(const T v1[3],const T v2[3],T out[3]); Calculate the Normalized Cross Product of two vectors. T MinElement(Long64_t n, const T *a); Return minimum of array a of length n. T MaxElement(Long64_t n, const T *a); Return maximum of array a of length n. Long64_t LocMin(Long64_t n, const T *a); Return index of array with the minimum element.; If more than one element is minimum returns first found. Iterator LocMin(Iterator first, Iterator last); Return index of array with the minimum element.; If more than one element is minimum returns first found. Long64_t LocMax(Long64_t n, const T *a); Return index of array with ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMath.html:39323,log,log,39323,root/html534/TMath.html,https://root.cern,https://root.cern/root/html534/TMath.html,1,['log'],['log']
Testability,"revFCN = 28.97257031 p0=0.000388, s=1.279, ; prevFCN = 28.97432524 s=1.273, ; prevFCN = 28.97145596 s=1.282, ; prevFCN = 28.97575564 s=1.269, ; prevFCN = 28.97003607 f=0.2452, m=1.663, p0=5.498e-07, s=0.9876, ; prevFCN = 28.8608997 f=0.2274, m=1.628, p0=0.0001029, s=0.8218, ; prevFCN = 28.87647974 f=0.241, m=1.655, p0=3.204e-06, s=0.9491, ; prevFCN = 28.85685477 f=0.2418, ; prevFCN = 28.85692699 f=0.2403, ; prevFCN = 28.85679737 f=0.241, m=1.659, ; prevFCN = 28.85436009 m=1.651, ; prevFCN = 28.8593705 m=1.655, p0=1.215e-06, ; prevFCN = 28.85682558 p0=6.138e-06, ; prevFCN = 28.85689784 p0=3.204e-06, s=0.9556, ; prevFCN = 28.85804684 s=0.9426, ; prevFCN = 28.85571545 s=0.9524, ; prevFCN = 28.85746237 s=0.9458, ; prevFCN = 28.85626117 f=0.2171, m=1.753, p0=0.0002379, s=0.6877, ; prevFCN = 28.6750677 f=0.1311, m=2.143, p0=0.004887, s=-0.3611, RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (31.8407) to force MIGRAD to back out of this region. Error log follows.; Parameter values: f=0.131146 m=2.14309 p0=0.00488743 s=-0.361096; RooAddPdf::model[ f * g_over_g_Int[x] + [%] * p_over_p_Int[x] ]; getLogVal() top-level p.d.f evaluates to NaN @ !refCoefNorm=(x = 0), !pdfs=(g_over_g_Int[x] = nan,p_over_p_Int[x] = 0.05), !coefficients=(f = 0.131146); getLogVal() top-level p.d.f evaluates to NaN @ !refCoefNorm=(x = 0), !pdfs=(g_over_g_Int[x] = nan,p_over_p_Int[x] = 0.05), !coefficients=(f = 0.131146); getLogVal() top-level p.d.f evaluates to NaN @ !refCoefNorm=(x = 0), !pdfs=(g_over_g_Int[x] = nan,p_over_p_Int[x] = 0.05), !coefficients=(f = 0.131146); getLogVal() top-level p.d.f evaluates to NaN @ !refCoefNorm=(x = 0), !pdfs=(g_over_g_Int[x] = nan,p_over_p_Int[x] = 0.05), !coefficients=(f = 0.131146); getLogVal() top-level p.d.f evaluates to NaN @ !refCoefNorm=(x = 0), !pdfs=(g_over_g_Int[x] = nan,p_over_p_Int[x] = 0.05), !coefficients=(f = 0.131146); getLogVal() top-level p.d.f evaluates to NaN @ !refCoefNorm=(x = 0), !pdfs=(g_over_g_Int[x] =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf506__msgservice_8C.html:11964,log,log,11964,doc/master/rf506__msgservice_8C.html,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html,2,['log'],['log']
Testability,"rface for all concrete MVA method implementations.Definition IMethod.h:53; TMVA::IMethod::PrintHelpMessagevirtual void PrintHelpMessage() const =0; TMVA::IMethod::HasAnalysisTypevirtual Bool_t HasAnalysisType(Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets)=0; TMVA::IMethod::MakeClassvirtual void MakeClass(const TString &classFileName=TString("""")) const =0; TMVA::MethodBaseVirtual base Class for all MVA method.Definition MethodBase.h:111; TMVA::MethodBase::GetSeparationvirtual Double_t GetSeparation(TH1 *, TH1 *) constcompute ""separation"" defined asDefinition MethodBase.cxx:2789; TMVA::MethodBase::SetSilentFilevoid SetSilentFile(Bool_t status)Definition MethodBase.h:378; TMVA::MethodBase::SetWeightFileDirvoid SetWeightFileDir(TString fileDir)set directory of weight fileDefinition MethodBase.cxx:2059; TMVA::MethodBase::TestRegressionvirtual void TestRegression(Double_t &bias, Double_t &biasT, Double_t &dev, Double_t &devT, Double_t &rms, Double_t &rmsT, Double_t &mInf, Double_t &mInfT, Double_t &corr, Types::ETreeType type)calculate <sum-of-deviation-squared> of regression output versus ""true"" value from test sampleDefinition MethodBase.cxx:992; TMVA::MethodBase::DeclareCompatibilityOptionsvirtual void DeclareCompatibilityOptions()options that are used ONLY for the READER to ensure backward compatibility they are hence without any...Definition MethodBase.cxx:596; TMVA::MethodBase::GetMethodTypeNameTString GetMethodTypeName() constDefinition MethodBase.h:332; TMVA::MethodBase::DoMulticlassBool_t DoMulticlass() constDefinition MethodBase.h:439; TMVA::MethodBase::GetSignificancevirtual Double_t GetSignificance() constcompute significance of mean differenceDefinition MethodBase.cxx:2776; TMVA::MethodBase::GetNameconst char * GetName() constDefinition MethodBase.h:334; TMVA::MethodBase::GetAnalysisTypeTypes::EAnalysisType GetAnalysisType() constDefinition MethodBase.h:437; TMVA::MethodBase::GetMulticlassConfusionMatrixvirtual TMatrixD GetMulticlassCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:126908,test,test,126908,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['test'],['test']
Testability,"rflows included by default underflows and overflows are not included . [out]igoodtest output; igood=0 - no problems; For unweighted unweighted comparison; igood=1'There is a bin in the 1st histogram with less than 1 event'; igood=2'There is a bin in the 2nd histogram with less than 1 event'; igood=3'when the conditions for igood=1 and igood=2 are satisfied'. For unweighted weighted comparison; igood=1'There is a bin in the 1st histogram with less then 1 event'; igood=2'There is a bin in the 2nd histogram with less then 10 effective number of events'; igood=3'when the conditions for igood=1 and igood=2 are satisfied'. For weighted weighted comparison; igood=1'There is a bin in the 1st histogram with less then 10 effective number of events'; igood=2'There is a bin in the 2nd histogram with less then 10 effective number of events'; igood=3'when the conditions for igood=1 and igood=2 are satisfied' . [out]chi2chisquare of the test ; [out]ndfnumber of degrees of freedom (important, when both histograms have the same empty bins) ; [out]resnormalized residuals for further analysis . Definition at line 2067 of file TH1.cxx. ◆ Chisquare(). Double_t TH1::Chisquare ; (; TF1 * ; func, . Option_t * ; option = """" . ); const. virtual . Compute and return the chisquare of this histogram with respect to a function The chisquare is computed by weighting each histogram point by the bin error By default the full range of the histogram is used. ; Use option ""R"" for restricting the chisquare calculation to the given range of the function Use option ""L"" for using the chisquare based on the poisson likelihood (Baker-Cousins Chisquare) Use option ""P"" for using the Pearson chisquare based on the expected bin errors ; Definition at line 2496 of file TH1.cxx. ◆ Class(). static TClass * TH1::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TH1::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TH1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:100572,test,test,100572,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['test'],['test']
Testability,"rg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; Bool_tdefineType(const char* label); Bool_tdefineType(const char* label, Int_t index); virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCategory.html:3434,test,testArg,3434,root/html534/RooCategory.html,https://root.cern,https://root.cern/root/html534/RooCategory.html,3,['test'],['testArg']
Testability,"rg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ). Plot the distribution of the -log(L) values on a newly created frame. . Optional arguments . FrameRange(double lo, double hi) Set range of frame to given specification . FrameBins(int bins) Set default number of bins of frame to given number . Frame() Pass supplied named arguments to RooAbsRealLValue::frame() function. See there for list of allowed arguments . If no frame specifications are given, the AutoRange() feature will be used to set the range. Any other named argument is passed to the RooAbsData::plotOn() call. See that function for allowed options. PyROOT; The RooMCStudy::plotNLL() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArg of the function. . Definition at line 962 of file RooMCStudy.cxx. ◆ plotNLL() [2/2]. RooPlot * RooMCStudy::plotNLL ; (; double ; lo, . double ; hi, . Int_t ; nBins = 100 . ). Create a RooPlot of the -log(L) distribution in the range lo-hi with 'nBins' bins. ; Definition at line 1199 of file RooMCStudy.cxx. ◆ plotParam() [1/2]. RooMCStudy::plotParam ; (; const char * ; paramName, . const RooCmdArg & ; arg1 = {}, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ). Plot the distribution of the fitted value of the given parameter on a newly created frame. . Optional arguments . FrameRange(double lo, double hi) Set range of frame to given specification . FrameBins(int bins) Set default number of bins of frame to given number . Frame() Pass supplied named arguments to RooAbsRealLValue::frame() function. See there for list of allowed arguments . If no frame specifications are given, the AutoRange() feature will be used to set the range Any other named argument is passed to the RooAbsData::plotOn() call. See that function for",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMCStudy.html:31814,log,log,31814,doc/master/classRooMCStudy.html,https://root.cern,https://root.cern/doc/master/classRooMCStudy.html,1,['log'],['log']
Testability,"rg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsOptTestStatistic.html:19435,test,testArg,19435,root/html530/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html,12,['test'],['testArg']
Testability,"rgSet& paramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = RooCmdArg::none(), const RooCmdArg arg7 = RooCmdArg::none(), const RooCmdArg arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/Roo2DKeysPdf.html:8255,test,testArg,8255,root/html526/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html526/Roo2DKeysPdf.html,238,['test'],['testArg']
Testability,"rgSet* altPOI = 0); static voidSetAlwaysReuseNLL(Bool_t flag); voidSetMinimizer(const char* minimizer); voidSetPrintLevel(Int_t printLevel); voidSetReuseNLL(Bool_t flag); voidSetStrategy(Int_t strategy); voidSetSubtractMLE(bool subtract); voidSetTolerance(Double_t tol); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. RooArgSet*fAltPOI; RooStats::ProfileLikelihoodTestStatfAltProfile; RooStats::ProfileLikelihoodTestStatfNullProfile; Bool_tfSubtractMLE; static Bool_tfgAlwaysReuseNll. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RatioOfProfiledLikelihoodsTestStat(); Proof constructor. Don't use. RatioOfProfiledLikelihoodsTestStat(RooAbsPdf& nullPdf, RooAbsPdf& altPdf, const RooArgSet* altPOI = 0). Calculates the ratio of profiled likelihoods. 	 By default the calculation is:. 	 Lambda(mu_alt , conditional MLE for alt nuisance); 	log --------------------------------------------; 	 Lambda(mu_null , conditional MLE for null nuisance). 	where Lambda is the profile likeihood ratio, so the; 	MLE for the null and alternate are subtracted off. 	If SetSubtractMLE(false) then it calculates:. 	 L(mu_alt , conditional MLE for alt nuisance); 	log --------------------------------------------; 	 L(mu_null , conditional MLE for null nuisance). 	The values of the parameters of interest for the alternative; 	hypothesis are taken at the time of the construction.; 	If empty, it treats all free parameters as nuisance parameters. 	The value of the parameters of interest for the null hypotheses; 	are given at each call of Evaluate(data,nullPOI). ~RatioOfProfiledLikelihoodsTestStat(void). Double_t ProfiledLikelihood(RooAbsData& data, RooArgSet& poi, RooAbsPdf& pdf). Double_t Evaluate(RooAbsData& data, RooArgSet& nullParamsOfInterest). void SetAlwaysReuseNLL(Bool_t flag); { fgAlwaysReuseNll = flag ; }. void SetReuseNLL(Bool_t flag). void SetMinimizer(const ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__RatioOfProfiledLikelihoodsTestStat.html:2258,log,log,2258,root/html532/RooStats__RatioOfProfiledLikelihoodsTestStat.html,https://root.cern,https://root.cern/root/html532/RooStats__RatioOfProfiledLikelihoodsTestStat.html,1,['log'],['log']
Testability,"rged ; (; Int_t ; steps = 10, . Double_t ; improvement = 0.1 . ). virtual . gives back true if the last ""steps"" steps have lead to an improvement of the ""fitness"" of the ""individuals"" of at least ""improvement"" ; this gives a simple measure of if the fitness of the individuals is converging and no major improvement is to be expected soon. ; Definition at line 260 of file GeneticAlgorithm.cxx. ◆ Init(). void TMVA::GeneticAlgorithm::Init ; (; ). calls evolution, but if it is not the first time. ; If it's the first time, the random population created by the constructor is still not evaluated, .. therefore we wait for the second time init is called. ; Definition at line 101 of file GeneticAlgorithm.cxx. ◆ IsA(). virtual TClass * TMVA::GeneticAlgorithm::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Definition at line 104 of file GeneticAlgorithm.h. ◆ Log(). MsgLogger & TMVA::GeneticAlgorithm::Log ; (; ); const. inlineprotected . message logger ; Definition at line 102 of file GeneticAlgorithm.h. ◆ NewFitness(). Double_t TMVA::GeneticAlgorithm::NewFitness ; (; Double_t ; oldValue, . Double_t ; newValue . ). virtual . if the ""fitnessFunction"" is called multiple times for one set of factors (because i.e. ; each event of a TTree has to be assessed with each set of Factors proposed by the Genetic Algorithm) the value of the current calculation has to be added(? or else) to the value obtained up to now. example: some chi-square is calculated for every event, after every event the new chi-square (newValue) has to be simply added to the oldValue.; this function has to be overridden eventually it might contain only the following return statement. return oldValue + newValue; ; Definition at line 123 of file GeneticAlgorithm.cxx. ◆ SetMakeCopies(). void TMVA::GeneticAlgorithm::SetMakeCopies ; (; Bool_t ; s). inline . Definition at line 72 of file GeneticAlgorithm.h. ◆ SetSpread(). void TMVA::GeneticAlgorithm::SetSpread ; (; Double_t ; s). inline . Defi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1GeneticAlgorithm.html:6263,log,logger,6263,doc/master/classTMVA_1_1GeneticAlgorithm.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1GeneticAlgorithm.html,1,['log'],['logger']
Testability,"rget&fFitterTargetthe fitter target; Double_tfLastResultremembers the last obtained result (for internal use); TMVA::MsgLogger*fLoggermessage logger; Bool_tfMakeCopiesif true, the population will make copies of the first individuals; Bool_tfMirrornew values for mutation are mirror-mapped if outside of constraints; TMVA::GeneticPopulationfPopulationcontains and controls the ""individual""; Int_tfPopulationSizethe size of the population; const vector<TMVA::Interval*>&fRangesparameter ranges; Double_tfSpreadregulates the spread of the value change at mutation (sigma); deque<Int_t>fSuccessListto adjust the stepSize . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GeneticAlgorithm(TMVA::IFitterTarget& target, Int_t populationSize, const vector<TMVA::Interval*>& ranges, UInt_t seed = 0); Constructor; Parameters:; int populationSize : defines the number of ""Individuals"" which are created and tested; within one Generation (Iteration of the Evolution); std::vector<TMVA::Interval*> ranges : Interval holds the information of an interval, where the GetMin; gets the low and GetMax gets the high constraint of the variable; the size of ""ranges"" is the number of coefficients which are optimised; Purpose:; Creates a random population with individuals of the size ranges.size(). ~GeneticAlgorithm(); destructor; deletes fLogger. void Init(); calls evolution, but if it is not the first time.; If it's the first time, the random population created by the; constructor is still not evaluated, .. therefore we wait for the; second time init is called. Double_t NewFitness(Double_t oldValue, Double_t newValue); if the ""fitnessFunction"" is called multiple times for one set of; factors (because i.e. each event of a TTree has to be assessed with; each set of Factors proposed by the Genetic Algorithm) the value; of the current calculation has to be added(? or else) to the value; obtained up to now.; example: some chi-square is calculated for every event,; a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__GeneticAlgorithm.html:2505,test,tested,2505,root/html534/TMVA__GeneticAlgorithm.html,https://root.cern,https://root.cern/root/html534/TMVA__GeneticAlgorithm.html,1,['test'],['tested']
Testability,"rging outputs if submerger; Long64_tfMsgSizeHWMHigh-Water-Mark on the size of messages with results; Int_tfNcmdcommand history number; TStringfOrdinalslave ordinal number; TStringfPackageDirdirectory containing packages and user libs; TProofLockPath*fPackageLockpackage dir locker; TVirtualProofPlayer*fPlayeractual player; TStringfPrefixPrefix identifying the node; TProof*fProofPROOF talking to slave servers; Int_tfProtocolprotocol version number; TQueryResultManager*fQMgrQuery-result manager; TMutex*fQMtxTo protect async msg queue; TStringfQueryDirdirectory containing query results and status; TProofLockPath*fQueryLockquery dir locker; Int_tfQuerySeqNumsequential number of the current or last query; TList*fQueuedMsglist of messages waiting to be processed; Float_tfRealTimereal time spent executing commands; Bool_tfRealTimeLogTRUE if log messages should be send back in real-time; TReaperTimer*fReaperTimerTimer used to control children state; Bool_tfSendLogToMasterOn workers, controls logs sending to master; TStringfServiceservice we are running, either ""proofserv"" or ""proofslave""; TStringfSessionDirdirectory containing session dependent files; TStringfSessionTagtag for the server session; TShutdownTimer*fShutdownTimerTimer used to shutdown out-of-control sessions; TSocket*fSocketsocket connection to client; TStringfTopSessionTagtag for the global session; Int_tfTotSessionsTotal number of PROOF sessions on the cluster ; TStringfUseruser as which we run; TList*fWaitingQuerieslist of TProofQueryResult waiting to be processed; TStringfWorkDirdirectory containing all proof related info; static FILE*fgErrorHandlerFileFile where to log; static Int_tfgLogToSysLog>0 sent to syslog too; static Float_tfgMemHWMThreshold fraction of max for warning and finer monitoring; static Float_tfgMemStopFraction of max for stop processing; static Int_tfgRecursiveKeep track of recursive inputs during processing; static Long_tfgResMemMaxHard limit on the resident memory checked; static TString",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofServ.html:19241,log,logs,19241,root/html528/TProofServ.html,https://root.cern,https://root.cern/root/html528/TProofServ.html,3,['log'],['logs']
Testability,"rgument was changed to set gDirectory to zero when being passed a null pointer; previously it was interpreting a null pointer as a request to not change the current directory - this behavior is now implement by the default constructor. I/O. Fix the issue described at ROOT-7500 : crash due to change in base class which versioned derived class. Proof. Add support for aliases ROOT-7392; Fix issue with trees in sub-directories causing stressProof test #29 to fail. Interpreter. Fix unloading of code ROOT-7290; Fix template instantiations in cling internals ROOT-7364; Forget erroneous decls in case of errors ROOT-7295; Work around binutils issue (ld crash building llvm) on MacOSX with GCC (pull requests 64-66); Work around MacOS X builds being version specific ROOT-6966; Handle relocation of ROOT and non-PCH-able glibc headers.; Fix parsing of definition for forward declared enums ROOT-7419; Pass CXXFLAGS to the PCH generator, to ensure platform consistency.; Work around linker assert when building with GCC on OS X (PR #68). PyROOT. Fix lookup of templated classes in namespace with arguments that have ‘std::’ in their name ROOT-7448; Use GetTrueTypeName() instead of GetFullTypeName(), as the latter loses namespaces; Strip down number of libraries linked to libPyROOT in order to reduce to the minimum the time needed to import the ROOT module. TFormula, TF1. Allow possibility to automatically normalize itself. If the function TF1::SetNormalized(true) is called, when evaluated, the function will return its value divided by its integral computed in the function range.; Added helper classes TF1NormSum, TF1Convolution.; Fix a bug in calling TF1::Update when changing the parameter values. Fix also the TF1Convolution.; Fix the caching of the parameters in TF1NormSum to avoid recomputing integrals for same parameter values.; Remove unwanted printout from Streamer method. RooFit. Fix for contour computations in RooMinimizer[ROOT-7290]. Dictionary Generation. Uniform style of warnin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:27287,assert,assert,27287,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['assert'],['assert']
Testability,"rgument.; training and test are the two TEventLists defining events; to be used during the neural net training.; Both the TTree and the TEventLists can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are two cuts (see TTreeFormula) defining events; to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are two cuts (see TTreeFormula) defining ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiLayerPerceptron.html:21364,test,test,21364,root/html528/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html,12,['test'],"['test', 'testing']"
Testability,"rhs.fData;; 273 if ( !fData.empty() ); 274 fDataPtr = &fData.front();; 275 ; 276 // copy coordinate errors and set correct pointers; 277 fCoordErrors = rhs.fCoordErrors;; 278 if (!fCoordErrors.empty()) {; 279 assert(kCoordError == fErrorType || kAsymError == fErrorType);; 280 fCoordErrorsPtr.resize(fDim);; 281 for (unsigned int i = 0; i < fDim; i++) {; 282 fCoordErrorsPtr[i] = fCoordErrors[i].empty() ? nullptr : &fCoordErrors[i].front();; 283 }; 284 }; 285 // copy data error; 286 fDataError = rhs.fDataError;; 287 if (!fDataError.empty()) {; 288 assert(kValueError == fErrorType || kCoordError == fErrorType);; 289 fDataErrorPtr = &fDataError.front();; 290 }; 291 // copy the asymmetric data error; 292 fDataErrorHigh = rhs.fDataErrorHigh;; 293 fDataErrorLow = rhs.fDataErrorLow;; 294 // both error low and high should be empty or not; 295 assert( fDataErrorLow.empty() == fDataErrorHigh.empty()) ;; 296 if (!fDataErrorHigh.empty() && !fDataErrorLow.empty()) {; 297 assert(kAsymError == fErrorType);; 298 fDataErrorHighPtr = &fDataErrorHigh.front();; 299 fDataErrorLowPtr = &fDataErrorLow.front();; 300 }; 301 }; 302 ; 303 fpTmpCoordErrorVector= new double[ fDim ];; 304 ; 305 if ( HasBinEdges() ); 306 fpTmpBinEdgeVector = new double[ fDim ];; 307 ; 308 return *this;; 309 }; 310 ; 311 ; 312 /**; 313 preallocate a data set with given size , dimension and error type (to get the full point size); 314 If the data set already exists and it is having the compatible point size space for the new points; 315 is created in the data sets, while if not compatible the old data are erased and new space of; 316 new size is allocated.; 317 (i.e if exists initialize is equivalent to a resize( NPoints() + maxpoints); 318 */; 319 ; 320 void BinData::Append( unsigned int newPoints, unsigned int dim , ErrorType err ); 321 {; 322 assert( !fWrapped );; 323 assert( fMaxPoints == 0 || fWrapped == fData.empty() );; 324 ; 325 assert( kValueError == fErrorType || kCoordError == fErrorType ||; 326 kAsymError ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:8494,assert,assert,8494,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['assert'],['assert']
Testability,"riable to integrate wrt. ; xMaxMaximum value of of variable to integrate wrt. ; meanMean. ; sigmaSigma. . ReturnsThe integral of an un-normalized RooGaussian over the value in x. ; Definition at line 418 of file MathFuncs.h. ◆ getUniformBinning(). unsigned int RooFit::Detail::MathFuncs::getUniformBinning ; (; double ; low, . double ; high, . double ; val, . unsigned int ; numBins . ). inline . Definition at line 172 of file MathFuncs.h. ◆ interpolate1d(). double RooFit::Detail::MathFuncs::interpolate1d ; (; double ; low, . double ; high, . double ; val, . unsigned int ; numBins, . double const * ; vals . ). inline . Definition at line 178 of file MathFuncs.h. ◆ landau(). double RooFit::Detail::MathFuncs::landau ; (; double ; x, . double ; mu, . double ; sigma . ). inline . Definition at line 331 of file MathFuncs.h. ◆ logNormal(). double RooFit::Detail::MathFuncs::logNormal ; (; double ; x, . double ; k, . double ; m0 . ). inline . Definition at line 338 of file MathFuncs.h. ◆ logNormalIntegral(). double RooFit::Detail::MathFuncs::logNormalIntegral ; (; double ; xMin, . double ; xMax, . double ; m0, . double ; k . ). inline . Definition at line 627 of file MathFuncs.h. ◆ logNormalIntegralStandard(). double RooFit::Detail::MathFuncs::logNormalIntegralStandard ; (; double ; xMin, . double ; xMax, . double ; mu, . double ; sigma . ). inline . Definition at line 638 of file MathFuncs.h. ◆ logNormalStandard(). double RooFit::Detail::MathFuncs::logNormalStandard ; (; double ; x, . double ; sigma, . double ; mu . ). inline . Definition at line 343 of file MathFuncs.h. ◆ nll(). double RooFit::Detail::MathFuncs::nll ; (; double ; pdf, . double ; weight, . int ; binnedL, . int ; doBinOffset . ). inline . Definition at line 353 of file MathFuncs.h. ◆ poisson(). double RooFit::Detail::MathFuncs::poisson ; (; double ; x, . double ; par . ). inline . Definition at line 198 of file MathFuncs.h. ◆ poissonIntegral(). double RooFit::Detail::MathFuncs::poissonIntegral ; (; int ; code, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceRooFit_1_1Detail_1_1MathFuncs.html:8860,log,logNormalIntegral,8860,doc/master/namespaceRooFit_1_1Detail_1_1MathFuncs.html,https://root.cern,https://root.cern/doc/master/namespaceRooFit_1_1Detail_1_1MathFuncs.html,1,['log'],['logNormalIntegral']
Testability,"riable. void NoErrorCalc(Double_t *const err, Double_t *const errUpper). Double_t GetMvaValue(const TMVA::Event *const ev, Double_t* err = 0, Double_t* errUpper = 0). Bool_t IsSignalLike(); uses a pre-set cut on the MVA output (SetSignalReferenceCut and SetSignalReferenceCutOrientation); for a quick determination if an event would be selected as signal or background. Bool_t IsSignalLike(Double_t mvaVal); uses a pre-set cut on the MVA output (SetSignalReferenceCut and SetSignalReferenceCutOrientation); for a quick determination if an event with this mva output value would tbe selected as signal or background. void AddClassifierOutput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void AddClassifierOutputProb(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); calculate <sum-of-deviation-squared> of regression output versus ""true"" value from test sample. bias = average deviation; dev = average absolute deviation; rms = rms of deviation. void TestMulticlass(); test multiclass classification. void TestClassification(); initialization. void WriteStateToStream(ostream& tf) const; general method used in writing the header of the weight files where; the used variables, variable transformation type etc. is specified. void AddInfoItem(void* gi, const TString& name, const TString& value) const; xml writing. void AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType). void WriteStateToXML(void* parent) const; general method used in writing the header of the weight files where; the used variables, variable transformation type etc. is specified. void ReadStateFromStream(TFile& rf); write reference MVA distributions (and other information); to a ROOT type weight file. void WriteSt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodBase.html:24020,test,test,24020,root/html534/TMVA__MethodBase.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodBase.html,1,['test'],['test']
Testability,"rianceMatrix() const; get the error matrix in a pointer to a NxN array.; excluding the fixed parameters. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; get error matrix element (return all zero if matrix is not available). Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; get fit errors. Int_t GetNumberTotalParameters() const; number of total parameters. Int_t GetNumberFreeParameters() const; number of variable parameters. Double_t GetParError(Int_t ipar) const; parameter error. Double_t GetParameter(Int_t ipar) const; parameter value. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; get all parameter info (name, value, errors). const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; get fit statistical information. Double_t GetSumLog(Int_t i); sum of log . Un-needed. Bool_t IsFixed(Int_t ipar) const; query if parameter ipar is fixed. void PrintResults(Int_t level, Double_t amin) const; print the fit result; use PrintResults function in case of Minuit for old -style printing. void ReleaseParameter(Int_t ipar); release a fit parameter. void SetFitMethod(const char* name); set fit method (i.e. chi2 or likelihood); according to the method the appropriate FCN function will be created. Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set (add) a new fit parameter passing initial value, step size (verr) and parametr limits; if vlow > vhigh the parameter is unbounded; if the stepsize (verr) == 0 the parameter is treated as fixed. void ReCreateMinimizer(); Recreate a minimizer instance using the function and data; set objective function in minimizers function to re-create FCN from stored data object and fit options. void SetFCN(void (*fcn)(Int_t &, Double_t *,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBackCompFitter.html:16287,log,log,16287,root/html602/TBackCompFitter.html,https://root.cern,https://root.cern/root/html602/TBackCompFitter.html,2,['log'],['log']
Testability,"rianceMatrix() const; get the error matrix in a pointer to a NxN array.; excluding the fixed parameters. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; get error matrix element (return all zero if matrix is not available). Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; get fit errors. Int_t GetNumberTotalParameters() const; number of total parameters. Int_t GetNumberFreeParameters() const; number of variable parameters. Double_t GetParError(Int_t ipar) const; parameter error. Double_t GetParameter(Int_t ipar) const; parameter value. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; get all parameter info (name, value, errors). const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; get fit statistical information. Double_t GetSumLog(Int_t i); sum of log . Un-needed. Bool_t IsFixed(Int_t ipar) const; query if parameter ipar is fixed. void PrintResults(Int_t level, Double_t amin) const; print the fit result; use PrintResults function in case of Minuit for old -style printing. void ReleaseParameter(Int_t ipar); release a fit parameter. void SetFitMethod(const char* name); set fit method (i.e. chi2 or likelihood); according to the method the appropriate FCN function will be created. Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set (add) a new fit parameter passing initial value, step size (verr) and parametr limits; if vlow > vhigh the parameter is unbounded; if the stepsize (verr) == 0 the parameter is treated as fixed. void ReCreateMinimizer(); Recreate a minimizer instance using the function and data; set objective function in minimizers function to re-create FCN from stored data object and fit options. void SetFCN(void fcn); override setFCN to us",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBackCompFitter.html:15554,log,log,15554,root/html528/TBackCompFitter.html,https://root.cern,https://root.cern/root/html528/TBackCompFitter.html,4,['log'],['log']
Testability,"ribed and taken from; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/andeksam.htm; and described and taken from (1); Scholz F.W., Stephens M.A. (1987), K-sample Anderson-Darling Tests, Journal of the American Statistical Association, 82, 918–924. (2-samples variant implemented); */ void AndersonDarling2SamplesTest(Double_t& pvalue, Double_t& testStat) const;. Double_t AndersonDarlingTest(const Char_t* option = ""p"") const. The Anderson-Darling 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/andedarl.htm; and described and taken from (2); Marsaglia J.C.W., Marsaglia G. (2004), Evaluating the Anderson-Darling Distribution, Journal of Statistical Software, Volume 09, Issue i02.; and described and taken from (3); Lewis P.A.W. (1961), The Annals of Mathematical Statistics, Distribution of the Anderson-Darling Statistic, Volume 32, Number 4, 1118-1124.; */ void AndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 2-Samples Test algorithm is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/ks2samp.htm; and described and taken from; http://root.cern.ch/root/html/TMath.html#TMath:KolmogorovTest; */ void KolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnovTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/kstest.htm; and described and taken from (4); Press W. H., Teukolsky S.A., Vetterling W.T., Flannery B.P. (2007), Numerical Recipes - The Art of Scientific Computing (Third Edition), Cambridge Univerdity Press; */ void KolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const;. void operator()(ROOT::Math::GoFTest::ETestType test, Dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__GoFTest.html:6062,test,testStat,6062,root/html528/ROOT__Math__GoFTest.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__GoFTest.html,3,['test'],['testStat']
Testability,"ribed and taken from; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/andeksam.htm; and described and taken from; (1) Scholz F.W., Stephens M.A. (1987), K-sample Anderson-Darling Tests, Journal of the American Statistical Association, 82, 918–924. (2-samples variant implemented); */ void AndersonDarling2SamplesTest(Double_t& pvalue, Double_t& testStat) const;. Double_t AndersonDarlingTest(const Char_t* option = ""p"") const. The Anderson-Darling 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/andedarl.htm; and described and taken from (2); Marsaglia J.C.W., Marsaglia G. (2004), Evaluating the Anderson-Darling Distribution, Journal of Statistical Software, Volume 09, Issue i02.; and described and taken from (3); Lewis P.A.W. (1961), The Annals of Mathematical Statistics, Distribution of the Anderson-Darling Statistic, Volume 32, Number 4, 1118-1124.; */ void AndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 2-Samples Test algorithm is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/ks2samp.htm; and described and taken from; http://root.cern.ch/root/html/TMath.html#TMath:KolmogorovTest; */ void KolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnovTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/kstest.htm; and described and taken from (4); Press W. H., Teukolsky S.A., Vetterling W.T., Flannery B.P. (2007), Numerical Recipes - The Art of Scientific Computing (Third Edition), Cambridge Univerdity Press; */ void KolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const;. void operator()(ROOT::Math::GoFTest::ETestType test, Dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__GoFTest.html:6245,test,testStat,6245,root/html534/ROOT__Math__GoFTest.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__GoFTest.html,3,['test'],['testStat']
Testability,"ribing current object ; Reimplemented from TNamed.; Reimplemented in TProofMonSenderSQL.; Definition at line 79 of file TProofMonSender.h. ◆ IsValid(). Bool_t TProofMonSender::IsValid ; (; ); const. inline . Definition at line 68 of file TProofMonSender.h. ◆ SendDataSetInfo(). virtual Int_t TProofMonSender::SendDataSetInfo ; (; TDSet * ; , . TList * ; , . const char * ; , . const char * ;  . ). pure virtual . Implemented in TProofMonSenderSQL. ◆ SendFileInfo(). virtual Int_t TProofMonSender::SendFileInfo ; (; TDSet * ; , . TList * ; , . const char * ; , . const char * ;  . ). pure virtual . Implemented in TProofMonSenderSQL. ◆ SendSummary(). virtual Int_t TProofMonSender::SendSummary ; (; TList * ; , . const char * ;  . ). pure virtual . Implemented in TProofMonSenderSQL. ◆ SetSendOptions(). Int_t TProofMonSender::SetSendOptions ; (; const char * ; sendopts). Parse send options from string 'sendopts'. ; Format is: ""[-,+]S[n]|[-,+]D[m]|[-,+]F[j]"" where:; The big letter refers to the 'table' following S table with summary log; D table with dataset info; F table files info. The '-,+' in front disables/enables the related table; if absent '+' is assumed; The number after the letter is the version of the related table. Returns -1 if nothing is enabled; 0 otherwise ; Definition at line 43 of file TProofMonSender.cxx. ◆ Streamer(). void TProofMonSender::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TNamed.; Reimplemented in TProofMonSenderSQL. ◆ StreamerNVirtual(). void TProofMonSender::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 79 of file TProofMonSender.h. Member Data Documentation. ◆ fDataSetInfoVrs. Int_t TProofMonSender::fDataSetInfoVrs. protected . Definition at line 34 of file TProofMonSender.h. ◆ fFileInfoVrs. Int_t TProofMonSender::fFileInfoVrs. protected . Definition at line 35 of file TProofMonSender.h. ◆ fSummaryVrs. Int_t TProofMonSender::fSummaryVrs. p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofMonSender.html:14314,log,log,14314,doc/master/classTProofMonSender.html,https://root.cern,https://root.cern/doc/master/classTProofMonSender.html,1,['log'],['log']
Testability,"ribing this class . ◆ Class_Name(). static const char * TApplicationServer::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TApplicationServer::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 94 of file TApplicationServer.h. ◆ DeclFileName(). static const char * TApplicationServer::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 94 of file TApplicationServer.h. ◆ ErrorHandler(). void TApplicationServer::ErrorHandler ; (; Int_t ; level, . Bool_t ; abort, . const char * ; location, . const char * ; msg . ). staticprotected . The error handler function. ; It prints the message on stderr and if abort is set it aborts the application. ; Definition at line 1088 of file TApplicationServer.cxx. ◆ ExecLogon(). void TApplicationServer::ExecLogon ; (; ). private . Execute logon macro's. ; There are three levels of logon macros that will be executed: the system logon etc/system.rootlogon.C, the global user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward compatibility also the logon macro as specified by the Rint.Logon environment setting, by default ./rootlogon.C, will be executed. No logon macros will be executed when the system is started with the -n option. ; Definition at line 1277 of file TApplicationServer.cxx. ◆ GetHost(). const char * TApplicationServer::GetHost ; (; ); const. inline . Definition at line 73 of file TApplicationServer.h. ◆ GetOptions(). void TApplicationServer::GetOptions ; (; Int_t * ; argc, . char ** ; argv . ). overridevirtual . Get and handle command line options. ; Fixed format: ""protocol url"" ; Reimplemented from TApplication.; Definition at line 449 of file TApplicationServer.cxx. ◆ GetPort(). Int_t TApplicationServer::GetPort ; (; ); const. inline . Definition at line 71 of file TApplicationServer.h. ◆ GetProtocol(). Int_t TApplicationServer::GetProtocol ; (; ); cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplicationServer.html:25273,log,logon,25273,doc/master/classTApplicationServer.html,https://root.cern,https://root.cern/doc/master/classTApplicationServer.html,2,['log'],['logon']
Testability,ributes; TAtomicCount ; TAtt3D 3D attributes; TAttAxis Axis attributes; TAttBBox Helper for management of bounding-box information; TAttCanvas Canvas attributes; TAttFill Fill area attributes; TAttFillEditor GUI for editing fill attributes; TAttImage Image attributes; TAttLine Line attributes; TAttLineEditor GUI for editing line attributes; TAttMarker Marker attributes; TAttMarkerEditor GUI for editing marker attributes; TAttPad Pad attributes; TAttParticle Particle definition; TAttText Text attributes; TAttTextEditor GUI for editing text attributes; TAuthenticate Class providing remote authentication service; TAxis Axis class; TAxis3D 3-D ruler painting class; TAxisEditor axis editor; TBRIK TBRIK shape; TBackCompFitter Class providing backward compatibility for fitting by implementing the TVirtualFitter interface; TBase64 Base64 encoding/decoding; TBaseClass Description of a base class; TBasket the TBranch buffers; TBasketSQL the TBranch buffers; TBenchmark ROOT utility to help benchmarking applications; TBinomialEfficiencyFitter Binomial Fitter for the division of two histograms; TBits Bit container; TBits::TReference ; TBonjourBrowser Browse hosts for specific bonjour service type; TBonjourRecord Bonjour information record; TBonjourRegistrar Register Bonjour service; TBonjourResolver Resolve Bonjour to actual IP address and port; TBox Box class; TBranch Branch descriptor; TBranchClones Branch in case of an array of clone objects; TBranchElement Branch in case of an object; TBranchObject Branch in case of an object; TBranchRef to support referenced objects on other branches; TBranchSTL Branch handling STL collection of pointers; TBrowser ROOT Object Browser; TBrowserImp ABC describing browser implementation protocol; TBrowserPlugin basic plugin description class; TBtree A B-tree; TBtreeIter B-tree iterator; TBuffer Buffer base class used for serializing objects; TBuffer3D 3D primitives description; TBufferFile concrete implementation of TBuffer for writing/reading ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ClassIndex.html:51958,benchmark,benchmarking,51958,root/html530/ClassIndex.html,https://root.cern,https://root.cern/root/html530/ClassIndex.html,2,['benchmark'],['benchmarking']
Testability,"ribution (const char *name, const char *title, RooDataSet &dataSet, const char *columnName=nullptr, const char *varName=nullptr);  Creates a SamplingDistribution from a RooDataSet for debugging purposes; e.g. ;  ;  SamplingDistribution (const char *name, const char *title, std::vector< double > &samplingDist, const char *varName=nullptr);  Constructor for SamplingDistribution. ;  ;  SamplingDistribution (const char *name, const char *title, std::vector< double > &samplingDist, std::vector< double > &sampleWeights, const char *varName=nullptr);  SamplingDistribution constructor. ;  ;  ~SamplingDistribution () override;  Destructor of SamplingDistribution. ;  ; void Add (const SamplingDistribution *other);  merge two sampling distributions ;  ; double CDF (double x) const;  calculate CDF as a special case of Integral(...) with lower limit equal to -inf ;  ; const std::vector< double > & GetSampleWeights () const;  Get the sampling weights. ;  ; const std::vector< double > & GetSamplingDistribution () const;  Get test statistics values. ;  ; Int_t GetSize () const;  size of samples ;  ; const TString GetVarName () const;  ; double Integral (double low, double high, bool normalize=true, bool lowClosed=true, bool highClosed=false) const;  numerical integral in these limits ;  ; double IntegralAndError (double &error, double low, double high, bool normalize=true, bool lowClosed=true, bool highClosed=false) const;  numerical integral in these limits including error estimation ;  ; double InverseCDF (double pvalue);  get the inverse of the Cumulative distribution function ;  ; double InverseCDF (double pvalue, double sigmaVariaton, double &inverseVariation);  get the inverse of the Cumulative distribution function together with the inverse based on sampling variation ;  ; double InverseCDFInterpolate (double pvalue);  get the inverse of the Cumulative distribution function ;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1SamplingDistribution.html:1953,test,test,1953,doc/master/classRooStats_1_1SamplingDistribution.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1SamplingDistribution.html,1,['test'],['test']
Testability,"ride;  Destructor. ;  ; void Build (TSessionViewer *gui);  Build session frame. ;  ; void CheckAutoEnPack (Bool_t checked=kTRUE);  ; Int_t GetLogLevel () const;  ; TGTab * GetTab () const;  ; TClass * IsA () const override;  ; void OnApplyLogLevel ();  Apply selected log level on current session. ;  ; void OnApplyParallel ();  Apply selected number of workers on current Proof session. ;  ; void OnBtnAddClicked ();  Open file dialog and add selected package file to the list. ;  ; void OnBtnDisconnectClicked ();  Disconnect from current Proof session. ;  ; void OnBtnDownClicked ();  Move selected package entry one position down in the list. ;  ; void OnBtnGetQueriesClicked ();  Get list of queries from current Proof server and populate the list tree. ;  ; void OnBtnNewQueryClicked ();  Call ""New Query"" Dialog. ;  ; void OnBtnRemoveClicked ();  Remove selected package from the list. ;  ; void OnBtnRemoveDSet ();  Remove dataset from the list and from the cluster. ;  ; void OnBtnShowLogClicked ();  Show session log. ;  ; void OnBtnUpClicked ();  Move selected package entry one position up in the list. ;  ; void OnBtnUploadDSet ();  Open Upload Dataset dialog. ;  ; void OnBtnVerifyDSet ();  Verify that the files in the selected dataset are present on the cluster. ;  ; void OnClearPackages ();  Clear (disable) all packages in the current session. ;  ; void OnCommandLine ();  Command line handling. ;  ; void OnDisablePackages ();  Disable selected package(s) in the current session. ;  ; void OnEnablePackages ();  Enable selected package(s) in the current session. ;  ; void OnMultipleSelection (Bool_t on);  Handle multiple selection check button. ;  ; void OnStartupEnable (Bool_t on);  Handle multiple selection check button. ;  ; void OnUploadPackages ();  Upload selected package(s) to the current session. ;  ; void ProofInfos ();  Display information on current session. ;  ; void SetLocal (Bool_t local=kTRUE);  Switch widgets status/visibility for local/remote sessions. ;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSessionFrame.html:1473,log,log,1473,doc/master/classTSessionFrame.html,https://root.cern,https://root.cern/doc/master/classTSessionFrame.html,1,['log'],['log']
Testability,"ridevirtual . Implements TVirtualPad.; Definition at line 213 of file TPad.h. ◆ HasCrosshair(). Bool_t TPad::HasCrosshair ; (; ); const. overridevirtual . Return kTRUE if the crosshair has been activated (via SetCrosshair). ; Implements TVirtualPad.; Definition at line 6642 of file TPad.cxx. ◆ HasFixedAspectRatio(). Bool_t TPad::HasFixedAspectRatio ; (; ); const. inlineoverridevirtual . Implements TVirtualPad.; Definition at line 270 of file TPad.h. ◆ Hash(). ULong_t TPad::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TPad::HashULong_t Hash() const overrideReturn hash value for this object.Definition TPad.h:267; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Definition at line 267 of file TPad.h. ◆ HasViewer3D(). Bool_t TPad::HasViewer3D ; (; ); const. inlineoverridevirtual . Implements TVirtualPad.; Definition at line 401 of file TPad.h. ◆ ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPad.html:87108,log,logarithmic,87108,doc/master/classTPad.html,https://root.cern,https://root.cern/doc/master/classTPad.html,1,['log'],['logarithmic']
Testability,"ries, calibrations.; The XML file is built in memory before being dumped to disk. Like for normal ROOT files, XML files use the same I/O mechanism; exploiting the ROOT/CINT dictionary. Any class having a dictionary; can be saved in XML format. This first implementation does not support subdirectories; or Trees. The shared library libRXML.so may be loaded dynamically; via gSystem->Load(""libRXML""). This library is automatically; loaded by the plugin manager as soon as a XML file is created; via, eg; TFile::Open(""file.xml"",""recreate"");; TFile::Open returns a TXMLFile object. When a XML file is open in write mode,; one can use the normal TObject::Write to write an object in the file.; Alternatively one can use the new functions TDirectoryFile::WriteObject and; TDirectoryFile::WriteObjectAny to write a TObject* or any class not deriving; from TObject. example of a session saving a histogram to a XML file. TFile *f = TFile::Open(""Example.xml"",""recreate"");; TH1F *h = new TH1F(""h"",""test"",1000,-2,2);; h->FillRandom(""gaus"");; h->Write();; delete f;. example of a session reading the histogram from the file. TFile *f = TFile::Open(""Example.xml"");; TH1F *h = (TH1F*)f->Get(""h"");; h->Draw();. A new option in the canvas ""File"" menu is available to save; a TCanvas as a XML file. One can also do; canvas->Print(""Example.xml"");. Configuring ROOT with the option ""xml"". The XML package is enabled by default. documentation. See also classes TBufferXML, TKeyXML, TXMLEngine, TXMLSetup and TXMLPlayer.; An example of XML file corresponding to the small example below; can be found at http://root.cern.ch/root/Example.xml. Function Members (Methods); public:. TXMLFile(); TXMLFile(const char* filename, Option_t* option = ""read"", const char* title = ""title"", Int_t compression = 1); virtual~TXMLFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXMLFile.html:1796,test,test,1796,root/html528/TXMLFile.html,https://root.cern,https://root.cern/root/html528/TXMLFile.html,4,['test'],['test']
Testability,"ries, calibrations.; The XML file is built in memory before being dumped to disk. Like for normal ROOT files, XML files use the same I/O mechanism; exploiting the ROOT/CINT dictionary. Any class having a dictionary; can be saved in XML format. This first implementation does not support subdirectories; or Trees. The shared library libRXML.so may be loaded dynamically; via gSystem->Load(""libRXML""). This library is automatically; loaded by the plugin manager as soon as a XML file is created; via, eg; TFile::Open(""file.xml"",""recreate"");; TFile::Open returns a TXMLFile object. When a XML file is open in write mode,; one can use the normal TObject::Write to write an object in the file.; Alternatively one can use the new functions TDirectoryFile::WriteObject and; TDirectoryFile::WriteObjectAny to write a TObject* or any class not deriving; from TObject. example of a session saving a histogram to a XML file. TFile *f = TFile::Open(""Example.xml"",""recreate"");; TH1F *h = new TH1F(""h"",""test"",1000,-2,2);; h->FillRandom(""gaus"");; h->Write();; delete f;. example of a session reading the histogram from the file. TFile *f = TFile::Open(""Example.xml"");; TH1F *h = (TH1F*)f->Get(""h"");; h->Draw();. A new option in the canvas ""File"" menu is available to save; a TCanvas as a XML file. One can also do; canvas->Print(""Example.xml"");. Configuring ROOT with the option ""xml"". The XML package is enabled by default. documentation. See also classes TBufferXML, TKeyXML, TXMLEngine, TXMLSetup and TXMLPlayer.; An example of XML file corresponding to the small example below; can be found at http://root.cern.ch/root/Example.xml. Function Members (Methods); public:. virtual~TXMLFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); Bool_tAddXmlComment(const char* comment); Bool_tAddXmlLine(const char* line); Bool_tAddXmlSt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXMLFile.html:1820,test,test,1820,root/html602/TXMLFile.html,https://root.cern,https://root.cern/root/html602/TXMLFile.html,2,['test'],['test']
Testability,"ries. Function documentation; MethodCFMlpANN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""3000:N-1:N-2"", TDirectory* theTargetDir = 0); standard constructor; option string: ""n_training_cycles:n_hidden_layers""; default is: n_training_cycles = 5000, n_layers = 4. * note that the number of hidden layers in the NN is:; n_hidden_layers = n_layers - 2. * since there is one input and one output layer. The number of; nodes (neurons) is predefined to be:; n_nodes[i] = nvars + 1 - i (where i=1..n_layers). with nvars being the number of variables used in the NN. Hence, the default case is: n_neurons(layer 1 (input)) : nvars; n_neurons(layer 2 (hidden)): nvars-1; n_neurons(layer 3 (hidden)): nvars-1; n_neurons(layer 4 (out)) : 2. This artificial neural network usually needs a relatively large; number of cycles to converge (8000 and more). Overtraining can; be efficienctly tested by comparing the signal and background; output of the NN for the events that were used for training and; an independent data sample (with equal properties). If the separation; performance is significantly better for the training sample, the; NN interprets statistical effects, and is hence overtrained. In; this case, the number of cycles should be reduced, or the size; of the training sample increased. MethodCFMlpANN(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = NULL); constructor from weight file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t ); CFMlpANN can handle classification with 2 classes. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options: NCycles=xx :the number of training cycles; HiddenLayser=""N-1,N-2"" :the specification of the hidden layers. void ProcessOptions(); decode the options in the option string. void Init( void ); default initialisation called by all constructors. ~MethodCFMlpANN( void )",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodCFMlpANN.html:21298,test,tested,21298,root/html528/TMVA__MethodCFMlpANN.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodCFMlpANN.html,4,['test'],['tested']
Testability,"ries. Function documentation; MethodCFMlpANN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""3000:N-1:N-2"", TDirectory* theTargetDir = 0); standard constructor; option string: ""n_training_cycles:n_hidden_layers""; default is: n_training_cycles = 5000, n_layers = 4. * note that the number of hidden layers in the NN is:; n_hidden_layers = n_layers - 2. * since there is one input and one output layer. The number of; nodes (neurons) is predefined to be:; n_nodes[i] = nvars + 1 - i (where i=1..n_layers). with nvars being the number of variables used in the NN. Hence, the default case is: n_neurons(layer 1 (input)) : nvars; n_neurons(layer 2 (hidden)): nvars-1; n_neurons(layer 3 (hidden)): nvars-1; n_neurons(layer 4 (out)) : 2. This artificial neural network usually needs a relatively large; number of cycles to converge (8000 and more). Overtraining can; be efficienctly tested by comparing the signal and background; output of the NN for the events that were used for training and; an independent data sample (with equal properties). If the separation; performance is significantly better for the training sample, the; NN interprets statistical effects, and is hence overtrained. In; this case, the number of cycles should be reduced, or the size; of the training sample increased. MethodCFMlpANN(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t ); CFMlpANN can handle classification with 2 classes. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options: NCycles=xx :the number of training cycles; HiddenLayser=""N-1,N-2"" :the specification of the hidden layers. void ProcessOptions(); decode the options in the option string. void Init( void ); default initialisation called by all constructors. ~MethodCFMlpANN( void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodCFMlpANN.html:23270,test,tested,23270,root/html602/TMVA__MethodCFMlpANN.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodCFMlpANN.html,2,['test'],['tested']
Testability,"rieves some of them in arrays thanks to GetVal,; generates and draw graphs with these arrays. The option goff in TTree::Draw behaves like any other drawing option except that, at the end, no graphics is produced ( goff= graphics off). This allows to generate as many TTree variables as needed. All the graphics options (except para and candle) are limited to four variables only. And para and candle need at least two variables.; Note that by default TTree::Draw creates the arrays obtained with GetVal with a length corresponding to the parameter fEstimate. By default fEstimate=1000000 and can be modified via TTree::SetEstimate. To keep in memory all the results use: tree->SetEstimate(-1);; SetEstimate should be called if the expected number of selected rows is greater than 1000000. ; The arrays' dimension is 5000; ; void treegetval() {; // create a simple TTree with 5 branches; Int_t run, evt;; Float_t x,y,z;; TTree *T = new TTree(""T"",""test friend trees"");; T->Branch(""Run"",&run,""Run/I"");; T->Branch(""Event"",&evt,""Event/I"");; T->Branch(""x"",&x,""x/F"");; T->Branch(""y"",&y,""y/F"");; T->Branch(""z"",&z,""z/F"");; TRandom r;; for (Int_t i=0;i<10000;i++) {; if (i < 5000) run = 1;; else run = 2;; evt = i;; x = r.Gaus(10,1);; y = r.Gaus(20,2);; z = r.Landau(2,1);; T->Fill();; }; ; // Draw with option goff and generate seven variables; Int_t n = T->Draw(""x:y:z:Run:Event:sin(x):cos(x)"",""Run==1"",""goff"");; printf(""The arrays' dimension is %d\n"",n);; ; // Retrieve variables 0, 5 et 6; Double_t *vx = T->GetVal(0);; Double_t *vxs = T->GetVal(5);; Double_t *vxc = T->GetVal(6);; ; // Create and draw graphs; TGraph *gs = new TGraph(n,vx,vxs);; TGraph *gc = new TGraph(n,vx,vxc);; gs->Draw(""ap"");; gc->Draw(""p"");; }; ; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Double_tdouble Double_tDefinition RtypesCore.h:59; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/treegetval_8C.html:1327,test,test,1327,doc/master/treegetval_8C.html,https://root.cern,https://root.cern/doc/master/treegetval_8C.html,1,['test'],['test']
Testability,"rigin[3]box origin; Double_tTGeoTube::fRmaxouter radius; Double_tTGeoTube::fRmininner radius; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoEltu(); Dummy constructor. TGeoEltu(Double_t a, Double_t b, Double_t dz); Default constructor specifying X and Y semiaxis length. TGeoEltu(const char* name, Double_t a, Double_t b, Double_t dz); Default constructor specifying X and Y semiaxis length. TGeoEltu(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = A; param[1] = B; param[2] = dz. ~TGeoEltu(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside the elliptical tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the shape along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoEltu.html:13957,test,test,13957,root/html534/TGeoEltu.html,https://root.cern,https://root.cern/root/html534/TGeoEltu.html,3,['test'],['test']
Testability,"riginator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tmaxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*mean(RooRealVar& obs); RooAbsMoment*mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tminTrialSamples(const RooArgSet&) const; RooAbsMoment*moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tnumEvalErrorItems(); static Int_tnumEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_toffset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_toperator==(Double_t value) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsReal.html:17975,test,testArg,17975,root/html534/RooAbsReal.html,https://root.cern,https://root.cern/root/html534/RooAbsReal.html,1,['test'],['testArg']
Testability,"riginator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tmaxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*mean(RooRealVar& obs); RooAbsMoment*mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tminTrialSamples(const RooArgSet&) const; RooAbsMoment*moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tnumEvalErrorItems(); static Int_tnumEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_toffset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsReal&operator=(const RooAbsReal&); Bool_toperator==(Double_t value) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsReal.html:17970,test,testArg,17970,root/html602/RooAbsReal.html,https://root.cern,https://root.cern/root/html602/RooAbsReal.html,2,['test'],['testArg']
Testability,"ring Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t UChar_t lenDefinition TGWin32VirtualXProxy.cxx:249; TGeoTube.h; TH2F.h; TList.h; TParticle.h; TROOT.h; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; CaloTowerProxyBuilderDefinition collection_proxies.C:484; CaloTowerProxyBuilder::CaloTowerProxyBuilderCaloTowerProxyBuilder(REveCaloDataHist *cd)Definition collection_proxies.C:511; CaloTowerProxyBuilder::assertSlicevoid assertSlice()Definition collection_proxies.C:490; CaloTowerProxyBuilder::fCaloDataREveCaloDataHist * fCaloDataDefinition collection_proxies.C:486; CaloTowerProxyBuilder::FillImpliedSelectedvoid FillImpliedSelected(REveElement::Set_t &impSet, const std::set< int > &sec_idcs, Product *) overrideDefinition collection_proxies.C:541; CaloTowerProxyBuilder::fSliceIndexint fSliceIndexDefinition collection_proxies.C:488; CaloTowerProxyBuilder::fHistTH2F * fHistDefinition collection_proxies.C:487; CaloTowerProxyBuilder::BuildProductvoid BuildProduct(const REveDataCollection *collection, REveElement *product, const REveViewContext *) overrideDefinition collection_proxies.C:514; CaloTowerProxyBuilder::ModelChangesvoid ModelChanges(const REveDataCollection::Ids_t &ids, Product *product) overrideDefinition collection_proxies.C:549; CollectionManagerDefinition collection_proxies.C:561; CollectionManager::addCollectionvoid addCollection(REveDataCollection *collection, REveDataProxyBuilderBase *glBui",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/collection__proxies_8C_source.html:35328,assert,assertSlicevoid,35328,doc/master/collection__proxies_8C_source.html,https://root.cern,https://root.cern/doc/master/collection__proxies_8C_source.html,2,['assert'],"['assertSlice', 'assertSlicevoid']"
Testability,"ring attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooProfileLL(); Default constructor; Should only be used by proof. RooProfileLL(const char* name, const char* title, RooAbsReal& nll, const RooArgSet& observables); Constructor of profile likelihood given input likelihood nll w.r.t; the given set of variables. The input log likelihood is minimized w.r.t; to all other variables of the likelihood at each evaluation and the; value of the global log likelihood minimum is always subtracted. RooProfileLL(const RooProfileLL& other, const char* name = 0); Copy constructor. ~RooProfileLL(); Destructor. const RooArgSet& bestFitParams() const. const RooArgSet& bestFitObs() const. RooAbsReal* createProfile(const RooArgSet& paramsOfInterest); Optimized implementation of createProfile for profile likelihoods.; Return profile of original function in terms of stated parameters; of interest rather than profiling recursively. void initializeMinimizer() const. Double_t evaluate() const; Evaluate profile likelihood by minimizing likelihood w.r.t. all; parameters that are not considered observables of this profile; likelihood object. void validateAbsMin() const; Check that parameters and likelihood value for 'best fit' are still valid. If not,; because the best fit has never been calculated, or because constant parameters have; changed value or parameters have changed const/float status, the minimum is recalculated. Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProfileLL.html:38854,log,log,38854,root/html602/RooProfileLL.html,https://root.cern,https://root.cern/root/html602/RooProfileLL.html,2,['log'],['log']
Testability,"ring cname containing color name, like ""green"" or ""#00FF00"". ;  ; Bool_t PointInRegion (Int_t x, Int_t y, Region_t reg) override;  Returns true if the point x,y is in the region. ;  ; Region_t PolygonRegion (Point_t *points, Int_t np, Bool_t winding) override;  Create region for the polygon defined by the points array. ;  ; void PutImage (Drawable_t id, GContext_t gc, Drawable_t img, Int_t dx, Int_t dy, Int_t x, Int_t y, UInt_t w, UInt_t h) override;  Put (x,y,w,h) part of image img in window win at position dx,dy. ;  ; void PutPixel (Drawable_t id, Int_t x, Int_t y, ULong_t pixel) override;  Set pixel at specified location in XImage img. ;  ; void QueryColor (Colormap_t cmap, ColorStruct_t &color) override;  Fill in the primary color components for a specific pixel value. ;  ; void QueryPointer (Int_t &ix, Int_t &iy) override;  Query pointer position. ;  ; void QueryPointer (Window_t id, Window_t &rootw, Window_t &childw, Int_t &root_x, Int_t &root_y, Int_t &win_x, Int_t &win_y, UInt_t &mask) override;  Returns the root window the pointer is logically on and the pointer coordinates relative to the root window's origin. ;  ; void RaiseWindow (Window_t id) override;  Put window on top of window stack. ;  ; Pixmap_t ReadGIF (Int_t x0, Int_t y0, const char *file, Window_t id=0) override;  If id is NULL - loads the specified gif file at position [x0,y0] in the current window. ;  ; Bool_t ReadPictureDataFromFile (const char *filename, char ***ret_data) override;  Read picture data from file and store in ret_data. ;  ; void RemoveWindow (ULong_t qwid) override;  Remove a window created by Qt (like CloseWindow1()). ;  ; void ReparentWindow (Window_t id, Window_t pid, Int_t x, Int_t y) override;  Reparent window to new parent window at position (x,y). ;  ; Int_t RequestLocator (Int_t mode, Int_t ctyp, Int_t &x, Int_t &y) override;  Request Locator position. ;  ; Int_t RequestString (Int_t x, Int_t y, char *text) override;  Request a string. ;  ; void RescaleWindow (Int_t wid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGX11.html:17754,log,logically,17754,doc/master/classTGX11.html,https://root.cern,https://root.cern/doc/master/classTGX11.html,2,['log'],['logically']
Testability,"ring& variable). void SetWeightExpression(const TString& variable, const TString& className = """"); Log() << kWarning << DefaultDataSetInfo().GetNClasses() /*fClasses.size()*/ << Endl;. void SetCut(const TString& cut, const TString& className = """"). void SetCut(const TCut& cut, const TString& className = """"). void AddCut(const TString& cut, const TString& className = """"). void AddCut(const TCut& cut, const TString& className = """"). void PrepareTrainingAndTestTree(const TCut& cut, Int_t NsigTrain, Int_t NbkgTrain, Int_t NsigTest, Int_t NbkgTest, const TString& otherOpt = ""SplitMode=Random:!V""); prepare the training and test trees. void PrepareTrainingAndTestTree(const TCut& cut, Int_t Ntrain, Int_t Ntest = -1); prepare the training and test trees; kept for backward compatibility. void PrepareTrainingAndTestTree(const TCut& cut, const TString& splitOpt); prepare the training and test trees; -> same cuts for signal and background. void PrepareTrainingAndTestTree(TCut sigcut, TCut bkgcut, const TString& splitOpt); prepare the training and test trees. TMVA::MethodBase* BookMethod(TString theMethodName, TString methodTitle, TString theOption = """"); Book a classifier or regression method. TMVA::MethodBase* BookMethod(TMVA::Types::EMVA theMethod, TString methodTitle, TString theOption = """"); books MVA method; the option configuration string is custom for each MVA; the TString field ""theNameAppendix"" serves to define (and distinguish); several instances of a given MVA, eg, when one wants to compare the; performance of various configurations. TMVA::IMethod* GetMethod(const TString& title) const; returns pointer to MVA that corresponds to given method title. void WriteDataInformation(); put correlations of input data and a few (default + user; selected) transformations into the root file. void OptimizeAllMethods(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); iterates through all booked methods and sees if they use parameter tuning and if so..; does just that i.e. c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__Factory.html:18356,test,test,18356,root/html530/TMVA__Factory.html,https://root.cern,https://root.cern/root/html530/TMVA__Factory.html,3,['test'],['test']
Testability,"ring& variable). void SetWeightExpression(const TString& variable, const TString& className = """"); Log() << kWarning << DefaultDataSetInfo().GetNClasses() /*fClasses.size()*/ << Endl;. void SetCut(const TString& cut, const TString& className = """"). void SetCut(const TCut& cut, const TString& className = """"). void AddCut(const TString& cut, const TString& className = """"). void AddCut(const TCut& cut, const TString& className = """"). void PrepareTrainingAndTestTree(const TCut& cut, Int_t NsigTrain, Int_t NbkgTrain, Int_t NsigTest, Int_t NbkgTest, const TString& otherOpt = ""SplitMode=Random:!V""); prepare the training and test trees. void PrepareTrainingAndTestTree(const TCut& cut, Int_t Ntrain, Int_t Ntest = -1); prepare the training and test trees; kept for backward compatibility. void PrepareTrainingAndTestTree(const TCut& cut, const TString& splitOpt); prepare the training and test trees; -> same cuts for signal and background. void PrepareTrainingAndTestTree(TCut sigcut, TCut bkgcut, const TString& splitOpt); prepare the training and test trees. TMVA::MethodBase* BookMethod(TString theMethodName, TString methodTitle, TString theOption = """"); Book a classifier or regression method. TMVA::MethodBase* BookMethod(TMVA::Types::EMVA theMethod, TString methodTitle, TString theOption = """"); books MVA method; the option configuration string is custom for each MVA; the TString field ""theNameAppendix"" serves to define (and distinguish); several instances of a given MVA, eg, when one wants to compare the; performance of various configurations. TMVA::IMethod* GetMethod(const TString& title) const; returns pointer to MVA that corresponds to given method title. void WriteDataInformation(); put correlations of input data and a few (default + user; selected) transformations into the root file. void OptimizeAllMethods(TString fomType = ""ROCIntegral"", TString fitType = ""Scan""); iterates through all booked methods and sees if they use parameter tuning and if so..; does just that i.e. ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__Factory.html:18488,test,test,18488,root/html528/TMVA__Factory.html,https://root.cern,https://root.cern/root/html528/TMVA__Factory.html,1,['test'],['test']
Testability,"ring,t);; 5481 ; 5482 if (!strstr(typeDesc, ""(*)("")) {; 5483 const char *s = strchr(typeDesc, ' ');; 5484 const char *template_start = strchr(typeDesc, '<');; 5485 if (!strcmp(typeDesc, ""long long"")) {; 5486 t = typeDesc;; 5487 }; 5488 else if (!strncmp(typeDesc, ""unsigned "", s + 1 - typeDesc)) {; 5489 t = typeDesc;; 5490 }; 5491 // s is the position of the second 'word' (if any); 5492 // except in the case of templates where there will be a space; 5493 // just before any closing '>': eg.; 5494 // TObj<std::vector<UShort_t,__malloc_alloc_template<0> > >*; 5495 else if (s && (template_start == nullptr || (s < template_start))) {; 5496 t = s + 1;; 5497 }; 5498 else {; 5499 t = typeDesc;; 5500 }; 5501 }; 5502 else {; 5503 t = typeDesc;; 5504 }; 5505 auto l = t.length();; 5506 while (l > 0 && (t[l - 1] == '*' || t[l - 1] == '&')); 5507 --l;; 5508 t.resize(l);; 5509 return t.c_str(); // NOLINT; 5510}; 5511 ; 5512static bool requiresRootMap(const char* rootmapfile); 5513{; 5514 assert(rootmapfile && *rootmapfile);; 5515 ; 5516 llvm::StringRef libName = llvm::sys::path::filename(rootmapfile);; 5517 libName.consume_back("".rootmap"");; 5518 ; 5519 return !gInterpreter->HasPCMForLibrary(libName.str().c_str());; 5520}; 5521 ; 5522////////////////////////////////////////////////////////////////////////////////; 5523/// Read and parse a rootmapfile in its new format, and return 0 in case of; 5524/// success, -1 if the file has already been read, and -3 in case its format; 5525/// is the old one (e.g. containing ""Library.ClassName""), -4 in case of syntax; 5526/// error.; 5527 ; 5528int TCling::ReadRootmapFile(const char *rootmapfile, TUniqueString *uniqueString); 5529{; 5530 if (!(rootmapfile && *rootmapfile)); 5531 return 0;; 5532 ; 5533 if (!requiresRootMap(rootmapfile)); 5534 return 0; // success; 5535 ; 5536 // For ""class "", ""namespace "", ""typedef "", ""header "", ""enum "", ""var "" respectively; 5537 const std::map<char, unsigned int> keyLenMap = {{'c',6},{'n',10},{'t',8},{'h',7},{",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:214394,assert,assert,214394,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['assert'],['assert']
Testability,"ringstd::vector< TString > SplitString(const TString &theOpt, const char separator) constsplits the option string at 'separator' and fills the list 'splitV' with the primitive stringsDefinition Tools.cxx:1199; TMVA::Tools::Colorconst TString & Color(const TString &)human readable color stringsDefinition Tools.cxx:828; TMVA::Tools::GetCorrelationMatrixconst TMatrixD * GetCorrelationMatrix(const TMatrixD *covMat)turns covariance into correlation matrixDefinition Tools.cxx:324; TMVA::Tools::kHtmlLink@ kHtmlLinkDefinition Tools.h:212; TMVA::Tools::UsefulSortAscendingvoid UsefulSortAscending(std::vector< std::vector< Double_t > > &, std::vector< TString > *vs=nullptr)sort 2D vector (AND in parallel a TString vector) in such a way that the ""first vector is sorted"" and...Definition Tools.cxx:538; TMVA::Tools::TMVACitationvoid TMVACitation(MsgLogger &logger, ECitation citType=kPlainText)kinds of TMVA citationDefinition Tools.cxx:1440; TMVA::Tools::TMVAVersionMessagevoid TMVAVersionMessage(MsgLogger &logger)prints the TMVA release number and dateDefinition Tools.cxx:1316; TMVA::Tools::TMVAWelcomeMessagevoid TMVAWelcomeMessage()direct output, eg, when starting ROOT session -> no use of Logger hereDefinition Tools.cxx:1302; TMVA::TransformationHandlerClass that contains all the data information.Definition TransformationHandler.h:56; TMVA::TransformationHandler::PrintVariableRankingvoid PrintVariableRanking() constprints ranking of input variablesDefinition TransformationHandler.cxx:926; TMVA::TypesSingleton class for Global types used by TMVA.Definition Types.h:71; TMVA::Types::Instancestatic Types & Instance()The single instance of ""Types"" if existing already, or create it (Singleton)Definition Types.cxx:70; TMVA::Types::EMVAEMVADefinition Types.h:76; TMVA::Types::kCategory@ kCategoryDefinition Types.h:97; TMVA::Types::kCuts@ kCutsDefinition Types.h:78; TMVA::Types::EAnalysisTypeEAnalysisTypeDefinition Types.h:126; TMVA::Types::kMulticlass@ kMulticlassDefinition Types.h:129; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:134711,log,logger,134711,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['log'],['logger']
Testability,"ring GetRFName (TString name);  ; void ImportSetup ();  import setup from MethodRuleFit ;  ; void InitRuleFit ();  default initialisation SetRFWorkDir(""./rulefit""); ;  ; Bool_t OpenRFile (TString name, std::ifstream &f);  ; Bool_t OpenRFile (TString name, std::ofstream &f);  ; Int_t ReadFloat (std::ifstream &f, Float_t *v, Int_t n=1) const;  ; Int_t ReadInt (std::ifstream &f, Int_t *v, Int_t n=1) const;  ; Bool_t ReadIntParms ();  ; Bool_t ReadLx ();  ; Bool_t ReadProgram ();  ; Bool_t ReadRealParms ();  ; Bool_t ReadRealVarImp ();  ; Bool_t ReadRfOut ();  ; Bool_t ReadRfStatus ();  ; Bool_t ReadRuleFitMod ();  ; Bool_t ReadRuleFitSum ();  ; Bool_t ReadTrainW ();  ; Bool_t ReadTrainX ();  ; Bool_t ReadTrainY ();  ; Bool_t ReadVarImp ();  read variable importance ;  ; Bool_t ReadVarNames ();  ; Bool_t ReadYhat ();  read the score ;  ; Int_t RunRuleFit ();  execute rf_go.exe ;  ; void SetRFPredict ();  ; void SetRFTrain ();  ; void SetRFVarimp ();  ; void SetTestParms ();  set the test params ;  ; void SetTrainParms ();  set the training parameters ;  ; Bool_t WriteAll ();  write all files read by rf_go.exe ;  ; Bool_t WriteFloat (std::ofstream &f, const Float_t *v, Int_t n=1);  ; Bool_t WriteInt (std::ofstream &f, const Int_t *v, Int_t n=1);  ; Bool_t WriteIntParms ();  write int params file ;  ; Bool_t WriteLx ();  Save input variable mask. ;  ; Bool_t WriteProgram ();  write command to rf_go.exe ;  ; Bool_t WriteRealParms ();  write int params file ;  ; Bool_t WriteRealVarImp ();  write the minimum importance to be considered ;  ; Bool_t WriteRfOut ();  written by rf_go.exe; write rulefit output (rfout) ;  ; Bool_t WriteRfStatus ();  written by rf_go.exe; write rulefit status ;  ; Bool_t WriteRuleFitMod ();  written by rf_go.exe (NOTE:Format unknown!) ;  ; Bool_t WriteRuleFitSum ();  written by rf_go.exe (NOTE: format unknown!) ;  ; Bool_t WriteTest ();  Write test data. ;  ; Bool_t WriteTrain ();  write training data, column wise ;  ; Bool_t WriteVarImp ();  ; Bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1RuleFitAPI.html:2740,test,test,2740,doc/master/classTMVA_1_1RuleFitAPI.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1RuleFitAPI.html,1,['test'],['test']
Testability,"rint details of each error up to numErr messages per p.d.f component. EvalErrorValue(double value) Set curve points at which (pdf) evaluation errors occur to specified value. By default the function value is plotted. Normalization(double scale, ScaleType code) Adjust normalization by given scale factor. Interpretation of number depends on code:; Relative: relative adjustment factor for a normalized function,; NumEvent: scale to match given number of events.; Raw: relative adjustment factor for an un-normalized function. Name(const chat* name) Give curve specified name in frame. Useful if curve is to be referenced later. Asymmetry(const RooCategory& c) Show the asymmetry of the PDF in given two-state category [F(+)-F(-)] / [F(+)+F(-)] rather than the PDF projection. Category must have two states with indices -1 and +1 or three states with indices -1,0 and +1. ShiftToZero(bool flag) Shift entire curve such that lowest visible point is at exactly zero. Mostly useful when plotting \( -\log(L) \) or \( \chi^2 \) distributions. AddTo(const char* name, double_t wgtSelf, double_t wgtOther) Add constructed projection to already existing curve with given name and relative weight factors . Components(const char* names) When plotting sums of PDFs, plot only the named components (e.g. only the signal of a signal+background model). . Components(const RooArgSet& compSet) As above, but pass a RooArgSet of the components themselves. Plotting control . DrawOption(const char* opt) Select ROOT draw option for resulting TGraph object. Currently supported options are ""F"" (fill), ""L"" (line), and ""P"" (points). NoteOption ""P"" will cause RooFit to plot (and treat) this pdf as if it were data! This is intended for plotting ""corrected data""-type pdfs such as ""data-minus-background"" or unfolded datasets. LineStyle(Int_t style) Select line style by ROOT line style code, default is solid. LineColor(Int_t color) Select line color by ROOT color code, default is blue. LineWidth(Int_t width) Select l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:133383,log,log,133383,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,2,['log'],['log']
Testability,"riority to users request. ; Otherwise use the system information, if available, or just start the minimal number, i.e. 2 . ; Definition at line 406 of file TProofLite.cxx. ◆ GetStagingStatusDataSet(). TFileCollection * TProofLite::GetStagingStatusDataSet ; (; const char * ; dataset). overridevirtual . Obtains a TFileCollection showing the staging status of the specified dataset. ; A valid dataset manager and dataset staging requests repository must be present on the endpoint. PROOF-Lite version of the equivalent function from TProofServ. ; Reimplemented from TProof.; Definition at line 2223 of file TProofLite.cxx. ◆ GetTreeHeader(). TTree * TProofLite::GetTreeHeader ; (; TDSet * ; tdset). overridevirtual . Creates a tree header (a tree with nonexisting files) object for the DataSet. ; Reimplemented from TProof.; Definition at line 2397 of file TProofLite.cxx. ◆ Init(). Int_t TProofLite::Init ; (; const char * ; masterurl, . const char * ; conffile, . const char * ; confdir, . Int_t ; loglevel, . const char * ; alias = 0 . ). protected . Start the PROOF environment. ; Starting PROOF involves either connecting to a master server, which in turn will start a set of slave servers, or directly starting as master server (if master = """"). For a description of the arguments see the TProof ctor. Returns the number of started master or slave servers, returns 0 in case of error, in which case fValid remains false. ; Definition at line 154 of file TProofLite.cxx. ◆ InitDataSetManager(). Int_t TProofLite::InitDataSetManager ; (; ). private . Initialize the dataset manager from directives or from defaults Return 0 on success, -1 on failure. ; Definition at line 1412 of file TProofLite.cxx. ◆ IsA(). TClass * TProofLite::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TProof.; Definition at line 170 of file TProofLite.h. ◆ Load(). Int_t TProofLite::Load ; (; const char * ; macro, . Bool_t ; notOnClient = kFALSE, . Bool_t ; uniq",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:53733,log,loglevel,53733,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['log'],['loglevel']
Testability,"riple knot. the representation (*) remains; valid in each open interval (x(i),x(i+1)). at a double knot,; x(j) = x(j+1), the output coefficients have the following values:; y(j) = s(x(j)) = y(j+1); b(j) = s'(x(j)) = b(j+1); c(j) = s""(x(j))/2 = c(j+1); d(j) = s""'(x(j))/6 = d(j+1); e(j) = s""""(x(j)-0)/24 e(j+1) = s""""(x(j)+0)/24; f(j) = s""""'(x(j)-0)/120 f(j+1) = s""""'(x(j)+0)/120; at a triple knot, x(j) = x(j+1) = x(j+2), the output; coefficients have the following values:; y(j) = s(x(j)) = y(j+1) = y(j+2); b(j) = s'(x(j)) = b(j+1) = b(j+2); c(j) = s""(x(j))/2 = c(j+1) = c(j+2); d(j) = s""'((x(j)-0)/6 d(j+1) = 0 d(j+2) = s""'(x(j)+0)/6; e(j) = s""""(x(j)-0)/24 e(j+1) = 0 e(j+2) = s""""(x(j)+0)/24; f(j) = s""""'(x(j)-0)/120 f(j+1) = 0 f(j+2) = s""""'(x(j)+0)/120. void Test(); Test method for TSpline5. n number of data points.; m 2*m-1 is order of spline.; m = 3 always for quintic spline.; nn,nm1,mm,; mm1,i,k,; j,jj temporary integer variables.; z,p temporary double precision variables.; x[n] the sequence of knots.; y[n] the prescribed function values at the knots.; a[200][6] two dimensional array whose columns are; the computed spline coefficients; diff[5] maximum values of differences of values and; derivatives to right and left of knots.; com[5] maximum values of coefficients. test of TSpline5 with nonequidistant knots and; equidistant knots follows. void Streamer(TBuffer& b); Stream an object of class TSpline5. void GetKnot(Int_t i, Double_t& x, Double_t& y) const. void GetCoeff(Int_t i, Double_t &x, Double_t &y, Double_t &b, Double_t &c, Double_t &d). TSpline5(); {}. virtual ~TSpline5(); {if (fPoly) delete [] fPoly;}. » Author: Federico Carminati 28/02/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id: TSpline.h 34074 2010-06-23 09:08:49Z brun $ » Last generated: 2010-10-10 12:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpline5.html:15839,test,test,15839,root/html528/TSpline5.html,https://root.cern,https://root.cern/root/html528/TSpline5.html,1,['test'],['test']
Testability,"riple knot. the representation (*) remains; valid in each open interval (x(i),x(i+1)). at a double knot,; x(j) = x(j+1), the output coefficients have the following values:; y(j) = s(x(j)) = y(j+1); b(j) = s'(x(j)) = b(j+1); c(j) = s""(x(j))/2 = c(j+1); d(j) = s""'(x(j))/6 = d(j+1); e(j) = s""""(x(j)-0)/24 e(j+1) = s""""(x(j)+0)/24; f(j) = s""""'(x(j)-0)/120 f(j+1) = s""""'(x(j)+0)/120; at a triple knot, x(j) = x(j+1) = x(j+2), the output; coefficients have the following values:; y(j) = s(x(j)) = y(j+1) = y(j+2); b(j) = s'(x(j)) = b(j+1) = b(j+2); c(j) = s""(x(j))/2 = c(j+1) = c(j+2); d(j) = s""'((x(j)-0)/6 d(j+1) = 0 d(j+2) = s""'(x(j)+0)/6; e(j) = s""""(x(j)-0)/24 e(j+1) = 0 e(j+2) = s""""(x(j)+0)/24; f(j) = s""""'(x(j)-0)/120 f(j+1) = 0 f(j+2) = s""""'(x(j)+0)/120. void Test(); Test method for TSpline5. n number of data points.; m 2*m-1 is order of spline.; m = 3 always for quintic spline.; nn,nm1,mm,; mm1,i,k,; j,jj temporary integer variables.; z,p temporary double precision variables.; x[n] the sequence of knots.; y[n] the prescribed function values at the knots.; a[200][6] two dimensional array whose columns are; the computed spline coefficients; diff[5] maximum values of differences of values and; derivatives to right and left of knots.; com[5] maximum values of coefficients. test of TSpline5 with nonequidistant knots and; equidistant knots follows. void Streamer(TBuffer& b); Stream an object of class TSpline5. void GetKnot(Int_t i, Double_t& x, Double_t& y) const. void GetCoeff(Int_t i, Double_t &x, Double_t &y, Double_t &b, Double_t &c, Double_t &d). TSpline5(); {}. virtual ~TSpline5(); {if (fPoly) delete [] fPoly;}. » Author: Federico Carminati 28/02/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id: TSpline.h 34074 2010-06-23 09:08:49Z brun $ » Last generated: 2011-07-04 15:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSpline5.html:15939,test,test,15939,root/html530/TSpline5.html,https://root.cern,https://root.cern/root/html530/TSpline5.html,1,['test'],['test']
Testability,"riple knot. the representation (*) remains; valid in each open interval (x(i),x(i+1)). at a double knot,; x(j) = x(j+1), the output coefficients have the following values:; y(j) = s(x(j)) = y(j+1); b(j) = s'(x(j)) = b(j+1); c(j) = s""(x(j))/2 = c(j+1); d(j) = s""'(x(j))/6 = d(j+1); e(j) = s""""(x(j)-0)/24 e(j+1) = s""""(x(j)+0)/24; f(j) = s""""'(x(j)-0)/120 f(j+1) = s""""'(x(j)+0)/120; at a triple knot, x(j) = x(j+1) = x(j+2), the output; coefficients have the following values:; y(j) = s(x(j)) = y(j+1) = y(j+2); b(j) = s'(x(j)) = b(j+1) = b(j+2); c(j) = s""(x(j))/2 = c(j+1) = c(j+2); d(j) = s""'((x(j)-0)/6 d(j+1) = 0 d(j+2) = s""'(x(j)+0)/6; e(j) = s""""(x(j)-0)/24 e(j+1) = 0 e(j+2) = s""""(x(j)+0)/24; f(j) = s""""'(x(j)-0)/120 f(j+1) = 0 f(j+2) = s""""'(x(j)+0)/120. void Test(); Test method for TSpline5. n number of data points.; m 2*m-1 is order of spline.; m = 3 always for quintic spline.; nn,nm1,mm,; mm1,i,k,; j,jj temporary integer variables.; z,p temporary double precision variables.; x[n] the sequence of knots.; y[n] the prescribed function values at the knots.; a[200][6] two dimensional array whose columns are; the computed spline coefficients; diff[5] maximum values of differences of values and; derivatives to right and left of knots.; com[5] maximum values of coefficients. test of TSpline5 with nonequidistant knots and; equidistant knots follows. void Streamer(TBuffer& b); Stream an object of class TSpline5. void GetKnot(Int_t i, Double_t& x, Double_t& y) const. void GetCoeff(Int_t i, Double_t &x, Double_t &y, Double_t &b, Double_t &c, Double_t &d). TSpline5(); {}. virtual ~TSpline5(); {if (fPoly) delete [] fPoly;}. » Author: Federico Carminati 28/02/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id: TSpline.h 34074 2010-06-23 09:08:49Z brun $ » Last generated: 2011-11-03 20:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSpline5.html:15939,test,test,15939,root/html532/TSpline5.html,https://root.cern,https://root.cern/root/html532/TSpline5.html,1,['test'],['test']
Testability,"ript ;  CTPRegexp;  CTPrimaryOld version of a dynamic particle class created by event generators ;  CTPrincipalPrincipal Components Analysis (PCA) ;  CTProcessEventTimer;  CTProcessIDA TProcessID identifies a ROOT job in a unique way in time and space ;  CTProcessUUIDThis class is a specialized TProcessID managing the list of UUIDs ;  CTProfileProfile Histogram ;  CTProfile2DProfile2D histograms are used to display the mean value of Z and its RMS for each cell in X,Y ;  CTProfile2Poly2D Profile Histogram with Polygonal Bins ;  CTProfile2PolyBinHelper class to represent a bin in the TProfile2Poly histogram ;  CTProfile3DProfile3D histograms are used to display the mean value of T and its RMS for each cell in X,Y,Z ;  CTProfileHelper;  ►CTProofThis class controls a Parallel ROOT Facility, PROOF, cluster ;  CMD5Mod_t;  CTProofBenchSteering class for PROOF benchmarks ;  CTProofBenchDataSetHandle operations on datasets used by ProofBench ;  CTProofBenchRunAbstract base class for PROOF benchmark runs ;  CTProofBenchRunCPUCPU-intensive PROOF benchmark test generates events and fill 1, 2, or 3-D histograms ;  CTProofBenchRunDataReadI/O-intensive PROOF benchmark test reads in event files distributed on the cluster ;  CTProofChain;  CTProofCondor;  CTProofDebug;  CTProofDesc;  CTProofDrawImplement Tree drawing using PROOF ;  CTProofDrawEntryList;  CTProofDrawEventList;  CTProofDrawGraph;  CTProofDrawHist;  ►CTProofDrawListOfGraphs;  CPoint3D_t;  ►CTProofDrawListOfPolyMarkers3D;  CPoint4D_t;  CTProofDrawPolyMarker3D;  CTProofDrawProfile;  CTProofDrawProfile2D;  CTProofInputHandler;  CTProofInterruptHandler;  CTProofLimitsFinderClass to find axis limits and synchronize them between workers ;  CTProofLiteThis class starts a PROOF session on the local machine: no daemons, client and master merged, communications via UNIX-like sockets ;  CTProofLockPath;  CTProofLockPathGuard;  CTProofLogImplementation of the PROOF session log handler ;  CTProofLogElem;  CTProofMergePrg;  CTProofM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:195240,benchmark,benchmark,195240,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,3,['benchmark'],['benchmark']
Testability,"ript header; Color_tfHistFillColorhistogram fill color; Style_tfHistFillStylehistogram fill style; Color_tfHistLineColorhistogram line color; Style_tfHistLineStylehistogram line style; Width_tfHistLineWidthhistogram line width; Bool_tfHistMinimumZerotrue if default minimum is 0, false if minimum is automatic; Double_tfHistTopMarginmargin between histogram's top and pad's top; Bool_tfIsReading!Set to FALSE when userclass::UseCurrentStyle is called by the style manager; Width_tfLegendBorderSizeTLegend box border size; Float_tfLegoInnerRInner radius for cylindrical legos; Float_tfLineScalePSLine scale factor when drawing lines on Postscript; TStringfLineStyle[30]String describing line style i (for postScript); Int_tfNumberContoursdefault number of contours for 2-d plots; Int_tfOptDate=1 if date option is selected; Int_tfOptFile=1 if option File is selected; Int_tfOptFit=1 if option Fit is selected; Int_tfOptLogx=1 if log scale in X; Int_tfOptLogy=1 if log scale in y; Int_tfOptLogz=1 if log scale in z; Int_tfOptStat=1 if option Stat is selected; Int_tfOptTitle=1 if option Title is selected; Int_tfPadBorderModepad border mode; Width_tfPadBorderSizepad border size; Float_tfPadBottomMarginpad bottom margin; Color_tfPadColorpad color; Bool_tfPadGridXtrue to get the grid along X; Bool_tfPadGridYtrue to get the grid along Y; Float_tfPadLeftMarginpad left margin; Float_tfPadRightMarginpad right margin; Int_tfPadTickX=1 to set special pad ticks along X; Int_tfPadTickY=1 to set special pad ticks along Y; Float_tfPadTopMarginpad top margin; TStringfPaintTextFormatPrinting format for TH2::PaintText; Float_tfPaperSizeXPostScript paper size along X; Float_tfPaperSizeYPostScript paper size along Y; Float_tfScreenFactorMultiplication factor for canvas size and position; Int_tfShowEditorShow pad editor; Int_tfShowEventStatusShow event status panel; Int_tfShowToolBarShow toolbar; Width_tfStatBorderSizeborder size of Stats PaveLabel; Color_tfStatColorstat fill area color; Style_tfStatFon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStyle.html:19825,log,log,19825,root/html528/TStyle.html,https://root.cern,https://root.cern/root/html528/TStyle.html,1,['log'],['log']
Testability,"rited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . Private Member Functions; double _DEBUG_getVal (const RooArgSet *normalisationSet) const;  Debug version of getVal(), which is slow and does error checking. ;  . Friends; class AddCacheElem;  ; class BatchInterfaceAccessor;  ; class RooAddHelpers;  ; class RooAddModel;  ; class RooAddPdf;  ; class RooFit::EvalContext;  ; class RooRealBinding;  ; class RooRealSumFunc;  ; class RooRealSumPdf;  ; class RooVectorDataStore;  . Additional Inherited Members;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <RooAbsReal.h>. Inheritance diagram for RooAbsReal:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ value_type. using RooAbsReal::value_type = double. Definition at line 61 of file RooAbsReal.h. Member Enumeration Documentation. ◆ ErrorLoggingMode. enum RooAbsReal::ErrorLoggingMode. EnumeratorPrintErrors ; CollectErrors ; CountErrors ; Ignore . Definition at line 317 of file RooAbsReal.h. ◆ ScaleType. enum RooAbsReal::ScaleType. EnumeratorRaw ; Relative ; NumEvent ; RelativeExpected . Definition at line 276 of file RooAbsReal.h. Constructor & Destructor Documentation. ◆ RooAbsReal() [1/4]. RooAbsReal::RooAbsReal ; (; ). coverity[UNINIT_CTOR] Default constructor ; Definition at line 199 of file RooAbsReal.cxx. ◆ RooAbsReal() [2/4]. RooAbsReal::RooAbsReal ; (; const char * ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:60340,test,testArg,60340,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,4,['test'],['testArg']
Testability,"rited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; std::unique_ptr< const RooArgList > fAllTestStatisticsData;  for the case of multiple test statistics, holds all the results ;  ; std::unique_ptr< RooDataSet > fAltDetailedOutput;  ; std::unique_ptr< SamplingDistribution > fAltDistr;  ; double fAlternatePValue;  p-value for the alternate hypothesis (small number means disfavoured) ;  ; double fAlternatePValueError;  error of p-value for the alternate hypothesis (small number means disfavoured) ;  ; bool fBackgroundIsAlt;  ; std::unique_ptr< RooDataSet > fFitInfo;  ; std::unique_ptr< RooDataSet > fNullDetailedOutput;  ; std::unique_ptr< SamplingDistribution > fNullDistr;  ; double fNullPValue;  p-value for the null hypothesis (small number means disfavoured) ;  ; double fNullPValueError;  error of p-value for the null hypothesis (small number means disfavoured) ;  ; bool fPValueIsRightTail;  ; double fTestStatisticData;  result of the test statistic evaluated on data ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions; void UpdatePValue (const SamplingDistribution *distr, double &pvalue, double &perror, bool pIsRightTail);  updates the pvalue if sufficient data is available ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1HypoTestResult.html:14703,test,test,14703,doc/master/classRooStats_1_1HypoTestResult.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1HypoTestResult.html,2,['test'],['test']
Testability,"rithm associates each; algorithm with a number. There is a utility function to help; to set the value of compress. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; cout << ""Error opening file"" << endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile.Recover: 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs referenced by this file are deleted.; Calling TFile::Close(""R"") might be necessary in case one reads a long list; of files having TRef, writing some of the referenced objects or TRef; to a new file. If the TRef or referenced objects of the file being closed; will not be referenced again, it is possible to minimize the size; of th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFile.html:27610,log,logical,27610,root/html534/TFile.html,https://root.cern,https://root.cern/root/html534/TFile.html,1,['log'],['logical']
Testability,"rithm associates each; algorithm with a number. There is a utility function to help; to set the value of compress. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; cout << ""Error opening file"" << endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile::Recover 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs referenced by this file are deleted.; Calling TFile::Close(""R"") might be necessary in case one reads a long list; of files having TRef, writing some of the referenced objects or TRef; to a new file. If the TRef or referenced objects of the file being closed; will not be referenced again, it is possible to minimize the size; of th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFile.html:26927,log,logical,26927,root/html530/TFile.html,https://root.cern,https://root.cern/root/html530/TFile.html,2,['log'],['logical']
Testability,"rithm:; The loop is executed with the end-point coordinates of a line segment; (X1,Y1)-(X2,Y2) and the Y-coordinate of a horizontal line.; The counter inter is incremented if the line (X1,Y1)-(X2,Y2) intersects; the horizontal line. In this case XINT is set to the X-coordinate of the; intersection point. If inter is an odd number, then the point x,y is within; the polygon. void LeastSquareFit(Int_t m, Double_t* a, Double_t xmin = 0, Double_t xmax = 0); Least squares polynomial fitting without weights. m number of parameters; a array of parameters; first 1st point number to fit (default =0); last last point number to fit (default=fNpoints-1). based on CERNLIB routine LSQ: Translated to C++ by Rene Brun. void LeastSquareLinearFit(Int_t n, Double_t& a0, Double_t& a1, Int_t& ifail, Double_t xmin = 0, Double_t xmax = 0); Least square linear fit without weights. Fit a straight line (a0 + a1*x) to the data in this graph.; ndata: if ndata<0, fits the logarithm of the graph (used in InitExpo() to set; the initial parameter values for a fit with exponential function.; a0: constant; a1: slope; ifail: return parameter indicating the status of the fit (ifail=0, fit is OK); xmin, xmax: fitting range. extracted from CERNLIB LLSQ: Translated to C++ by Rene Brun. void Paint(Option_t* chopt = """"); Draw this graph with its current attributes. void PaintGraph(Int_t npoints, const Double_t* x, const Double_t* y, Option_t* chopt); Draw the (x,y) as a graph. void PaintGrapHist(Int_t npoints, const Double_t* x, const Double_t* y, Option_t* chopt); Draw the (x,y) as a histogram. void PaintStats(TF1* fit); Draw the stats. void Print(Option_t* chopt = """") const; Print graph values. void RecursiveRemove(TObject* obj); Recursively remove object from the list of functions. Int_t RemovePoint(); Delete point close to the mouse position. Int_t RemovePoint(Int_t ipoint); Delete point number ipoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on outpu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraph.html:36492,log,logarithm,36492,root/html528/TGraph.html,https://root.cern,https://root.cern/root/html528/TGraph.html,6,['log'],['logarithm']
Testability,"rix ("") + fDataSetInfo.GetClassInfo(cls)->GetName() + TString("")""));; 624 if (h != 0) {; 625 h->Write();; 626 delete h;; 627 }; 628 }; 629 } else {; 630 m = fDataSetInfo.CorrelationMatrix(""Signal"");; 631 h = fDataSetInfo.CreateCorrelationMatrixHist(m, ""CorrelationMatrixS"", ""Correlation Matrix (signal)"");; 632 if (h != 0) {; 633 h->Write();; 634 delete h;; 635 }; 636 ; 637 m = fDataSetInfo.CorrelationMatrix(""Background"");; 638 h = fDataSetInfo.CreateCorrelationMatrixHist(m, ""CorrelationMatrixB"", ""Correlation Matrix (background)"");; 639 if (h != 0) {; 640 h->Write();; 641 delete h;; 642 }; 643 ; 644 m = fDataSetInfo.CorrelationMatrix(""Regression"");; 645 h = fDataSetInfo.CreateCorrelationMatrixHist(m, ""CorrelationMatrix"", ""Correlation Matrix"");; 646 if (h != 0) {; 647 h->Write();; 648 delete h;; 649 }; 650 }; 651 ; 652 // some default transformations to evaluate; 653 // NOTE: all transformations are destroyed after this test; 654 TString processTrfs = ""I""; //""I;N;D;P;U;G,D;""; 655 ; 656 // plus some user defined transformations; 657 processTrfs = fTransformations;; 658 ; 659 // remove any trace of identity transform - if given (avoid to apply it twice); 660 std::vector<TMVA::TransformationHandler *> trfs;; 661 TransformationHandler *identityTrHandler = 0;; 662 ; 663 std::vector<TString> trfsDef = gTools().SplitString(processTrfs, ';');; 664 std::vector<TString>::iterator trfsDefIt = trfsDef.begin();; 665 for (; trfsDefIt != trfsDef.end(); ++trfsDefIt) {; 666 trfs.push_back(new TMVA::TransformationHandler(fDataSetInfo, ""Factory""));; 667 TString trfS = (*trfsDefIt);; 668 ; 669 // Log() << kINFO << Endl;; 670 Log() << kDEBUG << ""current transformation string: '"" << trfS.Data() << ""'"" << Endl;; 671 TMVA::CreateVariableTransforms(trfS, fDataSetInfo, *(trfs.back()), Log());; 672 ; 673 if (trfS.BeginsWith('I')); 674 identityTrHandler = trfs.back();; 675 }; 676 ; 677 const std::vector<Event *> &inputEvents = fDataSetInfo.GetDataSet()->GetEventCollection();; 678 ; 679 // apply a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:26210,test,test,26210,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['test'],['test']
Testability,"rix = batch.GetOutput();; 1596 auto weights = batch.GetWeights();; 1597 trainingError += deepNet.Loss(inputTensor, outputMatrix, weights, false, false);; 1598 }; 1599 }; 1600 // normalize loss to number of batches and add regularization term; 1601 trainingError /= (Double_t)(nTrainingSamples / settings.batchSize);; 1602 trainingError += regTerm;; 1603 ; 1604 //Log the loss value; 1605 fTrainHistory.AddValue(""trainingError"",nTrainEpochs,trainingError);; 1606 ; 1607 // stop measuring; 1608 tend = std::chrono::system_clock::now();; 1609 ; 1610 // Compute numerical throughput.; 1611 std::chrono::duration<double> elapsed_seconds = tend - tstart;; 1612 std::chrono::duration<double> elapsed1 = t1-tstart;; 1613 // std::chrono::duration<double> elapsed2 = t2-tstart;; 1614 // time to compute training and test errors; 1615 std::chrono::duration<double> elapsed_testing = tend-t1;; 1616 ; 1617 double seconds = elapsed_seconds.count();; 1618 // double nGFlops = (double)(settings.testInterval * batchesInEpoch * settings.batchSize)*1.E-9;; 1619 // nGFlops *= deepnet.GetNFlops() * 1e-9;; 1620 double eventTime = elapsed1.count()/( batchesInEpoch * settings.testInterval * settings.batchSize);; 1621 ; 1622 converged =; 1623 convergenceCount > settings.convergenceSteps || nTrainEpochs >= settings.maxEpochs;; 1624 ; 1625 ; 1626 Log() << std::setw(10) << nTrainEpochs << "" | ""; 1627 << std::setw(12) << trainingError; 1628 << std::setw(12) << valError; 1629 << std::setw(12) << seconds / settings.testInterval; 1630 << std::setw(12) << elapsed_testing.count(); 1631 << std::setw(12) << 1. / eventTime; 1632 << std::setw(12) << convergenceCount; 1633 << Endl;; 1634 ; 1635 if (converged) {; 1636 Log() << Endl;; 1637 }; 1638 tstart = std::chrono::system_clock::now();; 1639 }; 1640 ; 1641 // if (stepCount % 10 == 0 || converged) {; 1642 if (converged && debug) {; 1643 Log() << ""Final Deep Net Weights for phase "" << trainingPhase << "" epoch "" << nTrainEpochs; 1644 << Endl;; 1645 auto & weights_tensor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:64341,test,testInterval,64341,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['test'],['testInterval']
Testability,"rix.Definition TGeoPainter.cxx:1249; TGeoPainter::DrawVolumevoid DrawVolume(TGeoVolume *vol, Option_t *option="""") overrideDraw method.Definition TGeoPainter.cxx:820; TGeoPainter::GetDrawnVolumeTGeoVolume * GetDrawnVolume() const overrideGet currently drawn volume.Definition TGeoPainter.cxx:338; TGeoPainter::DrawPolygonvoid DrawPolygon(const TGeoPolygon *poly) overrideDraw a polygon in 3D.Definition TGeoPainter.cxx:770; TGeoPainter::fNsegmentsInt_t fNsegmentsDefinition TGeoPainter.h:47; TGeoPainter::Testvoid Test(Int_t npoints, Option_t *option) overrideCheck time of finding ""Where am I"" for n points.Definition TGeoPainter.cxx:2170; TGeoPainter::PaintVolumevoid PaintVolume(TGeoVolume *vol, Option_t *option="""", TGeoMatrix *global=nullptr) overridePaint recursively a node and its content according to visualization options.Definition TGeoPainter.cxx:1384; TGeoPainter::fVolInfoTString fVolInfoDefinition TGeoPainter.h:58; TGeoPainter::CheckShapevoid CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option) overrideTest for shape navigation methods.Definition TGeoPainter.cxx:254; TGeoPainter::RandomPointsvoid RandomPoints(const TGeoVolume *vol, Int_t npoints, Option_t *option="""") overrideDraw random points in the bounding box of a volume.Definition TGeoPainter.cxx:1693; TGeoPainter::fTopVisibleBool_t fTopVisibleDefinition TGeoPainter.h:53; TGeoPainter::fGlobalTGeoHMatrix * fGlobalDefinition TGeoPainter.h:61; TGeoPainter::fVisLevelInt_t fVisLevelDefinition TGeoPainter.h:49; TGeoPainter::SetNsegmentsvoid SetNsegments(Int_t nseg=20) overrideSet number of segments to approximate circles.Definition TGeoPainter.cxx:1992; TGeoPainter::CheckBoundaryReferencevoid CheckBoundaryReference(Int_t icheck=-1) overrideCheck the boundary errors reference file created by CheckBoundaryErrors method.Definition TGeoPainter.cxx:210; TGeoPainter::AddTrackPointvoid AddTrackPoint(Double_t *point, Double_t *box, Bool_t reset=kFALSE) overrideAverage center of view of all painted tra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPainter_8cxx_source.html:103195,test,testNo,103195,doc/master/TGeoPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html,1,['test'],['testNo']
Testability,"rix.Definition TGeoPainter.cxx:1249; TGeoPainter::DrawVolumevoid DrawVolume(TGeoVolume *vol, Option_t *option="""") overrideDraw method.Definition TGeoPainter.cxx:820; TGeoPainter::GetDrawnVolumeTGeoVolume * GetDrawnVolume() const overrideGet currently drawn volume.Definition TGeoPainter.cxx:338; TGeoPainter::DrawPolygonvoid DrawPolygon(const TGeoPolygon *poly) overrideDraw a polygon in 3D.Definition TGeoPainter.cxx:770; TGeoPainter::fNsegmentsInt_t fNsegmentsDefinition TGeoPainter.h:47; TGeoPainter::Testvoid Test(Int_t npoints, Option_t *option) overrideCheck time of finding ""Where am I"" for n points.Definition TGeoPainter.cxx:2170; TGeoPainter::PaintVolumevoid PaintVolume(TGeoVolume *vol, Option_t *option="""", TGeoMatrix *global=nullptr) overridePaint recursively a node and its content according to visualization options.Definition TGeoPainter.cxx:1384; TGeoPainter::fVolInfoTString fVolInfoDefinition TGeoPainter.h:58; TGeoPainter::CheckShapevoid CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option) overrideTest for shape navigation methods.Definition TGeoPainter.cxx:254; TGeoPainter::SetIteratorPluginvoid SetIteratorPlugin(TGeoIteratorPlugin *plugin) overrideDefinition TGeoPainter.h:165; TGeoPainter::RandomPointsvoid RandomPoints(const TGeoVolume *vol, Int_t npoints, Option_t *option="""") overrideDraw random points in the bounding box of a volume.Definition TGeoPainter.cxx:1693; TGeoPainter::fTopVisibleBool_t fTopVisibleDefinition TGeoPainter.h:53; TGeoPainter::GetTopVolumeTGeoVolume * GetTopVolume() const overrideDefinition TGeoPainter.h:129; TGeoPainter::fGlobalTGeoHMatrix * fGlobalDefinition TGeoPainter.h:61; TGeoPainter::GetBombFactorsvoid GetBombFactors(Double_t &bombx, Double_t &bomby, Double_t &bombz, Double_t &bombr) const overrideDefinition TGeoPainter.h:116; TGeoPainter::fVisLevelInt_t fVisLevelDefinition TGeoPainter.h:49; TGeoPainter::Lockvoid Lock(Bool_t flag=kTRUE)Definition TGeoPainter.h:142; TGeoPainter::SetNsegmentsvoid SetNsegment",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPainter_8h_source.html:22096,test,testNo,22096,doc/master/TGeoPainter_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoPainter_8h_source.html,1,['test'],['testNo']
Testability,"rixT<Element> target;; 2553 ; 2554 if (gMatrixCheck && !AreCompatible(source1, source2)) {; 2555 Error(""operator||(const TMatrixT&,const TMatrixTSym&)"", ""matrices not compatible"");; 2556 return target;; 2557 }; 2558 ; 2559 target.ResizeTo(source1);; 2560 ; 2561 const Element *sp1 = source1.GetMatrixArray();; 2562 const Element *sp2 = source2.GetMatrixArray();; 2563 Element *tp = target.GetMatrixArray();; 2564 const Element *const tp_last = tp + target.GetNoElements();; 2565 while (tp < tp_last); 2566 *tp++ = (*sp1++ != 0.0 || *sp2++ != 0.0);; 2567 ; 2568 return target;; 2569}; 2570 ; 2571////////////////////////////////////////////////////////////////////////////////; 2572/// Logical OR; 2573 ; 2574template <class Element>; 2575TMatrixT<Element> TMatrixTAutoloadOps::operator||(const TMatrixTSym<Element> &source1, const TMatrixT<Element> &source2); 2576{; 2577 return operator||(source2, source1);; 2578}; 2579 ; 2580////////////////////////////////////////////////////////////////////////////////; 2581/// logical operation source1 > source2; 2582 ; 2583template <class Element>; 2584TMatrixT<Element> TMatrixTAutoloadOps::operator>(const TMatrixT<Element> &source1, const TMatrixT<Element> &source2); 2585{; 2586 TMatrixT<Element> target;; 2587 ; 2588 if (gMatrixCheck && !AreCompatible(source1, source2)) {; 2589 Error(""operator|(const TMatrixT&,const TMatrixT&)"", ""matrices not compatible"");; 2590 return target;; 2591 }; 2592 ; 2593 target.ResizeTo(source1);; 2594 ; 2595 const Element *sp1 = source1.GetMatrixArray();; 2596 const Element *sp2 = source2.GetMatrixArray();; 2597 Element *tp = target.GetMatrixArray();; 2598 const Element *const tp_last = tp + target.GetNoElements();; 2599 while (tp < tp_last) {; 2600 *tp++ = (*sp1) > (*sp2);; 2601 sp1++;; 2602 sp2++;; 2603 }; 2604 ; 2605 return target;; 2606}; 2607 ; 2608////////////////////////////////////////////////////////////////////////////////; 2609/// logical operation source1 > source2; 2610 ; 2611template <class Elemen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMatrixT_8cxx_source.html:90671,log,logical,90671,doc/master/TMatrixT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html,1,['log'],['logical']
Testability,"rization _regularization=TMVA::DNN::EnumRegularization::NONE, MinimizerType _eMinimizerType=MinimizerType::fSteepest, double _learningRate=1e-5, double _momentum=0.3, int _repetitions=3, bool _multithreading=true);  c'tor ;  ; virtual ~Settings ();  d'tor ;  ; void addPoint (std::string histoName, double x);  for monitoring ;  ; void addPoint (std::string histoName, double x, double y);  for monitoring ;  ; size_t batchSize () const;  mini-batch size ;  ; void clear (std::string histoName);  for monitoring ;  ; virtual void computeResult (const Net &, std::vector< double > &);  callback for monitoring and logging ;  ; size_t convergenceCount () const;  returns the current convergence count ;  ; size_t convergenceSteps () const;  how many steps until training is deemed to have converged ;  ; void create (std::string histoName, int bins, double min, double max);  for monitoring ;  ; void create (std::string histoName, int bins, double min, double max, int bins2, double min2, double max2);  for monitoring ;  ; virtual void cycle (double progress, TString text);  ; virtual void drawSample (const std::vector< double > &, const std::vector< double > &, const std::vector< double > &, double);  callback for monitoring and logging ;  ; const std::vector< double > & dropFractions () const;  ; size_t dropRepetitions () const;  ; bool exists (std::string histoName);  for monitoring ;  ; double factorWeightDecay () const;  get the weight-decay factor ;  ; virtual bool hasConverged (double testError);  has this training converged already? ;  ; double learningRate () const;  get the learning rate ;  ; size_t maxConvergenceCount () const;  returns the max convergence count so far ;  ; size_t minError () const;  returns the smallest error so far ;  ; MinimizerType minimizerType () const;  which minimizer shall be used (e.g. SGD) ;  ; double momentum () const;  get the momentum (e.g. for SGD) ;  ; void pads (int numPads);  preparation for monitoring ;  ; void plot (std::string histoN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html:2701,log,logging,2701,doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html,3,"['log', 'test']","['logging', 'testError']"
Testability,"rization(settings.regularization);; 1127 // Need to convert dropoutprobabilities to conventions used; 1128 // by backend implementation.; 1129 std::vector<Double_t> dropoutVector(settings.dropoutProbabilities);; 1130 for (auto & p : dropoutVector) {; 1131 p = 1.0 - p;; 1132 }; 1133 net.SetDropoutProbabilities(dropoutVector);; 1134 net.InitializeGradients();; 1135 auto testNet = net.CreateClone(settings.batchSize);; 1136 ; 1137 using DataLoader_t = TDataLoader<TMVAInput_t, TCpu<>>;; 1138 ; 1139 // Split training data into training and validation set; 1140 const std::vector<Event *> &allData = GetEventCollection(Types::kTraining);; 1141 const std::vector<Event *> trainingInputData =; 1142 std::vector<Event *>(allData.begin(), allData.begin() + nTrainingSamples);; 1143 const std::vector<Event *> testInputData =; 1144 std::vector<Event *>(allData.begin() + nTrainingSamples, allData.end());; 1145 ; 1146 if (trainingInputData.size() != nTrainingSamples) {; 1147 Log() << kFATAL << ""Inconsistent training sample size"" << Endl;; 1148 }; 1149 if (testInputData.size() != nTestSamples) {; 1150 Log() << kFATAL << ""Inconsistent test sample size"" << Endl;; 1151 }; 1152 ; 1153 size_t nThreads = 1;; 1154 TMVAInput_t trainingTuple = std::tie(trainingInputData, DataInfo());; 1155 TMVAInput_t testTuple = std::tie(testInputData, DataInfo());; 1156 DataLoader_t trainingData(trainingTuple, nTrainingSamples,; 1157 net.GetBatchSize(), net.GetInputWidth(),; 1158 net.GetOutputWidth(), nThreads);; 1159 DataLoader_t testData(testTuple, nTestSamples, testNet.GetBatchSize(),; 1160 net.GetInputWidth(), net.GetOutputWidth(),; 1161 nThreads);; 1162 DNN::TGradientDescent<TCpu<>> minimizer(settings.learningRate,; 1163 settings.convergenceSteps,; 1164 settings.testInterval);; 1165 ; 1166 std::vector<TNet<TCpu<>>> nets{};; 1167 std::vector<TBatch<TCpu<>>> batches{};; 1168 nets.reserve(nThreads);; 1169 for (size_t i = 0; i < nThreads; i++) {; 1170 nets.push_back(net);; 1171 for (size_t j = 0; j < net.GetD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:41435,test,testInputData,41435,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['test'],['testInputData']
Testability,"rk properly; gPad->Update();; myTree->Draw(""Cost:Age"", """",""same"");; }; In this example, h2->Draw is only adding the object h2 to the pad’s list of primitives. It does not paint the object on the screen. However, TTree::Draw when called with option “same” gets the current pad coordinates to build an intermediate histogram with the right limits. Since nothing has been painted in the pad yet, the pad limits have not been computed. Calling pad->Update() forces the painting of the pad and allows TTree::Draw to compute the right limits for the intermediate histogram.; 12.20.6 Setting the Range in TTree::Draw; There are two more optional parameters to the TTree::Draw method: one is the number of entries and the second one is the entry to start with. For example, this command draws 1000 entries starting with entry 100:; myTree->Draw(""Cost:Age"", """","""",1000,100);; 12.20.7 TTree::Draw Examples; The examples below use the Event.root file generated by the $ROOTSYS/test/Event executable and the Event, Track, and EventHeader class definitions are in $ROOTSYS/test/Event.h. The commands have been tested on the split-levels 0, 1, and 9. Each command is numbered and referenced by the explanations immediately following the examples.; // Data members and methods; 1 tree->Draw(""fNtrack"");; 2 tree->Draw(""event.GetNtrack()"");; 3 tree->Draw(""GetNtrack()"");; 4 tree->Draw(""fH.fXaxis.fXmax"");; 5 tree->Draw(""fH.fXaxis.GetXmax()"");; 6 tree->Draw(""fH.GetXaxis().fXmax"");; 7 tree->Draw(""GetHistogram().GetXaxis().GetXmax()"");; // Expressions in the selection parameter; 8 tree->Draw(""fTracks.fPx"",""fEvtHdr.fEvtNum%10 == 0"");; 9 tree->Draw(""fPx"",""fEvtHdr.fEvtNum%10 == 0"");; // Two dimensional arrays defined as:; // Float_t fMatrix[4][4] in Event class; 10 tree->Draw(""fMatrix"");; 11 tree->Draw(""fMatrix[ ][ ]"");; 12 tree->Draw(""fMatrix[2][2]"");; 13 tree->Draw(""fMatrix[ ][0]"");; 14 tree->Draw(""fMatrix[1][ ]"");; // using two arrays... Float_t fVertex[3]; in Track class; 15 tree->Draw(""fMatrix - fVertex"");; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:592603,test,test,592603,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['test'],['test']
Testability,"rkers, which have not been yet assigned to any merger; static TPluginHandler*fgLogViewerLog dialog box plugin; static TList*fgProofEnvListList of TNameds defining environment. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProof(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); Create a PROOF environment. Starting PROOF involves either connecting; to a master server, which in turn will start a set of slave servers, or; directly starting as master server (if master = """"). Masterurl is of; the form: [proof[s]://]host[:port]. Conffile is the name of the config; file describing the remote PROOF cluster (this argument alows you to; describe different cluster configurations).; The default is proof.conf. Confdir is the directory where the config; file and other PROOF related files are (like motd and noproof files).; Loglevel is the log level (default = 1). User specified custom config; files will be first looked for in $HOME/.conffile. TProof(); Protected constructor to be used by classes deriving from TProof; (they have to call Init themselves and override StartSlaves; appropriately). This constructor simply closes any previous gProof and sets gProof; to this instance. void InitMembers(); Default initializations. ~TProof(); Clean up PROOF environment. Int_t Init(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); Start the PROOF environment. Starting PROOF involves either connecting; to a master server, which in turn will start a set of slave servers, or; directly starting as master server (if master = """"). For a description; of the arguments see the TProof ctor. Returns the number of started; master or slave servers, returns 0 in case of error, in which case; fValid remains false. Int_t GetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); Set th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProof.html:32589,log,log,32589,root/html530/TProof.html,https://root.cern,https://root.cern/root/html530/TProof.html,2,['log'],['log']
Testability,"rkers, which have not been yet assigned to any merger; static TPluginHandler*fgLogViewerLog dialog box plugin; static TList*fgProofEnvListList of TNameds defining environment. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProof(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); Create a PROOF environment. Starting PROOF involves either connecting; to a master server, which in turn will start a set of slave servers, or; directly starting as master server (if master = """"). Masterurl is of; the form: [proof[s]://]host[:port]. Conffile is the name of the config; file describing the remote PROOF cluster (this argument alows you to; describe different cluster configurations).; The default is proof.conf. Confdir is the directory where the config; file and other PROOF related files are (like motd and noproof files).; Loglevel is the log level (default = 1). User specified custom config; files will be first looked for in $HOME/.conffile. TProof(); Protected constructor to be used by classes deriving from TProof; (they have to call Init themselves and override StartSlaves; appropriately). This constructor simply closes any previous gProof and sets gProof; to this instance. void InitMembers(); Default initializations. ~TProof(); Clean up PROOF environment. Int_t Init(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); Start the PROOF environment. Starting PROOF involves either connecting; to a master server, which in turn will start a set of slave servers, or; directly starting as master server (if master = """"). For a description; of the arguments see the TProof ctor. Returns the number of started; master or slave servers, returns 0 in case of error, in which case; fValid remains false. void ParseConfigField(const char* config); The config file field may contain spec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:32353,log,log,32353,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,1,['log'],['log']
Testability,"rlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction3Binding<double,unsigned int,double,double>&operator=(const RooCFunction3Binding<double,unsigned int,double,double>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction3Binding_double_unsigned_int_double_double_.html:20102,test,testArg,20102,root/html602/RooCFunction3Binding_double_unsigned_int_double_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction3Binding_double_unsigned_int_double_double_.html,2,['test'],['testArg']
Testability,"rlay elements.; TGLOverlayList Collection of overlay elements to draw/select together.; TGLOvlSelectRecord Standard GL overlay-selection record.; TGLPShapeObj This object wraps TGLPhysicalShape (not a TObject); TGLPShapeObjEditor GUI for editing attributes of a physical-shape.; TGLPShapeRef Reference to a TGLPhysicalShape object.; TGLPadPainter ; TGLPaintDevice Base class for GL widgets and GL off-screen rendering; TGLParametricEquation Equation of parametric surface.; TGLParametricEquationGL GL renderer for TGLParametricEquation; TGLParametricPlot Parametric plot's painter.; TGLPerspectiveCamera Camera for perspective view.; TGLPhysicalShape a physical (placed, global frame) drawable object; TGLPlane GL plane helper/wrapper class; TGLPlotBox Back box for plot.; TGLPlotCamera Camera for plot-painters.; TGLPlotCoordinates Auxilary class, holds plot dimensions.; TGLPlotPainter Base for gl plots; TGLPolyLine a polyline logical shape; TGLPolyMarker a polymarker logical shape; TGLQuadric GL quadric object; TGLRect GL rect helper/wrapper class; TGLRnrCtx Collection of objects and data passes along all rendering calls.; TGLRotateManip GL rotation manipulator widget; TGLSAFrame GUI frame for standalone viewer; TGLSAViewer Standalone GL viewer.; TGLScaleManip GL scaling manipulator widget; TGLScene Standard ROOT OpenGL scene with logial/physical shapes.; TGLScene::TSceneInfo ; TGLSceneBase Base-class for OpenGL scenes.; TGLSceneInfo Data about a scene within a viewer context.; TGLScenePad GL-scene filled via TPad-TVirtualViewer interface.; TGLSelectBuffer OpenGL select buffer with depth sorting.; TGLSelectRecord Standard GL selection record.; TGLSelectRecordBase Base class for GL selection records.; TGLSelectionBuffer Holds color buffer content for selection; TGLSphere a spherical logical shape; TGLStopwatch a GL stopwatch utility class; TGLSurfacePainter Surface painter.; TGLTF3Painter GL TF3 painter.; TGLTH3Slice TH3 slice; TGLText a GL text; TGLTransManip GL translation m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:73618,log,logical,73618,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,2,['log'],['logical']
Testability,"rmLog"",""Some points have negative values - cannot apply a log transformation"");; 370 return *this;; 371 }; 372 ; 373 fData[i] = std::log( val );; 374 ; 375 if( kNoError == fErrorType ); 376 {; 377 fDataError[i] = val;; 378 }; 379 else if ( kValueError == fErrorType ); 380 {; 381 fDataError[i]*= val;; 382 }; 383 else if ( kCoordError == fErrorType ); 384 {; 385 fDataError[i]/= val;; 386 }; 387 else if ( kAsymError == fErrorType ); 388 {; 389 fDataErrorHigh[i]/= val;; 390 fDataErrorLow[i]/= val;; 391 }; 392 else; 393 assert(false);; 394 }; 395 ; 396 if ( kNoError == fErrorType ); 397 {; 398 fErrorType = kValueError;; 399 }; 400 ; 401 return *this;; 402 }; 403 ; 404 ; 405 /**; 406 add one dim data with only coordinate and values; 407 */; 408 void BinData::Add( double x, double y ); 409 {; 410 assert( kNoError == fErrorType );; 411 ; 412 assert( !fData.empty() && fDataPtr );; 413 assert( fDataErrorHigh.empty() && !fDataErrorHighPtr );; 414 assert( fDataErrorLow.empty() && !fDataErrorLowPtr );; 415 assert( fDataError.empty() && !fDataErrorPtr );; 416 assert( fCoordErrors.empty() && fCoordErrorsPtr.empty() );; 417 ; 418 fData[ fNPoints ] = y;; 419 ; 420 FitData::Add( x );; 421 fSumContent += y;; 422 }; 423 ; 424 /**; 425 add one dim data with no error in the coordinate (x); 426 in this case store the inverse of the error in the value (y); 427 */; 428 void BinData::Add( double x, double y, double ey ); 429 {; 430 assert( kValueError == fErrorType );; 431 assert( !fData.empty() && fDataPtr );; 432 assert( fDataErrorHigh.empty() && !fDataErrorHighPtr );; 433 assert( fDataErrorLow.empty() && !fDataErrorLowPtr );; 434 assert( !fDataError.empty() && fDataErrorPtr );; 435 assert( fCoordErrors.empty() && fCoordErrorsPtr.empty() );; 436 ; 437 fData[ fNPoints ] = y;; 438 fDataError[ fNPoints ] = (ey != 0.0) ? 1.0/ey : 0.0;; 439 ; 440 FitData::Add( x );; 441 fSumContent += y;; 442 if (y != 0 || ey != 1.0) fSumError2 += ey*ey;; 443 // set the weight flag checking if error^2 != y; 444",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:12019,assert,assert,12019,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['assert'],['assert']
Testability,"rmal distribution if Y=Ln(X) has normal distribution; 2394///; 2395/// \param[in] x is the evaluation point; 2396/// \param[in] sigma is the shape parameter; 2397/// \param[in] theta is the location parameter; 2398/// \param[in] m is the scale parameter; 2399///; 2400/// The formula was taken from ""Engineering Statistics Handbook"" on site; 2401/// http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm; 2402/// Implementation using ROOT::Math::lognormal_pdf; 2403///; 2404/// Begin_Macro; 2405/// {; 2406/// TCanvas *c1 = new TCanvas(""c1"", ""c1"", 700, 500);; 2407///; 2408/// c1->SetLogy();; 2409/// c1->SetGridx();; 2410/// c1->SetGridy();; 2411///; 2412/// TF1 *logn = new TF1(""logn"", ""TMath::LogNormal(x, [0], [1], [2])"", 0, 5);; 2413/// logn->SetMinimum(1e-3);; 2414///; 2415/// logn->SetParameters(0.5, 0., 1.);; 2416/// logn->SetLineColor(2);; 2417/// TF1 *logn1 = logn->DrawCopy(""L"");; 2418/// logn->SetParameters(1.0, 0., 1.);; 2419/// logn->SetLineColor(3);; 2420/// TF1 *logn2 = logn->DrawCopy(""LSAME"");; 2421/// logn->SetParameters(2.0, 0., 1.);; 2422/// logn->SetLineColor(4);; 2423/// TF1 *logn3 = logn->DrawCopy(""LSAME"");; 2424/// logn->SetParameters(5.0, 0., 1.);; 2425/// logn->SetLineColor(6);; 2426/// TF1 *logn4 = logn->DrawCopy(""LSAME"");; 2427///; 2428/// auto legend = new TLegend(0.15, 0.15, 0.5, 0.35);; 2429/// legend->AddEntry(logn1, ""sigma = 0.5, theta = 0, m = 1"", ""L"");; 2430/// legend->AddEntry(logn2, ""sigma = 1.0, theta = 0, m = 1"", ""L"");; 2431/// legend->AddEntry(logn3, ""sigma = 2.0, theta = 0, m = 1"", ""L"");; 2432/// legend->AddEntry(logn4, ""sigma = 5.0, theta = 0, m = 1"", ""L"");; 2433/// legend->Draw();; 2434/// }; 2435/// End_Macro; 2436 ; 2437Double_t TMath::LogNormal(Double_t x, Double_t sigma, Double_t theta, Double_t m); 2438{; 2439 if ((x<theta) || (sigma<=0) || (m<=0)) {; 2440 Error(""TMath::Lognormal"", ""illegal parameter values"");; 2441 return 0;; 2442 }; 2443 // lognormal_pdf uses same definition of http://en.wikipedia.org/wiki/Log-normal_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8cxx_source.html:82462,log,logn,82462,doc/master/TMath_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html,3,['log'],['logn']
Testability,"rmat; kNESDayMYear: date in day/month/year format; kNESMDayYear: date in month/day/year format; kNESHex: hex number. The following attributes can be specified:; kNEAAnyNumber: any number is allowed; kNEANonNegative: only non-negative numbers are allowed; kNEAPositive: only positive numbers are allowed. Explicit limits can be specified individually:; kNELNoLimits: no limits; kNELLimitMin: lower limit only; kNELLimitMax upper limit only; kNELLimitMinMax both lower and upper limits. TGNumberEntryField is a plain vanilla entry field, whereas TGNumberEntry adds two small buttons to increase and decrease the numerical value in the field. The number entry widgets also support using the up and down cursor keys to change the numerical values. The step size can be selected with control and shift keys:; – small step (1 unit/factor of 3); shift medium step (10 units/factor of 10); control large step (100 units/factor of 30); shift-control huge step (1000 units/factor of 100). The steps are either linear or logarithmic. The default behaviour is set when the entry field is created, but it can be changed by pressing the alt key at the same time.; Changing the number in the widget will generate the event:; kC_TEXTENTRY, kTE_TEXTCHANGED, widget id, 0. Hitting the enter key will generate:; kC_TEXTENTRY, kTE_ENTER, widget id, 0. Hitting the tab key will generate:; kC_TEXTENTRY, kTE_TAB, widget id, 0. . Definition at line 147 of file TGNumberEntry.h. Public Member Functions;  TGNumberEntry (const TGWindow *parent=nullptr, Double_t val=0, Int_t digitwidth=5, Int_t id=-1, EStyle style=kNESReal, EAttribute attr=kNEAAnyNumber, ELimit limits=kNELNoLimits, Double_t min=0, Double_t max=1);  Constructs a numeric entry widget. ;  ;  ~TGNumberEntry () override;  Destructs a numeric entry widget. ;  ; void Associate (const TGWindow *w) override;  Make w the window that will receive the generated messages. ;  ; TGButton * GetButtonDown () const;  Get the down button. ;  ; TGButton * GetButtonUp ()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGNumberEntry.html:2456,log,logarithmic,2456,doc/master/classTGNumberEntry.html,https://root.cern,https://root.cern/doc/master/classTGNumberEntry.html,1,['log'],['logarithmic']
Testability,"rmation (peaks) from useless; information (background). method is based on Sensitive Nonlinear Iterative Peak (SNIP) clipping; algorithm.; new value in the channel ""i"" is calculated. where p = 1, 2, ..., numberIterations. In fact it represents second order; difference filter (-1,2,-1).; One can also change the; direction of the change of the clipping window, the order of the clipping; filter, to include smoothing, to set width of smoothing window and to include; the estimation of Compton edges. On successful completion it returns 0. On; error it returns pointer to the string describing error.; Parameters:. spectrum: pointer to the vector of source spectrum; ssize: length of the spectrum vector; numberIterations: maximal width of clipping window,; direction: direction of change of clipping window.; Possible values: kBackIncreasingWindow, kBackDecreasingWindow; filterOrder: order of clipping filter.; Possible values: kBackOrder2, kBackOrder4, kBackOrder6, kBackOrder8; smoothing: logical variable whether the smoothing operation in the; estimation of background will be included.; Possible values: kFALSE, kTRUE; smoothWindow: width of smoothing window.; Possible values: kBackSmoothing3, kBackSmoothing5, kBackSmoothing7,; kBackSmoothing9, kBackSmoothing11, kBackSmoothing13, kBackSmoothing15.; compton: logical variable whether the estimation of Compton edge will be; included. Possible values: kFALSE, kTRUE. References:. C. G Ryan et al.: SNIP, a statistics-sensitive background treatment for the; quantitative analysis of PIXE spectra in geoscience applications. NIM, B34; (1988), 396-402.; M. Morh�č, J. Kliman, V. Matou�ek, M. Veselsk�, I. Turzo:; Background elimination methods for multidimensional gamma-ray spectra. NIM,; A401 (1997) 113-132.; D. D. Burgess, R. J. Tervo: Background estimation for gamma-ray; spectroscopy. NIM 214 (1983), 431-434. Example 1 script Background_incr.c:. Figure 1 Example of the estimation of background for number of iterations=6.; Original spectru",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum.html:14417,log,logical,14417,root/html528/TSpectrum.html,https://root.cern,https://root.cern/root/html528/TSpectrum.html,6,['log'],['logical']
Testability,"rmation); virtual voidReset(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAnalysisType(TMVA::Types::EAnalysisType type); voidSetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMethodBaseDir(TDirectory* methodDir); voidSetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidSetSignalReferenceCut(Double_t cut); voidSetSignalReferenceCutOrientation(Double_t cutOrientation); voidSetTestTime(Double_t testTime); voidSetTestvarName(const TString& v = """"); voidSetTrainTime(Double_t trainTime); virtual voidSetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTestClassification(); virtual voidTestMulticlass(); virtual voidTestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodBase.html:11652,test,testTime,11652,root/html602/TMVA__MethodBase.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodBase.html,2,['test'],['testTime']
Testability,"rmation); virtual voidReset(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAnalysisType(TMVA::Types::EAnalysisType type); voidSetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMethodBaseDir(TDirectory* methodDir); voidSetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidSetSignalReferenceCut(Double_t cut); voidSetSignalReferenceCutOrientation(Double_t cutOrientation); voidSetTestTime(Double_t testTime); voidSetTestvarName(const TString& v = """"); voidSetTrainTime(Double_t trainTime); virtual voidSetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetupMethod(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTestClassification(); virtual voidTestMulticlass(); virtual voidTestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodBase.html:11141,test,testTime,11141,root/html534/TMVA__MethodBase.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodBase.html,1,['test'],['testTime']
Testability,"rms of the first layer for compatibility with the previous implementation. ; Definition at line 193 of file DLMinimizers.h. ◆ StepReducedWeightsLoss(). template<typename Architecture_t > . auto TMVA::DNN::TDLGradientDescent< Architecture_t >::StepReducedWeightsLoss ; (; DeepNet_t & ; deepNet, . std::vector< Matrix_t > & ; input, . const Matrix_t & ; output, . const Matrix_t & ; weights . ). Similar to StepReducedWeights(...) but also evaluates the loss. ; May trigger synchronization with the device. ; Definition at line 224 of file DLMinimizers.h. Member Data Documentation. ◆ fBatchSize. template<typename Architecture_t > . size_t TMVA::DNN::TDLGradientDescent< Architecture_t >::fBatchSize. private . Batch size to use for the training. ; Definition at line 72 of file DLMinimizers.h. ◆ fConvergenceCount. template<typename Architecture_t > . size_t TMVA::DNN::TDLGradientDescent< Architecture_t >::fConvergenceCount. private . Current number of training epochs without. ; considerable decrease in the test error. ; Definition at line 76 of file DLMinimizers.h. ◆ fConvergenceSteps. template<typename Architecture_t > . size_t TMVA::DNN::TDLGradientDescent< Architecture_t >::fConvergenceSteps. private . Number of training epochs without considerable. ; decrease in the test error for convergence. ; Definition at line 74 of file DLMinimizers.h. ◆ fLearningRate. template<typename Architecture_t > . Scalar_t TMVA::DNN::TDLGradientDescent< Architecture_t >::fLearningRate. private . Learning rate \(\alpha\). ; Definition at line 81 of file DLMinimizers.h. ◆ fMinimumError. template<typename Architecture_t > . Scalar_t TMVA::DNN::TDLGradientDescent< Architecture_t >::fMinimumError. private . The minimum loss achieved on the training set during the current training session. ; Definition at line 82 of file DLMinimizers.h. ◆ fStepCount. template<typename Architecture_t > . size_t TMVA::DNN::TDLGradientDescent< Architecture_t >::fStepCount. private . Number of steps performed in the curr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html:11663,test,test,11663,doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html,1,['test'],['test']
Testability,"rn = kFALSE); Add a TFriendElement to the list of friends. The TTree is managed by the user (e.g., the user must delete the file).; For a complete description see AddFriend(const char *, const char *). Long64_t AutoSave(Option_t* option = """"); AutoSave tree header every fAutoSave bytes. When large Trees are produced, it is safe to activate the AutoSave; procedure. Some branches may have buffers holding many entries.; AutoSave is automatically called by TTree::Fill when the number of bytes; generated since the previous AutoSave is greater than fAutoSave bytes.; This function may also be invoked by the user, for example every; N entries.; Each AutoSave generates a new key on the file.; Once the key with the tree header has been written, the previous cycle; (if any) is deleted. Note that calling TTree::AutoSave too frequently (or similarly calling; TTree::SetAutoSave with a small value) is an expensive operation.; You should make tests for your own application to find a compromise; between speed and the quantity of information you may loose in case of; a job crash. In case your program crashes before closing the file holding this tree,; the file will be automatically recovered when you will connect the file; in UPDATE mode.; The Tree will be recovered at the status corresponding to the last AutoSave. if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; This allows another process to analyze the Tree while the Tree is being filled. if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; the current basket are closed-out and written to disk individually. By default the previous header is deleted after having written the new header.; if option contains ""Overwrite"", the previous Tree header is deleted; before written the new header. This option is slightly faster, but; the default option is safer in case of a problem (disk quota exceeded); when writing the new header. The function returns the number of bytes written to the file.; if the number",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:40445,test,tests,40445,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,1,['test'],['tests']
Testability,"rn = kFALSE); Add a TFriendElement to the list of friends. The TTree is managed by the user (e.g., the user must delete the file).; For a complete description see AddFriend(const char *, const char *). Long64_t AutoSave(Option_t* option = """"); AutoSave tree header every fAutoSave bytes. When large Trees are produced, it is safe to activate the AutoSave; procedure. Some branches may have buffers holding many entries.; AutoSave is automatically called by TTree::Fill when the number of bytes; generated since the previous AutoSave is greater than fAutoSave bytes.; This function may also be invoked by the user, for example every; N entries.; Each AutoSave generates a new key on the file.; Once the key with the tree header has been written, the previous cycle; (if any) is deleted. Note that calling TTree::AutoSave too frequently (or similarly calling; TTree::SetAutoSave with a small value) is an expensive operation.; You should make tests for your own application to find a compromize; between speed and the quantity of information you may loose in case of; a job crash. In case your program crashes before closing the file holding this tree,; the file will be automatically recovered when you will connect the file; in UPDATE mode.; The Tree will be recovered at the status corresponding to the last AutoSave. if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; This allows another process to analyze the Tree while the Tree is being filled. if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; the current basket are closed-out and written to disk individually. By default the previous header is deleted after having written the new header.; if option contains ""Overwrite"", the previous Tree header is deleted; before written the new header. This option is slightly faster, but; the default option is safer in case of a problem (disk quota exceeded); when writing the new header. The function returns the number of bytes written to the file.; if the number",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:38300,test,tests,38300,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,2,['test'],['tests']
Testability,"rn unur_get_dimension(fGen);; 381}; 382 ; 383int TUnuran::GetDistType() const; 384{; 385 // get type of distribution; 386 if (!fGen) return -1;; 387 return unur_distr_get_type (unur_get_distr(fGen));; 388}; 389 ; 390bool TUnuran::IsDistCont() const {; 391 if (!fGen) return false;; 392 return unur_distr_is_cont (unur_get_distr(fGen));; 393}; 394bool TUnuran::IsDistMultiCont() const {; 395 if (!fGen) return false;; 396 return unur_distr_is_cvec (unur_get_distr(fGen));; 397}; 398bool TUnuran::IsDistDiscrete() const {; 399 if (!fGen) return false;; 400 return unur_distr_is_discr (unur_get_distr(fGen));; 401}; 402bool TUnuran::IsDistEmpirical() const {; 403 if (!fGen) return false;; 404 return unur_distr_is_cemp (unur_get_distr(fGen));; 405}; 406 ; 407int TUnuran::SampleDiscr(); 408{; 409 // sample one-dimensional distribution; 410 assert(fGen != nullptr);; 411 return unur_sample_discr(fGen);; 412}; 413 ; 414double TUnuran::Sample(); 415{; 416 // sample one-dimensional distribution; 417 assert(fGen != nullptr);; 418 return unur_sample_cont(fGen);; 419}; 420 ; 421bool TUnuran::SampleMulti(double * x); 422{; 423 // sample multidimensional distribution; 424 if (fGen == nullptr) return false;; 425 unur_sample_vec(fGen,x);; 426 return true;; 427}; 428 ; 429void TUnuran::SetSeed(unsigned int seed) {; 430 return fRng->SetSeed(seed);; 431}; 432 ; 433bool TUnuran::SetLogLevel(unsigned int debugLevel); 434{; 435 if (fGen == nullptr) return false;; 436 int ret = 0;; 437 if ( debugLevel > 1); 438 ret |= unur_chg_debug(fGen, UNUR_DEBUG_ALL);; 439 else if (debugLevel == 1); 440 ret |= unur_chg_debug(fGen, UNUR_DEBUG_ALL);; 441 else; 442 ret |= unur_chg_debug(fGen, UNUR_DEBUG_OFF);; 443 ; 444 return (ret ==0) ? true : false;; 445 ; 446}; 447 ; 448bool TUnuran::InitPoisson(double mu, const std::string & method) {; 449 // initialization for a Poisson; 450 double p[1];; 451 p[0] = mu;; 452 ; 453 fUdistr = unur_distr_poisson(p,1);; 454 ; 455 fMethod = method;; 456 if (fUdistr == nullptr) re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnuran_8cxx_source.html:13724,assert,assert,13724,doc/master/TUnuran_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnuran_8cxx_source.html,1,['assert'],['assert']
Testability,"rn.push_back(Pattern (values.begin(),; 724 values.end(),; 725 outputValue,; 726 event->GetWeight()));; 727 trainPattern.back().addInput(1.0);; 728 } else if (fAnalysisType == Types::kMulticlass) {; 729 std::vector<Float_t> oneHot(DataInfo().GetNClasses(), 0.0);; 730 oneHot[event->GetClass()] = 1.0;; 731 trainPattern.push_back(Pattern (values.begin(), values.end(),; 732 oneHot.cbegin(), oneHot.cend(),; 733 event->GetWeight()));; 734 trainPattern.back().addInput(1.0);; 735 } else {; 736 const std::vector<Float_t>& targets = event->GetTargets ();; 737 trainPattern.push_back(Pattern(values.begin(),; 738 values.end(),; 739 targets.begin(),; 740 targets.end(),; 741 event->GetWeight ()));; 742 trainPattern.back ().addInput (1.0); // bias node; 743 }; 744 }; 745 ; 746 for (auto &event : eventCollectionTesting) {; 747 const std::vector<Float_t>& values = event->GetValues();; 748 if (fAnalysisType == Types::kClassification) {; 749 double outputValue = event->GetClass () == 0 ? 0.9 : 0.1;; 750 testPattern.push_back(Pattern (values.begin(),; 751 values.end(),; 752 outputValue,; 753 event->GetWeight()));; 754 testPattern.back().addInput(1.0);; 755 } else if (fAnalysisType == Types::kMulticlass) {; 756 std::vector<Float_t> oneHot(DataInfo().GetNClasses(), 0.0);; 757 oneHot[event->GetClass()] = 1.0;; 758 testPattern.push_back(Pattern (values.begin(), values.end(),; 759 oneHot.cbegin(), oneHot.cend(),; 760 event->GetWeight()));; 761 testPattern.back().addInput(1.0);; 762 } else {; 763 const std::vector<Float_t>& targets = event->GetTargets ();; 764 testPattern.push_back(Pattern(values.begin(),; 765 values.end(),; 766 targets.begin(),; 767 targets.end(),; 768 event->GetWeight ()));; 769 testPattern.back ().addInput (1.0); // bias node; 770 }; 771 }; 772 ; 773 TMVA::DNN::Net net;; 774 std::vector<double> weights;; 775 ; 776 net.SetIpythonInteractive(fInteractive, &fExitFromTraining, &fIPyMaxIter, &fIPyCurrentIter);; 777 ; 778 net.setInputSize(fNet.GetInputWidth() + 1);; 779 net.setOu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:26539,test,testPattern,26539,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['test'],['testPattern']
Testability,"rnally, randomly, and by accept/reject sampling; Int_t_updateFMaxPerEventIf true, maximum p.d.f value needs to be recalculated for each event; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0); Initialize a new context for generating events with the specified; variables, using the specified PDF model. A prototype dataset (if provided); is not cloned and still belongs to the caller. The contents and shape; of this dataset can be changed between calls to generate() as long as the; expected columns to be copied to the generated dataset are present.; Any argument supplied in the forceDirect RooArgSet are always offered; for internal generation to the p.d.f., even if this is deemed unsafe by; the logic of RooGenContext. ~RooGenContext(); Destructor. void attach(const RooArgSet& params); Attach the cloned model to the event buffer we will be filling. void initGenerator(const RooArgSet& theEvent); Perform one-time initialization of the generator context. void generateEvent(RooArgSet& theEvent, Int_t remaining); Generate one event. The 'remaining' integer is not used other than; for printing messages. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Printing interface. RooGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0). » Last changed: Tue Jun 30 14:33:14 2015 » Last generated: 2015-06-30 14:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGenContext.html:11605,log,logic,11605,root/html602/RooGenContext.html,https://root.cern,https://root.cern/root/html602/RooGenContext.html,1,['log'],['logic']
Testability,"rnel(const TMVA::kNN::Event& event_knn, const TMVA::kNN::Event& event, const vector<Double_t>& svec) const; Double_tgetKernelRadius(const TMVA::kNN::List& rlist) const; doublegetLDAValue(const TMVA::kNN::List& rlist, const TMVA::kNN::Event& event_knn); const vector<Double_t>getRMS(const TMVA::kNN::List& rlist, const TMVA::kNN::Event& event_knn) const; virtual voidInit(); voidMakeKNN(); Double_tPolnKernel(Double_t value) const; virtual voidProcessOptions(). Data Members; public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodKNN.html:15770,test,testing,15770,root/html602/TMVA__MethodKNN.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodKNN.html,2,['test'],['testing']
Testability,"rnelEstimator=Gauss:GaussSigma=0.3:NEventsMin=40:NEventsMax=60:VarTransform=None"" );; // And the options strings for the MinMax and RMS methods, respectively:; //; // ""!H:!V:VolumeRangeMode=MinMax:DeltaFrac=0.2:KernelEstimator=Gauss:GaussSigma=0.3"" );; // ""!H:!V:VolumeRangeMode=RMS:DeltaFrac=3:KernelEstimator=Gauss:GaussSigma=0.3"" );; ; if (Use[""PDEFoam""]); factory->BookMethod( dataloader, TMVA::Types::kPDEFoam, ""PDEFoam"",; ""!H:!V:MultiTargetRegression=F:TargetSelection=Mpv:TailCut=0.001:VolFrac=0.0666:nActiveCells=500:nSampl=2000:nBin=5:Compress=T:Kernel=None:Nmin=10:VarTransform=None"" );; ; // K-Nearest Neighbour classifier (KNN); if (Use[""KNN""]); factory->BookMethod( dataloader, TMVA::Types::kKNN, ""KNN"",; ""nkNN=20:ScaleFrac=0.8:SigmaFact=1.0:Kernel=Gaus:UseKernel=F:UseWeight=T:!Trim"" );; ; // Linear discriminant; if (Use[""LD""]); factory->BookMethod( dataloader, TMVA::Types::kLD, ""LD"",; ""!H:!V:VarTransform=None"" );; ; // Function discrimination analysis (FDA) -- test of various fitters - the recommended one is Minuit (or GA or SA); if (Use[""FDA_MC""]); factory->BookMethod( dataloader, TMVA::Types::kFDA, ""FDA_MC"",; ""!H:!V:Formula=(0)+(1)*x0+(2)*x1:ParRanges=(-100,100);(-100,100);(-100,100):FitMethod=MC:SampleSize=100000:Sigma=0.1:VarTransform=D"" );; ; if (Use[""FDA_GA""]) // can also use Simulated Annealing (SA) algorithm (see Cuts_SA options) .. the formula of this example is good for parabolas; factory->BookMethod( dataloader, TMVA::Types::kFDA, ""FDA_GA"",; ""!H:!V:Formula=(0)+(1)*x0+(2)*x1:ParRanges=(-100,100);(-100,100);(-100,100):FitMethod=GA:PopSize=100:Cycles=3:Steps=30:Trim=True:SaveBestGen=1:VarTransform=Norm"" );; ; if (Use[""FDA_MT""]); factory->BookMethod( dataloader, TMVA::Types::kFDA, ""FDA_MT"",; ""!H:!V:Formula=(0)+(1)*x0+(2)*x1:ParRanges=(-100,100);(-100,100);(-100,100);(-10,10):FitMethod=MINUIT:ErrorLevel=1:PrintLevel=-1:FitStrategy=2:UseImprove:UseMinos:SetBatch"" );; ; if (Use[""FDA_GAMT""]); factory->BookMethod( dataloader, TMVA::Types::kFDA, ""FDA_GAMT"",; ""!H",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:142679,test,test,142679,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['test'],['test']
Testability,"rns MVA value: -1 for background, 1 for signal. void UpdateTargets(vector<const TMVA::Event*>& , UInt_t cls = 0); Calculate residua for all events;. void UpdateTargetsRegression(vector<const TMVA::Event*>& , Bool_t first = kFALSE); Calculate current residuals for all events and update targets for next iteration. Double_t GetWeightedQuantile(vector<pair<Double_t,Double_t> > vec, const Double_t quantile, const Double_t SumOfWeights = 0.); calculates the quantile of the distribution of the first pair entries weighted with the values in the second pair entries. Double_t GradBoost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt, UInt_t cls = 0); Calculate the desired response value for each region. Double_t GradBoostRegression(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); Implementation of M_TreeBoost using a Huber loss function as desribed by Friedman 1999. void InitGradBoost(vector<const TMVA::Event*>& ); initialize targets for first tree. Double_t TestTreeQuality(TMVA::DecisionTree* dt); test the tree quality.. in terms of Miscalssification. Double_t Boost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt, UInt_t cls = 0); apply the boosting alogrithim (the algorithm is selecte via the the ""option"" given; in the constructor. The return value is the boosting weight. void BoostMonitor(Int_t iTree); fills the ROCIntegral vs Itree from the testSample for the monitoring plots; during the training .. but using the testing events. Double_t AdaBoost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); the AdaBoost implementation.; a new training sample is generated by weighting; events that are misclassified by the decision tree. The weight; applied is w = (1-err)/err or more general:; w = ((1-err)/err)^beta; where err is the fraction of misclassified events in the tree ( <0.5 assuming; demanding the that previous selection was better than random guessing); and ""beta"" being a free parameter (standard: beta = 1) that modifies the; boosting. Double_t AdaCost(v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodBDT.html:32496,test,test,32496,root/html602/TMVA__MethodBDT.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodBDT.html,2,['test'],['test']
Testability,"rnsTClass describing current object ; Reimplemented from TMVA::Envelope.; Definition at line 202 of file Classification.h. ◆ IsCutsMethod(). Bool_t TMVA::Experimental::Classification::IsCutsMethod ; (; TMVA::MethodBase * ; method). protected . Allows to check if the ml method is a Cuts method. ; Returnsboolen true if the method is a Cuts method. ; Definition at line 957 of file Classification.cxx. ◆ MergeFiles(). void TMVA::Experimental::Classification::MergeFiles ; (; ). protected . Definition at line 1130 of file Classification.cxx. ◆ Streamer(). virtual void TMVA::Experimental::Classification::Streamer ; (; TBuffer & ; R__b). virtual . Stream an object of class TObject. ; Reimplemented from TMVA::Envelope. ◆ StreamerNVirtual(). void TMVA::Experimental::Classification::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 202 of file Classification.h. ◆ Test(). void TMVA::Experimental::Classification::Test ; (; ). virtual . Perform test evaluation in all booked methods. ; Definition at line 513 of file Classification.cxx. ◆ TestMethod() [1/2]. void TMVA::Experimental::Classification::TestMethod ; (; TString ; methodname, . TString ; methodtitle . ). virtual . Lets perform test an specific ml method. ; Parameters. methodnamename of the method. ; methodtitlemethod title. . Definition at line 526 of file Classification.cxx. ◆ TestMethod() [2/2]. void TMVA::Experimental::Classification::TestMethod ; (; Types::EMVA ; method, . TString ; methodtitle . ). virtual . Lets perform test an specific ml method given the method type in enum TMVA::Types::EMVA. ; Parameters. methodTMVA::Types::EMVA type. ; methodtitlemethod title. . Definition at line 935 of file Classification.cxx. ◆ Train(). void TMVA::Experimental::Classification::Train ; (; ). virtual . Method to train all booked ml methods. ; Definition at line 324 of file Classification.cxx. ◆ TrainMethod() [1/2]. void TMVA::Experimental::Classification::TrainMethod ; (; TString ; method",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Experimental_1_1Classification.html:26365,test,test,26365,doc/master/classTMVA_1_1Experimental_1_1Classification.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Experimental_1_1Classification.html,1,['test'],['test']
Testability,"ro as specified by the Rint.Logon; 337/// environment setting, by default ./rootlogon.C, will be executed.; 338/// No logon macros will be executed when the system is started with; 339/// the -n option.; 340 ; 341void TRint::ExecLogon(); 342{; 343 if (NoLogOpt()) return;; 344 ; 345 TString name = "".rootlogon.C"";; 346 TString sname = ""system"";; 347 sname += name;; 348 char *s = gSystem->ConcatFileName(TROOT::GetEtcDir(), sname);; 349 if (!gSystem->AccessPathName(s, kReadPermission)) {; 350 ProcessFile(s);; 351 }; 352 delete [] s;; 353 s = gSystem->ConcatFileName(gSystem->HomeDirectory(), name);; 354 if (!gSystem->AccessPathName(s, kReadPermission)) {; 355 ProcessFile(s);; 356 }; 357 delete [] s;; 358 // avoid executing ~/.rootlogon.C twice; 359 if (strcmp(gSystem->HomeDirectory(), gSystem->WorkingDirectory())) {; 360 if (!gSystem->AccessPathName(name, kReadPermission)); 361 ProcessFile(name);; 362 }; 363 ; 364 // execute also the logon macro specified by ""Rint.Logon""; 365 const char *logon = gEnv->GetValue(""Rint.Logon"", (char*)nullptr);; 366 if (logon) {; 367 char *mac = gSystem->Which(TROOT::GetMacroPath(), logon, kReadPermission);; 368 if (mac); 369 ProcessFile(logon);; 370 delete [] mac;; 371 }; 372}; 373 ; 374////////////////////////////////////////////////////////////////////////////////; 375/// Main application eventloop. First process files given on the command; 376/// line and then go into the main application event loop, unless the -q; 377/// command line option was specified in which case the program terminates.; 378/// When return is true this method returns even when -q was specified.; 379///; 380/// When QuitOpt is true and return is false, terminate the application with; 381/// an error code equal to either the ProcessLine error (if any) or the; 382/// return value of the command casted to a long.; 383 ; 384void TRint::Run(Bool_t retrn); 385{; 386 if (!QuitOpt()) {; 387 // Prompt prompt only if we are expecting / allowing input.; 388 Getlinem(kInit, GetP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRint_8cxx_source.html:12644,log,logon,12644,doc/master/TRint_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html,1,['log'],['logon']
Testability,robFuncMathCore.cxx;  QuantFuncMathCore.cxx;  RandomFunctions.cxx;  RichardsonDerivator.cxx;  RootFinder.cxx;  SparseData.cxx;  SpecFuncCephes.cxx;  SpecFuncCephes.h;  SpecFuncCephesInv.cxx;  SpecFuncMathCore.cxx;  TComplex.cxx;  TDataPointN.cxx;  TKDTree.cxx;  TKDTreeBinning.cxx;  TMath.cxx;  TRandom.cxx;  TRandom1.cxx;  TRandom2.cxx;  TRandom3.cxx;  triangle.c;  triangle.h;  TStatistic.cxx;  UnBinData.cxx;  ► test;  ► fit;  GaussFunction.h;  MinimizerTypes.h;  SparseDataComparer.cxx;  SparseFit3.cxx;  SparseFit4.cxx;  testFit.cxx;  testFitPerf.cxx;  testGraphFit.cxx;  testMinim.cxx;  testRooFit.cxx;  WrapperRooPdf.h;  binarySearchTime.cxx;  kDTreeTest.cxx;  newKDTreeTest.cxx;  stdsort.cxx;  stressGoFTest.cxx;  stressTF1.cxx;  stressTMath.cxx;  testAnalyticalIntegrals.cxx;  testBinarySearch.cxx;  testDistSampler.cxx;  testIntegration.cxx;  testIntegrationMultiDim.cxx;  testkdTreeBinning.cxx;  testMathRandom.cxx;  testRootFinder.cxx;  testSampleQuantiles.cxx;  testSortOrder.cxx;  testSpecFuncBeta.cxx;  testSpecFuncBetaI.cxx;  testSpecFuncErf.cxx;  testSpecFuncGamma.cxx;  testSpecFuncSiCi.cxx;  testTMath.cxx;  testTStatistic.cxx;  ► v7;  ► inc;  ► ROOT;  TFit.h;  ► mathmore;  ► inc;  ► Math;  ChebyshevApprox.h;  Derivator.h;  DistFuncMathMore.h;  GSLFunctionAdapter.h;  GSLIntegrator.h;  GSLMCIntegrator.h;  GSLMinimizer.h;  GSLMinimizer1D.h;  GSLMultiRootFinder.h;  GSLNLSMinimizer.h;  GSLQuasiRandom.h;  GSLRandom.h;  GSLRandomFunctions.h;  GSLRndmEngines.h;  GSLRootFinder.h;  GSLRootFinderDeriv.h;  GSLRootHelper.h;  GSLSimAnMinimizer.h;  GSLSimAnnealing.h;  IntegrationTypes.h;  InterpolationTypes.h;  Interpolator.h;  KelvinFunctions.h;  LinkDef.h;  LinkDef_Func.h;  LinkDef_RootFinding.h;  MCIntegrationTypes.h;  MCParameters.h;  MultiNumGradFunction.h;  MultiRootFinder.h;  ParamFunction.h;  PdfFuncMathMore.h;  Polynomial.h;  QuantFuncMathMore.h;  QuasiRandom.h;  RootFinderAlgorithms.h;  SpecFuncMathMore.h;  Vavilov.h;  VavilovAccurate.h;  VavilovAccurateCdf.h;  VavilovA,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/files.html:46356,test,testSpecFuncBeta,46356,root/html606/files.html,https://root.cern,https://root.cern/root/html606/files.html,1,['test'],['testSpecFuncBeta']
Testability,"rocedure root-release-6.20 (or whichever branch) in Jenkins; tarfiles and other artifacts are copied to final destination. Install binaries to CVMFS. Install release binaries to CVMFS with the Jenkins procedure root-release-CVMFS. Documentation. Update the release pages. Generate the release notes with the Jenkins procedure called root-releasenotes; Update the releases xml with the Jenkins procedure called root-release-makeReleasesXml; Once authenticated, import the releases xml in the site clicking import here (Be reminded: this works for authenticated users only!).; Eventually edit the 'highlights' section, which is currently commented, in the generated release page.; If this applies, mark the release as Pro or Old and remove the attribute to the one previously holding it. There are radio buttons exposed by Drupal when editing a release's page.; If not a patch release edit reference-guide page to add the new reference guide for the release. Announcements. send mail to the following mailing lists: root-planning@cern.ch, root-dev@cern.ch, roottalk@cern.ch, root-godparents@cern.ch, root-ambassadors@cern.ch; write announcement in RootTalk forum news. Quick Links; Jenkins Service; Jenkins How To; CDash; Coverity; Github; GitWeb; LXR; Jira; Conventions Violations; ROOT Logos; Upgrade of ROOTbinder. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/release-checklist.html:5258,test,tests,5258,d/release-checklist.html,https://root.cern,https://root.cern/d/release-checklist.html,1,['test'],['tests']
Testability,"rocessAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAbsPdf* genModel(); Return generator pdf. RooAbsGenContext* genContext(); Accessor for generator context, generator parameters,	prototype data and projected dependents. RooArgSet* genInitParams(); Return initial value of generator model parameters. RooArgSet* genParams(); Return current value of generator model parameters. const RooDataSet* genProtoData(); Return generator prototype data provided by user. RooArgSet* projDeps(); Return projected observables. RooArgSet* dependents(); Accessors for fit observables, fit model, current and initial fit parameters and NLL value. RooArgSet* allDependents(); Returna all observables. RooAbsPdf* fitModel(); Return fit model. RooArgSet* fitInitParams(); Return initial value of parameters of fit model. RooArgSet* fitParams(); Return current value of parameters of fit model. RooRealVar* nllVar(); Return pointer to RooRealVar holding minimized -log(L) value. const char* fitOptions(); Accessors for fit options, generator annd MCstudy configuration flags. RooLinkedList* fitOptList(); Return list of fit options provided by user. Bool_t extendedGen(); If true extended mode generation is requested. Bool_t binGenData(); If true binning of data between generating and fitting is requested. Double_t numExpGen(); Return expected number of events from generator model. Bool_t randProto(); If true randomization of prototype data order is requested. Bool_t verboseGen(); If true verbose message in the generation step is requested. » Last changed: Mon Dec 7 13:45:40 2009 » Last generated: 2009-12-07 13:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsMCStudyModule.html:9578,log,log,9578,root/html526/RooAbsMCStudyModule.html,https://root.cern,https://root.cern/root/html526/RooAbsMCStudyModule.html,1,['log'],['log']
Testability,"rocessAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAbsPdf* genModel(); Return generator pdf. RooAbsGenContext* genContext(); Accessor for generator context, generator parameters,	prototype data and projected dependents. RooArgSet* genInitParams(); Return initial value of generator model parameters. RooArgSet* genParams(); Return current value of generator model parameters. const RooDataSet* genProtoData(); Return generator prototype data provided by user. RooArgSet* projDeps(); Return projected observables. RooArgSet* dependents(); Accessors for fit observables, fit model, current and initial fit parameters and NLL value. RooArgSet* allDependents(); Returna all observables. RooAbsPdf* fitModel(); Return fit model. RooArgSet* fitInitParams(); Return initial value of parameters of fit model. RooArgSet* fitParams(); Return current value of parameters of fit model. RooRealVar* nllVar(); Return pointer to RooRealVar holding minimized -log(L) value. const char* fitOptions(); Accessors for fit options, generator annd MCstudy configuration flags. RooLinkedList* fitOptList(); Return list of fit options provided by user. Bool_t extendedGen(); If true extended mode generation is requested. Bool_t binGenData(); If true binning of data between generating and fitting is requested. Double_t numExpGen(); Return expected number of events from generator model. Bool_t randProto(); If true randomization of prototype data order is requested. Bool_t verboseGen(); If true verbose message in the generation step is requested. » Last changed: Mon Jul 4 15:21:24 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsMCStudyModule.html:9633,log,log,9633,root/html530/RooAbsMCStudyModule.html,https://root.cern,https://root.cern/root/html530/RooAbsMCStudyModule.html,1,['log'],['log']
Testability,"rocessAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAbsPdf* genModel(); Return generator pdf. RooAbsGenContext* genContext(); Accessor for generator context, generator parameters,	prototype data and projected dependents. RooArgSet* genInitParams(); Return initial value of generator model parameters. RooArgSet* genParams(); Return current value of generator model parameters. const RooDataSet* genProtoData(); Return generator prototype data provided by user. RooArgSet* projDeps(); Return projected observables. RooArgSet* dependents(); Accessors for fit observables, fit model, current and initial fit parameters and NLL value. RooArgSet* allDependents(); Returna all observables. RooAbsPdf* fitModel(); Return fit model. RooArgSet* fitInitParams(); Return initial value of parameters of fit model. RooArgSet* fitParams(); Return current value of parameters of fit model. RooRealVar* nllVar(); Return pointer to RooRealVar holding minimized -log(L) value. const char* fitOptions(); Accessors for fit options, generator annd MCstudy configuration flags. RooLinkedList* fitOptList(); Return list of fit options provided by user. Bool_t extendedGen(); If true extended mode generation is requested. Bool_t binGenData(); If true binning of data between generating and fitting is requested. Double_t numExpGen(); Return expected number of events from generator model. Bool_t randProto(); If true randomization of prototype data order is requested. Bool_t verboseGen(); If true verbose message in the generation step is requested. » Last changed: Thu Nov 3 20:06:44 2011 » Last generated: 2011-11-03 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsMCStudyModule.html:9633,log,log,9633,root/html532/RooAbsMCStudyModule.html,https://root.cern,https://root.cern/root/html532/RooAbsMCStudyModule.html,1,['log'],['log']
Testability,"rocessAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAbsPdf* genModel(); Return generator pdf. RooAbsGenContext* genContext(); Accessor for generator context, generator parameters,	prototype data and projected dependents. RooArgSet* genInitParams(); Return initial value of generator model parameters. RooArgSet* genParams(); Return current value of generator model parameters. const RooDataSet* genProtoData(); Return generator prototype data provided by user. RooArgSet* projDeps(); Return projected observables. RooArgSet* dependents(); Accessors for fit observables, fit model, current and initial fit parameters and NLL value. RooArgSet* allDependents(); Returna all observables. RooAbsPdf* fitModel(); Return fit model. RooArgSet* fitInitParams(); Return initial value of parameters of fit model. RooArgSet* fitParams(); Return current value of parameters of fit model. RooRealVar* nllVar(); Return pointer to RooRealVar holding minimized -log(L) value. const char* fitOptions(); Accessors for fit options, generator annd MCstudy configuration flags. RooLinkedList* fitOptList(); Return list of fit options provided by user. Bool_t extendedGen(); If true extended mode generation is requested. Bool_t binGenData(); If true binning of data between generating and fitting is requested. Double_t numExpGen(); Return expected number of events from generator model. Bool_t randProto(); If true randomization of prototype data order is requested. Bool_t verboseGen(); If true verbose message in the generation step is requested. » Last changed: Tue Jun 2 15:27:10 2015 » Last generated: 2015-06-02 15:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooAbsMCStudyModule.html:10113,log,log,10113,root/html604/RooAbsMCStudyModule.html,https://root.cern,https://root.cern/root/html604/RooAbsMCStudyModule.html,1,['log'],['log']
Testability,"roduces a distribution.; What you can learn from that is:; is variable a really useful, or is my network insensitive to it ?; is there any risk of big systematic ? Is the network extremely sensitive to small variations of any of my inputs ?. As you might understand, this is to be considered with care and can serve as input for an ""educated guess"" when optimizing the network. ; Definition at line 311 of file TMLPAnalyzer.cxx. ◆ DrawNetwork(). void TMLPAnalyzer::DrawNetwork ; (; Int_t ; neuron, . const char * ; signal, . const char * ; bg . ). Draws the distribution of the neural network (using ith neuron). ; Two distributions are drawn, for events passing respectively the ""signal"" and ""background"" cuts. Only the test sample is used. ; Definition at line 337 of file TMLPAnalyzer.cxx. ◆ DrawTruthDeviation(). TProfile * TMLPAnalyzer::DrawTruthDeviation ; (; Int_t ; outnode = 0, . Option_t * ; option = """" . ). Create a profile of the difference of the MLP output minus the true value for a given output node outnode, vs the true value for outnode, for all test data events. ; This method is mainly useful when doing regression analysis with the MLP (i.e. not classification, but continuous truth values). The resulting TProfile histogram is returned. It is not drawn if option ""goff"" is specified. Options are passed to TProfile::Draw ; Definition at line 398 of file TMLPAnalyzer.cxx. ◆ DrawTruthDeviationInOut(). TProfile * TMLPAnalyzer::DrawTruthDeviationInOut ; (; Int_t ; innode, . Int_t ; outnode = 0, . Option_t * ; option = """" . ). Creates a profile of the difference of the MLP output outnode minus the true value of outnode vs the input value innode, for all test data events. ; The resulting TProfile histogram is returned. It is not drawn if option ""goff"" is specified. Options are passed to TProfile::Draw ; Definition at line 474 of file TMLPAnalyzer.cxx. ◆ DrawTruthDeviationInsOut(). THStack * TMLPAnalyzer::DrawTruthDeviationInsOut ; (; Int_t ; outnode = 0, . Option_t * ; o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMLPAnalyzer.html:15484,test,test,15484,doc/master/classTMLPAnalyzer.html,https://root.cern,https://root.cern/doc/master/classTMLPAnalyzer.html,1,['test'],['test']
Testability,"rogram used by Create.; It explores newly defined cell with help of special short MC sampling.; As a result, estimates of kTRUE and drive volume is defined/determined; Average and dispersion of the weight distribution will is found along; each edge and the best edge (minimum dispersion, best maximum weight); is memorized for future use.; The optimal division point for eventual future cell division is; determined/recorded. Recorded are also minimum and maximum weight etc.; The volume estimate in all (inactive) parent cells is updated.; Note that links to parents and initial volume = 1/2 parent has to be; already defined prior to calling this routine. If fNmin > 0 then the total number of (training) events found in; the cell during the exploration is stored in the cell. This; information is used withing PeekMax() to avoid splitting cells; which contain less than fNmin events. void DTExplore(TMVA::PDEFoamCell* Cell); Internal subprogram used by Create. It explores newly defined; cell with according to the decision tree logic. The separation; set by the 'fDTSeparation' option is used (see also; GetSeparation()). The optimal division point for eventual future cell division is; determined/recorded. Note that links to parents and initial; volume = 1/2 parent has to be already defined prior to calling; this routine. Note, that according to the decision tree logic, a cell is only; split, if the number of (unweighted) events in each dautghter; cell is greater than fNmin. Float_t GetSeparation(Float_t s, Float_t b); Calculate the separation depending on 'fDTSeparation' for the; given number of signal and background events 's', 'b'. Note,; that if (s+b) < 0 or s < 0 or b < 0 than the return value is 0. void Varedu(Double_t* , Int_t& , Double_t& , Double_t& ); Internal subrogram used by Create.; In determines the best edge candidate and the position of the cell division plane; in case of the variance reduction for future cell division,; using results of the MC exploration run sto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__PDEFoam.html:13767,log,logic,13767,root/html528/TMVA__PDEFoam.html,https://root.cern,https://root.cern/root/html528/TMVA__PDEFoam.html,1,['log'],['logic']
Testability,"rogressDialog&); TProofProgressDialog(TProof* proof, const char* selector, Int_t files, Long64_t first, Long64_t entries). private:. Float_tAdjustBytes(Float_t mbs, TString& sf). Data Members; private:. TGTextButton*fAbort; TGraph*fActWGraph; TGTextButton*fAsyn; Double_tfAvgMBRate; Double_tfAvgRate; TGProgressBar*fBarprogress bar; TGTextButton*fClose; TGTransientFrame*fDialogtransient frame, main dialog window; TGraph*fEffSGraph; TTimefEndTime; Long64_tfEntries; TGTextEntry*fEntry; TGLabel*fEstim; Int_tfFiles; TGLabel*fFilesEvents; Long64_tfFirst; TGLabel*fInit; Float_tfInitTime; Bool_tfKeep; TGCheckButton*fKeepToggle; TGTextButton*fLog; Bool_tfLogQuery; TGCheckButton*fLogQueryToggle; TProofProgressLog*fLogWindowtransient frame for logs; TGraph*fMBRtGraph; TGTextButton*fMemPlot; TProofProgressMemoryPlot*fMemWindowtransient frame for memory plots; Long64_tfPrevProcessed; Long64_tfPrevTotal; Float_tfProcTime; TGLabel*fProcessed; TProof*fProof; TGLabel*fRate; TGraph*fRateGraph; TGTextButton*fRatePlot; TNtuple*fRatePoints; Int_tfRightInfo; Int_tfSVNRev; TGLabel*fSelector; TStringfSessionUrl; TGCheckButton*fSmoothSpeedouse smooth speedometer update; TGSpeedo*fSpeedospeedometer; Bool_tfSpeedoEnabledwhether to enable the speedometer; TTimefStartTime; TProofProgressDialog::EQueryStatusfStatus; TGTextButton*fStop; TGTextBuffer*fTextQuery; TGLabel*fTimeLab; TGLabel*fTitleLab; TGraph*fTotSGraph; TGLabel*fTotal; TGTextButton*fUpdtSpeedo; static Bool_tfgKeepDefault; static Bool_tfgLogQueryDefault; static TStringfgTextQueryDefault; static TProofProgressDialog::EQueryStatuskAborted; static TProofProgressDialog::EQueryStatuskDone; static TProofProgressDialog::EQueryStatuskIncomplete; static TProofProgressDialog::EQueryStatuskRunning; static TProofProgressDialog::EQueryStatuskStopped. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressDialog(TProof* proof, const char* selector, Int_t files, Long64_t first, Long64_t entries); Crea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofProgressDialog.html:2279,log,logs,2279,root/html602/TProofProgressDialog.html,https://root.cern,https://root.cern/root/html602/TProofProgressDialog.html,1,['log'],['logs']
Testability,"rom TGLScene;  TGLScene ();  ;  ~TGLScene () override;  Destroy scene objects. ;  ; virtual void AdoptLogical (TGLLogicalShape &shape);  Adopt dynamically created logical 'shape' - add to internal map and take responsibility for deleting. ;  ; virtual void AdoptPhysical (TGLPhysicalShape &shape);  Adopt dynamically created physical 'shape' - add to internal map and take responsibility for deleting. ;  ; UInt_t BeginSmartRefresh ();  Moves logicals that support smart-refresh to intermediate cache. ;  ; virtual Bool_t BeginUpdate ();  Put scene in update mode, return true if lock acquired. ;  ; void CalcBoundingBox () const override;  Encapsulates all physical shapes bounding box with axes aligned box. ;  ; TSceneInfo * CreateSceneInfo (TGLViewerBase *view) override;  Create a scene-info instance appropriate for this scene class. ;  ; virtual Bool_t DestroyLogical (TObject *logid, Bool_t mustFind=kTRUE);  Destroy logical shape defined by unique 'ID'. ;  ; virtual Int_t DestroyLogicals ();  Destroy all logical shapes in scene. ;  ; virtual Bool_t DestroyPhysical (UInt_t phid);  Destroy physical shape defined by unique 'ID'. ;  ; virtual Int_t DestroyPhysicals ();  Destroy physical shapes. ;  ; void DumpMapSizes () const;  Print sizes of logical and physical-shape maps. ;  ; void EndSmartRefresh ();  Wipes logicals in refresh-cache. ;  ; virtual void EndUpdate (Bool_t minorChange=kTRUE, Bool_t sceneChanged=kTRUE, Bool_t updateViewers=kTRUE);  Exit scene update mode. ;  ; TGLLogicalShape * FindLogical (TObject *logid) const override;  Find and return logical shape identified by unique logid. ;  ; TGLLogicalShape * FindLogicalSmartRefresh (TObject *ID) const;  Find and return logical shape identified by unique 'ID' in refresh-cache. ;  ; virtual TGLPhysicalShape * FindPhysical (UInt_t phid) const;  Find and return physical shape identified by unique 'ID'. ;  ; TGLContextIdentity * GetGLCtxIdentity () const;  ; virtual UInt_t GetMaxPhysicalID ();  Returns the maximum used p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLScenePad.html:11987,log,logical,11987,doc/master/classTGLScenePad.html,https://root.cern,https://root.cern/doc/master/classTGLScenePad.html,1,['log'],['logical']
Testability,"rom TMVA::Configurable.; Reimplemented in TMVA::CvSplitKFolds.; Definition at line 57 of file CvSplit.h. ◆ MakeKFoldDataSet(). virtual void TMVA::CvSplit::MakeKFoldDataSet ; (; DataSetInfo & ; dsi). pure virtual . Implemented in TMVA::CvSplitKFolds. ◆ NeedsRebuild(). Bool_t TMVA::CvSplit::NeedsRebuild ; (; ). inline . Definition at line 47 of file CvSplit.h. ◆ PrepareFoldDataSet(). void TMVA::CvSplit::PrepareFoldDataSet ; (; DataSetInfo & ; dsi, . UInt_t ; foldNumber, . Types::ETreeType ; tt . ). virtual . Set training and test set vectors of dataset described by dsi. ; Parameters. [in]dsiDataSetInfo for data set to be split ; [in]foldNumberOrdinal of fold to prepare ; [in]ttThe set used to prepare fold. If equal to Types::kTraining splitting will be based off the original train set. If instead equal to Types::kTesting the test set will be used. The original training/test set is the set as defined by DataLoader::PrepareTrainingAndTestSet. Sets the training and test set vectors of the DataSet described by dsi as defined by the split. If tt is eqal to Types::kTraining the split will be based off of the original training set.; Note: Requires MakeKFoldDataSet to have been called first. ; Definition at line 57 of file CvSplit.cxx. ◆ RecombineKFoldDataSet(). void TMVA::CvSplit::RecombineKFoldDataSet ; (; DataSetInfo & ; dsi, . Types::ETreeType ; tt = Types::kTraining . ). virtual . Definition at line 114 of file CvSplit.cxx. ◆ Streamer(). virtual void TMVA::CvSplit::Streamer ; (; TBuffer & ; R__b). virtual . Stream an object of class TObject. ; Reimplemented from TMVA::Configurable.; Reimplemented in TMVA::CvSplitKFolds. ◆ StreamerNVirtual(). void TMVA::CvSplit::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 57 of file CvSplit.h. Member Data Documentation. ◆ fMakeFoldDataSet. Bool_t TMVA::CvSplit::fMakeFoldDataSet. protected . Definition at line 51 of file CvSplit.h. ◆ fNumFolds. UInt_t TMVA::CvSplit::fNumFolds. protected . Def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1CvSplit.html:16339,test,test,16339,doc/master/classTMVA_1_1CvSplit.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1CvSplit.html,1,['test'],['test']
Testability,"rom a ROOT dataset into a basic TensorFlow workflow. ;  ;  tmva001_RTensor.C;   This tutorial illustrates the basic features of the RTensor class, RTensor is a std::vector-like container with additional shape information. ;  ;  tmva002_RDataFrameAsTensor.C;   This tutorial shows how the content of an RDataFrame can be converted to an RTensor object. ;  ;  tmva003_RReader.C;   This tutorial shows how to apply with the modern interfaces models saved in TMVA XML files. ;  ;  tmva004_RStandardScaler.C;   This tutorial illustrates the usage of the standard scaler as preprocessing method. ;  ;  tmva100_DataPreparation.py;   This tutorial illustrates how to prepare ROOT datasets to be nicely readable by most machine learning methods. ;  ;  tmva101_Training.py;   This tutorial show how you can train a machine learning model with any package reading the training data directly from ROOT files. ;  ;  tmva102_Testing.py;   This tutorial illustrates how you can test a trained BDT model using the fast tree inference engine offered by TMVA and external tools such as scikit-learn. ;  ;  tmva103_Application.C;   This tutorial illustrates how you can conveniently apply BDTs in C++ using the fast tree inference engine offered by TMVA. ;  ;  TMVA_CNN_Classification.C;   TMVA Classification Example Using a Convolutional Neural Network ;  ;  TMVA_CNN_Classification.py;   TMVA Classification Example Using a Convolutional Neural Network ;  ;  TMVA_Higgs_Classification.C;   Classification example of TMVA based on public Higgs UCI dataset ;  ;  TMVA_Higgs_Classification.py;   Classification example of TMVA based on public Higgs UCI dataset ;  ;  TMVA_RNN_Classification.C;   TMVA Classification Example Using a Recurrent Neural Network ;  ;  TMVA_RNN_Classification.py;   TMVA Classification Example Using a Recurrent Neural Network ;  ;  TMVA_SOFIE_GNN.py;  ;  TMVA_SOFIE_GNN_Application.C;  ;  TMVA_SOFIE_GNN_Parser.py;  ;  TMVA_SOFIE_Inference.py;   This macro provides an example of using a tra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html:1736,test,test,1736,doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,https://root.cern,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,1,['test'],['test']
Testability,"rom logical to physical hierarchy cannot be stored on regular basis due to the large size of the latter, one cannot directly assign state numbers. If the size of the expansion proves however to be small enough (less than about 50 million objects), a parallel structure storing these state indices is built and stored in memory. In such case each state automatically gets an index that can be retrieved after any state initialization. These indices can prove to be quite useful for being able to keep track of the navigation history and force certain states. Let's illustrate how this works with a simple example:; Suppose we have a simple geometry with a volume B positioned twice inside a container A. Then A is positioned twice in a top container T. The complete list of logical nodes is: T_1, A_1, A_2, B_1, B_2. On the other hand we will have more states than logical nodes:; /T_1- 1 state at level = 0; /T_1/A_1,/T_1/A_2- 2 states at level = 1; /T_1/A_1/B_1,/T_1/A_1/B_2,/T_1/A_2/B_1,/T_1/A_2/B_2 - 4 states at level = 2; All these states will get automatic numbers, starting with 0 corresponding to the top-level state and ending with an integer corresponding to Ntotal_states-1. The mapping from a given logical node to a state number is generally not possible, as for the node B_1 that appears as current node for 2 different states. The numbering order of states is therefore not important, but it can be used as in the following lines:. gGeoManager->InitTrack(pt,dir); // anything to initialize a state; Int_t istate = gGeoManager->GetCurrentNodeId(); // in fact state Id; {; //... code changing the current state; }; gGeoManager->CdNode(istate); // forces state's re-initialization; TGeoManager::GetCurrentNodeIdInt_t GetCurrentNodeId() constGet the unique ID of the current node.Definition TGeoManager.cxx:1663; TGeoManager::CdNodevoid CdNode(Int_t nodeid)Change current path to point to the node having this id.Definition TGeoManager.cxx:1655; ptTPaveText * ptDefinition entrylist_figure",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:76405,log,logical,76405,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['log'],['logical']
Testability,"rom logical to physical hierarchy cannot be stored on regular basis due to the large size of the latter, one cannot directly assign state numbers. If the size of the expansion proves however to be small enough (less than about 50 million objects), a parallel structure storing these state indices is built and stored in memory. In such case each state automatically gets an index that can be retrieved after any state initialization. These indices can prove to be quite useful for being able to keep track of the navigation history and force certain states. Let’s illustrate how this works with a simple example:; Suppose we have a simple geometry with a volume B positioned twice inside a container A. Then A is positioned twice in a top container T. The complete list of logical nodes is: T_1, A_1, A_2, B_1, B_2. On the other hand we will have more states than logical nodes:; /T_1- 1 state at level = 0; /T_1/A_1,/T_1/A_2- 2 states at level = 1; /T_1/A_1/B_1,/T_1/A_1/B_2,/T_1/A_2/B_1,/T_1/A_2/B_2 - 4 states at level = 2; All these states will get automatic numbers, starting with 0 corresponding to the top-level state and ending with an integer corresponding to Ntotal_states-1. The mapping from a given logical node to a state number is generally not possible, as for the node B_1 that appears as current node for 2 different states. The numbering order of states is therefore not important, but it can be used as in the following lines:. gGeoManager->InitTrack(pt,dir); // anything to initialize a state; Int_t istate = gGeoManager->GetCurrentNodeId(); // in fact state Id; {; //... code changing the current state; }; gGeoManager->CdNode(istate); // forces state's re-initialization. Current global transformation. This represents the transformation from MARS to the local reference of the current node, being the product of all local mother-daughter transformations in the branch. The global transformation can be referenced or copied:. const TGeoHMatrix *global = gGeoManager->GetCurrentM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:979523,log,logical,979523,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['log'],['logical']
Testability,"rom the cache. void InitializeCompressedBuffer(Int_t len, TFile* file); Initialize the compressed buffer; either from the TTree or create a local one. Int_t ReadBasketBuffers(Long64_t pos, Int_t len, TFile* file); Read basket buffers in memory and cleanup. Read a basket buffer. Check if buffers of previous ReadBasket; should not be dropped. Remember, we keep buffers in memory up to; fMaxVirtualSize.; The function returns 0 in case of success, 1 in case of error; This function was modified with the addition of the parallel; unzipping, it will try to get the unzipped file from the cache; receiving only a pointer to that buffer (so we shall not; delete that pointer), although we get a new buffer in case; it's not found in the cache.; There is a lot of code duplication but it was necesary to assure; the expected behavior when there is no cache. Int_t ReadBasketBytes(Long64_t pos, TFile* file); Read basket buffers in memory and cleanup. Read first bytes of a logical record starting at position pos; return record length (first 4 bytes of record). void Reset(); Reset the basket to the starting state. i.e. as it was after calling; the constructor (and potentially attaching a TBuffer.); Reduce memory used by fEntryOffset and the TBuffer if needed .. void SetReadMode(); Set read mode of basket. void SetWriteMode(); Set write mode of basket. void Streamer(TBuffer& b); Stream a class object. void Update(Int_t newlast, Int_t skipped); Update basket header and EntryOffset table. Int_t WriteBuffer(); Write buffer of this basket on the current file. The function returns the number of bytes committed to the memory.; If a write error occurs, the number of bytes returned is -1.; If no data are written, the number of bytes returned is 0. TBasket(const TBasket& ). TBasket& operator=(const TBasket& ). TBranch * GetBranch() const; {return fBranch;}. Int_t GetBufferSize() const; {return fBufferSize;}. Int_t * GetDisplacement() const; {return fDisplacement;}. Int_t * GetEntryOffset() const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TBasket.html:11584,log,logical,11584,root/html530/TBasket.html,https://root.cern,https://root.cern/root/html530/TBasket.html,1,['log'],['logical']
Testability,"rom this volume is the active geometry. A geometry hierarchy in memory. Nodes are never instantiated directly by users, but created as a result of volume operations. Adding a volume named A with a given user id inside a volume B will create a node named A_id. This will be added to the list of nodes stored by B. In addition, when applying a division operation in N slices to a volume A, a list of nodes B_1, B_2, … , B_N is also created. A node B_i does not represent a unique object in the geometry because its container A might be at its turn positioned as node inside several other volumes. Only when a complete branch of nodes is fully defined up to the top node in the geometry, a given path:/TOP_1/…/A_3/B_7 will represent a unique object. Its global transformation matrix can be computed as the pile-up of all local transformations in its branch. We will therefore call logical graph the hierarchy defined by nodes and volumes. The expansion of the logical graph by all possible paths defines a tree structure where all nodes are unique “touchable” objects. We will call this the “physical tree”. Unlike the logical graph, the physical tree can become a huge structure with several millions of nodes in case of complex geometries; therefore, it is not always a good idea to keep it transient in memory. Since the logical and physical structures are correlated, the modeller rather keeps track only of the current branch, updating the current global matrix at each change of the level in geometry. The current physical node is not an object that can be asked for at a given moment, but rather represented by the combination: current node/current global matrix. However, physical nodes have unique ID’s that can be retrieved for a given modeller state. These can be fed back to the modeller in order to force a physical node to become current. The advantage of this comes from the fact that all navigation queries check first the current node; therefore the location of a point in the geometry ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:932406,log,logical,932406,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['log'],['logical']
Testability,"rom tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSimultaneous(const char* name, const char* title, RooAbsCategoryLValue& indexCat); Constructor with index category. PDFs associated with indexCat; states can be added after construction with the addPdf() function. RooSimultaneous can function without having a PDF associated; with every single state. The normalization in such cases is taken; from the number of registered PDFs, but getVal() will assert if; when called for an unregistered index state. RooSimultaneous(const char *name, const char *title, 				 const RooArgList& inPdfList, RooAbsCategoryLValue& inIndexCat); Constructor from index category and full list of PDFs.; In this constructor form, a PDF must be supplied for each indexCat state; to avoid ambiguities. The PDFS are associated in order with the state of the; index category as listed by the index categories type iterator. PDFs may not overlap (i.e. share any variables) with the index category (function). RooSimultaneous(const char *name, const char *title, 				 map<string,RooAbsPdf*> pdfMap, RooAbsCategoryLValue& inIndexCat). void initialize(RooAbsCategoryLValue& inIndexCat, std::map<std::string,RooAbsPdf*> pdfMap); First see if there are any RooSimultaneous input components. RooSimultaneous(const RooSimultaneous& other, const char* name = 0); Copy constructor. ~RooSimultaneous(); Destructor. RooAbsPdf* getPdf(const char* catName) const; Ret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooSimultaneous.html:41063,assert,assert,41063,root/html526/RooSimultaneous.html,https://root.cern,https://root.cern/root/html526/RooSimultaneous.html,1,['assert'],['assert']
Testability,"rom tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSimultaneous(const char* name, const char* title, RooAbsCategoryLValue& indexCat); Constructor with index category. PDFs associated with indexCat; states can be added after construction with the addPdf() function. RooSimultaneous can function without having a PDF associated; with every single state. The normalization in such cases is taken; from the number of registered PDFs, but getVal() will assert if; when called for an unregistered index state. RooSimultaneous(const char* name, const char* title, const RooArgList& pdfList, RooAbsCategoryLValue& indexCat); Constructor from index category and full list of PDFs.; In this constructor form, a PDF must be supplied for each indexCat state; to avoid ambiguities. The PDFS are associated in order with the state of the; index category as listed by the index categories type iterator. PDFs may not overlap (i.e. share any variables) with the index category (function). RooSimultaneous(const char* name, const char* title, map<std::string,RooAbsPdf*> pdfMap, RooAbsCategoryLValue& inIndexCat). void initialize(RooAbsCategoryLValue& inIndexCat, map<std::string,RooAbsPdf*> pdfMap); First see if there are any RooSimultaneous input components. RooSimultaneous(const RooSimultaneous& other, const char* name = 0); Copy constructor. ~RooSimultaneous(); Destructor. RooAbsPdf* getPdf(const char* catName) const; Return the p.d.f ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooSimultaneous.html:41731,assert,assert,41731,root/html528/RooSimultaneous.html,https://root.cern,https://root.cern/root/html528/RooSimultaneous.html,3,['assert'],['assert']
Testability,"romEventAssignTrees()assign event-wise local trees to data setDefinition DataLoader.cxx:319; TMVA::DataLoader::AddTrainingEventvoid AddTrainingEvent(const TString &className, const std::vector< Double_t > &event, Double_t weight)add signal training eventDefinition DataLoader.cxx:260; TMVA::DataLoader::AddRegressionTreevoid AddRegressionTree(TTree *tree, Double_t weight=1.0, Types::ETreeType treetype=Types::kMaxTreeType)Definition DataLoader.h:103; TMVA::DataLoader::fDefaultTrfsstd::vector< TMVA::VariableTransformBase * > fDefaultTrfslist of transformations on default DataSetDefinition DataLoader.h:191; TMVA::DataLoader::fDataAssignTypeDataAssignType fDataAssignTypeflags for data assigningDefinition DataLoader.h:202; TMVA::DataLoader::SetTreevoid SetTree(TTree *tree, const TString &className, Double_t weight)deprecatedDefinition DataLoader.cxx:447; TMVA::DataLoader::AddSignalTestEventvoid AddSignalTestEvent(const std::vector< Double_t > &event, Double_t weight=1.0)add signal testing eventDefinition DataLoader.cxx:236; TMVA::DataLoader::fATreeEventstd::vector< Float_t > fATreeEventevent variablesDefinition DataLoader.h:208; TMVA::DataLoader::DefaultDataSetInfoDataSetInfo & DefaultDataSetInfo()default creationDefinition DataLoader.cxx:533; TMVA::DataLoader::AddBackgroundTestEventvoid AddBackgroundTestEvent(const std::vector< Double_t > &event, Double_t weight=1.0)add signal training eventDefinition DataLoader.cxx:252; TMVA::DataLoader::fDataSetManagerDataSetManager * fDataSetManagerDefinition DataLoader.h:186; TMVA::DataLoader::MakeCopyDataLoader * MakeCopy(TString name)Copy method use in VI and CV.Definition DataLoader.cxx:691; TMVA::DataLoader::SetSignalWeightExpressionvoid SetSignalWeightExpression(const TString &variable)Definition DataLoader.cxx:549; TMVA::DataLoader::MakeKFoldDataSetvoid MakeKFoldDataSet(CvSplit &s)Function required to split the training and testing datasets into a number of folds.Definition DataLoader.cxx:662; TMVA::DataLoader::SetWeightExpressi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataLoader_8h_source.html:14028,test,testing,14028,doc/master/DataLoader_8h_source.html,https://root.cern,https://root.cern/doc/master/DataLoader_8h_source.html,1,['test'],['testing']
Testability,"roof::RemoveWorkers(TList* wrks); static Int_tTProof::SaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidTProof::SaveWorkerInfo(); Int_tTProof::SendFile(const char* file, Int_t opt = (kBinary|kForward|kCp|kCpBin), const char* rfile = 0, TSlave* sl = 0); static Int_tTProof::SendInputData(TQueryResult* qr, TProof* p, TString& emsg); voidTProof::SetDSet(TDSet* dset); voidTProof::SetPlayer(TVirtualProofPlayer* player); voidSetQueryRunning(TProofQueryResult* pq); Int_tSetupWorkers(Int_t opt = 0, TList* wrks = 0); static void*TProof::SlaveStartupThread(void* arg); virtual Bool_tTProof::StartSlaves(Bool_t attach = kFALSE); static voidTProof::SystemCmd(const char* cmd, Int_t fdout); voidTProof::UpdateDialog(); virtual voidTProof::ValidateDSet(TDSet* dset). private:. TProofLite(const TProofLite&); Int_tCleanupSandbox(); Int_tCreateSandbox(); virtual voidFindUniqueSlaves(); Int_tInitDataSetManager(); voidNotifyStartUp(const char* action, Int_t done, Int_t tot); voidoperator=(const TProofLite&); Int_tRegisterDataSets(TList* in, TList* out); voidResolveKeywords(TString& s, const char* logfile); virtual voidSendInputDataFile(); Int_tSetProofServEnv(const char* ord). Data Members; public:. enum TProof::EStatusBits { kUsingSessionGui; kNewInputData; kIsClient; kIsMaster; kIsTopMaster; kUseProgressDialog; };; enum TProof::EQueryMode { kSync; kAsync; };; enum TProof::EUploadOpt { kAppend; kOverwriteDataSet; kNoOverwriteDataSet; kOverwriteAllFiles; kOverwriteNoFiles; kAskUser; };; enum TProof::ERegisterOpt { kFailIfExists; kOverwriteIfExists; kMergeIfExists; };; enum TProof::EUploadDataSetAnswer { kError; kDataSetExists; kFail; };; enum TProof::EUploadPackageOpt { kUntar; kRemoveOld; };; enum TProof::ERunStatus { kRunning; kStopped; kAborted; };; enum TProof::ESubMerger { kOutputSize; kSendOutput; kBeMerger; kMergerDown; kStopMerging; kOutputSent; };; enum TProof::ESlaves { kAll; kActive; kUnique; kAllUnique; };; enum TObject::EStatusBits { kCanDelete; k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofLite.html:21514,log,logfile,21514,root/html530/TProofLite.html,https://root.cern,https://root.cern/root/html530/TProofLite.html,2,['log'],['logfile']
Testability,"roofdVersion; static Bool_tfgInitDoneAvoid initializing more than once; static TStringfgLocLocation string; static TXSockPipefgPipePipe for input monitoring; static TMutexfgSMtxTo protect spare list; static list<TXSockBuf*>fgSQuelist of spare buffers. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TSocket. XrdClientAbsUnsolMsgHandler. ←; TXSocket. ←. TXUnixSocket. Function documentation; void DoError(int level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protected). TXSocket(const char* url, Char_t mode = 'M', Int_t psid = -1, Char_t ver = -1, const char* logbuf = 0, Int_t loglevel = -1, TXHandler* handler = 0); Constructor; Open the connection to a remote XrdProofd instance and start a PROOF; session.; The mode 'm' indicates the role of this connection:; 'a' Administrator; used by an XPD to contact the head XPD; 'i' Internal; used by a TXProofServ to call back its creator; (see XrdProofUnixConn); 'C' PROOF manager: open connection only (do not start a session); 'M' Client creating a top master; 'A' Client attaching to top master; 'm' Top master creating a submaster; 's' Master creating a slave; The buffer 'logbuf' is a null terminated string to be sent over at; login. TXSocket(const TXSocket& ); TXSocket copy ctor. TXSocket& operator=(const TXSocket& ); TXSocket assignment operator. ~TXSocket(); Destructor. void SetLocation(const char* loc = """"); Set location string. void SetSessionID(Int_t id); Set session ID to 'id'. If id < 0, disable also the asynchronous handler. void DisconnectSession(Int_t id, Option_t* opt = """"); Disconnect a session. Use opt= ""S"" or ""s"" to; shutdown remote session.; Default is opt = """". void Close(Option_t* opt = """"); Close connection. Available options are (case insensitive); 'P' force closing of the underlying physical connection; 'S' shutdown remote session, is any; A session ID can be given using #...# signature, e.g. ""#1#"".; Default is opt = """". UnsolRespProcResult ProcessUnsolicitedM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXSocket.html:14126,log,logbuf,14126,root/html602/TXSocket.html,https://root.cern,https://root.cern/root/html602/TXSocket.html,2,['log'],"['logbuf', 'login']"
Testability,"root.[c]sh scripts will set correctly the ROOTSYS, LD_LIBRARY_PATH or other paths depending on the platform and the MANPATH. To run the program just type: root.; 2.2 Start and Quit a ROOT Session; $ root; -------------------------------------------------------------------------; | Welcome to ROOT 6.10/01 http://root.cern.ch |; | (c) 1995-2017, The ROOT Team |; | Built for macosx64 |; | From heads/v6-10-00-patches@v6-10-00-25-g9f78c3a, Jul 03 2017, 11:39:44 |; | Try '.help', '.demo', '.license', '.credits', '.quit'/'.q' |; -------------------------------------------------------------------------. root [0]; To start ROOT you can type root at the system prompt. This starts up Cling, the ROOT command line C/C++ interpreter, and it gives you the ROOT prompt (root[0]).; It is possible to launch ROOT with some command line options, as shown below:; % root -?; Usage: root [-l] [-b] [-n] [-q] [dir] [[file:]data.root]; [file1.C ... fileN.C]; Options:; -b : run in batch mode without graphics; -n : do not execute logon and logoff macros as specified in .rootrc; -q : exit after processing command line macro files; -l : do not show splash screen; -x : exit on exception; dir : if dir is a valid directory cd to it before executing. -? : print usage; -h : print usage; --help : print usage; -config : print ./configure options. -b ROOT session runs in batch mode, without graphics display. This mode is useful in case one does not want to set the DISPLAY or cannot do it for some reason.; -n usually, launching a ROOT session will execute a logon script and quitting will execute a logoff script. This option prevents the execution of these two scripts.; it is also possible to execute a script without entering a ROOT session. One simply adds the name of the script(s) after the ROOT command. Be warned: after finishing the execution of the script, ROOT will normally enter a new session.; -q process command line script files and exit. For example if you would like to run a script myMacro.C in ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:32964,log,logon,32964,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['log'],"['logoff', 'logon']"
Testability,"rop<Architecture_t, Layer_t, DeepNet_t>(deepNet, settings.learningRate, settings.momentum,; 1378 settings.optimizerParams[""RMSPROP_rho""],; 1379 settings.optimizerParams[""RMSPROP_eps""]));; 1380 break;; 1381 ; 1382 case EOptimizer::kAdadelta:; 1383 optimizer = std::unique_ptr<DNN::TAdadelta<Architecture_t, Layer_t, DeepNet_t>>(; 1384 new DNN::TAdadelta<Architecture_t, Layer_t, DeepNet_t>(deepNet, settings.learningRate,; 1385 settings.optimizerParams[""ADADELTA_rho""],; 1386 settings.optimizerParams[""ADADELTA_eps""]));; 1387 break;; 1388 }; 1389 ; 1390 ; 1391 // Initialize the vector of batches, one batch for one slave network; 1392 std::vector<TTensorBatch<Architecture_t>> batches{};; 1393 ; 1394 bool converged = false;; 1395 size_t convergenceCount = 0;; 1396 size_t batchesInEpoch = nTrainingSamples / deepNet.GetBatchSize();; 1397 ; 1398 // start measuring; 1399 std::chrono::time_point<std::chrono::system_clock> tstart, tend;; 1400 tstart = std::chrono::system_clock::now();; 1401 ; 1402 // function building string with optimizer parameters values for logging; 1403 auto optimParametersString = [&]() {; 1404 TString optimParameters;; 1405 for ( auto & element : settings.optimizerParams) {; 1406 TString key = element.first;; 1407 key.ReplaceAll(settings.optimizerName + ""_"", """"); // strip optimizerName_; 1408 double value = element.second;; 1409 if (!optimParameters.IsNull()); 1410 optimParameters += "","";; 1411 else; 1412 optimParameters += "" ("";; 1413 optimParameters += TString::Format(""%s=%g"", key.Data(), value);; 1414 }; 1415 if (!optimParameters.IsNull()); 1416 optimParameters += "")"";; 1417 return optimParameters;; 1418 };; 1419 ; 1420 Log() << ""Training phase "" << trainingPhase << "" of "" << this->GetTrainingSettings().size() << "": ""; 1421 << "" Optimizer "" << settings.optimizerName; 1422 << optimParametersString(); 1423 << "" Learning rate = "" << settings.learningRate << "" regularization "" << (char)settings.regularization; 1424 << "" minimum error = "" << minValError << En",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:55660,log,logging,55660,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['log'],['logging']
Testability,"ror == fErrorType || kCoordError == fErrorType ); 768 {; 769 assert( fDataError.empty() );; 770 assert( fDataErrorPtr );; 771 ; 772 fDataError.resize(fNPoints + vectorPadding);; 773 std::copy(fDataErrorPtr, fDataErrorPtr + fNPoints + vectorPadding, fDataError.begin());; 774 fDataErrorPtr = fDataError.empty() ? nullptr : &fDataError.front();; 775 }; 776 ; 777 if ( kValueError == fErrorType ); 778 {; 779 for ( unsigned int i=0; i < fNPoints; i++ ); 780 {; 781 fDataError[i] = 1.0 / fDataError[i];; 782 }; 783 }; 784 ; 785 if ( kCoordError == fErrorType || kAsymError == fErrorType ); 786 {; 787 fCoordErrors.resize( fDim );; 788 for( unsigned int i=0; i < fDim; i++ ); 789 {; 790 assert( fCoordErrorsPtr[i] );; 791 fCoordErrors[i].resize(fNPoints + vectorPadding);; 792 std::copy(fCoordErrorsPtr[i], fCoordErrorsPtr[i] + fNPoints + vectorPadding, fCoordErrors[i].begin());; 793 fCoordErrorsPtr[i] = fCoordErrors[i].empty() ? nullptr : &fCoordErrors[i].front();; 794 }; 795 ; 796 if( kAsymError == fErrorType ); 797 {; 798 assert( fDataErrorHigh.empty() );; 799 assert( fDataErrorLow.empty() );; 800 assert( fDataErrorHighPtr && fDataErrorLowPtr );; 801 ; 802 fDataErrorHigh.resize(fNPoints + vectorPadding);; 803 fDataErrorLow.resize(fNPoints + vectorPadding);; 804 std::copy(fDataErrorHighPtr, fDataErrorHighPtr + fNPoints + vectorPadding, fDataErrorHigh.begin());; 805 std::copy(fDataErrorLowPtr, fDataErrorLowPtr + fNPoints + vectorPadding, fDataErrorLow.begin());; 806 fDataErrorHighPtr = fDataErrorHigh.empty() ? nullptr : &fDataErrorHigh.front();; 807 fDataErrorLowPtr = fDataErrorLow.empty() ? nullptr : &fDataErrorLow.front();; 808 }; 809 }; 810 ; 811 FitData::UnWrap();; 812 }; 813 ; 814 void BinData::ComputeSums() {; 815 unsigned int n = Size();; 816 fSumContent = 0;; 817 fSumError2 = 0;; 818 if (fErrorType != kAsymError) {; 819 for (unsigned int i = 0; i < n; ++i) {; 820 double y = Value(i);; 821 double err = Error(i);; 822 fSumContent += y;; 823 if (fErrorType != kNoError) {; 824 i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:24502,assert,assert,24502,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['assert'],['assert']
Testability,"ror == fErrorType || kNoError == fErrorType );; 253 ; 254 if ( fErrorType == kNoError ); 255 return nullptr;; 256 return &fDataErrorPtr[ ipoint ];; 257 }; 258 ; 259 /// Return the error on the given point.; 260 /// Safer method returning in any case the error and not the inverse as in the; 261 /// function above.; 262 double Error( unsigned int ipoint ) const; 263 {; 264 assert( ipoint < fMaxPoints );; 265 assert( kValueError == fErrorType || kCoordError == fErrorType ||; 266 kAsymError == fErrorType || kNoError == fErrorType );; 267 ; 268 if ( fErrorType == kNoError ); 269 {; 270 assert( !fDataErrorPtr && !fDataErrorHighPtr && !fDataErrorLowPtr );; 271 assert( fDataError.empty() && fDataErrorHigh.empty() && fDataErrorLow.empty() );; 272 return 1.0;; 273 }; 274 ; 275 if ( fErrorType == kValueError ) // need to invert (inverror is stored); 276 {; 277 assert( fDataErrorPtr && !fDataErrorHighPtr && !fDataErrorLowPtr );; 278 assert( fDataErrorHigh.empty() && fDataErrorLow.empty() );; 279 assert( fDataError.empty() || &fDataError.front() == fDataErrorPtr );; 280 ; 281 double eval = fDataErrorPtr[ ipoint ];; 282 ; 283 if (fWrapped); 284 return eval;; 285 else; 286 return (eval != 0.0) ? 1.0/eval : 0.0;; 287 }; 288 ; 289 if ( fErrorType == kAsymError ); 290 { // return 1/2(el + eh); 291 assert( !fDataErrorPtr && fDataErrorHighPtr && fDataErrorLowPtr );; 292 assert( fDataError.empty() );; 293 assert( fDataErrorHigh.empty() || &fDataErrorHigh.front() == fDataErrorHighPtr );; 294 assert( fDataErrorLow.empty() || &fDataErrorLow.front() == fDataErrorLowPtr );; 295 assert( fDataErrorLow.empty() == fDataErrorHigh.empty() );; 296 ; 297 double eh = fDataErrorHighPtr[ ipoint ];; 298 double el = fDataErrorLowPtr[ ipoint ];; 299 ; 300 return (el+eh) / 2.0;; 301 }; 302 ; 303 assert( fErrorType == kCoordError );; 304 return fDataErrorPtr[ ipoint ];; 305 }; 306 ; 307 void GetAsymError( unsigned int ipoint, double& lowError, double& highError ) const; 308 {; 309 assert( fErrorType == kAsym",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8h_source.html:9633,assert,assert,9633,doc/master/BinData_8h_source.html,https://root.cern,https://root.cern/doc/master/BinData_8h_source.html,1,['assert'],['assert']
Testability,"ror bars. ;  ; file  exclusiongraph.C;   Draw three graphs with an exclusion zone. ;  ; file  exclusiongraph2.C;   Draw several graphs with an exclusion zones. ;  ; file  gerrors.C;   Draw a graph with error bars ;  ; file  gerrors2.C;   Draw two graphs with error bars ;  ; file  gmultierrors.C;   Draw a graph with multiple y errors ;  ; file  graph.C;   Draw a simple graph. ;  ; file  graph2derrorsfit.C;   Draw and fit a TGraph2DErrors ;  ; file  graphApply.C;   A macro to demonstrate the functionality of TGraph::Apply() method. ;  ; file  graphpalettecolor.C;   Palette coloring for graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ;  ; file  graphpolar.C;   Create and draw a polar graph. ;  ; file  graphpolar2.C;   Create and draw a polar graph with PI axis ;  ; file  graphpolar3.C;   Create and draw a polar graph with PI axis using a TF1. ;  ; file  graphreverse.C;   This example test all the various case of reverse graphs combined with logarithmic scale. ;  ; file  graphShade.C;   Show how to shade an area between two graphs ;  ; file  graphstruct.C;   Draw a simple graph structure. ;  ; file  graphtext.C;   Draw a graph with text attached to each point. ;  ; file  gtime.C;   Example of TGraphTime. ;  ; file  gtime2.C;   Example of TGraphTime showing how the class could be used to visualize a set of particles with their time stamp in a MonteCarlo program. ;  ; file  hlGraph1.C;  This tutorial demonstrates how to use the highlight mode on graph. ;  ; file  hlGraph2.C;  This tutorial demonstrates how to use the highlight mode on graph. ;  ; file  labels1.C;   Setting alphanumeric labels in a 1-d histogram. ;  ; file  labels2.C;   Setting alphanumeric labels. ;  ; file  motorcycle.C;   Macro to test scatterplot smoothers: ksmooth, lowess, supsmu as described in: ;  ; file  multigraph.C;   Create and Draw a TMultiGraph. ;  ; file  multigraphpalettecolor.C;   Palette coloring for multi-graphs ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__graphs.html:1404,test,test,1404,doc/master/group__tutorial__graphs.html,https://root.cern,https://root.cern/doc/master/group__tutorial__graphs.html,2,"['log', 'test']","['logarithmic', 'test']"
Testability,"ror; By default the integral is computed as the sum of bin contents in the range.; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x.; the error is computed using error propagation from the bin errors assumming that; all the bins are uncorrelated. Double_t DoIntegral(Int_t ix1, Int_t ix2, Int_t iy1, Int_t iy2, Int_t iz1, Int_t iz2, Double_t& err, Option_t* opt, Bool_t doerr = kFALSE) const; internal function compute integral and optionally the error between the limits; specified by the bin number values working for all histograms (1D, 2D and 3D). Double_t AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; Statistical test of compatibility in shape between; this histogram and h2, using the Anderson-Darling 2 sample test.; The AD 2 sample test formula are derived from the paper; F.W Scholz, M.A. Stephens ""k-Sample Anderson-Darling Test"".; The test is implemented in root in the ROOT::Math::GoFTest class; It is the same formula ( (6) in the paper), and also shown in this preprint; http://arxiv.org/pdf/0804.0380v1.pdf; Binned data are considered as un-binned data; with identical observation happening in the bin center. option is a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""T"" Return the normalized A-D test statistic. Note1: Underflow and overflow are not considered in the test; Note2: The test works only for un-weighted histogram (i.e. representing counts); Note3: The histograms are not required to have the same X axis; Note4: The test works only for 1-dimensional histograms. Double_t AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; Same funciton as above but returning also the test statistic value. Double_t KolmogorovTest(const TH1* h2, Option_t* option = """") const; Statistical test of compatibility in shape between; this histogram and h2, using Kolmogorov test.; Note that the KolmogorovTest (KS) test should in theory be used only for unbinned data; a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH1.html:114019,test,test,114019,root/html534/TH1.html,https://root.cern,https://root.cern/root/html534/TH1.html,3,['test'],['test']
Testability,"rorHigh.empty() ? nullptr : &fDataErrorHigh.front();; 712 ; 713 fDataErrorLow.resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 714 fDataErrorLowPtr = fDataErrorLow.empty() ? nullptr : &fDataErrorLow.front();; 715 ; 716 fDataError.clear();; 717 fDataErrorPtr = nullptr;; 718 }; 719 else; 720 {; 721 assert(false);; 722 }; 723 }; 724 ; 725 void BinData::InitBinEdge(); 726 {; 727 fBinEdge.resize( fDim );; 728 ; 729 for( unsigned int i=0; i<fDim; i++ ); 730 {; 731 fBinEdge[i].reserve(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 732 }; 733 ; 734 if ( fpTmpBinEdgeVector ); 735 {; 736 delete[] fpTmpBinEdgeVector;; 737 fpTmpBinEdgeVector = nullptr;; 738 }; 739 ; 740 fpTmpBinEdgeVector = new double[ fDim ];; 741 }; 742 ; 743 void BinData::UnWrap( ); 744 {; 745 assert( fWrapped );; 746 assert( kValueError == fErrorType || kCoordError == fErrorType ||; 747 kAsymError == fErrorType || kNoError == fErrorType );; 748 assert( fDataError.empty() || &fDataError.front() == fDataErrorPtr );; 749 assert( fDataErrorHigh.empty() || &fDataErrorHigh.front() == fDataErrorHighPtr );; 750 assert( fDataErrorLow.empty() || &fDataErrorLow.front() == fDataErrorLowPtr );; 751 assert( fDataErrorLow.empty() == fDataErrorHigh.empty() );; 752 ; 753 assert( fData.empty() );; 754 assert( fDataPtr );; 755 ; 756 unsigned vectorPadding = FitData::VectorPadding(fNPoints);; 757 fData.resize(fNPoints + vectorPadding);; 758 std::copy( fDataPtr, fDataPtr + fNPoints, fData.begin() );; 759 fDataPtr = fData.empty() ? nullptr : &fData.front();; 760 ; 761 for ( unsigned int i=0; i < fDim; i++ ); 762 {; 763 assert( fCoordErrorsPtr[i] );; 764 assert( fCoordErrors.empty() || &fCoordErrors[i].front() == fCoordErrorsPtr[i] );; 765 }; 766 ; 767 if( kValueError == fErrorType || kCoordError == fErrorType ); 768 {; 769 assert( fDataError.empty() );; 770 assert( fDataErrorPtr );; 771 ; 772 fDataError.resize(fNPoints + vectorPadding);; 773 std::copy(fDataErrorPtr, fDataErrorPtr + fNPoints + vectorPadding, fDataErr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:22740,assert,assert,22740,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['assert'],['assert']
Testability,"rorHigh.empty() || &fDataErrorHigh.front() == fDataErrorHighPtr );; 359 assert( fDataErrorLow.empty() || &fDataErrorLow.front() == fDataErrorLowPtr );; 360 assert( fDataErrorLow.empty() == fDataErrorHigh.empty() );; 361 ; 362 double eh = fDataErrorHighPtr[ ipoint ];; 363 double el = fDataErrorLowPtr[ ipoint ];; 364 ; 365 return 2.0 / (el+eh);; 366 }; 367 ; 368 assert( fErrorType == kCoordError );; 369 // for coordinate error we store the error and not the inverse; 370 return 1.0 / fDataErrorPtr[ ipoint ];; 371 }; 372 ; 373 ; 374 /**; 375 retrieve at the same time a pointer to the coordinate data and the fit value; 376 More efficient than calling Coords(i) and Value(i); 377 */; 378 // not threadsafe, to be replaced with never constructs!; 379 // for example: just return std::array or std::vector, there's; 380 // is going to be only minor overhead in c++11.; 381 const double * GetPoint( unsigned int ipoint, double & value ) const; 382 {; 383 assert( ipoint < fMaxPoints );; 384 value = Value( ipoint );; 385 ; 386 return Coords( ipoint );; 387 }; 388 ; 389 /**; 390 returns a single coordinate error component of a point.; 391 This function is threadsafe in contrast to Coords(...); 392 and can easily get vectorized by the compiler in loops; 393 running over the ipoint-index.; 394 */; 395 double GetCoordErrorComponent( unsigned int ipoint, unsigned int icoord ) const; 396 {; 397 assert( ipoint < fMaxPoints );; 398 assert( icoord < fDim );; 399 assert( fCoordErrorsPtr.size() == fDim );; 400 assert( fCoordErrorsPtr[icoord] );; 401 assert( fCoordErrors.empty() || &fCoordErrors[icoord].front() == fCoordErrorsPtr[icoord] );; 402 ; 403 return fCoordErrorsPtr[icoord][ipoint];; 404 }; 405 ; 406 /**; 407 Return a pointer to the errors in the coordinates for the given fit point; 408 */; 409 // not threadsafe, to be replaced with never constructs!; 410 // for example: just return std::array or std::vector, there's; 411 // is going to be only minor overhead in c++11.; 412 const double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8h_source.html:13490,assert,assert,13490,doc/master/BinData_8h_source.html,https://root.cern,https://root.cern/doc/master/BinData_8h_source.html,1,['assert'],['assert']
Testability,"rors reference file created by CheckBoundaryErrors method.; The shape for which the crossing failed is drawn with the starting point in red; and the extrapolated point to boundary (+/- failing push/pull) in yellow. void CheckGeometryFull(Bool_t checkoverlaps = kTRUE, Bool_t checkcrossings = kTRUE, Int_t nrays = 10000, const Double_t* vertex = __null); Geometry checking method (see: TGeoManager::CheckGeometry()). void CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const; Geometry checking method (see TGeoChecker). void CheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.10000000000000001, Option_t* option = """") const; Check overlaps for the top volume of the geometry, within a limit OVLP. void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); check current point in the geometry. void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2). void ClearVisibleVolumes(); Clear the list of visible volumes; reset the kVisOnScreen bit for volumes previously in the list. void DefineColors() const; Define 100 colors with increasing light intensities for each basic color (1-7); Register these colors at indexes starting with 1000. Int_t GetColor(Int_t base, Float_t light) const; Get index of a base color with given light intensity (0,1). TGeoVolume * GetDrawnVolume() const; Get currently drawn volume. Int_t DistanceToPrimitiveVol(TGeoVolume* vol, Int_t px, Int_t py); compute the closest distance of approach from point px,py to a volume. void DefaultAngles(); Set default angles for the current view. void DefaultColors(); Set default volume colors according to tracking media. Int_t CountNodes(TGeoVolume* v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoPainter.html:15548,test,test,15548,root/html602/TGeoPainter.html,https://root.cern,https://root.cern/root/html602/TGeoPainter.html,2,['test'],['test']
Testability,"rors[0].front() == fCoordErrorsPtr[0] );; 462 ; 463 fData[ fNPoints ] = y;; 464 fCoordErrors[0][ fNPoints ] = ex;; 465 fDataError[ fNPoints ] = ey;; 466 ; 467 FitData::Add( x );; 468 fSumContent += y;; 469 if (y != 0 || ey != 1.0) fSumError2 += ey*ey;; 470 // set the weight flag checking if error^2 != y; 471 if (!fIsWeighted); 472 if (y != 0 && std::abs( ey*ey/y - 1.0) > 1.E-12) fIsWeighted = true;; 473 }; 474 ; 475 /**; 476 add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); 477 in this case store the y errors and not the inverse; 478 */; 479 void BinData::Add( double x, double y, double ex, double eyl, double eyh ); 480 {; 481 assert( kAsymError == fErrorType );; 482 assert( !fData.empty() && fDataPtr );; 483 assert( !fDataErrorHigh.empty() && fDataErrorHighPtr );; 484 assert( !fDataErrorLow.empty() && fDataErrorLowPtr );; 485 assert( fDataError.empty() && !fDataErrorPtr );; 486 assert( !fCoordErrors.empty() && fCoordErrors.size() == 1 );; 487 assert( !fCoordErrorsPtr.empty() && fCoordErrorsPtr.size() == 1 && fCoordErrorsPtr[0] );; 488 assert( &fCoordErrors[0].front() == fCoordErrorsPtr[0] );; 489 ; 490 fData[ fNPoints ] = y;; 491 fCoordErrors[0][ fNPoints ] = ex;; 492 fDataErrorHigh[ fNPoints ] = eyh;; 493 fDataErrorLow[ fNPoints ] = eyl;; 494 ; 495 FitData::Add( x );; 496 fSumContent += y;; 497 if (y != 0 || eyl != 1.0 || eyh != 1.0) fSumError2 += (eyl+eyh)*(eyl+eyh)/4;; 498 ; 499 }; 500 ; 501 /**; 502 add multi-dim coordinate data with only value; 503 */; 504 void BinData::Add( const double* x, double val ); 505 {; 506 assert( kNoError == fErrorType );; 507 ; 508 assert( !fData.empty() && fDataPtr );; 509 assert( fDataErrorHigh.empty() && !fDataErrorHighPtr );; 510 assert( fDataErrorLow.empty() && !fDataErrorLowPtr );; 511 assert( fDataError.empty() && !fDataErrorPtr );; 512 assert( fCoordErrors.empty() && fCoordErrorsPtr.empty() );; 513 ; 514 fData[ fNPoints ] = val;; 515 ; 516 FitData::Add( x );; 517 fSumContent += val;; 5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:14764,assert,assert,14764,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['assert'],['assert']
Testability,"rotected Attributes; UInt_t fTarget;  ;  Protected Attributes inherited from TMVA::PDEFoam; Double_t * fAlpha;  [fDim] Internal parameters of the hyperrectangle ;  ; PDEFoamCell ** fCells;  [fNCells] Array of ALL cells ;  ; Int_t fDim;  Dimension of the integration/simulation space. ;  ; PDEFoamDensityBase * fDistr;  ! distribution of training events ;  ; EDTSeparation fDTSeparation;  BACKWARDS COMPATIBILITY: split cells according to decision tree logic. ;  ; Int_t fEvPerBin;  Maximum number of effective (wt=1) events per bin. ;  ; Bool_t fFillFoamWithOrigWeights;  BACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights. ;  ; EFoamType fFoamType;  BACKWARDS COMPATIBILITY: type of foam. ;  ; TObjArray * fHistEdg;  Histograms of wt, one for each cell edge. ;  ; Int_t * fInhiDiv;  ! [fDim] Flags for inhibiting cell division ;  ; Int_t fLastCe;  Index of the last cell. ;  ; MsgLogger * fLogger;  ! message logger ;  ; Int_t * fMaskDiv;  ! [fDim] Dynamic Mask for cell division ;  ; UInt_t fMaxDepth;  maximum depth of cell tree ;  ; TString fName;  Name of a given instance of the FOAM class. ;  ; Int_t fNBin;  No. of bins in the edge histogram for cell MC exploration. ;  ; Int_t fNCells;  Maximum number of cells. ;  ; UInt_t fNElements;  BACKWARDS COMPATIBILITY: number of variables in every cell. ;  ; UInt_t fNmin;  minimal number of events in cell to split cell ;  ; Int_t fNoAct;  Number of active cells. ;  ; Int_t fNSampl;  No. of MC events, when dividing (exploring) cell. ;  ; Bool_t fPeekMax;  BACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split. ;  ; TRandom3 * fPseRan;  Pointer to user-defined generator of pseudorandom numbers. ;  ; Double_t * fRvec;  [fDim] random number vector from r.n. generator fDim+1 maximum elements ;  ; Timer * fTimer;  ! timer for graphical output ;  ; TObjArray * fVariableNames;  collection of all variable names ;  ; Float_t fVolFrac;  BACKWARDS COMPATIBILITY: volume fraction (with respect to total phase space",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1PDEFoamTarget.html:17214,log,logger,17214,doc/master/classTMVA_1_1PDEFoamTarget.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1PDEFoamTarget.html,1,['log'],['logger']
Testability,"rotected:. RooArgSetfAlternateParamsRooArgSet specifying alternate parameters for hypothesis test // Is it used ????; RooAbsData*fData; RooArgSetfNuisParamsRooArgSet specifying nuisance parameters for interval; RooArgSetfNullParamsRooArgSet specifying null parameters for hypothesis test; RooArgSetfPOIRooArgSet specifying parameters of interest for interval; RooAbsPdf*fPdf; Double_tfSizesize of the test (eg. specified rate of Type I error). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetTestSize(Double_t size). SetModel(const RooStats::ModelConfig& model). virtual ~CombinedCalculator(); destructor. { }. ConfInterval* GetInterval() const; Main interface to get a ConfInterval, pure virtual. HypoTestResult* GetHypoTest() const; main interface to get a HypoTestResult, pure virtual. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void SetData(RooAbsData& data); Set the DataSet, add to the the workspace if not already there. void SetNullModel(const RooStats::ModelConfig& ). void SetAlternateModel(const RooStats::ModelConfig& ). void SetPdf(RooAbsPdf& pdf); specific setting - keep for convenience- some of them could be removed; Set the Pdf. { fPdf = &pdf; }. void SetParameters(const RooArgSet& set); specify the parameters of interest in the interval. { fPOI.removeAll(); fPOI.add(set); }. void SetNuisanceParameters(const RooArgSet& set); specify the nuisance parameters (eg. the rest of the parameters). {fNuisParams.removeAll(); fNuisParams.add(set);}. void SetNullParameters(const RooArgSet& set); set parameter values for the null if using a common PDF. {fNullParams.removeAll(); fNullParams.add(set);}. void SetAlternateParameters(const RooArgSet& set); set p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__CombinedCalculator.html:4158,test,test,4158,root/html526/RooStats__CombinedCalculator.html,https://root.cern,https://root.cern/root/html526/RooStats__CombinedCalculator.html,4,['test'],['test']
Testability,"round ay parameter ;  ; Double_t fAyInit;  initial value of background ay parameter(backgroud is estimated as a0+ax*x+ay*y) ;  ; Double_t fBxCalc;  calculated value of b parameter for 1D ridges in x direction ;  ; Double_t fBxErr;  error value of b parameter for 1D ridges in x direction ;  ; Double_t fBxInit;  initial value of b parameter for 1D ridges in x direction (slope), for details see html manual and references ;  ; Double_t fByCalc;  calculated value of b parameter for 1D ridges in y direction ;  ; Double_t fByErr;  error value of b parameter for 1D ridges in y direction ;  ; Double_t fByInit;  initial value of b parameter for 1D ridges in y direction (slope), for details see html manual and references ;  ; Double_t fChi;  here the fitting functions return resulting chi square ;  ; Int_t fFitTaylor;  order of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function. ;  ; Bool_t fFixA0;  logical value of a0 parameter, which allows to fix the parameter (not to fit). ;  ; Bool_t * fFixAmp;  [fNPeaks] array of logical values which allow to fix appropriate amplitudes of 2D peaks (not fit). However they are present in the estimated functional ;  ; Bool_t * fFixAmpX1;  [fNPeaks] array of logical values which allow to fix appropriate amplitudes of 1D ridges in x direction (not fit). However they are present in the estimated functional ;  ; Bool_t * fFixAmpY1;  [fNPeaks] array of logical values which allow to fix appropriate amplitudes of 1D ridges in y direction (not fit). However they are present in the estimated functional ;  ; Bool_t fFixAx;  logical value of ax parameter, which allows to fix the parameter (not to fit). ;  ; Bool_t fFixAy;  logical value of ay parameter, which allows to fix the parameter (not to fit). ;  ; Bool_t fFixBx;  logical value of b parameter for 1D ridges in x direction, which allows to fix the parameter (not to fit). ;  ; Bool_t fFixBy;  logical value of b parameter for 1D ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2Fit.html:25856,log,logical,25856,doc/master/classTSpectrum2Fit.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2Fit.html,1,['log'],['logical']
Testability,"rovides examples for the training and testing of the TMVA classifiers in categorisation mode. ;  ;  TMVAClassificationCategoryApplication.C;   This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  ;  TMVACrossValidation.C;   This macro provides an example of how to use TMVA for k-folds cross evaluation. ;  ;  TMVACrossValidationApplication.C;   This macro provides an example of how to use TMVA for k-folds cross evaluation in application. ;  ;  TMVACrossValidationRegression.C;   This macro provides an example of how to use TMVA for k-folds cross evaluation. ;  ;  TMVAGAexample.C;   This executable gives an example of a very simple use of the genetic algorithm of TMVA ;  ;  TMVAGAexample2.C;   This executable gives an example of a very simple use of the genetic algorithm of TMVA. ;  ;  TMVAMinimalClassification.C;   Minimal self-contained example for setting up TMVA with binary classification. ;  ;  TMVAMulticlass.C;   This macro provides a simple example for the training and testing of the TMVA multiclass classification ;  ;  TMVAMulticlassApplication.C;   This macro provides a simple example on how to use the trained multiclass classifiers within an analysis module ;  ;  TMVAMultipleBackgroundExample.C;   This example shows the training of signal with three different backgrounds Then in the application a tree is created with all signal and background events where the true class ID and the three classifier outputs are added finally with the application tree, the significance is maximized with the help of the TMVA genetic algorithm. ;  ;  TMVARegression.C;   This macro provides examples for the training and testing of the TMVA classifiers. ;  ;  TMVARegressionApplication.C;   This macro provides a simple example on how to use the trained regression MVAs within an analysis module ;  . tutorialstmva. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:51 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html:6318,test,testing,6318,doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,https://root.cern,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,2,['test'],['testing']
Testability,"rowse a volume. Double_t Capacity() const; Computes the capacity of this [cm^3] as the capacity of its shape.; In case of assemblies, the capacity is computed as the sum of daughter's capacities. void CheckGeometry(Int_t nrays = 1, Double_t startx = 0, Double_t starty = 0, Double_t startz = 0) const; Shoot nrays with random directions from starting point (startx, starty, startz); in the reference frame of this volume. Track each ray until exiting geometry, then; shoot backwards from exiting point and compare boundary crossing points. void CheckOverlaps(Double_t ovlp = 0.10000000000000001, Option_t* option = """") const; Overlap checking tool. Check for illegal overlaps within a limit OVLP.; Use option=""s[number]"" to force overlap checking by sampling volume with; [number] points.; Ex: myVol->CheckOverlaps(0.01, ""s10000000""); // shoot 10000000 points; myVol->CheckOverlaps(0.01, ""s""); // shoot the default value of 1e6 points. void CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); Tests for checking the shape navigation algorithms. See TGeoShape::CheckShape(). void CleanAll(); Clean data of the volume. void ClearShape(); Clear the shape of this volume from the list held by the current manager. void CheckShapes(); check for negative parameters in shapes.; THIS METHOD LEAVES SOME GARBAGE NODES -> memory leak, to be fixed; printf(""---Checking daughters of volume %s\n"", GetName());. Int_t CountNodes(Int_t nlevels = 1000, Int_t option = 0); Count total number of subnodes starting from this volume, nlevels down; option = 0 (default) - count only once per volume; option = 1 - count every time; option = 2 - count volumes on visible branches; option = 3 - return maximum level counted already with option = 0. Bool_t IsAllInvisible() const; Return TRUE if volume and all daughters are invisible. void InvisibleAll(Bool_t flag = kTRUE); Make volume and each of it daughters (in)visible. Bool_t IsFolder() const; Return TRUE if volume contains nodes; return (GetNda",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoVolume.html:34701,test,testNo,34701,root/html602/TGeoVolume.html,https://root.cern,https://root.cern/root/html602/TGeoVolume.html,2,['test'],['testNo']
Testability,"rowser in specified place ;  . Protected Member Functions; std::shared_ptr< RBrowserWidget > AddCatchedWidget (RWebWindow *win, const std::string &kind);  Add widget catched from external scripts. ;  ; void AddInitWidget (const std::string &kind);  Create new widget and send init message to the client. ;  ; std::shared_ptr< RBrowserWidget > AddWidget (const std::string &kind);  Creates new widget. ;  ; void CheckWidgtesModified (unsigned connid);  Check if any widget was modified and update if necessary. ;  ; void CloseTab (const std::string &name);  Close and delete specified widget. ;  ; std::shared_ptr< RBrowserWidget > FindWidget (const std::string &name, const std::string &kind="""") const;  Find widget by name or kind. ;  ; std::shared_ptr< RBrowserWidget > GetActiveWidget () const;  ; std::string GetCurrentWorkingDirectory ();  Return the current directory of ROOT. ;  ; std::vector< std::string > GetRootHistory ();  Get content of history file. ;  ; std::vector< std::string > GetRootLogs ();  Get content of log file. ;  ; std::string NewWidgetMsg (std::shared_ptr< RBrowserWidget > &widget);  Create message which send to client to create new widget. ;  ; std::string ProcessBrowserRequest (const std::string &msg);  Process browser request. ;  ; std::string ProcessDblClick (unsigned connid, std::vector< std::string > &args);  Process dbl click on browser item. ;  ; void ProcessMsg (unsigned connid, const std::string &arg);  Process received message from the client. ;  ; void ProcessPostponedRequests ();  Process postponed requests - decouple from websocket handling Only requests which can take longer time should be postponed. ;  ; void ProcessRunMacro (const std::string &file_path);  Process run macro command in the editor. ;  ; void ProcessSaveFile (const std::string &fname, const std::string &content);  Process file save command in the editor. ;  ; void SendInitMsg (unsigned connid);  Process client connect. ;  ; void SendProgress (unsigned connid, float progr);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RBrowser.html:2604,log,log,2604,doc/master/classROOT_1_1RBrowser.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RBrowser.html,1,['log'],['log']
Testability,"roximation. ; Definition at line 209 of file LDA.cxx. ◆ GetLogLikelihood(). Float_t TMVA::LDA::GetLogLikelihood ; (; const std::vector< Float_t > & ; x, . Int_t ; k . ). Log likelihood function with Gaussian approximation. ; Definition at line 250 of file LDA.cxx. ◆ GetProb(). Float_t TMVA::LDA::GetProb ; (; const std::vector< Float_t > & ; x, . Int_t ; k . ). Signal probability with Gaussian approximation. ; Definition at line 237 of file LDA.cxx. ◆ Initialize(). void TMVA::LDA::Initialize ; (; const LDAEvents & ; inputSignal, . const LDAEvents & ; inputBackground . ). Create LDA matrix using local events found by knn method. ; Definition at line 66 of file LDA.cxx. ◆ Log(). MsgLogger & TMVA::LDA::Log ; (; ); const. inlineprivate . Definition at line 65 of file LDA.h. Member Data Documentation. ◆ fDebug. Bool_t TMVA::LDA::fDebug. private . documentation! ; Definition at line 76 of file LDA.h. ◆ fEventFraction. std::map<Int_t, Float_t> TMVA::LDA::fEventFraction. private . documentation! ; Definition at line 75 of file LDA.h. ◆ fLogger. MsgLogger* TMVA::LDA::fLogger. mutableprivate . ! message logging service ; Definition at line 78 of file LDA.h. ◆ fMu. std::map<Int_t, std::vector<Float_t> > TMVA::LDA::fMu. private . documentation! ; Definition at line 72 of file LDA.h. ◆ fNumParams. UInt_t TMVA::LDA::fNumParams. private . documentation! ; Definition at line 71 of file LDA.h. ◆ fSigma. TMatrixF* TMVA::LDA::fSigma. private . documentation! ; Definition at line 73 of file LDA.h. ◆ fSigmaInverse. TMatrixF* TMVA::LDA::fSigmaInverse. private . documentation! ; Definition at line 74 of file LDA.h. ◆ fTolerence. Float_t TMVA::LDA::fTolerence. private . documentation! ; Definition at line 70 of file LDA.h. Libraries for TMVA::LDA:. [legend]; The documentation for this class was generated from the following files:; tmva/tmva/inc/TMVA/LDA.h; tmva/tmva/src/LDA.cxx. TMVALDA. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1LDA.html:2964,log,logging,2964,doc/master/classTMVA_1_1LDA.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1LDA.html,1,['log'],['logging']
Testability,"roxy.cxx:102; namechar name[80]Definition TGX11.cxx:110; TVirtualMutex.h; ROOT::Browsable::RItemRepresentation of single item in the browser.Definition RItem.hxx:23; ROOT::Browsable::RItem::RItemRItem()=default; ROOT::RGeoItemRepresentation of single item in the geometry browser.Definition RGeomData.hxx:91; ROOT::RGeoItem::RGeoItemRGeoItem(const std::string &_name, int _nchilds, int _nodeid, const std::string &_color, const std::string &_material="""", int _vis=0, int _pvis=0)Definition RGeomData.hxx:107; ROOT::RGeoItem::colorstd::string colorcolorDefinition RGeomData.hxx:96; ROOT::RGeoItem::topbool topindicates if node selected as topDefinition RGeomData.hxx:100; ROOT::RGeoItem::SetTopvoid SetTop(bool on=true)Definition RGeomData.hxx:115; ROOT::RGeoItem::materialstd::string materialmaterialDefinition RGeomData.hxx:97; ROOT::RGeoItem::~RGeoItem~RGeoItem() override=default; ROOT::RGeoItem::pvisint pvisvisibility of physical nodeDefinition RGeomData.hxx:99; ROOT::RGeoItem::visint visvisibility of logical nodeDefinition RGeomData.hxx:98; ROOT::RGeoItem::idint idnode idDefinition RGeomData.hxx:95; ROOT::RGeoItem::RGeoItemRGeoItem()=defaultDefault constructor.; ROOT::RGeomBrowserIterIterator of hierarchical geometry structures.Definition RGeomData.cxx:60; ROOT::RGeomConfigConfiguration parameters which can be configured on the client Send as is to-from client.Definition RGeomData.hxx:162; ROOT::RGeomConfig::showtopbool showtopshow geometry top volume, off by defaultDefinition RGeomData.hxx:167; ROOT::RGeomConfig::maxnumfacesint maxnumfacesmaximal number of facesDefinition RGeomData.hxx:166; ROOT::RGeomConfig::vislevelint vislevelvisible levelDefinition RGeomData.hxx:164; ROOT::RGeomConfig::maxnumnodesint maxnumnodesmaximal number of nodesDefinition RGeomData.hxx:165; ROOT::RGeomConfig::drawoptstd::string drawoptdraw options for TGeoPainterDefinition RGeomData.hxx:170; ROOT::RGeomConfig::build_shapesint build_shapeswhen shapes build on server 0 - never, 1 - TGeoComposite, 2 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8hxx_source.html:19364,log,logical,19364,doc/master/RGeomData_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8hxx_source.html,2,['log'],['logical']
Testability,"rph"");; morph_->plotOn(frame1, LineColor(kRed));; ; return frame1;; }; ; // Define the workspace; std::unique_ptr<RooWorkspace> build_ws(double mu_observed, double sigma); {; auto ws = std::make_unique<RooWorkspace>();; ws->factory(Form(""Gaussian::gauss(x[-5,15],mu[%f,0,4], %f)"", mu_observed, sigma));; return ws;; }; ; // Do the example; void rf616_morphing(); {; // Define the 'observed' mu; double mu_observed = 2.5;; double sigma = 1.5;; ; // Import variables from workspace; std::unique_ptr<RooWorkspace> ws = build_ws(mu_observed, sigma);; ; RooPlot *frame1 = perform_morphing(*ws, RooMomentMorphFuncND::Linear, sigma);; ; RooRealVar *x_var = ws->var(""x"");; RooRealVar *mu_var = ws->var(""mu"");; RooAbsPdf *gauss = ws->pdf(""gauss"");; RooDataSet *obs_data = gauss->generate(*x_var, n_samples);; ; // Create the exact negative log likelihood function for Gaussian model; RooAbsReal *nll_gauss = gauss->createNLL(*obs_data);; ; // Create the morphed negative log likelihood function; // TODO: Fix RooAddPdf::fixCoefNormalization(nset) warnings with new CPU backend; RooAbsReal *nll_morph = ws->pdf(""morph"")->createNLL(*obs_data, RooFit::EvalBackend(""legacy""));; ; // Plot the negative logarithmic summed likelihood; RooPlot *frame2 = mu_var->frame(Title(""Negative log Likelihood""));; nll_gauss->plotOn(frame2, LineColor(kBlue), ShiftToZero(), Name(""gauss""));; nll_morph->plotOn(frame2, LineColor(kRed), ShiftToZero(), Name(""morph""));; ; TCanvas *c = new TCanvas(""rf616_morphing"", ""rf616_morphing"", 800, 400);; c->Divide(2);; c->cd(1);; gPad->SetLeftMargin(0.15);; frame1->GetYaxis()->SetTitleOffset(1.4);; frame1->Draw();; c->cd(2);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.8);; frame2->Draw();; ; // Compute the minimum of the nll via minuit; std::vector<RooAbsReal *> nlls = {nll_gauss, nll_morph};; for (auto nll : nlls) {; RooMinimizer minimizer(*nll);; minimizer.setPrintLevel(-1);; minimizer.minimize(""Minuit2"");; RooFitResult *result = minimizer.save();; result->Pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf616__morphing_8C.html:3962,log,log,3962,doc/master/rf616__morphing_8C.html,https://root.cern,https://root.cern/doc/master/rf616__morphing_8C.html,4,['log'],"['log', 'logarithmic']"
Testability,"rpolation applied on numeric cdf . PyROOT; The RooAbsPdf::createCdf() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 2490 of file RooAbsPdf.cxx. ◆ createExpectedEventsFunc(). std::unique_ptr< RooAbsReal > RooAbsPdf::createExpectedEventsFunc ; (; const RooArgSet * ; nset); const. virtual . Returns an object that represents the expected number of events for a given normalization set, similar to how createIntegral() returns an object that returns the integral. ; This is used to build the computation graph for the final likelihood. ; Reimplemented in RooNormalizedPdf, RooFixedProdPdf, RooAddPdf, RooBinSamplingPdf, RooExtendedTerm, RooExtendPdf, RooProdPdf, and RooRealSumPdf.; Definition at line 2812 of file RooAbsPdf.cxx. ◆ createNLL(). template<typename... CmdArgs_t> . RooAbsPdf::createNLL ; (; RooAbsData & ; data, . CmdArgs_t const &... ; cmdArgs . ). inline . Construct representation of -log(L) of PDF with given dataset. ; If dataset is unbinned, an unbinned likelihood is constructed. If the dataset is binned, a binned likelihood is constructed.; Parameters. dataReference to a RooAbsData object representing the dataset. ; cmdArgsVariadic template arguments representing optional command arguments. You can pass either an arbitrary number of RooCmdArg instances or a single RooLinkedList that points to the RooCmdArg objects. . ReturnsAn owning pointer to the created RooAbsReal NLL object.; Template Parameters. CmdArgs_tTemplate types for optional command arguments. Can either be an arbitrary number of RooCmdArg or a single RooLinkedList. NoteThis front-end function should not be re-implemented in derived PDF types. If you mean to customize the NLL creation routine, you need to override the virtual RooAbsPdf::createNLLImpl() method.; The following named arguments are supported:. Type of CmdArg Effect on NLL . ConditionalObservables(Args_t &&... argsOrArgSet) Do not normalize ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:86920,log,log,86920,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['log'],['log']
Testability,"rporating systematic variations to the nominal PDF. ; The Bernstein basis polynomails are particularly appropriate because they are positive definite. . This tool was inspired by the work of Glen Cowan together with Stephan Horner, Sascha Caron, ; Eilam Gross, and others. ; The initial implementation is independent work. The major step forward in the approach was ; to provide a well defined algorithm that specifies the order of polynomial to be included ; in the correction. This is an emperical algorithm, so in addition to the nominal model it ; needs either a real data set or a simulated one. In the early work, the nominal model was taken; to be a histogram from Monte Carlo simulations, but in this implementation it is generalized to an; arbitrary PDF (which includes a RooHistPdf). The algorithm basically consists of a ; hypothesis test of an nth-order correction (null) against a n+1-th order correction (alternate). ; The quantity q = -2 log LR is used to determine whether the n+1-th order correction is a major ; improvement to the n-th order correction. The distribution of q is expected to be roughly ; \chi^2 with one degree of freedom if the n-th order correction is a good model for the data. ; Thus, one only moves to the n+1-th order correction of q is relatively large. The chance that ; one moves from the n-th to the n+1-th order correction when the n-th order correction ; (eg. a type 1 error) is sufficient is given by the Prob(\chi^2_1 > threshold). The constructor ; of this class allows you to directly set this tolerance (in terms of probability that the n+1-th; term is added unnecessarily). To do:; Add another method to the utility that will make the sampling distribution for -2 log lambda ; for various m vs. m+1 order corrections using a nominal model and perhaps having two ways of ; generating the toys (either via a histogram or via an independent model that is supposed to; reflect reality). That will allow one to make plots like Glen has at the end of his ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__BernsteinCorrection.html:1421,log,log,1421,root/html526/RooStats__BernsteinCorrection.html,https://root.cern,https://root.cern/root/html526/RooStats__BernsteinCorrection.html,7,['log'],['log']
Testability,"rr - gets error value of b parameter; s - gets the fitted value of s parameter; sErr - gets error value of s parameter . Definition at line 2762 of file TSpectrumFit.cxx. ◆ IsA(). TClass * TSpectrumFit::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Definition at line 131 of file TSpectrumFit.h. ◆ Ourpowl(). Double_t TSpectrumFit::Ourpowl ; (; Double_t ; a, . Int_t ; pw . ). protected . Power function. ; Definition at line 676 of file TSpectrumFit.cxx. ◆ SetBackgroundParameters(). void TSpectrumFit::SetBackgroundParameters ; (; Double_t ; a0Init, . Bool_t ; fixA0, . Double_t ; a1Init, . Bool_t ; fixA1, . Double_t ; a2Init, . Bool_t ; fixA2 . ). This function sets the following fitting parameters of background: . a0Init - initial value of a0 parameter (background is estimated as a0+a1*x+a2*x*x); fixA0 - logical value of a0 parameter, which allows to fix the parameter (not to fit); a1Init - initial value of a1 parameter; fixA1 - logical value of a1 parameter, which allows to fix the parameter (not to fit); a2Init - initial value of a2 parameter; fixA2 - logical value of a2 parameter, which allows to fix the parameter (not to fit) . Definition at line 2693 of file TSpectrumFit.cxx. ◆ SetFitParameters(). void TSpectrumFit::SetFitParameters ; (; Int_t ; xmin, . Int_t ; xmax, . Int_t ; numberIterations, . Double_t ; alpha, . Int_t ; statisticType, . Int_t ; alphaOptim, . Int_t ; power, . Int_t ; fitTaylor . ). This function sets the following fitting parameters: . xmin, xmax - fitting region; numberIterations - # of desired iterations in the fit; alpha - convergence coefficient, it should be positive number and <=1, for details see references; statisticType - type of statistics, possible values kFitOptimChiCounts (chi square statistics with counts as weighting coefficients), kFitOptimChiFuncValues (chi square statistics with function values as weighting coefficients),kFitOptimMaxLikelihood; alphaOptim - opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrumFit.html:44880,log,logical,44880,doc/master/classTSpectrumFit.html,https://root.cern,https://root.cern/doc/master/classTSpectrumFit.html,3,['log'],['logical']
Testability,"rrLower = nullptr, . Double_t * ; errUpper = nullptr . ). pure virtual . Implements TMVA::IMethod.; Implemented in TMVA::MethodANNBase, TMVA::MethodBayesClassifier, TMVA::MethodBDT, TMVA::MethodBoost, TMVA::MethodCategory, TMVA::MethodCFMlpANN, TMVA::MethodCompositeBase, TMVA::MethodCrossValidation, TMVA::MethodCuts, TMVA::MethodDL, TMVA::MethodDNN, TMVA::MethodDT, TMVA::MethodFDA, TMVA::MethodFisher, TMVA::MethodHMatrix, TMVA::MethodKNN, TMVA::MethodLD, TMVA::MethodLikelihood, TMVA::MethodMLP, TMVA::MethodPDEFoam, TMVA::MethodPDERS, TMVA::MethodRuleFit, TMVA::MethodSVM, TMVA::MethodTMlpANN, TMVA::MethodPyKeras, TMVA::MethodPyTorch, TMVA::MethodPyAdaBoost, TMVA::MethodPyGTB, TMVA::MethodPyRandomForest, TMVA::MethodC50, TMVA::MethodRSNNS, TMVA::MethodRSVM, TMVA::MethodRXGB, TMVA::PyMethodBase, TMVA::RMethodBase, and TMVA::MethodCompositeBase. ◆ GetMvaValues(). std::vector< Double_t > TMVA::MethodBase::GetMvaValues ; (; Long64_t ; firstEvt = 0, . Long64_t ; lastEvt = -1, . Bool_t ; logProgress = false . ). protectedvirtual . get all the MVA values for the events of the current Data type ; Reimplemented in TMVA::MethodPyKeras, TMVA::MethodPyTorch, TMVA::MethodDL, TMVA::MethodPyAdaBoost, TMVA::MethodPyGTB, TMVA::MethodPyRandomForest, TMVA::MethodC50, TMVA::MethodRSNNS, TMVA::MethodRSVM, TMVA::MethodRXGB, TMVA::MethodCategory, and TMVA::PyMethodBase.; Definition at line 898 of file MethodBase.cxx. ◆ GetName(). const char * TMVA::MethodBase::GetName ; (; ); const. inlinevirtual . Implements TMVA::IMethod.; Definition at line 334 of file MethodBase.h. ◆ GetNEvents(). UInt_t TMVA::MethodBase::GetNEvents ; (; ); const. inline . Definition at line 416 of file MethodBase.h. ◆ GetNTargets(). UInt_t TMVA::MethodBase::GetNTargets ; (; ); const. inline . Definition at line 346 of file MethodBase.h. ◆ GetNvar(). UInt_t TMVA::MethodBase::GetNvar ; (; ); const. inline . Definition at line 344 of file MethodBase.h. ◆ GetNVariables(). UInt_t TMVA::MethodBase::GetNVariables ; (; ); const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBase.html:50834,log,logProgress,50834,doc/master/classTMVA_1_1MethodBase.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBase.html,1,['log'],['logProgress']
Testability,"rray of Z planes positions. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ClearThreadData() const. void CreateThreadData(Int_t nthreads); Create thread data for n threads max. TGeoPgon(); dummy ctor. TGeoPgon(Double_t phi, Double_t dphi, Int_t nedges, Int_t nz); Default constructor. TGeoPgon(const char* name, Double_t phi, Double_t dphi, Int_t nedges, Int_t nz); Default constructor. TGeoPgon(Double_t* params); Default constructor in GEANT3 style; param[0] = phi1; param[1] = dphi; param[2] = nedges; param[3] = nz. param[4] = z1; param[5] = Rmin1; param[6] = Rmax1. ~TGeoPgon(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a polygone; Check if the sections are in increasing Z order. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this shape; check total z range. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the polygone; first find out in which Z section the point is in. void LocatePhi(const Double_t* point, Int_t& ipsec) const; Locates index IPSEC of the phi sector containing POINT. Int_t GetPhiCrossList(const Double_t* point, const Double_t* dir, Int_t istart, Double_t* sphi, Int_t* iphi, Double_t stepmax = TGeoShape::Big()) const; Returns lists of PGON phi crossings for a ray starting from POINT. Bool_t SliceCrossingInZ(const Double_t* point, const Double_t* dir, Int_t nphi, Int_t* iphi, Double_t* sphi, Double_t& snext, Double_t stepmax) const; Performs ray propagation between Z segments. Bool_t SliceCrossingZ(const Double_t* point, const Double_t* dir, Int_t nphi, Int_t* iphi, Double_t* sphi, Double_t& snext, Double_t stepmax) const; Performs ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoPgon.html:17945,test,test,17945,root/html602/TGeoPgon.html,https://root.cern,https://root.cern/root/html602/TGeoPgon.html,2,['test'],['test']
Testability,"rrent directory.Definition TTree.cxx:9753; ROOT::VecOps::cosRVec< PromoteType< T > > cos(const RVec< T > &v)Definition RVec.hxx:1852; ROOT::VecOps::acosRVec< PromoteType< T > > acos(const RVec< T > &v)Definition RVec.hxx:1855; ROOT::VecOps::sinRVec< PromoteType< T > > sin(const RVec< T > &v)Definition RVec.hxx:1851; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; TMVA_SOFIE_GNN_Parser.tmptmpDefinition TMVA_SOFIE_GNN_Parser.py:196; TMVA_SOFIE_GNN_Parser.treetreeDefinition TMVA_SOFIE_GNN_Parser.py:169; TMath::GausDouble_t Gaus(Double_t x, Double_t mean=0, Double_t sigma=1, Bool_t norm=kFALSE)Calculates a gaussian function with mean and sigma.Definition TMath.cxx:471; TMath::NintInt_t Nint(T x)Round to nearest integer. Rounds half integers to the nearest even integer.Definition TMath.h:693; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::DegToRadconstexpr Double_t DegToRad()Conversion from degree to radian: .Definition TMath.h:79; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::SinDouble_t Sin(Double_t)Returns the sine of an angle of x radians.Definition TMath.h:588; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; v@ vDefinition rootcling_impl.cxx:3699; mTMarker mDefinition textangle.C:8; lTLine lDefinition textangle.C:4; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345; AuthorAndreas Hoecker ; Definition in file createData.C. tutorialstmvacreateData.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/createData_8C.html:65548,log,logarithm,65548,doc/master/createData_8C.html,https://root.cern,https://root.cern/doc/master/createData_8C.html,1,['log'],['logarithm']
Testability,"rresponding to the ""final"" choice of tau; Recommendation: always check logTauCurvature, it should be a peaked function (similar to a Gaussian), the maximum corresponding to the final choice of tau. Also, check the lCurve it should be approximately L-shaped. If in doubt, adjust tauMin and tauMax until the results are satisfactory. ; Definition at line 2558 of file TUnfold.cxx. ◆ ScanSURE(). Int_t TUnfold::ScanSURE ; (; Int_t ; nPoint, . Double_t ; tauMin, . Double_t ; tauMax, . TGraph ** ; logTauSURE = nullptr, . TGraph ** ; df_chi2A = nullptr, . TGraph ** ; lCurve = nullptr . ). virtual . minimize Stein's unbiased risk estimator ""SURE"" using successive calls to DoUnfold at various tau. ; Optionally, also the L-curve and its curvature are calculated for comparison. See description of GetSURE() See e.g. arXiv:1612.09415 for the definition of SURE; Parameters. [in]nPoint: number of points ; [in]tauMin: lower end of scan-range ; [in]tauMax: upper end of scan-range ; [out]logTauSURE: scan result, SURE as a function of log(tau) ; [out]df_chi2A: parametric plot of DF against chi2A ; [out]lCurve: parametric plot (lCurve). return value: index of the ""best"" point; if tauMin is less than zero of if tauMin is not loer than tauMax, then the scan range is determined automatically if tau=nullptr is included in the scan, then the first x-coordinate ; Definition at line 3785 of file TUnfold.cxx. ◆ SetBias(). void TUnfold::SetBias ; (; const TH1 * ; bias). set bias vector ; Parameters. [in]biashistogram with new bias vector. the initial bias vector is determined from the response matrix but may be changed by using this method ; Definition at line 1895 of file TUnfold.cxx. ◆ SetConstraint(). void TUnfold::SetConstraint ; (; EConstraint ; constraint). set type of area constraint ; results of a previous unfolding are reset ; Definition at line 3211 of file TUnfold.cxx. ◆ SetEpsMatrix(). void TUnfold::SetEpsMatrix ; (; Double_t ; eps). set numerical accuracy for Eigenvalue analysis when ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfold.html:56325,log,logTauSURE,56325,doc/master/classTUnfold.html,https://root.cern,https://root.cern/doc/master/classTUnfold.html,2,['log'],"['log', 'logTauSURE']"
Testability,"rride this function. ; Definition at line 440 of file TQCommand.cxx. ◆ IsUndoing(). Bool_t TQCommand::IsUndoing ; (; ); const. Undo action is in progress. ; Definition at line 808 of file TQCommand.cxx. ◆ ls(). void TQCommand::ls ; (; Option_t * ; option = """"); const. overridevirtual . ls this command and merged commands ; Reimplemented from TCollection.; Reimplemented in TQUndoManager.; Definition at line 848 of file TQCommand.cxx. ◆ Merge() [1/2]. Long64_t TQCommand::Merge ; (; TCollection * ; collection, . TFileMergeInfo * ;  . ). virtual . Merge a collection of TQCommand. ; Definition at line 337 of file TQCommand.cxx. ◆ Merge() [2/2]. void TQCommand::Merge ; (; TQCommand * ; c). virtual . Add command to the list of merged commands. ; This make it possible to group complex actions together so an end user can undo and redo them with one command. Execution of TQUndoManager::Undo(), TQUndoManager::Redo() methods only invokes the top level command as a whole.; Merge method is analogous to logical join operation.; Note: Merge method invokes redo action. ; Definition at line 329 of file TQCommand.cxx. ◆ operator=(). TQCommand & TQCommand::operator= ; (; const TQCommand & ; ). private . ◆ PrintCollectionHeader(). void TQCommand::PrintCollectionHeader ; (; Option_t * ; option); const. overrideprotectedvirtual . Print collection header. ; Reimplemented from TCollection.; Definition at line 864 of file TQCommand.cxx. ◆ Redo(). void TQCommand::Redo ; (; Option_t * ; option = """"). virtual . Execute command and then merge commands. ; Reimplemented in TQUndoManager.; Definition at line 588 of file TQCommand.cxx. ◆ SetArgs(). void TQCommand::SetArgs ; (; Int_t ; narg, .  ; ... . ). virtual . Set do/redo and undo parameters. ; The format is SetArgs(number_of_params, redo_params, undo_params); Example: move_command->SetArgs(2, 100, 100, 200, 200);; 2 params, (100,100) - do/redo position, (200,200) - undo position ; Definition at line 465 of file TQCommand.cxx. ◆ SetName(). void ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:41886,log,logical,41886,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['log'],['logical']
Testability,"rror = trainCycle (minimizer, weights, begin (trainPattern), end (trainPattern), settings, dropContainer);; 772 ; 773 ; 774 // ------ check if we have to execute a test ------------------; 775 bool hasConverged = false;; 776 if (testCycleCount % settings.testRepetitions () == 0) // we test only everye ""testRepetitions"" repetition; 777 {; 778 if (isWeightsForDrop); 779 {; 780 dropOutWeightFactor (weights, dropFractions);; 781 isWeightsForDrop = false;; 782 }; 783 ; 784 ; 785 testError = 0;; 786 //double weightSum = 0;; 787 settings.startTestCycle ();; 788 if (settings.useMultithreading ()); 789 {; 790 size_t numThreads = std::thread::hardware_concurrency ();; 791 size_t patternPerThread = testPattern.size () / numThreads;; 792 std::vector<Batch> batches;; 793 auto itPat = testPattern.begin ();; 794 // auto itPatEnd = testPattern.end ();; 795 for (size_t idxThread = 0; idxThread < numThreads-1; ++idxThread); 796 {; 797 batches.push_back (Batch (itPat, itPat + patternPerThread));; 798 itPat += patternPerThread;; 799 }; 800 if (itPat != testPattern.end ()); 801 batches.push_back (Batch (itPat, testPattern.end ()));; 802 ; 803 std::vector<std::future<std::tuple<double,std::vector<double>>>> futures;; 804 for (auto& batch : batches); 805 {; 806 // -------------------- execute each of the batch ranges on a different thread -------------------------------; 807 futures.push_back (; 808 std::async (std::launch::async, [&](); 809 {; 810 std::vector<double> localOutput;; 811 pass_through_type passThrough (settings, batch, dropContainerTest);; 812 double testBatchError = (*this) (passThrough, weights, ModeOutput::FETCH, localOutput);; 813 return std::make_tuple (testBatchError, localOutput);; 814 }); 815 );; 816 }; 817 ; 818 auto itBatch = batches.begin ();; 819 for (auto& f : futures); 820 {; 821 std::tuple<double,std::vector<double>> result = f.get ();; 822 testError += std::get<0>(result) / batches.size ();; 823 std::vector<double> output = std::get<1>(result);; 824 if (outpu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8icc_source.html:23883,test,testPattern,23883,doc/master/NeuralNet_8icc_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8icc_source.html,1,['test'],['testPattern']
Testability,"rror == fErrorType );; 330 ; 331 if ( fErrorType == kNoError ); 332 {; 333 assert( !fDataErrorPtr && !fDataErrorHighPtr && !fDataErrorLowPtr );; 334 assert( fDataError.empty() && fDataErrorHigh.empty() && fDataErrorLow.empty() );; 335 return 1.0;; 336 }; 337 ; 338 if ( fErrorType == kValueError ) // need to invert (inverror is stored); 339 {; 340 assert( fDataErrorPtr && !fDataErrorHighPtr && !fDataErrorLowPtr );; 341 assert( fDataErrorHigh.empty() && fDataErrorLow.empty() );; 342 assert( fDataError.empty() || &fDataError.front() == fDataErrorPtr );; 343 ; 344 double eval = fDataErrorPtr[ ipoint ];; 345 ; 346 // in case of wrapped data the pointer stores the error and; 347 // not the inverse; 348 if (fWrapped); 349 return 1.0 / eval;; 350 else; 351 return (eval != 0.0) ? eval : 0.0;; 352 }; 353 ; 354 if ( fErrorType == kAsymError ) {; 355 // return inverse of 1/2(el + eh); 356 assert( !fDataErrorPtr && fDataErrorHighPtr && fDataErrorLowPtr );; 357 assert( fDataError.empty() );; 358 assert( fDataErrorHigh.empty() || &fDataErrorHigh.front() == fDataErrorHighPtr );; 359 assert( fDataErrorLow.empty() || &fDataErrorLow.front() == fDataErrorLowPtr );; 360 assert( fDataErrorLow.empty() == fDataErrorHigh.empty() );; 361 ; 362 double eh = fDataErrorHighPtr[ ipoint ];; 363 double el = fDataErrorLowPtr[ ipoint ];; 364 ; 365 return 2.0 / (el+eh);; 366 }; 367 ; 368 assert( fErrorType == kCoordError );; 369 // for coordinate error we store the error and not the inverse; 370 return 1.0 / fDataErrorPtr[ ipoint ];; 371 }; 372 ; 373 ; 374 /**; 375 retrieve at the same time a pointer to the coordinate data and the fit value; 376 More efficient than calling Coords(i) and Value(i); 377 */; 378 // not threadsafe, to be replaced with never constructs!; 379 // for example: just return std::array or std::vector, there's; 380 // is going to be only minor overhead in c++11.; 381 const double * GetPoint( unsigned int ipoint, double & value ) const; 382 {; 383 assert( ipoint < fMaxPoints );; 384",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8h_source.html:12521,assert,assert,12521,doc/master/BinData_8h_source.html,https://root.cern,https://root.cern/doc/master/BinData_8h_source.html,1,['assert'],['assert']
Testability,"rror == fErrorType || kNoError == fErrorType );; 267 ; 268 if ( fErrorType == kNoError ); 269 {; 270 assert( !fDataErrorPtr && !fDataErrorHighPtr && !fDataErrorLowPtr );; 271 assert( fDataError.empty() && fDataErrorHigh.empty() && fDataErrorLow.empty() );; 272 return 1.0;; 273 }; 274 ; 275 if ( fErrorType == kValueError ) // need to invert (inverror is stored); 276 {; 277 assert( fDataErrorPtr && !fDataErrorHighPtr && !fDataErrorLowPtr );; 278 assert( fDataErrorHigh.empty() && fDataErrorLow.empty() );; 279 assert( fDataError.empty() || &fDataError.front() == fDataErrorPtr );; 280 ; 281 double eval = fDataErrorPtr[ ipoint ];; 282 ; 283 if (fWrapped); 284 return eval;; 285 else; 286 return (eval != 0.0) ? 1.0/eval : 0.0;; 287 }; 288 ; 289 if ( fErrorType == kAsymError ); 290 { // return 1/2(el + eh); 291 assert( !fDataErrorPtr && fDataErrorHighPtr && fDataErrorLowPtr );; 292 assert( fDataError.empty() );; 293 assert( fDataErrorHigh.empty() || &fDataErrorHigh.front() == fDataErrorHighPtr );; 294 assert( fDataErrorLow.empty() || &fDataErrorLow.front() == fDataErrorLowPtr );; 295 assert( fDataErrorLow.empty() == fDataErrorHigh.empty() );; 296 ; 297 double eh = fDataErrorHighPtr[ ipoint ];; 298 double el = fDataErrorLowPtr[ ipoint ];; 299 ; 300 return (el+eh) / 2.0;; 301 }; 302 ; 303 assert( fErrorType == kCoordError );; 304 return fDataErrorPtr[ ipoint ];; 305 }; 306 ; 307 void GetAsymError( unsigned int ipoint, double& lowError, double& highError ) const; 308 {; 309 assert( fErrorType == kAsymError );; 310 assert( !fDataErrorPtr && fDataErrorHighPtr && fDataErrorLowPtr );; 311 assert( fDataError.empty() );; 312 assert( fDataErrorHigh.empty() || &fDataErrorHigh.front() == fDataErrorHighPtr );; 313 assert( fDataErrorLow.empty() || &fDataErrorLow.front() == fDataErrorLowPtr );; 314 assert( fDataErrorLow.empty() == fDataErrorHigh.empty() );; 315 ; 316 lowError = fDataErrorLowPtr[ ipoint ];; 317 highError = fDataErrorHighPtr[ ipoint ];; 318 }; 319 ; 320 /**; 321 Return the in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8h_source.html:10129,assert,assert,10129,doc/master/BinData_8h_source.html,https://root.cern,https://root.cern/doc/master/BinData_8h_source.html,1,['assert'],['assert']
Testability,"rror(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TMVA::MsgLogger&Log() const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfAbsTolabsolute tolerance deviation; Double_t (*)(Double_t)fGetRootVal; TMVA::MsgLogger*fLogger! message logger; Int_tfMaxItermaximum number of iterations; Double_tfRootMaxmaximum root value; Double_tfRootMinminimum root value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RootFinder(Double_t (*)(Double_t) rootVal, Double_t rootMin, Double_t rootMax, Int_t maxIterations = 100, Double_t absTolerance = 0.0); constructor. ~RootFinder( void ); destructor. Double_t Root(Double_t refValue); Root finding using Brents algorithm; taken from CERNLIB function RZERO. RootFinder(Double_t (*)(Double_t) rootVal, Double_t rootMin, Double_t rootMax, Int_t maxIterations = 100, Double_t absTolerance = 0.0). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: RootFinder.h 29195 2009-06-24 10:39:49Z brun $ » Last generated: 2010-09-23 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__RootFinder.html:5361,log,logger,5361,root/html528/TMVA__RootFinder.html,https://root.cern,https://root.cern/root/html528/TMVA__RootFinder.html,1,['log'],['logger']
Testability,"rror;  CPlotOpt;  CRooAbsRealLValueRooAbsRealLValue is the common abstract base class for objects that represent a real value that may appear on the left hand side of an equation ('lvalue') ;  CRooAbsRootFinderRooAbsRootFinder is the abstract interface for finding roots of real-valued 1-dimensional function that implements the RooAbsFunc interface ;  CRooAbsSelfCachedPdfRooAbsSelfCachedPdf is an abstract base class for probability density functions whose output is cached in terms of a histogram in all observables between getVal() and evaluate() ;  CRooAbsSelfCachedRealRooAbsSelfCachedReal is an abstract base class for functions whose output is cached in terms of a histogram in all observables between getVal() and evaluate() ;  CRooAbsStringRooAbsString is the common abstract base class for objects that represent a string value ;  CRooAbsStudyRooAbsStudy is an abstract base class for RooStudyManager modules ;  CRooAbsTestStatisticRooAbsTestStatistic is the abstract base class for all test statistics ;  CRooAcceptRejectClass RooAcceptReject is a generic toy monte carlo generator implement the accept/reject sampling technique on any positively valued function ;  CRooAdaptiveGaussKronrodIntegrator1DRooAdaptiveGaussKronrodIntegrator1D implements the Gauss-Kronrod integration algorithm ;  CRooAdaptiveIntegratorNDRooAdaptiveIntegratorND implements an adaptive one-dimensional numerical integration algorithm ;  CRooAddGenContextRooAddGenContext is an efficient implementation of the generator context specific for RooAddPdf PDFs ;  ►CRooAdditionRooAddition calculates the sum of a set of RooAbsReal terms, or when constructed with two sets, it sums the product of the terms in the two sets ;  CCacheElemIterator over set ;  ►CRooAddModel;  CCacheElemTransiet cache with transformed values of coefficients ;  CIntCacheElem;  ►CRooAddPdfRooAddPdf is an efficient implementation of a sum of PDFs of the form ;  CCacheElemTransiet cache with transformed values of coefficients ;  CRooAICReg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:102985,test,test,102985,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['test'],['test']
Testability,"rrorType ||; 747 kAsymError == fErrorType || kNoError == fErrorType );; 748 assert( fDataError.empty() || &fDataError.front() == fDataErrorPtr );; 749 assert( fDataErrorHigh.empty() || &fDataErrorHigh.front() == fDataErrorHighPtr );; 750 assert( fDataErrorLow.empty() || &fDataErrorLow.front() == fDataErrorLowPtr );; 751 assert( fDataErrorLow.empty() == fDataErrorHigh.empty() );; 752 ; 753 assert( fData.empty() );; 754 assert( fDataPtr );; 755 ; 756 unsigned vectorPadding = FitData::VectorPadding(fNPoints);; 757 fData.resize(fNPoints + vectorPadding);; 758 std::copy( fDataPtr, fDataPtr + fNPoints, fData.begin() );; 759 fDataPtr = fData.empty() ? nullptr : &fData.front();; 760 ; 761 for ( unsigned int i=0; i < fDim; i++ ); 762 {; 763 assert( fCoordErrorsPtr[i] );; 764 assert( fCoordErrors.empty() || &fCoordErrors[i].front() == fCoordErrorsPtr[i] );; 765 }; 766 ; 767 if( kValueError == fErrorType || kCoordError == fErrorType ); 768 {; 769 assert( fDataError.empty() );; 770 assert( fDataErrorPtr );; 771 ; 772 fDataError.resize(fNPoints + vectorPadding);; 773 std::copy(fDataErrorPtr, fDataErrorPtr + fNPoints + vectorPadding, fDataError.begin());; 774 fDataErrorPtr = fDataError.empty() ? nullptr : &fDataError.front();; 775 }; 776 ; 777 if ( kValueError == fErrorType ); 778 {; 779 for ( unsigned int i=0; i < fNPoints; i++ ); 780 {; 781 fDataError[i] = 1.0 / fDataError[i];; 782 }; 783 }; 784 ; 785 if ( kCoordError == fErrorType || kAsymError == fErrorType ); 786 {; 787 fCoordErrors.resize( fDim );; 788 for( unsigned int i=0; i < fDim; i++ ); 789 {; 790 assert( fCoordErrorsPtr[i] );; 791 fCoordErrors[i].resize(fNPoints + vectorPadding);; 792 std::copy(fCoordErrorsPtr[i], fCoordErrorsPtr[i] + fNPoints + vectorPadding, fCoordErrors[i].begin());; 793 fCoordErrorsPtr[i] = fCoordErrors[i].empty() ? nullptr : &fCoordErrors[i].front();; 794 }; 795 ; 796 if( kAsymError == fErrorType ); 797 {; 798 assert( fDataErrorHigh.empty() );; 799 assert( fDataErrorLow.empty() );; 800 assert( fDa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:23574,assert,assert,23574,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['assert'],['assert']
Testability,rrors in coordinates and value (e.g from TGraphErrors) returns a; 243 pointer to the corresponding value error (NOT the inverse).; 244 - If the data contains asymmetric errors return a pointer to the average error (NOT the inverse):; 245 0.5(eu + el).; 246 - If the data does not contain errors return a nullptr.; 247 */; 248 ; 249 const double * ErrorPtr(unsigned int ipoint) const{; 250 assert( ipoint < fMaxPoints );; 251 assert( kValueError == fErrorType || kCoordError == fErrorType ||; 252 kAsymError == fErrorType || kNoError == fErrorType );; 253 ; 254 if ( fErrorType == kNoError ); 255 return nullptr;; 256 return &fDataErrorPtr[ ipoint ];; 257 }; 258 ; 259 /// Return the error on the given point.; 260 /// Safer method returning in any case the error and not the inverse as in the; 261 /// function above.; 262 double Error( unsigned int ipoint ) const; 263 {; 264 assert( ipoint < fMaxPoints );; 265 assert( kValueError == fErrorType || kCoordError == fErrorType ||; 266 kAsymError == fErrorType || kNoError == fErrorType );; 267 ; 268 if ( fErrorType == kNoError ); 269 {; 270 assert( !fDataErrorPtr && !fDataErrorHighPtr && !fDataErrorLowPtr );; 271 assert( fDataError.empty() && fDataErrorHigh.empty() && fDataErrorLow.empty() );; 272 return 1.0;; 273 }; 274 ; 275 if ( fErrorType == kValueError ) // need to invert (inverror is stored); 276 {; 277 assert( fDataErrorPtr && !fDataErrorHighPtr && !fDataErrorLowPtr );; 278 assert( fDataErrorHigh.empty() && fDataErrorLow.empty() );; 279 assert( fDataError.empty() || &fDataError.front() == fDataErrorPtr );; 280 ; 281 double eval = fDataErrorPtr[ ipoint ];; 282 ; 283 if (fWrapped); 284 return eval;; 285 else; 286 return (eval != 0.0) ? 1.0/eval : 0.0;; 287 }; 288 ; 289 if ( fErrorType == kAsymError ); 290 { // return 1/2(el + eh); 291 assert( !fDataErrorPtr && fDataErrorHighPtr && fDataErrorLowPtr );; 292 assert( fDataError.empty() );; 293 assert( fDataErrorHigh.empty() || &fDataErrorHigh.front() == fDataErrorHighPtr );; 294 ass,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8h_source.html:9008,assert,assert,9008,doc/master/BinData_8h_source.html,https://root.cern,https://root.cern/doc/master/BinData_8h_source.html,4,['assert'],['assert']
Testability,"rrors method. ;  ; void CheckGeometry (Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const;  Shoot nrays with random directions from starting point (startx, starty, startz) in the reference frame of this volume. ;  ; void CheckGeometryFull (Bool_t checkoverlaps=kTRUE, Bool_t checkcrossings=kTRUE, Int_t nrays=10000, const Double_t *vertex=nullptr);  Geometry checking. ;  ; void CheckOverlaps (const TGeoVolume *vol, Double_t ovlp=0.1, Option_t *option="""");  Check illegal overlaps for volume VOL within a limit OVLP. ;  ; void CheckOverlapsBySampling (TGeoVolume *vol, Double_t ovlp=0.1, Int_t npoints=1000000) const;  Check illegal overlaps for volume VOL within a limit OVLP by sampling npoints inside the volume shape. ;  ; void CheckPoint (Double_t x=0, Double_t y=0, Double_t z=0, Option_t *option="""", Double_t safety=0.);  Draw point (x,y,z) over the picture of the daughters of the volume containing this point. ;  ; void CheckShape (TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option);  Test for shape navigation methods. ;  ; Double_t CheckVoxels (TGeoVolume *vol, TGeoVoxelFinder *voxels, Double_t *xyz, Int_t npoints);  count voxel timing ;  ; TClass * IsA () const override;  ; TH2F * LegoPlot (Int_t ntheta=60, Double_t themin=0., Double_t themax=180., Int_t nphi=90, Double_t phimin=0., Double_t phimax=360., Double_t rmin=0., Double_t rmax=9999999, Option_t *option="""");  Generate a lego plot fot the top volume, according to option. ;  ; TGeoOverlap * MakeCheckOverlap (const char *name, TGeoVolume *vol1, TGeoVolume *vol2, TGeoMatrix *mat1, TGeoMatrix *mat2, Bool_t isovlp, Double_t ovlp);  Check if the 2 non-assembly volume candidates overlap/extrude. Returns overlap object. ;  ; void OpProgress (const char *opname, Long64_t current, Long64_t size, TStopwatch *watch=nullptr, Bool_t last=kFALSE, Bool_t refresh=kFALSE, const char *msg="""");  Print current operation progress. ;  ; void PrintOverlaps () const;  Print the current list of overlaps h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoChecker.html:3962,test,testNo,3962,doc/master/classTGeoChecker.html,https://root.cern,https://root.cern/doc/master/classTGeoChecker.html,1,['test'],['testNo']
Testability,"rrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual RooAbsArg&RooAbsRealLValue::operator=(const RooAbsReal& other); virtual RooAbsArg&RooAbsRealLValue::operator=(Double_t newValue); virtual RooAbsArg&RooAbsRealLValue::operator=(Int_t ival); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooErrorVar.html:21607,test,testArg,21607,root/html526/RooErrorVar.html,https://root.cern,https://root.cern/root/html526/RooErrorVar.html,6,['test'],['testArg']
Testability,"rs From TH2D ;  cumulative.C Illustrate use of the TH1::GetCumulative method ;  draw2dopt.C Display the various 2-d drawing options ;  DynamicSlice.C Show the slice of a TH2 following the mouse position ;  exec1.CEcho object at mouse position ;  exec2.CEcho object at mouse position and show a graphics line ;  Fibonacci.C A TH2Poly build with Fibonacci numbers ;  fillrandom.C Fill a 1-D histogram from a parametric function ;  FirstContour.C Make a contour plot and get the first contour in a TPolyMarker ;  greyscale.C Create grey scale of 200 x 200 boxes ;  h1draw.C 1-D histogram drawing options ;  hbars.C Example of bar charts with 1-d histograms ;  hksimple.C Illustrates the advantages of a TH1K histogram ;  hlabels1.C 1-D histograms with alphanumeric labels ;  hlabels2.C 2-D histograms with alphanumeric labels ;  hstack.C Example of stacked histograms: class THStack ;  hsum.C Histograms filled and drawn in a loop ;  hsumTimer.C Demo of Timers ;  logscales.C Draw parametric functions with log scales ;  multicolor.C Use a THStack to show a 2-D hist with cells with different colors ;  ratioplot1.C Example creating a simple ratio plot of two histograms using the pois division option ;  ratioplot2.C Example of a fit residual plot ;  ratioplot3.C Example which shows how you can get the graph of the lower plot and set the y axis range for it ;  ratioplot4.C Example that shows custom dashed lines on the lower plot, specified by a vector of floats ;  ratioplot5.C Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors ;  ratioplot6.C Example showing a fit residual plot, where the separation margin has been set to 0 ;  ratioplotOld.CExample displaying two histograms and their ratio ;  rebin.C Rebin a variable bin-width histogram ;  reverseaxis.C Example showing an histogram with reverse axis ;  sparsehist.CEvaluate the performance of THnSparse vs TH1/2/3/nF for different numbers of dimensions ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:122801,log,log,122801,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,1,['log'],['log']
Testability,"rs in other groups, and on the analysis; of historical logging data (i.e. usage of CPU by the group in a; previous time slot, as recorded in TPerfStats::WriteQueryLog()). Currently the group priority is obtained by a query in a SQL DB; table proofpriority, which has the format:; CREATE TABLE proofpriority (; id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,; group VARCHAR(32) NOT NULL,; priority INT; ). Int_t SendAsynMessage(const char* msg, Bool_t lf = kTRUE); Send an asychronous message to the master / client .; Masters will forward up the message to the client.; The client prints 'msg' of stderr and adds a '\n'/'\r' depending on; 'lf' being kTRUE (default) or kFALSE.; Returns the return value from TSocket::Send(TMessage &) . void FlushLogFile(); Reposition the read pointer in the log file to the very end.; This allows to ""hide"" useful debug messages during normal operations; while preserving the possibility to have them in case of problems. void TruncateLogFile(); Truncate the log file to the 80% of the required max size if this; is set. void HandleException(Int_t sig); Exception handler: we do not try to recover here, just exit. Int_t HandleDataSets(TMessage* mess, TString* slb = 0); Handle here requests about datasets. void HandleSubmerger(TMessage* mess); Handle a message of type kPROOF_SUBMERGER. void HandleFork(TMessage* mess); Cloning itself via fork. Not implemented. Int_t Fork(); Fork a child.; If successful, return 0 in the child process and the child pid in the parent; process. The child pid is registered for reaping.; Return <0 in the parent process in case of failure. void ResolveKeywords(TString& fname, const char* path = 0); Replace <ord>, <user>, <u>, <group>, <stag>, <qnum> and <file> placeholders in fname. Int_t GetSessionStatus(); Return the status of this session:; 0 idle; 1 running; 2 being terminated (currently unused); 3 queued; 4 idle timed-out (not set in here but in TIdleTOTimer::Notify); This is typically run in the reader thread, so access nee",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofServ.html:29016,log,log,29016,root/html530/TProofServ.html,https://root.cern,https://root.cern/root/html530/TProofServ.html,2,['log'],['log']
Testability,"rs in other groups, and on the analysis; of historical logging data (i.e. usage of CPU by the group in a; previous time slot, as recorded in TPerfStats::WriteQueryLog()). Currently the group priority is obtained by a query in a SQL DB; table proofpriority, which has the format:; CREATE TABLE proofpriority (; id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,; group VARCHAR(32) NOT NULL,; priority INT; ). Int_t SendAsynMessage(const char* msg, Bool_t lf = kTRUE); Send an asychronous message to the master / client .; Masters will forward up the message to the client.; The client prints 'msg' of stderr and adds a '\n'/'\r' depending on; 'lf' being kTRUE (default) or kFALSE.; Returns the return value from TSocket::Send(TMessage &) . void FlushLogFile(); Reposition the read pointer in the log file to the very end.; This allows to ""hide"" useful debug messages during normal operations; while preserving the possibility to have them in case of problems. void TruncateLogFile(); Truncate the log file to the 80% of the required max size if this; is set. void HandleException(Int_t sig); Exception handler: we do not try to recover here, just exit. Int_t HandleDataSets(TMessage* mess, TString* slb = 0); Handle here requests about datasets. void HandleSubmerger(TMessage* mess); Handle a message of type kPROOF_SUBMERGER. void HandleFork(TMessage* mess); Cloning itself via fork. Not implemented. Int_t Fork(); Fork a child.; If successful, return 0 in the child process and the child pid in the parent; process. The child pid is registered for reaping.; Return <0 in the parent process in case of failure. void ResolveKeywords(TString& fname, const char* path = 0); Replace <ord>, <user>, <u>, <group>, <stag>, <qnum>, <file>, <rver> and; <build> placeholders in fname.; Here, <rver> is the root version in integer form, e.g. 53403, and <build> a; string includign version, architecture and compiler version, e.g.; '53403_linuxx8664gcc_gcc46' . Int_t GetSessionStatus(); Return the status of this sessio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofServ.html:29988,log,log,29988,root/html534/TProofServ.html,https://root.cern,https://root.cern/root/html534/TProofServ.html,3,['log'],['log']
Testability,"rs is apparent from description of one_dim_pic structure. The constants, which can be used for appropriate parameters, are defined in procfunc.h header file.; struct one_dim_pic {. float *source; // spectrum to be displayed. TCanvas *Canvas; // Canvas where the spectrum will be displayed. int size; // size of source spectrum; int xmin; // x-starting channel of spectrum; int xmax; // x-end channel of spectrum; int ymin; // base counts; int ymax; // count full scale. int bx1; // position of picture on Canvas, min x; int bx2; // position of picture on Canvas, max x; int by1; // position of picture on Canvas, min y; int by2; // position of picture on Canvas, max y. int display_mode; // spectrum display mode (points, polyline, bars, rainbow, steps, bezier); int y_scale; // y scale (linear, log, sqrt); int levels; // # of color levels for rainbow display mode, it does not apply; // for other display modes; float rainbow1_step; // determines the first color component step for neighboring; // color levels, applies only for rainbow display mode; float rainbow2_step; // determines the second component color step for; // neighboring color levels, applies only for rainbow display mode; float rainbow3_step; // determines the third component color step for; // neighboring color levels, applies only for rainbow display mode. int color_alg; // applies only for rainbow display mode (rgb smooth algorithm, rgb; // modulo color component, cmy smooth algorithm, cmy modulo color; // component, cie smooth algorithm, cie modulo color component, yiq; // smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component [15]. int bar_thickness; // applies only for bar display mode; int bar_empty_flag; // (empty bars, full bars) applies only for bar display mode; int border_color; // color of background of the picture; int full_border; // decides whether background is painted; int raster_en_dis; // decides whether the axes and rasters are shown; int raster_long",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:67963,log,log,67963,root/htmldoc/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html,1,['log'],['log']
Testability,"rs, do profile; Bool_tfFluctuateDatatell ToyMCSampler to fluctuate number of entries in dataset; Int_tfNbinsnumber of samples per variable; RooArgSetfNuisParamsRooArgSet specifying nuisance parameters for interval; RooArgSetfPOIRooArgSet specifying parameters of interest for interval; RooAbsPdf*fPdfcommon PDF; RooAbsData*fPointsToTestpoints to perform the construction; boolfSaveBeltToFilecontrols use if ConfidenceBelt should be saved to a TFile; Double_tfSizesize of the test (eg. specified rate of Type I error); RooStats::ToyMCSampler*fTestStatSamplerthe test statistic sampler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FeldmanCousins(); default constructor; fWS = new RooWorkspace(""FeldmanCousinsWS"");; fOwnsWorkspace = true;; fDataName = """";; fPdfName = """";. ~FeldmanCousins(); destructor; if(fOwnsWorkspace && fWS) delete fWS;. void SetModel(const RooStats::ModelConfig& ); set the model. void CreateTestStatSampler() const; specify the Test Statistic and create a ToyMC test statistic sampler. void CreateParameterPoints() const; specify the parameter points to perform the construction.; allow ability to profile on some nuisance paramters. ConfInterval* GetInterval() const; Main interface to get a RooStats::ConfInterval.; It constructs a RooStats::PointSetInterval. FeldmanCousins(). Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void SetData(RooAbsData& data); Set the DataSet. { fData = &data; }. void SetPdf(RooAbsPdf& pdf); Set the Pdf. { fPdf = &pdf; }. void SetParameters(const RooArgSet& set); specify the parameters of interest in the interval. { fPOI.removeAll(); fPOI.add(set); }. void SetNuisanceParameters(const RooArgSet& set); specify the nuisance parameters (eg. the rest of the parameters). {fNuisParams.removeAll(); fNuisParams.add(set);}. void SetTestSize(Double_t size); set th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__FeldmanCousins.html:8910,test,test,8910,root/html526/RooStats__FeldmanCousins.html,https://root.cern,https://root.cern/root/html526/RooStats__FeldmanCousins.html,1,['test'],['test']
Testability,"rs. maxProgressfor monitoring and logging (set the current ""progress"" limits for the display of the progress); minProgressminimum value; maxProgressmaximum value . Definition at line 790 of file NeuralNet.h. ◆ startTestCycle(). virtual void TMVA::DNN::Settings::startTestCycle ; (; ). inlinevirtual . callback for monitoring and loggging ; Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 804 of file NeuralNet.h. ◆ startTrainCycle(). virtual void TMVA::DNN::Settings::startTrainCycle ; (; ). inlinevirtual . Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 782 of file NeuralNet.h. ◆ startTraining(). virtual void TMVA::DNN::Settings::startTraining ; (; ). inlinevirtual . Definition at line 795 of file NeuralNet.h. ◆ testIteration(). virtual void TMVA::DNN::Settings::testIteration ; (; ). inlinevirtual . callback for monitoring and loggging ; Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 806 of file NeuralNet.h. ◆ testRepetitions(). size_t TMVA::DNN::Settings::testRepetitions ; (; ); const. inline . how often is the test data tested ; Definition at line 768 of file NeuralNet.h. ◆ testSample(). virtual void TMVA::DNN::Settings::testSample ; (; double ; , . double ; , . double ; , . double ;  . ). inlinevirtual . virtual function to be used for monitoring (callback) ; Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 781 of file NeuralNet.h. ◆ useMultithreading(). bool TMVA::DNN::Settings::useMultithreading ; (; ); const. inline . is multithreading turned on? ; Definition at line 815 of file NeuralNet.h. Member Data Documentation. ◆ count_dE. size_t TMVA::DNN::Settings::count_dE. Definition at line 843 of file NeuralNet.h. ◆ count_E. size_t TMVA::DNN::Settings::count_E. Definition at line 842 of file NeuralNet.h. ◆ count_mb_dE. size_t TMVA::DNN::Settings::count_mb_dE. Definition at line 845 of file NeuralNet.h. ◆ count_mb_E. size_t TMVA::DNN::Settings::count_mb_E. Definition at line ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html:12445,test,testRepetitions,12445,doc/master/classTMVA_1_1DNN_1_1Settings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html,1,['test'],['testRepetitions']
Testability,"rs=0, a Deep Sea palette is used.; if ncolors = 52 and colors=0, a Grey Scale palette is used.; if ncolors = 53 and colors=0, a Dark Body Radiator palette is used.; if ncolors = 54 and colors=0, a two-color hue palette palette is used.(dark blue through neutral gray to bright yellow); if ncolors = 55 and colors=0, a Rain Bow palette is used.; if ncolors = 56 and colors=0, an inverted Dark Body Radiator palette is used.; If ncolors > 0 && colors == 0, the default palette is used with a maximum of ncolors.; The default palette defines:. index 0 to 9 : shades of grey; index 10 to 19 : shades of brown; index 20 to 29 : shades of blue; index 30 to 39 : shades of red; index 40 to 49 : basic colors. The color numbers specified in the palette can be viewed by selecting the item colors in the VIEW menu of the canvas tool bar. The red, green, and blue components of a color can be changed thanks to TColor::SetRGB().; SinceROOT version 6.19/01; As default labels and ticks are drawn by TGAxis at equidistant (lin or log) points as controlled by SetNdivisions. If option ""CJUST"" is given labels and ticks are justified at the color boundaries defined by the contour levels. For more details see TPaletteAxis. Drawing a sub-range of a 2D histogram; the [cutg] option; Using a TCutG object, it is possible to draw a sub-range of a 2D histogram. One must create a graphical cut (mouse or C++) and specify the name of the cut between [] in the Draw() option. For example (fit2a.C), with a TCutG named cutg, one can call: myhist->Draw(""surf1 [cutg]"");; To invert the cut, it is enough to put a - in front of its name: myhist->Draw(""surf1 [-cutg]"");; It is possible to apply several cuts (, means logical AND): myhist->Draw(""surf1 [cutg1,cutg2]"");; ; #include ""TF2.h""; #include ""TH2.h""; #include ""TCutG.h""; #include ""TMath.h""; #include ""TCanvas.h""; #include ""TStyle.h""; ; double g2(double *x, double *par) {; double r1 = double((x[0]-par[1])/par[2]);; double r2 = double((x[1]-par[3])/par[4]);; return par[",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:110782,log,log,110782,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['log'],['log']
Testability,"rsPtr.empty() );; 436 ; 437 fData[ fNPoints ] = y;; 438 fDataError[ fNPoints ] = (ey != 0.0) ? 1.0/ey : 0.0;; 439 ; 440 FitData::Add( x );; 441 fSumContent += y;; 442 if (y != 0 || ey != 1.0) fSumError2 += ey*ey;; 443 // set the weight flag checking if error^2 != y; 444 if (!fIsWeighted); 445 if (y != 0 && std::abs( ey*ey/y - 1.0) > 1.E-12) fIsWeighted = true;; 446 }; 447 ; 448 /**; 449 add one dim data with error in the coordinate (x); 450 in this case store the value (y) error and not the inverse; 451 */; 452 void BinData::Add( double x, double y, double ex, double ey ); 453 {; 454 assert( kCoordError == fErrorType );; 455 assert( !fData.empty() && fDataPtr );; 456 assert( !fDataError.empty() && fDataErrorPtr );; 457 assert( fDataErrorHigh.empty() && !fDataErrorHighPtr );; 458 assert( fDataErrorLow.empty() && !fDataErrorLowPtr );; 459 assert( !fCoordErrors.empty() && fCoordErrors.size() == 1 );; 460 assert( !fCoordErrorsPtr.empty() && fCoordErrorsPtr.size() == 1 && fCoordErrorsPtr[0] );; 461 assert( &fCoordErrors[0].front() == fCoordErrorsPtr[0] );; 462 ; 463 fData[ fNPoints ] = y;; 464 fCoordErrors[0][ fNPoints ] = ex;; 465 fDataError[ fNPoints ] = ey;; 466 ; 467 FitData::Add( x );; 468 fSumContent += y;; 469 if (y != 0 || ey != 1.0) fSumError2 += ey*ey;; 470 // set the weight flag checking if error^2 != y; 471 if (!fIsWeighted); 472 if (y != 0 && std::abs( ey*ey/y - 1.0) > 1.E-12) fIsWeighted = true;; 473 }; 474 ; 475 /**; 476 add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); 477 in this case store the y errors and not the inverse; 478 */; 479 void BinData::Add( double x, double y, double ex, double eyl, double eyh ); 480 {; 481 assert( kAsymError == fErrorType );; 482 assert( !fData.empty() && fDataPtr );; 483 assert( !fDataErrorHigh.empty() && fDataErrorHighPtr );; 484 assert( !fDataErrorLow.empty() && fDataErrorLowPtr );; 485 assert( fDataError.empty() && !fDataErrorPtr );; 486 assert( !fCoordErrors.empty() && fCoordErro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:13749,assert,assert,13749,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['assert'],['assert']
Testability,"rsa). GDML->ROOT; As this binding is integrated into the ROOT installation, you need to enable the use of the binding at the configure point of the ROOT installation. This can be done like so:; ./configure --enable-gdml; On doing this the libraries will be built by issuing the standard ROOT make command. The GDML to TGeo converter uses the TXMLEngine to parse the GDML files. This XML parser is a DOM parser and returns the DOM tree to the class TGDMLParse. This class then interprets the GDML file and adds the bindings in their TGeo equivalent.; The GDML schema is fully supported with a few exceptions:. Replica Volumes are not supported; Loops are not supported; Matrices are not supported. These will hopefully be added in the near future.; Once you have enabled GDML in the configure process for ROOT, to import a GDML file, this can be done using TGeoManager::Import. This automatically calls the right method to parse the GDML by detecting the .gdml file extension. Here is how to do it:; TGeoManager::Import(""test.gdml"");; TGeoManager::Importstatic TGeoManager * Import(const char *filename, const char *name="""", Option_t *option="""")static function Import a geometry from a gdml or ROOT fileDefinition TGeoManager.cxx:4096; Replace test.gdml with the gdml filename you want to import. Once the GDML file has been successfully imported, you can view the geometry by calling:; gGeoManager->GetTopVolume()->Draw(""ogl"");; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TGeoManager::GetTopVolumeTGeoVolume * GetTopVolume() constDefinition TGeoManager.h:512; TGeoVolume::Drawvoid Draw(Option_t *option="""") overridedraw top volume according to optionDefinition TGeoVolume.cxx:1206; For any questions or comments about the GDML->ROOT binding please contact ben.l.nosp@m.loyd.nosp@m.@cern.nosp@m..ch. ROOT->GDML; The TGeo to GDML converter allows to export ROOT geometries (TGeo geometry trees) as GDML files. The writer module writes a GDML file out of the 'in-memory'",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry__gdml.html:1507,test,test,1507,doc/master/group__Geometry__gdml.html,https://root.cern,https://root.cern/doc/master/group__Geometry__gdml.html,1,['test'],['test']
Testability,rse.cxx;  TQpProbBase.cxx;  TQpProbDens.cxx;  TQpProbSparse.cxx;  TQpResidual.cxx;  TQpSolverBase.cxx;  TQpVar.cxx;  ► rtools;  ► inc;  ► Math;  RMinimizer.h;  LinkDef.h;  ► src;  RMinimizer.cxx;  ► smatrix;  ► inc;  ► Math;  BinaryOperators.h;  BinaryOpPolicy.h;  CholeskyDecomp.hHeader file containing the templated implementation of matrix inversion routines for use with ROOT's SMatrix classes (symmetric positive definite case) ;  CramerInversion.icc;  CramerInversionSym.icc;  Dfact.h;  Dfactir.h;  Dfinv.h;  Dinv.h;  Dsfact.h;  Dsinv.h;  Expression.h;  Functions.h;  HelperOps.h;  MatrixFunctions.h;  MatrixInversion.icc;  MatrixRepresentationsStatic.h;  MConfig.h;  SMatrix.h;  SMatrix.icc;  SMatrixDfwd.h;  SMatrixFfwd.h;  StaticCheck.h;  SVector.h;  SVector.icc;  UnaryOperators.h;  LinkDef.h;  LinkDefAll.h;  LinkDefD32.h;  ► src;  Dict.h;  ► test;  kalman.C;  matrix_op.h;  matrix_util.h;  matrixOperations.C;  stressKalman.cxx;  stressOperations.cxx;  testInversion.cxx;  testIO.cxx;  testKalman.cxx;  testOperations.cxx;  testSMatrix.cxx;  TestTimer.h;  Track.h;  TrackLinkDef.h;  ► splot;  ► inc;  LinkDef.h;  TSPlot.h;  ► src;  TSPlot.cxx;  ► unuran;  ► inc;  LinkDef.h;  TUnuran.h;  TUnuranBaseDist.h;  TUnuranContDist.h;  TUnuranDiscrDist.h;  TUnuranEmpDist.h;  TUnuranMultiContDist.h;  TUnuranSampler.h;  ► src;  TUnuran.cxx;  TUnuranContDist.cxx;  TUnuranDiscrDist.cxx;  TUnuranEmpDist.cxx;  TUnuranMultiContDist.cxx;  TUnuranSampler.cxx;  UnuranDistr.h;  UnuranDistrAdapter.h;  UnuranRng.h;  ► test;  unuranDiscrete.cxx;  unuranDistr.cxx;  unuranHist.cxx;  unuranMulti2D.cxx;  unuranMultiDim.cxx;  unuranSimple.cxx;  ► vc;  ► examples;  ► buddhabrot;  main.cpp;  main.h;  ► finitediff;  main.cpp;  ► fit;  GaussFunction.h;  MinimizerTypes.h;  testFitPerf.cxx;  ► genvector;  vectorOperation.cxx;  ► mandelbrot;  main.cpp;  main.h;  mandel.cpp;  mandel.h;  ► matrix;  main.cpp;  ► polarcoord;  main.cpp;  ► smatrix;  matrix_op_vec.h;  matrix_util.h;  testKalman.cxx;  testOperation,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/files.html:57047,test,testKalman,57047,root/html606/files.html,https://root.cern,https://root.cern/root/html606/files.html,1,['test'],['testKalman']
Testability,rse.cxx;  TQpProbBase.cxx;  TQpProbDens.cxx;  TQpProbSparse.cxx;  TQpResidual.cxx;  TQpSolverBase.cxx;  TQpVar.cxx;  ► rtools;  ► inc;  ► Math;  RMinimizer.h;  LinkDef.h;  ► src;  RMinimizer.cxx;  ► smatrix;  ► inc;  ► Math;  BinaryOperators.h;  BinaryOpPolicy.h;  CholeskyDecomp.hHeader file containing the templated implementation of matrix inversion routines for use with ROOT's SMatrix classes (symmetric positive definite case) ;  CramerInversion.icc;  CramerInversionSym.icc;  Dfact.h;  Dfactir.h;  Dfinv.h;  Dinv.h;  Dsfact.h;  Dsinv.h;  Expression.h;  Functions.h;  HelperOps.h;  MatrixFunctions.h;  MatrixInversion.icc;  MatrixRepresentationsStatic.h;  MConfig.h;  SMatrix.h;  SMatrix.icc;  SMatrixDfwd.h;  SMatrixFfwd.h;  StaticCheck.h;  SVector.h;  SVector.icc;  UnaryOperators.h;  LinkDef.h;  LinkDefAll.h;  LinkDefD32.h;  ► src;  Dict.h;  ► test;  kalman.C;  matrix_op.h;  matrix_util.h;  matrixOperations.C;  stressKalman.cxx;  stressOperations.cxx;  testInversion.cxx;  testIO.cxx;  testKalman.cxx;  testOperations.cxx;  testSMatrix.cxx;  TestTimer.h;  Track.h;  TrackLinkDef.h;  ► splot;  ► inc;  LinkDef.h;  TSPlot.h;  ► src;  TSPlot.cxx;  ► unuran;  ► inc;  LinkDef.h;  TUnuran.h;  TUnuranBaseDist.h;  TUnuranContDist.h;  TUnuranDiscrDist.h;  TUnuranEmpDist.h;  TUnuranMultiContDist.h;  TUnuranSampler.h;  ► src;  TUnuran.cxx;  TUnuranContDist.cxx;  TUnuranDiscrDist.cxx;  TUnuranEmpDist.cxx;  TUnuranMultiContDist.cxx;  TUnuranSampler.cxx;  UnuranDistr.h;  UnuranDistrAdapter.h;  UnuranRng.h;  ► test;  unuranDiscrete.cxx;  unuranDistr.cxx;  unuranHist.cxx;  unuranMulti2D.cxx;  unuranMultiDim.cxx;  unuranSimple.cxx;  ► vdt;  ► include;  ► vdt;  asin.h;  atan.h;  atan2.h;  cos.h;  exp.h;  inv.h;  log.h;  sin.h;  sincos.h;  sqrt.h;  tan.h;  vdtcore_common.h;  vdtMath.h;  ► tests;  stressVdt.cxx;  ► misc;  ► memstat;  ► inc;  LinkDef.h;  TMemStat.h;  TMemStatBacktrace.h;  TMemStatDef.h;  TMemStatHelpers.h;  TMemStatHook.h;  TMemStatMng.h;  ► src;  TMemStat.cxx;  TMemStatBacktr,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:57415,test,testKalman,57415,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,1,['test'],['testKalman']
Testability,"rse::MedMapfmedmap!Map containing medium names and the TGeoMedium for it; TGDMLParse::MixMapfmixmap!Map containing mixture names and the TGeoMixture for it; TGDMLParse::PosMapfposmap!Map containing position names and the TGeoTranslation for it; TGDMLParse::ReflectionsMapfreflectmap!Map containing reflection names and the Solid name ir references to; TGDMLParse::ReflSolidMapfreflsolidmap!Map containing reflection names and the TGDMLRefl for it - containing refl matrix; TGDMLParse::ReflVolMapfreflvolmap!Map containing reflected volume names and the solid ref for it; TGDMLParse::RotMapfrotmap!Map containing rotation names and the TGeoRotation for it; TGDMLParse::SclMapfsclmap!Map containing scale names and the TGeoScale for it; TGDMLParse::SolMapfsolmap!Map containing solid names and the TGeoShape for it; TGDMLParse::VolMapfvolmap!Map containing volume names and the TGeoVolume for it. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoVolume* GDMLReadFile(const char* filename = ""test.gdml""); creates the new instance of the XMLEngine called 'gdml', using the filename >>; then parses the file and creates the DOM tree. Then passes the DOM to the; next function to translate it. const char* ParseGDML(TXMLEngine* gdml, XMLNodePointer_t node); this function recursively moves thru the DOM tree of the GDML file. It checks for; key words along the way and if a key word is found it calls the corresponding; function to interpret the node. double Evaluate(const char* evalline). Int_t SetAxis(const char* axisString); When using the 'divide' process in the geometry this function; sets the variable 'axis' depending on what is specified. const char* NameShort(const char* name); this function looks thru a string for the chars '0x' next to; each other, when it finds this, it calls another function to strip; the hex address. It does this recursively until the end of the; string is reached, returning a string without any hex addresses. XMLNodePoin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGDMLParse.html:10550,test,test,10550,root/html602/TGDMLParse.html,https://root.cern,https://root.cern/root/html602/TGDMLParse.html,2,['test'],['test']
Testability,"rsion > 1000) {; 1370 b >> fSeekKey;; 1371 ; 1372 // We currently store in the 16 highest bit of fSeekPdir the value of; 1373 // fPidOffset. This offset is used when a key (or basket) is transfered from one; 1374 // file to the other. In this case the TRef and TObject might have stored a; 1375 // pid index (to retrieve TProcessIDs) which refered to their order on the original; 1376 // file, the fPidOffset is to be added to those values to correctly find the; 1377 // TProcessID. This fPidOffset needs to be increment if the key/basket is copied; 1378 // and need to be zero for new key/basket.; 1379 Long64_t pdir;; 1380 b >> pdir;; 1381 fPidOffset = pdir >> kPidOffsetShift;; 1382 fSeekPdir = pdir & kPidOffsetMask;; 1383 } else {; 1384 UInt_t seekkey, seekdir;; 1385 b >> seekkey; fSeekKey = (Long64_t)seekkey;; 1386 b >> seekdir; fSeekPdir= (Long64_t)seekdir;; 1387 }; 1388 fClassName.Streamer(b);; 1389 //the following test required for forward and backward compatibility; 1390 if (fClassName == ""TDirectory"") {; 1391 fClassName = ""TDirectoryFile"";; 1392 SetBit(kIsDirectoryFile);; 1393 }; 1394 fName.Streamer(b);; 1395 fTitle.Streamer(b);; 1396 if (fKeylen < 0) {; 1397 Error(""Streamer"",""The value of fKeylen is incorrect (%d) ; trying to recover by setting it to zero"",fKeylen);; 1398 MakeZombie();; 1399 fKeylen = 0;; 1400 }; 1401 if (fObjlen < 0) {; 1402 Error(""Streamer"",""The value of fObjlen is incorrect (%d) ; trying to recover by setting it to zero"",fObjlen);; 1403 MakeZombie();; 1404 fObjlen = 0;; 1405 }; 1406 if (fNbytes < 0) {; 1407 Error(""Streamer"",""The value of fNbytes is incorrect (%d) ; trying to recover by setting it to zero"",fNbytes);; 1408 MakeZombie();; 1409 fNbytes = 0;; 1410 }; 1411 ; 1412 } else {; 1413 b << fNbytes;; 1414 version = (Version_t)fVersion;; 1415 b << version;; 1416 b << fObjlen;; 1417 if (fDatime.Get() == 0) fDatime.Set();; 1418 if (TestBit(TKey::kReproducible)); 1419 TDatime((UInt_t) 1).Streamer(b);; 1420 else; 1421 fDatime.Streamer(b);; 1422 b ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TKey_8cxx_source.html:49128,test,test,49128,doc/master/TKey_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html,1,['test'],['test']
Testability,"rspective(). virtual Bool_t TGLCamera::IsPerspective ; (; ); const. inlinevirtual . Reimplemented in TGLPerspectiveCamera.; Definition at line 119 of file TGLCamera.h. ◆ OfInterest(). Bool_t TGLCamera::OfInterest ; (; const TGLBoundingBox & ; box, . Bool_t ; ignoreSize . ); const. Calculate if the an object defined by world frame bounding box is 'of interest' to the camera. ; This is defined as box:. intersecting completely or partially (kInside/kPartial) with cameras interest box (fInterestBox); having significant length OR volume ratio compared to this interest box. If a box is 'of interest' returns kTRUE, kFALSE otherwise. See TGLCamera::UpdateInterest() for more details of camera interest box.; Note: Length/volume ratios NOT dependent on the projected size of box at current camera configuration as we do not want continual changes. This is used when (re) populating the scene with objects from external client.; TODO: Might be more logical to move this test out to client - and have accessor for fInterestBox instead? ; Definition at line 578 of file TGLCamera.cxx. ◆ operator=(). TGLCamera & TGLCamera::operator= ; (; const TGLCamera & ; ). privatedelete . ◆ RefCamBase(). TGLMatrix & TGLCamera::RefCamBase ; (; ). inline . Definition at line 169 of file TGLCamera.h. ◆ RefCamTrans(). TGLMatrix & TGLCamera::RefCamTrans ; (; ). inline . Definition at line 170 of file TGLCamera.h. ◆ RefLastNoPickProjM(). TGLMatrix & TGLCamera::RefLastNoPickProjM ; (; ); const. inline . Definition at line 174 of file TGLCamera.h. ◆ RefModelViewMatrix(). const TGLMatrix & TGLCamera::RefModelViewMatrix ; (; ); const. inline . Definition at line 121 of file TGLCamera.h. ◆ RefViewport() [1/2]. TGLRect & TGLCamera::RefViewport ; (; ). inline . Definition at line 128 of file TGLCamera.h. ◆ RefViewport() [2/2]. const TGLRect & TGLCamera::RefViewport ; (; ); const. inline . Definition at line 129 of file TGLCamera.h. ◆ Reset(). virtual void TGLCamera::Reset ; (; ). pure virtual . Implemented in TGLO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLCamera.html:28206,log,logical,28206,doc/master/classTGLCamera.html,https://root.cern,https://root.cern/doc/master/classTGLCamera.html,2,"['log', 'test']","['logical', 'test']"
Testability,"rst != last ) {; 1067 if ( *w < 0) {; 1068 ::Error(""TMath::Mean"",""w[%d] = %.4e < 0 ?!"",i,*w);; 1069 return 0;; 1070 }; 1071 sum += (*w) * (*first);; 1072 sumw += (*w) ;; 1073 ++w;; 1074 ++first;; 1075 ++i;; 1076 }; 1077 if (sumw <= 0) {; 1078 ::Error(""TMath::Mean"",""sum of weights == 0 ?!"");; 1079 return 0;; 1080 }; 1081 ; 1082 return sum/sumw;; 1083}; 1084 ; 1085////////////////////////////////////////////////////////////////////////////////; 1086/// Returns the weighted mean of an array a with length n.; 1087 ; 1088template <typename T>; 1089Double_t TMath::Mean(Long64_t n, const T *a, const Double_t *w); 1090{; 1091 if (w) {; 1092 return TMath::Mean(a, a+n, w);; 1093 } else {; 1094 return TMath::Mean(a, a+n);; 1095 }; 1096}; 1097 ; 1098////////////////////////////////////////////////////////////////////////////////; 1099/// Returns the geometric mean of an array defined by the iterators.; 1100/// \f[ GeomMean = (\prod_{i=0}^{n-1} |a[i]|)^{1/n} \f]; 1101 ; 1102template <typename Iterator>; 1103Double_t TMath::GeomMean(Iterator first, Iterator last); 1104{; 1105 Double_t logsum = 0.;; 1106 Long64_t n = 0;; 1107 while ( first != last ) {; 1108 if (*first == 0) return 0.;; 1109 Double_t absa = (Double_t) TMath::Abs(*first);; 1110 logsum += TMath::Log(absa);; 1111 ++first;; 1112 ++n;; 1113 }; 1114 ; 1115 return TMath::Exp(logsum/n);; 1116}; 1117 ; 1118////////////////////////////////////////////////////////////////////////////////; 1119/// Returns the geometric mean of an array a of size n.; 1120/// \f[ GeomMean = (\prod_{i=0}^{n-1} |a[i]|)^{1/n} \f]; 1121 ; 1122template <typename T>; 1123Double_t TMath::GeomMean(Long64_t n, const T *a); 1124{; 1125 return TMath::GeomMean(a, a+n);; 1126}; 1127 ; 1128////////////////////////////////////////////////////////////////////////////////; 1129/// Returns the Standard Deviation of an array defined by the iterators.; 1130/// Note that this function returns the sigma(standard deviation) and; 1131/// not the root mean square of the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8h_source.html:39504,log,logsum,39504,doc/master/TMath_8h_source.html,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html,1,['log'],['logsum']
Testability,"rt( &fCoordErrors[0].front() == fCoordErrorsPtr[0] );; 489 ; 490 fData[ fNPoints ] = y;; 491 fCoordErrors[0][ fNPoints ] = ex;; 492 fDataErrorHigh[ fNPoints ] = eyh;; 493 fDataErrorLow[ fNPoints ] = eyl;; 494 ; 495 FitData::Add( x );; 496 fSumContent += y;; 497 if (y != 0 || eyl != 1.0 || eyh != 1.0) fSumError2 += (eyl+eyh)*(eyl+eyh)/4;; 498 ; 499 }; 500 ; 501 /**; 502 add multi-dim coordinate data with only value; 503 */; 504 void BinData::Add( const double* x, double val ); 505 {; 506 assert( kNoError == fErrorType );; 507 ; 508 assert( !fData.empty() && fDataPtr );; 509 assert( fDataErrorHigh.empty() && !fDataErrorHighPtr );; 510 assert( fDataErrorLow.empty() && !fDataErrorLowPtr );; 511 assert( fDataError.empty() && !fDataErrorPtr );; 512 assert( fCoordErrors.empty() && fCoordErrorsPtr.empty() );; 513 ; 514 fData[ fNPoints ] = val;; 515 ; 516 FitData::Add( x );; 517 fSumContent += val;; 518 }; 519 ; 520 /**; 521 add multi-dim coordinate data with only error in value; 522 The class stores internally the inverse of the error in this case; 523 */; 524 void BinData::Add( const double* x, double val, double eval ); 525 {; 526 assert( kValueError == fErrorType );; 527 assert( !fData.empty() && fDataPtr );; 528 assert( fDataErrorHigh.empty() && !fDataErrorHighPtr );; 529 assert( fDataErrorLow.empty() && !fDataErrorLowPtr );; 530 assert( !fDataError.empty() && fDataErrorPtr );; 531 assert( fCoordErrors.empty() && fCoordErrorsPtr.empty() );; 532 ; 533 fData[ fNPoints ] = val;; 534 fDataError[ fNPoints ] = (eval != 0.0) ? 1.0/eval : 0.0;; 535 ; 536 FitData::Add( x );; 537 fSumContent += val;; 538 if (val != 0 || eval != 1.0) fSumError2 += eval*eval;; 539 if (!fIsWeighted); 540 if (val != 0 && std::abs( eval*eval/val - 1.0) > 1.E-12) fIsWeighted = true;; 541 }; 542 ; 543 /**; 544 add multi-dim coordinate data with both error in coordinates and value; 545 */; 546 void BinData::Add( const double* x, double val, const double* ex, double eval ); 547 {; 548 assert( kCoordError =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:16005,assert,assert,16005,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,2,['assert'],['assert']
Testability,"rt[0], fNpoints);; 982 Double_t result = s.Eval(x);; 983 return result;; 984 }; 985 }; 986 //linear interpolation; 987 //In case x is < fX[0] or > fX[fNpoints-1] return the extrapolated point; 988 ; 989 //find points in graph around x assuming points are not sorted; 990 // (if point are sorted use a binary search); 991 Int_t low = -1;; 992 Int_t up = -1;; 993 if (TestBit(TGraph::kIsSortedX) ) {; 994 low = TMath::BinarySearch(fNpoints, fX, x);; 995 if (low == -1) {; 996 // use first two points for doing an extrapolation; 997 low = 0;; 998 }; 999 if (fX[low] == x) return fY[low];; 1000 if (low == fNpoints-1) low--; // for extrapolating; 1001 up = low+1;; 1002 }; 1003 else {; 1004 // case TGraph is not sorted; 1005 ; 1006 // find neighbours simply looping all points; 1007 // and find also the 2 adjacent points: (low2 < low < x < up < up2 ); 1008 // needed in case x is outside the graph ascissa interval; 1009 Int_t low2 = -1;; 1010 Int_t up2 = -1;; 1011 ; 1012 for (Int_t i = 0; i < fNpoints; ++i) {; 1013 if (fX[i] < x) {; 1014 if (low == -1 || fX[i] > fX[low]) {; 1015 low2 = low;; 1016 low = i;; 1017 } else if (low2 == -1) low2 = i;; 1018 } else if (fX[i] > x) {; 1019 if (up == -1 || fX[i] < fX[up]) {; 1020 up2 = up;; 1021 up = i;; 1022 } else if (up2 == -1) up2 = i;; 1023 } else // case x == fX[i]; 1024 return fY[i]; // no interpolation needed; 1025 }; 1026 ; 1027 // treat cases when x is outside graph min max abscissa; 1028 if (up == -1) {; 1029 up = low;; 1030 low = low2;; 1031 }; 1032 if (low == -1) {; 1033 low = up;; 1034 up = up2;; 1035 }; 1036 }; 1037 // do now the linear interpolation; 1038 assert(low != -1 && up != -1);; 1039 ; 1040 if (fX[low] == fX[up]) return fY[low];; 1041 Double_t yn = fY[up] + (x - fX[up]) * (fY[low] - fY[up]) / (fX[low] - fX[up]);; 1042 return yn;; 1043}; 1044 ; 1045////////////////////////////////////////////////////////////////////////////////; 1046/// Execute action corresponding to one event.; 1047///; 1048/// This member function is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph_8cxx_source.html:34192,assert,assert,34192,doc/master/TGraph_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html,1,['assert'],['assert']
Testability,"rt_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Int_tTProof::EnablePackage(const char* package, Bool_t notOnClient = kFALSE, TList* workers = 0); Int_tTProof::EnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); Int_tTProof::EnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tTProof::Exec(const char* cmd, Bool_t plusMaster = kFALSE); Int_tTProof::Exec(const char* cmd, const char* ord, Bool_t logtomacro = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tExistsDataSet(const char* uri); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTProof::Feedback(TList* objs)SIGNAL ; virtual voidTNamed::FillBuffer(char*& buffer); Long64_tTProof::Finalize(Int_t query = -1, Bool_t force = kFALSE); Long64_tTProof::Finalize(const char* queryref, Bool_t force = kFALSE); TList*TProof::FindDataSets(const char* searchString, const char* optStr = """"); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTProof::GetBytesRead() const; Int_tTProof::GetClientProtocol() const; const char*TProof::GetConfDir() const; const char*TProof::GetConfFile() const; Float_tTProof::GetCpuTime() const; co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofLite.html:6268,log,logtomacro,6268,root/html534/TProofLite.html,https://root.cern,https://root.cern/root/html534/TProofLite.html,1,['log'],['logtomacro']
Testability,"rt_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Int_tTProof::EnablePackage(const char* package, Bool_t notOnClient = kFALSE, TList* workers = 0); Int_tTProof::EnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); Int_tTProof::EnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tTProof::Exec(const char* cmd, Bool_t plusMaster = kFALSE); Int_tTProof::Exec(const char* cmd, const char* ord, Bool_t logtomacro = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tTProof::ExistsDataSet(const char* dataset); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTProof::Feedback(TList* objs)SIGNAL ; virtual voidTNamed::FillBuffer(char*& buffer); Long64_tTProof::Finalize(Int_t query = -1, Bool_t force = kFALSE); Long64_tTProof::Finalize(const char* queryref, Bool_t force = kFALSE); TList*TProof::FindDataSets(const char* searchString, const char* optStr = """"); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTProof::GetBytesRead() const; Int_tTProof::GetClientProtocol() const; const char*TProof::GetConfDir() const; const char*TProof::GetConfFile() const; Float_tTProof::GetCpuTime",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofCondor.html:6497,log,logtomacro,6497,root/html534/TProofCondor.html,https://root.cern,https://root.cern/root/html534/TProofCondor.html,2,['log'],['logtomacro']
Testability,"rticle class created by event generators ;  CTPrincipalPrincipal Components Analysis (PCA) ;  CTProcessEventTimer;  CTProcessIDA TProcessID identifies a ROOT job in a unique way in time and space ;  CTProcessUUIDThis class is a specialized TProcessID managing the list of UUIDs ;  CTProfileProfile Histogram ;  CTProfile2DProfile2D histograms are used to display the mean value of Z and its RMS for each cell in X,Y ;  CTProfile2Poly2D Profile Histogram with Polygonal Bins ;  CTProfile2PolyBinHelper class to represent a bin in the TProfile2Poly histogram ;  CTProfile3DProfile3D histograms are used to display the mean value of T and its RMS for each cell in X,Y,Z ;  CTProfileHelper;  ►CTProofThis class controls a Parallel ROOT Facility, PROOF, cluster ;  CMD5Mod_t;  CTProofBenchSteering class for PROOF benchmarks ;  CTProofBenchDataSetHandle operations on datasets used by ProofBench ;  CTProofBenchRunAbstract base class for PROOF benchmark runs ;  CTProofBenchRunCPUCPU-intensive PROOF benchmark test generates events and fill 1, 2, or 3-D histograms ;  CTProofBenchRunDataReadI/O-intensive PROOF benchmark test reads in event files distributed on the cluster ;  CTProofChain;  CTProofCondor;  CTProofDebug;  CTProofDesc;  CTProofDrawImplement Tree drawing using PROOF ;  CTProofDrawEntryList;  CTProofDrawEventList;  CTProofDrawGraph;  CTProofDrawHist;  ►CTProofDrawListOfGraphs;  CPoint3D_t;  ►CTProofDrawListOfPolyMarkers3D;  CPoint4D_t;  CTProofDrawPolyMarker3D;  CTProofDrawProfile;  CTProofDrawProfile2D;  CTProofInputHandler;  CTProofInterruptHandler;  CTProofLimitsFinderClass to find axis limits and synchronize them between workers ;  CTProofLiteThis class starts a PROOF session on the local machine: no daemons, client and master merged, communications via UNIX-like sockets ;  CTProofLockPath;  CTProofLockPathGuard;  CTProofLogImplementation of the PROOF session log handler ;  CTProofLogElem;  CTProofMergePrg;  CTProofMgrThe PROOF manager interacts with the PROOF server coor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:195296,benchmark,benchmark,195296,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,3,['benchmark'],['benchmark']
Testability,"rtual Double_tTF1::GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.0E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual const char*TNamed::GetName() const; virtual Int_tTF1::GetNDF() const; virtual Int_tTFormula::GetNdim() const; virtual Int_tTFormula::GetNpar() const; virtual Int_tTF1::GetNpx() const; virtual Int_tTFormula::GetNumber() const; virtual Int_tTF1::GetNumberFitPoints() const; virtual Int_tTF1::GetNumberFreeParameters() const; virtual char*TF1::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tTFormula::GetParameter(Int_t ipar) const; Double_tTFormula::GetParameter(const char* name) const; virtual Double_t*TFormula::GetParameters() const; virtual voidTFormula::GetParameters(Double_t* params); TObject*TF1::GetParent() const; virtual Double_tTF1::GetParError(Int_t ipar) const; virtual Double_t*TF1::GetParErrors() const; virtual voidTF1::GetParLimits(Int_t ipar, Double_t& parmin, Double_t& parmax) const; virtual const char*TFormula::GetParName(Int_t ipar) const; virtual Int_tTFormula::GetParNumber(const char* name) const; virtual Double_tTF1::GetProb() const; virtual Int_tTF1::GetQuantiles(Int_t nprobSum, Double_t* q, const Double_t* probSum); virtual Double_tTF1::GetRandom(); virtual Double_tTF1::GetRandom(Double_t xmin, Double_t xmax); virtual voidTF1::GetRange(Double_t& xmin, Double_t& xmax) const; virtual voidTF1::GetRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; virtual voidTF1::GetRange(Double_t& xmin, Double_t& ymin, Double_t& zmin, Double_t& xmax, Double_t& ymax, Double_t& zmax) const; virtual Double_tTF1::GetSave(const Double_t* x); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Double_tTF1::GetX(Double_t y, Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.0E-10, Int_t maxiter = 100, Bool_t logx = false) const; TAxis*TF1::GetXaxis() const; virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF12.html:5085,log,logx,5085,root/html602/TF12.html,https://root.cern,https://root.cern/root/html602/TF12.html,1,['log'],['logx']
Testability,"rtual StyleOption defaultPrintStyle (Option_t *opt) const;  ; virtual void printExtras (std::ostream &os) const;  Interface to print extras of object. ;  ; virtual void printStream (std::ostream &os, Int_t contents, StyleOption style, TString indent="""") const;  Print description of object on ostream, printing contents set by contents integer, which is interpreted as an OR of 'enum ContentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Protected Types; enum  Message { ;   SendReal =0; , SendCat; , Calculate; , Retrieve; , ;   ReturnValue; , Terminate; , ConstOpt; , Verbose; , ;   LogEvalError; , ApplyNLLW2; , EnableOffset; , CalculateNoOffset. };  ; enum  State { Initialize; , Client; , Server; , Inline; };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions; void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTracking=true) override;  Intercept call to optimize constant term in test statistics and forward it to object on server side. ;  ; void doApplyNLLW2 (bool flag);  ; double evaluate () const override;  Send message to server process to retrieve output value If error were logged use logEvalError() on remote side transfer those errors to the local eval error queue. ;  ; virtual double getCarry () const;  ; void initialize ();  Initialize the remote process and message passing pipes between current process and remote process. ;  ; void initVars ();  Initialize list of variables of front-end argument 'arg'. ;  ; void serverLoop ();  Server loop of remote processes. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached valu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealMPFE.html:46972,test,test,46972,doc/master/classRooRealMPFE.html,https://root.cern,https://root.cern/doc/master/classRooRealMPFE.html,1,['test'],['test']
Testability,"rtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidEditSyst(RooWorkspace* proto, const char* pdfNameChar, map<string,double> gammaSyst, map<string,double> uniformSyst, map<string,double> logNormSyst); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; stringFilePrefixStr(string); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFitModel(RooWorkspace*, string, string, string, bool = false); voidFormatFrameForLikelihood(RooPlot* frame, string XTitle = std::string(""#sigma / #sigma_{SM}""), string YTitle = std::string(""-log likelihood"")); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; RooStats::HistFactory::HistoToWorkspaceFactoryHistoToWorkspaceFactory(); RooStats::HistFactory::HistoToWorkspaceFactoryHistoToWorkspaceFactory(const RooStats::HistFactory::HistoToWorkspaceFactory&); RooStats::HistFactory::HistoToWorkspaceFactoryHistoToWorkspaceFactory(string, string, vector<string>, double = 200, double = 20, int = 0, int = 6, TFile* = 0); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HistFactory__HistoToWorkspaceFactory.html:2801,log,log,2801,root/html602/RooStats__HistFactory__HistoToWorkspaceFactory.html,https://root.cern,https://root.cern/root/html602/RooStats__HistFactory__HistoToWorkspaceFactory.html,2,['log'],['log']
Testability,"rtual void TMVA::MethodRSNNS::AddWeightsXMLTo ; (; void * ; ); const. inlinevirtual . Implements TMVA::RMethodBase.; Definition at line 70 of file MethodRSNNS.h. ◆ CreateRanking(). const Ranking * TMVA::MethodRSNNS::CreateRanking ; (; ). inlinevirtual . Implements TMVA::RMethodBase.; Definition at line 54 of file MethodRSNNS.h. ◆ DeclareOptions(). void MethodRSNNS::DeclareOptions ; (; ). virtual . Implements TMVA::RMethodBase.; Definition at line 202 of file MethodRSNNS.cxx. ◆ GetHelpMessage(). void MethodRSNNS::GetHelpMessage ; (; ); const. protectedvirtual . Implements TMVA::IMethod.; Definition at line 348 of file MethodRSNNS.cxx. ◆ GetMvaValue(). Double_t MethodRSNNS::GetMvaValue ; (; Double_t * ; errLower = nullptr, . Double_t * ; errUpper = nullptr . ). virtual . Implements TMVA::RMethodBase.; Definition at line 253 of file MethodRSNNS.cxx. ◆ GetMvaValues(). std::vector< Double_t > MethodRSNNS::GetMvaValues ; (; Long64_t ; firstEvt = 0, . Long64_t ; lastEvt = -1, . Bool_t ; logProgress = false . ). virtual . get all the MVA values for the events of the current Data type ; Reimplemented from TMVA::MethodBase.; Definition at line 273 of file MethodRSNNS.cxx. ◆ HasAnalysisType(). Bool_t MethodRSNNS::HasAnalysisType ; (; Types::EAnalysisType ; type, . UInt_t ; numberClasses, . UInt_t ; numberTargets . ). virtual . Implements TMVA::RMethodBase.; Definition at line 137 of file MethodRSNNS.cxx. ◆ Init(). void MethodRSNNS::Init ; (; void ; ). virtual . Implements TMVA::RMethodBase.; Definition at line 145 of file MethodRSNNS.cxx. ◆ ProcessOptions(). void MethodRSNNS::ProcessOptions ; (; ). virtual . Implements TMVA::RMethodBase.; Definition at line 230 of file MethodRSNNS.cxx. ◆ ReadModelFromFile(). void TMVA::MethodRSNNS::ReadModelFromFile ; (; ). Definition at line 332 of file MethodRSNNS.cxx. ◆ ReadWeightsFromStream() [1/3]. virtual void TMVA::MethodRSNNS::ReadWeightsFromStream ; (; std::istream & ; ). inlinevirtual . Implements TMVA::RMethodBase.; Definition at lin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodRSNNS.html:30628,log,logProgress,30628,doc/master/classTMVA_1_1MethodRSNNS.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodRSNNS.html,1,['log'],['logProgress']
Testability,"rtual voidInit(); voidInitHistos(); voidMonitorBoost(TMVA::Types::EBoostStage stage, UInt_t methodIdx = 0); voidPrintResults(const TString&, vector<Double_t>&, const Double_t) const; virtual voidProcessOptions(); voidResetBoostWeights(); Double_tSingleBoost(TMVA::MethodBase* method); voidSingleTrain(); virtual voidTestClassification(); virtual voidWriteEvaluationHistosToFile(TMVA::Types::ETreeType treetype); virtual voidWriteMonitoringHistosToFile() const. Data Members; public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; TMVA::MethodBase*TMVA::MethodCompositeBase::fCurrentMethod; UInt_tTMVA::MethodCompositeBase::fCurrentMethodIdx; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Double_t>TMVA::MethodCompositeBase::fMethodWeight; vector<TMVA::IMethod*>TMVA::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodBoost.html:17410,test,testing,17410,root/html602/TMVA__MethodBoost.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodBoost.html,2,['test'],['testing']
Testability,"rtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual voidnormLeafServerList(RooArgSet& list) const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooResolutionModel.html:22363,test,testArg,22363,root/html526/RooResolutionModel.html,https://root.cern,https://root.cern/root/html526/RooResolutionModel.html,1,['test'],['testArg']
Testability,"rtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); Int_tTUnfold::RegularizeBins(int start, int step, int nbin, TUnfold::ERegMode regmode); Int_tTUnfold::RegularizeBins2D(int start_bin, int step1, int nbin1, int step2, int nbin2, TUnfold::ERegMode regmode); Int_tTUnfold::RegularizeCurvature(int left_bin, int center_bin, int right_bin, Double_t scale_left = 1., Double_t scale_right = 1.); Int_tTUnfold::RegularizeDerivative(int left_bin, int right_bin, Double_t scale = 1.); Int_tTUnfold::RegularizeSize(int bin, Double_t scale = 1.); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTUnfold::ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); voidTUnfold::SetBias(const TH1* bias); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTUnfold::SetConstraint(TUnfold::EConstraint constraint); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTUnfold::SetEpsMatrix(Double_t eps); virtual Int_tSetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); static voidTObject::SetObjectStat(Bool_t stat); voidSetTauError(Double_t delta_tau); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidSubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1., Double_t scale_error = 0.); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnfoldSys.html:10067,log,logTauX,10067,root/html602/TUnfoldSys.html,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html,4,['log'],"['logTauX', 'logTauY']"
Testability,"rtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGraphPainter(). Default constructor; ; . ~TGraphPainter(). Destructor.; ; . void ComputeLogs(Int_t npoints, Int_t opt). Compute the logarithm of global variables gxwork and gywork; according to the value of Options and put the results in the global; variables gxworkl and gyworkl.; ; npoints : Number of points in gxwork and in gywork.; ; opt = 1 ComputeLogs is called from PaintGrapHist; opt = 0 ComputeLogs is called from PaintGraph; ; . Int_t DistancetoPrimitiveHelper(TGraph* theGraph, Int_t px, Int_t py). Compute distance from point px,py to a graph.; ; Compute the closest distance of approach from point px,py to this line.; The distance is computed in pixels units.; ; . void DrawPanelHelper(TGraph* theGraph). Display a panel with all histogram drawing options.; ; . void ExecuteEventHelper(TGraph* theGraph, Int_t event, Int_t px, Int_t py). Execute action corresponding to one event.; ; This member function is called when a graph is clicked with the locator.; ; If the left mouse button is clicked on one of the line end points, this point; follows the cursor until button is released.; ; If the middle mouse button clicked, the line is moved parallel to itself; until the button is rele",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGraphPainter.html:19825,log,logarithm,19825,root/html534/TGraphPainter.html,https://root.cern,https://root.cern/root/html534/TGraphPainter.html,1,['log'],['logarithm']
Testability,"rtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual const char * GetSenderClassName () const;  . Protected Attributes; Bool_t fBold;  bold flag ;  ; TGColorSelect * fColorSelect;  color selection dialog ;  ; TGListBox * fFontNames;  list of font names ;  ; FontProp_t * fFontProp;  font info structure ;  ; TGListBox * fFontSizes;  list of font sizes ;  ; TGListBox * fFontStyles;  list of font styles ;  ; Bool_t fHitOK;  flag = kTRUE if user press the Ok button ;  ; Int_t fInitAlign;  initial value of text align ;  ; Pixel_t fInitColor;  initial value of text color ;  ; TGFont * fInitFont;  initial font ;  ; Bool_t fItalic;  italic flag ;  ; TGFont * fLabelFont;  TGFont used for sample text. ;  ; TString fLName;  logical font name ;  ; TString fName;  font name ;  ; Int_t fNumberOfFonts;  total number of fonts ;  ; TGLabel * fSample;  sample of selected font ;  ; TString fSampleText;  string used for sample ;  ; TGGC * fSampleTextGC;  GC used for sample text. ;  ; Int_t fSize;  font size ;  ; Int_t fTextAlign;  text alignment ;  ; TGComboBox * fTextAligns;  font alignment selection ;  ; Pixel_t fTextColor;  text color ;  ; Bool_t fWaitFor;  if kTRUE WaitForUnmap is called in constructor. ;  ;  Protected Attributes inherited from TGTransientFrame; const TGWindow * fMain;  ;  Protected Attributes inherited from TGMainFrame; TList * fBindList;  list with key bindings ;  ; TString fClassName;  WM class name. ;  ; Atom_t * fDNDTypeList;  handles DND types ;  ; TString fIconName;  icon name ;  ; TString fIconPixmap;  icon pixmap name ;  ; UInt_t fMWMFuncs;  MWM functions. ;  ; UInt_t fMWMInput;  MWM input modes. ;  ; UInt_t fMWMValue;  MWM decoration hints. ;  ; TString fResourceName;  WM resource name. ;  ; TString fWindowName;  window name ;  ; UInt_t fWMHeight;  WM height. ;  ; UInt_t fWMHeightInc;  WM height",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGFontDialog.html:31192,log,logical,31192,doc/master/classTGFontDialog.html,https://root.cern,https://root.cern/doc/master/classTGFontDialog.html,1,['log'],['logical']
Testability,rtual void Streamer (TBuffer &);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Bool_t UseColor () const;  ; Bool_t WriteOptionsReference () const;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static void DestroyInstance ();  static function: destroy TMVA instance ;  ; static Config & Instance ();  static function: returns TMVA instance ;  . Public Attributes; class TMVA::Config::IONames fIONames;  ; class TMVA::Config::VariablePlotting fVariablePlotting;  . Protected Attributes; Executor fExecutor;  . Private Member Functions;  Config ();  constructor - set defaults ;  ;  Config (const Config &);  ; virtual ~Config ();  destructor ;  ; MsgLogger & Log () const;  ; Config & operator= (const Config &);  . Private Attributes; std::atomic< Bool_t > fDrawProgressBar;  draw progress bar to indicate training evolution ;  ; MsgLogger * fLogger;  ! message logger ;  ; std::atomic< UInt_t > fNWorkers;  Default number of workers for multi-process jobs. ;  ; std::atomic< Bool_t > fSilent;  no output at all ;  ; std::atomic< Bool_t > fUseColoredConsole;  coloured standard output ;  ; std::atomic< Bool_t > fWriteOptionsReference;  if set true: Configurable objects write file with option reference ;  . Static Private Attributes; static std::atomic< Config * > fgConfigPtr { 0 };  . #include <TMVA/Config.h>; Constructor & Destructor Documentation. ◆ Config() [1/2]. TMVA::Config::Config ; (; ). private . constructor - set defaults ; Definition at line 51 of file Config.cxx. ◆ Config() [2/2]. TMVA::Config::Config ; (; const Config & ; ). private . ◆ ~Config(). TMVA::Config::~Config ; (; ). privatevirtual . destructor ; Definition at line 82 of file Config.cxx. Member Function Documentation. ◆ Class(). static TClass * TMVA::Config::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const ch,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Config.html:2509,log,logger,2509,doc/master/classTMVA_1_1Config.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Config.html,1,['log'],['logger']
Testability,"rtual; GetFillStyle() constTAttFillinlinevirtual; GetFormula()TF1inlinevirtual; GetFormula() constTF1inlinevirtual; GetHistogram() constTF1virtual; GetIconName() constTObjectvirtual; GetLinearPart(Int_t i) constTF1inlinevirtual; GetLineColor() constTAttLineinlinevirtual; GetLineStyle() constTAttLineinlinevirtual; GetLineWidth() constTAttLineinlinevirtual; GetMarkerColor() constTAttMarkerinlinevirtual; GetMarkerLineWidth(Style_t style)TAttMarkerstatic; GetMarkerSize() constTAttMarkerinlinevirtual; GetMarkerStyle() constTAttMarkerinlinevirtual; GetMarkerStyleBase(Style_t style)TAttMarkerstatic; GetMaximum(Double_t *x) constTF2virtual; GetMaximum(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constTF2virtual; GetMaximumStored() constTF1inlinevirtual; GetMaximumX(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constTF1virtual; GetMaximumXY(Double_t &x, Double_t &y) constTF2virtual; GetMethodCall() constTF1inline; GetMinimum(Double_t *x) constTF2virtual; GetMinimum(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constTF2virtual; GetMinimumStored() constTF1inlinevirtual; GetMinimumX(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constTF1virtual; GetMinimumXY(Double_t &x, Double_t &y) constTF2virtual; GetMinMaxNDim(Double_t *x, Bool_t findmax, Double_t epsilon=0, Int_t maxiter=0) constTF1protectedvirtual; GetName() const overrideTNamedinlinevirtual; GetNDF() constTF1virtual; GetNdim() constTF1inlinevirtual; GetNpar() constTF1inlinevirtual; GetNpx() constTF1inlinevirtual; GetNpy() constTF2inline; GetNumber() constTF1inlinevirtual; GetNumberFitPoints() constTF1inlinevirtual; GetNumberFreeParameters() constTF1virtual; GetObjectInfo(Int_t px, Int_t py) const overrideTF2virtual; GetObjectStat()TObjectstatic; GetOption() constTObjectinlinevirtual; GetParameter(Int_t ipar) constTF1inli",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF2-members.html:6432,log,logx,6432,doc/master/classTF2-members.html,https://root.cern,https://root.cern/doc/master/classTF2-members.html,1,['log'],['logx']
Testability,"rtual; GetFormula() constTF1inlinevirtual; GetHistogram() constTF1virtual; GetIconName() constTObjectvirtual; GetLinearPart(Int_t i) constTF1inlinevirtual; GetLineColor() constTAttLineinlinevirtual; GetLineStyle() constTAttLineinlinevirtual; GetLineWidth() constTAttLineinlinevirtual; GetMarkerColor() constTAttMarkerinlinevirtual; GetMarkerLineWidth(Style_t style)TAttMarkerstatic; GetMarkerSize() constTAttMarkerinlinevirtual; GetMarkerStyle() constTAttMarkerinlinevirtual; GetMarkerStyleBase(Style_t style)TAttMarkerstatic; GetMaximum(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constTF1virtual; GetMaximumStored() constTF1inlinevirtual; GetMaximumX(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constTF1virtual; GetMethodCall() constTF1inline; GetMinimum(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constTF1virtual; GetMinimumStored() constTF1inlinevirtual; GetMinimumX(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constTF1virtual; GetMinMaxNDim(Double_t *x, Bool_t findmax, Double_t epsilon=0, Int_t maxiter=0) constTF1protectedvirtual; GetName() const overrideTNamedinlinevirtual; GetNDF() constTF1virtual; GetNdim() constTF1inlinevirtual; GetNpar() constTF1inlinevirtual; GetNpx() constTF1inlinevirtual; GetNumber() constTF1inlinevirtual; GetNumberFitPoints() constTF1inlinevirtual; GetNumberFreeParameters() constTF1virtual; GetObjectInfo(Int_t px, Int_t py) const overrideTF1virtual; GetObjectStat()TObjectstatic; GetOption() constTObjectinlinevirtual; GetParameter(Int_t ipar) constTF1inlinevirtual; GetParameter(const TString &name) constTF1inlinevirtual; GetParameters() constTF1inlinevirtual; GetParameters(Double_t *params)TF1inlinevirtual; GetParent() constTF1inline; GetParError(Int_t ipar) constTF1virtual; GetParErrors() constTF1inlinevirtual; GetParLimits(Int_t ipar, Doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1-members.html:6031,log,logx,6031,doc/master/classTF1-members.html,https://root.cern,https://root.cern/doc/master/classTF1-members.html,1,['log'],['logx']
Testability,"rtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static void verboseDirty (bool flag);  Activate verbose messaging related to dirty flag propagation. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Versi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCFunction1Binding.html:45890,log,logEvalError,45890,doc/master/classRooCFunction1Binding.html,https://root.cern,https://root.cern/doc/master/classRooCFunction1Binding.html,126,['log'],"['logEvalError', 'logging']"
Testability,"rt{ m_t^2 = E^2 - p{_z}^2} X sign(E^ - p{_z}^2) \f]. { return fCoordinates.Mt(); }. Scalar Et2() const. return the transverse energy squared; \f[ e_t = \frac{E^2 p_{\perp}^2 }{ |p|^2 } \f]. { return fCoordinates.Et2(); }. Scalar Et() const. return the transverse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar& a) const; LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect() const; TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html:15757,log,log,15757,root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html,1,['log'],['log']
Testability,"rt{ m_t^2 = E^2 - p{_z}^2} X sign(E^ - p{_z}^2) \f]. { return fCoordinates.Mt(); }. Scalar Et2() const. return the transverse energy squared; \f[ e_t = \frac{E^2 p_{\perp}^2 }{ |p|^2 } \f]. { return fCoordinates.Et2(); }. Scalar Et() const. return the transverse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar& a) const; LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect() const; TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html:15757,log,log,15757,root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html,1,['log'],['log']
Testability,"ructed using the same mechanism as described for the root; node. The devision is stopped once a certain node has reached either a; minimum number of events, or a minimum or maximum signal purity. These; leave nodes are then called ""signal"" or ""background"" if they contain; more signal respective background events from the training sample. Boosting:. The idea behind adaptive boosting (AdaBoost) is, that signal events; from the training sample, that end up in a background node; (and vice versa) are given a larger weight than events that are in; the correct leave node. This results in a re-weighed training event; sample, with which then a new decision tree can be developed.; The boosting can be applied several times (typically 100-500 times); and one ends up with a set of decision trees (a forest).; Gradient boosting works more like a function expansion approach, where; each tree corresponds to a summand. The parameters for each summand (tree); are determined by the minimization of a error function (binomial log-; likelihood for classification and Huber loss for regression).; A greedy algorithm is used, which means, that only one tree is modified; at a time, while the other trees stay fixed. Bagging:. In this particular variant of the Boosted Decision Trees the boosting; is not done on the basis of previous training results, but by a simple; stochastic re-sampling of the initial training event sample. Random Trees:; Similar to the ""Random Forests"" from Leo Breiman and Adele Cutler, it; uses the bagging algorithm together and bases the determination of the; best node-split during the training on a random subset of variables only; which is individually chosen for each split. Analysis:. Applying an individual decision tree to a test event results in a; classification of the event as either signal or background. For the; boosted decision tree selection, an event is successively subjected to; the whole set of decision trees and depending on how often it is; classified as sign",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodBDT.html:2784,log,log,2784,root/html528/TMVA__MethodBDT.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodBDT.html,6,['log'],['log']
Testability,"ructor ;  ;  ~SVWorkingSet ();  destructor ;  ; Bool_t ExamineExample (SVEvent *);  ; Bool_t ExamineExampleReg (SVEvent *);  ; Float_t GetBpar ();  ; std::vector< TMVA::SVEvent * > * GetSupportVectors ();  ; Bool_t IsDiffSignificant (Float_t, Float_t, Float_t);  ; void SetIPythonInteractive (bool *ExitFromTraining, UInt_t *fIPyCurrentIter_);  ; Bool_t TakeStep (SVEvent *, SVEvent *);  ; Bool_t TakeStepReg (SVEvent *, SVEvent *);  ; Bool_t Terminated ();  ; void Train (UInt_t nIter=1000);  train the SVM ;  ; void TrainReg ();  . Private Member Functions; void SetIndex (TMVA::SVEvent *);  . Private Attributes; Float_t fB_low;  documentation ;  ; Float_t fB_up;  documentation ;  ; Bool_t fdoRegression;  TODO temporary, find nicer solution. ;  ; bool * fExitFromTraining = nullptr;  ; std::vector< TMVA::SVEvent * > * fInputData;  input events ;  ; UInt_t * fIPyCurrentIter = nullptr;  ; SVKernelFunction * fKFunction;  kernel function ;  ; SVKernelMatrix * fKMatrix;  kernel matrix ;  ; MsgLogger * fLogger;  ! message logger ;  ; std::vector< TMVA::SVEvent * > * fSupVec;  output events - support vectors ;  ; SVEvent * fTEventLow;  last optimized event ;  ; SVEvent * fTEventUp;  last optimized event ;  ; Float_t fTolerance;  documentation ;  . #include <TMVA/SVWorkingSet.h>; Constructor & Destructor Documentation. ◆ SVWorkingSet() [1/2]. TMVA::SVWorkingSet::SVWorkingSet ; (; ). constructor ; Definition at line 50 of file SVWorkingSet.cxx. ◆ SVWorkingSet() [2/2]. TMVA::SVWorkingSet::SVWorkingSet ; (; std::vector< TMVA::SVEvent * > * ; inputVectors, . SVKernelFunction * ; kernelFunction, . Float_t ; tol, . Bool_t ; doreg . ). constructor ; Definition at line 68 of file SVWorkingSet.cxx. ◆ ~SVWorkingSet(). TMVA::SVWorkingSet::~SVWorkingSet ; (; ). destructor ; Definition at line 120 of file SVWorkingSet.cxx. Member Function Documentation. ◆ ExamineExample(). Bool_t TMVA::SVWorkingSet::ExamineExample ; (; TMVA::SVEvent * ; jevt). Definition at line 128 of file SVWorkingSet.cxx. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1SVWorkingSet.html:1559,log,logger,1559,doc/master/classTMVA_1_1SVWorkingSet.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1SVWorkingSet.html,1,['log'],['logger']
Testability,"ructor. . virtual ~BrentRootFinder(); Default Destructor. . {}. bool SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup). bool Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); Returns the X value corresponding to the function value fy for (xmin<x<xmax).; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval. \@param maxIter maximum number of iterations.; \@param absTol desired absolute error in the minimum position.; \@param absTol desired relative error in the minimum position. void SetNpx(int npx); Set the number of point used to bracket root using a grid . { fNpx = npx; }. void SetLogScan(bool on). Set a log grid scan (default is equidistant bins); will work only if xlow > 0. { fLogScan = on; }. double Root() const; Returns root value. Need to call first Solve(). . { return fRoot; }. int Status() const; Returns status of last estimate. If = 0 is OK . { return fStatus; }. int Iterations() const; Return number of iteration used to find minimum . { return fNIter; }. const char* Name() const; Return name of root finder algorithm (""BrentRootFinder""). . void SetDefaultNpx(int npx); static function used to modify the default parameters; set number of default Npx used at construction time (when SetNpx is not called); Default value is 100. void SetDefaultNSearch(int n); set number of times the bracketing search in combination with is done to find a good interval; Default value is 10. » Last changed: root/mathcore:$Id: BrentRootFinder.h 36905 2010-11-24 15:44:34Z moneta $ » Last generated: 2010-11-25 07:08; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general ple",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__BrentRootFinder.html:3689,log,log,3689,root/html528/ROOT__Math__BrentRootFinder.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__BrentRootFinder.html,1,['log'],['log']
Testability,"ructor. . virtual ~BrentRootFinder(); Default Destructor. . {}. bool SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup). bool Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); Returns the X value corresponding to the function value fy for (xmin<x<xmax).; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval. \@param maxIter maximum number of iterations.; \@param absTol desired absolute error in the minimum position.; \@param absTol desired relative error in the minimum position. void SetNpx(int npx); Set the number of point used to bracket root using a grid . { fNpx = npx; }. void SetLogScan(bool on). Set a log grid scan (default is equidistant bins); will work only if xlow > 0. { fLogScan = on; }. double Root() const; Returns root value. Need to call first Solve(). . { return fRoot; }. int Status() const; Returns status of last estimate. If = 0 is OK . { return fStatus; }. int Iterations() const; Return number of iteration used to find minimum . { return fNIter; }. const char* Name() const; Return name of root finder algorithm (""BrentRootFinder""). . void SetDefaultNpx(int npx); static function used to modify the default parameters; set number of default Npx used at construction time (when SetNpx is not called); Default value is 100. void SetDefaultNSearch(int n); set number of times the bracketing search in combination with is done to find a good interval; Default value is 10. » Last changed: root/mathcore:$Id: BrentRootFinder.h 36905 2010-11-24 15:44:34Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general ple",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__BrentRootFinder.html:3691,log,log,3691,root/html530/ROOT__Math__BrentRootFinder.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__BrentRootFinder.html,1,['log'],['log']
Testability,"ructor. . virtual ~BrentRootFinder(); Default Destructor. . {}. bool SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup). bool Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); Returns the X value corresponding to the function value fy for (xmin<x<xmax).; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval. \@param maxIter maximum number of iterations.; \@param absTol desired absolute error in the minimum position.; \@param absTol desired relative error in the minimum position. void SetNpx(int npx); Set the number of point used to bracket root using a grid . { fNpx = npx; }. void SetLogScan(bool on). Set a log grid scan (default is equidistant bins); will work only if xlow > 0. { fLogScan = on; }. double Root() const; Returns root value. Need to call first Solve(). . { return fRoot; }. int Status() const; Returns status of last estimate. If = 0 is OK . { return fStatus; }. int Iterations() const; Return number of iteration used to find minimum . { return fNIter; }. const char* Name() const; Return name of root finder algorithm (""BrentRootFinder""). . void SetDefaultNpx(int npx); static function used to modify the default parameters; set number of default Npx used at construction time (when SetNpx is not called); Default value is 100. void SetDefaultNSearch(int n); set number of times the bracketing search in combination with is done to find a good interval; Default value is 10. » Last changed: root/mathcore:$Id: BrentRootFinder.h 36905 2010-11-24 15:44:34Z moneta $ » Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general ple",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__BrentRootFinder.html:3691,log,log,3691,root/html532/ROOT__Math__BrentRootFinder.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__BrentRootFinder.html,1,['log'],['log']
Testability,"ructor. ; Definition at line 247 of file TProofProgressLog.cxx. Member Function Documentation. ◆ AddBuffer(). void TProofProgressLog::AddBuffer ; (; const char * ; buffer). Add text to the window. ; Definition at line 298 of file TProofProgressLog.cxx. ◆ BuildLogList(). void TProofProgressLog::BuildLogList ; (; Bool_t ; create = kFALSE). Build the list of workers. ; For this, extract the logs and take the names of TProofLogElements ; Definition at line 319 of file TProofProgressLog.cxx. ◆ Class(). static TClass * TProofProgressLog::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TProofProgressLog::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TProofProgressLog::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 93 of file TProofProgressLog.h. ◆ Clear(). void TProofProgressLog::Clear ; (; Option_t * ; = nullptr). overridevirtual . Clear log window. ; Reimplemented from TObject.; Definition at line 271 of file TProofProgressLog.cxx. ◆ CloseWindow(). void TProofProgressLog::CloseWindow ; (; ). overridevirtual . Handle close button or when closed via window manager action. ; Reimplemented from TGMainFrame.; Definition at line 310 of file TProofProgressLog.cxx. ◆ DeclFileName(). static const char * TProofProgressLog::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 93 of file TProofProgressLog.h. ◆ DoLog(). void TProofProgressLog::DoLog ; (; Bool_t ; grep = kFALSE). Display logs. ; 'grep' is set to kTRUE if it is invoked by pressing the 'Filter' button. ; Definition at line 388 of file TProofProgressLog.cxx. ◆ Init(). void TProofProgressLog::Init ; (; Int_t ; w = 700, . Int_t ; h = 600 . ). private . Init window frame for log messages. ; Definition at line 70 of file TProofProgressLog.cxx. ◆ IsA(). TClass * TProofProgressLog::IsA ; (; ); const. inlineoverridev",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofProgressLog.html:39894,log,log,39894,doc/master/classTProofProgressLog.html,https://root.cern,https://root.cern/doc/master/classTProofProgressLog.html,1,['log'],['log']
Testability,"ructor. ; Definition at line 313 of file TFormula_v5.cxx. Member Function Documentation. ◆ Analyze(). void TFormula::Analyze ; (; const char * ; schain, . Int_t & ; err, . Int_t ; offset = 0 . ). virtual . Analyze a sub-expression in one formula. ; Expressions in one formula are recursively analyzed. Result of analysis is stored in the object tables. Table of function codes and errors; * functions :; ; + 1 pow 20; - 2 sq 21; * 3 sqrt 22; / 4 strstr 23; % 5 min 24; max 25; log 30; cos 10 exp 31; sin 11 log10 32; tan 12; acos 13 abs 41; asin 14 sign 42; atan 15 int 43; atan2 16; fmod 17 rndm 50; ; cosh 70 acosh 73; sinh 71 asinh 74; tanh 72 atanh 75; ; expo 100 gaus 110 gausn (see note below); expo(0) 100 0 gaus(0) 110 0 gausn(0); expo(1) 100 1 gaus(1) 110 1 gausn(1); xexpo 100 x xgaus 110 x xgausn; yexpo 101 x ygaus 111 x ygausn; zexpo 102 x zgaus 112 x zgausn; xyexpo 105 x xygaus 115 x xygausn; yexpo(5) 102 5 ygaus(5) 111 5 ygausn(5); xyexpo(2) 105 2 xygaus(2) 115 2 xygausn(2); ; landau 120 x landaun (see note below); landau(0) 120 0 landaun(0); landau(1) 120 1 landaun(1); xlandau 120 x xlandaun; ylandau 121 x ylandaun; zlandau 122 x zlandaun; xylandau 125 x xylandaun; ylandau(5) 121 5 ylandaun(5); xylandau(2) 125 2 xylandaun(2); ; pol0 130 x pol1 130 1xx; pol0(0) 130 0 pol1(0) 130 100; pol0(1) 130 1 pol1(1) 130 101; xpol0 130 x xpol1 130 101; ypol0 131 x ypol1 131 101; zpol0 132 x zpol1 132 1xx; ypol0(5) 131 5 ypol1(5) 131 105; ; pi 40; ; && 60 < 64; || 61 > 65; == 62 <= 66; != 63 => 67; ! 68; ==(string) 76 & 78; !=(string) 77 | 79; <<(shift) 80 >>(shift) 81; ? : 82; ; * constants (kConstants) :; ; c0 141 1 c1 141 2 etc..; ; * strings (kStringConst):; ; sX 143 x; ; * variables (kFormulaVar) :; ; x 144 0 y 144 1 z 144 2 t 144 3; ; * parameters :; ; [1] 140 1; [2] 140 2; etc.; ROOT::v5::TFormula::kStringConst@ kStringConstDefinition TFormula.h:185; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17. Special",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1v5_1_1TFormula.html:25658,log,log,25658,doc/master/classROOT_1_1v5_1_1TFormula.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1v5_1_1TFormula.html,1,['log'],['log']
Testability,"ructor. The network is described by a simple; string: The input/output layers are defined by giving the expression for; each neuron, separated by comas. Hidden layers are just described; by the number of neurons. The layers are separated by colons.; In addition, input/output layer formulas can be preceded by '@' (e.g ""@out""); if one wants to also normalize the data from the TTree.; Input and outputs are taken from the TTree given as second argument.; Expressions are evaluated as for TTree::Draw(), arrays are expended in; distinct neurons, one for each index.; This can only be done for fixed-size arrays.; If the formula ends with ""!"", softmax functions are used for the output layer.; One defines the training and test datasets by TEventLists. Example:; TMultiLayerPerceptron(""x,y:10:5:f"",inputTree);; Both the TTree and the TEventLists can be defined in; the constructor, or later with the suited setter method. The lists; used for training and test can be defined either explicitly, or via; a string containing the formula to be used to define them, exactly as; for a TCut.; The learning method is defined using the; TMultiLayerPerceptron::SetLearningMethod() . Learning methods are :; TMultiLayerPerceptron::kStochastic, ; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS; A weight can be assigned to events, either in the constructor, either; with TMultiLayerPerceptron::SetEventWeight(). In addition, the TTree weight; is taken into account.; Finally, one starts the training with; TMultiLayerPerceptron::Train(Int_t nepoch, Option_t* options). The; first argument is the number of epochs while option is a string that; can contain: ""text"" (simple text output) , ""graph""; (evoluting graphical training curves), ""update=X"" (step for; the text/graph output update) or ""+"" (will skip the; randomisation and start from the previous values). All combinations; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMultiLayerPerceptron.html:7220,test,test,7220,root/html534/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html534/TMultiLayerPerceptron.html,3,['test'],['test']
Testability,"runed tree"" may have set the variable ""IsTerminal"" to ""arbitrary"" at; any node, hence this tree quality testing will stop there, hence test; the pruned tree (while the full tree is still in place for normal/later use). void CheckEventWithPrunedTree(const TMVA::Event& ) const; pass a single validation event throught a pruned decision tree; on the way down the tree, fill in all the ""intermediate"" information; that would normally be there from training. Double_t GetSumWeights(const TMVA::DecisionTree::EventList* validationSample) const; calculate the normalization factor for a pruning validation sample. UInt_t CountLeafNodes(TMVA::Node* n = NULL); return the number of terminal nodes in the sub-tree below Node n. void DescendTree(TMVA::Node* n = NULL); descend a tree to find all its leaf nodes. void PruneNode(TMVA::DecisionTreeNode* node); prune away the subtree below the node. void PruneNodeInPlace(TMVA::DecisionTreeNode* node); prune a node temporaily (without actually deleting its decendants; which allows testing the pruned tree quality for many different; pruning stages without ""touching"" the tree. TMVA::Node* GetNode(ULong_t sequence, UInt_t depth); retrieve node from the tree. Its position (up to a maximal tree depth of 64); is coded as a sequence of left-right moves starting from the root, coded as; 0-1 bit patterns stored in the ""long-integer"" (i.e. 0:left ; 1:right. void GetRandomisedVariables(Bool_t* useVariable, UInt_t* variableMap, UInt_t& nVars). Double_t TrainNodeFast(const TMVA::DecisionTree::EventList& eventSample, TMVA::DecisionTreeNode* node); Decide how to split a node using one of the variables that gives; the best separation of signal/background. In order to do this, for each; variable a scan of the different cut values in a grid (grid = fNCuts) is; performed and the resulting separation gains are compared.; in addition to the individual variables, one can also ask for a fisher; discriminant being built out of (some) of the variables and used as a; p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__DecisionTree.html:12383,test,testing,12383,root/html528/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html528/TMVA__DecisionTree.html,3,['test'],['testing']
Testability,"running multiple RDataFrame event loops concurrently:; 936~~~{.cpp}; 937ROOT::EnableImplicitMT();; 938ROOT::RDataFrame df1(""tree1"", ""f1.root"");; 939ROOT::RDataFrame df2(""tree2"", ""f2.root"");; 940auto histo1 = df1.Histo1D(""x"");; 941auto histo2 = df2.Histo1D(""y"");; 942 ; 943// just accessing result pointers, the event loops of separate RDataFrames run one after the other; 944histo1->Draw(); // runs first multi-thread event loop; 945histo2->Draw(); // runs second multi-thread event loop; 946 ; 947// alternatively, with ROOT::RDF::RunGraphs, event loops for separate computation graphs can run concurrently; 948ROOT::RDF::RunGraphs({histo1, histo2});; 949histo1->Draw(); // results can then be used as usual; 950~~~; 951 ; 952### Performance considerations; 953 ; 954To obtain the maximum performance out of RDataFrame, make sure to avoid just-in-time compiled versions of transformations and actions if at all possible.; 955For instance, `Filter(""x > 0"")` requires just-in-time compilation of the corresponding C++ logic, while the equivalent `Filter([](float x) { return x > 0.; }, {""x""})` does not.; 956Similarly, `Histo1D(""x"")` requires just-in-time compilation after the type of `x` is retrieved from the dataset, while `Histo1D<float>(""x"")` does not; the latter spelling; 957should be preferred for performance-critical applications.; 958 ; 959Python applications cannot easily specify template parameters or pass C++ callables to RDataFrame.; 960See [Efficient analysis in Python](#python) for possible ways to speed up hot paths in this case.; 961 ; 962Just-in-time compilation happens once, right before starting an event loop. To reduce the runtime cost of this step, make sure to book all operations *for all RDataFrame computation graphs*; 963before the first event loop is triggered: just-in-time compilation will happen once for all code required to be generated up to that point, also across different computation graphs.; 964 ; 965Also make sure not to count the just-in-time compilat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:54855,log,logic,54855,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['log'],['logic']
Testability,"running multiple RDataFrame event loops concurrently:; 976~~~{.cpp}; 977ROOT::EnableImplicitMT();; 978ROOT::RDataFrame df1(""tree1"", ""f1.root"");; 979ROOT::RDataFrame df2(""tree2"", ""f2.root"");; 980auto histo1 = df1.Histo1D(""x"");; 981auto histo2 = df2.Histo1D(""y"");; 982 ; 983// just accessing result pointers, the event loops of separate RDataFrames run one after the other; 984histo1->Draw(); // runs first multi-thread event loop; 985histo2->Draw(); // runs second multi-thread event loop; 986 ; 987// alternatively, with ROOT::RDF::RunGraphs, event loops for separate computation graphs can run concurrently; 988ROOT::RDF::RunGraphs({histo1, histo2});; 989histo1->Draw(); // results can then be used as usual; 990~~~; 991 ; 992### Performance considerations; 993 ; 994To obtain the maximum performance out of RDataFrame, make sure to avoid just-in-time compiled versions of transformations and actions if at all possible.; 995For instance, `Filter(""x > 0"")` requires just-in-time compilation of the corresponding C++ logic, while the equivalent `Filter([](float x) { return x > 0.; }, {""x""})` does not.; 996Similarly, `Histo1D(""x"")` requires just-in-time compilation after the type of `x` is retrieved from the dataset, while `Histo1D<float>(""x"")` does not; the latter spelling; 997should be preferred for performance-critical applications.; 998 ; 999Python applications cannot easily specify template parameters or pass C++ callables to RDataFrame.; 1000See [Efficient analysis in Python](#python) for possible ways to speed up hot paths in this case.; 1001 ; 1002Just-in-time compilation happens once, right before starting an event loop. To reduce the runtime cost of this step, make sure to book all operations *for all RDataFrame computation graphs*; 1003before the first event loop is triggered: just-in-time compilation will happen once for all code required to be generated up to that point, also across different computation graphs.; 1004 ; 1005Also make sure not to count the just-in-time co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:56495,log,logic,56495,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['log'],['logic']
Testability,"ruptif true macro execution will be stopped; Int_tfNcmdcommand history number; charfPrompt[64]interpreter prompt. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRint(const char* appClassName, int* argc, char** argv, void* options = 0, int numOptions = 0, Bool_t noLogo = kFALSE); Create an application environment. The TRint environment provides an; interface to the WM manager functionality and eventloop via inheritance; of TApplication and in addition provides interactive access to; the CINT C++ interpreter via the command line. ~TRint(); Destructor. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. void Run(Bool_t retrn = kFALSE); Main application eventloop. First process files given on the command; line and then go into the main application event loop, unless the -q; command line option was specfied in which case the program terminates.; When retrun is true this method returns even when -q was specified. When QuitOpt is true and retrn is false, terminate the application with; an error code equal to either the ProcessLine error (if any) or the; return value of the command casted to a long. void PrintLogo(Bool_t lite = kFALSE); Print the ROOT logo on standard output. char * GetPrompt(); Get prompt from interpreter. Either ""root [n]"" or ""end with '}'"". const char * SetPrompt(const char* newPrompt); Set a new default prompt. It returns the previous prompt.; The prompt may contain a %d which will be replaced by the commend; number. The default prompt is ""root [%d] "". The maximum length of; the prompt is 55 characters. To set the prompt in an ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRint.html:13110,log,logon,13110,root/html528/TRint.html,https://root.cern,https://root.cern/root/html528/TRint.html,4,['log'],['logon']
Testability,"rv::fgLastEntryLast entry before exception; static TStringTProofServ::fgLastMsgMessage about status before exception. private:. TXSocketHandler*fInputHandler; TXProofServInterruptHandler*fInterruptHandler; TStringfSockPath; Bool_tfTerminatedtrue if Terminate() has been already called. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TXProofServ(Int_t* argc, char** argv, FILE* flog = 0); Main constructor. Int_t CreateServer(); Finalize the server setup. If master, create the TProof instance to talk; the worker or submaster nodes.; Return 0 on success, -1 on error. ~TXProofServ(); Cleanup. Not really necessary since after this dtor there is no; live anyway. void HandleUrgentData(); Handle high priority data sent by the master or client. void HandleSigPipe(); Called when the client is not alive anymore; terminate the session. void HandleTermination(); Called when the client is not alive anymore; terminate the session. Int_t Setup(); Print the ProofServ logo on standard output.; Return 0 on success, -1 on error. TProofServ::EQueryAction GetWorkers(TList* workers, Int_t& prioritychange, Bool_t resume = kFALSE); Get list of workers to be used from now on.; The list must be provided by the caller. Bool_t HandleError(const void* in = 0); Handle error on the input socket. Bool_t HandleInput(const void* in = 0); Handle asynchronous input on the input socket. void DisableTimeout(); Disable read timeout on the underlying socket. void EnableTimeout(); Enable read timeout on the underlying socket. void Terminate(Int_t status); Terminate the proof server. Int_t LockSession(const char* sessiontag, TProofLockPath** lck); Try locking query area of session tagged sessiontag.; The id of the locking file is returned in fid and must be; unlocked via UnlockQueryFile(fid). void ReleaseWorker(const char* ord); Send message to intermediate coordinator to release worker of last ordinal; ord. » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXProofServ.html:18213,log,logo,18213,root/html534/TXProofServ.html,https://root.cern,https://root.cern/root/html534/TXProofServ.html,1,['log'],['logo']
Testability,"rvableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooProduct&operator=(const RooProduct&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProduct.html:19394,test,testArg,19394,root/html602/RooProduct.html,https://root.cern,https://root.cern/root/html602/RooProduct.html,2,['test'],['testArg']
Testability,"rvables 'intObs'. ;  ;  RooProjectedPdf (const RooProjectedPdf &other, const char *name=nullptr);  Copy constructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Return analytical integral represent by appropriate element of projection cache. ;  ; TObject * clone (const char *newname) const override;  ; std::unique_ptr< RooAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const override;  ; RooAbsPdf * createProjection (const RooArgSet &iset) override;  Special version of RooAbsReal::createProjection that deals with projections of projections. ;  ; double expectedEvents (const RooArgSet *nset) const override;  Return expected number of events to be used in calculation of extended likelihood. ;  ; ExtendMode extendMode () const override;  Returns ability of PDF to provide extended likelihood terms. ;  ; bool forceAnalyticalInt (const RooAbsArg &dep) const override;  Force RooRealIntegral to relegate integration of all observables to internal logic. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Mark all requested variables as internally integrated. ;  ; void initGenerator (Int_t) override;  Interface for one-time initialization to setup the generator for the specified code. ;  ; TClass * IsA () const override;  ; void printMetaArgs (std::ostream &os) const override;  Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the integration operation. ;  ; bool selfNormalized () const override;  Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProjectedPdf.html:2453,log,logic,2453,doc/master/classRooProjectedPdf.html,https://root.cern,https://root.cern/doc/master/classRooProjectedPdf.html,1,['log'],['logic']
Testability,"rval(); static TClass*Class(); virtual Double_tGetElement(Int_t position) const; virtual Double_tGetMax() const; virtual Double_tGetMean() const; virtual Double_tGetMin() const; virtual Int_tGetNbins() const; virtual Double_tGetRndm(TRandom3&) const; virtual Double_tGetStepSize(Int_t iBin = 0) const; virtual Double_tGetWidth() const; TMVA::IntervalInterval(const TMVA::Interval& other); TMVA::IntervalInterval(Double_t min, Double_t max, Int_t nbins = 0); virtual TClass*IsA() const; TMVA::Interval&operator=(const TMVA::Interval&); virtual voidPrint(ostream& os) const; voidSetMax(Double_t m); voidSetMin(Double_t m); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TMVA::MsgLogger&Log() const. Data Members; protected:. Double_tfMaxthe constraints of the Interval; Double_tfMin; Int_tfNbinswhen >0 : number of bins (discrete interval); when ==0 continuous interval. private:. static TMVA::MsgLogger*fgLoggermessage logger. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Interval(Double_t min, Double_t max, Int_t nbins = 0). Interval(const TMVA::Interval& other). ~Interval(); destructor. Double_t GetElement(Int_t position) const; calculates the value of the ""number"" bin in a discrete interval.; Parameters:; Double_t position. Double_t GetStepSize(Int_t iBin = 0) const; retuns the step size between the numbers of a ""discrete Interval"". Double_t GetRndm(TRandom3& ) const; get uniformely distributed number within interval. Double_t GetWidth() const. Double_t GetMean() const. void Print(ostream& os) const. Double_t GetMin() const; accessors; accessors. { return fMin; }. Double_t GetMax() const; { return fMax; }. Int_t GetNbins() const; { return fNbins; }. void SetMax(Double_t m); { fMax = m; }. void SetMin(Double_t m); { fMin = m; }. » Author: Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-03-14",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__Interval.html:2232,log,logger,2232,root/html534/TMVA__Interval.html,https://root.cern,https://root.cern/root/html534/TMVA__Interval.html,1,['log'],['logger']
Testability,"rve * TMVA::Experimental::ClassificationResult::GetROC ; (; UInt_t ; iClass = 0, . TMVA::Types::ETreeType ; type = TMVA::Types::kTesting . ). Method to get TMVA::ROCCurve Object. ; Parameters. iClasscategory, default 0 then signal ; typetrain/test tree, default test. . ReturnsTMVA::ROCCurve object. ; Definition at line 93 of file Classification.cxx. ◆ GetROCGraph(). TGraph * TMVA::Experimental::ClassificationResult::GetROCGraph ; (; UInt_t ; iClass = 0, . TMVA::Types::ETreeType ; type = TMVA::Types::kTesting . ). Method to get TGraph object with the ROC curve. ; Parameters. iClasscategory, default 0 then signal ; typetrain/test tree, default test. . ReturnsTGraph object. ; Definition at line 149 of file Classification.cxx. ◆ GetROCIntegral(). Double_t TMVA::Experimental::ClassificationResult::GetROCIntegral ; (; UInt_t ; iClass = 0, . TMVA::Types::ETreeType ; type = TMVA::Types::kTesting . ). Method to get ROC-Integral value from mvas. ; Parameters. iClasscategory, default 0 then signal ; typetrain/test tree, default test. . ReturnsDouble_t with the ROC-Integral value. ; Definition at line 74 of file Classification.cxx. ◆ IsA(). virtual TClass * TMVA::Experimental::ClassificationResult::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 159 of file Classification.h. ◆ IsCutsMethod(). Bool_t TMVA::Experimental::ClassificationResult::IsCutsMethod ; (; ). inline . Definition at line 152 of file Classification.h. ◆ IsMethod(). Bool_t TMVA::Experimental::ClassificationResult::IsMethod ; (; TString ; methodname, . TString ; methodtitle . ). private . Method to check if method was booked. ; Parameters. methodnamename of the method. ; methodtitlemethod title. . Returnsboolean true if the method was booked, false in other case. ; Definition at line 166 of file Classification.cxx. ◆ operator=(). TMVA::Experimental::ClassificationResult & TMVA::Experimental::ClassificationResult::operator= ; (; const Clas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Experimental_1_1ClassificationResult.html:14271,test,test,14271,doc/master/classTMVA_1_1Experimental_1_1ClassificationResult.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Experimental_1_1ClassificationResult.html,2,['test'],['test']
Testability,"rverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); const RooArgSet&numIntCatVars() const; const RooArgSet&numIntRealVars() const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealIntegral.html:17649,test,testArg,17649,root/html532/RooRealIntegral.html,https://root.cern,https://root.cern/root/html532/RooRealIntegral.html,1,['test'],['testArg']
Testability,"rward declare template specialization with enumerator as template arg; [#7454] - [RF][Docs] Breaking changes of batch computation interface not documented in release notes; [#7558] - AfterImage compilation broken with binutils 2.36; [#7507] - [tree] Possible error in TLeaf::GetLeafCounter; [#7361] - RooFit backend library: force to specific architecture; [#7362] - Incremental build problems; [#7319] - [Hist] Wrong computation in TH3::GetCovariance for diagonal elements; [#7206] - Unable to build with builtin_cling=OFF for LLVM 9; [#7157] - RooFFTConvPdf doesn’t work with RooProdPdf; [#7076] - RNTuple, parallel unzip tear down race condition; [#7021] - cling depends on exact macOS SDK headers; [#6953] - Missing documentation for ROOT.RDF.MakeNumpyDataFrame; [#6421] - Proposal to unify logging in Minuit2; [#7302] - TGraph copy constructor error; [#7212] - TMathText does not display with high value coordinates; [#6997] - Fill attribute is not fully reflected in THStack; [#6360] - [Docs] Missing figures in RDF tutorials 10[5,6,7] on doxygen; [#7093] - Race condition affecting (at least) TEnum::GetEnum; [#7054] - sporadic roottest-python-cmdLineUtils failures; [#6939] - Problems when TFile object is opened and closed on different threads.; [#6715] - [bug] Type overflow in TMessageHandler; [#7281] - Trailing dot dropped in top level branch name. Release 6.24/02; Published on June 28, 2021; RDataFrame. Scaling behavior at high core counts (32+ cores) has been improved (see also PR #8007). Bugs and Issues fixed in this release. [ROOT-9558] - [DF] RDataFrame Snapshot throws for branches with branch name!=variable name; [ROOT-10625] - Issues with RDataFrame if name and leaflist of a TBranch are different; [#6881] - [TTreeReader] Partial leaf/branch names not recognized in cases that TTree::Draw supports; [#7912] - TStreamerInfo Crash - V5 File Backward incompatibility introduced somewhere since 6.22.00; [#7903] - Invalid read in TClassEdit; [#7890] - Memory leak when running ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:46480,log,logging,46480,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['log'],['logging']
Testability,"ry function (integrand) ;  ; static PDF * ThisPDF (void);  . Private Attributes; TString fBorderMethodString;  ; Bool_t fCheckHist;  check of source histogram ;  ; Float_t fFineFactor;  fine tuning factor for Adaptive KDE ;  ; TGraph * fGraph;  ! needed to create PDF from histogram ;  ; TH1 * fHist;  copy of input histogram ;  ; Int_t fHistAvgEvtPerBin;  avg event per source hist bin ;  ; Int_t fHistDefinedNBins;  source hist bin num set by user ;  ; TH1 * fHistOriginal;  the input histogram ;  ; TF1 * fIGetVal;  integration interface ;  ; TString fInterpolateString;  ; TMVA::PDF::EInterpolateMethod fInterpolMethod;  interpolation method ;  ; KDEKernel::EKernelBorder fKDEborder;  The method to take care about ""border"" effects (string) ;  ; KDEKernel::EKernelIter fKDEiter;  Number of iterations (adaptive or not) ;  ; TString fKDEiterString;  ; KDEKernel::EKernelType fKDEtype;  Kernel type to use for KDE. ;  ; TString fKDEtypeString;  strings used to read definitions ;  ; MsgLogger * fLogger;  ! message logger ;  ; Int_t fMaxNsmooth;  Max number of smoothing iterations. ;  ; Int_t fMinNsmooth;  Min number of smoothing iterations. ;  ; Bool_t fNormalize;  normalize histogram (false for cumulative distribution used in GaussTranform) ;  ; Int_t fNsmooth;  Min number of smoothing iterations. ;  ; TH1 * fNSmoothHist;  number of smooth for each bin ;  ; TH1 * fPDFHist;  the high-binned histogram corresponding to the PDF ;  ; TString fPDFName;  for output ;  ; UInt_t fReadingVersion;  the TMVA version of the weight file ;  ; TSpline * fSpline;  ! the used spline type ;  ; TString fSuffix;  ! the suffix for options ;  ; Bool_t fUseHistogram;  . Static Private Attributes; static const Double_t fgEpsilon = 1.0e-12;  minimum PDF return ;  ; static const Bool_t fgManualIntegration = kTRUE;  manual integration (sum over bins) or DGAUSS ;  ; static const Int_t fgNbin_PdfHist = 10000;  number of bins in high-binned reference histogram ;  . Friends; std::ostream & operator<< (std::os",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1PDF.html:16774,log,logger,16774,doc/master/classTMVA_1_1PDF.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1PDF.html,1,['log'],['logger']
Testability,"ry vectors for 2,3 and 4 dimensions with their transformations) is not anymore part of MathCore, but is built as a separate library. MathCore contains instead now classes which were originally part of libCore. These include:. TMath : namespace with mathematical functions and basic function algorithms.; TComplex: class for complex numbers.; Random classes: base class TRandom and the derived classes TRandom1, TRandom2 and TRandom3, implementing the pseudo-random number generators.; Other classes, such as; TKDTree for partitioning the data using a kd-Tree and TKDTreeBinning for binning data using a kdTree; ROOT::Math::GoFTest for goodness of fit tests . Modules;  Fitting and Parameter Estimation;  Classes used for fitting (regression analysis) and estimation of parameter values given a data sample. ;  ;  Interface classes for Random number generation;  Pseudo-random numbers generator classes and for generation of random number distributions. ;  ;  Goodness of Fit Tests;  Classical one-dimensional goodness of git tests for unbinned data. ;  ;  Function Classes and Interfaces;  Interfaces (abstract classes) and Base classes used in MathCore and MathMore numerical methods for describing function classes. ;  ;  Numerical Algorithms;  Numerical Algorithm classes from the MathCore and MathMore libraries. ;  ;  Statistical functions;  Probability density functions, cumulative distribution functions and their inverses (quantiles) for various statistical distributions (continuous and discrete). ;  ;  Special functions;  Special mathematical functions. ;  . Files; file  RFit.hxx;  . Classes; class  ROOT::Math::Delaunay2D;  Class to generate a Delaunay triangulation of a 2D set of points. More...;  ; class  TKDTreeBinning;  <- TKDTreeBinning - A class providing multidimensional binning -> More...;  ; class  TStatistic;  Statistical variable, defined by its mean and variance (RMS). More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxyg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__MathCore.html:2469,test,tests,2469,doc/master/group__MathCore.html,https://root.cern,https://root.cern/doc/master/group__MathCore.html,1,['test'],['tests']
Testability,"ry vectors for 2,3 and 4 dimensions with their transformations) is not anymore part of MathCore, but is built as a separate library. MathCore contains instead now classes which were originally part of libCore. These include:. TMath : namespace with mathematical functions and basic function algorithms.; TComplex: class for complex numbers.; Random classes: base class TRandom and the derived classes TRandom1, TRandom2 and TRandom3, implementing the pseudo-random number generators.; Other classes, such as; TKDTree for partitioning the data using a kd-Tree and TKDTreeBinning for binning data using a kdTree; ROOT::Math::GoFTest for goodness of fit tests . Modules;  Fitting and Parameter Estimation;  Classes used for fitting (regression analysis) and estimation of parameter values given a data sample. ;  ;  Interface classes for Random number generation;  Pseudo-random numbers generator classes and for generation of random number distributions. ;  ;  Goodness of Fit Tests;  Classical one-dimensional goodness of git tests for unbinned data. ;  ;  Function Classes and Interfaces;  Interfaces (abstract classes) and Base classes used in MathCore and MathMore numerical methods for describing function classes. ;  ;  Numerical Algorithms;  Numerical Algorithm classes from the MathCore and MathMore libraries. ;  ;  Statistical functions;  Probability density functions, cumulative distribution functions and their inverses (quantiles) for various statistical distributions (continuous and discrete). ;  ;  Special functions;  Special mathematical functions. ;  . Files; file  RFit.hxx;  . Classes; class  ROOT::Math::Delaunay2D;  Class to generate a Delaunay triangulation of a 2D set of points. More...;  ; class  TKDTreeBinning;  <- TKDTreeBinning - A class providing multidimensional binning -> More...;  ; class  TStatistic;  Statistical variable, defined by its mean and variance (RMS). More...;  . ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:10:08 (GVA Time) using Doxyge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/group__MathCore.html:2468,test,tests,2468,doc/v632/group__MathCore.html,https://root.cern,https://root.cern/doc/v632/group__MathCore.html,1,['test'],['tests']
Testability,"ry, but just as a temporary structure helping temporary assembling and positioning volumes.; If we define now C as an assembly containing A and B, positioning the assembly into D,E and F will actually position only A and Bdirectly into these volumes, taking into account their combined transformations A/B to C and C to D/E/F. This looks much nicer, is it? In fact, it is and it is not. Of course, we managed to get rid of the ‘unnecessary’ volume C in our geometry, but we end-up with a more flat structure for D,E and F (more daughters inside). This can get much worse when extensively used, as in the case: assemblies of assemblies.; For deciding what to choose between using virtual containers or assemblies for a specific case, one can use for both cases, after the geometry was closed:; gGeoManager->SetTopVolume(ptr_D);; gGeoManager->Test();; gGeoManager->RestoreMasterVolume();; The ptr_D is a pointer to volume D containing the interesting structure. The test will provide the timing for classifying 1 million random points inside D.; 18.4.2.5 Examples of Volume Positioning; Now let us make a simple volume representing a copper wire. We suppose that a medium is already created (see TGeoMedium class on how to create media).; We will create a TUBE shape for our wire, having Rmin=0cm, Rmax=0.01cm and a half-length dZ=1cm:; TGeoTube *tube = new TGeoTube(""wire_tube"",0,0.01,1);; One may omit the name for the shape wire_tube, if no retrieving by name is further needed during geometry building. Different volumes having different names and materials can share the same shape.; Now let’s make the volume for our wire:; TGeoVolume *wire_co = new TGeoVolume(""WIRE_CO"",tube,; ptrCOPPER); //(*); (*) Do not bother to delete the media, shapes or volumes that you have created since all will be automatically cleaned on exit by the manager class.; If we would have taken a look inside TGeoManager::MakeTube() method, we would have been able to create our wire with a single line:; TGeoVolume *wire_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:943620,test,test,943620,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['test'],['test']
Testability,"ry::CalcCorrelationMatrix ; (; DataSet * ; ds, . const UInt_t ; classNumber . ). protected . computes correlation matrix for variables ""theVars"" in tree; ""theType"" defines the required event ""type"" (""type"" variable must be present in tree) ; Definition at line 548 of file DataSetFactory.cxx. ◆ CalcCovarianceMatrix(). TMatrixD * TMVA::DataSetFactory::CalcCovarianceMatrix ; (; DataSet * ; ds, . const UInt_t ; classNumber . ). protected . compute covariance matrix ; Definition at line 579 of file DataSetFactory.cxx. ◆ CalcMinMax(). void TMVA::DataSetFactory::CalcMinMax ; (; DataSet * ; ds, . TMVA::DataSetInfo & ; dsi . ). protected . compute covariance matrix ; Definition at line 479 of file DataSetFactory.cxx. ◆ ChangeToNewTree(). void TMVA::DataSetFactory::ChangeToNewTree ; (; TreeInfo & ; tinfo, . const DataSetInfo & ; dsi . ). protected . While the data gets copied into the local training and testing trees, the input tree can change (for instance when changing from signal to background tree, or using TChains as input) The TTreeFormulas, that hold the input expressions need to be re-associated with the new tree, which is done here. ; Definition at line 293 of file DataSetFactory.cxx. ◆ CheckTTreeFormula(). Bool_t TMVA::DataSetFactory::CheckTTreeFormula ; (; TTreeFormula * ; ttf, . const TString & ; expression, . Bool_t & ; hasDollar . ). protected . checks a TTreeFormula for problems ; Definition at line 251 of file DataSetFactory.cxx. ◆ Class(). static TClass * TMVA::DataSetFactory::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMVA::DataSetFactory::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMVA::DataSetFactory::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 238 of file DataSetFactory.h. ◆ CreateDataSet(). TMVA::DataSet * TMVA::DataSetFactory::CreateDataSet ; (; TMVA::DataSetInfo & ; dsi, . TMVA::DataInputHa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DataSetFactory.html:17475,test,testing,17475,doc/master/classTMVA_1_1DataSetFactory.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DataSetFactory.html,1,['test'],['testing']
Testability,"rystalball function Parameters can be set: ;  ; file  fitpanel_playback.C;  This file will test all the transient frames (aka Dialog windows) displayed in the fitpanel, as the rest of the functionality is tried automatically with the UnitTest.C unit. ;  ; file  fitslicesy.C;   Illustrates how to use the TH1::FitSlicesY function It uses the TH2F histogram generated in macro hsimple.C It invokes FitSlicesY and draw the fitted ""mean"" and ""sigma"" in 2 sepate pads. ;  ; file  FittingDemo.C;   Example for fitting signal/background. ;  ; file  graph2dfit.C;   Fitting a TGraph2D ;  ; file  Ifit.C;   Example of a program to fit non-equidistant data points ;  ; file  langaus.C;   Convoluted Landau and Gaussian Fitting Function (using ROOT's Landau and Gauss functions) ;  ; file  line3Dfit.C;   Fitting of a TGraph2D with a 3D straight line ;  ; file  minuit2FitBench.C;   Demonstrate performance and usage of Minuit2 and Fumili2 for monodimensional fits. ;  ; file  minuit2FitBench2D.C;   Minuit2 fit 2D benchmark. ;  ; file  minuit2GausFit.C;   Perform fits with different configurations using Minuit2 ;  ; file  multidimfit.C;   Multi-Dimensional Parametrisation and Fitting ;  ; file  multifit.C;   Fitting multiple functions to different ranges of a 1-D histogram Example showing how to fit in a sub-range of an histogram A histogram is created and filled with the bin contents and errors defined in the table below. ;  ; file  multifit.py;   Fitting multiple functions to different ranges of a 1-D histogram Example showing how to fit in a sub-range of an histogram A histogram is created and filled with the bin contents and errors defined in the table below. ;  ; file  myfit.C;   Get in memory an histogram from a root file and fit a user defined function. ;  ; file  NumericalMinimization.C;   Example on how to use the new Minimizer class in ROOT Show usage with all the possible minimizers. ;  ; file  qa2.C;   Test generation of random numbers distributed according to a function defined",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__fit.html:3844,benchmark,benchmark,3844,doc/master/group__tutorial__fit.html,https://root.cern,https://root.cern/doc/master/group__tutorial__fit.html,1,['benchmark'],['benchmark']
Testability,"s ""Background""; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Background""; <HEADER> Factory : Test all methods; <HEADER> Factory : Test method: Fisher for Classification performance; : ; <HEADER> Fisher : [dataset] : Evaluation of Fisher on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00318 sec ; <HEADER> Factory : Test method: Likelihood for Classification performance; : ; <HEADER> Likelihood : [dataset] : Evaluation of Likelihood on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00959 sec ; <HEADER> Factory : Test method: FisherCat for Classification performance; : ; <HEADER> Category_Fisher_1 : [Category_Fisher_1_dsi] : Evaluation of Category_Fisher_1 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00192 sec ; <HEADER> Category_Fisher_2 : [Category_Fisher_2_dsi] : Evaluation of Category_Fisher_2 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00196 sec ; <HEADER> Factory : Test method: LikelihoodCat for Classification performance; : ; <HEADER> Category_Likelihood_1 : [Category_Likelihood_1_dsi] : Evaluation of Category_Likelihood_1 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00948 sec ; <HEADER> Category_Likelihood_2 : [Category_Likelihood_2_dsi] : Evaluation of Category_Likelihood_2 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00932 sec ; <HEADER> Factory : Evaluate all methods; <HEADER> Factory : Evaluate classifier: Fisher; : ; <HEADER> Fisher : [dataset] : Loop over test events and fill histograms with classifier response...; : ; <HEADER> TFHandler_Fisher : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: -0.014081 1.2910 [ -5.3119 4.5609 ]; : var2: -0.014399 1.3299 [ -4.7537 4.6723 ]; : var3: -0.027971",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassificationCategory_8C.html:23406,test,testing,23406,doc/master/TMVAClassificationCategory_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html,1,['test'],['testing']
Testability,"s (Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) override;  Return pad axis coordinates range. ;  ; TObject * GetSelected () const override;  Get selected. ;  ; TVirtualPad * GetSelectedPad () const override;  Get selected pad. ;  ; Double_t GetTheta () const override;  ; Int_t GetTickx () const override;  ; Int_t GetTicky () const override;  ; const char * GetTitle () const override;  Returns title of object. ;  ; Double_t GetUxmax () const override;  Returns the maximum x-coordinate value visible on the pad. If log axis the returned value is in decades. ;  ; Double_t GetUxmin () const override;  Returns the minimum x-coordinate value visible on the pad. If log axis the returned value is in decades. ;  ; Double_t GetUymax () const override;  Returns the maximum y-coordinate value visible on the pad. If log axis the returned value is in decades. ;  ; Double_t GetUymin () const override;  Returns the minimum y-coordinate value visible on the pad. If log axis the returned value is in decades. ;  ; TView * GetView () const override;  ; TObject * GetView3D () const override;  ; TVirtualViewer3D * GetViewer3D (Option_t *type="""") override;  Create/obtain handle to 3D viewer. ;  ; TVirtualPad * GetVirtCanvas () const override;  Get virtual canvas. ;  ; UInt_t GetWh () const override;  Get Wh. ;  ; Double_t GetWNDC () const override;  Get width of pad along X in Normalized Coordinates (NDC) ;  ; UInt_t GetWw () const override;  Get Ww. ;  ; Double_t GetX1 () const override;  ; Double_t GetX2 () const override;  ; Double_t GetXlowNDC () const override;  ; Double_t GetY1 () const override;  ; Double_t GetY2 () const override;  ; Double_t GetYlowNDC () const override;  ; Bool_t HasCrosshair () const override;  Return kTRUE if the crosshair has been activated (via SetCrosshair). ;  ; Bool_t HasFixedAspectRatio () const override;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t HasViewer3D () const override;  ; void HighLight (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTCanvas.html:19891,log,log,19891,doc/v632/classTCanvas.html,https://root.cern,https://root.cern/doc/v632/classTCanvas.html,8,['log'],['log']
Testability,"s (Methods); public:. stringCleanType(const char* typeDesc, int mode = 0, const char** tail = 0); stringGetLong64_Name(const string& original); intGetSplit(const char* type, vector<std::string>& output, int& nestedLoc); stringInsertStd(const char* tname); boolIsDefAlloc(const char* alloc, const char* classname); boolIsDefAlloc(const char* alloc, const char* keyclassname, const char* valueclassname); boolIsDefComp(const char* comp, const char* classname); boolIsStdClass(const char* type); boolIsSTLBitset(const char* type); intIsSTLCont(const char* type, int testAlloc = 0); boolIsVectorBool(const char* name); stringResolveTypedef(const char* tname, bool resolveAll = false); stringShortType(const char* typeDesc, int mode); intSTLArgs(int kind); intSTLKind(const char* type). Data Members. Class Charts; Function documentation; std::string CleanType(const char* typeDesc, int mode = 0, const char** tail = 0). bool IsDefAlloc(const char* alloc, const char* classname). bool IsDefAlloc(const char* alloc, const char* keyclassname, const char* valueclassname). bool IsDefComp(const char* comp, const char* classname). bool IsSTLBitset(const char* type). int IsSTLCont(const char* type, int testAlloc = 0). bool IsStdClass(const char* type). bool IsVectorBool(const char* name). std::string GetLong64_Name(const string& original). int GetSplit(const char* type, vector<std::string>& output, int& nestedLoc). int STLKind(const char* type). int STLArgs(int kind). std::string ResolveTypedef(const char* tname, bool resolveAll = false). std::string ShortType(const char* typeDesc, int mode). std::string InsertStd(const char* tname). » Author: Victor Perev 10/04/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TClassEdit.h 28776 2009-06-02 15:16:39Z pcanal $ » Last generated: 2009-12-07 15:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TClassEdit.html:1471,test,testAlloc,1471,root/html526/TClassEdit.html,https://root.cern,https://root.cern/root/html526/TClassEdit.html,1,['test'],['testAlloc']
Testability,"s * TRatioPlot::GetUpperRefXaxis ; (; ); const. Gets the x axis of the object returned by TRatioPlot::GetUpperRefObject. ; Definition at line 755 of file TRatioPlot.cxx. ◆ GetUpperRefYaxis(). TAxis * TRatioPlot::GetUpperRefYaxis ; (; ); const. Gets the y axis of the object returned by TRatioPlot::GetUpperRefObject. ; Definition at line 774 of file TRatioPlot.cxx. ◆ GetUpYaxis(). TAxis * TRatioPlot::GetUpYaxis ; (; ); const. inline . Definition at line 187 of file TRatioPlot.h. ◆ GetXaxis(). TAxis * TRatioPlot::GetXaxis ; (; ); const. inline . Definition at line 186 of file TRatioPlot.h. ◆ ImportAxisAttributes(). void TRatioPlot::ImportAxisAttributes ; (; TGaxis * ; gaxis, . TAxis * ; axis . ). protected . Internal method to import TAxis attributes to a TGaxis. ; Copied from TGaxis::ImportAxisAttributes ; Definition at line 1710 of file TRatioPlot.cxx. ◆ Init(). void TRatioPlot::Init ; (; TH1 * ; h1, . TH1 * ; h2, . Option_t * ; option = """" . ). protectedvirtual . Internal method that shares constructor logic. ; Definition at line 128 of file TRatioPlot.cxx. ◆ IsA(). TClass * TRatioPlot::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 249 of file TRatioPlot.h. ◆ operator=(). TRatioPlot & TRatioPlot::operator= ; (; const TRatioPlot & ; ). privatedelete . ◆ Paint(). void TRatioPlot::Paint ; (; Option_t * ; opt = """"). overridevirtual . Update the visual axes and grid lines when painting. ; Reimplemented from TObject.; Definition at line 875 of file TRatioPlot.cxx. ◆ RangeAxisChanged(). void TRatioPlot::RangeAxisChanged ; (; ). Slot that receives the RangeAxisChanged signal from any of the pads and reacts correspondingly. ; Definition at line 1479 of file TRatioPlot.cxx. ◆ SetC1(). void TRatioPlot::SetC1 ; (; Double_t ; c1). inline . Definition at line 246 of file TRatioPlot.h. ◆ SetC2(). void TRatioPlot::SetC2 ; (; Double_t ; c2). inline . Definition at line 247 of file TRatioPlot.h. ◆ S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRatioPlot.html:35811,log,logic,35811,doc/master/classTRatioPlot.html,https://root.cern,https://root.cern/doc/master/classTRatioPlot.html,1,['log'],['logic']
Testability,s . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Documentation Interfacing ROOT and Spark. Presently two ways are available to exploit the widely adopted Spark technology for carrying out ROOT based data analysis:. PyROOTSpark : offers the possibility to use a simple map reduce interface to run existing root code with a few changes on Spark resources. The key is to use the PyROOT inteface in combination with PySpark.; Spark-ROOT : offers the possibility to read ROOT files connecting the format directly to Spark's DataFrames/Datasets/RDDs. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/interfacing-root-and-spark.html:2896,test,tests,2896,d/interfacing-root-and-spark.html,https://root.cern,https://root.cern/d/interfacing-root-and-spark.html,1,['test'],['tests']
Testability,"s 0 in case of success and -1 in case of error. Int_t BuildPackage(const char* package, TProof::EBuildPackageOpt opt = kBuildAll, Int_t chkveropt = kCheckROOT); Build specified package. Executes the PROOF-INF/BUILD.sh; script if it exists on all unique nodes. If opt is kBuildOnSlavesNoWait; then submit build command to slaves, but don't wait; for results. If opt is kCollectBuildResults then collect result; from slaves. To be used on the master.; If opt = kBuildAll (default) then submit and wait for results; (to be used on the client).; Returns 0 in case of success and -1 in case of error. Int_t BuildPackageOnClient(const char* package, Int_t opt = 0, TString* path = 0, Int_t chkveropt = kCheckROOT); Build specified package on the client. Executes the PROOF-INF/BUILD.sh; script if it exists on the client.; If opt == 0, both the preparation and building phases are run.; If opt == 1, only the preparation phase (asserting and, eventually, downloading; of the package) is done; '*path' contains the full path to the; package to be passed in the next call; If opt == 2, only the building phase is run using *path .; Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::kBuildPackage; case). Keep in sync in case of changes. Int_t LoadPackage(const char* package, Bool_t notOnClient = kFALSE, TList* loadopts = 0, TList* workers = 0); Load specified package. Executes the PROOF-INF/SETUP.C script; on all active nodes. If notOnClient = true, don't load package; on the client. The default is to load the package also on the client.; The argument 'loadopts' specify a list of objects to be passed to the SETUP.; The objects in the list must be streamable; the SETUP macro will be executed; like this: SETUP.C(loadopts).; Returns 0 in case of success and -1 in case of error. Int_t LoadPackageOnClient(const char* package, TList* loadopts = 0); Load specified package in the client. Executes the PROOF-INF/SETUP.C; script on the clie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProof.html:74043,assert,asserting,74043,root/html602/TProof.html,https://root.cern,https://root.cern/root/html602/TProof.html,1,['assert'],['asserting']
Testability,"s ; Definition at line 98 of file TGLScenePad.h. ◆ CloseComposite(). void TGLScenePad::CloseComposite ; (; ). overridevirtual . Close composite container TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx for description of viewer architecture. ; Implements TVirtualViewer3D.; Definition at line 507 of file TGLScenePad.cxx. ◆ ComposePolymarker(). void TGLScenePad::ComposePolymarker ; (; const TList * ; padPrimitives). protected . Definition at line 709 of file TGLScenePad.cxx. ◆ CreateNewLogical(). TGLLogicalShape * TGLScenePad::CreateNewLogical ; (; const TBuffer3D & ; buffer); const. protected . Create and return a new TGLLogicalShape from the supplied buffer. ; Definition at line 616 of file TGLScenePad.cxx. ◆ CreateNewPhysical(). TGLPhysicalShape * TGLScenePad::CreateNewPhysical ; (; UInt_t ; physicalID, . const TBuffer3D & ; buffer, . const TGLLogicalShape & ; logical . ); const. protected . Create and return a new TGLPhysicalShape with id 'ID', using 'buffer' placement information (translation etc), and bound to suppled 'logical'. ; Definition at line 693 of file TGLScenePad.cxx. ◆ DeclFileName(). static const char * TGLScenePad::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 98 of file TGLScenePad.h. ◆ DistancetoPrimitive(). Int_t TGLScenePad::DistancetoPrimitive ; (; Int_t ; px, . Int_t ; py . ). inlineoverridevirtual . Computes distance from point (px,py) to the object. ; This member function must be implemented for each graphics primitive. This default function returns a big number (999999). ; Reimplemented from TObject.; Definition at line 83 of file TGLScenePad.h. ◆ EndScene(). void TGLScenePad::EndScene ; (; ). overridevirtual . End building of the scene. ; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx for description of viewer architecture ; Implements TVirtualViewer3D.; Definition at line 310 of file TGLScenePad.cxx. ◆ ExecuteEvent(). void T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLScenePad.html:29541,log,logical,29541,doc/master/classTGLScenePad.html,https://root.cern,https://root.cern/doc/master/classTGLScenePad.html,1,['log'],['logical']
Testability,"s ; charfPosposition, i.e. it is a left (l) or right (r) daughter ; TMVA::Node*fRightpointers to the two ""daughter"" nodes. private:. static Int_tfgCountcounter of all nodes present.. for debug.. to spot memory leaks... Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~Node(); node destructor. int GetCount(); retuns the global number of instantiated nodes. Int_t CountMeAndAllDaughters() const; recursively go through the part of the tree below this node and count all daughters. void* AddXMLTo(void* parent) const; add attributes to XML. void ReadXML(void* node, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); read attributes from XML. Node* CreateNode() const. Bool_t GoesRight(const TMVA::Event& ) const; test event if i{ decends the tree at this node to the right. Bool_t GoesLeft(const TMVA::Event& ) const; test event if it decends the tree at this node to the left. Node* GetLeft() const; test event if it is equal to the event that ""makes the node"" (just for the ""search tree""; return pointer to the left/right daughter or parent node. { return fLeft; }. Node* GetRight() const; { return fRight; }. Node* GetParent() const; { return fParent; }. void SetLeft(TMVA::Node* l); set pointer to the left/right daughter or parent node. { fLeft = l;}. void SetRight(TMVA::Node* r); { fRight = r;}. void SetParent(TMVA::Node* p); { fParent = p;}. void Print(ostream& os) const; printout of the node. void PrintRec(ostream& os) const; recursive printout of the node and it daughters. void AddAttributesToNode(void* node) const. void AddContentToNode(stringstream& s) const. void SetDepth(UInt_t d); Set depth, layer of the where the node is within the tree, seen from the top (root). {fDepth=d;}. UInt_t GetDepth() const; Return depth, layer of the where the node is within the tree, seen from the top (root). {return fDepth;}. void SetPos(char s); set node position, i.e, the node is a left (l) or right (r) daugther. {fPos=s;}. char GetPos() const; Return th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__Node.html:3296,test,test,3296,root/html528/TMVA__Node.html,https://root.cern,https://root.cern/root/html528/TMVA__Node.html,4,['test'],['test']
Testability,"s RooAbsArg object to the given ostream. ;  ; bool hasClients () const;  ; bool hasDataToken () const;  ; virtual bool hasRange (const char *) const;  ; virtual bool importWorkspaceHook (RooWorkspace &ws);  ; virtual bool inRange (const char *) const;  ; bool isConstant () const;  Check if the ""Constant"" attribute is set. ;  ; virtual bool isDerived () const;  Does value or shape of this arg depend on any other arg? ;  ; virtual bool isReducerNode () const;  ; bool IsSortable () const override;  ; bool localNoDirtyInhibit () const;  ; const TNamed * namePtr () const;  De-duplicated pointer to this object's name. ;  ; Int_t numProxies () const;  Return the number of registered proxies. ;  ; bool observableOverlaps (const RooAbsData *dset, const RooAbsArg &testArg) const;  Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ;  ; bool observableOverlaps (const RooArgSet *depList, const RooAbsArg &testArg) const;  Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ;  ; RooAbsArg & operator= (const RooAbsArg &other)=delete;  ; bool overlaps (const RooAbsArg &testArg, bool valueOnly=false) const;  Test if any of the nodes of tree are shared with that of the given tree. ;  ; const RooArgSet * ownedComponents () const;  ; void Print (Option_t *options=nullptr) const override;  Print the object to the defaultPrintStream(). ;  ; void printAddress (std::ostream &os) const override;  Print address of this RooAbsArg. ;  ; void printArgs (std::ostream &os) const override;  Print object arguments, ie its proxies. ;  ; void printClassName (std::ostream &os) const override;  Print object class name. ;  ; void printCompactTree (const char *indent="""", const char *fileName=nullptr, const char *namePat=nullptr, RooAbsArg *client=nullptr);  Print tree structure of expression tree on stdout, or to file if filename is specified. ;  ; void printCompactTree (std::o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMappedCategory.html:13494,test,testArg,13494,doc/master/classRooMappedCategory.html,https://root.cern,https://root.cern/doc/master/classRooMappedCategory.html,12,['test'],['testArg']
Testability,"s and recreate them from weight file - this ensures that the application; 1209 // of the methods (in TMVAClassificationApplication) is consistent with the results obtained; 1210 // in the testing; 1211 // Log() << Endl;; 1212 if (fModelPersistence) {; 1213 ; 1214 Log() << kHEADER << ""=== Destroy and recreate all methods via weight files for testing ==="" << Endl << Endl;; 1215 ; 1216 if (!IsSilentFile()); 1217 RootBaseDir()->cd();; 1218 ; 1219 // iterate through all booked methods; 1220 for (UInt_t i = 0; i < methods->size(); i++) {; 1221 ; 1222 MethodBase *m = dynamic_cast<MethodBase *>((*methods)[i]);; 1223 if (m == nullptr); 1224 continue;; 1225 ; 1226 TMVA::Types::EMVA methodType = m->GetMethodType();; 1227 TString weightfile = m->GetWeightFileName();; 1228 ; 1229 // decide if .txt or .xml file should be read:; 1230 if (READXML); 1231 weightfile.ReplaceAll("".txt"", "".xml"");; 1232 ; 1233 DataSetInfo &dataSetInfo = m->DataInfo();; 1234 TString testvarName = m->GetTestvarName();; 1235 delete m; // itrMethod[i];; 1236 ; 1237 // recreate; 1238 m = dynamic_cast<MethodBase *>(ClassifierFactory::Instance().Create(; 1239 Types::Instance().GetMethodName(methodType).Data(), dataSetInfo, weightfile));; 1240 if (m->GetMethodType() == Types::kCategory) {; 1241 MethodCategory *methCat = (dynamic_cast<MethodCategory *>(m));; 1242 if (!methCat); 1243 Log() << kFATAL << ""Method with type kCategory cannot be casted to MethodCategory. /Factory"" << Endl;; 1244 else; 1245 methCat->fDataSetManager = m->DataInfo().GetDataSetManager();; 1246 }; 1247 // ToDo, Do we need to fill the DataSetManager of MethodBoost here too?; 1248 ; 1249 TString wfileDir = m->DataInfo().GetName();; 1250 wfileDir += ""/"" + gConfig().GetIONames().fWeightFileDir;; 1251 m->SetWeightFileDir(wfileDir);; 1252 m->SetModelPersistence(fModelPersistence);; 1253 m->SetSilentFile(IsSilentFile());; 1254 m->SetAnalysisType(fAnalysisType);; 1255 m->SetupMethod();; 1256 m->ReadStateFromFile();; 1257 m->SetTestvarName(testvarNam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:50497,test,testvarName,50497,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['test'],['testvarName']
Testability,"s array. ;  ; void Streamer (TBuffer &) override;  Stream a class object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TH1;  ~TH1 () override;  Histogram default destructor. ;  ; virtual Bool_t Add (const TH1 *h, const TH1 *h2, Double_t c1=1, Double_t c2=1);  Replace contents of this histogram by the addition of h1 and h2. ;  ; virtual Bool_t Add (const TH1 *h1, Double_t c1=1);  Performs the operation: this = this + c1*h1 If errors are defined (see TH1::Sumw2), errors are also recalculated. ;  ; virtual Bool_t Add (TF1 *h1, Double_t c1=1, Option_t *option="""");  Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2), errors are also recalculated. ;  ; virtual Double_t AndersonDarlingTest (const TH1 *h2, Double_t &advalue) const;  Same function as above but returning also the test statistic value. ;  ; virtual Double_t AndersonDarlingTest (const TH1 *h2, Option_t *option="""") const;  Statistical test of compatibility in shape between this histogram and h2, using the Anderson-Darling 2 sample test. ;  ; void Browse (TBrowser *b) override;  Browse the Histogram object. ;  ; virtual Int_t BufferEmpty (Int_t action=0);  Fill histogram with all entries in the buffer. ;  ; virtual Bool_t CanExtendAllAxes () const;  Returns true if all axes are extendable. ;  ; virtual Double_t Chi2Test (const TH1 *h2, Option_t *option=""UU"", Double_t *res=nullptr) const;  \( \chi^{2} \) test for comparing weighted and unweighted histograms. ;  ; virtual Double_t Chi2TestX (const TH1 *h2, Double_t &chi2, Int_t &ndf, Int_t &igood, Option_t *option=""UU"", Double_t *res=nullptr) const;  The computation routine of the Chisquare test. ;  ; virtual Double_t Chisquare (TF1 *f1, Option_t *option="""") const;  Compute and return the chisquare of this histogram with respect to a function The chisquare is computed by weighting each histogram point by the bin error By default the full range of the histogram is used. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1C.html:2690,test,test,2690,doc/master/classTH1C.html,https://root.cern,https://root.cern/doc/master/classTH1C.html,12,['test'],['test']
Testability,"s at Google, or enable JavaScript to view them here. . ; Download . ; Download ROOT . ; All Releases . ; Documentation . ; Reference Manual . ; User's Guides . ; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome Development. The links in this menu and in the block on your right are intended for the ROOT developers and for people who want to contribute to the ROOT system. Quick Links; Jenkins Service; Jenkins How To; CDash; Coverity; Github; GitWeb; LXR; Jira; Conventions Violations; ROOT Logos; Upgrade of ROOTbinder. Sign in. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/development.html:2703,test,tests,2703,d/development.html,https://root.cern,https://root.cern/d/development.html,1,['test'],['tests']
Testability,"s bar to display training and testing. ModelPersistence = to save the trained model in xml or serialized files. Jobs = number of ml methods to test/train in parallel using MultiProc, requires to call Evaluate method. Basic example. void classification(UInt_t jobs = 2); {; TMVA::Tools::Instance();; ; TFile *input(0);; TString fname = ""./tmva_class_example.root"";; if (!gSystem->AccessPathName(fname)) {; input = TFile::Open(fname); // check if file in local directory exists; } else {; TFile::SetCacheFileDir(""."");; input = TFile::Open(""http://root.cern/files/tmva_class_example.root"", ""CACHEREAD"");; }; if (!input) {; std::cout << ""ERROR: could not open data file"" << std::endl;; exit(1);; }; ; // Register the training and test trees; ; TTree *signalTree = (TTree *)input->Get(""TreeS"");; TTree *background = (TTree *)input->Get(""TreeB"");; ; TMVA::DataLoader *dataloader = new TMVA::DataLoader(""dataset"");; ; dataloader->AddVariable(""myvar1 := var1+var2"", 'F');; dataloader->AddVariable(""myvar2 := var1-var2"", ""Expression 2"", """", 'F');; dataloader->AddVariable(""var3"", ""Variable 3"", ""units"", 'F');; dataloader->AddVariable(""var4"", ""Variable 4"", ""units"", 'F');; ; dataloader->AddSpectator(""spec1 := var1*2"", ""Spectator 1"", ""units"", 'F');; dataloader->AddSpectator(""spec2 := var1*3"", ""Spectator 2"", ""units"", 'F');; ; // global event weights per tree (see below for setting event-wise weights); Double_t signalWeight = 1.0;; Double_t backgroundWeight = 1.0;; ; dataloader->SetBackgroundWeightExpression(""weight"");; ; TMVA::Experimental::Classification *cl = new TMVA::Experimental::Classification(dataloader, Form(""Jobs=%d"", jobs));; ; cl->BookMethod(TMVA::Types::kBDT, ""BDTG"", ""!H:!V:NTrees=2000:MinNodeSize=2.5%:BoostType=Grad:Shrinkage=0.10:""; ""UseBaggedBoost:BaggedSampleFraction=0.5:nCuts=20:MaxDepth=2"");; cl->BookMethod(TMVA::Types::kSVM, ""SVM"", ""Gamma=0.25:Tol=0.001:VarTransform=Norm"");; ; cl->Evaluate(); // Train and Test all methods; ; auto &results = cl->GetResults();; ; TCanvas *c = new",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Classification.html:1597,test,test,1597,doc/master/classTMVA_1_1Classification.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Classification.html,1,['test'],['test']
Testability,"s cannot be computed in weighted likelihood fits"");; 455 fConfig.SetMinosErrors(false);; 456 }; 457 ; 458 ; 459 fBinFit = false;; 460 fDataSize = data->Size();; 461 ; 462#ifdef DEBUG; 463 int ipar = 0;; 464 std::cout << ""Fitter ParamSettings "" << Config().ParamsSettings()[ipar].IsBound() << "" lower limit "" << Config().ParamsSettings()[ipar].LowerLimit() << "" upper limit "" << Config().ParamsSettings()[ipar].UpperLimit() << std::endl;; 465#endif; 466 ; 467 // logl fit (error should be 0.5) set if different than default values (of 1); 468 if (fConfig.MinimizerOptions().ErrorDef() == gDefaultErrorDef ) {; 469 fConfig.MinimizerOptions().SetErrorDef(0.5);; 470 }; 471 ; 472 if (!fUseGradient) {; 473 // do minimization without using the gradient; 474 if (fFunc_v ){; 475 auto logl = std::make_unique<LogLikelihoodFCN<BaseFunc, IModelFunction_v>>(data, fFunc_v, useWeight, extended, executionPolicy);; 476 // do minimization; 477 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 478 } else {; 479 auto logl = std::make_unique<LogLikelihoodFCN<BaseFunc>>(data, fFunc, useWeight, extended, executionPolicy);; 480 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 481 }; 482 } else {; 483 // use gradient : check if fFunc provides gradient; 484 if (fConfig.MinimizerOptions().PrintLevel() > 0); 485 MATH_INFO_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""use gradient from model function"");; 486 if (extended) {; 487 MATH_WARN_MSG(""Fitter::DoUnbinnedLikelihoodFit"",; 488 ""Extended unbinned fit with gradient not yet supported - do a not-extended fit"");; 489 extended = false;; 490 }; 491 if (fFunc_v) {; 492 std::shared_ptr<IGradModelFunction_v> gradFun = std::dynamic_pointer_cast<IGradModelFunction_v>(fFunc_v);; 493 if (!gradFun) {; 494 MATH_ERROR_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 495 return false;; 496 }; 497 auto logl = std::make_unique<LogLikeli",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8cxx_source.html:17923,log,logl,17923,doc/master/Fitter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html,6,['log'],['logl']
Testability,s charts. ROOT; » TMVA; » TMVA::TActivationChooser. class TMVA::TActivationChooser. TActivationChooser. Class for easily choosing activation functions. Function Members (Methods); public:. virtual~TActivationChooser(); static TClass*Class(); TMVA::TActivation*CreateActivation(TMVA::TActivationChooser::EActivationType type) const; TMVA::TActivation*CreateActivation(const TString& type) const; vector<TString>*GetAllActivationNames() const; virtual TClass*IsA() const; TMVA::TActivationChooser&operator=(const TMVA::TActivationChooser&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); TMVA::TActivationChooserTActivationChooser(); TMVA::TActivationChooserTActivationChooser(const TMVA::TActivationChooser&). private:. TMVA::MsgLogger&Log() const. Data Members; public:. enum EActivationType { kLinear; kSigmoid; kTanh; kRadial; };. private:. TStringfLINEARactivation function name; TMVA::MsgLogger*fLogger! message logger; TStringfRADIALactivation function name; TStringfSIGMOIDactivation function name; TStringfTANHactivation function name. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TActivationChooser(); defaut constructor. ~TActivationChooser(); destructor. CreateActivation(EActivationType type); instantiate the correct activation object according to the; type choosen (given as the enumeration type). CreateActivation(const TString& type) const; instantiate the correct activation object according to the; type choosen (given by a TString). GetAllActivationNames() const; retuns the names of all know activation functions. TActivationChooser(). » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id: TActivationChooser.h 39395 2011-05-26 10:05:54Z moneta $ » Last generated: 2011-07-04 15:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__TActivationChooser.html:1211,log,logger,1211,root/html530/TMVA__TActivationChooser.html,https://root.cern,https://root.cern/root/html530/TMVA__TActivationChooser.html,1,['log'],['logger']
Testability,"s classes"" usage. ;  GUI tutorialsExample code which illustrates how to use the ROOT GUI ;  Histograms tutorialsExamples showing the ""histograms' classes"" usage. ;  HTTP tutorialsExamples showing the HTTP interface ;  Image tutorialsExamples showing the TImage class usage ;  IO tutorialsThese tutorials illustrate some of the capabilities of the ROOT IO subsystem ;  Math tutorialsExamples showing the Math classes ;  Matrix tutorialsExamples showing how to use TMatrix ;  Monte Carlo tutorialsMonte Carlo examples ;  TMemStat tutorialsExamples showing the TMemStat class ;  Multi Layer Perceptron tutorialsExamples showing the Multi Layer Perceptron classes ;  Multicore tutorialsThese examples aim to illustrate the multicore features of ROOT, such as thread awareness and safety, multithreading and multiprocessing ;  Net tutorialsExamples showing the net classes ;  Physics tutorialsPhysics examples ;  ►Proof tutorialsThese examples aim to illustrate the usage of PROOF ;  ProcFileElementsClass to hold information about the processed elements of a file ;  ProofAuxSelector used for auxiliary actions in the PROOF tutorials ;  ProofEventSelector for generic processing with Event ;  ProofEventProcSelector to process trees containing Event structures ;  ProofFriendsSelector to process tree friends ;  ProofNtupleSelector to fill a simple ntuple ;  ProofPythiaSelector to generate Monte Carlo events with Pythia8 ;  ProofSimpleSelector to fill a set of histograms ;  ProofSimpleFileSelector to fill a set of histograms and merging via file ;  ProofStdVecSelector for generic processing with stdlib collections ;  ProofTestsAuxilliary selector used to test PROOF functionality ;  PyRoot tutorialsExamples showing how to write python script for Root ;  Pythia tutorialsExamples showing the pythia usage ;  Quadratic programming package.Example showing the usage of the quadratic programming package quadp ;  R tutorialsExamples showing the R interface ;  RooFit TutorialsThese tutorials illustrate",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/modules.html:11635,test,test,11635,doc/v614/modules.html,https://root.cern,https://root.cern/doc/v614/modules.html,2,['test'],['test']
Testability,"s classes"" usage. ;  GUI tutorialsExample code which illustrates how to use the ROOT GUI ;  Histograms tutorialsExamples showing the ""histograms' classes"" usage. ;  HTTP tutorialsExamples showing the HTTP interface ;  Image tutorialsExamples showing the TImage class usage ;  IO tutorialsThese tutorials illustrate some of the capabilities of the ROOT IO subsystem ;  Math tutorialsExamples showing the Math classes ;  Matrix tutorialsExamples showing how to use TMatrix ;  Monte Carlo tutorialsMonte Carlo examples ;  TMemStat tutorialsExamples showing the TMemStat class ;  Multi Layer Perceptron tutorialsExamples showing the Multi Layer Perceptron classes ;  Multicore tutorialsThese examples aim to illustrate the multicore features of ROOT, such as thread awareness and safety, multithreading and multiprocessing ;  Net tutorialsExamples showing the net classes ;  Physics tutorialsPhysics examples ;  ►Proof tutorialsThese examples aim to illustrate the usage of PROOF ;  ProcFileElementsClass to hold information about the processed elements of a file ;  ProofAuxSelector used for auxiliary actions in the PROOF tutorials ;  ProofEventSelector for generic processing with Event ;  ProofEventProcSelector to process trees containing Event structures ;  ProofFriendsSelector to process tree friends ;  ProofNtupleSelector to fill a simple ntuple ;  ProofPythiaSelector to generate Monte Carlo events with Pythia8 ;  ProofSimpleSelector to fill a set of histograms ;  ProofSimpleFileSelector to fill a set of histograms and merging via file ;  ProofStdVecSelector for generic processing with stdlib collections ;  ProofTestsAuxilliary selector used to test PROOF functionality ;  PyRoot tutorialsExamples showing how to write python script for Root ;  Pythia tutorialsExamples showing the pythia usage ;  Quadratic programming package.Example showing the use of the quadratic programming package quadp ;  R tutorialsExamples showing the R interface ;  RooFit TutorialsThese tutorials illustrate t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/modules.html:11380,test,test,11380,doc/v610/modules.html,https://root.cern,https://root.cern/doc/v610/modules.html,2,['test'],['test']
Testability,"s connected with the original tree; 3691/// until the original tree is deleted. In particular, any changes; 3692/// to the branch addresses in the original tree are also made to; 3693/// the copied tree. Any changes made to the branch addresses of the; 3694/// copied tree are overridden anytime the original tree changes its; 3695/// branch addresses. When the original tree is deleted, all the; 3696/// branch addresses of the copied tree are set to zero.; 3697///; 3698/// For examples of CopyTree, see the tutorials:; 3699///; 3700/// - copytree.C:; 3701/// Example macro to copy a subset of a tree to a new tree.; 3702/// The input file was generated by running the program in; 3703/// $ROOTSYS/test/Event in this way:; 3704/// ~~~ {.cpp}; 3705/// ./Event 1000 1 1 1; 3706/// ~~~; 3707/// - copytree2.C; 3708/// Example macro to copy a subset of a tree to a new tree.; 3709/// One branch of the new tree is written to a separate file.; 3710/// The input file was generated by running the program in; 3711/// $ROOTSYS/test/Event in this way:; 3712/// ~~~ {.cpp}; 3713/// ./Event 1000 1 1 1; 3714/// ~~~; 3715/// - copytree3.C; 3716/// Example macro to copy a subset of a tree to a new tree.; 3717/// Only selected entries are copied to the new tree.; 3718/// NOTE that only the active branches are copied.; 3719 ; 3720TTree* TTree::CopyTree(const char* selection, Option_t* option /* = 0 */, Long64_t nentries /* = TTree::kMaxEntries */, Long64_t firstentry /* = 0 */); 3721{; 3722 GetPlayer();; 3723 if (fPlayer) {; 3724 return fPlayer->CopyTree(selection, option, nentries, firstentry);; 3725 }; 3726 return nullptr;; 3727}; 3728 ; 3729////////////////////////////////////////////////////////////////////////////////; 3730/// Create a basket for this tree and given branch.; 3731 ; 3732TBasket* TTree::CreateBasket(TBranch* branch); 3733{; 3734 if (!branch) {; 3735 return nullptr;; 3736 }; 3737 return new TBasket(branch->GetName(), GetName(), branch);; 3738}; 3739 ; 3740/////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:146464,test,test,146464,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['test'],['test']
Testability,"s containing 'txt', starting from line 'from'. ; Print the lines where this happens. ; Definition at line 261 of file TProofLog.cxx. ◆ IsA(). TClass * TProofLog::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Definition at line 75 of file TProofLog.h. ◆ LogToBox(). Bool_t TProofLog::LogToBox ; (; ). inline . Definition at line 71 of file TProofLog.h. ◆ Print(). void TProofLog::Print ; (; Option_t * ; opt = 0); const. overridevirtual . Print head info about the content. ; Reimplemented from TNamed.; Definition at line 158 of file TProofLog.cxx. ◆ Prt(). void TProofLog::Prt ; (; const char * ; what, . Bool_t ; newline = kTRUE . ). Special printing procedure. ; Definition at line 181 of file TProofLog.cxx. ◆ Retrieve(). Int_t TProofLog::Retrieve ; (; const char * ; ord = ""*"", . TProofLog::ERetrieveOpt ; opt = TProofLog::kTrailing, . const char * ; fname = 0, . const char * ; pattern = 0 . ). Retrieve the content of the log file associated with worker 'ord'. ; If 'ord' is ""*"" (default), all the workers are retrieved. If 'all' is true, the whole files are retrieved; else a max of fgMaxTransferSize (about 1000 lines) per file is read, starting from the end (i.e. the last ~1000 lines). The received buffer is added to the file fname, if the latter is defined. If opt == TProofLog::kGrep only the lines containing 'pattern' are retrieved (remote grep functionality); to filter out a pattern 'pat' use pattern = ""-v pat"". Return 0 on success, -1 in case of any error. ; Definition at line 87 of file TProofLog.cxx. ◆ Save(). Int_t TProofLog::Save ; (; const char * ; ord = ""*"", . const char * ; fname = 0, . Option_t * ; opt = ""w"" . ). Save the content associated with worker 'ord' to finel 'fname'. ; If 'ord' is ""*"" (default), the log from all the workers is saved. If 'opt' is ""a"" the file is open in append mode; otherwise the file is truncated. ; Definition at line 201 of file TProofLog.cxx. ◆ SetLogToBox(). void TProo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLog.html:20191,log,log,20191,doc/master/classTProofLog.html,https://root.cern,https://root.cern/doc/master/classTProofLog.html,1,['log'],['log']
Testability,"s definition ;  ContourList.C Getting Contours From TH2D ;  cumulative.C Illustrate use of the TH1::GetCumulative method ;  draw2dopt.C Display the various 2-d drawing options ;  DynamicSlice.C Show the slice of a TH2 following the mouse position ;  exec1.CEcho object at mouse position ;  exec2.CEcho object at mouse position and show a graphics line ;  Fibonacci.C A TH2Poly build with Fibonacci numbers ;  fillrandom.C Fill a 1-D histogram from a parametric function ;  FirstContour.C Make a contour plot and get the first contour in a TPolyMarker ;  greyscale.C Create grey scale of 200 x 200 boxes ;  h1draw.C 1-D histogram drawing options ;  hbars.C Example of bar charts with 1-d histograms ;  hksimple.C Illustrates the advantages of a TH1K histogram ;  hlabels1.C 1-D histograms with alphanumeric labels ;  hlabels2.C 2-D histograms with alphanumeric labels ;  hstack.C Example of stacked histograms: class THStack ;  hsum.C Histograms filled and drawn in a loop ;  hsumTimer.C Demo of Timers ;  logscales.C Draw parametric functions with log scales ;  multicolor.C Use a THStack to show a 2-D hist with cells with different colors ;  ratioplot1.C Example creating a simple ratio plot of two histograms using the pois division option ;  ratioplot2.C Example of a fit residual plot ;  ratioplot3.C Example which shows how you can get the graph of the lower plot and set the y axis range for it ;  ratioplot4.C Example that shows custom dashed lines on the lower plot, specified by a vector of floats ;  ratioplot5.C Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors ;  ratioplot6.C Example showing a fit residual plot, where the separation margin has been set to 0 ;  ratioplotOld.CExample displaying two histograms and their ratio ;  rebin.C Rebin a variable bin-width histogram ;  reverseaxis.C Example showing an histogram with reverse axis ;  sparsehist.CEvaluate the performance of THnSparse vs TH1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:122758,log,logscales,122758,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,1,['log'],['logscales']
Testability,"s describing current object ; Reimplemented from TGTransientFrame.; Definition at line 93 of file TProofProgressLog.h. ◆ LoadBuffer(). void TProofProgressLog::LoadBuffer ; (; const char * ; buffer). Load a text buffer in the window. ; Definition at line 280 of file TProofProgressLog.cxx. ◆ LoadFile(). void TProofProgressLog::LoadFile ; (; const char * ; file). Load a file in the window. ; Definition at line 289 of file TProofProgressLog.cxx. ◆ LogMessage(). void TProofProgressLog::LogMessage ; (; const char * ; msg, . Bool_t ; all . ). Load/append a log msg in the log frame, if open. ; Definition at line 519 of file TProofProgressLog.cxx. ◆ NoLineEntry(). void TProofProgressLog::NoLineEntry ; (; ). Enable/disable the line number entry. ; Definition at line 599 of file TProofProgressLog.cxx. ◆ Popup(). void TProofProgressLog::Popup ; (; ). Show log window. ; Definition at line 263 of file TProofProgressLog.cxx. ◆ Rebuild(). void TProofProgressLog::Rebuild ; (; ). Rebuild the log info for a new entered session. ; Definition at line 635 of file TProofProgressLog.cxx. ◆ SaveToFile(). void TProofProgressLog::SaveToFile ; (; ). Save the logs to a file Only the name of the file is taken, no expansion. ; Definition at line 534 of file TProofProgressLog.cxx. ◆ Select(). void TProofProgressLog::Select ; (; Int_t ; id, . Bool_t ; all = kTRUE . ). actions of select all/clear all button ; Definition at line 614 of file TProofProgressLog.cxx. ◆ SetGrepView(). void TProofProgressLog::SetGrepView ; (; ). Sets the view of grep filters according to the value of checkboxes. ; Definition at line 570 of file TProofProgressLog.cxx. ◆ SetUrl(). void TProofProgressLog::SetUrl ; (; const char * ; url). inline . Definition at line 89 of file TProofProgressLog.h. ◆ Streamer(). void TProofProgressLog::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGTransientFrame. ◆ StreamerNVirtual(). void TProofProgressLog::StreamerNVirtual ; (; TB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofProgressLog.html:41906,log,log,41906,doc/master/classTProofProgressLog.html,https://root.cern,https://root.cern/doc/master/classTProofProgressLog.html,1,['log'],['log']
Testability,"s description; function members; data members; class charts. ROOT; » GUI; » RECORDER; » TRecWinPair. class TRecWinPair: public TObject. ROOT EVENT RECORDING SYSTEM. TRecorder class provides interface for recording and replaying; events in ROOT.; Recorded events are:; - Commands typed by user in commandline ('new TCanvas'); - GUI events (mouse movement, button clicks, ...). All the recorded events from one session are stored in one TFile; and can be replayed again anytime. Recording. 1] To start recording. TRecorder r(const char *filename, ""NEW""); TRecorder r(const char *filename, ""RECREATE""). or:. TRecorder *recorder = new TRecorder;; recorder->Start(const char *filename, ...). -filename Name of ROOT file in which to save; recorded events. 2] To stop recording. recorder->Stop(). IMPORTANT:; State capturing is part of recording. It means that if you want to; record events for some object (window), creation of this object; must be also recorded. Example:. t = new TRecorder(); // Create a new recorder; t->Start(""logfile.root""); // ! Start recording first. c = new TCanvas(); // ! Then, create an object; c->Dump(); // Work with that object. t->Stop(); // Stop recording. It is strongly recommended to start recording with empty ROOT; environment, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows dur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRecWinPair.html:1186,log,logfile,1186,root/html528/TRecWinPair.html,https://root.cern,https://root.cern/root/html528/TRecWinPair.html,6,['log'],['logfile']
Testability,"s desired (more speed), a RooBinSamplingPdf has to be created manually, and its integrator; 921 * has to be manipulated directly.; 922 * - precision = 0: Activate bin integration only for continuous PDFs fit to a RooDataHist.; 923 * - precision < 0: Deactivate.; 924 * \see RooBinSamplingPdf; 925 * <tr><td> `ModularL(bool flag)` <td> Enable or disable modular likelihoods, which will become the default in a future release.; 926 * This does not change any user-facing code, but only enables a different likelihood class in the back-end. Note that this; 927 * should be set to true for parallel minimization of likelihoods!; 928 * Note that it is currently not recommended to use Modular likelihoods without any parallelization enabled in the minimization, since; 929 * some features such as offsetting might not yet work in this case.; 930 * </table>; 931 */; 932 ; 933 ; 934/** @brief Protected implementation of the NLL creation routine.; 935 *; 936 * This virtual function can be overridden in case you want to change the NLL creation logic for custom PDFs.; 937 *; 938 * \note Never call this function directly. Instead, call RooAbsPdf::createNLL().; 939 */; 940 ; 941std::unique_ptr<RooAbsReal> RooAbsPdf::createNLLImpl(RooAbsData &data, const RooLinkedList &cmdList); 942{; 943 return RooFit::FitHelpers::createNLL(*this, data, cmdList);; 944}; 945 ; 946 ; 947/** @fn RooAbsPdf::fitTo(); 948 *; 949 * @brief Fit PDF to given dataset.; 950 *; 951 * If dataset is unbinned, an unbinned maximum likelihood is performed.; 952 * If the dataset is binned, a binned maximum likelihood is performed.; 953 * By default the fit is executed through the MINUIT commands MIGRAD, HESSE in succession.; 954 *; 955 * @param data Reference to a RooAbsData object representing the dataset.; 956 * @param cmdArgs Variadic template arguments representing optional command arguments.; 957 * You can pass either an arbitrary number of RooCmdArg instances; 958 * or a single RooLinkedList that points to the RooCmdArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:43163,log,logic,43163,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['log'],['logic']
Testability,"s first found.; Implement here since it is faster (see comment in LocMin function) ; Definition at line 1012 of file TMath.h. ◆ LocMin() [1/2]. template<typename Iterator > . Iterator TMath::LocMin ; (; Iterator ; first, . Iterator ; last . ). Returns index of array with the minimum element. ; If more than one element is minimum returns first found. ; Definition at line 1000 of file TMath.h. ◆ LocMin() [2/2]. template<typename T > . Long64_t TMath::LocMin ; (; Long64_t ; n, . const T * ; a . ). Returns index of array with the minimum element. ; If more than one element is minimum returns first found.; Implement here since this one is found to be faster (mainly on 64 bit machines) than stl generic implementation. When performing the comparison, the STL implementation needs to de-reference both the array iterator and the iterator pointing to the resulting minimum location ; Definition at line 982 of file TMath.h. ◆ Log(). Double_t TMath::Log ; (; Double_t ; x). inline . Returns the natural logarithm of x. ; Definition at line 756 of file TMath.h. ◆ Log10(). Double_t TMath::Log10 ; (; Double_t ; x). inline . Returns the common (base-10) logarithm of x. ; Definition at line 762 of file TMath.h. ◆ Log2(). Double_t TMath::Log2 ; (; Double_t ; x). Returns the binary (base-2) logarithm of x. ; Definition at line 107 of file TMath.cxx. ◆ LogE(). constexpr Double_t TMath::LogE ; (; ). constexpr . Base-10 log of e (to convert ln to log) ; Definition at line 107 of file TMath.h. ◆ LogNormal(). Double_t TMath::LogNormal ; (; Double_t ; x, . Double_t ; sigma, . Double_t ; theta = 0, . Double_t ; m = 1 . ). Computes the density of LogNormal distribution at point x. ; Variable X has lognormal distribution if Y=Ln(X) has normal distribution; Parameters. [in]xis the evaluation point ; [in]sigmais the shape parameter ; [in]thetais the location parameter ; [in]mis the scale parameter. The formula was taken from ""Engineering Statistics Handbook"" on site http://www.itl.nist.gov/div898/ha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMath.html:60246,log,logarithm,60246,doc/master/namespaceTMath.html,https://root.cern,https://root.cern/doc/master/namespaceTMath.html,1,['log'],['logarithm']
Testability,"s for special authentication options; static ULong64_tTSocket::fgBytesRecvtotal bytes received by all socket objects; static ULong64_tTSocket::fgBytesSenttotal bytes sent by all socket objects; static Int_tTSocket::fgClientProtocolclient ""protocol"" version. private:. TMutex*fAMtxTo protect async msg queue; list<TXSockBuf*>fAQuelist of asynchronous messages; TSemaphorefASemControl access to conn async msg queue; Bool_tfAWaitkTRUE if waiting at the async msg queue; TSemaphorefAsynProcControl actions while processing async messages; TXSockBuf*fBufCurcurrent read buffer; TStringfBufferContainer for exchanging information; Int_tfByteCurcurrent position in the first buffer; Int_tfByteLeftbytes left in the first buffer; XrdProofConn*fConninstance of the underlying connection module; Bool_tfDontTimeoutIf true wait forever for incoming messages; TXHandler*fHandlerHandler of asynchronous events (input, error); TStringfHostRemote host; Bool_tfIForwardWhether the interrupt should be propagated; kXR_int32fILevHighest received interrupt; TMutex*fIMtxTo protect interrupt queue; Int_tfLogLevelLog level to be transmitted to servers; charfMode'e' (def) or 'i' (internal - proofsrv); Int_tfPid; Int_tfPortRemote port; Bool_tfRDInterruptTo interrupt waiting for messages; TObject*fReferenceGeneric object reference of this socket; kXR_int32fSendOptOptions for sending messages; Short_tfSessionIDproofsrv: remote ID of connected session; TStringfUserUsername used for login; Int_tfXrdProofdVersion; static Bool_tfgInitDoneAvoid initializing more than once; static TStringfgLocLocation string; static TXSockPipefgPipePipe for input monitoring; static TMutexfgSMtxTo protect spare list; static list<TXSockBuf*>fgSQuelist of spare buffers. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TSocket. XrdClientAbsUnsolMsgHandler. ←; TXSocket. ←. TXUnixSocket. Function documentation; void DoError(int level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protecte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXSocket.html:12933,log,login,12933,root/html602/TXSocket.html,https://root.cern,https://root.cern/root/html602/TXSocket.html,1,['log'],['login']
Testability,"s for special authentication options; static ULong64_tTSocket::fgBytesRecvtotal bytes received by all socket objects; static ULong64_tTSocket::fgBytesSenttotal bytes sent by all socket objects; static Int_tTSocket::fgClientProtocolclient ""protocol"" version. private:. TMutex*fAMtxTo protect async msg queue; list<TXSockBuf*>fAQuelist of asynchronous messages; TSemaphorefASemControl access to conn async msg queue; Bool_tfAWaitkTRUE if waiting at the async msg queue; TSemaphorefAsynProcControl actions while processing async messages; TXSockBuf*fBufCurcurrent read buffer; TStringfBufferContainer for exchanging information; Int_tfByteCurcurrent position in the first buffer; Int_tfByteLeftbytes left in the first buffer; XrdProofConn*fConninstance of the underlying connection module; Bool_tfDontTimeoutIf true wait forever for incoming messages; TXHandler*fHandlerHandler of asynchronous events (input, error); TStringfHostRemote host; Bool_tfIForwardWhether the interrupt should be propagated; kXR_int32fILevHighest received interrupt; TMutex*fIMtxTo protect interrupt queue; Int_tfLogLevelLog level to be transmitted to servers; charfMode'e' (def) or 'i' (internal - proofsrv); Int_tfPid; Int_tfPortRemote port; Bool_tfRDInterruptTo interrupt waiting for messages; TObject*fReferenceGeneric object reference of this socket; kXR_int32fSendOptOptions for sending messages; Short_tfSessionIDproofsrv: remote ID of connected session; TStringfUserUsername used for login; Int_tfXrdProofdVersion; static Bool_tfgInitDoneAvoid initializing more than once; static TStringfgLocLocation string; static TXSockPipefgPipePipe for input monitoring; static TMutexfgSMtxTo protect spare list; static list<TXSockBuf*>fgSQuelist of spare buffers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DoError(int level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protected). TXSocket(const char* url, Char_t mode = 'M', Int_t psi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TXSocket.html:12909,log,login,12909,root/html604/TXSocket.html,https://root.cern,https://root.cern/root/html604/TXSocket.html,1,['log'],['login']
Testability,s how to run items of work asynchronously with a TTaskGroup ;  mt302_TTaskGroupNested.C Calculate Fibonacci numbers exploiting nested parallelism through TTaskGroup ;  mt303_AsyncSimple.C Shows how to run items of work asynchronously with Async ;  mt304_AsyncNested.C Calculate Fibonacci numbers exploiting nested parallelism through Async ;  mt304_fillHistos.CFill histograms in parallel with automatic binning ;  mt305_TFuture.C Shows how to use the Future class of ROOT as a wrapper of std::future ;  mtbb001_fillHistos.C Fill histograms in parallel and write them on file ;  mtbb101_fillNtuples.C Fill n-tuples in distinct workers ;  mtbb201_parallelHistoFill.C Parallel fill of a histogram ;  ► net;  alien.C Example of use of the TAlien class (an implementation of TGrid) ;  authclient.CThis macro should be run together with authserv.C to test authentication between two remote ROOT sessions ;  authserv.CThis macro should be run together with authclient.C to test authentication between two remote ROOT sessions ;  fastMergeServer.CThis script shows how to make a simple iterative server that can receive TMemFile from multiple clients and merge them into a single file without block ;  hclient.CClient program which creates and fills a histogram ;  hclientbonj.CClient program which creates and fills a histogram ;  hcons.CHistogram consumer script ;  hprod.CHistogram producer script ;  hserv.CServer program which waits for two clients to connect ;  hserv2.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  hserv2bonj.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  LDAPExample.C;  parallelMergeClient.CClient program which creates and fills 2 histograms and a TTree ;  parallelMergeServer.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  parallel,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:136200,test,test,136200,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,1,['test'],['test']
Testability,s in External Applications? . How to let graphics primitives respond to a mouse click? . How to Pick Objects? . How to redraw Axis and plot borders? . How to reuse a color palette ? . How to set ranges on axis? . How to Use the Graphics Editor? . How to use the PostScript interface? . Linear Algebra. How to Create and Fill a Matrix? . How to Fit Histograms or Data Points? . How to fit using the FitPanel . How to Invert a Matrix . How to Perform a Linear Fit? . Multicore. How to express parallelism on many cores? . Histograms. How to Find Peaks in Histograms ? . How to Get Started with Histogram Classes? . How To Merge Histogram Files? . Input/Output. How to Merge Custom Objects? . How to Quickly Inspect the Content of a File? . How to Read Objects from a File? . How to Read Remote Files? . How to use the ClassDef Preprocessor Macro? . How to Write Objects to a File? . Trees. How to Read a Tree? . How to Use Chains (Lists of Files)? . How to Write a Tree? . Developer's Tips. How To Suppress Understood Valgrind False Positives? . Integrate ROOT into my project with CMake . Report a bug with JIRA . Running ROOT tests . Writing a Graphical User Interface. How to Use the ROOT GUI Builder? . How to Use the Signal/Slot Communication Mechanism? . Virtual Monte Carlo. How to Use Virtual Monte Carlo? . . Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/howtos.html:4069,test,tests,4069,d/howtos.html,https://root.cern,https://root.cern/d/howtos.html,2,['test'],['tests']
Testability,"s in TFile; 2D Histograms, Functions, 2D Fits; Graphics & PostScript; Subdirectories in a ROOT file; TNtuple, Selections, TCutG, TEventList; Split and Compression modes for Trees; Analyze Event.root file of stress 8; Create 10 files starting from Event.root; Test chains of Trees using the 10 files; Compare histograms of test 9 and 11; Merging files of a chain; Check correct rebuilt of Event.root in test 13; Divert Tree branches to separate files; Cling test (3 nested loops) with LHCb trigger. The program stress takes one argument, the number of events to process. The default is 1000 events. Be aware that executing stress with 1000 eventswill create several files consuming about 100 MB of disk space; running stress with 30 events will consume about 20 MB. The disk space is released once stress is done.; There are two ways to run stress:; From the system prompt or from the ROOT prompt using the interpreter.; > cd $ROOTSYS/test; > stress // default 1000 events; > stress 30 // test with 30 events; Start ROOT with the batch mode option (-b) to suppress the graphic output.; > root -b; root[] .L stress.cxx; root[] stress(1000)// test with 1000 events; root[] stress(30)// test with 30 events; The output of stress includes a pass/fail conclusion for each test, the total number of bytes read and written, and the elapsed real and CPU time. It also calculates a performance index for your machine relative to a reference machine a DELL Inspiron 7500 (Pentium III 600 MHz) with 256 MB of memory and 18GB IDE disk in ROOTMARKS. Higher ROOTMARKS means better performance. The reference machine has 200 ROOTMARKS, so the sample run below with 53.7 ROOTMARKS is about four times slower than the reference machine.; Here is a sample run:; % root -b; root[] .x stress.cxx(30). Test 1 : Functions, Random Numbers, Histogram Fits............. OK; Test 2 : Check size & compression factor of a Root file........ OK; Test 3 : Purge, Reuse of gaps in TFile......................... OK; Test 4 : Test of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1083670,test,test,1083670,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['test'],['test']
Testability,"s in a TList all found datasets. ;  ; Long64_t GetBytesRead () const;  ; Int_t GetClientProtocol () const;  ; const char * GetConfDir () const;  ; const char * GetConfFile () const;  ; Float_t GetCpuTime () const;  ; const char * GetDataPoolUrl () const;  ; virtual TFileCollection * GetDataSet (const char *dataset, const char *optStr="""");  Get a list of TFileInfo objects describing the files of the specified dataset. ;  ; TMap * GetDataSetQuota (const char *optStr="""");  returns a map of the quotas of all groups ;  ; virtual TMap * GetDataSets (const char *uri="""", const char *optStr="""");  Lists all datasets that match given uri. ;  ; TString Getenv (const char *env, const char *ord=""0"");  Get value of environment variable 'env' on node 'ord'. ;  ; TList * GetFeedbackList () const;  Return feedback list. ;  ; const char * GetGroup () const;  ; const char * GetImage () const;  ; TList * GetInputList ();  Get input list. ;  ; TMacro * GetLastLog ();  Fill a TMacro with the log lines since the last reading (fLogFileR) Return (TMacro *)0 if no line was logged. ;  ; TList * GetListOfEnabledPackages ();  Get from the master the list of names of the packages enabled. ;  ; TList * GetListOfPackages ();  Get from the master the list of names of the packages available. ;  ; virtual TList * GetListOfQueries (Option_t *opt="""");  Ask the master for the list of queries. ;  ; TList * GetListOfSlaveInfos ();  Returns list of TSlaveInfo's. In case of error return 0. ;  ; TList * GetLoadedMacros () const;  ; void GetLog (Int_t start=-1, Int_t end=-1);  Ask for remote logs in the range [start, end]. ;  ; Int_t GetLogLevel () const;  ; TMacro * GetMacroLog ();  ; TProofMgr * GetManager ();  ; const char * GetMaster () const;  ; void GetMaxQueries ();  Get max number of queries whose full results are kept in the remote sandbox. ;  ; TFileCollection * GetMissingFiles (TQueryResult *qr=0);  Get a TFileCollection with the files missing in the query described by 'qr' or the last query if qr i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:8899,log,log,8899,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,6,['log'],"['log', 'logged']"
Testability,"s in memory. Note that one histogram can be removed from its support directory by calling h->SetDirectory(nullptr) or h->SetDirectory(dir) to add it to the list of objects in the directory dir.; NOTE that this is a static function. To call it, use; TH1::AddDirectory ; Definition at line 1294 of file TH1.cxx. ◆ AddDirectoryStatus(). Bool_t TH1::AddDirectoryStatus ; (; ). static . Static function: cannot be inlined on Windows/NT. ; Definition at line 754 of file TH1.cxx. ◆ AndersonDarlingTest() [1/2]. Double_t TH1::AndersonDarlingTest ; (; const TH1 * ; h2, . Double_t & ; advalue . ); const. virtual . Same function as above but returning also the test statistic value. ; Definition at line 8080 of file TH1.cxx. ◆ AndersonDarlingTest() [2/2]. Double_t TH1::AndersonDarlingTest ; (; const TH1 * ; h2, . Option_t * ; option = """" . ); const. virtual . Statistical test of compatibility in shape between this histogram and h2, using the Anderson-Darling 2 sample test. ; The AD 2 sample test formula are derived from the paper F.W Scholz, M.A. Stephens ""k-Sample Anderson-Darling Test"".; The test is implemented in root in the ROOT::Math::GoFTest class It is the same formula ( (6) in the paper), and also shown in this preprint; Binned data are considered as un-binned data with identical observation happening in the bin center.; Parameters. [in]h2Pointer to 1D histogram ; [in]optionis a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""T"" Return the normalized A-D test statistic. Note1: Underflow and overflow are not considered in the test; Note2: The test works only for un-weighted histogram (i.e. representing counts); Note3: The histograms are not required to have the same X axis; Note4: The test works only for 1-dimensional histograms . Definition at line 8062 of file TH1.cxx. ◆ AutoP2FindLimits(). Int_t TH1::AutoP2FindLimits ; (; Double_t ; xmi, . Double_t ; xma . ). protectedvirtual . Buffer-based estimate of the histogram range using the power of 2 a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:80305,test,test,80305,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['test'],['test']
Testability,"s in the datasets are train: ""; 683 << nTrainingSamples << "" valid: "" << nValidationSamples; 684 << "" test: "" << nTestSamples << "". ""; 685 << ""One of these is smaller than the batch size of ""; 686 << settings.batchSize << "". Please increase the batch""; 687 << "" size to be at least the same size as the smallest""; 688 << "" of these values."" << Endl;; 689 }; 690 }; 691 ; 692 if (fArchitectureString == ""GPU"") {; 693 TrainGpu();; 694 if (!fExitFromTraining) fIPyMaxIter = fIPyCurrentIter;; 695 ExitFromTraining();; 696 return;; 697 } else if (fArchitectureString == ""OpenCL"") {; 698 Log() << kFATAL << ""OpenCL backend not yet supported."" << Endl;; 699 return;; 700 } else if (fArchitectureString == ""CPU"") {; 701 TrainCpu();; 702 if (!fExitFromTraining) fIPyMaxIter = fIPyCurrentIter;; 703 ExitFromTraining();; 704 return;; 705 }; 706 ; 707 Log() << kINFO << ""Using Standard Implementation."";; 708 ; 709 std::vector<Pattern> trainPattern;; 710 std::vector<Pattern> testPattern;; 711 ; 712 size_t nValidationSamples = GetNumValidationSamples();; 713 size_t nTrainingSamples = GetEventCollection(Types::kTraining).size() - nValidationSamples;; 714 ; 715 const std::vector<TMVA::Event *> &allData = GetEventCollection(Types::kTraining);; 716 const std::vector<TMVA::Event *> eventCollectionTraining{allData.begin(), allData.begin() + nTrainingSamples};; 717 const std::vector<TMVA::Event *> eventCollectionTesting{allData.begin() + nTrainingSamples, allData.end()};; 718 ; 719 for (auto &event : eventCollectionTraining) {; 720 const std::vector<Float_t>& values = event->GetValues();; 721 if (fAnalysisType == Types::kClassification) {; 722 double outputValue = event->GetClass () == 0 ? 0.9 : 0.1;; 723 trainPattern.push_back(Pattern (values.begin(),; 724 values.end(),; 725 outputValue,; 726 event->GetWeight()));; 727 trainPattern.back().addInput(1.0);; 728 } else if (fAnalysisType == Types::kMulticlass) {; 729 std::vector<Float_t> oneHot(DataInfo().GetNClasses(), 0.0);; 730 oneHot[event->GetClass",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:24794,test,testPattern,24794,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['test'],['testPattern']
Testability,"s in x direction; Double_tfBxErrerror value of b parameter for 1D ridges in x direction; Double_tfBxInitinitial value of b parameter for 1D ridges in x direction (slope), for details see html manual and references; Double_tfByCalccalculated value of b parameter for 1D ridges in y direction; Double_tfByErrerror value of b parameter for 1D ridges in y direction; Double_tfByInitinitial value of b parameter for 1D ridges in y direction (slope), for details see html manual and references; Double_tfChihere the fitting functions return resulting chi square; Int_tfFitTaylororder of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function.; Bool_tfFixA0logical value of a0 parameter, which allows to fix the parameter (not to fit).; Bool_t*fFixAmp[fNPeaks] array of logical values which allow to fix appropriate amplitudes of 2D peaks (not fit). However they are present in the estimated functional; Bool_t*fFixAmpX1[fNPeaks] array of logical values which allow to fix appropriate amplitudes of 1D ridges in x direction (not fit). However they are present in the estimated functional; Bool_t*fFixAmpY1[fNPeaks] array of logical values which allow to fix appropriate amplitudes of 1D ridges in y direction (not fit). However they are present in the estimated functional; Bool_tfFixAxlogical value of ax parameter, which allows to fix the parameter (not to fit).; Bool_tfFixAylogical value of ay parameter, which allows to fix the parameter (not to fit).; Bool_tfFixBxlogical value of b parameter for 1D ridges in x direction, which allows to fix the parameter (not to fit).; Bool_tfFixBylogical value of b parameter for 1D ridges in y direction, which allows to fix the parameter (not to fit).; Bool_t*fFixPositionX[fNPeaks] array of logical values which allow to fix appropriate x positions of 2D peaks (not fit). However they are present in the estimated functional; Bool_t*fFixPositionX1[fNPeaks] array of logical values which allow to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrum2Fit.html:16172,log,logical,16172,root/html602/TSpectrum2Fit.html,https://root.cern,https://root.cern/root/html602/TSpectrum2Fit.html,2,['log'],['logical']
Testability,"s is apparent from description of one_dim_pic structure. The constants , which can be used for appropriate parameters are defined in procfunc.h header file.; struct one_dim_pic {. float *source; // spectrum to be displayed. TCanvas *Canvas; // Canvas where the spectrum will be displayed. int size; // size of source spectrum; int xmin; // x-starting channel of spectrum; int xmax; // x-end channel of spectrum; int ymin; // base counts; int ymax; // count full scale. int bx1; // position of picture on Canvas, min x; int bx2; // position of picture on Canvas, max x; int by1; // position of picture on Canvas, min y; int by2; // position of picture on Canvas, max y. int display_mode; // spectrum display mode (points, polyline, bars, rainbow, steps, bezier); int y_scale; // y scale (linear, log, sqrt); int levels; // # of color levels for rainbow display mode, it does not apply; // for other display modes; float rainbow1_step; // determines the first color component step for neighbouring; // color levels, applies only for rainbow display mode; float rainbow2_step; // determines the second component color step for; // neighbouring color levels, applies only for rainbow display mode; float rainbow3_step; // determines the third component color step for; // neighbouring color levels, applies only for rainbow display mode. int color_alg; // applies only for rainbow display mode (rgb smooth algorithm, rgb; // modulo color component, cmy smooth algorithm, cmy modulo color; // component, cie smooth algorithm, cie modulo color component, yiq; // smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component [15]. int bar_thickness; // applies only for bar display mode; int bar_empty_flag; // (empty bars, full bars) applies only for bar display mode; int border_color; // color of background of the picture; int full_border; // decides whether background is painted; int raster_en_dis; // decides whether the axes and rasters are shown; int raster_lon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/spectrum/Spectrum.html:67003,log,log,67003,root/html534/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html,1,['log'],['log']
Testability,"s is of course defined by the user,; who uses the values of those parameters to calculate their function Value.; The order and the position of these parameters is strictly the one specified; by the user when supplying the starting values for minimization. The starting; values must be specified by the user, either via an std::vector<double> or the; MnUserParameters supplied as input to the MINUIT minimizers such as; VariableMetricMinimizer or MnMigrad. Later values are determined by MINUIT; as it searches for the Minimum or performs whatever analysis is requested by; the user. @param par function parameters as defined by the user. @return the Value of the function. @see MnUserParameters; @see VariableMetricMinimizer; @see MnMigrad. double ErrorDef() const. Error definition of the function. MINUIT defines Parameter errors as the; change in Parameter Value required to change the function Value by up. Normally,; for chisquared fits it is 1, and for negative log likelihood, its Value is 0.5.; If the user wants instead the 2-sigma errors for chisquared fits, it becomes 4,; as Chi2(x+n*sigma) = Chi2(x) + n*n. Comment a little bit better with links!!!!!!!!!!!!!!!!!. {return Up();}. double Up() const. Error definition of the function. MINUIT defines Parameter errors as the; change in Parameter Value required to change the function Value by up. Normally,; for chisquared fits it is 1, and for negative log likelihood, its Value is 0.5.; If the user wants instead the 2-sigma errors for chisquared fits, it becomes 4,; as Chi2(x+n*sigma) = Chi2(x) + n*n. \todo Comment a little bit better with links!!!!!!!!!!!!!!!!! Idem for ErrorDef(). void SetErrorDef(double ). add interface to set dynamically a new error definition; Re-implement this function if needed. {}. » Last changed: root/minuit2:$Id$ » Last generated: 2015-06-30 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Minuit2__FCNBase.html:2851,log,log,2851,root/html602/ROOT__Minuit2__FCNBase.html,https://root.cern,https://root.cern/root/html602/ROOT__Minuit2__FCNBase.html,1,['log'],['log']
Testability,"s is of course defined by the user,; who uses the values of those parameters to calculate their function Value.; The order and the position of these parameters is strictly the one specified; by the user when supplying the starting values for minimization. The starting; values must be specified by the user, either via an std::vector<double> or the; MnUserParameters supplied as input to the MINUIT minimizers such as; VariableMetricMinimizer or MnMigrad. Later values are determined by MINUIT; as it searches for the Minimum or performs whatever analysis is requested by; the user. @param par function parameters as defined by the user. @return the Value of the function. @see MnUserParameters; @see VariableMetricMinimizer; @see MnMigrad. double ErrorDef() const. Error definition of the function. MINUIT defines Parameter errors as the; change in Parameter Value required to change the function Value by up. Normally,; for chisquared fits it is 1, and for negative log likelihood, its Value is 0.5.; If the user wants instead the 2-sigma errors for chisquared fits, it becomes 4,; as Chi2(x+n*sigma) = Chi2(x) + n*n. Comment a little bit better with links!!!!!!!!!!!!!!!!!. {return Up();}. double Up() const. Error definition of the function. MINUIT defines Parameter errors as the; change in Parameter Value required to change the function Value by up. Normally,; for chisquared fits it is 1, and for negative log likelihood, its Value is 0.5.; If the user wants instead the 2-sigma errors for chisquared fits, it becomes 4,; as Chi2(x+n*sigma) = Chi2(x) + n*n. \todo Comment a little bit better with links!!!!!!!!!!!!!!!!! Idem for ErrorDef(). void SetErrorDef(double ). add interface to set dynamically a new error definition; Re-implement this function if needed. {}. » Last changed: root/minuit2:$Id$ » Last generated: 2015-09-08 17:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Minuit2__FCNBase.html:2851,log,log,2851,root/html604/ROOT__Minuit2__FCNBase.html,https://root.cern,https://root.cern/root/html604/ROOT__Minuit2__FCNBase.html,1,['log'],['log']
Testability,"s is skipped and therefore histograms; filled with weights are accepted. Bool_t CheckEntries(const TH1& pass, const TH1& total, Option_t* opt = """"); checks whether bin contents are compatible with binomial statistics. The following inequality has to be valid for each bin i:; total.GetBinContent(i) >= pass.GetBinContent(i). and the histogram have to be filled with unit weights. Option: - w: Do not check for unit weights -> accept histograms filled with; weights. Note: - It is assumed that both histograms have the same dimension and; binning. Double_t ClopperPearson(Int_t total, Int_t passed, Double_t level, Bool_t bUpper); calculates the boundaries for the frequentist Clopper-Pearson interval. This interval is recommended by the PDG. Input: - total : number of total events; - passed: 0 <= number of passed events <= total; - level : confidence level; - bUpper: true - upper boundary is returned; false - lower boundary is returned. calculation:. The lower boundary of the Clopper-Pearson interval is the ""exact"" inversion; of the test:. The lower boundary is therfore given by the quantile; of the beta distribution. The upper boundary of the Clopper-Pearson interval is the ""exact"" inversion; of the test:. The upper boundary is therfore given by the quantile; of the beta distribution. Note: The connection between the binomial distribution and the regularized; incomplete beta function has been used. Double_t Combine(Double_t& up, Double_t& low, Int_t n, const Int_t* pass, const Int_t* total, Double_t alpha, Double_t beta, Double_t level = 0.683, const Double_t* w = 0, Option_t* opt = """"); calculates the combined efficiency and its uncertainties. This method does a bayesian combination of the given samples. Input:; - up : contains the upper limit of the confidence interval afterwards; - low : contains the lower limit of the confidence interval afterwards; - n : number of samples which are combined; - pass : array of length n containing the number of passed events; - total : ar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEfficiency.html:46755,test,test,46755,root/html528/TEfficiency.html,https://root.cern,https://root.cern/root/html528/TEfficiency.html,3,['test'],['test']
Testability,"s kIgnoreTObjectStreamer bit is set, the automatically; 4824/// generated Streamer will not call TObject::Streamer.; 4825/// This option saves the TObject space overhead on the file.; 4826/// However, the information (fBits, fUniqueID) of TObject is lost.; 4827///; 4828/// Note that to be effective for objects streamed object-wise this function; 4829/// must be called for the class deriving directly from TObject, eg, assuming; 4830/// that BigTrack derives from Track and Track derives from TObject, one must do:; 4831/// ~~~ {.cpp}; 4832/// Track::Class()->IgnoreTObjectStreamer();; 4833/// ~~~; 4834/// and not:; 4835/// ~~~ {.cpp}; 4836/// BigTrack::Class()->IgnoreTObjectStreamer();; 4837/// ~~~; 4838/// To be effective for object streamed member-wise or split in a TTree,; 4839/// this function must be called for the most derived class (i.e. BigTrack).; 4840 ; 4841void TClass::IgnoreTObjectStreamer(Bool_t doIgnore); 4842{; 4843 // We need to tak the lock since we are test and then setting fBits; 4844 // and TStreamerInfo::fBits (and the StreamerInfo state in general); 4845 // which can also be modified by another thread.; 4846 R__LOCKGUARD(gInterpreterMutex);; 4847 ; 4848 if ( doIgnore && TestBit(kIgnoreTObjectStreamer)) return;; 4849 if (!doIgnore && !TestBit(kIgnoreTObjectStreamer)) return;; 4850 TVirtualStreamerInfo *sinfo = GetCurrentStreamerInfo();; 4851 if (sinfo) {; 4852 if (sinfo->IsCompiled()) {; 4853 // -- Warn the user that what they are doing cannot work.; 4854 // Note: The reason is that TVirtualStreamerInfo::Build() examines; 4855 // the kIgnoreTObjectStreamer bit and sets the TStreamerElement; 4856 // type for the TObject base class streamer element it creates; 4857 // to -1 as a flag. Later on the TStreamerInfo::Compile(); 4858 // member function sees the flag and does not insert the base; 4859 // class element into the compiled streamer info. None of this; 4860 // machinery works correctly if we are called after the streamer; 4861 // info has already",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:184140,test,test,184140,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['test'],['test']
Testability,"s kIgnoreTObjectStreamer bit is set, the automatically; 4891/// generated Streamer will not call TObject::Streamer.; 4892/// This option saves the TObject space overhead on the file.; 4893/// However, the information (fBits, fUniqueID) of TObject is lost.; 4894///; 4895/// Note that to be effective for objects streamed object-wise this function; 4896/// must be called for the class deriving directly from TObject, eg, assuming; 4897/// that BigTrack derives from Track and Track derives from TObject, one must do:; 4898/// ~~~ {.cpp}; 4899/// Track::Class()->IgnoreTObjectStreamer();; 4900/// ~~~; 4901/// and not:; 4902/// ~~~ {.cpp}; 4903/// BigTrack::Class()->IgnoreTObjectStreamer();; 4904/// ~~~; 4905/// To be effective for object streamed member-wise or split in a TTree,; 4906/// this function must be called for the most derived class (i.e. BigTrack).; 4907 ; 4908void TClass::IgnoreTObjectStreamer(Bool_t doIgnore); 4909{; 4910 // We need to tak the lock since we are test and then setting fBits; 4911 // and TStreamerInfo::fBits (and the StreamerInfo state in general); 4912 // which can also be modified by another thread.; 4913 R__LOCKGUARD(gInterpreterMutex);; 4914 ; 4915 if ( doIgnore && TestBit(kIgnoreTObjectStreamer)) return;; 4916 if (!doIgnore && !TestBit(kIgnoreTObjectStreamer)) return;; 4917 TVirtualStreamerInfo *sinfo = GetCurrentStreamerInfo();; 4918 if (sinfo) {; 4919 if (sinfo->IsCompiled()) {; 4920 // -- Warn the user that what they are doing cannot work.; 4921 // Note: The reason is that TVirtualStreamerInfo::Build() examines; 4922 // the kIgnoreTObjectStreamer bit and sets the TStreamerElement; 4923 // type for the TObject base class streamer element it creates; 4924 // to -1 as a flag. Later on the TStreamerInfo::Compile(); 4925 // member function sees the flag and does not insert the base; 4926 // class element into the compiled streamer info. None of this; 4927 // machinery works correctly if we are called after the streamer; 4928 // info has already",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:186891,test,test,186891,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['test'],['test']
Testability,"s mainly useful; when doing regression analysis with the MLP (i.e. not classification,; but continuous truth values).; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfile::Draw. THStack* DrawTruthDeviations(Option_t* option = """"); Creates TProfiles of the difference of the MLP output minus the; true value vs the true value, one for each output, filled with the; test data events. This method is mainly useful when doing regression; analysis with the MLP (i.e. not classification, but continuous truth; values).; The returned THStack contains all the TProfiles. It is drawn unless; the option ""goff"" is specified.; Options are passed to TProfile::Draw. TProfile* DrawTruthDeviationInOut(Int_t innode, Int_t outnode = 0, Option_t* option = """"); Creates a profile of the difference of the MLP output outnode minus; the true value of outnode vs the input value innode, for all test; data events.; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfile::Draw. THStack* DrawTruthDeviationInsOut(Int_t outnode = 0, Option_t* option = """"); Creates a profile of the difference of the MLP output outnode minus the; true value of outnode vs the input value, stacked for all inputs, for; all test data events.; The returned THStack contains all the TProfiles. It is drawn unless; the option ""goff"" is specified.; Options are passed to TProfile::Draw. TMLPAnalyzer(TMultiLayerPerceptron& net); {}. TMLPAnalyzer(TMultiLayerPerceptron* net); {}. TTree* GetIOTree() const; { return fIOTree;}. » Author: Christophe.Delaere@cern.ch 25/04/04 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/mlp:$Id: TMLPAnalyzer.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-30 17:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMLPAnalyzer.html:9640,test,test,9640,root/html528/TMLPAnalyzer.html,https://root.cern,https://root.cern/root/html528/TMLPAnalyzer.html,1,['test'],['test']
Testability,"s mainly useful; when doing regression analysis with the MLP (i.e. not classification,; but continuous truth values).; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfile::Draw. THStack* DrawTruthDeviations(Option_t* option = """"); Creates TProfiles of the difference of the MLP output minus the; true value vs the true value, one for each output, filled with the; test data events. This method is mainly useful when doing regression; analysis with the MLP (i.e. not classification, but continuous truth; values).; The returned THStack contains all the TProfiles. It is drawn unless; the option ""goff"" is specified.; Options are passed to TProfile::Draw. TProfile* DrawTruthDeviationInOut(Int_t innode, Int_t outnode = 0, Option_t* option = """"); Creates a profile of the difference of the MLP output outnode minus; the true value of outnode vs the input value innode, for all test; data events.; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfile::Draw. THStack* DrawTruthDeviationInsOut(Int_t outnode = 0, Option_t* option = """"); Creates a profile of the difference of the MLP output outnode minus the; true value of outnode vs the input value, stacked for all inputs, for; all test data events.; The returned THStack contains all the TProfiles. It is drawn unless; the option ""goff"" is specified.; Options are passed to TProfile::Draw. TMLPAnalyzer(TMultiLayerPerceptron& net); {}. TMLPAnalyzer(TMultiLayerPerceptron* net); {}. TTree* GetIOTree() const; { return fIOTree;}. » Author: Christophe.Delaere@cern.ch 25/04/04 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/mlp:$Id: TMLPAnalyzer.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMLPAnalyzer.html:9709,test,test,9709,root/html530/TMLPAnalyzer.html,https://root.cern,https://root.cern/root/html530/TMLPAnalyzer.html,1,['test'],['test']
Testability,"s mainly useful; when doing regression analysis with the MLP (i.e. not classification,; but continuous truth values).; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfile::Draw. THStack* DrawTruthDeviations(Option_t* option = """"); Creates TProfiles of the difference of the MLP output minus the; true value vs the true value, one for each output, filled with the; test data events. This method is mainly useful when doing regression; analysis with the MLP (i.e. not classification, but continuous truth; values).; The returned THStack contains all the TProfiles. It is drawn unless; the option ""goff"" is specified.; Options are passed to TProfile::Draw. TProfile* DrawTruthDeviationInOut(Int_t innode, Int_t outnode = 0, Option_t* option = """"); Creates a profile of the difference of the MLP output outnode minus; the true value of outnode vs the input value innode, for all test; data events.; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfile::Draw. THStack* DrawTruthDeviationInsOut(Int_t outnode = 0, Option_t* option = """"); Creates a profile of the difference of the MLP output outnode minus the; true value of outnode vs the input value, stacked for all inputs, for; all test data events.; The returned THStack contains all the TProfiles. It is drawn unless; the option ""goff"" is specified.; Options are passed to TProfile::Draw. TMLPAnalyzer(TMultiLayerPerceptron& net); {}. TMLPAnalyzer(TMultiLayerPerceptron* net); {}. TTree* GetIOTree() const; { return fIOTree;}. » Author: Christophe.Delaere@cern.ch 25/04/04 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/mlp:$Id: TMLPAnalyzer.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMLPAnalyzer.html:9709,test,test,9709,root/html532/TMLPAnalyzer.html,https://root.cern,https://root.cern/root/html532/TMLPAnalyzer.html,1,['test'],['test']
Testability,s modified by the user. void ModXTitleColor(); Slot called whenever the X axis title color is modified by the user. void ModXTitleOffset(); Slot called whenever the X axis title offset is modified by the user. void ModXTitleFont(); Slot called whenever the X axis title font is modified by the user. void ModXLabelSize(); Slot called whenever the X axis label size is modified by the user. void ModXLabelSizeInPixels(Bool_t b); Slot called whenever the X axis label size mode is modified by the user. void ModXLabelColor(); Slot called whenever the X axis label color is modified by the user. void ModXLabelOffset(); Slot called whenever the X axis label offset is modified by the user. void ModXLabelFont(); Slot called whenever the X axis label font is modified by the user. void ModXAxisColor(); Slot called whenever the X axis color is modified by the user. void ModXTickLength(); Slot called whenever the X axis tick length is modified by the user. void ModOptLogx(); Slot called whenever the X axis log scale boolean is modified; by the user. void ModXNdivisions(); Slot called whenever the X axis Number of divisions is modified; by the user. void ModYTitleSize(); Slot called whenever the Y axis title size is modified by the user. void ModYTitleSizeInPixels(Bool_t b); Slot called whenever the Y axis title size mode is modified by the user. void ModYTitleColor(); Slot called whenever the Y axis title color is modified by the user. void ModYTitleOffset(); Slot called whenever the Y axis title offset is modified by the user. void ModYTitleFont(); Slot called whenever the Y axis title font is modified by the user. void ModYLabelSize(); Slot called whenever the Y axis label size is modified by the user. void ModYLabelSizeInPixels(Bool_t b); Slot called whenever the Y axis label size mode is modified by the user. void ModYLabelColor(); Slot called whenever the Y axis label color is modified by the user. void ModYLabelOffset(); Slot called whenever the Y axis label offset is modified ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStyleManager.html:69721,log,log,69721,root/html528/TStyleManager.html,https://root.cern,https://root.cern/root/html528/TStyleManager.html,6,['log'],['log']
Testability,s modified by the user. void ModYTitleColor(); Slot called whenever the Y axis title color is modified by the user. void ModYTitleOffset(); Slot called whenever the Y axis title offset is modified by the user. void ModYTitleFont(); Slot called whenever the Y axis title font is modified by the user. void ModYLabelSize(); Slot called whenever the Y axis label size is modified by the user. void ModYLabelSizeInPixels(Bool_t b); Slot called whenever the Y axis label size mode is modified by the user. void ModYLabelColor(); Slot called whenever the Y axis label color is modified by the user. void ModYLabelOffset(); Slot called whenever the Y axis label offset is modified by the user. void ModYLabelFont(); Slot called whenever the Y axis label font is modified by the user. void ModYAxisColor(); Slot called whenever the Y axis color is modified by the user. void ModYTickLength(); Slot called whenever the Y axis tick length is modified by the user. void ModOptLogy(); Slot called whenever the Y axis log scale boolean is modified by the user. void ModYNdivisions(); Slot called whenever the Y axis Number of divisions is modified; by the user. void ModZTitleSize(); Slot called whenever the Z axis title size is modified by the user. void ModZTitleSizeInPixels(Bool_t b); Slot called whenever the Z axis title size mode is modified by the user. void ModZTitleColor(); Slot called whenever the Z axis title color is modified by the user. void ModZTitleOffset(); Slot called whenever the Z axis title offset is modified by the user. void ModZTitleFont(); Slot called whenever the Z axis title font is modified by the user. void ModZLabelSize(); Slot called whenever the Z axis label size is modified by the user. void ModZLabelSizeInPixels(Bool_t b); Slot called whenever the Z axis Label size mode is modified by the user. void ModZLabelColor(); Slot called whenever the Z axis label color is modified by the user. void ModZLabelOffset(); Slot called whenever the Z axis label offset is modified ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStyleManager.html:71048,log,log,71048,root/html528/TStyleManager.html,https://root.cern,https://root.cern/root/html528/TStyleManager.html,6,['log'],['log']
Testability,s modified by the user. void ModZTitleColor(); Slot called whenever the Z axis title color is modified by the user. void ModZTitleOffset(); Slot called whenever the Z axis title offset is modified by the user. void ModZTitleFont(); Slot called whenever the Z axis title font is modified by the user. void ModZLabelSize(); Slot called whenever the Z axis label size is modified by the user. void ModZLabelSizeInPixels(Bool_t b); Slot called whenever the Z axis Label size mode is modified by the user. void ModZLabelColor(); Slot called whenever the Z axis label color is modified by the user. void ModZLabelOffset(); Slot called whenever the Z axis label offset is modified by the user. void ModZLabelFont(); Slot called whenever the Z axis label font is modified by the user. void ModZAxisColor(); Slot called whenever the Z axis color is modified by the user. void ModZTickLength(); Slot called whenever the Z axis tick length is modified by the user. void ModOptLogz(); Slot called whenever the Z axis log scale boolean is modified by the user. void ModZNdivisions(); Slot called whenever the Z axis Number of divisions is modified; by the user. void ModOptTitle(); Slot called whenever the OptTitle boolean is modified by the user. void ModTitleFillColor(); Slot called whenever the title fill color is modified by the user. void ModTitleStyle(); Slot called whenever the title fill style is modified by the user. void ModTitleTextColor(); Slot called whenever the title text color is modified by the user. void ModTitleFontSize(); Slot called whenever the text size is modified by the user. void ModTitleFontSizeInPixels(Bool_t b); Slot called whenever the text size mode is modified by the user. void ModTitleFont(); Slot called whenever the title text font is modified by the user. void ModTitleAlign(); Slot called whenever the title text align is modified by the user. void ModTitleBorderSize(); Slot called whenever the title border size is modified by the user. void ModLegendBorderSize();,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStyleManager.html:72374,log,log,72374,root/html528/TStyleManager.html,https://root.cern,https://root.cern/root/html528/TStyleManager.html,6,['log'],['log']
Testability,"s must match the dimension of the fit function; 511 // confidence intervals are returned in array ci; 512 ; 513 if (!fFitFunc) {; 514 // check if model function exists; 515 MATH_ERROR_MSG(""FitResult::GetConfidenceIntervals"",""Cannot compute Confidence Intervals without fit model function"");; 516 return;; 517 }; 518 assert(fFitFunc);; 519 ; 520 // use student quantile in case of normalized errors; 521 double corrFactor = 1;; 522 if (fChi2 <= 0 || fNdf == 0) norm = false;; 523 if (norm); 524 corrFactor = TMath::StudentQuantile(0.5 + cl/2, fNdf) * std::sqrt( fChi2/fNdf );; 525 else; 526 // correction to apply to the errors given a CL different than 1 sigma (cl=0.683); 527 corrFactor = ROOT::Math::normal_quantile(0.5 + cl/2, 1);; 528 ; 529 ; 530 ; 531 unsigned int ndim = fFitFunc->NDim();; 532 unsigned int npar = fFitFunc->NPar();; 533 ; 534 std::vector<double> xpoint(ndim);; 535 std::vector<double> grad(npar);; 536 std::vector<double> vsum(npar);; 537 ; 538 // loop on the points; 539 for (unsigned int ipoint = 0; ipoint < n; ++ipoint) {; 540 ; 541 for (unsigned int kdim = 0; kdim < ndim; ++kdim) {; 542 unsigned int i = ipoint * stride1 + kdim * stride2;; 543 assert(i < ndim*n);; 544 xpoint[kdim] = x[i];; 545 }; 546 ; 547 // calculate gradient of fitted function w.r.t the parameters; 548 ROOT::Math::RichardsonDerivator d;; 549 for (unsigned int ipar = 0; ipar < npar; ++ipar) {; 550 if (!IsParameterFixed(ipar)) {; 551 ROOT::Math::OneDimParamFunctionAdapter<const ROOT::Math::IParamMultiFunction &> fadapter(*fFitFunc,&xpoint.front(),&fParams.front(),ipar);; 552 d.SetFunction(fadapter);; 553 // compute step size as a small fraction of the error; 554 // (see numerical recipes in C 5.7.8) 1.E-5 is ~ (eps)^1/3; 555 if ( fErrors[ipar] > 0 ); 556 d.SetStepSize( std::max( fErrors[ipar]*1.E-5, 1.E-15) );; 557 else; 558 d.SetStepSize( std::min(std::max(fParams[ipar]*1.E-5, 1.E-15), 0.0001 ) );; 559 ; 560 grad[ipar] = d(fParams[ipar] ); // evaluate df/dp; 561 }; 562 else; 563 grad[ip",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/FitResult_8cxx_source.html:19487,assert,assert,19487,doc/master/FitResult_8cxx_source.html,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html,1,['assert'],['assert']
Testability,"s name (including module); 290 PyObject* pyClName = PyObject_GetAttr(value, PyStrings::gName);; 291 if (PyErr_Occurred()); 292 PyErr_Clear();; 293 ; 294 // build full, qualified name; 295 std::string fullname = mod_name;; 296 fullname += ""."";; 297 fullname += CPyCppyy_PyText_AsString(pyClName);; 298 ; 299 // force class creation (this will eventually call TPyClassGenerator); 300 // TODO: the following is broken (and should live in Cppyy.cxx) to; 301 // TClass::GetClass(fullname.c_str(), true);; 302 ; 303 Py_XDECREF(pyClName);; 304 }; 305 ; 306 Py_DECREF(value);; 307 }; 308 ; 309 Py_DECREF(values);; 310 ; 311// TODO: mod ""leaks"" here; 312 if (PyErr_Occurred()); 313 return false;; 314 return true;; 315}; 316 ; 317//-----------------------------------------------------------------------------; 318void CPyCppyy::ExecScript(const std::string& name, const std::vector<std::string>& args); 319{; 320// Execute a python stand-alone script, with argv CLI arguments.; 321//; 322// example of use:; 323// CPyCppyy::ExecScript(""test.py"", {""1"", ""2"", ""3""});; 324 ; 325 if (!Initialize()); 326 return;; 327 ; 328// verify arguments; 329 if (name.empty()) {; 330 std::cerr << ""Error: no file name specified."" << std::endl;; 331 return;; 332 }; 333 ; 334 FILE* fp = fopen(name.c_str(), ""r"");; 335 if (!fp) {; 336 std::cerr << ""Error: could not open file \"""" << name << ""\""."" << std::endl;; 337 return;; 338 }; 339 ; 340// store a copy of the old cli for restoration; 341 PyObject* oldargv = PySys_GetObject(const_cast<char*>(""argv"")); // borrowed; 342 if (!oldargv) // e.g. apache; 343 PyErr_Clear();; 344 else {; 345 PyObject* l = PyList_New(PyList_GET_SIZE(oldargv));; 346 for (int i = 0; i < PyList_GET_SIZE(oldargv); ++i) {; 347 PyObject* item = PyList_GET_ITEM(oldargv, i);; 348 Py_INCREF(item);; 349 PyList_SET_ITEM(l, i, item); // steals ref; 350 }; 351 oldargv = l;; 352 }; 353 ; 354// create and set (add program name) the new command line; 355 int argc = args.size() + 1;; 356#if PY_VERSION_HEX <",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/API_8cxx_source.html:11038,test,test,11038,doc/master/API_8cxx_source.html,https://root.cern,https://root.cern/doc/master/API_8cxx_source.html,1,['test'],['test']
Testability,"s of events with respect to the control variable. TSPlot is optimal if the control variable is uncorrelated with the discriminating variables. A detail description of the formalism itself, called ; , is given in [1]. The method. The ; technique is developped in the above context of a maximum Likelihood method making use of discriminating variables.; One considers a data sample in which are merged several species; of events. These species represent various signal components and; background components which all together account for the data sample.; The different terms of the log-Likelihood are:. : the total number of events in the data sample,. : the number of species of events populating the data sample,. : the number of events expected on the average for the species,. : the value of the PDFs of the discriminating variables for the species and for event ,. : the set of control variables which, by definition, do not appear in the expression of the Likelihood function . The extended log-Likelihood reads:. (1). From this expression, after maximization of with respect to the parameters, a weight can be computed for every event and each species, in order to obtain later the true distribution ; of variable . If is one of the ; species present in the data sample, the weight for this species is defined by:. (2). where . is the covariance matrix resulting from the Likelihood maximization.; This matrix can be used directly from the fit, but this is numerically; less accurate than the direct computation:. (3). The distribution of the control variable  obtained by histogramming the weighted events reproduces, on average, the true distribution ; . The class TSPlot allows to reconstruct the true distribution ; of a control variable  for each of the ; species from the sole knowledge of the PDFs of the discriminating variables . The plots obtained thanks to the TSPlot class are called ; . Some properties and checks. Beside reproducing the true distribution, ; bear remarkable proper",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSPlot.html:2619,log,log-Likelihood,2619,root/html602/TSPlot.html,https://root.cern,https://root.cern/root/html602/TSPlot.html,2,['log'],['log-Likelihood']
Testability,"s only a reasonable thing to do when you use; ""YesOrNo"" leafs, while it might loose s.th. if you use the; purity information in the nodes.; --> hence I don't call it automatically in the tree building. Double_t PruneTree(const TMVA::DecisionTree::EventConstList* validationSample = NULL); prune (get rid of internal nodes) the Decision tree to avoid overtraining; serveral different pruning methods can be applied as selected by the; variable ""fPruneMethod"". void ApplyValidationSample(const TMVA::DecisionTree::EventConstList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample. This is then later used; when asking for the ""tree quality"" .. Double_t TestPrunedTreeQuality(const TMVA::DecisionTreeNode* dt = NULL, Int_t mode = 0) const; return the misclassification rate of a pruned tree; a ""pruned tree"" may have set the variable ""IsTerminal"" to ""arbitrary"" at; any node, hence this tree quality testing will stop there, hence test; the pruned tree (while the full tree is still in place for normal/later use). void CheckEventWithPrunedTree(const TMVA::Event* ) const; pass a single validation event throught a pruned decision tree; on the way down the tree, fill in all the ""intermediate"" information; that would normally be there from training. Double_t GetSumWeights(const TMVA::DecisionTree::EventConstList* validationSample) const; calculate the normalization factor for a pruning validation sample. UInt_t CountLeafNodes(TMVA::Node* n = NULL); return the number of terminal nodes in the sub-tree below Node n. void DescendTree(TMVA::Node* n = NULL); descend a tree to find all its leaf nodes. void PruneNode(TMVA::DecisionTreeNode* node); prune away the subtree below the node. void PruneNodeInPlace(TMVA::DecisionTreeNode* node); prune a node temporaily (without actually deleting its decendants; which allows testing ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__DecisionTree.html:11802,test,testing,11802,root/html534/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html534/TMVA__DecisionTree.html,2,['test'],"['test', 'testing']"
Testability,"s or pass C++ callables to RDataFrame.; 1000See [Efficient analysis in Python](#python) for possible ways to speed up hot paths in this case.; 1001 ; 1002Just-in-time compilation happens once, right before starting an event loop. To reduce the runtime cost of this step, make sure to book all operations *for all RDataFrame computation graphs*; 1003before the first event loop is triggered: just-in-time compilation will happen once for all code required to be generated up to that point, also across different computation graphs.; 1004 ; 1005Also make sure not to count the just-in-time compilation time (which happens once before the event loop and does not depend on the size of the dataset) as part of the event loop runtime (which scales with the size of the dataset). RDataFrame has an experimental logging feature that simplifies measuring the time spent in just-in-time compilation and in the event loop (as well as providing some more interesting information). See [Activating RDataFrame execution logs](\ref rdf-logging).; 1006 ; 1007### Memory usage; 1008 ; 1009There are two reasons why RDataFrame may consume more memory than expected. Firstly, each result is duplicated for each worker thread, which e.g. in case of many (possibly multi-dimensional) histograms with fine binning can result in visible memory consumption during the event loop. The thread-local copies of the results are destroyed when the final result is produced. Reducing the number of threads or using coarser binning will reduce the memory usage.; 1010 ; 1011Secondly, just-in-time compilation of string expressions or non-templated actions (see the previous paragraph) causes Cling, ROOT's C++ interpreter, to allocate some memory for the generated code that is only released at the end of the application. This commonly results in memory usage creep in long-running applications that create many RDataFrames one after the other. Possible mitigations include creating and running each RDataFrame event loop in a sub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:57896,log,logs,57896,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,2,['log'],"['logging', 'logs']"
Testability,"s overlap object. void CheckOverlapsBySampling(TGeoVolume* vol, Double_t ovlp = 0.1, Int_t npoints = 1000000) const; Check illegal overlaps for volume VOL within a limit OVLP by sampling npoints; inside the volume shape. Int_t NChecksPerVolume(TGeoVolume* vol); Compute number of overlaps combinations to check per volume. void CheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.1, Option_t* option = """"); Check illegal overlaps for volume VOL within a limit OVLP. void PrintOverlaps() const; Print the current list of overlaps held by the manager class. void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); --- Draw point (x,y,z) over the picture of the daughers of the volume containing this point.; Generates a report regarding the path to the node containing this point and the distance to; the closest boundary. void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2); 2: Safety test. Sample points inside the bounding and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; Distance to boundary is bigger than safety. void ShapeDistances(TGeoShape* shape, Int_t nsamples, Option_t* option); Test TGeoShape::DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary; then compute DistFromInside that should be bigger than d1.; Plot d-(d1+d2). void Sha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoChecker.html:14610,test,test,14610,root/html530/TGeoChecker.html,https://root.cern,https://root.cern/root/html530/TGeoChecker.html,3,['test'],['test']
Testability,"s parameter uncertainties to an uncertainty estimate for this RooAbsReal. ;  ; TString getTitle (bool appendUnit=false) const;  Return this variable's title string. ;  ; const Text_t * getUnit () const;  ; double getVal (const RooArgSet &normalisationSet) const;  Like getVal(const RooArgSet*), but always requires an argument for normalisation. ;  ; double getVal (const RooArgSet *normalisationSet=nullptr) const;  Evaluate object. ;  ; virtual double getValV (const RooArgSet *normalisationSet=nullptr) const;  Return value of object. ;  ; virtual void gradient (double *) const;  ; virtual bool hasGradient () const;  ; TClass * IsA () const override;  ; virtual bool isBinnedDistribution (const RooArgSet &) const;  Tests if the distribution is binned. Unless overridden by derived classes, this always returns false. ;  ; bool isIdentical (const RooAbsArg &other, bool assumeSameType=false) const override;  ; virtual bool isOffsetting () const;  ; bool isSelectedComp () const;  If true, the current pdf is a selected component (for use in plotting) ;  ; void logEvalError (const char *message, const char *serverValueString=nullptr) const;  Log evaluation error message. ;  ; virtual double maxVal (Int_t code) const;  Return maximum value for set of observables identified by code assigned in getMaxVal. ;  ; RooAbsMoment * mean (RooRealVar &obs);  ; RooAbsMoment * mean (RooRealVar &obs, const RooArgSet &nset);  ; virtual Int_t minTrialSamples (const RooArgSet &) const;  ; RooAbsMoment * moment (RooRealVar &obs, const RooArgSet &normObs, Int_t order, bool central, bool takeRoot, bool intNormObs);  Return function representing moment of p.d.f (normalized w.r.t given observables) of given order. ;  ; RooAbsMoment * moment (RooRealVar &obs, Int_t order, bool central, bool takeRoot);  Return function representing moment of function of given order. ;  ; virtual double offset () const;  ; bool operator== (const RooAbsArg &other) const override;  Equality operator when comparing to ano",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:16160,log,logEvalError,16160,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,6,['log'],['logEvalError']
Testability,"s provided, this information; will assist the accept/reject generator to operate more efficiently as; it can skip the initial trial sampling phase to empirically find the function; maximum. Double_t maxVal(Int_t code) const; Return maximum value for set of observables identified by code assigned; in getMaxVal. void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); Interface to insert remote error logging messages received by RooRealMPFE into current error loggin stream. void logEvalError(const char* message, const char* serverValueString = 0) const; Log evaluation error message. Evaluation errors may be routed through a different; protocol than generic RooFit warning message (which go straight through RooMsgService); because evaluation errors can occur in very large numbers in the use of likelihood; evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar information is passed as argument. void clearEvalErrorLog(); Clear the stack of evaluation error messages. void printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10000000); Print all outstanding logged evaluation error on the given ostream. If maxPerNode; is zero, only the number of errors for each source (object with unique name) is listed.; If maxPerNode is greater than zero, up to m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:61810,log,logEvalError,61810,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,7,['log'],['logEvalError']
Testability,"s required for the Wait and TimedWait locking methods. One can pass the address of an external mutex to the TCondition constructor:; TMutex MyMutex;; TCondition MyCondition(&MyMutex);; If zero is passed, TCondition creates and uses its own internal mutex:; TCondition MyCondition(0);; You can now use the following methods of synchronization:. TCondition::Wait() waits until any thread sends a signal of the same condition instance: MyCondition.Wait() reacts on MyCondition.Signal() or MyCondition.Broadcast(). MyOtherCondition.Signal() has no effect.; If several threads wait for the signal from the same TCondition MyCondition, at MyCondition.Signal() only one thread will react; to activate a further thread another MyCondition.Signal() is required, etc.; If several threads wait for the signal from the same TCondition MyCondition, at MyCondition.Broadcast() all threads waiting for MyCondition are activated at once. In some tests of MyCondition using an internal mutex, Broadcast() activated only one thread (probably depending whether MyCondition had been signaled before). MyCondition.TimedWait(secs,nanosecs) waits for MyCondition until the absolute time in seconds and nanoseconds since beginning of the epoch (January, 1st, 1970) is reached; to use relative timeouts ‘‘delta’‘, it is required to calculate the absolute time at the beginning of waiting ‘‘now’’; for example:. Ulong_t now,then,delta; // seconds; TDatime myTime; // root daytime class; myTime.Set(); // myTime set to ""now""; now=myTime.Convert(); // to seconds since 1970. Return value wait of MyCondition.TimedWait should be 0, if MyCondition.Signal() was received, and should be nonzero, if timeout was reached. The conditions example shows how three threaded functions are synchronized using TCondition: a ROOT script condstart.C starts the threads, which are defined in a shared library (conditions.cxx, conditions.h).; 23.2.4.3 Xlib Connections; Usually Xlib is not thread safe. This means that calls to the X could fail, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1109421,test,tests,1109421,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['test'],['tests']
Testability,"s shown.; 3358 ; 3359Double_t TFormula::DoEval(const double * x, const double * params) const; 3360{; 3361 if(!fReadyToExecute); 3362 {; 3363 Error(""Eval"", ""Formula is invalid and not ready to execute "");; 3364 for (auto it = fFuncs.begin(); it != fFuncs.end(); ++it) {; 3365 TFormulaFunction fun = *it;; 3366 if (!fun.fFound) {; 3367 printf(""%s is unknown.\n"", fun.GetName());; 3368 }; 3369 }; 3370 return TMath::QuietNaN();; 3371 }; 3372 ; 3373 // Lazy initialization is set and needed when reading from a file; 3374 if (!fClingInitialized && fLazyInitialization) {; 3375 // try recompiling the formula. We need to lock because this is not anymore thread safe; 3376 R__LOCKGUARD(gROOTMutex);; 3377 // check again in case another thread has initialized the formula (see ROOT-10994); 3378 if (!fClingInitialized) {; 3379 auto thisFormula = const_cast<TFormula*>(this);; 3380 thisFormula->ReInitializeEvalMethod();; 3381 }; 3382 if (!fClingInitialized) {; 3383 Error(""DoEval"", ""Formula has error and it is not properly initialized "");; 3384 return TMath::QuietNaN();; 3385 }; 3386 }; 3387 ; 3388 if (fLambdaPtr && TestBit(TFormula::kLambda)) {// case of lambda functions; 3389 std::function<double(double *, double *)> & fptr = * ( (std::function<double(double *, double *)> *) fLambdaPtr);; 3390 assert(x);; 3391 //double * v = (x) ? const_cast<double*>(x) : const_cast<double*>(fClingVariables.data());; 3392 double * v = const_cast<double*>(x);; 3393 double * p = (params) ? const_cast<double*>(params) : const_cast<double*>(fClingParameters.data());; 3394 return fptr(v, p);; 3395 }; 3396 ; 3397 ; 3398 Double_t result = 0;; 3399 void* args[2];; 3400 double * vars = (x) ? const_cast<double*>(x) : const_cast<double*>(fClingVariables.data());; 3401 args[0] = &vars;; 3402 if (fNpar <= 0) {; 3403 (*fFuncPtr)(nullptr, 1, args, &result);; 3404 } else {; 3405 double *pars = (params) ? const_cast<double *>(params) : const_cast<double *>(fClingParameters.data());; 3406 args[1] = &pars;; 3407 (*fFunc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFormula_8cxx_source.html:128995,assert,assert,128995,doc/master/TFormula_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html,1,['assert'],['assert']
Testability,"s starting from Event.root; Test chains of Trees using the 10 files; Compare histograms of test 9 and 11; Merging files of a chain; Check correct rebuilt of Event.root in test 13; Divert Tree branches to separate files; Cling test (3 nested loops) with LHCb trigger. The program stress takes one argument, the number of events to process. The default is 1000 events. Be aware that executing stress with 1000 eventswill create several files consuming about 100 MB of disk space; running stress with 30 events will consume about 20 MB. The disk space is released once stress is done.; There are two ways to run stress:; From the system prompt or from the ROOT prompt using the interpreter.; > cd $ROOTSYS/test; > stress // default 1000 events; > stress 30 // test with 30 events; Start ROOT with the batch mode option (-b) to suppress the graphic output.; > root -b; root[] .L stress.cxx; root[] stress(1000)// test with 1000 events; root[] stress(30)// test with 30 events; The output of stress includes a pass/fail conclusion for each test, the total number of bytes read and written, and the elapsed real and CPU time. It also calculates a performance index for your machine relative to a reference machine a DELL Inspiron 7500 (Pentium III 600 MHz) with 256 MB of memory and 18GB IDE disk in ROOTMARKS. Higher ROOTMARKS means better performance. The reference machine has 200 ROOTMARKS, so the sample run below with 53.7 ROOTMARKS is about four times slower than the reference machine.; Here is a sample run:; % root -b; root[] .x stress.cxx(30). Test 1 : Functions, Random Numbers, Histogram Fits............. OK; Test 2 : Check size & compression factor of a Root file........ OK; Test 3 : Purge, Reuse of gaps in TFile......................... OK; Test 4 : Test of 2-d histograms, functions, 2-d fits........... OK; Test 5 : Test graphics & PostScript ............................OK; Test 6 : Test subdirectories in a Root file.................... OK; Test 7 : TNtuple, selections, TCutG, TEventL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1083876,test,test,1083876,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,3,['test'],['test']
Testability,"s store internally the full list of logical nodes corresponding to the elements from the string path, as well as the global transformation matrix for each of them. The top node corresponds to the level 0 in the stored array, while the last node will correspond to level n. For each level, the node, volume and global matrix can be retrieved using corresponding getters:; TGeoHMatrix *GetMatrix(Int_t level=-1) const; TGeoNode *GetNode(Int_t level=-1) const; TGeoShape *GetShape(Int_t level=-1) const; TGeoVolume *GetVolume(Int_t level=-1) const; By default the object at level n is retrieved (the align-able object).; Once created, a physical node can be misaligned, meaning that its positioning matrix or even the shape.:; void Align(TGeoMatrix* newmat=0, TGeoShape* newshape=0,; Bool_t check=kFALSE); The convention used is that newmat represents the new local matrix of the last node in the branch with respect to its mother volume. The Align() method will actually duplicate the corresponding branch within the logical hierarchy, creating new volumes and nodes. This is mandatory in order to avoid problems due to replicated volumes and can create exhaustive memory consumption if used abusively.; Once aligned, a physical node is ready to be tracked. The operation can be done only after the geometry was closed.; Important NOTE: Calling the Align() method for a physical node changes the node pointers for the stored node branch in the active geometry, Due to this the other defined physical nodes containing elements of this path will be invalid. Example:; TGeoPhysicalNode *pn1 =; gGeoManager->MakePhysicalNode(""/A_1/B_1/C_2"");; TGeoPhysicalNode *pn2 =; gGeoManager->MakePhysicalNode(""/A_1/B_1/C_3"");; ...; pn1->Align(...);; TGeoManager::MakePhysicalNodeTGeoPhysicalNode * MakePhysicalNode(const char *path=nullptr)Makes a physical node corresponding to a path.Definition TGeoManager.cxx:3506; TGeoPhysicalNode::AlignBool_t Align(TGeoMatrix *newmat=nullptr, TGeoShape *newshape=nullptr, Bool_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:118599,log,logical,118599,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['log'],['logical']
Testability,"s store internally the full list of logical nodes corresponding to the elements from the string path, as well as the global transformation matrix for each of them. The top node corresponds to the level 0 in the stored array, while the last node will correspond to level n. For each level, the node, volume and global matrix can be retrieved using corresponding getters:; TGeoHMatrix *GetMatrix(Int_t level=-1) const; TGeoNode *GetNode(Int_t level=-1) const; TGeoShape *GetShape(Int_t level=-1) const; TGeoVolume *GetVolume(Int_t level=-1) const; By default the object at level n is retrieved (the align-able object).; Once created, a physical node can be misaligned, meaning that its positioning matrix or even the shape.:; void Align(TGeoMatrix* newmat=0, TGeoShape* newshape=0,; Bool_t check=kFALSE); The convention used is that newmat represents the new local matrix of the last node in the branch with respect to its mother volume. The Align() method will actually duplicate the corresponding branch within the logical hierarchy, creating new volumes and nodes. This is mandatory in order to avoid problems due to replicated volumes and can create exhaustive memory consumption if used abusively.; Once aligned, a physical node is ready to be tracked. The operation can be done only after the geometry was closed.; Important NOTE: Calling the Align() method for a physical node changes the node pointers for the stored node branch in the active geometry, Due to this the other defined physical nodes containing elements of this path will be invalid. Example:; TGeoPhysicalNode *pn1 =; gGeoManager->MakePhysicalNode(""/A_1/B_1/C_2"");; TGeoPhysicalNode *pn2 =; gGeoManager->MakePhysicalNode(""/A_1/B_1/C_3"");; ...; pn1->Align(...);; The call to pn1->Align() will invalidate the pointer to the node B_1 in pn2 object.. The way out is to either call pn1->Align() before the creation of pn2, either to use a global method that will correct all existing physical nodes:; void RefreshPhysicalNodes(Bool_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1016338,log,logical,1016338,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['log'],['logical']
Testability,"s the MD5 Algorithm defined in RFC 1321, whose; 108 text is available at; 109 http://www.ietf.org/rfc/rfc1321.txt; 110 The code is derived from the text of the RFC, including the test suite; 111 (section A.5) but excluding the rest of Appendix A. It does not include; 112 any code or documentation that is identified in the RFC as being; 113 copyrighted.; 114 ; 115 The original and principal author of md5.c is L. Peter Deutsch; 116 <ghost@aladdin.com>. Other authors are noted in the change history; 117 that follows (in reverse chronological order):; 118 ; 119 2002-04-13 lpd Clarified derivation from RFC 1321; now handles byte order; 120 either statically or dynamically; added missing #include <string.h>; 121 in library.; 122 2002-03-11 lpd Corrected argument list for main(), and added int return; 123 type, in test program and T value program.; 124 2002-02-21 lpd Added missing #include <stdio.h> in test program.; 125 2000-07-03 lpd Patched to eliminate warnings about ""constant is; 126 unsigned in ANSI C, signed in traditional""; made test program; 127 self-checking.; 128 1999-11-04 lpd Edited comments slightly for automatic TOC extraction.; 129 1999-10-18 lpd Fixed typo in header comment (ansi2knr rather than md5).; 130 1999-05-03 lpd Original version.; 131 */; 132 ; 133#if !defined(MD5_STATIC); 134#include <stdint.h>; 135#include <string.h>; 136#endif; 137 ; 138#undef BYTE_ORDER /* 1 = big-endian, -1 = little-endian, 0 = unknown */; 139#if defined(ARCH_IS_BIG_ENDIAN); 140#define BYTE_ORDER (ARCH_IS_BIG_ENDIAN ? 1 : -1); 141#else; 142#define BYTE_ORDER (0); 143#endif; 144 ; 145#define T_MASK ((md5_word_t)~0); 146#define T1 /* 0xd76aa478 */ (T_MASK ^ 0x28955b87); 147#define T2 /* 0xe8c7b756 */ (T_MASK ^ 0x173848a9); 148#define T3 (0x242070db); 149#define T4 /* 0xc1bdceee */ (T_MASK ^ 0x3e423111); 150#define T5 /* 0xf57c0faf */ (T_MASK ^ 0x0a83f050); 151#define T6 (0x4787c62a); 152#define T7 /* 0xa8304613 */ (T_MASK ^ 0x57cfb9ec); 153#define T8 /* 0xfd469501 */ (T_MASK ^ ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/md5_8inl_source.html:5320,test,test,5320,doc/master/md5_8inl_source.html,https://root.cern,https://root.cern/doc/master/md5_8inl_source.html,1,['test'],['test']
Testability,"s the date and time with a precision of one second in an unsigned 32 bit word (950130...Definition TDatime.h:37; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH2I2-D histogram with an int per channel (see TH1 documentation)Definition TH2.h:225; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TStyle::SetTimeOffsetvoid SetTimeOffset(Double_t toffset)Change the time offset for time plotting.Definition TStyle.cxx:1913; c1return c1Definition legend1.C:41; TMVA_SOFIE_GNN_Parser.h2h2Definition TMVA_SOFIE_GNN_Parser.py:188; hsumDefinition hsum.py:1; . Automatic coloring according to the current palette is available as shown in the following example:; ; void thstackpalettecolor(); {; auto hs = new THStack(""hs"",""Stacked 1D histograms colored using kOcean palette"");; ; gStyle->SetPalette(kOcean);; ; // Create three 1-d histograms and add them in the stack; auto h1st = new TH1F(""h1st"",""test hstack"",100,-4,4);; h1st->FillRandom(""gaus"",20000);; hs->Add(h1st);; ; auto h2st = new TH1F(""h2st"",""test hstack"",100,-4,4);; h2st->FillRandom(""gaus"",15000);; hs->Add(h2st);; ; auto h3st = new TH1F(""h3st"",""test hstack"",100,-4,4);; h3st->FillRandom(""gaus"",10000);; hs->Add(h3st);; ; // draw the stack; hs->Draw(""pfc nostack"");; }; kOcean@ kOceanDefinition TColor.h:119; TStyle::SetPalettevoid SetPalette(Int_t ncolors=kBird, Int_t *colors=nullptr, Float_t alpha=1.)See TColor::SetPalette.Definition TStyle.cxx:1888; . Definition at line 40 of file THStack.h. Public Member Functions;  THStack ();  ;  THStack (const char *name, const char *title);  constructor with name and title ;  ;  THStack (const THStack &hstack);  THStack copy constructor. ;  ;  THStack (TH1 *hist, Option_t *axis=""x"", const char *name=nullptr, const char *title=nullptr, Int_t firstbin=1, Int_t lastbin=-1, Int_t firstbin2=1, Int_t lastbin2=-1, Option_t *proj_option="""", Option_t *draw_option="""");  Creates a new THStack from a TH2 or T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHStack.html:8420,test,test,8420,doc/master/classTHStack.html,https://root.cern,https://root.cern/doc/master/classTHStack.html,3,['test'],['test']
Testability,"s the name of an interpreted C++ function. The function is defined with npar parameters fcn must be a function of type:; Double_t fcn(Double_t *x, Double_t *params); This constructor is called for functions of type C by the C++ interpreter.; WarningA function created with this constructor cannot be Cloned. ; Definition at line 714 of file TF1.cxx. ◆ TF1() [6/15]. TF1::TF1 ; (; const char * ; name, . Double_t(*)(Double_t *, Double_t *) ; fcn, . Double_t ; xmin = 0, . Double_t ; xmax = 1, . Int_t ; npar = 0, . Int_t ; ndim = 1, . EAddToList ; addToGlobList = EAddToList::kDefault . ). Constructor using a pointer to a real function. ; Parameters. [in]nameobject name ; [in]fcnpointer to function ; [in]xmin,xmaxx axis limits ; [in]nparis the number of free parameters used by the function ; [in]ndimnumber of dimensions ; [in]addToGlobListboolean marking if it should be added to global list. This constructor creates a function of type C when invoked with the normal C++ compiler.; see test program test/stress.cxx (function stress1) for an example. note the interface with an intermediate pointer.; WarningA function created with this constructor cannot be Cloned. ; Definition at line 753 of file TF1.cxx. ◆ TF1() [7/15]. TF1::TF1 ; (; const char * ; name, . Double_t(*)(const Double_t *, const Double_t *) ; fcn, . Double_t ; xmin = 0, . Double_t ; xmax = 1, . Int_t ; npar = 0, . Int_t ; ndim = 1, . EAddToList ; addToGlobList = EAddToList::kDefault . ). Constructor using a pointer to (const) real function. ; Parameters. [in]nameobject name ; [in]fcnpointer to function ; [in]xmin,xmaxx axis limits ; [in]nparis the number of free parameters used by the function ; [in]ndimnumber of dimensions ; [in]addToGlobListboolean marking if it should be added to global list. This constructor creates a function of type C when invoked with the normal C++ compiler.; see test program test/stress.cxx (function stress1) for an example. note the interface with an intermediate pointer.; WarningA functi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1.html:52974,test,test,52974,doc/master/classTF1.html,https://root.cern,https://root.cern/doc/master/classTF1.html,2,['test'],['test']
Testability,"s the previous block status. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static Bool_t Connect (const char *sender_class, const char *signal, const char *receiver_class, void *receiver, const char *slot);  This method allows to make a connection from any object of the same class to a single slot. ;  ; static Bool_t Connect (TQObject *sender, const char *signal, const char *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ; static const char * DeclFileName ();  ; static Bool_t Disconnect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Private Member Functions; Int_t Setup () override;  Print the ProofServ logo on standard output. ;  ; Int_t SetupOnFork (const char *ord);  Finalize the server setup afetr forking. ;  . Private Attributes; TProofServLiteInterruptHandler * fInterruptHandler;  ; TString fSockPath;  ; Bool_t fTerminated;  . Additional Inherited Members;  Public Types inherited from TProofServ; enum  EQueryAction { kQueryOK; , kQueryModify; , kQueryStop; , kQueryEnqueued; };  ; enum  EStatusBits { kHighMemory = (1ULL << ( 17 )); };  ;  Public Types inherited from TApplication; enum  EExitOnException { kDontExit; , kExit; , kAbort; };  ; enum  EFileBits { kExpression = (1ULL << ( 14 )); };  ; enum  EStatusBits { kProcessRemotely = (1ULL << ( 15 )); , kDefaultApplication = (1ULL << ( 16 )); };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofServLite.html:22268,log,logo,22268,doc/master/classTProofServLite.html,https://root.cern,https://root.cern/doc/master/classTProofServLite.html,1,['log'],['logo']
Testability,"s title of object. This default method returns the class title; 485/// (i.e. description). Classes that give objects a title should override; 486/// this method.; 487 ; 488const char *TObject::GetTitle() const; 489{; 490 return IsA()->GetTitle();; 491}; 492 ; 493 ; 494////////////////////////////////////////////////////////////////////////////////; 495/// Execute action in response of a timer timing out. This method; 496/// must be overridden if an object has to react to timers.; 497 ; 498Bool_t TObject::HandleTimer(TTimer *); 499{; 500 return kFALSE;; 501}; 502 ; 503////////////////////////////////////////////////////////////////////////////////; 504/// Return hash value for this object.; 505///; 506/// Note: If this routine is overloaded in a derived class, this derived class; 507/// should also add; 508/// ~~~ {.cpp}; 509/// ROOT::CallRecursiveRemoveIfNeeded(*this); 510/// ~~~; 511/// Otherwise, when RecursiveRemove is called (by ~TObject or example) for this; 512/// type of object, the transversal of THashList and THashTable containers will; 513/// will have to be done without call Hash (and hence be linear rather than; 514/// logarithmic complexity). You will also see warnings like; 515/// ~~~; 516/// Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; 517/// ~~~; 518///; 519 ; 520ULong_t TObject::Hash() const; 521{; 522 //return (ULong_t) this >> 2;; 523 const void *ptr = this;; 524 return TString::Hash(&ptr, sizeof(void*));; 525}; 526 ; 527////////////////////////////////////////////////////////////////////////////////; 528/// Returns kTRUE if object inherits from class ""classname"".; 529 ; 530Bool_t TObject::InheritsFrom(const char *classname) const; 531{; 532 return IsA()->InheritsFrom(classname);; 533}; 534 ; 535////////////////////////////////////////////////////////////////////////////////; 536/// Returns kTRUE if obje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TObject_8cxx_source.html:18038,log,logarithmic,18038,doc/master/TObject_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html,1,['log'],['logarithmic']
Testability,"s to be used ; Definition at line 1096 of file NeuralNet.h. ◆ setInputSize(). void TMVA::DNN::Net::setInputSize ; (; size_t ; sizeInput). inline . set the input size of the DNN ; Definition at line 1092 of file NeuralNet.h. ◆ SetIpythonInteractive(). void TMVA::DNN::Net::SetIpythonInteractive ; (; IPythonInteractive * ; fI, . bool * ; fE, . UInt_t * ; M, . UInt_t * ; C . ). inline . Definition at line 1283 of file NeuralNet.h. ◆ setOutputSize(). void TMVA::DNN::Net::setOutputSize ; (; size_t ; sizeOutput). inline . set the output size of the DNN ; Definition at line 1093 of file NeuralNet.h. ◆ train(). template<typename Minimizer > . double TMVA::DNN::Net::train ; (; std::vector< double > & ; weights, . std::vector< Pattern > & ; trainPattern, . const std::vector< Pattern > & ; testPattern, . Minimizer & ; minimizer, . Settings & ; settings . ). start the training ; execute the training until convergence emerges; Parameters. weightsweight vector ; trainPatterntraining pattern ; testPatterntest pattern ; minimizeruse this minimizer for training (e.g. SGD) ; settingssettings used for this training run. Parameters. weightsthe container with the weights (synapses) ; trainPatternthe pattern for the training ; testPatternthe pattern for the testing ; minimizerthe minimizer (e.g. steepest gradient descent) to be used ; settingsthe settings for the training (e.g. multithreading or not, regularization etc.) . Definition at line 712 of file NeuralNet.icc. ◆ trainCycle(). template<typename Iterator , typename Minimizer > . double TMVA::DNN::Net::trainCycle ; (; Minimizer & ; minimizer, . std::vector< double > & ; weights, . Iterator ; itPatternBegin, . Iterator ; itPatternEnd, . Settings & ; settings, . DropContainer & ; dropContainer . ). inline . executes one training cycle ; execute a single training cycle; Parameters. minimizerthe minimizer to be used ; weightsthe weight vector to be used ; itPatternBeginthe pattern to be trained with ; itPatternEndthe pattern to be trained",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Net.html:17105,test,testPatterntest,17105,doc/master/classTMVA_1_1DNN_1_1Net.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Net.html,1,['test'],['testPatterntest']
Testability,"s to be used by the calculator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ToyMCSampler(TestStatistic &ts). virtual ~ToyMCSampler(). SamplingDistribution* AppendSamplingDistribution(RooArgSet& allParameters, RooStats::SamplingDistribution* last, Int_t additionalMC); Extended interface to append to sampling distribution more samples. SamplingDistribution* GetSamplingDistribution(RooArgSet& allParameters); Main interface to get a SamplingDistribution. RooAbsData* GenerateToyData(RooArgSet& allParameters) const; This method generates a toy dataset for the given parameter point. SetParameters(&allParameters, parameters). string MakeName(RooArgSet& ); helper method to create meaningful names for sampling dist. Double_t EvaluateTestStatistic(RooAbsData& data, RooArgSet& allParameters); Main interface to evaluate the test statistic on a dataset. const RooAbsArg* GetTestStatistic() const; Get the TestStatistic. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void Initialize(RooAbsArg& , RooArgSet& , RooArgSet& ); Common Initialization. void SetNEventsPerToy(const Int_t nevents). void SetExtended(const Bool_t isExtended). void SetData(RooAbsData& data); Set the DataSet, add to the the workspace if not already there. void SetPdf(RooAbsPdf& pdf); Set the Pdf, add to the the workspace if not already there. void SetData(const char* name); specify the name of the dataset in the workspace to be used. {fDataName = name;}. void SetPdf(const char* name); specify the name of the PDF in the workspace to be used. {fPdfName = name;}. void SetNuisanceParameters(RooArgSet& set); specify the nuisance parameters (eg. the rest of the parameters). {fNuisParams = &set;}. void SetObservables(RooArgSet& set); specify the observables in the dataset (needed to evaluate the test statistic). {fObservables = &set;}. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__ToyMCSampler.html:4715,test,test,4715,root/html526/RooStats__ToyMCSampler.html,https://root.cern,https://root.cern/root/html526/RooStats__ToyMCSampler.html,1,['test'],['test']
Testability,"s tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo002_VectorCalculations.C In this tutorial we learn how the RVec class can be used to express easily mathematical operations involving arrays and scalars ;  vo003_LogicalOperations.C In this tutorial we learn how the RVec class can be used to express logical operations ;  ► xml;  DOMParsePerson.C ROOT implementation of a XML DOM Parser ;  DOMRecursive.C ROOT implementation of a XML DOM Parser ;  SAXHandler.C ROOT implementation of a simple SAX Handler ;  xmlmodifyfile.C Example to read, modify and store xml file, using TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ;  xmlnewfile.C Example to create a new xml file with the TXMLEngine class ;  xmlreadfile.C Example to read and parse any xml file, supported by TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ;  benchmarks.CThis macro run several tests and produces an benchmark report ;  demos.CThis macro shows a control bar to run some of the ROOT tutorials ;  demoshelp.CThis macro shows help on running the Demos ;  geant3tasks.CThis script is a representation using TTasks of the Geant3 simulation program This example uses directly TTask objects ;  hsimple.C This program creates : ;  htmlex.CThis file demonstrates how THtml can document sources ;  MyTasks.cxxA set of classes deriving from TTask ;  regexp.CA regular expression, often called a pattern, is an expression that describes a set of strings ;  regexp_pme.CClass TPMERegexp - API similar to PME - PCRE Made Easy Tries to be as close as possible to PERL syntax and functionality ;  rootalias.CDefines aliases: ;  rootenv.CProduce a picture of the ROOT environment ;  rootlogoff.CExample of rootlogoff.C ;  rootlogon.CExample of rootlogon.C ;  rootmarks.CPrints a summary of all ROOT benchmarks (must be run bef",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:166288,benchmark,benchmarks,166288,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,1,['benchmark'],['benchmarks']
Testability,"s used as weight. A separate firstval argument is needed so the compiler does not pick this overload instead of the non-templated Fill overloads ; Definition at line 167 of file THnBase.h. ◆ FillBin(). virtual void THnBase::FillBin ; (; Long64_t ; bin, . Double_t ; w . ). pure virtual . Implemented in THn, and THnSparse. ◆ FillBinBase(). void THnBase::FillBinBase ; (; Double_t ; w). inlineprotected . Increment the statistics due to filled weight ""w"",. ; Definition at line 89 of file THnBase.h. ◆ Fit(). TFitResultPtr THnBase::Fit ; (; TF1 * ; f, . Option_t * ; option = """", . Option_t * ; goption = """" . ). Fit a THnSparse with function f. ; since the data is sparse by default a likelihood fit is performed merging all the regions with empty bins for better performance efficiency; Since the THnSparse is not drawn no graphics options are passed Here is the list of possible options = ""I"" Use integral of function in bin instead of value at bin center; = ""X"" Use chi2 method (default is log-likelihood method); = ""U"" Use a User specified fitting algorithm (via SetFCN); = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""B"" Use this option when you want to fix one or more parameters; and the fitting function is like ""gaus"", ""expo"", ""poln"", ""landau"".; = ""M"" More. Improve fit results; = ""R"" Use the Range specified in the function range . Definition at line 505 of file THnBase.cxx. ◆ GetAxis(). TAxis * THnBase::GetAxis ; (; Int_t ; dim); const. inline . Definition at line 130 of file THnBase.h. ◆ GetBin() [1/6]. virtual Long64_t THnBase::GetBin ; (; const char * ; name[]); const. pure virtual . Implemented in THn, and THnSparse. ◆ GetBin() [2/6]. virtual Long64_t THnBase::GetBin ; (; const char * ; name[], . Bool_t ; = kTRUE . ). pure virtual . Implemented in THnSparse, and THn. ◆ GetBin() [3/6]. virtual Long64_t THnBase::GetBin ; (; const Double_t * ; x); const. pure virtual . Imple",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHnBase.html:29364,log,log-likelihood,29364,doc/master/classTHnBase.html,https://root.cern,https://root.cern/doc/master/classTHnBase.html,1,['log'],['log-likelihood']
Testability,"s used for async running; TSelector*TProof::fSelectorSelector to be processed, if any; TProofMgr::EServTypeTProof::fServTypetype of server: proofd, XrdProofd; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TList*TProof::fSlaveslist of all slave servers as in config file; TList*TProof::fTerminatedSlaveInfoslist of unique infos of terminated slaves; TStringTNamed::fTitleobject title; Long64_tTProof::fTotalBytesnumber of bytes to be analyzed; TUrlTProof::fUrlUrl of the master; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TSemaphore*TProof::fgSemaphoresemaphore to control no of parallel startup threads; static TProof::ESlavesTProof::kActive; static TProof::ESlavesTProof::kAll; static TProof::ESlavesTProof::kAllUnique; static TProof::ESlavesTProof::kUnique. private:. TCondor*fCondorproxy for our Condor pool; TTimer*fTimertimer for delayed Condor COD suspend. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofCondor(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); Start proof using condor. ~TProofCondor(); Clean up Condor PROOF environment. Bool_t StartSlaves(Bool_t ); Setup Condor workers using dynamic information. void SetActive(Bool_t active); Suspend or resume PROOF via Condor. TString GetJobAd(); Get job Ad. TProofCondor(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0). void SetActive(); { TProof::SetActive(); }. » Author: Fons Rademakers 13/02/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-06-02 16:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofCondor.html:28332,log,loglevel,28332,root/html604/TProofCondor.html,https://root.cern,https://root.cern/root/html604/TProofCondor.html,2,['log'],['loglevel']
Testability,"s used for async running; TSelector*TProof::fSelectorSelector to be processed, if any; TProofMgr::EServTypeTProof::fServTypetype of server: proofd, XrdProofd; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TList*TProof::fSlaveslist of all slave servers as in config file; TList*TProof::fTerminatedSlaveInfoslist of unique infos of terminated slaves; TStringTNamed::fTitleobject title; Long64_tTProof::fTotalBytesnumber of bytes to be analyzed; TUrlTProof::fUrlUrl of the master; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TSemaphore*TProof::fgSemaphoresemaphore to control no of parallel startup threads; static TProof::ESlavesTProof::kActive; static TProof::ESlavesTProof::kAll; static TProof::ESlavesTProof::kAllUnique; static TProof::ESlavesTProof::kUnique. private:. TCondor*fCondorproxy for our Condor pool; TTimer*fTimertimer for delayed Condor COD suspend. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofCondor(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); Start proof using condor. ~TProofCondor(); Clean up Condor PROOF environment. Bool_t StartSlaves(Bool_t ); Setup Condor workers using dynamic information. void SetActive(Bool_t active); Suspend or resume PROOF via Condor. TString GetJobAd(); Get job Ad. TProofCondor(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0). void SetActive(); { TProof::SetActive(); }. » Author: Fons Rademakers 13/02/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-06-30 15:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofCondor.html:28071,log,loglevel,28071,root/html602/TProofCondor.html,https://root.cern,https://root.cern/root/html602/TProofCondor.html,2,['log'],['loglevel']
Testability,"s useful to contact us first to discuss the code you want to develop or the bug you want to fix.; Picking up an Idea; We maintain a set of ""ideas"" for talented scientists and developers to pick up. An ""idea"" is a sketch of a development project, a functionality a missing feature we would like to see in our tool, in your ROOT! You can inspect the ideas in the following list. Ideas. ; 30-01-2019 ; Transform GNU-makefile tests to CMake; ROOT's test suite has several crucial tests that still try on GNU-Makefile. We need to integrate them with CMake. ; 30-01-2019 ; Better argument parsing; Use a C++ command line argument library for defining and parsing ROOT's options. ; 30-01-2019 ; More tests, more benchmarks!; ROOT relies on testing, including performance testing - and we need to improve both. ; 05-01-2016 ; Wanted: A tool to 'warn' user of inefficient (for I/O) construct in data model; A tool to 'warn' user of inefficient (for I/O) construct in data model. ; 02-09-2015 ; Wanted: Storage of HEP data via key/value storage solutions; Interface the ROOT I/O to key/value stores. Completed ideas. ; 28-03-2015 ; Commandline tools for ROOT files inspection, modification and automated plotting; Create a unix-like set of Python command line tools to explore, modify and display the content of ROOT files. . Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/collaborate-with-us.html:4812,test,tests,4812,d/collaborate-with-us.html,https://root.cern,https://root.cern/d/collaborate-with-us.html,1,['test'],['tests']
Testability,"s using the 10 files............... OK; Test 12 : Compare histograms of test 9 and 11................... OK; Test 13 : Test merging files of a chain......................... OK; Test 14 : Check correct rebuilt of Event.root in test 13........ OK; Test 15 : Divert Tree branches to separate files................ OK; Test 16 : Cling test (3 nested loops) with LHCb trigger.......... OK; ******************************************************************; * IRIX64 fnpat1 6.5 01221553 IP27; ******************************************************************; stress : Total I/O = 75.3 Mbytes, I = 59.2, O = 16.1; stress : Compr I/O = 75.7 Mbytes, I = 60.0, O = 15.7; stress : Real Time = 307.61 seconds Cpu Time = 292.82 seconds; ******************************************************************; * ROOTMARKS = 53.7 * Root2.25/00 20000710/1022; 20.2.3 guitest - A Graphical User Interface. The guitest example, created by compiling guitest.cxx, tests and illustrates the use of the native GUI widgets such as cascading menus, dialog boxes, sliders and tab panels. It is a very useful example to study when designing a GUI. Some examples of the output of guitest are shown next. To run it type guitest at the system prompt in the $ROOTSYS/test directory. We have included an entire chapter on this subject where we explore guitest in detail and use it to explain how to build our own ROOT application with a GUI. See “Writing a Graphical User Interface”. Native GUI widgets. 21 Example Analysis; This chapter is an example of a typical physics analysis. Large data files are chained together and analyzed using the TSelector class.; 21.1 Explanation; This script uses four large data sets from the H1 collaboration at DESY Hamburg. One can access these data sets (277 Mbytes) from the ROOT web site at: ftp://root.cern.ch/root/h1analysis/; The physics plots generated by this example cannot be produced using smaller data sets.; There are several ways to analyze data stored in a ROOT Tree. Using TTree:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1086164,test,tests,1086164,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['test'],['tests']
Testability,"s { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TMVA::MethodBase; Bool_t fSetupCompleted;  ; TrainingHistory fTrainHistory;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Attributes inherited from TMVA::MethodCompositeBase; MethodBase * fCurrentMethod;  ; UInt_t fCurrentMethodIdx;  ; std::vector< IMethod * > fMethods;  vector of all classifiers ;  ; std::vector< Double_t > fMethodWeight;  ;  Protected Attributes inherited from TMVA::MethodBase; Types::EAnalysisType fAnalysisType;  ; UInt_t fBackgroundClass;  ; bool fExitFromTraining = false;  ; std::vector< TString > * fInputVars;  ; IPythonInteractive * fInteractive = nullptr;  temporary dataset used when evaluating on a different data (used by MethodCategory::GetMvaValues) ;  ; UInt_t fIPyCurrentIter = 0;  ; UInt_t fIPyMaxIter = 0;  ; std::vector< Float_t > * fMulticlassReturnVal;  ; Int_t fNbins;  ; Int_t fNbinsH;  ; Int_t fNbinsMVAoutput;  ; Ranking * fRanking;  ; std::vector< Float_t > * fRegressionReturnVal;  ; Results * fResults;  ; UInt_t fSignalClass;  ; DataSet * fTmpData = nullptr;  temporary event when testing on a different DataSet than the own one ;  ; const Event * fTmpEvent;  ;  Protected Attributes inherited from TMVA::Configurable; MsgLogger * fLogger;  ! message logger ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . #include <TMVA/MethodBoost.h>. Inheritance diagram for TMVA::MethodBoost:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ MethodBoost() [1/2]. TMVA::MethodBoost::MethodBoost ; (; const TString & ; jobName, . cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBoost.html:32187,test,testing,32187,doc/master/classTMVA_1_1MethodBoost.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBoost.html,2,"['log', 'test']","['logger', 'testing']"
Testability,"s |; Static Public Member Functions |; Private Attributes |; List of all members ; TFitResultPtr Class Reference. ; Provides an indirection to the TFitResult class and with a semantics identical to a TFitResult pointer, i.e. ; it is like a smart pointer to a TFitResult. In addition it provides an automatic conversion to an integer. In this way it can be returned from the TH1::Fit method and the change in TH1::Fit be backward compatible. ; Definition at line 32 of file TFitResultPtr.h. Public Member Functions;  TFitResultPtr (const std::shared_ptr< TFitResult > &p);  Constructor from a TFitResult pointer. ;  ;  TFitResultPtr (const TFitResultPtr &rhs);  ;  TFitResultPtr (int status=-1);  ;  TFitResultPtr (TFitResult *p);  Constructor from a TFitResult pointer. ;  ; virtual ~TFitResultPtr ();  Destructor. ;  ; TFitResult * Get () const;  Return contained pointer. ;  ; virtual TClass * IsA () const;  ;  operator int () const;  ; TFitResult & operator* () const;  Implement the de-reference operator to make the class acts as a pointer to a TFitResult assert in case the class does not contain a pointer to TFitResult. ;  ; TFitResult * operator-> () const;  Implement the -> operator to make the class acts as a pointer to a TFitResult. ;  ; TFitResultPtr & operator= (const TFitResultPtr &rhs);  Assignment operator. ;  ; virtual void Streamer (TBuffer &);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Private Attributes; std::shared_ptr< TFitResult > fPointer;  ! Smart Pointer to TFitResult class ;  ; int fStatus;  fit status code ;  . #include <TFitResultPtr.h>; Constructor & Destructor Documentation. ◆ TFitResultPtr() [1/4]. TFitResultPtr::TFitResultPtr ; (; int ; status = -1). inline . Definition at line 35 of file TFitResultPtr.h. ◆ TFitResultPtr() [2/4]. TFitResultPt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFitResultPtr.html:1227,assert,assert,1227,doc/master/classTFitResultPtr.html,https://root.cern,https://root.cern/doc/master/classTFitResultPtr.html,1,['assert'],['assert']
Testability,"s"", theMethod->fDataSetInfo.GetName(), mname[0][i].Data());; 1924 // for (UInt_t icls = 0; icls < theMethod->fDataSetInfo.GetNClasses(); ++icls) {; 1925 // res += TString::Format(""%#1.3f "", (multiclass_testEff[i][icls]) * (multiclass_testPur[i][icls]));; 1926 // }; 1927 // Log() << kINFO << res << Endl;; 1928 // }; 1929 ; 1930 // Log() << kINFO << hLine << Endl;; 1931 // Log() << kINFO << Endl;; 1932 // }; 1933 ; 1934 // --- 1 vs Rest ROC AUC, signal efficiency @ given background efficiency; 1935 // --------------------------------------------------------------------; 1936 TString header1 = TString::Format(""%-15s%-15s%-15s%-15s%-15s%-15s"", ""Dataset"", ""MVA Method"", ""ROC AUC"", ""Sig eff@B=0.01"",; 1937 ""Sig eff@B=0.10"", ""Sig eff@B=0.30"");; 1938 TString header2 = TString::Format(""%-15s%-15s%-15s%-15s%-15s%-15s"", ""Name:"", ""/ Class:"", ""test (train)"", ""test (train)"",; 1939 ""test (train)"", ""test (train)"");; 1940 Log() << kINFO << Endl;; 1941 Log() << kINFO << ""1-vs-rest performance metrics per class"" << Endl;; 1942 Log() << kINFO << hLine << Endl;; 1943 Log() << kINFO << Endl;; 1944 Log() << kINFO << ""Considers the listed class as signal and the other classes"" << Endl;; 1945 Log() << kINFO << ""as background, reporting the resulting binary performance."" << Endl;; 1946 Log() << kINFO << ""A score of 0.820 (0.850) means 0.820 was acheived on the"" << Endl;; 1947 Log() << kINFO << ""test set and 0.850 on the training set."" << Endl;; 1948 ; 1949 Log() << kINFO << Endl;; 1950 Log() << kINFO << header1 << Endl;; 1951 Log() << kINFO << header2 << Endl;; 1952 for (Int_t k = 0; k < 2; k++) {; 1953 for (Int_t i = 0; i < nmeth_used[k]; i++) {; 1954 if (k == 1) {; 1955 mname[k][i].ReplaceAll(""Variable_"", """");; 1956 }; 1957 ; 1958 const TString datasetName = itrMap->first;; 1959 const TString mvaName = mname[k][i];; 1960 ; 1961 MethodBase *theMethod = dynamic_cast<MethodBase *>(GetMethod(datasetName, mvaName));; 1962 if (theMethod == 0) {; 1963 continue;; 1964 }; 1965 ; 1966 Log() << kINFO <<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:81080,test,test,81080,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,4,['test'],['test']
Testability,"s& axis1, const TAxis& axis2);; 141 Bool_t IsEmpty() const;; 142 UInt_t GetAxisLabelStatus() const;; 143 ; 144 inline static Double_t AutoP2GetPower2(Double_t x, Bool_t next = kTRUE);; 145 inline static Int_t AutoP2GetBins(Int_t n);; 146 virtual Int_t AutoP2FindLimits(Double_t min, Double_t max);; 147 ; 148 virtual Double_t DoIntegral(Int_t ix1, Int_t ix2, Int_t iy1, Int_t iy2, Int_t iz1, Int_t iz2, Double_t & err,; 149 Option_t * opt, Bool_t doerr = kFALSE) const;; 150 ; 151 virtual void DoFillN(Int_t ntimes, const Double_t *x, const Double_t *w, Int_t stride=1);; 152 Bool_t GetStatOverflowsBehaviour() const { return EStatOverflows::kNeutral == fStatOverflows ? fgStatOverflows : EStatOverflows::kConsider == fStatOverflows; }; 153 ; 154 static bool CheckAxisLimits(const TAxis* a1, const TAxis* a2);; 155 static bool CheckBinLimits(const TAxis* a1, const TAxis* a2);; 156 static bool CheckBinLabels(const TAxis* a1, const TAxis* a2);; 157 static bool CheckEqualAxes(const TAxis* a1, const TAxis* a2);; 158 static bool CheckConsistentSubAxes(const TAxis *a1, Int_t firstBin1, Int_t lastBin1, const TAxis *a2, Int_t firstBin2=0, Int_t lastBin2=0);; 159 static int CheckConsistency(const TH1* h1, const TH1* h2);; 160 int LoggedInconsistency(const char* name, const TH1* h1, const TH1* h2, bool useMerge=false) const;; 161 ; 162public:; 163 /// TH1 status bits; 164 enum EStatusBits {; 165 kNoStats = BIT(9), ///< Don't draw stats box; 166 kUserContour = BIT(10), ///< User specified contour levels; 167 // kCanRebin = BIT(11), ///< FIXME DEPRECATED - to be removed, replaced by SetCanExtend / CanExtendAllAxes; 168 kLogX = BIT(15), ///< X-axis in log scale; 169 kIsZoomed = BIT(16), ///< Bit set when zooming on Y axis; 170 kNoTitle = BIT(17), ///< Don't draw the histogram title; 171 kIsAverage = BIT(18), ///< Bin contents are average (used by Add); 172 kIsNotW = BIT(19), ///< Histogram is forced to be not weighted even when the histogram is filled with weighted; 173 /// different than 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8h_source.html:6990,log,log,6990,doc/master/TH1_8h_source.html,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html,1,['log'],['log']
Testability,"s&). Data Members; private:. EGLCoordTypefCoordType; Double_tfFactor; Bool_tfModified; Rgl::BinRange_tfXBins; Bool_tfXLog; Rgl::Range_tfXRange; Rgl::Range_tfXRangeScaled; Double_tfXScale; Rgl::BinRange_tfYBins; Bool_tfYLog; Rgl::Range_tfYRange; Rgl::Range_tfYRangeScaled; Double_tfYScale; Rgl::BinRange_tfZBins; Bool_tfZLog; Rgl::Range_tfZRange; Rgl::Range_tfZRangeScaled; Double_tfZScale. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPlotCoordinates(); Constructor. ~TGLPlotCoordinates(); Destructor. void SetCoordType(EGLCoordType type); If coord type was changed, plot must reset sections (if any),; set fModified. EGLCoordType GetCoordType() const; Get coordinates type. void SetXLog(Bool_t xLog); If log changed, sections must be reset,; set fModified. Bool_t GetXLog() const; Get X log. void SetYLog(Bool_t yLog); If log changed, sections must be reset,; set fModified. Bool_t GetYLog() const; Get Y log. void SetZLog(Bool_t zLog); If log changed, sections must be reset,; set fModified. Bool_t GetZLog() const; Get Z log. void ResetModified(); Reset modified. Bool_t Modified() const; Modified. Bool_t SetRanges(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Set bin ranges, ranges. Int_t GetNXBins() const; Number of X bins. Int_t GetNYBins() const; Number of Y bins. Int_t GetNZBins() const; Number of Z bins. const Rgl::BinRange_t & GetXBins() const; X bins range. const Rgl::BinRange_t & GetYBins() const; Y bins range. const Rgl::BinRange_t & GetZBins() const; Z bins range. const Rgl::Range_t & GetXRange() const; X range. Double_t GetXLength() const; X length. const Rgl::Range_t & GetYRange() const; Y range. Double_t GetYLength() const; Y length. const Rgl::Range_t & GetZRange() const; Z range. Double_t GetZLength() const; Z length. const Rgl::Range_t & GetXRangeScaled() const; Scaled range. const Rgl::Range_t & GetYRangeScaled() const; Scaled range. const Rgl::Range_t & GetZRangeScaled() const; Scaled range. Dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLPlotCoordinates.html:3273,log,log,3273,root/html602/TGLPlotCoordinates.html,https://root.cern,https://root.cern/root/html602/TGLPlotCoordinates.html,2,['log'],['log']
Testability,"s';; let obj = parse(json_string);; 1.11.3 Objects drawing; After an object has been created, one can directly draw it. If HTML page has <div> element:; <div id=""drawing""></div>; One could use the draw function:; import { draw } from 'https://root.cern/js/latest/modules/main.mjs';; draw(""drawing"", obj, ""colz"");; The first argument is the id of the HTML div element, where drawing will be performed. The second argument is the object to draw and the third one is the drawing option.; Here is complete running example ans source code:; import { httpRequest, draw, redraw, resize, cleanup } from 'https://root.cern/js/latest/modules/main.mjs';; let filename = ""https://root.cern/js/files/th2ul.json.gz"";; let obj = await httpRequest(filename, 'object');; draw(""drawing"", obj, ""lego"");; In very seldom cases one need to access painter object, created in draw() function. This can be done via handling Promise results like:; let painter = await draw(""drawing"", obj, ""colz"");; console.log('Object type in painter', painter.getClassName());; One is also able to update the drawing with a new version of the object:; // after some interval request object again; redraw(""drawing"", obj2, ""colz"");; The redraw function will call draw if the drawing was not performed before.; In the case when changing of HTML layout leads to resize of element with JSROOT drawing, one should call resize() to let JSROOT adjust drawing size. One should do:; resize(""drawing"");; As second argument one could specify exact size for draw elements like:; resize(""drawing"", { width: 500, height: 200 });; To correctly cleanup JSROOT drawings from HTML element, one should call:; cleanup(""drawing"");; 1.11.4 File API; JSROOT defines the TFile class, which can be used to access binary ROOT files. One should always remember that all I/O operations are asynchronous in JSROOT. Therefore promises are used to retrieve results when the I/O operation is completed. For example, reading an object from a file and displaying it will look ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:27178,log,log,27178,root/htmldoc/guides/JSROOT/JSROOT.html,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html,1,['log'],['log']
Testability,"s() const { return fStatus; }; 129 ; 130 ///covariance matrix status code; 131 /// using Minuit convention : =0 not calculated, =1 approximated, =2 made pos def , =3 accurate; 132 ; 133 int CovMatrixStatus() const { return fCovStatus; }; 134 ; 135 /** fitting quantities **/; 136 ; 137 /// Return pointer to model (fit) function with fitted parameter values.; 138 /// Pointer is managed internally. I must not be deleted; 139 const IModelFunction * FittedFunction() const {; 140 return fFitFunc.get();; 141 }; 142 ; 143 /// return BinData used in the fit (return a nullptr in case a different fit is done; 144 /// or the data are not available; 145 /// Pointer is managed internally, it must not be deleted; 146 const BinData * FittedBinData() const;; 147 ; 148 ; 149 /// Return the Chi2 value after fitting; 150 /// In case of unbinned fits (or not defined one, see the documentation of Fitter::FitFCN) return -1; 151 /// In case of binned likelihood fits (Poisson Likelihood) return the 2 * negative log-likelihood ratio; 152 /// using the definition of Baker-Cousins; 153 double Chi2() const { return fChi2; }; 154 ; 155 /// Number of degree of freedom; 156 unsigned int Ndf() const { return fNdf; }; 157 ; 158 /// p value of the fit (chi2 probability); 159 double Prob() const;; 160 ; 161 /// parameter errors (return st::vector); 162 const std::vector<double> & Errors() const { return fErrors; }; 163 /// parameter errors (return const pointer); 164 const double * GetErrors() const { return fErrors.empty() ? nullptr : &fErrors.front(); }; 165 ; 166 /// parameter values (return std::vector); 167 const std::vector<double> & Parameters() const { return fParams; }; 168 /// parameter values (return const pointer); 169 const double * GetParams() const { return &fParams.front(); }; 170 ; 171 /// parameter value by index; 172 double Value(unsigned int i) const { return fParams[i]; }; 173 /// parameter value by index; 174 double Parameter(unsigned int i) const { return fParams[i]; }; 175 ; 176",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/FitResult_8h_source.html:5415,log,log-likelihood,5415,doc/master/FitResult_8h_source.html,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html,1,['log'],['log-likelihood']
Testability,s(). template<typename Architecture_t > . size_t TMVA::DNN::TGradientDescent< Architecture_t >::GetConvergenceSteps ; (; ); const. inline . Definition at line 160 of file Minimizers.h. ◆ GetTestError(). template<typename Architecture_t > . Scalar_t TMVA::DNN::TGradientDescent< Architecture_t >::GetTestError ; (; ); const. inline . Definition at line 162 of file Minimizers.h. ◆ GetTestInterval(). template<typename Architecture_t > . size_t TMVA::DNN::TGradientDescent< Architecture_t >::GetTestInterval ; (; ); const. inline . Definition at line 163 of file Minimizers.h. ◆ GetTrainingError(). template<typename Architecture_t > . Scalar_t TMVA::DNN::TGradientDescent< Architecture_t >::GetTrainingError ; (; ); const. inline . Definition at line 161 of file Minimizers.h. ◆ HasConverged() [1/2]. template<typename Architecture_t > . bool TMVA::DNN::TGradientDescent< Architecture_t >::HasConverged. inline . Increases the minimization step counter by the test error evaluation period and uses the current internal value of the test error to determine if the minimization has converged. ; Definition at line 667 of file Minimizers.h. ◆ HasConverged() [2/2]. template<typename Architecture_t > . bool TMVA::DNN::TGradientDescent< Architecture_t >::HasConverged ; (; Scalar_t ; testError). inline . Increases the minimization step counter by the test error evaluation period and uses the provided test error value to determine if the minimization has converged. ; Definition at line 681 of file Minimizers.h. ◆ Reset(). template<typename Architecture_t > . void TMVA::DNN::TGradientDescent< Architecture_t >::Reset ; (; ). inline . Reset minimizer object to default state. ; Definition at line 81 of file Minimizers.h. ◆ SetBatchSize(). template<typename Architecture_t > . void TMVA::DNN::TGradientDescent< Architecture_t >::SetBatchSize ; (; Scalar_t ; rate). inline . Definition at line 168 of file Minimizers.h. ◆ SetConvergenceSteps(). template<typename Architecture_t > . void TMVA::DNN::TGrad,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TGradientDescent.html:7249,test,test,7249,doc/master/classTMVA_1_1DNN_1_1TGradientDescent.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TGradientDescent.html,2,['test'],['test']
Testability,"s(); set the training parameters. void SetTestParms(); set the test params. void FillRealParmsDef(); set default real params. void FillIntParmsDef(); set default int params. Bool_t WriteAll(); write all files read by rf_go.exe. Bool_t WriteIntParms(); write int params file. Bool_t WriteRealParms(); write int params file. Bool_t WriteLx(); Save input variable mask. If the lx vector size is not the same as inputVars,; resize it and fill it with 1; NOTE: Always set all to 1; if (fRFLx.size() != m_inputVars->size()) {. Bool_t WriteProgram(); write command to rf_go.exe. Bool_t WriteRealVarImp(); write the minimum importance to be considered. Bool_t WriteRfOut(); written by rf_go.exe; write rulefit output (rfout). Bool_t WriteRfStatus(); written by rf_go.exe; write rulefit status. Bool_t WriteRuleFitMod(); written by rf_go.exe (NOTE:Format unknown!). Bool_t WriteRuleFitSum(); written by rf_go.exe (NOTE: format unknown!). Bool_t WriteTrain(); write training data, columnwise. Bool_t WriteTest(); Write test data. Bool_t WriteVarNames(); write variable names, ascii. Bool_t WriteVarImp(); written by rf_go.exe. Bool_t WriteYhat(); written by rf_go.exe. Bool_t ReadYhat(); read the score. Bool_t ReadVarImp(); read variable importance. Bool_t ReadModelSum(); read model from rulefit.sum. Int_t RunRuleFit(); execute rf_go.exe. void TrainRuleFit(). void TestRuleFit(). void VarImp(). TString GetRFName(TString name). Bool_t OpenRFile(TString name, ofstream& f). Bool_t OpenRFile(TString name, ifstream& f). Bool_t WriteInt(ofstream& f, const Int_t* v, Int_t n = 1). Bool_t WriteFloat(ofstream& f, const Float_t* v, Int_t n = 1). Int_t ReadInt(ifstream& f, Int_t* v, Int_t n = 1) const. Int_t ReadFloat(ifstream& f, Float_t* v, Int_t n = 1) const. RuleFitAPI(const TMVA::MethodRuleFit* rfbase, TMVA::RuleFit* rulefit, TMVA::EMsgType minType). const TString GetRFWorkDir() const; Get working directory. { return fRFWorkDir; }. void SetRFTrain(); set rf_go.exe running mode. { fRFProgram = kRfTrain; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__RuleFitAPI.html:4554,test,test,4554,root/html528/TMVA__RuleFitAPI.html,https://root.cern,https://root.cern/root/html528/TMVA__RuleFitAPI.html,6,['test'],['test']
Testability,"s(const char* msg, const char* usr = 0); virtual voidTProofMgr::SetAlias(const char* alias = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetInvalid(); virtual voidTProofMgr::SetMssUrl(const char* mss); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual Int_tSetROOTVersion(const char* tag); virtual voidTNamed::SetTitle(const char* title = """")MENU ; static voidTProofMgr::SetTXProofMgrHook(TProofMgr_t pmh); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidShowROOTVersions(); virtual voidShowWorkers(); virtual voidTProofMgr::ShutdownSession(Int_t id); virtual voidTProofMgr::ShutdownSession(TProof* p); virtual Int_tTNamed::Sizeof() const; virtual Int_tStat(const char* what, FileStat_t& st, const char* where = 0); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTail(const char* what, const char* how = 0, const char* where = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TXProofMgr(const TXProofMgr&); TXProofMgr(const char* url, Int_t loglevel = -1, const char* alias = """"); static TFileCollection*TProofMgr::UploadFiles(TList* src, const char* mss, const char* dest = 0); static TFileCollection*TProofMgr::UploadFiles(const char* txtfile, const char* mss, const char* dest = 0); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXProofMgr.html:7795,log,loglevel,7795,root/html602/TXProofMgr.html,https://root.cern,https://root.cern/root/html602/TXProofMgr.html,2,['log'],['loglevel']
Testability,"s(eta)>1.3""; : Dataset[Category_Fisher_2_dsi] : Signal -- number of events passed: 4877 / sum of weights: 4877 ; : Dataset[Category_Fisher_2_dsi] : Signal -- efficiency : 0.4877; : Dataset[Category_Fisher_2_dsi] : Background requirement: ""abs(eta)>1.3""; : Dataset[Category_Fisher_2_dsi] : Background -- number of events passed: 4866 / sum of weights: 4866 ; : Dataset[Category_Fisher_2_dsi] : Background -- efficiency : 0.4866; : Dataset[Category_Fisher_2_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.4877 preselection efficiency); : Dataset[Category_Fisher_2_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.4866 preselection efficiency); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 2438; : Signal -- testing events : 2438; : Signal -- training and testing events: 4876; : Dataset[Category_Fisher_2_dsi] : Signal -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.4877; : Background -- training events : 2433; : Background -- testing events : 2433; : Background -- training and testing events: 4866; : Dataset[Category_Fisher_2_dsi] : Background -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.4866; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.005 +0.002 -0.039; : var2: -0.005 +1.000 +0.011 -0.004; : var3: +0.002 +0.011 +1.000 -0.021; : var4: -0.039 -0.004 -0.021 +1.000; : ----------------------------------------; <HEADER> DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.007 +0.009 +0.008; : var2: -0.007 +1.000 -0.020 +0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassificationCategory_8C.html:9771,test,testing,9771,doc/master/TMVAClassificationCategory_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html,3,['test'],['testing']
Testability,"s(modelName):; useKeras = False; print(""Error creating Keras recurrent model file - Skip using Keras""); else:; # book PyKeras method only if Keras model could be created; print(""Booking Keras model "", rnn_types[i]); factory.BookMethod(; dataloader,; TMVA.Types.kPyKeras,; ""PyKeras_"" + rnn_types[i],; H=True,; V=False,; VarTransform=None,; FilenameModel=modelName,; FilenameTrainedModel=""trained_"" + modelName,; NumEpochs=maxepochs,; BatchSize=batchSize,; GpuOptions=""allow_growth=True"",; ); ; ; # use BDT in case not using Keras or TMVA DL; if not useKeras or not useTMVA_BDT:; useTMVA_BDT = True; ; ; ## Book TMVA BDT; ; ; if useTMVA_BDT:; factory.BookMethod(; dataloader,; TMVA.Types.kBDT,; ""BDTG"",; H=True,; V=False,; NTrees=100,; MinNodeSize=""2.5%"",; BoostType=""Grad"",; Shrinkage=0.10,; UseBaggedBoost=True,; BaggedSampleFraction=0.5,; nCuts=20,; MaxDepth=2,; ); ; ; ## Train all methods; factory.TrainAllMethods(); ; print(""nthreads = {}"".format(ROOT.GetThreadPoolSize())); ; # ---- Evaluate all MVAs using the set of test events; factory.TestAllMethods(); ; # ----- Evaluate and compare performance of all configured MVAs; factory.EvaluateAllMethods(); ; # check method; ; # plot ROC curve; c1 = factory.GetROCCurve(dataloader); c1.Draw(); ; if outputFile:; outputFile.Close(); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:61293,test,test,61293,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['test'],['test']
Testability,s*Class(); TMVA::TActivation*CreateActivation(TMVA::TActivationChooser::EActivationType type) const; TMVA::TActivation*CreateActivation(const TString& type) const; vector<TString>*GetAllActivationNames() const; virtual TClass*IsA() const; TMVA::TActivationChooser&operator=(const TMVA::TActivationChooser&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TMVA::TActivationChooserTActivationChooser(); TMVA::TActivationChooserTActivationChooser(const TMVA::TActivationChooser&). private:. TMVA::MsgLogger&Log() const. Data Members; public:. static TMVA::TActivationChooser::EActivationTypekLinear; static TMVA::TActivationChooser::EActivationTypekRadial; static TMVA::TActivationChooser::EActivationTypekReLU; static TMVA::TActivationChooser::EActivationTypekSigmoid; static TMVA::TActivationChooser::EActivationTypekTanh. private:. TStringfLINEARactivation function name; TMVA::MsgLogger*fLogger! message logger; TStringfRADIALactivation function name; TStringfRELUactivation function name; TStringfSIGMOIDactivation function name; TStringfTANHactivation function name. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TActivationChooser(); defaut constructor. ~TActivationChooser(); destructor. CreateActivation(EActivationType type); instantiate the correct activation object according to the; type choosen (given as the enumeration type). CreateActivation(const TString& type) const; instantiate the correct activation object according to the; type choosen (given by a TString). GetAllActivationNames() const; retuns the names of all know activation functions. TActivationChooser(). » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-09-08 17:46; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__TActivationChooser.html:1469,log,logger,1469,root/html604/TMVA__TActivationChooser.html,https://root.cern,https://root.cern/root/html604/TMVA__TActivationChooser.html,1,['log'],['logger']
Testability,"s++;; 964 ; 965 // now read the event-values (variables and regression targets); 966 ; 967 if (contains_NaN_or_inf) {; 968 Log() << kWARNING << Form(""Dataset[%s] : "",dsi.GetName())<< ""NaN or +-inf in Event "" << evtIdx << Endl;; 969 if (sizeOfArrays>1) Log() << kWARNING << Form(""Dataset[%s] : "",dsi.GetName())<< "" rejected"" << Endl;; 970 continue;; 971 }; 972 ; 973 // Count the events after rejection due to cut or NaN value; 974 // (weighted and unweighted); 975 classEventCounts.nEvAfterCut++;; 976 classEventCounts.nWeEvAfterCut += weight;; 977 ; 978 // event accepted, fill temporary ntuple; 979 event_v.push_back(new Event(vars, tgts , vis, cl , weight));; 980 }; 981 }; 982 currentInfo.GetTree()->ResetBranchAddresses();; 983 }; 984 }; 985 ; 986 if (!nanInfWarnings.empty()) {; 987 Log() << kWARNING << ""Found events with NaN and/or +-inf values"" << Endl;; 988 for (const auto &warning : nanInfWarnings) {; 989 auto &log = Log() << kWARNING << warning.first;; 990 if (warning.second > 1) log << "" ("" << warning.second << "" times)"";; 991 log << Endl;; 992 }; 993 Log() << kWARNING << ""These NaN and/or +-infs were all removed by the specified cut, continuing."" << Endl;; 994 Log() << Endl;; 995 }; 996 ; 997 if (!nanInfErrors.empty()) {; 998 Log() << kWARNING << ""Found events with NaN and/or +-inf values (not removed by cut)"" << Endl;; 999 for (const auto &error : nanInfErrors) {; 1000 auto &log = Log() << kWARNING << error.first;; 1001 if (error.second > 1) log << "" ("" << error.second << "" times)"";; 1002 log << Endl;; 1003 }; 1004 Log() << kFATAL << ""How am I supposed to train a NaN or +-inf?!"" << Endl;; 1005 }; 1006 ; 1007 // for output format, get the maximum class name length; 1008 Int_t maxL = dsi.GetClassNameMaxLength();; 1009 ; 1010 Log() << kHEADER << Form(""[%s] : "",dsi.GetName()) << ""Number of events in input trees"" << Endl;; 1011 Log() << kDEBUG << ""(after possible flattening of arrays):"" << Endl;; 1012 ; 1013 ; 1014 for (UInt_t cl = 0; cl < dsi.GetNClasses(); cl++) {; 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataSetFactory_8cxx_source.html:42107,log,log,42107,doc/master/DataSetFactory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html,1,['log'],['log']
Testability,"s, which can be varied for each physical; object.; As a minimum requirement all clients must be capable of filling the raw tessellation; of the object buffer, in the master reference frame. Conversely viewers must; always be capable of displaying the object described by this buffer. Scene Rebuilds; It should be understood that AddObject is not an explicit command to the viewer; - it may for various reasons decide to ignore it:. It already has the object internally cached .; The object falls outside; some 'interest' limits of the viewer camera.; The object is too small to; be worth drawing. In all these cases AddObject() returns kNone, as it does for successful addition,; simply indicating it does not require you to provide further information about; this object. You should; not try to make any assumptions about what the viewer did with it.; This enables the viewer to be connected to a client which sends potentially; millions of objects, and only accept those that are of interest at a certain; time, caching the relatively small number of CPU/memory costly logical shapes,; and retaining/discarding the physical placements as required. The viewer may; decide to force the client to rebuild (republish) the scene (via; a TPad; repaint; at; present),; and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const; TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs; SetSectionsValid(T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBuffer3D.html:7146,log,logical,7146,root/html526/TBuffer3D.html,https://root.cern,https://root.cern/root/html526/TBuffer3D.html,7,['log'],['logical']
Testability,"s, which can be varied for each physical; object.; As a minimum requirement all clients must be capable of filling the raw tessellation; of the object buffer, in the master reference frame. Conversely viewers must; always be capable of displaying the object described by this buffer. Scene Rebuilds; It should be understood that AddObject is not an explicit command to the viewer; - it may for various reasons decide to ignore it:. It already has the object internally cached .; The object falls outside; some 'interest' limits of the viewer camera.; The object is too small to; be worth drawing. In all these cases AddObject() returns kNone, as it does for successful addition,; simply indicating it does not require you to provide further information about; this object. You should; not try to make any assumptions about what the viewer did with it.; This enables the viewer to be connected to a client which sends potentially; millions of objects, and only accept those that are of interest at a certain; time, caching the relatively small number of CPU/memory costly logical shapes,; and retaining/discarding the physical placements as required. The viewer may; decide to force the client to rebuild (republish) the scene (via; a TPad; repaint; at; present),; and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const; TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs; will generate IDs ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualViewer3D.html:9197,log,logical,9197,root/html528/TVirtualViewer3D.html,https://root.cern,https://root.cern/root/html528/TVirtualViewer3D.html,6,['log'],['logical']
Testability,"s. It also takes; into account the option to generate a binned data set (ie RooDataHist). SamplingDistribution* AppendSamplingDistribution(RooArgSet& allParameters, RooStats::SamplingDistribution* last, Int_t additionalMC). void ClearCache(); clear the cache obtained from the pdf used for speeding the toy and global observables generation; needs to be called every time the model pdf (fPdf) changes. ToyMCSampler(). void SetUseMultiGen(Bool_t flag); { fUseMultiGen = flag ; }. void AddTestStatistic(RooStats::TestStatistic* t = NULL); The pdf can be NULL in which case the density from SetPdf(); is used. The snapshot and TestStatistic is also optional. RooAbsData* GenerateToyData(RooArgSet& paramPoint, RooAbsPdf& pdf) const; generates toy data; without weight. return GenerateToyData(paramPoint, weight, pdf). RooAbsData* GenerateToyData(RooArgSet& paramPoint) const; with weight. { return GenerateToyData(paramPoint,*fPdf); }. Double_t EvaluateTestStatistic(RooAbsData& data, RooArgSet& nullPOI, int i); Main interface to evaluate the test statistic on a dataset. Double_t EvaluateTestStatistic(RooAbsData& data, RooArgSet& nullPOI); { return EvaluateTestStatistic( data,nullPOI, 0 ); }. TestStatistic* GetTestStatistic(unsigned int i) const. TestStatistic* GetTestStatistic(unsigned int i) const; { return GetTestStatistic(0); }. Double_t ConfidenceLevel() const; { return 1. - fSize; }. void Initialize(RooAbsArg& , RooArgSet& , RooArgSet& ); { return fNToys; }. void SetNToys(const Int_t ntoy); { fNToys = ntoy; }. void SetNEventsPerToy(const Int_t nevents); Forces n events even for extended PDFs. Set NEvents=0 to; use the Poisson distributed events from the extended PDF. void SetParametersForTestStat(const RooArgSet& nullpoi); Set the Pdf, add to the the workspace if not already there. void SetPdf(RooAbsPdf& pdf); { fPdf = &pdf; ClearCache(); }. void SetPriorNuisance(RooAbsPdf* pdf); How to randomize the prior. Set to NULL to deactivate randomization. void SetNuisanceParameters(cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__ToyMCSampler.html:8369,test,test,8369,root/html534/RooStats__ToyMCSampler.html,https://root.cern,https://root.cern/root/html534/RooStats__ToyMCSampler.html,1,['test'],['test']
Testability,"s. We warmly welcome external contributions to the ROOT! By providing code, you agree to transfer your copyright on the code to the ""ROOT project"". Of course you will be duly credited and your name will appear on the contributors page and in the CREDITS file shipped with every binary and source distribution. The copyright transfer is necessary for us to be able to effectively defend the project in case of litigation.; Presently, there are two ways in which you can contribute:; 1. Via the Users' contribution section in the Forum; The Users' Forum has a section which describes how to submit contributions. It is the easiest way to make your code known to the community, even if it will not be automatically integrated in ROOT. Of course the most successful contributions will become part of the repository!; 2. Sending Patches; You can send us a patch or a pull request with Github, provided that you follow these two simple rules:. Make sure you follow the ROOT coding conventions in your code; Make sure you provide a set of tests for your feature/bug fix. Often it is useful to contact us first to discuss the code you want to develop or the bug you want to fix.; Picking up an Idea; We maintain a set of ""ideas"" for talented scientists and developers to pick up. An ""idea"" is a sketch of a development project, a functionality a missing feature we would like to see in our tool, in your ROOT! You can inspect the ideas in the following list. Ideas. ; 30-01-2019 ; Transform GNU-makefile tests to CMake; ROOT's test suite has several crucial tests that still try on GNU-Makefile. We need to integrate them with CMake. ; 30-01-2019 ; Better argument parsing; Use a C++ command line argument library for defining and parsing ROOT's options. ; 30-01-2019 ; More tests, more benchmarks!; ROOT relies on testing, including performance testing - and we need to improve both. ; 05-01-2016 ; Wanted: A tool to 'warn' user of inefficient (for I/O) construct in data model; A tool to 'warn' user of ine",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/collaborate-with-us.html:2917,test,tests,2917,d/collaborate-with-us.html,https://root.cern,https://root.cern/d/collaborate-with-us.html,1,['test'],['tests']
Testability,"s. chopt : Drawing options (see below).; gridlength: grid length on main tick marks. Examples:. Picture; Source. {; TCanvas *c2 = new TCanvas(""c2"",""c2"",10,10,700,500);. gStyle->SetOptStat(0);. TH2F *h2 = new TH2F(""h"",""Axes"",100,0,10,100,-2,2);; h2->Draw();. TF1 *f1=new TF1(""f1"",""-x"",-10,10);; TGaxis *A1 = new TGaxis(0,2,10,2,""f1"",510,""-"");; A1->SetTitle(""axis with decreasing values"");; A1->Draw();. TF1 *f2=new TF1(""f2"",""exp(x)"",0,2);; TGaxis *A2 = new TGaxis(1,1,9,1,""f2"");; A2->SetTitle(""exponential axis"");; A2->SetLabelSize(0.03);; A2->SetTitleSize(0.03);; A2->SetTitleOffset(1.2);; A2->Draw();. TF1 *f3=new TF1(""f3"",""log10(x)"",1,1000);; TGaxis *A3 = new TGaxis(2,-2,2,0,""f3"",505,""G"");; A3->SetTitle(""logarithmic axis"");; A3->SetLabelSize(0.03);; A3->SetTitleSize(0.03);; A3->SetTitleOffset(1.2);; A3->Draw();; return c2;; }; Logarithmic axis; By default axis are linear. To define a TGaxis as logarithmic, it is; enough to create it with the option ""G"". When plotting an histogram or a graph the logarithmic scale can be set using:. gPad->SetLogx(1); set the logarithmic scale on the X axis; gPad->SetLogy(1); set the logarithmic scale on the Y axis. When the SetMoreLogLabels() method is called more labels are drawn; when in logarithmic scale and there is a small number of decades (less than 3).; Blank axis; To draw only the axis tick marks without the axis body, it is enough to specify; the option ""B"". It useful to superpose axis.; Tick marks' orientation; By default tick marks are drawn on the positive side of the axis, except for; vertical axis for which the default is negative. The chop parameter; allows to control the tick marks orientation:. chopt = ""+"": tick marks are drawn on Positive side. (default); chopt =""-"": tick mark are drawn on the negative side.; chopt = ""+-"": tick marks are drawn on both sides of the axis.; chopt = ""U"": Unlabelled axis, default is labeled. Tick marks' size; By default, tick marks have a length equal to 3 per cent of the axis length.; When the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGaxis.html:5124,log,logarithmic,5124,root/html604/TGaxis.html,https://root.cern,https://root.cern/root/html604/TGaxis.html,1,['log'],['logarithmic']
Testability,"s. code fragment (with histograms A and y filled):. TUnfold unfold(A,TUnfold::kHistMapOutputHoriz);; Double_t tau=1.E-4;; Double_t biasScale=0.0;; unfold.DoUnfold(tau,y,biasScale);; TH1D *x=unfold.GetOutput(""x"",""myVariable"");; TH2D *rhoij=unfold.GetRhoIJ(""correlation"",""myVariable"");. will create histograms ""x"" and ""correlation"" from A and y.; if tau is very large, the output is biased to the generated distribution scaled by biasScale; if tau is very small, the output will show oscillations; and large entries in the correlation matrix. Proper choice of tau. One of the difficult questions is about the choice of tau. The most; common method is the L-curve method: a two-dimensional curve is plotted; x-axis: log10(chisquare); y-axis: log10(regularisation condition); In many cases this curve has an L-shape. The best choice of tau is in the; kink of the L. Within TUnfold a simple version of the L-curve analysis is included.; It tests a given number of points in a predefined tau-range and searches; for the maximum of the curvature in the L-curve (kink position).; if no tau range is given, the range of teh scan is determied automatically. Example: scan tau and produce the L-curve plot. Code fragment: assume A and y are filled. TUnfold unfold(A,TUnfold::kHistMapOutputHoriz);. unfold.SetInput(y);. Int_t nScan=30;; Int_t iBest;; TSpline *logTauX,*logTauY;; TGraph *lCurve;. iBest=unfold.ScanLcurve(nScan,0.0,0.0,&lCurve);. std::cout<<""tau=""<<unfold.GetTau()<<""\n"";. TH1D *x=unfold.GetOutput(""x"",""myVariable"");; TH2D *rhoij=unfold.GetRhoIJ(""correlation"",""myVariable"");. This creates; logTauX: the L-curve's x-coordinate as a function of log(tau); logTauY: the L-curve's y-coordinate as a function of log(tau); lCurve: a graph of the L-curve; x,rhoij: unfolding result for best choice of tau; iBest: the coordinate/spline knot number with the best choice of tau. Note: always check the L curve after unfolding. The algorithm is not; perfect. Bin averaging of the output. Sometimes it is usefu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnfold.html:5338,test,tests,5338,root/html528/TUnfold.html,https://root.cern,https://root.cern/root/html528/TUnfold.html,3,['test'],['tests']
Testability,"s. private . number of events of class 0,1,2,... in training[0] and testing[1] (+validation, trainingoriginal) ; Definition at line 158 of file DataSet.h. ◆ fCurrentEventIdx. Long64_t TMVA::DataSet::fCurrentEventIdx. mutableprivate . Definition at line 146 of file DataSet.h. ◆ fCurrentTreeIdx. UInt_t TMVA::DataSet::fCurrentTreeIdx. mutableprivate . Definition at line 145 of file DataSet.h. ◆ fdsi. const DataSetInfo* TMVA::DataSet::fdsi. private . -> datasetinfo that created this dataset ; Definition at line 139 of file DataSet.h. ◆ fEventCollection. std::vector< std::vector<Event*> > TMVA::DataSet::fEventCollection. private . list of events for training/testing/... ; Definition at line 141 of file DataSet.h. ◆ fHasNegativeEventWeights. Bool_t TMVA::DataSet::fHasNegativeEventWeights. private . true if at least one signal or bkg event has negative weight ; Definition at line 161 of file DataSet.h. ◆ fLogger. MsgLogger* TMVA::DataSet::fLogger. mutableprivate . ! message logger ; Definition at line 163 of file DataSet.h. ◆ fResults. std::vector< std::map< TString, Results* > > TMVA::DataSet::fResults. private . ! [train/test/...][method-identifier] ; Definition at line 143 of file DataSet.h. ◆ fSampling. std::vector<Char_t> TMVA::DataSet::fSampling. private . random or importance sampling (not all events are taken) !! Bool_t are stored ( no std::vector<bool> taken for speed (performance) issues ) ; Definition at line 149 of file DataSet.h. ◆ fSamplingEventList. std::vector< std::vector< std::pair< Float_t, Long64_t > > > TMVA::DataSet::fSamplingEventList. mutableprivate . weights and indices for sampling ; Definition at line 152 of file DataSet.h. ◆ fSamplingNEvents. std::vector<Int_t> TMVA::DataSet::fSamplingNEvents. private . number of events which should be sampled ; Definition at line 150 of file DataSet.h. ◆ fSamplingRandom. TRandom3* TMVA::DataSet::fSamplingRandom. private . -> random generator for sampling ; Definition at line 154 of file DataSet.h. ◆ fSamplingSel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DataSet.html:26438,log,logger,26438,doc/master/classTMVA_1_1DataSet.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DataSet.html,1,['log'],['logger']
Testability,"s.cxx:211; TMVA::MethodCuts::ProcessOptionsvoid ProcessOptions()process user options.Definition MethodCuts.cxx:363; TMVA::MethodCuts::WriteMonitoringHistosToFilevoid WriteMonitoringHistosToFile(void) constwrite histograms and PDFs to file for monitoring purposesDefinition MethodCuts.cxx:1411; TMVA::MethodCuts::EEffMethodEEffMethodDefinition MethodCuts.h:157; TMVA::MethodCuts::kUsePDFs@ kUsePDFsDefinition MethodCuts.h:158; TMVA::MethodCuts::kUseEventSelection@ kUseEventSelectionDefinition MethodCuts.h:157; TMVA::MethodCuts::CheckSetupvoid CheckSetup()check may be overridden by derived class (sometimes, eg, fitters are used which can only be implement...Definition MethodCuts.h:133; TMVA::MethodCuts::MatchParsToCutsvoid MatchParsToCuts(const std::vector< Double_t > &, Double_t *, Double_t *)translates parameters into cutsDefinition MethodCuts.cxx:974; TMVA::MethodCuts::~MethodCutsvirtual ~MethodCuts(void)destructorDefinition MethodCuts.cxx:270; TMVA::MethodCuts::TestClassificationvoid TestClassification()nothing to testDefinition MethodCuts.cxx:827; TMVA::MethodCuts::EFitMethodTypeEFitMethodTypeDefinition MethodCuts.h:146; TMVA::MethodCuts::kUseMinuit@ kUseMinuitDefinition MethodCuts.h:149; TMVA::MethodCuts::kUseEventScan@ kUseEventScanDefinition MethodCuts.h:150; TMVA::MethodCuts::kUseSimulatedAnnealing@ kUseSimulatedAnnealingDefinition MethodCuts.h:148; TMVA::MethodCuts::kUseGeneticAlgorithm@ kUseGeneticAlgorithmDefinition MethodCuts.h:147; TMVA::MethodCuts::kUseMonteCarlo@ kUseMonteCarloDefinition MethodCuts.h:146; TMVA::MethodCuts::kUseMonteCarloEvents@ kUseMonteCarloEventsDefinition MethodCuts.h:151; TMVA::MethodCuts::fCutRangeMinDouble_t * fCutRangeMinminimum of allowed cut rangeDefinition MethodCuts.h:175; TMVA::MethodCuts::fBinaryTreeBBinarySearchTree * fBinaryTreeBDefinition MethodCuts.h:181; TMVA::MethodCuts::fRmsSstd::vector< Double_t > * fRmsSRMSs of variables (signal)Definition MethodCuts.h:199; TMVA::MethodCuts::fMeanSstd::vector< Double_t > * fMeanSmeans ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodCuts_8h_source.html:19201,test,testDefinition,19201,doc/master/MethodCuts_8h_source.html,https://root.cern,https://root.cern/doc/master/MethodCuts_8h_source.html,1,['test'],['testDefinition']
Testability,"s.fp);; 3402 timestamp = time(NULL);; 3403 ; 3404 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3405 fprintf(fi.access.fp,; 3406 ""[%010lu] [error] [client %s] "",; 3407 (unsigned long)timestamp,; 3408 src_addr);; 3409 ; 3410 if (conn->request_info.request_method != NULL) {; 3411 fprintf(fi.access.fp,; 3412 ""%s %s: "",; 3413 conn->request_info.request_method,; 3414 conn->request_info.request_uri; 3415 ? conn->request_info.request_uri; 3416 : """");; 3417 }; 3418 ; 3419 fprintf(fi.access.fp, ""%s"", buf);; 3420 fputc('\n', fi.access.fp);; 3421 fflush(fi.access.fp);; 3422 funlockfile(fi.access.fp);; 3423 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3424 * mg_cry here anyway ;-) */; 3425 }; 3426 }; 3427}; 3428#else; 3429#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3430#endif /* Externally provided function */; 3431 ; 3432 ; 3433/* Construct fake connection structure. Used for logging, if connection; 3434 * is not applicable at the moment of logging. */; 3435static struct mg_connection *; 3436fake_connection(struct mg_connection *fc, struct mg_context *ctx); 3437{; 3438 static const struct mg_connection conn_zero = {0};; 3439 *fc = conn_zero;; 3440 fc->phys_ctx = ctx;; 3441 fc->dom_ctx = &(ctx->dd);; 3442 return fc;; 3443}; 3444 ; 3445 ; 3446static void; 3447mg_cry_internal_wrap(const struct mg_connection *conn,; 3448 struct mg_context *ctx,; 3449 const char *func,; 3450 unsigned line,; 3451 const char *fmt,; 3452 ...); 3453{; 3454 va_list ap;; 3455 va_start(ap, fmt);; 3456 if (!conn && ctx) {; 3457 struct mg_connection fc;; 3458 mg_cry_internal_impl(fake_connection(&fc, ctx), func, line, fmt, ap);; 3459 } else {; 3460 mg_cry_internal_impl(conn, func, line, fmt, ap);; 3461 }; 3462 va_end(ap);; 3463}; 3464 ; 3465 ; 3466void; 3467mg_cry(const struct mg_connection *conn, const char *fmt, ...); 3468{; 3469 va_list ap;; 3470 va_start(ap, fmt);; 3471 mg_cry_internal_impl(conn, ""user"", 0, fmt, ap",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:102168,log,logging,102168,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,2,['log'],['logging']
Testability,"s.fp);; 3403 timestamp = time(NULL);; 3404 ; 3405 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3406 fprintf(fi.access.fp,; 3407 ""[%010lu] [error] [client %s] "",; 3408 (unsigned long)timestamp,; 3409 src_addr);; 3410 ; 3411 if (conn->request_info.request_method != NULL) {; 3412 fprintf(fi.access.fp,; 3413 ""%s %s: "",; 3414 conn->request_info.request_method,; 3415 conn->request_info.request_uri; 3416 ? conn->request_info.request_uri; 3417 : """");; 3418 }; 3419 ; 3420 fprintf(fi.access.fp, ""%s"", buf);; 3421 fputc('\n', fi.access.fp);; 3422 fflush(fi.access.fp);; 3423 funlockfile(fi.access.fp);; 3424 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3425 * mg_cry here anyway ;-) */; 3426 }; 3427 }; 3428}; 3429#else; 3430#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3431#endif /* Externally provided function */; 3432 ; 3433 ; 3434/* Construct fake connection structure. Used for logging, if connection; 3435 * is not applicable at the moment of logging. */; 3436static struct mg_connection *; 3437fake_connection(struct mg_connection *fc, struct mg_context *ctx); 3438{; 3439 static const struct mg_connection conn_zero = {0};; 3440 *fc = conn_zero;; 3441 fc->phys_ctx = ctx;; 3442 fc->dom_ctx = &(ctx->dd);; 3443 return fc;; 3444}; 3445 ; 3446 ; 3447static void; 3448mg_cry_internal_wrap(const struct mg_connection *conn,; 3449 struct mg_context *ctx,; 3450 const char *func,; 3451 unsigned line,; 3452 const char *fmt,; 3453 ...); 3454{; 3455 va_list ap;; 3456 va_start(ap, fmt);; 3457 if (!conn && ctx) {; 3458 struct mg_connection fc;; 3459 mg_cry_internal_impl(fake_connection(&fc, ctx), func, line, fmt, ap);; 3460 } else {; 3461 mg_cry_internal_impl(conn, func, line, fmt, ap);; 3462 }; 3463 va_end(ap);; 3464}; 3465 ; 3466 ; 3467void; 3468mg_cry(const struct mg_connection *conn, const char *fmt, ...); 3469{; 3470 va_list ap;; 3471 va_start(ap, fmt);; 3472 mg_cry_internal_impl(conn, ""user"", 0, fmt, ap",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:102200,log,logging,102200,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,['log'],['logging']
Testability,s.h;  SpecFuncCephesInv.cxx;  SpecFuncMathCore.cxx;  StdEngine.cxx;  TComplex.cxx;  TKDTree.cxx;  TKDTreeBinning.cxx;  TMath.cxx;  TRandom.cxx;  TRandom1.cxx;  TRandom2.cxx;  TRandom3.cxx;  TRandomGen.cxx;  triangle.c;  triangle.h;  TStatistic.cxx;  UnBinData.cxx;  ► test;  ► fit;  GaussFunction.h;  MinimizerTypes.h;  SparseDataComparer.cxx;  SparseFit3.cxx;  SparseFit4.cxx;  testFit.cxx;  testFitPerf.cxx;  testGraphFit.cxx;  testMinim.cxx;  testRooFit.cxx;  WrapperRooPdf.h;  binarySearchTime.cxx;  kDTreeTest.cxx;  newKDTreeTest.cxx;  stdsort.cxx;  stressGoFTest.cxx;  stressTF1.cxx;  stressTMath.cxx;  testAnalyticalIntegrals.cxx;  testBinarySearch.cxx;  testDistSampler.cxx;  testIntegration.cxx;  testIntegrationMultiDim.cxx;  testKahan.cxx;  testkdTreeBinning.cxx;  testMathRandom.cxx;  testRootFinder.cxx;  testSampleQuantiles.cxx;  testSortOrder.cxx;  testSpecFuncBeta.cxx;  testSpecFuncBetaI.cxx;  testSpecFuncErf.cxx;  testSpecFuncGamma.cxx;  testSpecFuncSiCi.cxx;  testTMath.cxx;  testTStatistic.cxx;  ► v7;  ► inc;  ► ROOT;  TFit.hxx;  ► mathmore;  ► inc;  ► Math;  ChebyshevApprox.h;  Derivator.h;  DistFuncMathMore.h;  GSLFunctionAdapter.h;  GSLIntegrator.h;  GSLMCIntegrator.h;  GSLMinimizer.h;  GSLMinimizer1D.h;  GSLMultiRootFinder.h;  GSLNLSMinimizer.h;  GSLQuasiRandom.h;  GSLRandom.h;  GSLRandomFunctions.h;  GSLRndmEngines.h;  GSLRootFinder.h;  GSLRootFinderDeriv.h;  GSLRootHelper.h;  GSLSimAnMinimizer.h;  GSLSimAnnealing.h;  IntegrationTypes.h;  InterpolationTypes.h;  Interpolator.h;  KelvinFunctions.h;  LinkDef_Func.h;  LinkDef_RootFinding.h;  MCIntegrationTypes.h;  MCParameters.h;  MultiNumGradFunction.h;  MultiRootFinder.h;  ParamFunction.h;  PdfFuncMathMore.h;  Polynomial.h;  QuantFuncMathMore.h;  QuasiRandom.h;  RootFinderAlgorithms.h;  SpecFuncMathMore.h;  Vavilov.h;  VavilovAccurate.h;  VavilovAccurateCdf.h;  VavilovAccuratePdf.h;  VavilovAccurateQuantile.h;  VavilovFast.h;  ► src;  cblas.cxx;  ChebyshevApprox.cxx;  complex_quartic.h;  Derivator.cxx;  GSL1,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:45422,test,testTStatistic,45422,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['test'],['testTStatistic']
Testability,s: 0.00573 sec ; Factory : Test method: TMVA_DNN_CPU for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 400; : ; TMVA_DNN_CPU : [dataset] : Evaluation of TMVA_DNN_CPU on testing sample (400 events); : Elapsed time for evaluation of 400 events: 0.023 sec ; Factory : Test method: TMVA_CNN_CPU for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 400; : ; TMVA_CNN_CPU : [dataset] : Evaluation of TMVA_CNN_CPU on testing sample (400 events); : Elapsed time for evaluation of 400 events: 0.149 sec ; Factory : Test method: PyKeras for Classification performance; : ; : Setting up tf.keras; : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Disabled TF eager execution when evaluating model ; : Loading Keras Model ; : Loaded model from file: trained_model_cnn.h5; PyKeras : [dataset] : Evaluation of PyKeras on testing sample (400 events); : Elapsed time for evaluation of 400 events: 0.175 sec ; Factory : Test method: PyTorch for Classification performance; : ; : Setup PyTorch Model for training; : Executing user initialization code from /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master.build/tutorials/tmva/PyTorch_Generate_CNN_Model.py; RecursiveScriptModule(; original_name=Sequential; (0): RecursiveScriptModule(original_name=Reshape); (1): RecursiveScriptModule(original_name=Conv2d); (2): RecursiveScriptModule(original_name=ReLU); (3): RecursiveScriptModule(original_name=BatchNorm2d); (4): RecursiveScriptModule(original_name=Conv2d); (5): RecursiveScriptModule(original_name=ReLU); (6): RecursiveScriptModule(original_name=MaxPool2d); (7): RecursiveScriptModule(original_name=Flatten); (8): RecursiveScriptModule(original_name=Linear); (9): RecursiveScriptModule(original_name=ReLU); (10): RecursiveScriptModule(original_name=Linear); (11): RecursiveScriptModule(original_name=Sigmoid),MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:38996,test,testing,38996,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['test'],['testing']
Testability,"s::ETreeType treeType, const TString& theVarName, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&); Bool_tTMVA::MethodBase::TxtWeightsOnly() const; Bool_tTMVA::MethodBase::Verbose() const; voidTMVA::Configurable::WriteOptionsReferenceToFile(). private:. virtual voidDeclareOptions(); virtual voidInit(); voidInitCircularTree(const TMVA::DataSetInfo& dsi); Bool_tPassesCut(const TMVA::Event* ev, UInt_t methodIdx); virtual voidProcessOptions(). Data Members; public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kROOT; static TObject::(anonymous)TObject::kSingleKey; static TMVA::MethodBase::EWeightFileTypeTMVA::MethodBase::kTEXT; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TCut>fCategoryCuts; vector<UInt_t>fCategorySpecIdx; TMVA::MethodBase*TMVA::MethodCompositeBase::fCurrentMethod; UInt_tTMVA::MethodCompositeBase::fCurrentMethodIdx; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Double_t>TMVA::Metho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodCategory.html:16904,test,testing,16904,root/html602/TMVA__MethodCategory.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodCategory.html,2,['test'],['testing']
Testability,"s::ETreeType type); prepare tree branch with the method's discriminating variable. void AddMulticlassOutput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void NoErrorCalc(Double_t *const err, Double_t *const errUpper). Double_t GetMvaValue(const TMVA::Event *const ev, Double_t* err = 0, Double_t* errUpper = 0). void AddClassifierOutput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void AddClassifierOutputProb(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); calculate <sum-of-deviation-squared> of regression output versus ""true"" value from test sample. bias = average deviation; dev = average absolute deviation; rms = rms of deviation. void TestMulticlass(); test multiclass classification. void TestClassification(); initialization. void WriteStateToStream(ostream& tf) const; general method used in writing the header of the weight files where; the used variables, variable transformation type etc. is specified. void AddInfoItem(void* gi, const TString& name, const TString& value) const; xml writing. void AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType). void WriteStateToXML(void* parent) const; general method used in writing the header of the weight files where; the used variables, variable transformation type etc. is specified. void ReadStateFromStream(TFile& rf); write reference MVA distributions (and other information); to a ROOT type weight file. void WriteStateToFile() const; write options and weights to file; note that each one text file for the main configuration information; and one ROOT file for ROOT objects are created. void ReadStateFromFile(); Function to write options and weights to file. void ReadStat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodBase.html:22446,test,test,22446,root/html528/TMVA__MethodBase.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodBase.html,1,['test'],['test']
Testability,"s::FeldmanCousins Interface for tools setting limits (producing confidence intervals); RooStats::HLFactory The high Level Model Factory to create models from datacards; RooStats::Heavyside Your description goes here...; RooStats::HybridCalculator Hypothesis test calculator using a Bayesian-frequentist hybrid method; RooStats::HybridPlot Provides the plots for an HybridResult; RooStats::HybridResult Class containing the results of the HybridCalculator; RooStats::HypoTestCalculator Interface for tools doing hypothesis tests; RooStats::HypoTestInverter HypoTestInverter class; RooStats::HypoTestInverterPlot HypoTestInverterPlot class; RooStats::HypoTestInverterResult HypoTestInverterResult class ; RooStats::HypoTestResult Base class to represent results of a hypothesis test; RooStats::IntervalCalculator Interface for tools setting limits (producing confidence intervals); RooStats::LikelihoodInterval Concrete implementation of a ConfInterval based on a likelihood ratio; RooStats::LikelihoodIntervalPlot Class containing the results of the IntervalCalculator; RooStats::MCMCCalculator Markov Chain Monte Carlo calculator for Bayesian credible intervals; RooStats::MCMCInterval Concrete implementation of a ConfInterval based on MCMC calculation; RooStats::MCMCIntervalPlot Class containing the results of the MCMCCalculator; RooStats::MarkovChain ; RooStats::MetropolisHastings Markov Chain Monte Carlo calculator for Bayesian credible intervals; RooStats::ModelConfig A class that holds configuration information for a model using a workspace as a store; RooStats::NeymanConstruction Interface for tools setting limits (producing confidence intervals); RooStats::NumEventsTestStat ; RooStats::NumberCountingPdfFactory A factory specific to common number counting problems.; RooStats::NumberCountingUtils ; RooStats::PdfProposal ; RooStats::PointSetInterval Concrete implementation of ConfInterval for simple 1-D intervals in the form [a,b]; RooStats::ProfileLikelihoodCalculator A concrete ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ClassIndex.html:43038,test,test,43038,root/html526/ClassIndex.html,https://root.cern,https://root.cern/root/html526/ClassIndex.html,3,['test'],"['test', 'tests']"
Testability,"s::TestStatSampler. class RooStats::TestStatSampler. TestStatSampler is an interface class for a tools which produce RooStats SamplingDistributions. ; Tools that implement this interface are expected to be used for coverage studies, the Neyman Construction, etc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TestStatSampler(); static TClass*Class(); virtual Double_tConfidenceLevel() const; virtual Double_tEvaluateTestStatistic(RooAbsData& data, RooArgSet& paramsOfInterest); virtual RooStats::SamplingDistribution*GetSamplingDistribution(RooArgSet& paramsOfInterest); virtual RooStats::TestStatistic*GetTestStatistic() const; virtual voidInitialize(RooAbsArg& testStatistic, RooArgSet& paramsOfInterest, RooArgSet& nuisanceParameters); virtual TClass*IsA() const; RooStats::TestStatSampler&operator=(const RooStats::TestStatSampler&); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetGlobalObservables(const RooArgSet&); virtual voidSetNuisanceParameters(const RooArgSet&); virtual voidSetObservables(const RooArgSet&); virtual voidSetParametersForTestStat(const RooArgSet&); virtual voidSetPdf(RooAbsPdf&); virtual voidSetPriorNuisance(RooAbsPdf*); virtual voidSetSamplingDistName(const char* name); virtual voidSetTestSize(Double_t size); virtual voidSetTestStatistic(RooStats::TestStatistic* testStatistic); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TestStatSampler(); TestStatSampler();. {}. SamplingDistribution* GetSamplingDistribution(RooArgSet& paramsOfInterest); Main interface to get a ConfInterval, pure virtual. Double_t EvaluateTestStatistic(RooAbsData& data, RooArgSet& paramsOfInterest); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__TestStatSampler.html:1040,test,testStatistic,1040,root/html528/RooStats__TestStatSampler.html,https://root.cern,https://root.cern/root/html528/RooStats__TestStatSampler.html,6,['test'],['testStatistic']
Testability,"s::kDL, ""DL_CPU"", nnOptions);; }; if (Use[""DL_GPU""]) {; TString layoutString(""Layout=TANH|100,TANH|50,TANH|10,LINEAR"");; TString trainingStrategyString(""TrainingStrategy=Optimizer=ADAM,LearningRate=1e-3,""; ""TestRepetitions=1,ConvergenceSteps=10,BatchSize=100,MaxEpochs=20"");; TString nnOptions(""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=N:""; ""WeightInitialization=XAVIERUNIFORM:Architecture=GPU"");; nnOptions.Append("":"");; nnOptions.Append(layoutString);; nnOptions.Append("":"");; nnOptions.Append(trainingStrategyString);; factory->BookMethod(dataloader, TMVA::Types::kDL, ""DL_GPU"", nnOptions);; }; ; ; // Train MVAs using the set of training events; factory->TrainAllMethods();; ; // Evaluate all MVAs using the set of test events; factory->TestAllMethods();; ; // Evaluate and compare performance of all configured MVAs; factory->EvaluateAllMethods();; ; // --------------------------------------------------------------; ; // Save the output; outputFile->Close();; ; std::cout << ""==> Wrote root file: "" << outputFile->GetName() << std::endl;; std::cout << ""==> TMVAMulticlass is done!"" << std::endl;; ; delete factory;; delete dataloader;; ; // Launch the GUI for the root macros; if (!gROOT->IsBatch()) TMVAMultiClassGui( outfileName );; ; ; }; ; int main( int argc, char** argv ); {; // Select methods (don't look at this code - not of interest); TString methodList;; for (int i=1; i<argc; i++) {; TString regMethod(argv[i]);; if(regMethod==""-b"" || regMethod==""--batch"") continue;; if (!methodList.IsNull()) methodList += TString("","");; methodList += regMethod;; }; TMVAMulticlass(methodList);; return 0;; }; ; DataLoader.h; mainint main()Definition Prototype.cxx:12; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; TFile.h; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void inputDefinition TGWin32VirtualXProxy.cxx:142; TMVAMultiClassGui.h; TROOT.h; gROOT#define gROOTDefin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C.html:37079,test,test,37079,doc/master/TMVAMulticlass_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C.html,1,['test'],['test']
Testability,"s::kTraining].at(cls).end(); itEvent != itEventEnd; ++itEvent ){; 1409 // if( std::distance( itTarget, trainingEventVector->end()) < Int_t(cls+1) ) {; 1410 if( (trainingEventVector->end() - itTarget) < Int_t(cls+1) ) {; 1411 itTarget = trainingEventVector->end();; 1412 trainingEventVector->insert( itTarget, itEvent, itEventEnd ); // fill in the rest without mixing; 1413 break;; 1414 }else{; 1415 itTarget += cls+1;; 1416 trainingEventVector->insert( itTarget, (*itEvent) ); // fill event; 1417 }; 1418 }; 1419 // testing vector; 1420 itTarget = testingEventVector->begin() - 1;; 1421 // loop over source; 1422 for( itEvent = tmpEventVector[Types::kTesting].at(cls).begin(), itEventEnd = tmpEventVector[Types::kTesting].at(cls).end(); itEvent != itEventEnd; ++itEvent ){; 1423 // if( std::distance( itTarget, testingEventVector->end()) < Int_t(cls+1) ) {; 1424 if( ( testingEventVector->end() - itTarget ) < Int_t(cls+1) ) {; 1425 itTarget = testingEventVector->end();; 1426 testingEventVector->insert( itTarget, itEvent, itEventEnd ); // fill in the rest without mixing; 1427 break;; 1428 }else{; 1429 itTarget += cls+1;; 1430 testingEventVector->insert( itTarget, (*itEvent) ); // fill event; 1431 }; 1432 }; 1433 }; 1434 }else{; 1435 for( UInt_t cls = 0; cls < dsi.GetNClasses(); ++cls ){; 1436 trainingEventVector->insert( trainingEventVector->end(), tmpEventVector[Types::kTraining].at(cls).begin(), tmpEventVector[Types::kTraining].at(cls).end() );; 1437 testingEventVector->insert ( testingEventVector->end(), tmpEventVector[Types::kTesting].at(cls).begin(), tmpEventVector[Types::kTesting].at(cls).end() );; 1438 }; 1439 }; 1440 // delete the tmpEventVector (but not the events therein); 1441 tmpEventVector[Types::kTraining].clear();; 1442 tmpEventVector[Types::kTesting].clear();; 1443 ; 1444 tmpEventVector[Types::kMaxTreeType].clear();; 1445 ; 1446 if (mixMode == ""RANDOM"") {; 1447 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""shuffling events""<<Endl;; 1448 ; 1449 std::sh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataSetFactory_8cxx_source.html:64646,test,testingEventVector,64646,doc/master/DataSetFactory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html,5,['test'],['testingEventVector']
Testability,"s::left) << std::setw(maxL); 1620 << dsi.GetClassInfo(cls)->GetName() << "" event weights by factor: "" << renormFactor.at(cls) << Endl;; 1621 for (EventVector::iterator it = tmpEventVector[Types::kTraining].at(cls).begin(),; 1622 itEnd = tmpEventVector[Types::kTraining].at(cls).end(); it != itEnd; ++it){; 1623 (*it)->SetWeight ((*it)->GetWeight() * renormFactor.at(cls));; 1624 }; 1625 ; 1626 }; 1627 ; 1628 ; 1629 // print out the result; 1630 // (same code as before --> this can be done nicer ); 1631 //; 1632 ; 1633 Log() << kINFO //<< Form(""Dataset[%s] : "",dsi.GetName()); 1634 << ""Number of training and testing events"" << Endl;; 1635 Log() << kDEBUG << ""\tafter rescaling:"" << Endl;; 1636 Log() << kINFO //<< Form(""Dataset[%s] : "",dsi.GetName()); 1637 << ""---------------------------------------------------------------------------"" << Endl;; 1638 ; 1639 trainingSumSignalWeights = 0;; 1640 trainingSumBackgrWeights = 0; // Backgr. includes all classes that are not signal; 1641 testingSumSignalWeights = 0;; 1642 testingSumBackgrWeights = 0; // Backgr. includes all classes that are not signal; 1643 ; 1644 for( UInt_t cls = 0, clsEnd = dsi.GetNClasses(); cls < clsEnd; ++cls ){; 1645 trainingSumWeightsPerClass.at(cls) =; 1646 std::accumulate(tmpEventVector[Types::kTraining].at(cls).begin(),; 1647 tmpEventVector[Types::kTraining].at(cls).end(),; 1648 Double_t(0), [](Double_t w, const TMVA::Event *E) { return w + E->GetOriginalWeight(); });; 1649 ; 1650 testingSumWeightsPerClass.at(cls) =; 1651 std::accumulate(tmpEventVector[Types::kTesting].at(cls).begin(),; 1652 tmpEventVector[Types::kTesting].at(cls).end(),; 1653 Double_t(0), [](Double_t w, const TMVA::Event *E) { return w + E->GetOriginalWeight(); });; 1654 ; 1655 if ( cls == dsi.GetSignalClassIndex()){; 1656 trainingSumSignalWeights += trainingSumWeightsPerClass.at(cls);; 1657 testingSumSignalWeights += testingSumWeightsPerClass.at(cls);; 1658 }else{; 1659 trainingSumBackgrWeights += trainingSumWeightsPerClass.at(cls);; 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataSetFactory_8cxx_source.html:76311,test,testingSumSignalWeights,76311,doc/master/DataSetFactory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html,2,['test'],"['testingSumBackgrWeights', 'testingSumSignalWeights']"
Testability,"s:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GDML; » TGDMLParse. class TGDMLParse: public TObject. Function Members (Methods); public:. TGDMLParse(); TGDMLParse(const TGDMLParse&); virtual~TGDMLParse(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGeoVolume*GDMLReadFile(const char* filename = ""test.gdml""); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Optio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGDMLParse.html:1717,test,test,1717,root/html528/TGDMLParse.html,https://root.cern,https://root.cern/root/html528/TGDMLParse.html,4,['test'],['test']
Testability,"s:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::Ranking. class TMVA::Ranking. Ranking for variables in method (implementation). Function Members (Methods); public:. virtual~Ranking(); virtual voidAddRank(const TMVA::Rank& rank); static TClass*Class(); virtual TClass*IsA() const; TMVA::Ranking&operator=(const TMVA::Ranking&); virtual voidPrint() const; TMVA::RankingRanking(); TMVA::RankingRanking(const TMVA::Ranking&); TMVA::RankingRanking(const TString& context, const TString& rankingDiscriminatorName); voidSetContext(const TString& context); voidSetDiscrName(const TString& discrName); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TMVA::MsgLogger&Log() const. Data Members; private:. TStringfContextthe ranking context; TMVA::MsgLogger*fLogger! message logger; vector<TMVA::Rank>fRankingvector of ranks; TStringfRankingDiscriminatorNamethe name of the ranking discriminator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Ranking(); default constructor. Ranking(const TString& context, const TString& rankingDiscriminatorName); constructor. ~Ranking(); destructor. void SetContext(const TString& context). void AddRank(const TMVA::Rank& rank); Add a new rank; take ownership of it. void Print() const; get maximum length of variable names. Ranking(). void SetDiscrName(const TString& discrName); { fRankingDiscriminatorName = discrName; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: Ranking.h 39395 2011-05-26 10:05:54Z moneta $ » Last generated: 2011-07-04 15:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__Ranking.html:1040,log,logger,1040,root/html530/TMVA__Ranking.html,https://root.cern,https://root.cern/root/html530/TMVA__Ranking.html,1,['log'],['logger']
Testability,s; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-743.339) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.942558 a1=-0.775768 mean=4.99866 nbkg=187.872 nsig=63.0852 sig1frac=0.868175; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-743.339) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.984478 a1=-0.59938 mean=4.99914 nbkg=173.959 nsig=90.3182 sig1frac=0.461117; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 90; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 80; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 70; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-775.389) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.72761 a1=-0.375581 mean=5.04879 nbkg=141.143 nsig=137.402 sig1frac=0.495257; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 60; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 50; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 40; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 30; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 20; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 10; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 0; [#0] WARNING:Generation -- Fit parameter 'sigma1' does not have an error. A pull distribution cannot be generated. This might be caused by the parameter being constant or because the fits were not run.; [#0] WARNING:Generation -- Fit parameter 'sigma2' does not have an error. A pull distribution cannot be generated. This might be caused by the parameter being constant or because the fits were not run.; [#1] INFO:Object,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf801__mcstudy_8C.html:28137,log,log,28137,doc/master/rf801__mcstudy_8C.html,https://root.cern,https://root.cern/doc/master/rf801__mcstudy_8C.html,2,['log'],['log']
Testability,s; Float_tfEffSessionsEffective Number of PROOF sessions on the assigned machines; TList*fEnabledPackageslist of enabled packages; Bool_tfEndMastertrue for a master in direct contact only with workers; THashList*fGlobalPackageDirListlist of directories containing global packages libs; TStringfGroupgroup the user belongs to; Int_tfGroupIdslave unique id in the active slave group; Int_tfGroupPrioritypriority of group the user belongs to (0 - 100); Int_tfGroupSizesize of the active slave group; Long64_tfHWMBoxSizeHigh-Water-Mark on the sandbox size; Bool_tfIdleTRUE if idle; TIdleTOTimer*fIdleTOTimerTimer used to control children state; TStringfImageimage name of the session; Int_tfInflateFactorFactor in 1/1000 to inflate the CPU time; TFileHandler*fInputHandlerInput socket handler; Bool_tfInterruptif true macro execution will be stopped; TStopwatchfLatencymeasures latency of packet requests; FILE*fLogFilelog file; Int_tfLogFileDeslog file descriptor; Long64_tfLogFileMaxSizemax size for log files (enabled if > 0); Int_tfLogLeveldebug logging level; Bool_tfMasterServtrue if we are a master server; Long64_tfMaxBoxSizeMax size of the sandbox; Int_tfMaxQueriesMax number of queries fully kept; Int_tfMergedWorkersNumber of workers merged; TMonitor*fMergingMonitorMonitor for merging sockets; TServerSocket*fMergingSocketSocket used for merging outputs if submerger; Long64_tfMsgSizeHWMHigh-Water-Mark on the size of messages with results; Int_tfNcmdcommand history number; TStringfOrdinalslave ordinal number; TStringfOutputFilepath with the temporary results of the current or last query; TStringfPackageDirdirectory containing packages and user libs; TProofLockPath*fPackageLockpackage dir locker; TVirtualProofPlayer*fPlayeractual player; TStringfPrefixPrefix identifying the node; TProof*fProofPROOF talking to slave servers; Int_tfProtocolprotocol version number; TQueryResultManager*fQMgrQuery-result manager; TMutex*fQMtxTo protect async msg queue; TStringfQueryDirdirectory containi,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofServ.html:18702,log,log,18702,root/html534/TProofServ.html,https://root.cern,https://root.cern/root/html534/TProofServ.html,1,['log'],['log']
Testability,"s; TPointsArray3D A 3-D PolyLine; TPolyLine A PolyLine; TPolyLine3D A 3-D polyline; TPolyLineShape The base class to define an abstract 3D shape of STAR ""event"" geometry; TPolyMarker An array of points with the same marker; TPolyMarker3D An array of 3-D points with the same marker; TPosixCondition Posix condition variable; TPosixMutex Posix mutex lock; TPosixThread TPosixThread class; TPosixThreadFactory Posix thread factory; TPostScript PostScript driver; TPrimary TPrimary vertex particle information; TPrincipal Principal Components Analysis; TProcessEventTimer Process pending events at fixed time intervals; TProcessID Process Unique Identifier in time and space; TProcessUUID TProcessID managing UUIDs; TProfile Profile histogram class; TProfile2D Profile2D histogram class; TProfile3D Profile3D histogram class; TProof PROOF control class; TProofBench Steering class for PROOF benchmarks; TProofBenchDataSet Handle operations on datasets; TProofBenchRun Abstract base class for PROOF benchmark run; TProofBenchRunCPU CPU-intensive PROOF benchmark; TProofBenchRunDataRead IO-intensive PROOF benchmark; TProofChain TChain proxy for running chains on PROOF; TProofCondor PROOF control class for slaves allocated by condor; TProofDebug ; TProofDesc Small class describing a proof session; TProofDraw Tree drawing selector for PROOF; TProofDrawEntryList A Selectoor to fill a TEntryList from TTree::Draw; TProofDrawEventList Tree drawing selector for PROOF; TProofDrawGraph Tree drawing selector for PROOF; TProofDrawHist Tree drawing selector for PROOF; TProofDrawListOfGraphs Tree drawing selector for PROOF; TProofDrawListOfGraphs::Point3D_t ; TProofDrawListOfPolyMarkers3D Tree drawing selector for PROOF; TProofDrawListOfPolyMarkers3D::Point4D_t ; TProofDrawPolyMarker3D Tree drawing selector for PROOF; TProofDrawProfile Tree drawing selector for PROOF; TProofDrawProfile2D Tree drawing selector for PROOF; TProofLimitsFinder Find and communicate best axis limits; TProofLite PROOF-Lite c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ClassIndex.html:115666,benchmark,benchmark,115666,root/html530/ClassIndex.html,https://root.cern,https://root.cern/root/html530/ClassIndex.html,5,['benchmark'],['benchmark']
Testability,s; TProof PROOF control class; TProofChain TChain proxy for running chains on PROOF; TProofCondor PROOF control class for slaves allocated by condor; TProofDebug ; TProofDesc Small class describing a proof session; TProofDraw Tree drawing selector for PROOF; TProofDrawEntryList A Selectoor to fill a TEntryList from TTree::Draw; TProofDrawEventList Tree drawing selector for PROOF; TProofDrawGraph Tree drawing selector for PROOF; TProofDrawHist Tree drawing selector for PROOF; TProofDrawListOfGraphs Tree drawing selector for PROOF; TProofDrawListOfGraphs::Point3D_t ; TProofDrawListOfPolyMarkers3D Tree drawing selector for PROOF; TProofDrawListOfPolyMarkers3D::Point4D_t ; TProofDrawPolyMarker3D Tree drawing selector for PROOF; TProofDrawProfile Tree drawing selector for PROOF; TProofDrawProfile2D Tree drawing selector for PROOF; TProofLimitsFinder Find and communicate best axis limits; TProofLite PROOF-Lite control class; TProofLog PROOF session log handler; TProofLogElem PROOF session log element; TProofMgr Abstract PROOF manager interface; TProofMgrLite XrdProofd PROOF manager interface; TProofNodeInfo Class describing a PROOF node; TProofOutputFile Wrapper class to steer the merging of files produced on workers; TProofPlayer Basic PROOF player; TProofPlayerLite PROOF player running in PROOF-Lite; TProofPlayerLocal PROOF player running on client; TProofPlayerRemote PROOF player running on master server; TProofPlayerSlave PROOF player running on slave server; TProofPlayerSuperMaster PROOF player running on super master; TProofProgressDialog PROOF progress dialog; TProofProgressInfo Progress information; TProofProgressLog Class implementing a log graphic box; TProofProgressMemoryPlot PROOF progress memory plots; TProofProgressStatus Proof progress status class; TProofQueryResult Class describing a PROOF query; TProofResources Abstract class describing PROOF resources; TProofResourcesStatic Class to handle PROOF static config; TProofServ PROOF Server Application Interfa,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ClassIndex.html:113824,log,log,113824,root/html528/ClassIndex.html,https://root.cern,https://root.cern/root/html528/ClassIndex.html,1,['log'],['log']
Testability,"s> has to be in range (0, 1] but is set to %f."",eventCounts[cls].TrainTestSplitRequested) << Endl;; 1125 Int_t requestedTraining = Int_t(eventCounts[cls].nTrainingEventsRequested * presel_scale);; 1126 Int_t requestedTesting = Int_t(eventCounts[cls].nTestingEventsRequested * presel_scale);; 1127 ; 1128 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""events in training trees : "" << availableTraining << Endl;; 1129 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""events in testing trees : "" << availableTesting << Endl;; 1130 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""events in unspecified trees : "" << availableUndefined << Endl;; 1131 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""requested for training : "" << requestedTraining << Endl;; 1132 ; 1133 if(presel_scale<1); 1134 Log() << "" ( "" << eventCounts[cls].nTrainingEventsRequested; 1135 << "" * "" << presel_scale << "" preselection efficiency)"" << Endl;; 1136 else; 1137 Log() << Endl;; 1138 Log() << kDEBUG << ""requested for testing : "" << requestedTesting;; 1139 if(presel_scale<1); 1140 Log() << "" ( "" << eventCounts[cls].nTestingEventsRequested; 1141 << "" * "" << presel_scale << "" preselection efficiency)"" << Endl;; 1142 else; 1143 Log() << Endl;; 1144 ; 1145 // nomenclature r = available training; 1146 // s = available testing; 1147 // u = available undefined; 1148 // R = requested training; 1149 // S = requested testing; 1150 // nR = to be used to select training events; 1151 // nS = to be used to select test events; 1152 // we have the constraint: nR + nS < r+s+u,; 1153 // since we can not use more events than we have; 1154 // free events: Nfree = u-Thet(R-r)-Thet(S-s); 1155 // nomenclature: Thet(x) = x, if x>0 else 0; 1156 // nR = max(R,r) + 0.5 * Nfree; 1157 // nS = max(S,s) + 0.5 * Nfree; 1158 // nR +nS = R+S + u-R+r-S+s = u+r+s= ok! for R>r; 1159 // nR +nS = r+S + u-S+s = u+r+s= ok! for r>R; 1160 ; 1161 // three different cases might occur here; 1162 //; 1163 // Cas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataSetFactory_8cxx_source.html:50220,test,testing,50220,doc/master/DataSetFactory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html,1,['test'],['testing']
Testability,"sArg objects in the model support vectorized evaluation, likelihood computations are 2 to 10 times faster than with the legacy backend; unless your dataset is so small that the vectorization is not worth it. The relative difference of the single log-likelihoods with respect to the legacy mode is usually better than \(10^{-12}\), and for fit parameters it's usually better than \(10^{-6}\). In past ROOT releases, this backend could be activated with the now deprecated BatchMode() option. . cuda Evaluate the likelihood on a GPU that supports CUDA. This backend re-uses code from the cpu backend, but compiled in CUDA kernels. Hence, the results are expected to be identical, modulo some numerical differences that can arise from the different order in which the GPU is summing the log probabilities. This backend can drastically speed up the fit if all RooAbsArg object in the model support it. . legacy The original likelihood evaluation method. Evaluates the PDF for each single data entry at a time before summing the negative log probabilities. . codegen Experimental - Generates and compiles minimal C++ code for the NLL on-the-fly and wraps it in the returned RooAbsReal. Also generates and compiles the code for the gradient using Automatic Differentiation (AD) with Clad. This analytic gradient is passed to the minimizer, which can result in significant speedups for many-parameter fits, even compared to the cpu backend. However, if one of the RooAbsArg objects in the model does not support the code generation, this backend can't be used. . codegen_no_grad Experimental - Same as codegen, but doesn't generate and compile the gradient code and use the regular numerical differentiation instead. This is expected to be slower, but useful for debugging problems with the analytic gradient. . Optimize(bool flag) Activate constant term optimization (on by default) . SplitRange(bool flag) Use separate fit ranges in a simultaneous fit. Actual range name for each subsample is assumed to b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:91150,log,log,91150,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['log'],['log']
Testability,"sArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; Bool_tok() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFormulaVar.html:20614,test,testArg,20614,root/html534/RooFormulaVar.html,https://root.cern,https://root.cern/root/html534/RooFormulaVar.html,1,['test'],['testArg']
Testability,"sArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooNumConvolution&operator=(const RooNumConvolution&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); RooAbsReal&pdf() const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumConvolution.html:21662,test,testArg,21662,root/html602/RooNumConvolution.html,https://root.cern,https://root.cern/root/html602/RooNumConvolution.html,2,['test'],['testArg']
Testability,"sArg. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsArg. class RooAbsArg: public TNamed, public RooPrintable. RooAbsArg is the common abstract base class for objects that; represent a value (of arbitrary type) and ""shape"" that in general; depends on (is a client of) other RooAbsArg subclasses. The only; state information about a value that is maintained in this base; class consists of named attributes and flags that track when either; the value or the shape of this object changes. The meaning of shape; depends on the client implementation but could be, for example, the; allowed range of a value. The base class is also responsible for; managing client/server links and propagating value/shape changes; through an expression tree. RooAbsArg implements public interfaces; for inspecting client/server relationships and; setting/clearing/testing named attributes.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsArg(); voidTObject::AbstractMethod(const char* method) const; Bool_taddOwnedComponents(const RooArgSet& comps); voidaddParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidaddServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidaddServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidattachDataSet(const RooAbsData& set); voidattachDataStore(const RooAbsDataStore& set); const set<std::string>&attributes() const; voidbranchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsArg.html:1048,test,testing,1048,root/html528/RooAbsArg.html,https://root.cern,https://root.cern/root/html528/RooAbsArg.html,4,['test'],['testing']
Testability,"sArg. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsArg. class RooAbsArg: public TNamed, public RooPrintable. RooAbsArg is the common abstract base class for objects that; represent a value (of arbitrary type) and ""shape"" that in general; depends on (is a client of) other RooAbsArg subclasses. The only; state information about a value that is maintained in this base; class consists of named attributes and flags that track when either; the value or the shape of this object changes. The meaning of shape; depends on the client implementation but could be, for example, the; allowed range of a value. The base class is also responsible for; managing client/server links and propagating value/shape changes; through an expression tree. RooAbsArg implements public interfaces; for inspecting client/server relationships and; setting/clearing/testing named attributes.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsArg(); voidTObject::AbstractMethod(const char* method) const; Bool_taddOwnedComponents(const RooArgSet& comps); voidaddParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidaddServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidaddServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidattachDataSet(const RooAbsData& set); voidattachDataStore(const RooAbsDataStore& set); const set<string>&attributes() const; voidbranchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsArg.html:1048,test,testing,1048,root/html602/RooAbsArg.html,https://root.cern,https://root.cern/root/html602/RooAbsArg.html,2,['test'],['testing']
Testability,"sArg. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsArg. class RooAbsArg: public TNamed, public RooPrintable. RooAbsArg is the common abstract base class for objects that; represent a value (of arbitrary type) and ""shape"" that in general; depends on (is a client of) other RooAbsArg subclasses. The only; state information about a value that is maintained in this base; class consists of named attributes and flags that track when either; the value or the shape of this object changes. The meaning of shape; depends on the client implementation but could be, for example, the; allowed range of a value. The base class is also responsible for; managing client/server links and propagating value/shape changes; through an expression tree. RooAbsArg implements public interfaces; for inspecting client/server relationships and; setting/clearing/testing named attributes.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsArg(); voidTObject::AbstractMethod(const char* method) const; Bool_taddOwnedComponents(const RooArgSet& comps); voidaddParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidaddServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidaddServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); voidattachDataSet(const RooAbsData& set); voidattachDataStore(const RooAbsDataStore& set); const set<std::string>&attributes() const; voidbranchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsArg.html:1048,test,testing,1048,root/html526/RooAbsArg.html,https://root.cern,https://root.cern/root/html526/RooAbsArg.html,1,['test'],['testing']
Testability,"sArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tRooAbsPdf::isDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); const RooArgList&lowList() const; virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*RooAbsPdf::normRange() const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooJeffreysPrior.html:19678,log,logEvalError,19678,root/html532/RooJeffreysPrior.html,https://root.cern,https://root.cern/root/html532/RooJeffreysPrior.html,1,['log'],['logEvalError']
Testability,"sArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tRooAbsPdf::isDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsReal&model() const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*RooAbsPdf::normRange() const; virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNumConvPdf.html:22041,log,logEvalError,22041,root/html532/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html532/RooNumConvPdf.html,1,['log'],['logEvalError']
Testability,"sArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tRooAbsPdf::isDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCachedPdf.html:20977,log,logEvalError,20977,root/html532/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsCachedPdf.html,7,['log'],['logEvalError']
Testability,"sArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tRooAbsPdf::isDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsSelfCachedPdf.html:20601,log,logEvalError,20601,root/html532/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsSelfCachedPdf.html,48,['log'],['logEvalError']
Testability,"sArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tRooAbsPdf::isDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tmaxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooHistPdf.html:20476,log,logEvalError,20476,root/html532/RooHistPdf.html,https://root.cern,https://root.cern/root/html532/RooHistPdf.html,1,['log'],['logEvalError']
Testability,"sArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tRooAbsPdf::isDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tmaxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCBShape.html:19663,log,logEvalError,19663,root/html532/RooCBShape.html,https://root.cern,https://root.cern/root/html532/RooCBShape.html,2,['log'],['logEvalError']
Testability,"sBinOverflow ; (; Int_t ; bin, . Int_t ; axis = 0 . ); const. Return true if the bin is overflow. ; Definition at line 5182 of file TH1.cxx. ◆ IsBinUnderflow(). Bool_t TH1::IsBinUnderflow ; (; Int_t ; bin, . Int_t ; iaxis = 0 . ); const. Return true if the bin is underflow. ; If iaxis = 0 make OR with all axes otherwise check only for the given axis ; Definition at line 5214 of file TH1.cxx. ◆ IsEmpty(). Bool_t TH1::IsEmpty ; (; ); const. protected . Check if a histogram is empty (this is a protected method used mainly by TH1Merger ) ; Definition at line 5164 of file TH1.cxx. ◆ IsHighlight(). virtual Bool_t TH1::IsHighlight ; (; ); const. inlinevirtual . Definition at line 338 of file TH1.h. ◆ KolmogorovTest(). Double_t TH1::KolmogorovTest ; (; const TH1 * ; h2, . Option_t * ; option = """" . ); const. virtual . Statistical test of compatibility in shape between this histogram and h2, using Kolmogorov test. ; Note that the KolmogorovTest (KS) test should in theory be used only for unbinned data and not for binned data as in the case of the histogram (see NOTE 3 below). So, before using this method blindly, read the NOTE 3.; Default: Ignore under- and overflow bins in comparison; Parameters. [in]h2histogram ; [in]optionis a character string to specify options; ""U"" include Underflows in test (also for 2-dim); ""O"" include Overflows (also valid for 2-dim); ""N"" include comparison of normalizations; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob; ""X"" Run the pseudo experiments post-processor with the following procedure: make pseudoexperiments based on random values from the parent distribution, compare the KS distance of the pseudoexperiment to the parent distribution, and count all the KS values above the value obtained from the original data to Monte Carlo distribution. The number of pseudo-experiments nEXPT is by default 1000, and it can be changed by specifying the option as ""X=number"", for example ""X=10000"" for 10000 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:183244,test,test,183244,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['test'],['test']
Testability,"sConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tRooAbsAnaConvPdf::isDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooBCPEffDecay.html:20710,log,logEvalError,20710,root/html532/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html532/RooBCPEffDecay.html,6,['log'],['logEvalError']
Testability,"sData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooFunctorBinding&operator=(const RooFunctorBinding&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFunctorBinding.html:19874,test,testArg,19874,root/html602/RooFunctorBinding.html,https://root.cern,https://root.cern/root/html602/RooFunctorBinding.html,2,['test'],['testArg']
Testability,"sData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooUnblindUniform&operator=(const RooUnblindUniform&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooUnblindUniform.html:19410,test,testArg,19410,root/html602/RooUnblindUniform.html,https://root.cern,https://root.cern/root/html602/RooUnblindUniform.html,2,['test'],['testArg']
Testability,"sDef(MethodBase,0); // Virtual base class for all TMVA method; 732 ; 733 };; 734} // namespace TMVA; 735 ; 736 ; 737 ; 738 ; 739 ; 740 ; 741 ; 742// ========== INLINE FUNCTIONS =========================================================; 743 ; 744 ; 745//_______________________________________________________________________; 746inline const TMVA::Event* TMVA::MethodBase::GetEvent( const TMVA::Event* ev ) const; 747{; 748 return GetTransformationHandler().Transform(ev);; 749}; 750 ; 751inline const TMVA::Event* TMVA::MethodBase::GetEvent() const; 752{; 753 if(fTmpEvent); 754 return GetTransformationHandler().Transform(fTmpEvent);; 755 else; 756 return GetTransformationHandler().Transform(Data()->GetEvent());; 757}; 758 ; 759inline const TMVA::Event* TMVA::MethodBase::GetEvent( Long64_t ievt ) const; 760{; 761 assert(fTmpEvent==nullptr);; 762 return GetTransformationHandler().Transform(Data()->GetEvent(ievt));; 763}; 764 ; 765inline const TMVA::Event* TMVA::MethodBase::GetEvent( Long64_t ievt, Types::ETreeType type ) const; 766{; 767 assert(fTmpEvent==nullptr);; 768 return GetTransformationHandler().Transform(Data()->GetEvent(ievt, type));; 769}; 770 ; 771inline const TMVA::Event* TMVA::MethodBase::GetTrainingEvent( Long64_t ievt ) const; 772{; 773 assert(fTmpEvent==nullptr);; 774 return GetEvent(ievt, Types::kTraining);; 775}; 776 ; 777inline const TMVA::Event* TMVA::MethodBase::GetTestingEvent( Long64_t ievt ) const; 778{; 779 assert(fTmpEvent==nullptr);; 780 return GetEvent(ievt, Types::kTesting);; 781}; 782 ; 783#endif; Configurable.h; DataSet.h; Event.h; IMethod.h; Results.h; Char_tchar Char_tDefinition RtypesCore.h:37; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; ClassDef#define ClassDef(name, id)Definition Rtypes.h:342; TFile.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodBase_8h_source.html:32915,assert,assert,32915,doc/master/MethodBase_8h_source.html,https://root.cern,https://root.cern/doc/master/MethodBase_8h_source.html,1,['assert'],['assert']
Testability,"sDef_StreamerNVirtual_b). Data Members; private:. RooArgSet*fAltPOI; RooStats::ProfileLikelihoodTestStatfAltProfile; RooArgSet*fDetailedOutput; boolfDetailedOutputEnabled; RooStats::ProfileLikelihoodTestStatfNullProfile; Bool_tfSubtractMLE; static Bool_tfgAlwaysReuseNll. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RatioOfProfiledLikelihoodsTestStat(); Proof constructor. Don't use. RatioOfProfiledLikelihoodsTestStat(RooAbsPdf& nullPdf, RooAbsPdf& altPdf, const RooArgSet* altPOI = 0). Calculates the ratio of profiled likelihoods. 	 By default the calculation is:. 	 Lambda(mu_alt , conditional MLE for alt nuisance); 	log --------------------------------------------; 	 Lambda(mu_null , conditional MLE for null nuisance). 	where Lambda is the profile likeihood ratio, so the; 	MLE for the null and alternate are subtracted off. 	If SetSubtractMLE(false) then it calculates:. 	 L(mu_alt , conditional MLE for alt nuisance); 	log --------------------------------------------; 	 L(mu_null , conditional MLE for null nuisance). 	The values of the parameters of interest for the alternative; 	hypothesis are taken at the time of the construction.; 	If empty, it treats all free parameters as nuisance parameters. 	The value of the parameters of interest for the null hypotheses; 	are given at each call of Evaluate(data,nullPOI). ~RatioOfProfiledLikelihoodsTestStat(void). Double_t ProfiledLikelihood(RooAbsData& data, RooArgSet& poi, RooAbsPdf& pdf); returns -logL(poi, conditional MLE of nuisance params); it does not subtract off the global MLE; because nuisance parameters of null and alternate may not; be the same. Double_t Evaluate(RooAbsData& data, RooArgSet& nullParamsOfInterest); evaluate the ratio of profile likelihood. void EnableDetailedOutput(bool e = true). void SetAlwaysReuseNLL(Bool_t flag). void SetReuseNLL(Bool_t flag). void SetMinimizer(const char* minimizer). void SetStrategy(Int_t strategy). void SetTolerance(Double_t tol). vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__RatioOfProfiledLikelihoodsTestStat.html:2800,log,log,2800,root/html534/RooStats__RatioOfProfiledLikelihoodsTestStat.html,https://root.cern,https://root.cern/root/html534/RooStats__RatioOfProfiledLikelihoodsTestStat.html,1,['log'],['log']
Testability,"sDef_StreamerNVirtual_b). inline . Definition at line 166 of file TGDoubleSlider.h. Member Data Documentation. ◆ fMarkEnds. Bool_t TGDoubleSlider::fMarkEnds. protected . lines marking where stretch zones begin ; Definition at line 59 of file TGDoubleSlider.h. ◆ fMove. Int_t TGDoubleSlider::fMove. protected . 1: move min value 2: move max value 3: move min and max value 0: don't move any value ; Definition at line 54 of file TGDoubleSlider.h. ◆ fPos. Double_t TGDoubleSlider::fPos. protected . logical position between fVmin and fVmax ; Definition at line 43 of file TGDoubleSlider.h. ◆ fPressPoint. Int_t TGDoubleSlider::fPressPoint. protected . mouse position at button press event ; Definition at line 51 of file TGDoubleSlider.h. ◆ fPressSmax. Double_t TGDoubleSlider::fPressSmax. protected . logical max position at button press event ; Definition at line 53 of file TGDoubleSlider.h. ◆ fPressSmin. Double_t TGDoubleSlider::fPressSmin. protected . logical min position at button press event ; Definition at line 52 of file TGDoubleSlider.h. ◆ fRelPos. Int_t TGDoubleSlider::fRelPos. protected . slider position in pixel coordinates ; Definition at line 46 of file TGDoubleSlider.h. ◆ fReversedScale. Bool_t TGDoubleSlider::fReversedScale. protected . reverse which end is min and max ; Definition at line 58 of file TGDoubleSlider.h. ◆ fScale. Int_t TGDoubleSlider::fScale. protected . tick mark scale ; Definition at line 49 of file TGDoubleSlider.h. ◆ fScaleType. Int_t TGDoubleSlider::fScaleType. protected . tick mark scale type (no, downright, both) ; Definition at line 50 of file TGDoubleSlider.h. ◆ fSliderPic. const TGPicture* TGDoubleSlider::fSliderPic. protected . picture to draw slider ends ; Definition at line 60 of file TGDoubleSlider.h. ◆ fSmax. Double_t TGDoubleSlider::fSmax. protected . logical position of max value of Slider ; Definition at line 45 of file TGDoubleSlider.h. ◆ fSmin. Double_t TGDoubleSlider::fSmin. protected . logical position of min value of Slider ; D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGDoubleSlider.html:39773,log,logical,39773,doc/master/classTGDoubleSlider.html,https://root.cern,https://root.cern/doc/master/classTGDoubleSlider.html,1,['log'],['logical']
Testability,"sFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsTestStatistic::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tisSealed() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsOptTestStatistic.html:18587,log,logEvalError,18587,root/html534/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html,3,['log'],['logEvalError']
Testability,"sFunc;  Abstract interface for evaluating a real-valued function of one real variable and performing numerical algorithms on it. More...;  ; class  RooAbsGenContext;  Abstract base class for generator contexts of RooAbsPdf objects. More...;  ; class  RooAbsHiddenReal;  Base class for objects that want to hide their return value from interactive use, e.g. More...;  ; class  RooAbsIntegrator;  Abstract interface for integrators of real-valued functions that implement the RooAbsFunc interface. More...;  ; class  RooAbsLValue;  Abstract base class for objects that are lvalues, i.e. More...;  ; class  RooAbsMCStudyModule;  Base class for add-on modules to RooMCStudy that can perform additional calculations on each generate+fit cycle managed by RooMCStudy. More...;  ; class  RooAbsMoment;  ; class  RooAbsNumGenerator;  Abstract base class for MC event generator implementations like RooAcceptReject and RooFoam. More...;  ; class  RooAbsOptTestStatistic;  Abstract base class for test statistics objects that evaluate a function or PDF at each point of a given dataset. More...;  ; class  RooAbsPdf;  Abstract interface for all probability density functions. More...;  ; class  RooAbsProxy;  Abstract interface for proxy classes. More...;  ; class  RooAbsReal;  Abstract base class for objects that represent a real value and implements functionality common to all real-valued objects such as the ability to plot them, to construct integrals of them, the ability to advertise (partial) analytical integrals etc. More...;  ; class  RooAbsRealLValue;  Abstract base class for objects that represent a real value that may appear on the left hand side of an equation ('lvalue'). More...;  ; class  RooAbsSelfCached< Base_t >;  Abstract base class for functions whose output is cached in terms of a histogram in all observables between getVal() and evaluate(). More...;  ; class  RooAbsStudy;  Abstract base class for RooStudyManager modules. More...;  ; class  RooAbsTestStatistic;  Abstract base c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Roofitcore.html:2857,test,test,2857,doc/master/group__Roofitcore.html,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html,1,['test'],['test']
Testability,"sInfo_DeleteArray(ClassInfo_t *info, void *arena, bool dtorOnly) const finalTClingvirtual; ClassInfo_Destruct(ClassInfo_t *info, void *arena) const finalTClingvirtual; ClassInfo_Factory(Bool_t all=kTRUE) const finalTClingvirtual; ClassInfo_Factory(ClassInfo_t *cl) const finalTClingvirtual; ClassInfo_Factory(const char *name) const finalTClingvirtual; ClassInfo_Factory(DeclId_t declid) const finalTClingvirtual; ClassInfo_FileName(ClassInfo_t *info) const finalTClingvirtual; ClassInfo_FullName(ClassInfo_t *info) const finalTClingvirtual; ClassInfo_GetBaseOffset(ClassInfo_t *fromDerived, ClassInfo_t *toBase, void *address, bool isDerivedObject) const finalTClingvirtual; ClassInfo_GetMethodNArg(ClassInfo_t *info, const char *method, const char *proto, Bool_t objectIsConst=false, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch) const finalTClingvirtual; ClassInfo_GetUnderlyingType(ClassInfo_t *info) const finalTClingvirtual; ClassInfo_HasDefaultConstructor(ClassInfo_t *info, Bool_t testio=kFALSE) const finalTClingvirtual; ClassInfo_HasMethod(ClassInfo_t *info, const char *name) const finalTClingvirtual; ClassInfo_Init(ClassInfo_t *info, const char *funcname) const finalTClingvirtual; ClassInfo_Init(ClassInfo_t *info, int tagnum) const finalTClingvirtual; ClassInfo_IsBase(ClassInfo_t *info, const char *name) const finalTClingvirtual; ClassInfo_IsEnum(const char *name) const finalTClingvirtual; ClassInfo_IsLoaded(ClassInfo_t *info) const finalTClingvirtual; ClassInfo_IsScopedEnum(ClassInfo_t *info) const finalTClingvirtual; ClassInfo_IsValid(ClassInfo_t *info) const finalTClingvirtual; ClassInfo_IsValidMethod(ClassInfo_t *info, const char *method, const char *proto, Longptr_t *offset, ROOT::EFunctionMatchMode=ROOT::kConversionMatch) const finalTClingvirtual; ClassInfo_IsValidMethod(ClassInfo_t *info, const char *method, const char *proto, Bool_t objectIsConst, Longptr_t *offset, ROOT::EFunctionMatchMode=ROOT::kConversionMatch) const finalTClingvirtual; ClassInfo_Name(C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling-members.html:7767,test,testio,7767,doc/master/classTCling-members.html,https://root.cern,https://root.cern/doc/master/classTCling-members.html,1,['test'],['testio']
Testability,"sIsIndexOnError [default]: In case of missing TTreeIndex, the resulting TTree index has gaps.; BuildIndexOnError : If any of the underlying TTree objects do not have a TTreeIndex,; all TTreeIndex are 'ignored' and the missing piece are rebuilt. TTree* CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Copy a tree with selection. IMPORTANT:. The returned copied tree stays connected with the original tree; until the original tree is deleted. In particular, any changes; to the branch addresses in the original tree are also made to; the copied tree. Any changes made to the branch addresses of the; copied tree are overridden anytime the original tree changes its; branch addresses. When the original tree is deleted, all the; branch addresses of the copied tree are set to zero. For examples of CopyTree, see the tutorials:. copytree. Example macro to copy a subset of a tree to a new tree. The input file was generated by running the program in; $ROOTSYS/test/Event in this way:. ./Event 1000 1 1 1. copytree2. Example macro to copy a subset of a tree to a new tree. One branch of the new tree is written to a separate file. The input file was generated by running the program in; $ROOTSYS/test/Event in this way:. ./Event 1000 1 1 1. copytree3. Example macro to copy a subset of a tree to a new tree. Only selected entries are copied to the new tree.; NOTE that only the active branches are copied. TBasket* CreateBasket(TBranch* ); Create a basket for this tree and given branch. void Delete(Option_t* option = """"); Delete this tree from memory or/and disk. if option == ""all"" delete Tree object from memory AND from disk; all baskets on disk are deleted. All keys with same name; are deleted.; if option =="""" only Tree object in memory is deleted. void DirectoryAutoAdd(TDirectory* ); Called by TKey and TObject::Clone to automatically add us to a directory; when we are read from a file. Long64_t Draw(const char* varexp, const TC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:65553,test,test,65553,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,3,['test'],['test']
Testability,"sKeras.py;  RegressionKeras.py;  createData.CPlot the variables ;  TMVAClassification.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVAClassificationApplication.C This macro provides a simple example on how to use the trained classifiers within an analysis module ;  TMVAClassificationCategory.C This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode ;  TMVAClassificationCategoryApplication.C This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  TMVACrossValidation.C This example explains how to use the cross-validation feature of TMVA ;  TMVAGAexample.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAGAexample2.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAMulticlass.C This macro provides a simple example for the training and testing of the TMVA multiclass classification ;  TMVAMulticlassApplication.C This macro provides a simple example on how to use the trained multiclass classifiers within an analysis module ;  TMVAMultipleBackgroundExample.C This example shows the training of signal with three different backgrounds Then in the application a tree is created with all signal and background events where the true class ID and the three classifier outputs are added finally with the application tree, the significance is maximized with the help of the TMVA genetic algrorithm ;  TMVARegression.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVARegressionApplication.C This macro provides a simple example on how to use the trained regression MVAs within an analysis module ;  ► tree;  basic.C Read data from an ascii file and create a root file with an histogram and an ntuple ;  basic2.C Create can ntuple reading data from an ascii file ;  bill.C Benchmark comparing row-wise and colum",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:153856,test,testing,153856,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,3,['test'],['testing']
Testability,"sPdf*>(branchList)) {; 607 if (pdf) pdf->setTraceCounter(value,false) ;; 608 }; 609 }; 610 ; 611}; 612 ; 613 ; 614 ; 615 ; 616////////////////////////////////////////////////////////////////////////////////; 617/// Return the log of the current value with given normalization; 618/// An error message is printed if the argument of the log is negative.; 619 ; 620double RooAbsPdf::getLogVal(const RooArgSet* nset) const; 621{; 622 return getLog(getVal(nset), this);; 623}; 624 ; 625 ; 626////////////////////////////////////////////////////////////////////////////////; 627/// Check for infinity or NaN.; 628/// \param[in] inputs Array to check; 629/// \return True if either infinity or NaN were found.; 630namespace {; 631template<class T>; 632bool checkInfNaNNeg(const T& inputs) {; 633 // check for a math error or negative value; 634 bool inf = false;; 635 bool nan = false;; 636 bool neg = false;; 637 ; 638 for (double val : inputs) { //CHECK_VECTORISE; 639 inf |= !std::isfinite(val);; 640 nan |= TMath::IsNaN(val); // Works also during fast math; 641 neg |= val < 0;; 642 }; 643 ; 644 return inf || nan || neg;; 645}; 646}; 647 ; 648 ; 649////////////////////////////////////////////////////////////////////////////////; 650/// Scan through outputs and fix+log all nans and negative values.; 651/// \param[in,out] outputs Array to be scanned & fixed.; 652/// \param[in] begin Begin of event range. Only needed to print the correct event number; 653/// where the error occurred.; 654void RooAbsPdf::logBatchComputationErrors(std::span<const double>& outputs, std::size_t begin) const {; 655 for (unsigned int i=0; i<outputs.size(); ++i) {; 656 const double value = outputs[i];; 657 if (TMath::IsNaN(outputs[i])) {; 658 logEvalError(Form(""p.d.f value of (%s) is Not-a-Number (%f) for entry %zu"",; 659 GetName(), value, begin+i));; 660 } else if (!std::isfinite(outputs[i])){; 661 logEvalError(Form(""p.d.f value of (%s) is (%f) for entry %zu"",; 662 GetName(), value, begin+i));; 663 } else if (o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:24518,log,log,24518,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['log'],['log']
Testability,"sReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; RooListProxy_set1Set of constraint terms; TIterator*_setIter1! do not persist; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooConstraintSum(); Default constructor. RooConstraintSum(const char* name, const char* title, const RooArgSet& constraintSet, const RooArgSet& paramSet); Constructor with set of constraint p.d.f.s. All elements in constraintSet must inherit from RooAbsPdf. RooConstraintSum(const RooConstraintSum& other, const char* name = 0); Copy constructor. ~RooConstraintSum(); Destructor. Double_t evaluate() const; Return sum of -log of constraint p.d.f.s. TObject* clone(const char* newname) const; { return new RooConstraintSum(*this, newname); }. const RooArgList& list(); { return _set1 ; }. » Last changed: Tue Jun 30 14:32:17 2015 » Last generated: 2015-06-30 14:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooConstraintSum.html:37910,log,log,37910,root/html602/RooConstraintSum.html,https://root.cern,https://root.cern/root/html602/RooConstraintSum.html,1,['log'],['log']
Testability,"sShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_toperator==(const char*) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::own",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsString.html:8949,test,testArg,8949,root/html532/RooAbsString.html,https://root.cern,https://root.cern/root/html532/RooAbsString.html,1,['test'],['testArg']
Testability,"sShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual TStringoperator TString(); virtual RooAbsArg&operator=(const char* newValue); Bool_tRooAbsString::operator==(const char*) const; virtual Bool_tRooAbsString::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& test",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStringVar.html:8836,test,testArg,8836,root/html532/RooStringVar.html,https://root.cern,https://root.cern/root/html532/RooStringVar.html,1,['test'],['testArg']
Testability,"sTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. const RooArgList*fAllTestStatisticsDatafor the case of multiple test statistics, holds all the results; RooDataSet*fAltDetailedOutput; RooStats::SamplingDistribution*fAltDistr; Double_tfAlternatePValuep-value for the alternate hypothesis (small number means disfavored); Double_tfAlternatePValueErrorerror of p-value for the alternate hypothesis (small number means disfavored); Bool_tfBackgroundIsAlt; RooDataSet*fFitInfo; TStringTNamed::fNameobject identifier; RooDataSet*fNullDetailedOutput; RooStats::SamplingDistribution*fNullDistr; Double_tfNullPValuep-value for the null hypothesis (small number means disfavored); Double_tfNullPValueErrorerror of p-value for the null hypothesis (small number means disfavored); Bool_tfPValueIsRightTail; Double_tfTestStatisticDataresult of the test statistic evaluated on data; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; HypoTestResult(const char* name = 0); Default constructor. HypoTestResult(const char* name, Double_t nullp, Double_t altp); Alternate constructor. HypoTestResult(const RooStats::HypoTestResult& other); copy constructor. ~HypoTestResult(); Destructor. HypoTestResult & operator=(const RooStats::HypoTestResult& other); assignment operator. void Append(const RooStats::HypoTestResult* other); Add additional toy-MC experiments to the current results.; Use the data test statistics of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HypoTestResult.html:8134,test,test,8134,root/html602/RooStats__HypoTestResult.html,https://root.cern,https://root.cern/root/html602/RooStats__HypoTestResult.html,4,['test'],['test']
Testability,sTestStatistic::_nGofNumber of sub-contexts; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooArgSet*RooAbsOptTestStatistic::_normSetPointer to set with observables used for normalization; Int_tRooAbsTestStatistic::_numSetsTotal number of partitions in parallel calculation mode; Double_tRooAbsTestStatistic::_offset! Offset; Double_tRooAbsTestStatistic::_offsetCarry! avoids loss of precision; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooAbsOptTestStatistic::_optimized!; RooAbsData*RooAbsOptTestStatistic::_origDataOriginal data; RooAbsReal*RooAbsOptTestStatistic::_origFuncOriginal function; Bool_tRooAbsOptTestStatistic::_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*RooAbsOptTestStatistic::_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; RooArgSet_rrvArgsSet of real-valued observables; TIterator*_rrvIter! Iterator over set of real-valued observables; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; TStringRooAbsOptTestStatistic::_sealNoticeUser-defined notice shown when reading a sealed likelihood; Bool_tRooAbsOptTestStatistic::_sealedIs test statistic sealed -- i.e. no access to data; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsA,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooXYChi2Var.html:41844,test,test,41844,root/html602/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html602/RooXYChi2Var.html,6,['test'],['test']
Testability,"sType type, UInt_t numberClasses, UInt_t numberTargets); FDA can handle classification with 2 classes. void Init( void ); default initialisation called by all constructors. void DeclareOptions(); define the options (their key words) that can be set in the option string; TransformOutput <bool> transform (often strongly peaked) likelihood output through sigmoid inversion. void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility. void ProcessOptions(). void Train( void ); create reference distributions (PDFs) from signal and background events:; fill histograms and smooth them; if decorrelation is required, compute; corresponding square-root matrices; the reference histograms require the correct boundaries. Since in Likelihood classification; the transformations are applied using both classes, also the corresponding boundaries; need to take this into account. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns the likelihood estimator for signal; fill a new Likelihood branch into the testTree. Double_t TransformLikelihoodOutput(Double_t ps, Double_t pb) const; returns transformed or non-transformed output. void WriteOptionsToStream(ostream& o, const TString& prefix) const; write options to stream. void AddWeightsXMLTo(void* parent) const; write weights to XML. const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void WriteWeightsToStream(TFile& rf) const; write reference PDFs to ROOT file. void ReadWeightsFromXML(void* wghtnode); read weights from XML. void ReadWeightsFromStream(istream& istr); read weight info from file; nothing to do for this method. void ReadWeightsFromStream(TFile& istr); read reference PDF from ROOT file. void WriteMonitoringHistosToFile( void ); write histograms and PDFs to file for monitoring purposes. void MakeClassSpecificHeader(ostream& , const TString& = """") const; write specific header of the classifier (mostly include files). void MakeClassSpeci",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodLikelihood.html:21306,test,testTree,21306,root/html534/TMVA__MethodLikelihood.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodLikelihood.html,3,['test'],['testTree']
Testability,"sValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(Int_t index, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const char* label, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; Bool_tmap(const char* inKeyRegExp, const char* outKeyName, Int_t outKeyNum = NoCatIdx); voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; Int_tRooAbsCategory::numTypes(const char* = 0) const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observable",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMappedCategory.html:9376,test,testArg,9376,root/html526/RooMappedCategory.html,https://root.cern,https://root.cern/root/html526/RooMappedCategory.html,2,['test'],['testArg']
Testability,"sValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(Int_t index, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const char* label, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; Bool_tmap(const char* inKeyRegExp, const char* outKeyName, Int_t outKeyNum = NoCatIdx); voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; Int_tRooAbsCategory::numTypes(const char* = 0) const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooMappedCategory.html:9544,test,testArg,9544,root/html530/RooMappedCategory.html,https://root.cern,https://root.cern/root/html530/RooMappedCategory.html,2,['test'],['testArg']
Testability,"s[9] = sumwxz s[10] = sumwyz; s[11] = sumwt s[12] = sumwt2 (11 and 12 used only by TProfile3D) . EnumeratorkNstat Size of statistics data (up to TProfile3D) . Definition at line 183 of file TH1.h. ◆ EBinErrorOpt. enum TH1::EBinErrorOpt. Enumeration specifying type of statistics for bin errors. . EnumeratorkNormal Errors with Normal (Wald) approximation: errorUp=errorLow= sqrt(N) . kPoisson Errors from Poisson interval at 68.3% (1 sigma) . kPoisson2 Errors from Poisson interval at 95% CL (~ 2 sigma) . Definition at line 64 of file TH1.h. ◆ EStatOverflows. enum TH1::EStatOverflows. Enumeration specifying the way to treat statoverflow. . EnumeratorkIgnore Override global flag ignoring the overflows. . kConsider Override global flag considering the overflows. . kNeutral Adapt to the global flag. . Definition at line 80 of file TH1.h. ◆ EStatusBits. enum TH1::EStatusBits. TH1 status bits. . EnumeratorkNoStats Don't draw stats box. . kUserContour User specified contour levels. . kLogX X-axis in log scale. . kIsZoomed Bit set when zooming on Y axis. . kNoTitle Don't draw the histogram title. . kIsAverage Bin contents are average (used by Add) . kIsNotW Histogram is forced to be not weighted even when the histogram is filled with weighted. . kAutoBinPTwo different than 1. ; Use Power(2)-based algorithm for autobinning . kIsHighlight bit set if histo is highlight . Definition at line 164 of file TH1.h. Constructor & Destructor Documentation. ◆ TH1() [1/5]. TH1::TH1 ; (; const TH1 & ; ). privatedelete . ◆ TH1() [2/5]. TH1::TH1 ; (; ). protected . Histogram default constructor. ; Definition at line 615 of file TH1.cxx. ◆ TH1() [3/5]. TH1::TH1 ; (; const char * ; name, . const char * ; title, . Int_t ; nbins, . Double_t ; xlow, . Double_t ; xup . ). protected . Constructor for fix bin size histograms. ; Creates the main histogram structure.; Parameters. [in]namename of histogram (avoid blanks) ; [in]titlehistogram title. If title is of the form stringt;stringx;stringy;stringz, t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:71462,log,log,71462,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['log'],['log']
Testability,s[i].front();; 688 }; 689 ; 690 fpTmpCoordErrorVector = new double[fDim];; 691 }; 692 else; 693 {; 694 fCoordErrors.clear();; 695 fCoordErrorsPtr.clear();; 696 }; 697 ; 698 if ( kValueError == fErrorType || kCoordError == fErrorType ); 699 {; 700 fDataError.resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 701 fDataErrorPtr = fDataError.empty() ? nullptr : &fDataError.front();; 702 ; 703 fDataErrorHigh.clear();; 704 fDataErrorHighPtr = nullptr;; 705 fDataErrorLow.clear();; 706 fDataErrorLowPtr = nullptr;; 707 }; 708 else if ( fErrorType == kAsymError ); 709 {; 710 fDataErrorHigh.resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 711 fDataErrorHighPtr = fDataErrorHigh.empty() ? nullptr : &fDataErrorHigh.front();; 712 ; 713 fDataErrorLow.resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 714 fDataErrorLowPtr = fDataErrorLow.empty() ? nullptr : &fDataErrorLow.front();; 715 ; 716 fDataError.clear();; 717 fDataErrorPtr = nullptr;; 718 }; 719 else; 720 {; 721 assert(false);; 722 }; 723 }; 724 ; 725 void BinData::InitBinEdge(); 726 {; 727 fBinEdge.resize( fDim );; 728 ; 729 for( unsigned int i=0; i<fDim; i++ ); 730 {; 731 fBinEdge[i].reserve(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 732 }; 733 ; 734 if ( fpTmpBinEdgeVector ); 735 {; 736 delete[] fpTmpBinEdgeVector;; 737 fpTmpBinEdgeVector = nullptr;; 738 }; 739 ; 740 fpTmpBinEdgeVector = new double[ fDim ];; 741 }; 742 ; 743 void BinData::UnWrap( ); 744 {; 745 assert( fWrapped );; 746 assert( kValueError == fErrorType || kCoordError == fErrorType ||; 747 kAsymError == fErrorType || kNoError == fErrorType );; 748 assert( fDataError.empty() || &fDataError.front() == fDataErrorPtr );; 749 assert( fDataErrorHigh.empty() || &fDataErrorHigh.front() == fDataErrorHighPtr );; 750 assert( fDataErrorLow.empty() || &fDataErrorLow.front() == fDataErrorLowPtr );; 751 assert( fDataErrorLow.empty() == fDataErrorHigh.empty() );; 752 ; 753 assert( fData.empty() );; 754 assert( fDataPtr );; 755 ; 756 unsigned ve,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:22042,assert,assert,22042,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['assert'],['assert']
Testability,"s] array of errors of peak areas ; Definition at line 37 of file TSpectrumFit.h. ◆ fBCalc. Double_t TSpectrumFit::fBCalc. protected . calculated value of b parameter ; Definition at line 45 of file TSpectrumFit.h. ◆ fBErr. Double_t TSpectrumFit::fBErr. protected . error value of b parameter ; Definition at line 46 of file TSpectrumFit.h. ◆ fBInit. Double_t TSpectrumFit::fBInit. protected . initial value of b parameter (slope), for details see html manual and references ; Definition at line 44 of file TSpectrumFit.h. ◆ fChi. Double_t TSpectrumFit::fChi. protected . here the fitting functions return resulting chi square ; Definition at line 29 of file TSpectrumFit.h. ◆ fFitTaylor. Int_t TSpectrumFit::fFitTaylor. protected . order of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function. ; Definition at line 27 of file TSpectrumFit.h. ◆ fFixA0. Bool_t TSpectrumFit::fFixA0. protected . logical value of a0 parameter, which allows to fix the parameter (not to fit). ; Definition at line 65 of file TSpectrumFit.h. ◆ fFixA1. Bool_t TSpectrumFit::fFixA1. protected . logical value of a1 parameter, which allows to fix the parameter (not to fit). ; Definition at line 66 of file TSpectrumFit.h. ◆ fFixA2. Bool_t TSpectrumFit::fFixA2. protected . logical value of a2 parameter, which allows to fix the parameter (not to fit). ; Definition at line 67 of file TSpectrumFit.h. ◆ fFixAmp. Bool_t* TSpectrumFit::fFixAmp. protected . [fNPeaks] array of logical values which allow to fix appropriate amplitudes (not fit). However they are present in the estimated functional ; Definition at line 60 of file TSpectrumFit.h. ◆ fFixB. Bool_t TSpectrumFit::fFixB. protected . logical value of b parameter, which allows to fix the parameter (not to fit). ; Definition at line 63 of file TSpectrumFit.h. ◆ fFixPosition. Bool_t* TSpectrumFit::fFixPosition. protected . [fNPeaks] array of logical values which allow to fix appropriate positions ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrumFit.html:52985,log,logical,52985,doc/master/classTSpectrumFit.html,https://root.cern,https://root.cern/doc/master/classTSpectrumFit.html,1,['log'],['logical']
Testability,"s] array of logical values which; allow to fix appropriate amplitudes of 1D ridges in x direction (not fit).; However they are present in the estimated functional; �� Bool_t��; *fFixAmpY1;��������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 1D ridges in y direction (not fit).; However they are present in the estimated functional; �� Bool_t���; fFixSigmaX;��������� �����������//logical value of sigma x parameter, which; allows to fix the parameter (not to fit).; �� Bool_t���; fFixSigmaY;�������������������� //logical value of sigma y parameter, which; allows to fix the parameter (not to fit).; �� Bool_t��� fFixRo;������� �����������������//logical; value of correlation coefficient, which allows to fix the parameter (not to; fit).; �� Bool_t���; fFixTxy;����������������������� //logical value of t parameter for 2D peaks,; which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSxy;����������������������� //logical value of s parameter for 2D peaks,; which allows to fix the parameter (not to fit).; �� Bool_t���; fFixTx;������������������������ //logical value of t parameter for 1D ridges in; x direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixTy;������������������������ //logical value of t parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSx;������������������������ //logical value of s parameter for 1D ridges in; x direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSy;������������������������ //logical value of s parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t��� fFixBx;�� ����������������������//logical; value of b parameter for 1D ridges in x direction, which allows to fix the; parameter (not to fit).; �� Bool_t���; fFixBy;������������������������ //logical value of b parameter for 1D ridges in; y direction, which allows to fix the parameter (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2Fit.html:49350,log,logical,49350,root/html528/TSpectrum2Fit.html,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html,6,['log'],['logical']
Testability,"s_Name(). static const char * TProofProgressLog::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TProofProgressLog::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 93 of file TProofProgressLog.h. ◆ Clear(). void TProofProgressLog::Clear ; (; Option_t * ; = nullptr). overridevirtual . Clear log window. ; Reimplemented from TObject.; Definition at line 271 of file TProofProgressLog.cxx. ◆ CloseWindow(). void TProofProgressLog::CloseWindow ; (; ). overridevirtual . Handle close button or when closed via window manager action. ; Reimplemented from TGMainFrame.; Definition at line 310 of file TProofProgressLog.cxx. ◆ DeclFileName(). static const char * TProofProgressLog::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 93 of file TProofProgressLog.h. ◆ DoLog(). void TProofProgressLog::DoLog ; (; Bool_t ; grep = kFALSE). Display logs. ; 'grep' is set to kTRUE if it is invoked by pressing the 'Filter' button. ; Definition at line 388 of file TProofProgressLog.cxx. ◆ Init(). void TProofProgressLog::Init ; (; Int_t ; w = 700, . Int_t ; h = 600 . ). private . Init window frame for log messages. ; Definition at line 70 of file TProofProgressLog.cxx. ◆ IsA(). TClass * TProofProgressLog::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGTransientFrame.; Definition at line 93 of file TProofProgressLog.h. ◆ LoadBuffer(). void TProofProgressLog::LoadBuffer ; (; const char * ; buffer). Load a text buffer in the window. ; Definition at line 280 of file TProofProgressLog.cxx. ◆ LoadFile(). void TProofProgressLog::LoadFile ; (; const char * ; file). Load a file in the window. ; Definition at line 289 of file TProofProgressLog.cxx. ◆ LogMessage(). void TProofProgressLog::LogMessage ; (; const char * ; msg, . Bool_t ; all . ). Load/append a log msg in the log frame, if",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofProgressLog.html:40503,log,logs,40503,doc/master/classTProofProgressLog.html,https://root.cern,https://root.cern/doc/master/classTProofProgressLog.html,1,['log'],['logs']
Testability,"s_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TMVA::PDEFoamDensityBase; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; UInt_t fTarget;  ;  Protected Attributes inherited from TMVA::PDEFoamDensityBase; BinarySearchTree * fBst;  Binary tree to find events within a volume. ;  ; MsgLogger * fLogger;  ! message logger ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TMVA::PDEFoamDensityBase; Double_t GetBoxVolume ();  Returns the volume of range searching box fBox. ;  ; MsgLogger & Log () const;  ;  Protected Member Functions inherited fro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1PDEFoamTargetDensity.html:10384,log,logger,10384,doc/master/classTMVA_1_1PDEFoamTargetDensity.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1PDEFoamTargetDensity.html,1,['log'],['logger']
Testability,"saging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void initSlave(RooAbsReal& real, RooAbsData& indata, const RooArgSet& projDeps, const char* rangeName, const char* addCoefRangeName). ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimiz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsOptTestStatistic.html:38358,test,test,38358,root/html532/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html532/RooAbsOptTestStatistic.html,2,['test'],['test']
Testability,"same name and structure) using a TChain:; TChain* chain = new TChain(""MyTree"");; chain->AddFile(""http://root.cern.ch/root/files/tutorials/mockupx.root"");; chain->AddFile(""http://root.cern.ch/root/files/tutorials/mockupx_1.root"");; chain->AddFile(""http://root.cern.ch/root/files/tutorials/mockupx_2.root"");; chain->AddFile(""http://root.cern.ch/root/files/tutorials/mockupx_3.root"");; chain->Process(""MySelector.C+""); // if you have put your selector from above into MySelector.C. The last line will run the selector on the whole chain. O - but that takes ages! We need to:; Enable Proof Lite; There are two parts to using Proof lite: you need to create an instance and you need to tell the chain to use that instance:; // Create a Proof-lite instance:; TProof::Open("""");; // tell the chain that we want to use PROOF; chain->SetProof();; // And this will now use all your cores!; chain->Process(""MySelector.C+"");. Spoiler: here is the solution!; . ‹ 9. Fitting By Coding; up; TutorialSelector.C ›. Navigate through this book; 0. Setting up ROOT; 1. Extracting an object from a TFile; 2. Running code in ROOT; 4. Histogramming; 3. Examining a TTree's data; 5. Fitting; 6. Multivariate Analysis; 7. Using the TTreeReader; 8. Efficiency Calculation; 9. Fitting By Coding; 10. Go Parallel!; TutorialSelector.C; 11. Done!. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/10-go-parallel.html:4858,test,tests,4858,d/10-go-parallel.html,https://root.cern,https://root.cern/d/10-go-parallel.html,1,['test'],['tests']
Testability,sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.0193 sec ; Factory : Test method: DNN_CPU for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; TFHandler_DNN_CPU : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: 0.12216 0.20255 [ -1.0614 1.0246 ]; : myvar2: -0.12333 0.30492 [ -1.2280 0.99911 ]; : var3: 0.097148 0.21347 [ -1.0158 0.99984 ]; : var4: 0.17495 0.23851 [ -1.2661 1.0694 ]; : -----------------------------------------------------------; DNN_CPU : [dataset] : Evaluation of DNN_CPU on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.333 sec ; Factory : Test method: SVM for Classification performance; : ; SVM : [dataset] : Evaluation of SVM on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.287 sec ; Factory : Test method: BDT for Classification performance; : ; BDT : [dataset] : Evaluation of BDT on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.571 sec ; Factory : Test method: RuleFit for Classification performance; : ; RuleFit : [dataset] : Evaluation of RuleFit on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.0137 sec ; Factory : ␛[1mEvaluate all methods␛[0m; Factory : Evaluate classifier: Cuts; : ; <WARNING> : You have asked for histogram MVA_EFF_BvsS which does not seem to exist in *Results* .. better don't use it ; <WARNING> : You have asked for histogram EFF_BVSS_TR which does not seem to exist in *Results* .. better don't use it ; TFHandler_Cuts : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: 0.21781 1.7248 [ -9.8605 7.9024 ]; : myvar2: -0.062175 1.1106 [ -4.0854 4.0259 ]; : var3: 0.16451 1.0589 [ -5.3563 4.6422 ]; : var4: 0.43566 1.2253 [ -6.9675 5.0307 ]; : -----------------------------------------------------------; Factory : Evalu,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:68281,test,testing,68281,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['test'],['testing']
Testability,"sampler. void CreateParameterPoints() const; specify the parameter points to perform the construction.; allow ability to profile on some nuisance paramters. PointSetInterval* GetInterval() const; Main interface to get a RooStats::ConfInterval.; It constructs a RooStats::PointSetInterval. FeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); FeldmanCousins();; Common constructor. Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void SetData(RooAbsData& ); Set the DataSet. void SetPdf(RooAbsPdf& ); Set the Pdf. void SetParameters(const RooArgSet& ); specify the parameters of interest in the interval. void SetNuisanceParameters(const RooArgSet& ); specify the nuisance parameters (eg. the rest of the parameters). void SetParameterPointsToTest(RooAbsData& pointsToTest); User-defined set of points to test. void SetPOIPointsToTest(RooAbsData& poiToTest); User-defined set of points to test. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size;}. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. RooAbsData* GetPointsToScan(). ConfidenceBelt* GetConfidenceBelt(); {return fConfBelt;}. void UseAdaptiveSampling(bool flag = true); {fAdaptiveSampling=flag;}. void AdditionalNToysFactor(double fact); {fAdditionalNToysFactor = fact;}. void SetNBins(Int_t bins); {fNbins = bins;}. void FluctuateNumDataEntries(bool flag = true); {fFluctuateData = flag;}. void SaveBeltToFile(bool flag = true). void CreateConfBelt(bool flag = true); {fCreateBelt = flag;}. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id$ » Last generated: 2015-03-10 17:19; This page has bee",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__FeldmanCousins.html:5500,test,test,5500,root/html534/RooStats__FeldmanCousins.html,https://root.cern,https://root.cern/root/html534/RooStats__FeldmanCousins.html,1,['test'],['test']
Testability,"sampler. void CreateParameterPoints() const; specify the parameter points to perform the construction.; allow ability to profile on some nuisance paramters. PointSetInterval* GetInterval() const; Main interface to get a RooStats::ConfInterval.; It constructs a RooStats::PointSetInterval. FeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); FeldmanCousins();; Common constructor. Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void SetData(RooAbsData& ); Set the DataSet. void SetPdf(RooAbsPdf& ); Set the Pdf. void SetParameters(const RooArgSet& ); specify the parameters of interest in the interval. void SetNuisanceParameters(const RooArgSet& ); specify the nuisance parameters (eg. the rest of the parameters). void SetParameterPointsToTest(RooAbsData& pointsToTest); User-defined set of points to test. void SetPOIPointsToTest(RooAbsData& poiToTest); User-defined set of points to test. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size;}. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. RooAbsData* GetPointsToScan(). ConfidenceBelt* GetConfidenceBelt(); {return fConfBelt;}. void UseAdaptiveSampling(bool flag = true); {fAdaptiveSampling=flag;}. void AdditionalNToysFactor(double fact); {fAdditionalNToysFactor = fact;}. void SetNBins(Int_t bins); {fNbins = bins;}. void FluctuateNumDataEntries(bool flag = true); {fFluctuateData = flag;}. void SaveBeltToFile(bool flag = true). void CreateConfBelt(bool flag = true); {fCreateBelt = flag;}. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id$ » Last generated: 2015-06-02 15:34; This page has bee",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooStats__FeldmanCousins.html:5667,test,test,5667,root/html604/RooStats__FeldmanCousins.html,https://root.cern,https://root.cern/root/html604/RooStats__FeldmanCousins.html,1,['test'],['test']
Testability,"sampler. void CreateParameterPoints() const; specify the parameter points to perform the construction.; allow ability to profile on some nuisance paramters. PointSetInterval* GetInterval() const; Main interface to get a RooStats::ConfInterval.; It constructs a RooStats::PointSetInterval. FeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); FeldmanCousins();; Common constructor. Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void SetData(RooAbsData& ); Set the DataSet. void SetPdf(RooAbsPdf& ); Set the Pdf. void SetParameters(const RooArgSet& ); specify the parameters of interest in the interval. void SetNuisanceParameters(const RooArgSet& ); specify the nuisance parameters (eg. the rest of the parameters). void SetParameterPointsToTest(RooAbsData& pointsToTest); User-defined set of points to test. void SetPOIPointsToTest(RooAbsData& poiToTest); User-defined set of points to test. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size;}. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. RooAbsData* GetPointsToScan(). ConfidenceBelt* GetConfidenceBelt(); {return fConfBelt;}. void UseAdaptiveSampling(bool flag = true); {fAdaptiveSampling=flag;}. void AdditionalNToysFactor(double fact); {fAdditionalNToysFactor = fact;}. void SetNBins(Int_t bins); {fNbins = bins;}. void FluctuateNumDataEntries(bool flag = true); {fFluctuateData = flag;}. void SaveBeltToFile(bool flag = true). void CreateConfBelt(bool flag = true); {fCreateBelt = flag;}. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id$ » Last generated: 2015-06-30 14:36; This page has bee",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__FeldmanCousins.html:5667,test,test,5667,root/html602/RooStats__FeldmanCousins.html,https://root.cern,https://root.cern/root/html602/RooStats__FeldmanCousins.html,1,['test'],['test']
Testability,"sampler. void CreateParameterPoints() const; specify the parameter points to perform the construction.; allow ability to profile on some nuisance paramters. PointSetInterval* GetInterval() const; Main interface to get a RooStats::ConfInterval.; It constructs a RooStats::PointSetInterval. FeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); FeldmanCousins();; Common constructor. Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void SetData(RooAbsData& ); Set the DataSet. void SetPdf(RooAbsPdf& ); Set the Pdf. void SetParameters(const RooArgSet& ); specify the parameters of interest in the interval. void SetNuisanceParameters(const RooArgSet& ); specify the nuisance parameters (eg. the rest of the parameters). void SetParameterPointsToTest(RooAbsData& pointsToTest); User-defined set of points to test. void SetPOIPointsToTest(RooAbsData& poiToTest); User-defined set of points to test. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size;}. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. RooAbsData* GetPointsToScan(). ConfidenceBelt* GetConfidenceBelt(); {return fConfBelt;}. void UseAdaptiveSampling(bool flag = true); {fAdaptiveSampling=flag;}. void AdditionalNToysFactor(double fact); {fAdditionalNToysFactor = fact;}. void SetNBins(Int_t bins); {fNbins = bins;}. void FluctuateNumDataEntries(bool flag = true); {fFluctuateData = flag;}. void SaveBeltToFile(bool flag = true). void CreateConfBelt(bool flag = true); {fCreateBelt = flag;}. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: FeldmanCousins.h 39391 2011-05-26 09:51:59Z moneta $ ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__FeldmanCousins.html:5481,test,test,5481,root/html530/RooStats__FeldmanCousins.html,https://root.cern,https://root.cern/root/html530/RooStats__FeldmanCousins.html,2,['test'],['test']
Testability,"samplesSizes). Data Members; public:. enum EDistribution { kUndefined; kUserDefined; kGaussian; kLogNormal; kExponential; };; enum EUserDistribution { kCDF; kPDF; };; enum ETestType { kAD; kAD2s; kKS; kKS2s; };. private:. auto_ptr<ROOT::Math::IBaseFunctionOneDim>fCDF; vector<Double_t>fCombinedSamples; ROOT::Math::GoFTest::EDistributionfDist; Double_tfMean; vector<std::vector<Double_t> >fSamples; Double_tfSigma; Bool_tfTestSampleFromH0. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GoFTest(UInt_t sample1Size, const Double_t* sample1, UInt_t sample2Size, const Double_t* sample2); Constructor for using only with 2-samples tests. GoFTest(UInt_t sampleSize, const Double_t* sample, ROOT::Math::GoFTest::EDistribution dist = kUndefined); Constructor for using only with 1-sample tests with a specified distribution. GoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Templated constructor for using only with 1-sample tests with a user specified distribution. Instantiate(const Double_t* sample, UInt_t sampleSize). GoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Specialization using IGenFunction interface. SetUserDistribution(const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0). SetDistributionFunction(const ROOT::Math::IGenFunction& cdf, Bool_t isPDF, Double_t xmin, Double_t xmax). void SetUserPDF(const ROOT::Math::IGenFunction& pdf, Double_t xmin = 1, Double_t xmax = 0); Sets the user input distribution as a probability density function for 1-sample tests. void SetUserCDF(const ROOT::Math::IGenFunction& cdf, Double_t xmin = 1, Double_t xmax = 0); Sets the user input distribution as a cumulati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__GoFTest.html:3799,test,tests,3799,root/html528/ROOT__Math__GoFTest.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__GoFTest.html,4,['test'],['tests']
Testability,"samples[i] + samplesSizes[i]);; 186 std::sort(fSamples[i].begin(), fSamples[i].end());; 187 for (size_t j = 0; j < samplesSizes[i]; ++j) {; 188 fCombinedSamples[combinedSamplesSize + j] = samples[i][j];; 189 }; 190 combinedSamplesSize += samplesSizes[i];; 191 }; 192 std::sort(fCombinedSamples.begin(), fCombinedSamples.end());; 193 ; 194 Bool_t degenerateSamples = *(fCombinedSamples.begin()) == *(fCombinedSamples.end() - 1);; 195 if (degenerateSamples) {; 196 std::string msg = ""Degenerate sample"";; 197 msg += samplesSizes.size() > 1 ? ""s!"" : ""!"";; 198 msg += "" Sampling values all identical."";; 199 MATH_ERROR_MSG(""SetSamples"", msg.c_str());; 200 assert(!degenerateSamples);; 201 }; 202 }; 203 ; 204 void GoFTest::SetParameters(const std::vector<double> & distParams) {; 205 fParams = distParams;; 206 }; 207 ; 208 void GoFTest::operator()(ETestType test, Double_t& pvalue, Double_t& testStat) const {; 209 switch (test) {; 210 default:; 211 case kAD:; 212 AndersonDarlingTest(pvalue, testStat);; 213 break;; 214 case kAD2s:; 215 AndersonDarling2SamplesTest(pvalue, testStat);; 216 break;; 217 case kKS:; 218 KolmogorovSmirnovTest(pvalue, testStat);; 219 break;; 220 case kKS2s:; 221 KolmogorovSmirnov2SamplesTest(pvalue, testStat);; 222 }; 223 }; 224 ; 225 Double_t GoFTest::operator()(ETestType test, const Char_t* option) const {; 226 Double_t result = 0.0;; 227 switch (test) {; 228 default:; 229 case kAD:; 230 result = AndersonDarlingTest(option);; 231 break;; 232 case kAD2s:; 233 result = AndersonDarling2SamplesTest(option);; 234 break;; 235 case kKS:; 236 result = KolmogorovSmirnovTest(option);; 237 break;; 238 case kKS2s:; 239 result = KolmogorovSmirnov2SamplesTest(option);; 240 }; 241 return result;; 242 }; 243 ; 244 void GoFTest::SetCDF() { // Setting parameter-free distributions; 245 IGenFunction* cdf = nullptr;; 246 switch (fDist) {; 247 case kLogNormal:; 248 LogSample();; 249 if (fParams.empty()) fParams = {0,1};; 250 /* fall through */; 251 case kGaussian :; 252 cdf = n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GoFTest_8cxx_source.html:6924,assert,assert,6924,doc/master/GoFTest_8cxx_source.html,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html,9,"['assert', 'test']","['assert', 'test', 'testStat']"
Testability,"sation function; Input parameters:; npar: number of currently variable parameters; par: array of (constant and variable) parameters; flag: Indicates what is to be calculated (see example below); grad: array of gradients; Output parameters:; fval: The calculated function value.; grad: The (optional) vector of first derivatives). The meaning of the parameters par is of course defined by the user,; who uses the values of those parameters to calculate his function value.; The starting values must be specified by the user.; Later values are determined by Minuit as it searches for the minimum; or performs whatever analysis is requested by the user. Note that this virtual function may be redefined in a class derived from TMinuit.; The default function calls the function specified in SetFCN. Example of Minimisation function:. if (flag == 1) {; read input data,; calculate any necessary constants, etc.; }; if (flag == 2) {; calculate GRAD, the first derivatives of FVAL; (this is optional); }; Always calculate the value of the function, FVAL,; which is usually a chisquare or log likelihood.; if (iflag == 3) {; will come here only after the fit is finished.; Perform any final calculations, output fitted data, etc.; }. See concrete examples in TH1::H1FitChisquare, H1FitLikelihood. Int_t FixParameter(Int_t parNo); fix a parameter. Int_t GetParameter(Int_t parNo, Double_t& currentValue, Double_t& currentError) const; return parameter value and error. Int_t GetNumFixedPars() const; returns the number of currently fixed parameters. Int_t GetNumFreePars() const; returns the number of currently free parameters. Int_t GetNumPars() const; returns the total number of parameters that have been defined.; (fixed and free). Int_t Migrad(); invokes the MIGRAD minimizer. Int_t Release(Int_t parNo); release a parameter. Int_t SetErrorDef(Double_t up); To get the n-sigma contour the error def parameter ""up"" has to set to n^2. void SetFCN(void (*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMinuit.html:33227,log,log,33227,root/html528/TMinuit.html,https://root.cern,https://root.cern/root/html528/TMinuit.html,3,['log'],['log']
Testability,"sation function; Input parameters:; npar: number of currently variable parameters; par: array of (constant and variable) parameters; flag: Indicates what is to be calculated (see example below); grad: array of gradients; Output parameters:; fval: The calculated function value.; grad: The (optional) vector of first derivatives). The meaning of the parameters par is of course defined by the user,; who uses the values of those parameters to calculate his function value.; The starting values must be specified by the user.; Later values are determined by Minuit as it searches for the minimum; or performs whatever analysis is requested by the user. Note that this virtual function may be redefined in a class derived from TMinuit.; The default function calls the function specified in SetFCN. Example of Minimisation function:. if (flag == 1) {; read input data,; calculate any necessary constants, etc.; }; if (flag == 2) {; calculate GRAD, the first derivatives of FVAL; (this is optional); }; Always calculate the value of the function, FVAL,; which is usually a chisquare or log likelihood.; if (iflag == 3) {; will come here only after the fit is finished.; Perform any final calculations, output fitted data, etc.; }. See concrete examples in TH1::H1FitChisquare, H1FitLikelihood. Int_t FixParameter(Int_t parNo); fix a parameter. Int_t GetParameter(Int_t parNo, Double_t& currentValue, Double_t& currentError) const; return parameter value and error. Int_t GetNumFixedPars() const; returns the number of currently fixed parameters. Int_t GetNumFreePars() const; returns the number of currently free parameters. Int_t GetNumPars() const; returns the total number of parameters that have been defined; as fixed or free. The constant parameters are not counted. Int_t Migrad(); invokes the MIGRAD minimizer. Int_t Release(Int_t parNo); release a parameter. Int_t SetErrorDef(Double_t up); To get the n-sigma contour the error def parameter ""up"" has to set to n^2. void SetFCN(void (*fcn)(Int_t &",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMinuit.html:33315,log,log,33315,root/html534/TMinuit.html,https://root.cern,https://root.cern/root/html534/TMinuit.html,1,['log'],['log']
Testability,"scale for X axis; log2y - enable log2 scale for Y axis; log2z - enable log2 scale for Z axis; log2 - enable log2 scale for X,Y,Z axes; gridx - enable grid for X axis; gridy - enable grid for X axis; grid - enable grid for X and Y axes; tickx - enable ticks for X axis; ticky - enable ticks for X axis; tick - enable ticks for X and Y axes; rx - reverse X axis; ry - reverse Y axis; rotate - rotate frame; fixframe - disable interactive moving of the frame; nozoomx - disable zooming on X axis; nozoomy - disable zooming on Y axis; cpXY - create palette XY for the canvas like cp50; nopalette - ignore palette stored with TCanvas; nocolors - ignore colors list stored with TCanvas; lcolors - use only locally colors list stored with TCanvas; nomargins - clear frame margins. 1.4 Superimposing draw objects; In the URL string one could use “+” sign to specify objects superposition:. item=hpx+hprof. With similar syntax one could specify individual draw options for superimposed objects. item=hpx+hprof&opt=logy+hist. Here “logy” option will be used for “hpx1” item and “hist” option for “hprof;1” item.; While draw option can include “+” sign itself, for superposition one could specify arrays of items and draw options like:. item=[hpx;1,hprof;1]&opt=[logy,hist]. 1.5 TTree draw; JSROOT provides possibility to display TTree data, using TTree::Draw syntax:. opt=px; opt=px:py; opt=px:py:pz. It is also possible to use branch by id number specifying name like “br_0”, “br_1” and so on:. opt=br_0:br_1. Histogram ranges and binning defined after reading first 1000 entries from the tree. Like in ROOT, one could configure histogram binning and range directly:. opt=px:py>>h(50,-5,5,50,-5,5). One and two dimensional draw expressions can be resulted into TGraph object, using “>>Graph” as output:. opt=px:py>>Graph. For any integer value one can accumulate histogram with value bits distribution, specifying as output “>>bits(16)” or “>>bits”:. opt=event.fTracks.fBits>>bits. There is special handling o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:8080,log,logy,8080,root/htmldoc/guides/JSROOT/JSROOT.html,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html,1,['log'],['logy']
Testability,"scene (via; a TPad; repaint; at; present),; and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const; TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs; will generate IDs for each physical object internally. In the second you; can specify; a unique identifier from the client, which allows the viewer to be more; efficient. It can now cache both logical and physical objects, and only discard; physical; objects no longer of interest as part of scene rebuilds. Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer; is not interested in a certain object due to limits/size then it will also; not be interest in any of the contained branch of descendents. Both AddObject(); methods have an addChildren parameter. The viewer will complete this (if passed); indicating if children (contained within the one just sent) are worth adding. Recyling TBuffer3D ; Once add AddObject() has been called, the contents are copied to the viewer; internally. You are free to destroy this object, or recycle it for the next; object if suitable. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualViewer3D(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddCompositeOp(UInt_t operation); virtual Int_tAddObject(con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualViewer3D.html:10301,log,logical,10301,root/html528/TVirtualViewer3D.html,https://root.cern,https://root.cern/root/html528/TVirtualViewer3D.html,6,['log'],['logical']
Testability,"scene, need to rebuild all-element draw-vector and; sort it. Sort the TGLPhysical draw list by shape bounding box diagonal, from; large to small. This makes dropout of shapes with time limited; Draw() calls must less noticable. As this does not use projected; size it only needs to be done after a scene content change - not; everytime scene drawn (potential camera/projection change). void UpdateSceneInfo(TGLRnrCtx& rnrCtx); Fill scene-info with information needed for rendering, take into; account the render-context (viewer state, camera, clipping).; Here we have to iterate over all the physical shapes and select; the visible ones. While at it, opaque and transparent shapes are; divided into two groups. void LodifySceneInfo(TGLRnrCtx& rnrCtx); Setup LOD-dependant values in scene-info.; We have to perform LOD quantization for all draw-elements. void PreDraw(TGLRnrCtx& rnrCtx); Initialize rendering.; Pass to base-class where most work is done.; Check if GL-ctx is shared with the previous one; if not; wipe display-lists of all logicals. void RenderOpaque(TGLRnrCtx& rnrCtx); Render opaque elements. void RenderTransp(TGLRnrCtx& rnrCtx); Render transparent elements. void RenderSelOpaque(TGLRnrCtx& rnrCtx); Render selected opaque elements. void RenderSelTransp(TGLRnrCtx& rnrCtx); Render selected transparent elements. void PostDraw(TGLRnrCtx& rnrCtx); Called after the rendering is finished.; In debug mode draw statistcs is dumped.; Parent's PostDraw is called for GL cleanup. void RenderAllPasses(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout); Do full rendering of scene. First draw the opaques, then the transparents. For each we do; the number of passes required by draw mode and clipping setup. void RenderElements(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout, const TGLPlaneSet_t* clipPlanes = 0); Render DrawElements in elementVec with given timeout.; If clipPlanes is non-zero, test each element against its; clipp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLScene.html:9233,log,logicals,9233,root/html528/TGLScene.html,https://root.cern,https://root.cern/root/html528/TGLScene.html,3,['log'],['logicals']
Testability,"scene, need to rebuild all-element draw-vector and; sort it. Sort the TGLPhysical draw list by shape bounding box diagonal, from; large to small. This makes dropout of shapes with time limited; Draw() calls must less noticable. As this does not use projected; size it only needs to be done after a scene content change - not; everytime scene drawn (potential camera/projection change). void UpdateSceneInfo(TGLRnrCtx& rnrCtx); Fill scene-info with information needed for rendering, take into; account the render-context (viewer state, camera, clipping).; Here we have to iterate over all the physical shapes and select; the visible ones. While at it, opaque and transparent shapes are; divided into two groups. void LodifySceneInfo(TGLRnrCtx& rnrCtx); Setup LOD-dependant values in scene-info.; We have to perform LOD quantization for all draw-elements. void PreDraw(TGLRnrCtx& rnrCtx); Initialize rendering.; Pass to base-class where most work is done.; Check if GL-ctx is shared with the previous one; if not; wipe display-lists of all logicals. void RenderOpaque(TGLRnrCtx& rnrCtx); Render opaque elements. void RenderTransp(TGLRnrCtx& rnrCtx); Render transparent elements. void RenderSelOpaque(TGLRnrCtx& rnrCtx); Render selected opaque elements. void RenderSelTransp(TGLRnrCtx& rnrCtx); Render selected transparent elements. void RenderSelOpaqueForHighlight(TGLRnrCtx& rnrCtx); Render selected opaque elements for highlight. void RenderSelTranspForHighlight(TGLRnrCtx& rnrCtx); Render selected transparent elements for highlight. void RenderHighlight(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec). void PostDraw(TGLRnrCtx& rnrCtx); Called after the rendering is finished.; In debug mode draw statistcs is dumped.; Parent's PostDraw is called for GL cleanup. void RenderAllPasses(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout); Do full rendering of scene. First draw the opaques, then the transparents. For each we do; the number of passes required by d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLScene.html:9458,log,logicals,9458,root/html534/TGLScene.html,https://root.cern,https://root.cern/root/html534/TGLScene.html,3,['log'],['logicals']
Testability,"screen the content of the temporary log file. ; If qry == -2 show messages from the last (current) query. If qry == -1 all the messages not yet displayed are shown (default). If qry == 0, all the messages in the file are shown. If qry > 0, only the messages related to query 'qry' are shown. For qry != -1 the original file offset is restored at the end ; Definition at line 10371 of file TProof.cxx. ◆ ShowMissingFiles(). void TProof::ShowMissingFiles ; (; TQueryResult * ; qr = 0). Show information about missing files during query described by 'qr' or the last query if qr is null (default). ; A short summary is printed in the end. ; Definition at line 12522 of file TProof.cxx. ◆ ShowPackages(). void TProof::ShowPackages ; (; Bool_t ; all = kFALSE, . Bool_t ; redirlog = kFALSE . ). List contents of package directory. ; If all is true show all package directories also on slaves. If everything is ok all package directories should be the same. If redir is kTRUE the result is redirected to the log file (option available for internal actions). ; Definition at line 7770 of file TProof.cxx. ◆ ShowParameters(). void TProof::ShowParameters ; (; const char * ; wildcard = ""PROOF_*""); const. Show the input list parameters specified by the wildcard. ; Default is the special PROOF control parameters (PROOF_*). ; Definition at line 9958 of file TProof.cxx. ◆ ShowQueries(). void TProof::ShowQueries ; (; Option_t * ; opt = """"). Ask the master for the list of queries. ; Options: ""A"" show information about all the queries known to the server, i.e. even those processed by other sessions ""L"" show only information about queries locally available i.e. already retrieved. If ""L"" is specified, ""A"" is ignored. ""F"" show all details available about queries ""H"" print help menu Default """" ; Definition at line 2165 of file TProof.cxx. ◆ ShowStagingStatusDataSet(). void TProof::ShowStagingStatusDataSet ; (; const char * ; dataset, . const char * ; optStr = ""filter:SsCc"" . ). virtual . Like GetStagingSt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:151069,log,log,151069,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['log'],['log']
Testability,"scribed in menu titles, implemented by TGMenuTitle class. The menu bar is the highest-level of the menu system and it is a starting point for all interactions. Also, it is always visible and allows using the keyboard equivalents. The geometry of the menu bar is automatically set to the parent widget, i.e. the menu bar automatically resizes itself so that it has the same width as its parent (typically TGMainFrame).; The menu bar is as a container for its menus - objects of the type TGPopupMenu. Popup menus can appear in a menu bar. They can be a sub-menu of another popup menu (cascading menus) or can be standalone (as a context menu). They are made of one or more menu items choices. When displayed, the menu items are arranged in a vertical list. Usually they correspond to actions (e.g. Open). These items can be labeled with text, graphics or a combination of both. Each of them should have a character defined as its unique key for access. Grouped logically by their functionality, they are separated visually by menu separators in groups. For example, The File menu is a common menu title for tasks that apply to a file, as Open,Save,Close,Print…; // a popup menu; fMenuFile = new TGPopupMenu(gClient->GetRoot());. // adding menu entries; fMenuFile->AddEntry(""&Open..."",M_FILE_OPEN);; fMenuFile->AddEntry(""&Save"",M_FILE_SAVE);; fMenuFile->AddEntry(""S&ave as..."",M_FILE_SAVEAS);; fMenuFile->AddEntry(""&Close"", -1);. // adding separator; fMenuFile->AddSeparator();. // next group of menu entries; fMenuFile->AddEntry(""&Print"",M_FILE_PRINT);; fMenuFile->AddEntry(""P&rint setup..."",M_FILE_PRINTSETUP);; . . .; fMenuFile->AddSeparator();; fMenuFile->AddEntry(""E&xit"",M_FILE_EXIT);; First we create the File menu by creating an object of classTGPopupMenu and adding menu entries with AddEntry method. Its first parameter is a hot string, the second - a menu ID. The ampersand character (&) denotes shortcut for each menu entry; you can use the letter after it to manage the menu via keyboard. T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1190672,log,logically,1190672,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['log'],['logically']
Testability,"scription; function members; data members; class charts. ROOT; » GUI; » RECORDER; » TRecGuiEvent. class TRecGuiEvent: public TRecEvent. ROOT EVENT RECORDING SYSTEM. TRecorder class provides interface for recording and replaying; events in ROOT.; Recorded events are:; - Commands typed by user in commandline ('new TCanvas'); - GUI events (mouse movement, button clicks, ...). All the recorded events from one session are stored in one TFile; and can be replayed again anytime. Recording. 1] To start recording. TRecorder r(const char *filename, ""NEW""); TRecorder r(const char *filename, ""RECREATE""). or:. TRecorder *recorder = new TRecorder;; recorder->Start(const char *filename, ...). -filename Name of ROOT file in which to save; recorded events. 2] To stop recording. recorder->Stop(). IMPORTANT:; State capturing is part of recording. It means that if you want to; record events for some object (window), creation of this object; must be also recorded. Example:. t = new TRecorder(); // Create a new recorder; t->Start(""logfile.root""); // ! Start recording first. c = new TCanvas(); // ! Then, create an object; c->Dump(); // Work with that object. t->Stop(); // Stop recording. It is strongly recommended to start recording with empty ROOT; environment, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows dur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRecGuiEvent.html:1191,log,logfile,1191,root/html528/TRecGuiEvent.html,https://root.cern,https://root.cern/root/html528/TRecGuiEvent.html,6,['log'],['logfile']
Testability,"se of the Student and F distributions ;  multidimSampling.C Example of sampling a multi-dim distribution using the DistSampler class NOTE: This tutorial must be run with ACLIC ;  normalDist.C Tutorial illustrating the new statistical distributions functions (pdf, cdf and quantile) ;  normalDist.py Tutorial illustrating the new statistical distributions functions (pdf, cdf and quantile) ;  permute.C Tutorial illustrating the use of TMath::Permute can be run with: ;  principal.C Principal Components Analysis (PCA) example ;  principal.py Principal Components Analysis (PCA) example ;  quantiles.C Demo for quantiles ;  quasirandom.C Example of generating quasi-random numbers ;  Rolke.C Example of the usage of the TRolke class The TRolke class computes the profile likelihood confidence limits for 7 different model assumptions on systematic/statistical uncertainties ;  testrandom.C Performance test of all the ROOT random generator (TRandom, TRandom1, TRandom2 and TRandom3) Tests the generator TRandom3 against some ref values and creates a timing table against TRandom, TRandom1 and TRandom2 ;  tStudent.C Example macro describing the student t distribution ;  tStudent.py Example macro describing the student t distribution ;  TSVDUnfoldExample.C Data unfolding using Singular Value Decomposition ;  vavilov.C Test of the TMath::Vavilov distribution ;  ► matrix;  invertMatrix.C This macro shows several ways to invert a matrix ;  solveLinear.C This macro shows several ways to perform a linear least-squares analysis ;  ► mc;  CompareMasses.CMacro to compare masses in ROOT data base to the values from pdg pdg ;  ► memstat;  memstatExample.CScript post-processing the file generated by TMemStat (default memstat.root) ;  ► mlp;  mlpHiggs.C Example of a Multi Layer Perceptron For a LEP search for invisible Higgs boson, a neural network was used to separate the signal from the background passing some selection cuts ;  mlpRegression.CThis macro shows the use of an ANN for regression ana",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:135144,test,test,135144,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,2,['test'],['test']
Testability,"se the actual (problematic) value of the likelihood to be passed; # to MINUIT.; #; # NB: Use of self option is NOT recommended as default strategt as broken -log(L) values; # can often be lower than 'good' ones because offending events are removed.; # ROOT.This may effectively create a False minimum in problem areas. ROOT.This is clearly; # illustrated in the second plot; ; m0.setError(0.1); argus.fitTo(data, PrintEvalErrors=0, EvalErrorWall=False); ; # Plot likelihood as function of m0; # ------------------------------------------------------------------; ; # Construct likelihood function of model and data; nll = argus.createNLL(data); ; # Plot likelihood in m0 in range that includes problematic values; # In self configuration no messages are printed for likelihood evaluation errors,; # but if an likelihood value evaluates with error, corresponding value; # on the curve will be set to the value given in EvalErrorValue().; ; frame2 = m0.frame(Range=(5.288, 5.293), Title=""-log(L) scan vs m0, regions masked""); nll.plotOn(frame2, ShiftToZero=True, PrintEvalErrors=-1, EvalErrorValue=(nll.getVal() + 10), LineColor=""r""); frame2.SetMaximum(15); frame2.SetMinimum(0); ; c = ROOT.TCanvas(""rf606_nllerrorhandling"", ""rf606_nllerrorhandling"", 1200, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf606_nllerrorhandling.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:2823,log,log,2823,doc/master/rf606__nllerrorhandling_8py.html,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html,1,['log'],['log']
Testability,"se this software for any purpose,; 88 including commercial applications, and to alter it and redistribute it; 89 freely, subject to the following restrictions:; 90 ; 91 1. The origin of this software must not be misrepresented; you must not; 92 claim that you wrote the original software. If you use this software; 93 in a product, an acknowledgment in the product documentation would be; 94 appreciated but is not required.; 95 2. Altered source versions must be plainly marked as such, and must not be; 96 misrepresented as being the original software.; 97 3. This notice may not be removed or altered from any source distribution.; 98 ; 99 L. Peter Deutsch; 100 ghost@aladdin.com; 101 ; 102 */; 103/* $Id: md5.c,v 1.6 2002/04/13 19:20:28 lpd Exp $ */; 104/*; 105 Independent implementation of MD5 (RFC 1321).; 106 ; 107 This code implements the MD5 Algorithm defined in RFC 1321, whose; 108 text is available at; 109 http://www.ietf.org/rfc/rfc1321.txt; 110 The code is derived from the text of the RFC, including the test suite; 111 (section A.5) but excluding the rest of Appendix A. It does not include; 112 any code or documentation that is identified in the RFC as being; 113 copyrighted.; 114 ; 115 The original and principal author of md5.c is L. Peter Deutsch; 116 <ghost@aladdin.com>. Other authors are noted in the change history; 117 that follows (in reverse chronological order):; 118 ; 119 2002-04-13 lpd Clarified derivation from RFC 1321; now handles byte order; 120 either statically or dynamically; added missing #include <string.h>; 121 in library.; 122 2002-03-11 lpd Corrected argument list for main(), and added int return; 123 type, in test program and T value program.; 124 2002-02-21 lpd Added missing #include <stdio.h> in test program.; 125 2000-07-03 lpd Patched to eliminate warnings about ""constant is; 126 unsigned in ANSI C, signed in traditional""; made test program; 127 self-checking.; 128 1999-11-04 lpd Edited comments slightly for automatic TOC extraction.; 129",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/md5_8inl_source.html:4453,test,test,4453,doc/master/md5_8inl_source.html,https://root.cern,https://root.cern/doc/master/md5_8inl_source.html,1,['test'],['test']
Testability,"se {; 610 // If necessary, subtract from 0 to the beginning of the range; 611 if (ixMin <= mu) {; 612 return ROOT::Math::inc_gamma_c(ixMax, mu) - ROOT::Math::inc_gamma_c(ixMin, mu);; 613 } else {; 614 // Avoid catastrophic cancellation in the high tails:; 615 return ROOT::Math::inc_gamma(ixMin, mu) - ROOT::Math::inc_gamma(ixMax, mu);; 616 }; 617 }; 618 }; 619 ; 620 // the integral with respect to the mean is the integral of a gamma distribution; 621 // negative ix does not need protection (gamma returns 0.0); 622 const double ix = 1 + x;; 623 ; 624 return ROOT::Math::inc_gamma(ix, integrandMax) - ROOT::Math::inc_gamma(ix, integrandMin);; 625}; 626 ; 627inline double logNormalIntegral(double xMin, double xMax, double m0, double k); 628{; 629 const double root2 = std::sqrt(2.);; 630 ; 631 double ln_k = std::abs(std::log(k));; 632 double ret =; 633 0.5 * (TMath::Erf(std::log(xMax / m0) / (root2 * ln_k)) - TMath::Erf(std::log(xMin / m0) / (root2 * ln_k)));; 634 ; 635 return ret;; 636}; 637 ; 638inline double logNormalIntegralStandard(double xMin, double xMax, double mu, double sigma); 639{; 640 const double root2 = std::sqrt(2.);; 641 ; 642 double ln_k = std::abs(sigma);; 643 double ret =; 644 0.5 * (TMath::Erf((std::log(xMax) - mu) / (root2 * ln_k)) - TMath::Erf((std::log(xMin) - mu) / (root2 * ln_k)));; 645 ; 646 return ret;; 647}; 648 ; 649inline double cbShapeIntegral(double mMin, double mMax, double m0, double sigma, double alpha, double n); 650{; 651 const double sqrtPiOver2 = 1.2533141373;; 652 const double sqrt2 = 1.4142135624;; 653 ; 654 double result = 0.0;; 655 bool useLog = false;; 656 ; 657 if (std::abs(n - 1.0) < 1.0e-05); 658 useLog = true;; 659 ; 660 double sig = std::abs(sigma);; 661 ; 662 double tmin = (mMin - m0) / sig;; 663 double tmax = (mMax - m0) / sig;; 664 ; 665 if (alpha < 0) {; 666 double tmp = tmin;; 667 tmin = -tmax;; 668 tmax = -tmp;; 669 }; 670 ; 671 double absAlpha = std::abs(alpha);; 672 ; 673 if (tmin >= -absAlpha) {; 674 result += sig *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MathFuncs_8h_source.html:21109,log,log,21109,doc/master/MathFuncs_8h_source.html,https://root.cern,https://root.cern/doc/master/MathFuncs_8h_source.html,3,['log'],"['log', 'logNormalIntegralStandard']"
Testability,"se); TUnuranMultiContDist(TF1* func = 0, unsigned int dim = 0, bool isLogPdf = false); virtual~TUnuranMultiContDist(); static TClass*Class(); virtual TUnuranMultiContDist*Clone() const; doubleDerivative(const double* x, int icoord) const; const double*GetLowerDomain() const; const double*GetMode() const; const double*GetUpperDomain() const; voidGradient(const double* x, double* grad) const; virtual TClass*IsA() const; boolIsLogPdf() const; unsigned intNDim() const; TUnuranMultiContDist&operator=(const TUnuranMultiContDist& rhs); doublePdf(const double* x) const; voidSetDomain(const double* xmin, const double* xmax); voidSetMode(const double* x); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. boolfIsLogPdfflag to control if function pointer represent log of pdf; vector<double>fModevector representing the x coordinates of the maximum of the pdf ; boolfOwnFuncflag to indicate if class manages the function pointers; const ROOT::Math::IBaseFunctionMultiDim*fPdfpointer to the pdf; vector<double>fXmaxvector with upper x values of the domain ; vector<double>fXminvector with lower x values of the domain. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuranMultiContDist(TF1* func = 0, unsigned int dim = 0, bool isLogPdf = false). Constructor from a TF1 object representing the Probability density function.; The derivatives of the Pdf are estimated, when required by the UNURAN algorithm,; using numerical derivation.; If a value of dim 0 is passed , the dimension of the function is taken from TF1::GetNdim().; This works only for 2D and 3D (for TF2 and TF3 objects). TUnuranMultiContDist(const ROOT::Math::IMultiGenFunction& pdf, bool isLogPdf = false). Constructor as before but from a generic function object interface for multi-dim functions. virtual ~TUnuranMultiContDist(). Destructor. TUnuranMultiContDist(const TUnuranMultiContDist& ). Copy ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnuranMultiContDist.html:2275,log,log,2275,root/html528/TUnuranMultiContDist.html,https://root.cern,https://root.cern/root/html528/TUnuranMultiContDist.html,3,['log'],['log']
Testability,"se, . TVectorD * ; be, . TObjArray * ; l, . Int_t ; nmc = 50000, . bool ; stat = false, . TRandom * ; generator = nullptr . ). static . Definition at line 348 of file TLimit.cxx. ◆ ComputeLimit() [5/5]. TConfidenceLevel * TLimit::ComputeLimit ; (; TLimitDataSource * ; data, . Int_t ; nmc = 50000, . bool ; stat = false, . TRandom * ; generator = nullptr . ). static . Definition at line 102 of file TLimit.cxx. ◆ DeclFileName(). static const char * TLimit::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 52 of file TLimit.h. ◆ Fluctuate(). bool TLimit::Fluctuate ; (; TLimitDataSource * ; input, . TLimitDataSource * ; output, . bool ; init, . TRandom * ; generator, . bool ; stat = false . ). staticprotected . Definition at line 227 of file TLimit.cxx. ◆ IsA(). virtual TClass * TLimit::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Definition at line 52 of file TLimit.h. ◆ LogLikelihood(). Double_t TLimit::LogLikelihood ; (; Double_t ; s, . Double_t ; b, . Double_t ; b2, . Double_t ; d . ). staticprotected . Definition at line 406 of file TLimit.cxx. ◆ Streamer(). virtual void TLimit::Streamer ; (; TBuffer & ; ). virtual . ◆ StreamerNVirtual(). void TLimit::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 52 of file TLimit.h. Member Data Documentation. ◆ fgSystNames. TOrdCollection * TLimit::fgSystNames = new TOrdCollection(). staticprivate . Collection of systematics names. ; Definition at line 51 of file TLimit.h. ◆ fgTable. TArrayD * TLimit::fgTable = new TArrayD(0). staticprivate . A log table... just to speed up calculation. ; Definition at line 50 of file TLimit.h. Libraries for TLimit:. [legend]; The documentation for this class was generated from the following files:; hist/hist/inc/TLimit.h; hist/hist/src/TLimit.cxx. TLimit. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:55 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLimit.html:9730,log,log,9730,doc/master/classTLimit.html,https://root.cern,https://root.cern/doc/master/classTLimit.html,1,['log'],['log']
Testability,"se.cxx. ◆ Draw(). void TEllipse::Draw ; (; Option_t * ; option = """"). overridevirtual . Draw this ellipse with its current attributes. ; Reimplemented from TObject.; Definition at line 169 of file TEllipse.cxx. ◆ DrawEllipse(). TEllipse * TEllipse::DrawEllipse ; (; Double_t ; x1, . Double_t ; y1, . Double_t ; r1, . Double_t ; r2, . Double_t ; phimin, . Double_t ; phimax, . Double_t ; theta, . Option_t * ; option = """" . ). virtual . Draw this ellipse with new coordinates. ; Definition at line 177 of file TEllipse.cxx. ◆ ExecuteEvent(). void TEllipse::ExecuteEvent ; (; Int_t ; event, . Int_t ; px, . Int_t ; py . ). overridevirtual . Execute action corresponding to one event. ; This member function is called when a line is clicked with the locator; If Left button clicked on one of the line end points, this point follows the cursor until button is released.; if Middle button clicked, the line is moved parallel to itself until the button is released.; NOTE that support for log scale is not implemented ; Reimplemented from TObject.; Definition at line 201 of file TEllipse.cxx. ◆ GetBBox(). Rectangle_t TEllipse::GetBBox ; (; ). overridevirtual . Return the bounding Box of the Ellipse, currently not taking into account the rotating angle. ; Implements TAttBBox2D.; Definition at line 698 of file TEllipse.cxx. ◆ GetBBoxCenter(). TPoint TEllipse::GetBBoxCenter ; (; ). overridevirtual . Return the center of the Ellipse as TPoint in pixels. ; Implements TAttBBox2D.; Definition at line 713 of file TEllipse.cxx. ◆ GetNoEdges(). Bool_t TEllipse::GetNoEdges ; (; ); const. Return kTRUE if kNoEdges bit is set, kFALSE otherwise. ; Definition at line 646 of file TEllipse.cxx. ◆ GetPhimax(). Double_t TEllipse::GetPhimax ; (; ); const. inline . Definition at line 54 of file TEllipse.h. ◆ GetPhimin(). Double_t TEllipse::GetPhimin ; (; ); const. inline . Definition at line 53 of file TEllipse.h. ◆ GetR1(). Double_t TEllipse::GetR1 ; (; ); const. inline . Definition at line 51 of file TEllip",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEllipse.html:21415,log,log,21415,doc/master/classTEllipse.html,https://root.cern,https://root.cern/doc/master/classTEllipse.html,1,['log'],['log']
Testability,se.cxx;  TQpProbDens.cxx;  TQpProbSparse.cxx;  TQpResidual.cxx;  TQpSolverBase.cxx;  TQpVar.cxx;  ► rtools;  ► inc;  ► Math;  RMinimizer.h;  LinkDef.h;  ► src;  RMinimizer.cxx;  ► smatrix;  ► inc;  ► Math;  BinaryOperators.h;  BinaryOpPolicy.h;  CholeskyDecomp.hHeader file containing the templated implementation of matrix inversion routines for use with ROOT's SMatrix classes (symmetric positive definite case) ;  CramerInversion.icc;  CramerInversionSym.icc;  Dfact.h;  Dfactir.h;  Dfinv.h;  Dinv.h;  Dsfact.h;  Dsinv.h;  Expression.h;  Functions.h;  HelperOps.h;  MatrixFunctions.h;  MatrixInversion.icc;  MatrixRepresentationsStatic.h;  MConfig.h;  SMatrix.h;  SMatrix.icc;  SMatrixDfwd.h;  SMatrixFfwd.h;  StaticCheck.h;  SVector.h;  SVector.icc;  UnaryOperators.h;  LinkDef.h;  LinkDefAll.h;  LinkDefD32.h;  ► src;  Dict.h;  ► test;  kalman.C;  matrix_op.h;  matrix_util.h;  matrixOperations.C;  stressKalman.cxx;  stressOperations.cxx;  testInversion.cxx;  testIO.cxx;  testKalman.cxx;  testOperations.cxx;  testSMatrix.cxx;  TestTimer.h;  Track.h;  TrackLinkDef.h;  ► splot;  ► inc;  LinkDef.h;  TSPlot.h;  ► src;  TSPlot.cxx;  ► unuran;  ► inc;  LinkDef.h;  TUnuran.h;  TUnuranBaseDist.h;  TUnuranContDist.h;  TUnuranDiscrDist.h;  TUnuranEmpDist.h;  TUnuranMultiContDist.h;  TUnuranSampler.h;  ► src;  TUnuran.cxx;  TUnuranContDist.cxx;  TUnuranDiscrDist.cxx;  TUnuranEmpDist.cxx;  TUnuranMultiContDist.cxx;  TUnuranSampler.cxx;  UnuranDistr.h;  UnuranDistrAdapter.h;  UnuranRng.h;  ► test;  unuranDiscrete.cxx;  unuranDistr.cxx;  unuranHist.cxx;  unuranMulti2D.cxx;  unuranMultiDim.cxx;  unuranSimple.cxx;  ► vc;  ► examples;  ► buddhabrot;  main.cpp;  main.h;  ► finitediff;  main.cpp;  ► fit;  GaussFunction.h;  MinimizerTypes.h;  testFitPerf.cxx;  ► genvector;  vectorOperation.cxx;  ► mandelbrot;  main.cpp;  main.h;  mandel.cpp;  mandel.h;  ► matrix;  main.cpp;  ► polarcoord;  main.cpp;  ► smatrix;  matrix_op_vec.h;  matrix_util.h;  testKalman.cxx;  testOperations.cxx;  TestTimer.h,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/files.html:57064,test,testOperations,57064,root/html606/files.html,https://root.cern,https://root.cern/root/html606/files.html,1,['test'],['testOperations']
Testability,se.cxx;  TQpProbDens.cxx;  TQpProbSparse.cxx;  TQpResidual.cxx;  TQpSolverBase.cxx;  TQpVar.cxx;  ► rtools;  ► inc;  ► Math;  RMinimizer.h;  LinkDef.h;  ► src;  RMinimizer.cxx;  ► smatrix;  ► inc;  ► Math;  BinaryOperators.h;  BinaryOpPolicy.h;  CholeskyDecomp.hHeader file containing the templated implementation of matrix inversion routines for use with ROOT's SMatrix classes (symmetric positive definite case) ;  CramerInversion.icc;  CramerInversionSym.icc;  Dfact.h;  Dfactir.h;  Dfinv.h;  Dinv.h;  Dsfact.h;  Dsinv.h;  Expression.h;  Functions.h;  HelperOps.h;  MatrixFunctions.h;  MatrixInversion.icc;  MatrixRepresentationsStatic.h;  MConfig.h;  SMatrix.h;  SMatrix.icc;  SMatrixDfwd.h;  SMatrixFfwd.h;  StaticCheck.h;  SVector.h;  SVector.icc;  UnaryOperators.h;  LinkDef.h;  LinkDefAll.h;  LinkDefD32.h;  ► src;  Dict.h;  ► test;  kalman.C;  matrix_op.h;  matrix_util.h;  matrixOperations.C;  stressKalman.cxx;  stressOperations.cxx;  testInversion.cxx;  testIO.cxx;  testKalman.cxx;  testOperations.cxx;  testSMatrix.cxx;  TestTimer.h;  Track.h;  TrackLinkDef.h;  ► splot;  ► inc;  LinkDef.h;  TSPlot.h;  ► src;  TSPlot.cxx;  ► unuran;  ► inc;  LinkDef.h;  TUnuran.h;  TUnuranBaseDist.h;  TUnuranContDist.h;  TUnuranDiscrDist.h;  TUnuranEmpDist.h;  TUnuranMultiContDist.h;  TUnuranSampler.h;  ► src;  TUnuran.cxx;  TUnuranContDist.cxx;  TUnuranDiscrDist.cxx;  TUnuranEmpDist.cxx;  TUnuranMultiContDist.cxx;  TUnuranSampler.cxx;  UnuranDistr.h;  UnuranDistrAdapter.h;  UnuranRng.h;  ► test;  unuranDiscrete.cxx;  unuranDistr.cxx;  unuranHist.cxx;  unuranMulti2D.cxx;  unuranMultiDim.cxx;  unuranSimple.cxx;  ► vdt;  ► include;  ► vdt;  asin.h;  atan.h;  atan2.h;  cos.h;  exp.h;  inv.h;  log.h;  sin.h;  sincos.h;  sqrt.h;  tan.h;  vdtcore_common.h;  vdtMath.h;  ► tests;  stressVdt.cxx;  ► misc;  ► memstat;  ► inc;  LinkDef.h;  TMemStat.h;  TMemStatBacktrace.h;  TMemStatDef.h;  TMemStatHelpers.h;  TMemStatHook.h;  TMemStatMng.h;  ► src;  TMemStat.cxx;  TMemStatBacktrace.cxx;  TMemStatH,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:57432,test,testOperations,57432,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,1,['test'],['testOperations']
Testability,"seOptionCheckingEnabled() const; voidTObject::MakeZombie(); voidTMVA::Configurable::ResetSetFlag(); voidTMVA::Configurable::WriteOptionsReferenceToFile(). private:. TMVA::IMethod*BookMVA(TMVA::Types::EMVA method, const TString& weightfile); voidDeclareOptions(); voidDecodeVarNames(const string& varNames); voidDecodeVarNames(const TString& varNames); TStringGetMethodTypeFromFile(const TString& filename); voidInit(); TMVA::MsgLogger&Log() const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Bool_tfCalculateErrorerror calculation mode; Bool_tfColorcolor mode; TMVA::DataInputHandlerfDataInputHandler; TMVA::DataSetInfofDataSetInfothe data set; TMVA::DataSetManager*fDataSetManagerDSMTEST; TMVA::MsgLogger*fLoggermessage logger; map<TString,IMethod*>fMethodMapmap of methods; Double_tfMvaEventErrorper-event error returned by MVA; Double_tfMvaEventErrorUpperper-event error returned by MVA; Bool_tfSilentsilent mode; vector<Float_t>fTmpEvalVectemporary evaluation vector (if user input is v<double>); Bool_tfVerboseverbosity. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Reader(const TString& theOption = """", Bool_t verbose = 0); constructor. Reader(vector<TString>& varNames, const TString& theOption = """", Bool_t verbose = 0); constructor. Reader(vector<std::string>& varNames, const TString& theOption = """", Bool_t verbose = 0); constructor. Reader( const std::string& varNames, const TString& theOption, Bool_t verbose ); constructor. Reader(const TString& varNames, const TString& theOption, Bool_t verbose = 0); constructor. void DeclareOptions(); declaration of configuration options. ~Reader( void ); destructor. void Init( void ); default initialisation (no member variables); default initialisation (no",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__Reader.html:10537,log,logger,10537,root/html528/TMVA__Reader.html,https://root.cern,https://root.cern/root/html528/TMVA__Reader.html,4,['log'],['logger']
Testability,"seRegulatorzjh; TRandom3*TMVA::MethodANNBase::frgenrandom number generator for various uses. private:. TMVA::MethodMLP::EBPTrainingModefBPModebackprop learning mode (sequential or batch); Int_tfBatchSizebatch size, only matters if in batch learning mode; TStringfBpModeSbackprop learning mode option string (sequential or batch); boolfCalculateErrorscompute inverse hessian matrix at the end of the training; Double_tfDecayRatedecay rate for above learning rate; vector<std::pair<Float_t,Float_t> >*fDeviationsFromTargetsdeviation from the targets, event weight; Bool_tfEpochMoncreate and fill epoch-wise monitoring histograms (makes outputfile big!); Double_tfGA_SC_factorGA settings: SC_factor; Int_tfGA_SC_rateGA settings: SC_rate; Int_tfGA_SC_stepsGA settings: SC_steps; Int_tfGA_nstepsGA settings: number of steps; Int_tfGA_preCalcGA settings: number of pre-calc steps; Double_tfLastAlphaline search variable; Double_tfLearnRatelearning rate for synapse weight adjustments; Double_tfPriorzjh; vector<Double_t>fPriorDevzjh; Int_tfResetStepreset time (how often we clear hessian matrix); Float_tfSamplingEpochfraction of epochs where sampling is used; Float_tfSamplingFractionfraction of events which is sampled for training; Bool_tfSamplingTestingThe testing sample is sampled; Bool_tfSamplingTrainingThe training sample is sampled; Float_tfSamplingWeightchanging factor for event weights when sampling is turned on; Double_tfTauline search variable; Int_tfTestRatetest for overtraining performed at each #th epochs; TStringfTrainMethodStraining method option param; TMVA::MethodMLP::ETrainingMethodfTrainingMethodmethod of training, BP or GA; Int_tfUpdateLimitzjh; boolfUseRegulatorzjh; Float_tfWeightRangesuppress outliers for the estimator calculation; static const Bool_tfgPRINT_BATCHdebug flags; static const Int_tfgPRINT_ESTIMATOR_INCdebug flags; static const Bool_tfgPRINT_SEQdebug flags. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodMLP(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodMLP.html:21704,test,testing,21704,root/html530/TMVA__MethodMLP.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodMLP.html,3,['test'],['testing']
Testability,"selection uses any arrays or containers, we return the number of entries where at least one element match the selection. GetEntries is implemented using the selector class TSelectorEntries, which can be used directly (see code in TTreePlayer::GetEntries) for additional option. If SetEventList was used on the TTree or TChain, only that subset of entries will be considered. ; Reimplemented in TProofChain, TChain, and TTreeSQL.; Definition at line 5499 of file TTree.cxx. ◆ GetEntriesFast(). virtual Long64_t TTree::GetEntriesFast ; (; ); const. inlinevirtual . Return a number greater or equal to the total number of entries in the dataset. ; NoteIf you are interested in the total number of entries in a TChain, this function will give that number once the last file of the chain is opened. In general, using this instead of GetEntries will avoid opening all files in the chain which could be very costly for very large number of files stored at a remote location.; The logic depends on whether the dataset is a TTree or a TChain. In the first case, it simply returns the total number of entries in the tree. In the latter case, it depends on which point of the processing of the chain this function is called. During most of the chain processing, this function will return TTree::kMaxEntries. When the chain arrives at the last file, then the function will return the accumulated total number of entries in the whole chain. A notable use case where this function becomes quite useful is when writing the following for loop to traverse the entries in the dataset:; for(Long64_t ievent = 0; ievent < dataset.GetEntriesFast(); ievent++) {; // Do something with the event in the dataset; }; In the example above, independently on whether the dataset is a TTree or a TChain, the GetEntriesFast call will provide the correct stopping condition for the loop (i.e. the total number of entries). In the TChain case, calling GetEntries instead would open all the files in the chain upfront which could be c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:149760,log,logic,149760,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,1,['log'],['logic']
Testability,"sent.. for debug.. to spot memory leaks... Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Node(); default constructor. Node(TMVA::Node* p, char pos); constructor of a daughter node as a daughter of 'p'. Node(const TMVA::Node& n); copy constructor, make sure you don't just copy the poiter to the node, but; that the parents/daugthers are initialized to 0 (and set by the copy; constructors of the derived classes. ~Node(); node destructor. int GetCount(); retuns the global number of instantiated nodes. Int_t CountMeAndAllDaughters() const; recursively go through the part of the tree below this node and count all daughters. void* AddXMLTo(void* parent) const; add attributes to XML. void ReadXML(void* node, UInt_t tmva_Version_Code = 262656); read attributes from XML. Node* CreateNode() const. Bool_t GoesRight(const TMVA::Event& ) const; test event if i{ decends the tree at this node to the right. Bool_t GoesLeft(const TMVA::Event& ) const; test event if it decends the tree at this node to the left. Node* GetLeft() const; test event if it is equal to the event that ""makes the node"" (just for the ""search tree""; return pointer to the left/right daughter or parent node. { return fLeft; }. Node* GetRight() const; { return fRight; }. Node* GetParent() const; { return fParent; }. void SetLeft(TMVA::Node* l); set pointer to the left/right daughter or parent node. { fLeft = l;}. void SetRight(TMVA::Node* r); { fRight = r;}. void SetParent(TMVA::Node* p); { fParent = p;}. void Print(ostream& os) const; printout of the node. void PrintRec(ostream& os) const; recursive printout of the node and it daughters. void AddAttributesToNode(void* node) const. void AddContentToNode(stringstream& s) const. void SetDepth(UInt_t d); Set depth, layer of the where the node is within the tree, seen from the top (root). {fDepth=d;}. UInt_t GetDepth() const; Return depth, layer of the where the node is within the tree, seen from the top (root). {return fDep",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__Node.html:3617,test,test,3617,root/html602/TMVA__Node.html,https://root.cern,https://root.cern/root/html602/TMVA__Node.html,1,['test'],['test']
Testability,"sent.. for debug.. to spot memory leaks... Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Node(); default constructor. Node(TMVA::Node* p, char pos); constructor of a daughter node as a daughter of 'p'. Node(const TMVA::Node& n); copy constructor, make sure you don't just copy the poiter to the node, but; that the parents/daugthers are initialized to 0 (and set by the copy; constructors of the derived classes. ~Node(); node destructor. int GetCount(); retuns the global number of instantiated nodes. Int_t CountMeAndAllDaughters() const; recursively go through the part of the tree below this node and count all daughters. void* AddXMLTo(void* parent) const; add attributes to XML. void ReadXML(void* node, UInt_t tmva_Version_Code = 262657); read attributes from XML. Node* CreateNode() const. Bool_t GoesRight(const TMVA::Event& ) const; test event if i{ decends the tree at this node to the right. Bool_t GoesLeft(const TMVA::Event& ) const; test event if it decends the tree at this node to the left. Node* GetLeft() const; test event if it is equal to the event that ""makes the node"" (just for the ""search tree""; return pointer to the left/right daughter or parent node. { return fLeft; }. Node* GetRight() const; { return fRight; }. Node* GetParent() const; { return fParent; }. void SetLeft(TMVA::Node* l); set pointer to the left/right daughter or parent node. { fLeft = l;}. void SetRight(TMVA::Node* r); { fRight = r;}. void SetParent(TMVA::Node* p); { fParent = p;}. void Print(ostream& os) const; printout of the node. void PrintRec(ostream& os) const; recursive printout of the node and it daughters. void AddAttributesToNode(void* node) const. void AddContentToNode(stringstream& s) const. void SetDepth(UInt_t d); Set depth, layer of the where the node is within the tree, seen from the top (root). {fDepth=d;}. UInt_t GetDepth() const; Return depth, layer of the where the node is within the tree, seen from the top (root). {return fDep",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__Node.html:3625,test,test,3625,root/html604/TMVA__Node.html,https://root.cern,https://root.cern/root/html604/TMVA__Node.html,1,['test'],['test']
Testability,"ser::FindWidget ; (; const std::string & ; name, . const std::string & ; kind = """" . ); const. protected . Find widget by name or kind. ; Definition at line 602 of file RBrowser.cxx. ◆ GetActiveWidget(). std::shared_ptr< RBrowserWidget > ROOT::RBrowser::GetActiveWidget ; (; ); const. inlineprotected . Definition at line 54 of file RBrowser.hxx. ◆ GetCatchWindowShow(). bool ROOT::RBrowser::GetCatchWindowShow ; (; ); const. inline . Is RWebWindow::Show calls catched for embeding of created widgets. ; Definition at line 102 of file RBrowser.hxx. ◆ GetCurrentWorkingDirectory(). std::string RBrowser::GetCurrentWorkingDirectory ; (; ). protected . Return the current directory of ROOT. ; Definition at line 734 of file RBrowser.cxx. ◆ GetRootHistory(). std::vector< std::string > RBrowser::GetRootHistory ; (; ). protected . Get content of history file. ; Definition at line 631 of file RBrowser.cxx. ◆ GetRootLogs(). std::vector< std::string > RBrowser::GetRootLogs ; (; ). protected . Get content of log file. ; Definition at line 654 of file RBrowser.cxx. ◆ GetUseRCanvas(). bool ROOT::RBrowser::GetUseRCanvas ; (; ); const. inline . Definition at line 82 of file RBrowser.hxx. ◆ GetWindowUrl(). std::string RBrowser::GetWindowUrl ; (; bool ; remote). Return URL parameter for the window showing ROOT Browser See ROOT::RWebWindow::GetUrl docu for more details. ; Definition at line 529 of file RBrowser.cxx. ◆ Hide(). void RBrowser::Hide ; (; ). hide Browser ; Hide ROOT Browser. ; Definition at line 519 of file RBrowser.cxx. ◆ NewWidgetMsg(). std::string RBrowser::NewWidgetMsg ; (; std::shared_ptr< RBrowserWidget > & ; widget). protected . Create message which send to client to create new widget. ; Definition at line 742 of file RBrowser.cxx. ◆ ProcessBrowserRequest(). std::string RBrowser::ProcessBrowserRequest ; (; const std::string & ; msg). protected . Process browser request. ; Definition at line 349 of file RBrowser.cxx. ◆ ProcessDblClick(). std::string RBrowser::ProcessDblClick ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RBrowser.html:7752,log,log,7752,doc/v632/classROOT_1_1RBrowser.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RBrowser.html,1,['log'],['log']
Testability,"ser::FindWidget ; (; const std::string & ; name, . const std::string & ; kind = """" . ); const. protected . Find widget by name or kind. ; Definition at line 616 of file RBrowser.cxx. ◆ GetActiveWidget(). std::shared_ptr< RBrowserWidget > ROOT::RBrowser::GetActiveWidget ; (; ); const. inlineprotected . Definition at line 54 of file RBrowser.hxx. ◆ GetCatchWindowShow(). bool ROOT::RBrowser::GetCatchWindowShow ; (; ); const. inline . Is RWebWindow::Show calls catched for embeding of created widgets. ; Definition at line 102 of file RBrowser.hxx. ◆ GetCurrentWorkingDirectory(). std::string RBrowser::GetCurrentWorkingDirectory ; (; ). protected . Return the current directory of ROOT. ; Definition at line 748 of file RBrowser.cxx. ◆ GetRootHistory(). std::vector< std::string > RBrowser::GetRootHistory ; (; ). protected . Get content of history file. ; Definition at line 645 of file RBrowser.cxx. ◆ GetRootLogs(). std::vector< std::string > RBrowser::GetRootLogs ; (; ). protected . Get content of log file. ; Definition at line 668 of file RBrowser.cxx. ◆ GetUseRCanvas(). bool ROOT::RBrowser::GetUseRCanvas ; (; ); const. inline . Definition at line 82 of file RBrowser.hxx. ◆ GetWindowUrl(). std::string RBrowser::GetWindowUrl ; (; bool ; remote). Return URL parameter for the window showing ROOT Browser See ROOT::RWebWindow::GetUrl docu for more details. ; Definition at line 543 of file RBrowser.cxx. ◆ Hide(). void RBrowser::Hide ; (; ). hide Browser ; Hide ROOT Browser. ; Definition at line 533 of file RBrowser.cxx. ◆ NewWidgetMsg(). std::string RBrowser::NewWidgetMsg ; (; std::shared_ptr< RBrowserWidget > & ; widget). protected . Create message which send to client to create new widget. ; Definition at line 756 of file RBrowser.cxx. ◆ ProcessBrowserRequest(). std::string RBrowser::ProcessBrowserRequest ; (; const std::string & ; msg). protected . Process browser request. ; Definition at line 363 of file RBrowser.cxx. ◆ ProcessDblClick(). std::string RBrowser::ProcessDblClick ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RBrowser.html:7800,log,log,7800,doc/master/classROOT_1_1RBrowser.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RBrowser.html,1,['log'],['log']
Testability,"sert( fDataErrorHigh.empty() && !fDataErrorHighPtr );; 529 assert( fDataErrorLow.empty() && !fDataErrorLowPtr );; 530 assert( !fDataError.empty() && fDataErrorPtr );; 531 assert( fCoordErrors.empty() && fCoordErrorsPtr.empty() );; 532 ; 533 fData[ fNPoints ] = val;; 534 fDataError[ fNPoints ] = (eval != 0.0) ? 1.0/eval : 0.0;; 535 ; 536 FitData::Add( x );; 537 fSumContent += val;; 538 if (val != 0 || eval != 1.0) fSumError2 += eval*eval;; 539 if (!fIsWeighted); 540 if (val != 0 && std::abs( eval*eval/val - 1.0) > 1.E-12) fIsWeighted = true;; 541 }; 542 ; 543 /**; 544 add multi-dim coordinate data with both error in coordinates and value; 545 */; 546 void BinData::Add( const double* x, double val, const double* ex, double eval ); 547 {; 548 assert( kCoordError == fErrorType );; 549 assert( !fData.empty() && fDataPtr );; 550 assert( !fDataError.empty() && fDataErrorPtr );; 551 assert( fDataErrorHigh.empty() && !fDataErrorHighPtr );; 552 assert( fDataErrorLow.empty() && !fDataErrorLowPtr );; 553 assert( fCoordErrors.size() == fDim );; 554 assert( fCoordErrorsPtr.size() == fDim );; 555 ; 556 fData[ fNPoints ] = val;; 557 ; 558 for( unsigned int i=0; i<fDim; i++ ); 559 {; 560 assert( &fCoordErrors[i].front() == fCoordErrorsPtr[i] );; 561 ; 562 fCoordErrors[i][ fNPoints ] = ex[i];; 563 }; 564 // in this case we store the y error and not the inverse; 565 fDataError[ fNPoints ] = eval;; 566 ; 567 FitData::Add( x );; 568 fSumContent += val;; 569 if (val != 0 || eval != 1.0) fSumError2 += eval*eval;; 570 if (!fIsWeighted); 571 if (val != 0 && std::abs( eval*eval/val - 1.0) > 1.E-12) fIsWeighted = true;; 572 }; 573 ; 574 /**; 575 add multi-dim coordinate data with both error in coordinates and value; 576 */; 577 void BinData::Add( const double* x, double val, const double* ex, double elval, double ehval ); 578 {; 579 assert( kAsymError == fErrorType );; 580 ; 581 assert( !fData.empty() && fDataPtr );; 582 assert( !fDataErrorHigh.empty() && fDataErrorHighPtr );; 583 assert( !fD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:17100,assert,assert,17100,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['assert'],['assert']
Testability,"sertActions(QAction* before, QList<QAction*> actions); voidQObject::installEventFilter(QObject*); WIdQWidget::internalWinId() const; boolQWidget::isActiveWindow() const; boolQWidget::isAncestorOf(const QWidget* child) const; boolQWidget::isEnabled() const; boolQWidget::isEnabledTo(QWidget*) const; boolQWidget::isEnabledToTLW() const; boolQWidget::isFullScreen() const; boolQWidget::isHidden() const; boolQWidget::isLeftToRight() const; boolQWidget::isMaximized() const; boolQWidget::isMinimized() const; boolQWidget::isModal() const; boolQWidget::isRightToLeft() const; boolQWidget::isTopLevel() const; boolQWidget::isVisible() const; boolQWidget::isVisibleTo(QWidget*) const; boolQObject::isWidgetType() const; boolQWidget::isWindow() const; boolQWidget::isWindowModified() const; static QWidget*QWidget::keyboardGrabber(); voidQObject::killTimer(int id); QLayout*QWidget::layout() const; Qt::LayoutDirectionQWidget::layoutDirection() const; QLocaleQWidget::locale() const; intQPaintDevice::logicalDpiX() const; intQPaintDevice::logicalDpiY() const; voidQWidget::lower(); QPointQWidget::mapFrom(QWidget*, const QPoint&) const; QPointQWidget::mapFromGlobal(const QPoint&) const; QPointQWidget::mapFromParent(const QPoint&) const; QPointQWidget::mapTo(QWidget*, const QPoint&) const; QPointQWidget::mapToGlobal(const QPoint&) const; QPointQWidget::mapToParent(const QPoint&) const; QRegionQWidget::mask() const; intQWidget::maximumHeight() const; QSizeQWidget::maximumSize() const; intQWidget::maximumWidth() const; virtual const QMetaObject*QWidget::metaObject() const; intQWidget::minimumHeight() const; QSizeQWidget::minimumSize() const; virtual QSizeQWidget::minimumSizeHint() const; intQWidget::minimumWidth() const; static QWidget*QWidget::mouseGrabber(); voidQWidget::move(const QPoint&); voidQWidget::move(int x, int y); voidQObject::moveToThread(QThread* thread); QWidget*QWidget::nativeParentWidget() const; QWidget*QWidget::nextInFocusChain() const; QRectQWidget::normalGeometry() const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQRootCanvas.html:5029,log,logicalDpiX,5029,root/html602/TQRootCanvas.html,https://root.cern,https://root.cern/root/html602/TQRootCanvas.html,2,['log'],['logicalDpiX']
Testability,"servables identified by code assigned in getMaxVal.Definition RooAbsReal.cxx:3397; RooAbsReal::findInnerMostIntegrationvoid findInnerMostIntegration(const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) constUtility function for createIntObj() that aids in the construct of recursive integrals over functions ...Definition RooAbsReal.cxx:701; RooAbsReal::integralNameSuffixTString integralNameSuffix(const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) constConstruct string with unique suffix name to give to integral object that encodes integrated observabl...Definition RooAbsReal.cxx:755; RooAbsReal::evaluatevirtual double evaluate() const =0Evaluate this PDF / function / constant. Needs to be overridden by all derived classes.; RooAbsReal::getTitleTString getTitle(bool appendUnit=false) constReturn this variable's title string.Definition RooAbsReal.cxx:285; RooAbsReal::logEvalErrorvoid logEvalError(const char *message, const char *serverValueString=nullptr) constLog evaluation error message.Definition RooAbsReal.cxx:3464; RooAbsReal::analyticalIntegralWNvirtual double analyticalIntegralWN(Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:380; RooAbsReal::getUnitconst Text_t * getUnit() constDefinition RooAbsReal.h:143; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAbsReal::isBinnedDistributionvirtual bool isBinnedDistribution(const RooArgSet &) constTests if the distribution is binned. Unless overridden by derived classes, this always returns false.Definition RooAbsReal.h:346; RooAbsReal::printEvalErrorsstatic void printEvalErrors(std::ostream &os=std::cout, Int_t maxPerNode=10000000)Print all outstanding logged evaluation error on the gi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8h_source.html:50073,log,logEvalErrorvoid,50073,doc/master/RooAbsReal_8h_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html,2,['log'],"['logEvalError', 'logEvalErrorvoid']"
Testability,"servables identified by code assigned in getMaxVal.Definition RooAbsReal.cxx:3397; RooAbsReal::findInnerMostIntegrationvoid findInnerMostIntegration(const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) constUtility function for createIntObj() that aids in the construct of recursive integrals over functions ...Definition RooAbsReal.cxx:701; RooAbsReal::integralNameSuffixTString integralNameSuffix(const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) constConstruct string with unique suffix name to give to integral object that encodes integrated observabl...Definition RooAbsReal.cxx:755; RooAbsReal::evaluatevirtual double evaluate() const =0Evaluate this PDF / function / constant. Needs to be overridden by all derived classes.; RooAbsReal::getTitleTString getTitle(bool appendUnit=false) constReturn this variable's title string.Definition RooAbsReal.cxx:285; RooAbsReal::logEvalErrorvoid logEvalError(const char *message, const char *serverValueString=nullptr) constLog evaluation error message.Definition RooAbsReal.cxx:3464; RooAbsReal::analyticalIntegralWNvirtual double analyticalIntegralWN(Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:380; RooAbsReal::getUnitconst Text_t * getUnit() constDefinition RooAbsReal.h:143; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAbsReal::printEvalErrorsstatic void printEvalErrors(std::ostream &os=std::cout, Int_t maxPerNode=10000000)Print all outstanding logged evaluation error on the given ostream.Definition RooAbsReal.cxx:3582; RooAbsReal::createIntRIRooFit::OwningPtr< RooAbsReal > createIntRI(const RooArgSet &iset, const RooArgSet &nset={})Utility function for createRunningIntegral.Definition RooAbsR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:230948,log,logEvalErrorvoid,230948,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,2,['log'],"['logEvalError', 'logEvalErrorvoid']"
Testability,"serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsReal*RooAbsMoment::mean(); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFirstMoment.html:18747,test,testArg,18747,root/html534/RooFirstMoment.html,https://root.cern,https://root.cern/root/html534/RooFirstMoment.html,3,['test'],['testArg']
Testability,"serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsReal*RooAbsMoment::mean(); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooFirstMoment&operator=(const RooFirstMoment&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFirstMoment.html:18437,test,testArg,18437,root/html602/RooFirstMoment.html,https://root.cern,https://root.cern/root/html602/RooFirstMoment.html,2,['test'],['testArg']
Testability,"serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsReal*RooAbsMoment::mean(); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooMoment&operator=(const RooMoment&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMoment.html:18412,test,testArg,18412,root/html602/RooMoment.html,https://root.cern,https://root.cern/root/html602/RooMoment.html,2,['test'],['testArg']
Testability,"serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsReal*RooAbsMoment::mean(); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooSecondMoment&operator=(const RooSecondMoment&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSecondMoment.html:18442,test,testArg,18442,root/html602/RooSecondMoment.html,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html,2,['test'],['testArg']
Testability,"serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tmaxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooCBShape.html:20435,test,testArg,20435,root/html528/RooCBShape.html,https://root.cern,https://root.cern/root/html528/RooCBShape.html,3,['test'],['testArg']
Testability,"serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tmaxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooCBShape.html:20771,test,testArg,20771,root/html530/RooCBShape.html,https://root.cern,https://root.cern/root/html530/RooCBShape.html,5,['test'],['testArg']
Testability,"ses that two histograms; represent identical distributions. To make a decision p-value should; be calculated. The hypotheses of identity is rejected if the p-value is; lower then some significance level. Traditionally significance levels; 0.1, 0.05 and 0.01 are used. The comparison procedure should include an; analysis of the residuals which is often helpful in identifying the; bins of histograms responsible for a significant overall value.; Residuals are the difference between bin contents and expected bin; contents. Most convenient for analysis are the normalized residuals. If; hypotheses of identity are valid then normalized residuals are; approximately independent and identically distributed random variables; having N(0,1) distribution. Analysis of residuals expect test of above; mentioned properties of residuals. Notice that indirectly the analysis; of residuals increase the power of test. Methods of comparison:. test for comparison two (unweighted) histograms:; Let us consider two histograms with the same binning and the number; of bins equal to r. Let us denote the number of events in the ith bin; in the first histogram as ni and as mi in the second one. The total; number of events in the first histogram is equal to:. and. in the second histogram. The hypothesis of identity (homogeneity) [3]; is that the two histograms represent random values with identical; distributions. It is equivalent that there exist r constants p1,...,pr,; such that. and the probability of belonging to the ith bin for some measured value; in both experiments is equal to pi. The number of events in the ith; bin is a random variable with a distribution approximated by a Poisson; probability distribution. for the first histogram and with distribution. for the second histogram. If the hypothesis of homogeneity is valid,; then the maximum likelihood estimator of pi, i=1,...,r, is. and then. has approximately a distribution [3].; The comparison procedure can include an analysis of the residua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:46067,test,test,46067,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,6,['test'],['test']
Testability,"ses the values of those parameters to calculate his function Value.; The order and the position of these parameters is strictly the one specified; by the user when supplying the starting values for minimization. The starting; values must be specified by the user, either via an std::vector<double> or the; MnUserParameters supplied as input to the MINUIT minimizers such as; VariableMetricMinimizer or MnMigrad. Later values are determined by MINUIT; as it searches for the Minimum or performs whatever analysis is requested by; the user. @param par function parameters as defined by the user. @return the Value of the function. @see MnUserParameters; @see VariableMetricMinimizer; @see MnMigrad. double ErrorDef() const. Error definition of the function. MINUIT defines Parameter errors as the; change in Parameter Value required to change the function Value by up. Normally,; for chisquared fits it is 1, and for negative log likelihood, its Value is 0.5.; If the user wants instead the 2-sigma errors for chisquared fits, it becomes 4,; as Chi2(x+n*sigma) = Chi2(x) + n*n. Comment a little bit better with links!!!!!!!!!!!!!!!!!. {return Up();}. double Up() const. Error definition of the function. MINUIT defines Parameter errors as the; change in Parameter Value required to change the function Value by up. Normally,; for chisquared fits it is 1, and for negative log likelihood, its Value is 0.5.; If the user wants instead the 2-sigma errors for chisquared fits, it becomes 4,; as Chi2(x+n*sigma) = Chi2(x) + n*n. \todo Comment a little bit better with links!!!!!!!!!!!!!!!!! Idem for ErrorDef(). void SetErrorDef(double ). add interface to set dynamically a new error definition; Re-implement this function if needed. {}. » Last changed: root/minuit2:$Id: FCNBase.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2009-12-07 13:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Minuit2__FCNBase.html:2553,log,log,2553,root/html526/ROOT__Minuit2__FCNBase.html,https://root.cern,https://root.cern/root/html526/ROOT__Minuit2__FCNBase.html,1,['log'],['log']
Testability,"ses the values of those parameters to calculate his function Value.; The order and the position of these parameters is strictly the one specified; by the user when supplying the starting values for minimization. The starting; values must be specified by the user, either via an std::vector<double> or the; MnUserParameters supplied as input to the MINUIT minimizers such as; VariableMetricMinimizer or MnMigrad. Later values are determined by MINUIT; as it searches for the Minimum or performs whatever analysis is requested by; the user. @param par function parameters as defined by the user. @return the Value of the function. @see MnUserParameters; @see VariableMetricMinimizer; @see MnMigrad. double ErrorDef() const. Error definition of the function. MINUIT defines Parameter errors as the; change in Parameter Value required to change the function Value by up. Normally,; for chisquared fits it is 1, and for negative log likelihood, its Value is 0.5.; If the user wants instead the 2-sigma errors for chisquared fits, it becomes 4,; as Chi2(x+n*sigma) = Chi2(x) + n*n. Comment a little bit better with links!!!!!!!!!!!!!!!!!. {return Up();}. double Up() const. Error definition of the function. MINUIT defines Parameter errors as the; change in Parameter Value required to change the function Value by up. Normally,; for chisquared fits it is 1, and for negative log likelihood, its Value is 0.5.; If the user wants instead the 2-sigma errors for chisquared fits, it becomes 4,; as Chi2(x+n*sigma) = Chi2(x) + n*n. \todo Comment a little bit better with links!!!!!!!!!!!!!!!!! Idem for ErrorDef(). void SetErrorDef(double ). add interface to set dynamically a new error definition; Re-implement this function if needed. {}. » Last changed: root/minuit2:$Id: FCNBase.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2010-09-23 19:57; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Minuit2__FCNBase.html:2553,log,log,2553,root/html528/ROOT__Minuit2__FCNBase.html,https://root.cern,https://root.cern/root/html528/ROOT__Minuit2__FCNBase.html,1,['log'],['log']
Testability,"ses the values of those parameters to calculate his function Value.; The order and the position of these parameters is strictly the one specified; by the user when supplying the starting values for minimization. The starting; values must be specified by the user, either via an std::vector<double> or the; MnUserParameters supplied as input to the MINUIT minimizers such as; VariableMetricMinimizer or MnMigrad. Later values are determined by MINUIT; as it searches for the Minimum or performs whatever analysis is requested by; the user. @param par function parameters as defined by the user. @return the Value of the function. @see MnUserParameters; @see VariableMetricMinimizer; @see MnMigrad. double ErrorDef() const. Error definition of the function. MINUIT defines Parameter errors as the; change in Parameter Value required to change the function Value by up. Normally,; for chisquared fits it is 1, and for negative log likelihood, its Value is 0.5.; If the user wants instead the 2-sigma errors for chisquared fits, it becomes 4,; as Chi2(x+n*sigma) = Chi2(x) + n*n. Comment a little bit better with links!!!!!!!!!!!!!!!!!. {return Up();}. double Up() const. Error definition of the function. MINUIT defines Parameter errors as the; change in Parameter Value required to change the function Value by up. Normally,; for chisquared fits it is 1, and for negative log likelihood, its Value is 0.5.; If the user wants instead the 2-sigma errors for chisquared fits, it becomes 4,; as Chi2(x+n*sigma) = Chi2(x) + n*n. \todo Comment a little bit better with links!!!!!!!!!!!!!!!!! Idem for ErrorDef(). void SetErrorDef(double ). add interface to set dynamically a new error definition; Re-implement this function if needed. {}. » Last changed: root/minuit2:$Id: FCNBase.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Minuit2__FCNBase.html:2555,log,log,2555,root/html530/ROOT__Minuit2__FCNBase.html,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__FCNBase.html,1,['log'],['log']
Testability,"ses the values of those parameters to calculate his function Value.; The order and the position of these parameters is strictly the one specified; by the user when supplying the starting values for minimization. The starting; values must be specified by the user, either via an std::vector<double> or the; MnUserParameters supplied as input to the MINUIT minimizers such as; VariableMetricMinimizer or MnMigrad. Later values are determined by MINUIT; as it searches for the Minimum or performs whatever analysis is requested by; the user. @param par function parameters as defined by the user. @return the Value of the function. @see MnUserParameters; @see VariableMetricMinimizer; @see MnMigrad. double ErrorDef() const. Error definition of the function. MINUIT defines Parameter errors as the; change in Parameter Value required to change the function Value by up. Normally,; for chisquared fits it is 1, and for negative log likelihood, its Value is 0.5.; If the user wants instead the 2-sigma errors for chisquared fits, it becomes 4,; as Chi2(x+n*sigma) = Chi2(x) + n*n. Comment a little bit better with links!!!!!!!!!!!!!!!!!. {return Up();}. double Up() const. Error definition of the function. MINUIT defines Parameter errors as the; change in Parameter Value required to change the function Value by up. Normally,; for chisquared fits it is 1, and for negative log likelihood, its Value is 0.5.; If the user wants instead the 2-sigma errors for chisquared fits, it becomes 4,; as Chi2(x+n*sigma) = Chi2(x) + n*n. \todo Comment a little bit better with links!!!!!!!!!!!!!!!!! Idem for ErrorDef(). void SetErrorDef(double ). add interface to set dynamically a new error definition; Re-implement this function if needed. {}. » Last changed: root/minuit2:$Id: FCNBase.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Minuit2__FCNBase.html:2555,log,log,2555,root/html532/ROOT__Minuit2__FCNBase.html,https://root.cern,https://root.cern/root/html532/ROOT__Minuit2__FCNBase.html,1,['log'],['log']
Testability,"set = (GetLayout() == MemoryLayout::RowMajor) ?; 388 i * ncols + j : j * nrows + i;; 389 ; 390 AFloat * elementPointer = fElementBuffer.data() + offset;; 391 return TCudaDeviceReference<AFloat>(elementPointer);; 392 }; 393 // element access ( for debugging); 394 TCudaDeviceReference<AFloat> operator()(size_t i, size_t j, size_t k) const; 395 {; 396 // k is B, i is C, j is HW :; 397 assert( fNDim >= 3); // || ( k==0 && fNDim == 2 ) );; 398 //note for larger dimension k is all other dims collapsed !!!; 399 ; 400 size_t offset = (GetLayout() == MemoryLayout::RowMajor) ?; 401 i * fStrides[0] + j * fStrides[1] + k :; 402 i * fStrides[2] + k * fStrides[1] + j;; 403 ; 404 AFloat * elementPointer = fElementBuffer.data() + offset;; 405 ; 406 return TCudaDeviceReference<AFloat>(elementPointer);; 407 }; 408 ; 409 TCudaDeviceReference<AFloat> operator()(size_t i, size_t j, size_t k, size_t l) const; 410 {; 411 // for row wise; 412 //assert(GetLayout() == MemoryLayout::RowMajor);; 413 assert( fNDim == 4); // || ( k==0 && fNDim == 2 ) );; 414 ; 415 size_t offset = (GetLayout() == MemoryLayout::RowMajor) ?; 416 i * fStrides[0] + j * fStrides[1] + k * fStrides[2] + l:; 417 l * fStrides[3] + k * fStrides[2] + j * fStrides[1] + i;; 418 ; 419 AFloat * elementPointer = fElementBuffer.data() + offset;; 420 ; 421 return TCudaDeviceReference<AFloat>(elementPointer);; 422 }; 423 ; 424private:; 425 ; 426 /** Initializes all shared devices resource and makes sure that a sufficient; 427 * number of curand states are allocated on the device and initialized as; 428 * well as that the one-vector for the summation over columns has the right; 429 * size. */; 430 void InitializeCuda();; 431 void InitializeCurandStates();; 432 ; 433};; 434 ; 435 ; 436 ; 437 ; 438} // namespace DNN; 439} // namespace TMVA; 440 ; 441#endif; CudaBuffers.h; CudaMatrix.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; dataOption_t Option_t TPoint TPoint co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/CudaTensor_8h_source.html:16061,assert,assert,16061,doc/master/CudaTensor_8h_source.html,https://root.cern,https://root.cern/doc/master/CudaTensor_8h_source.html,2,['assert'],['assert']
Testability,"set; the user need to specify the models in the S+B case and B-only case,; the list of observables of the model(s) (for MC-generation), the list of parameters; that are marginalised and the prior distribution of those parameters. HybridCalculatorOriginal(RooAbsData& data, RooAbsPdf& sb_model, RooAbsPdf& b_model, const RooArgSet* nuisance_parameters = 0, RooAbsPdf* prior_pdf = 0, bool GenerateBinned = false, int testStatistics = 1, int ntoys = 1000); HybridCalculatorOriginal constructor for performing hypotesis test; the user need to specify the data set, the models in the S+B case and B-only case.; In case of treatment of nuisance parameter, the user need to specify the; the list of parameters that are marginalised and the prior distribution of those parameters. HybridCalculatorOriginal(RooAbsData& data, const RooStats::ModelConfig& sb_model, const RooStats::ModelConfig& b_model, bool GenerateBinned = false, int testStatistics = 1, int ntoys = 1000); Constructor with a ModelConfig object representing the signal + background model and; another model config representig the background only model; a Prior pdf for the nuiscane parameter of the signal and background can be specified in; the s+b model or the b model. If it is specified in the s+b model, the one of the s+b model will be used. ~HybridCalculatorOriginal(); HybridCalculatorOriginal destructor. void SetNullModel(const RooStats::ModelConfig& ); Set the model describing the null hypothesis. void SetAlternateModel(const RooStats::ModelConfig& ); Set the model describing the alternate hypothesis. void SetTestStatistic(int index); set the desired test statistics:; index=1 : likelihood ratio: 2 * log( L_sb / L_b ) (DEFAULT); index=2 : number of generated events; index=3 : profiled likelihood ratio; if the index is different to any of those values, the default is used. HybridResult* Calculate(TH1& data, unsigned int nToys, bool usePriors) const; first compute the test statistics for data and then prepare and run the to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__HybridCalculatorOriginal.html:11774,test,testStatistics,11774,root/html528/RooStats__HybridCalculatorOriginal.html,https://root.cern,https://root.cern/root/html528/RooStats__HybridCalculatorOriginal.html,6,['test'],['testStatistics']
Testability,"setPrintLevel(Int_t newLevel); voidsetProfile(Bool_t flag = kTRUE); voidsetStrategy(Int_t strat); virtual voidTObject::SetUniqueID(UInt_t uid); voidsetVerbose(Bool_t flag = kTRUE); virtual voidShowMembers(TMemberInspector& insp) const; Int_tsimplex(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidzeroEvalCount(). protected:. voidapplyCovarianceMatrix(TMatrixDSym& V); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; const RooMinimizerFcn*fitterFcn() const; RooMinimizerFcn*fitterFcn(); Int_tgetNPar() const; ofstream*logfile(); voidTObject::MakeZombie(); Double_t&maxFCN(); voidprofileStart(); voidprofileStop(). private:. RooMinimizer(const RooMinimizer&). Data Members; public:. static RooMinimizer::StrategyBalance; static RooMinimizer::PrintLevelExtraForProblem; static RooMinimizer::PrintLevelMaximum; static RooMinimizer::PrintLevelNone; static RooMinimizer::PrintLevelNormal; static RooMinimizer::PrintLevelReduced; static RooMinimizer::StrategyRobustness; static RooMinimizer::StrategySpeed; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMinimizer.html:7027,log,logfile,7027,root/html602/RooMinimizer.html,https://root.cern,https://root.cern/root/html602/RooMinimizer.html,2,['log'],['logfile']
Testability,"setVal(0.75);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.875);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.95);; lmorph.plotOn(frame1, LineColor(kRed));; ; // S h o w 2 D d i s t r i b u t i o n o f p d f ( x , a l p h a ); // -----------------------------------------------------------------------; ; // Create 2D histogram; TH1 *hh = lmorph.createHistogram(""hh"", x, Binning(40), YVar(alpha, Binning(40)));; hh->SetLineColor(kBlue);; ; // F i t p d f t o d a t a s e t w i t h a l p h a = 0 . 8; // -----------------------------------------------------------------; ; // Generate a toy dataset at alpha = 0.8; alpha = 0.8;; std::unique_ptr<RooDataSet> data{lmorph.generate(x, 1000)};; ; // Fit pdf to toy data; lmorph.setCacheAlpha(true);; lmorph.fitTo(*data, Verbose(true), PrintLevel(-1));; ; // Plot fitted pdf and data overlaid; RooPlot *frame2 = x.frame(Bins(100));; data->plotOn(frame2);; lmorph.plotOn(frame2);; ; // S c a n - l o g ( L ) v s a l p h a; // -----------------------------------------; ; // Show scan -log(L) of dataset w.r.t alpha; RooPlot *frame3 = alpha.frame(Bins(100), Range(0.1, 0.9));; ; // Make 2D pdf of histogram; std::unique_ptr<RooAbsReal> nll{lmorph.createNLL(*data)};; nll->plotOn(frame3, ShiftToZero());; ; lmorph.setCacheAlpha(false);; ; TCanvas *c = new TCanvas(""rf705_linearmorph"", ""rf705_linearmorph"", 800, 800);; c->Divide(2, 2);; c->cd(1);; gPad->SetLeftMargin(0.15);; frame1->GetYaxis()->SetTitleOffset(1.6);; frame1->Draw();; c->cd(2);; gPad->SetLeftMargin(0.20);; hh->GetZaxis()->SetTitleOffset(2.5);; hh->Draw(""surf"");; c->cd(3);; gPad->SetLeftMargin(0.15);; frame3->GetYaxis()->SetTitleOffset(1.4);; frame3->Draw();; c->cd(4);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.4);; frame2->Draw();; ; return;; }; c#define c(i)Definition RSha256.hxx:101; RooDataSet.h; RooGaussian.h; RooIntegralMorph.h; RooPlot.h; RooPolynomial.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf705__linearmorph_8C.html:3125,log,log,3125,doc/master/rf705__linearmorph_8C.html,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8C.html,1,['log'],['log']
Testability,"setup cluster that exposes a Dask scheduler endpoint; 730 client = Client(""dask_scheduler.domain.com:8786""); 731 ; 732 # The Dask RDataFrame constructor accepts the Dask Client object as an optional argument; 733 df = RDataFrame(""mytree"",""myfile.root"", daskclient=client); 734 # Proceed as usual; 735 df.Define(""x"",""someoperation"").Histo1D((""name"", ""title"", 10, 0, 10), ""x""); 736~~~; 737 ; 738If an instance of [distributed.Client](http://distributed.dask.org/en/stable/api.html#distributed.Client) is not; 739provided to the RDataFrame object, it will be created for you and it will run the computations in the local machine; 740using all cores available.; 741 ; 742### Choosing the number of distributed tasks; 743 ; 744A distributed RDataFrame has internal logic to define in how many chunks the input dataset will be split before sending; 745tasks to the distributed backend. Each task reads and processes one of said chunks. The logic is backend-dependent, but; 746generically tries to infer how many cores are available in the cluster through the connection object. The number of; 747tasks will be equal to the inferred number of cores. There are cases where the connection object of the chosen backend; 748doesn't have information about the actual resources of the cluster. An example of this is when using Dask to connect to; 749a batch system. The client object created at the beginning of the application does not automatically know how many cores; 750will be available during distributed execution, since the jobs are submitted to the batch system after the creation of; 751the connection. In such cases, the logic is to default to process the whole dataset in 2 tasks.; 752 ; 753The number of tasks submitted for distributed execution can be also set programmatically, by providing the optional; 754keyword argument `npartitions` when creating the RDataFrame object. This parameter is accepted irrespectively of the; 755backend used:; 756 ; 757~~~{.py}; 758import ROOT; 759 ; 760# Define ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:43020,log,logic,43020,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['log'],['logic']
Testability,"setup cluster that exposes a Dask scheduler endpoint; 770 client = Client(""dask_scheduler.domain.com:8786""); 771 ; 772 # The Dask RDataFrame constructor accepts the Dask Client object as an optional argument; 773 df = RDataFrame(""mytree"",""myfile.root"", daskclient=client); 774 # Proceed as usual; 775 df.Define(""x"",""someoperation"").Histo1D((""name"", ""title"", 10, 0, 10), ""x""); 776~~~; 777 ; 778If an instance of [distributed.Client](http://distributed.dask.org/en/stable/api.html#distributed.Client) is not; 779provided to the RDataFrame object, it will be created for you and it will run the computations in the local machine; 780using all cores available.; 781 ; 782### Choosing the number of distributed tasks; 783 ; 784A distributed RDataFrame has internal logic to define in how many chunks the input dataset will be split before sending; 785tasks to the distributed backend. Each task reads and processes one of said chunks. The logic is backend-dependent, but; 786generically tries to infer how many cores are available in the cluster through the connection object. The number of; 787tasks will be equal to the inferred number of cores. There are cases where the connection object of the chosen backend; 788doesn't have information about the actual resources of the cluster. An example of this is when using Dask to connect to; 789a batch system. The client object created at the beginning of the application does not automatically know how many cores; 790will be available during distributed execution, since the jobs are submitted to the batch system after the creation of; 791the connection. In such cases, the logic is to default to process the whole dataset in 2 tasks.; 792 ; 793The number of tasks submitted for distributed execution can be also set programmatically, by providing the optional; 794keyword argument `npartitions` when creating the RDataFrame object. This parameter is accepted irrespectively of the; 795backend used:; 796 ; 797~~~{.py}; 798import ROOT; 799 ; 800# Define ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:44660,log,logic,44660,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['log'],['logic']
Testability,"setw(12) << ""Conv. Steps"" << Endl;; 1006 std::string separator(62, '-');; 1007 Log() << separator << Endl;; 1008 }; 1009 ; 1010 while (!converged); 1011 {; 1012 stepCount++;; 1013 ; 1014 // Perform minimization steps for a full epoch.; 1015 trainingData.Shuffle();; 1016 for (size_t i = 0; i < batchesInEpoch; i += nThreads) {; 1017 batches.clear();; 1018 for (size_t j = 0; j < nThreads; j++) {; 1019 batches.reserve(nThreads);; 1020 batches.push_back(trainingData.GetBatch());; 1021 }; 1022 if (settings.momentum > 0.0) {; 1023 minimizer.StepMomentum(net, nets, batches, settings.momentum);; 1024 } else {; 1025 minimizer.Step(net, nets, batches);; 1026 }; 1027 }; 1028 ; 1029 if ((stepCount % minimizer.GetTestInterval()) == 0) {; 1030 ; 1031 // Compute test error.; 1032 Double_t testError = 0.0;; 1033 for (auto batch : testData) {; 1034 auto inputMatrix = batch.GetInput();; 1035 auto outputMatrix = batch.GetOutput();; 1036 testError += testNet.Loss(inputMatrix, outputMatrix);; 1037 }; 1038 testError /= (Double_t) (nTestSamples / settings.batchSize);; 1039 ; 1040 //Log the loss value; 1041 fTrainHistory.AddValue(""testError"",stepCount,testError);; 1042 ; 1043 end = std::chrono::system_clock::now();; 1044 ; 1045 // Compute training error.; 1046 Double_t trainingError = 0.0;; 1047 for (auto batch : trainingData) {; 1048 auto inputMatrix = batch.GetInput();; 1049 auto outputMatrix = batch.GetOutput();; 1050 trainingError += net.Loss(inputMatrix, outputMatrix);; 1051 }; 1052 trainingError /= (Double_t) (nTrainingSamples / settings.batchSize);; 1053 //Log the loss value; 1054 fTrainHistory.AddValue(""trainingError"",stepCount,trainingError);; 1055 ; 1056 // Compute numerical throughput.; 1057 std::chrono::duration<double> elapsed_seconds = end - start;; 1058 double seconds = elapsed_seconds.count();; 1059 double nFlops = (double) (settings.testInterval * batchesInEpoch);; 1060 nFlops *= net.GetNFlops() * 1e-9;; 1061 ; 1062 converged = minimizer.HasConverged(testError);; 1063 start",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:37103,test,testError,37103,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['test'],['testError']
Testability,"sfavored); Double_tRooStats::HypoTestResult::fAlternatePValueErrorerror of p-value for the alternate hypothesis (small number means disfavored); Bool_tRooStats::HypoTestResult::fBackgroundIsAlt; TStringTNamed::fNameobject identifier; RooStats::SamplingDistribution*RooStats::HypoTestResult::fNullDistr; Double_tRooStats::HypoTestResult::fNullPValuep-value for the null hypothesis (small number means disfavored); Double_tRooStats::HypoTestResult::fNullPValueErrorerror of p-value for the null hypothesis (small number means disfavored); Bool_tRooStats::HypoTestResult::fPValueIsRightTail; Double_tRooStats::HypoTestResult::fTestStatisticDataresult of the test statistic evaluated on data; TStringTNamed::fTitleobject title. private:. boolfComputationsAltDoneFlagflag if the fAlternatePValue computation have been already done or not (ie need to be refreshed); boolfComputationsNulDoneFlagflag if the fNullPValue computation have been already done or not (ie need to be refreshed); boolfSumLargerValuesp-value for velues of testStat >= testStat_data (or testStat <= testStat_data); vector<double>fTestStat_bvector of results for B-only toy-MC; doublefTestStat_dataresults (test statistics) evaluated for data; vector<double>fTestStat_sbvector of results for S+B toy-MC. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; HybridResult(const char* name = 0); HybridResult default constructor (with name ). HybridResult(const char* name, const vector<double>& testStat_sb_vals, const vector<double>& testStat_b_vals, bool sumLargerValues = true); HybridResult constructor (with name, title and vectors of S+B and B values). ~HybridResult(); HybridResult destructor. void SetDataTestStatistics(double testStat_data_val); set the value of the test statistics on data. double NullPValue() const; return 1-CL_b : the B p-value. double AlternatePValue() const; return CL_s+b : the S+B p-value. Double_t CLbError() const; Returns an estimate of the error on CLb assuming ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__HybridResult.html:9344,test,testStat,9344,root/html530/RooStats__HybridResult.html,https://root.cern,https://root.cern/root/html530/RooStats__HybridResult.html,6,['test'],"['test', 'testStat']"
Testability,"sh_back(TMath::Max( (UInt_t)V[ivar].Length(), minL ));; 952 maxL = TMath::Max( vLengths.back(), maxL );; 953 }; 954 ; 955 // count column length; 956 UInt_t clen = maxL+1;; 957 for (UInt_t icol=0; icol<nvar; icol++) clen += vLengths[icol]+1;; 958 ; 959 // bar line; 960 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 961 logger << Endl;; 962 ; 963 // title bar; 964 logger << setw(maxL+1) << "" "";; 965 for (UInt_t icol=0; icol<nvar; icol++) logger << setw(vLengths[icol]+1) << V[icol];; 966 logger << Endl;; 967 ; 968 // the numbers; 969 for (UInt_t irow=0; irow<nvar; irow++) {; 970 logger << setw(maxL) << V[irow] << "":"";; 971 for (UInt_t icol=0; icol<nvar; icol++) {; 972 logger << setw(vLengths[icol]+1) << TString::Format( ""%+1.3f"", M(irow,icol) );; 973 }; 974 logger << Endl;; 975 }; 976 ; 977 // bar line; 978 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 979 logger << Endl;; 980}; 981 ; 982////////////////////////////////////////////////////////////////////////////////; 983/// formatted output of matrix (with labels); 984 ; 985void TMVA::Tools::FormattedOutput( const TMatrixD& M,; 986 const std::vector<TString>& vert, const std::vector<TString>& horiz,; 987 MsgLogger& logger ); 988{; 989 // sanity check: matrix must be quadratic; 990 UInt_t nvvar = vert.size();; 991 UInt_t nhvar = horiz.size();; 992 ; 993 // get length of each variable, and maximum length; 994 UInt_t minL = 7;; 995 UInt_t maxL = minL;; 996 std::vector<UInt_t> vLengths;; 997 for (UInt_t ivar=0; ivar<nvvar; ivar++) {; 998 vLengths.push_back(TMath::Max( (UInt_t)vert[ivar].Length(), minL ));; 999 maxL = TMath::Max( vLengths.back(), maxL );; 1000 }; 1001 ; 1002 // count column length; 1003 UInt_t minLh = 7;; 1004 UInt_t maxLh = minLh;; 1005 std::vector<UInt_t> hLengths;; 1006 for (UInt_t ivar=0; ivar<nhvar; ivar++) {; 1007 hLengths.push_back(TMath::Max( (UInt_t)horiz[ivar].Length(), minL ));; 1008 maxLh = TMath::Max( hLengths.back(), maxLh );; 1009 }; 1010 ; 1011 UInt_t clen = maxLh+1;; 1012 for (UInt_t icol=0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Tools_8cxx_source.html:33719,log,logger,33719,doc/master/Tools_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html,4,['log'],['logger']
Testability,"shape client RooAbsArgs. TIterator* serverIterator() const; Return iterator over all server RooAbsArgs. RooAbsArg* findServer(const char* name) const; Return server of this arg with given name. Returns null if not found. RooAbsArg* findServer(const RooAbsArg& arg) const; Return server of this arg with name of given input arg. Returns null if not found. RooAbsArg* findServer(Int_t index) const; Return i-th server from server list. Bool_t isValueServer(const RooAbsArg& arg) const; If true, arg is a value server of self. Bool_t isValueServer(const char* name) const; If true, we have a server with given name. Bool_t isShapeServer(const RooAbsArg& arg) const; If true arg is a shape server of self. Bool_t isShapeServer(const char* name) const; If true, we have a shape server with given name. Bool_t isFundamental() const; Is this object a fundamental type that can be added to a dataset?; Fundamental-type subclasses override this method to return kTRUE.; Note that this test is subtlely different from the dynamic isDerived(); test, e.g. a constant is not derived but is also not fundamental. RooAbsArg * createFundamental(const char* newname = 0) const; Create a fundamental-type object that stores our type of value. The; created object will have a valid value, but not necessarily the same; as our value. The caller is responsible for deleting the returned object. Bool_t isLValue() const; Is this argument an l-value, ie, can it appear on the left-hand side; of an assignment expression? LValues are also special since they can; potentially be analytically integrated and generated. RooArgSet* getParameters(const RooAbsData* data, Bool_t stripDisconnected = kTRUE) const. RooArgSet* getParameters(const RooAbsData& data, Bool_t stripDisconnected = kTRUE) const; Return the parameters of this p.d.f when used in conjuction with dataset 'data'. RooArgSet* getObservables(const RooArgSet& set, Bool_t valueOnly = kTRUE) const; Return the observables of _this_ pdf given a set of observables. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsArg.html:37100,test,test,37100,root/html528/RooAbsArg.html,https://root.cern,https://root.cern/root/html528/RooAbsArg.html,4,['test'],['test']
Testability,"shape parameter beta. ;  ; Double_t TMath::Ldexp (Double_t x, Int_t exp);  Returns the result of multiplying x (the significant) by 2 raised to the power of exp (the exponent). ;  ; constexpr Double_t TMath::Ln10 ();  Natural log of 10 (to convert log to ln) ;  ; Double_t TMath::LnGamma (Double_t z);  Computation of ln[gamma(z)] for all z. ;  ; template<typename Iterator > ; Iterator TMath::LocMax (Iterator first, Iterator last);  Returns index of array with the maximum element. ;  ; template<typename T > ; Long64_t TMath::LocMax (Long64_t n, const T *a);  Returns index of array with the maximum element. ;  ; template<typename Iterator > ; Iterator TMath::LocMin (Iterator first, Iterator last);  Returns index of array with the minimum element. ;  ; template<typename T > ; Long64_t TMath::LocMin (Long64_t n, const T *a);  Returns index of array with the minimum element. ;  ; Double_t TMath::Log (Double_t x);  Returns the natural logarithm of x. ;  ; Double_t TMath::Log10 (Double_t x);  Returns the common (base-10) logarithm of x. ;  ; Double_t TMath::Log2 (Double_t x);  Returns the binary (base-2) logarithm of x. ;  ; constexpr Double_t TMath::LogE ();  Base-10 log of e (to convert ln to log) ;  ; Double_t TMath::LogNormal (Double_t x, Double_t sigma, Double_t theta=0, Double_t m=1);  Computes the density of LogNormal distribution at point x. ;  ; template<typename T > ; T TMath::MaxElement (Long64_t n, const T *a);  Returns maximum of array a of length n. ;  ; template<typename Iterator > ; Double_t TMath::Mean (Iterator first, Iterator last);  Returns the weighted mean of an array defined by the iterators. ;  ; template<typename Iterator , typename WeightIterator > ; Double_t TMath::Mean (Iterator first, Iterator last, WeightIterator wfirst);  Returns the weighted mean of an array defined by the first and last iterators. ;  ; template<typename T > ; Double_t TMath::Mean (Long64_t n, const T *a, const Double_t *w=nullptr);  Returns the weighted mean of an array a wit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8h.html:12300,log,logarithm,12300,doc/master/TMath_8h.html,https://root.cern,https://root.cern/doc/master/TMath_8h.html,1,['log'],['logarithm']
Testability,"sher, ""Category_Fisher_2"",""!H:!V:Fisher"" );; ; // Likelihood with categories; TMVA::MethodBase* liCat = factory->BookMethod( dataloader, TMVA::Types::kCategory, ""LikelihoodCat"","""" );; mcat = dynamic_cast<TMVA::MethodCategory*>(liCat);; mcat->AddMethod( ""abs(eta)<=1.3"",theCat1Vars, TMVA::Types::kLikelihood,; ""Category_Likelihood_1"",""!H:!V:TransformOutput:PDFInterpol=Spline2:NSmoothSig[0]=20:NSmoothBkg[0]=20:NSmoothBkg[1]=10:NSmooth=1:NAvEvtPerBin=50"" );; mcat->AddMethod( ""abs(eta)>1.3"", theCat2Vars, TMVA::Types::kLikelihood,; ""Category_Likelihood_2"",""!H:!V:TransformOutput:PDFInterpol=Spline2:NSmoothSig[0]=20:NSmoothBkg[0]=20:NSmoothBkg[1]=10:NSmooth=1:NAvEvtPerBin=50"" );; ; // Now you can tell the factory to train, test, and evaluate the MVAs; ; // Train MVAs using the set of training events; factory->TrainAllMethods();; ; // Evaluate all MVAs using the set of test events; factory->TestAllMethods();; ; // Evaluate and compare performance of all configured MVAs; factory->EvaluateAllMethods();; ; // --------------------------------------------------------------; ; // Save the output; outputFile->Close();; ; std::cout << ""==> Wrote root file: "" << outputFile->GetName() << std::endl;; std::cout << ""==> TMVAClassificationCategory is done!"" << std::endl;; ; // Clean up; delete factory;; delete dataloader;; ; // Launch the GUI for the root macros; if (!gROOT->IsBatch()) TMVA::TMVAGui( outfileName );; }; int main( int argc, char** argv ); {; TMVAClassificationCategory();; return 0;; }; DataLoader.h; MethodCategory.h; mainint main()Definition Prototype.cxx:12; Bool_tbool Bool_tDefinition RtypesCore.h:63; Double_tdouble Double_tDefinition RtypesCore.h:59; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; TChain.h; TFile.h; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void inputDefinition TGWin32VirtualXProxy.cxx:142; TMVAGui.h; TObjString.h; TROOT.h; gROOT#defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassificationCategory_8C.html:32934,test,test,32934,doc/master/TMVAClassificationCategory_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html,2,['test'],['test']
Testability,"should be preferred for performance-critical applications.; 998 ; 999Python applications cannot easily specify template parameters or pass C++ callables to RDataFrame.; 1000See [Efficient analysis in Python](#python) for possible ways to speed up hot paths in this case.; 1001 ; 1002Just-in-time compilation happens once, right before starting an event loop. To reduce the runtime cost of this step, make sure to book all operations *for all RDataFrame computation graphs*; 1003before the first event loop is triggered: just-in-time compilation will happen once for all code required to be generated up to that point, also across different computation graphs.; 1004 ; 1005Also make sure not to count the just-in-time compilation time (which happens once before the event loop and does not depend on the size of the dataset) as part of the event loop runtime (which scales with the size of the dataset). RDataFrame has an experimental logging feature that simplifies measuring the time spent in just-in-time compilation and in the event loop (as well as providing some more interesting information). See [Activating RDataFrame execution logs](\ref rdf-logging).; 1006 ; 1007### Memory usage; 1008 ; 1009There are two reasons why RDataFrame may consume more memory than expected. Firstly, each result is duplicated for each worker thread, which e.g. in case of many (possibly multi-dimensional) histograms with fine binning can result in visible memory consumption during the event loop. The thread-local copies of the results are destroyed when the final result is produced. Reducing the number of threads or using coarser binning will reduce the memory usage.; 1010 ; 1011Secondly, just-in-time compilation of string expressions or non-templated actions (see the previous paragraph) causes Cling, ROOT's C++ interpreter, to allocate some memory for the generated code that is only released at the end of the application. This commonly results in memory usage creep in long-running applications that c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:57694,log,logging,57694,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['log'],['logging']
Testability,"show a graphics line ;  Fibonacci.C A TH2Poly build with Fibonacci numbers ;  fillhistosauto2p.CFill multiple histograms with different functions and automatic binning ;  fillrandom.C Fill a 1-D histogram from a parametric function ;  fillrandom.py Fill a 1-D histogram from a parametric function ;  FirstContour.C Make a contour plot and get the first contour in a TPolyMarker ;  h1draw.C 1-D histogram drawing options ;  h2proj.C;  hbars.C Example of bar charts with 1-d histograms ;  histpalettecolor.C Palette coloring for histogram is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color) ;  hksimple.C Illustrates the advantages of a TH1K histogram ;  hlabels1.C 1-D histograms with alphanumeric labels ;  hlabels2.C 2-D histograms with alphanumeric labels ;  hstack.C Example of stacked histograms: class THStack ;  hsum.C Histograms filled and drawn in a loop ;  hsumTimer.C Demo of Timers ;  logscales.C Draw parametric functions with log scales ;  multicolor.C Use a THStack to show a 2-D hist with cells with different colors ;  ratioplot1.C Example creating a simple ratio plot of two histograms using the pois division option ;  ratioplot1.py Example creating a simple ratio plot of two histograms using the pois division option ;  ratioplot2.C Example of a fit residual plot ;  ratioplot2.py Example of a fit residual plot ;  ratioplot3.C Example which shows how you can get the graph of the lower plot and set the y axis range for it ;  ratioplot3.py Example which shows how you can get the graph of the lower plot and set the y axis range for it ;  ratioplot4.C Example that shows custom dashed lines on the lower plot, specified by a vector of floats ;  ratioplot4.py Example that shows custom dashed lines on the lower plot, specified by a vector of floats ;  ratioplot5.C Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors ;  ratiopl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:123034,log,log,123034,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,1,['log'],['log']
Testability,"sianCalculator is a concrete implementation of IntervalCalculator, providing the computation of a credible interval using a Bayesian method ;  CBernsteinCorrectionBernsteinCorrection is a utility in RooStats to augment a nominal PDF with a polynomial correction term ;  CCombinedCalculatorCombinedCalculator is an interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals ;  CConfidenceBeltConfidenceBelt is a concrete implementation of the ConfInterval interface ;  CConfIntervalConfInterval is an interface class for a generic interval in the RooStats framework ;  CDebuggingSampler;  CDebuggingTestStat;  CDetailedOutputAggregatorThis class is designed to aid in the construction of RooDataSets and RooArgSets, particularly those naturally arising in fitting operations ;  CFeldmanCousins(like the Feldman-Cousins technique) is essentially a specific configuration of the more general NeymanConstruction ;  CFrequentistCalculatorDoes a frequentist hypothesis test ;  CHeavisideRepresents the Heaviside function ;  CHLFactoryHLFactory is an High Level model Factory allows you to describe your models in a configuration file (datacards) acting as an interface with the RooFactoryWSTool ;  CHybridCalculatorSame purpose as HybridCalculatorOriginal, but different implementation ;  CHybridCalculatorOriginalHybridCalculatorOriginal class ;  CHybridPlotThis class provides the plots for the result of a study performed with the HybridCalculatorOriginal class ;  CHybridResultClass encapsulating the result of the HybridCalculatorOriginal ;  CHypoTestCalculatorHypoTestCalculator is an interface class for a tools which produce RooStats HypoTestResults ;  CHypoTestCalculatorGenericCommon base class for the Hypothesis Test Calculators ;  CHypoTestInverterHypoTestInverter class for performing an hypothesis test inversion by scanning the hypothesis test results of an HypoTestCalculator for various values of the parameter of interest ;  CHypoTestInverterOriginalThi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:4533,test,test,4533,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,5,['test'],['test']
Testability,sianCalculator.h. ◆ SetPriorPdf(). virtual void RooStats::BayesianCalculator::SetPriorPdf ; (; RooAbsPdf & ; pdf). inlinevirtual . Set only the Prior Pdf. ; Definition at line 88 of file BayesianCalculator.h. ◆ SetScanOfPosterior(). void RooStats::BayesianCalculator::SetScanOfPosterior ; (; int ; nbin = 100). inline . use directly the approximate posterior function obtained by binning it in nbins by default the cdf is used by integrating the posterior if a value of nbin <= 0 the cdf function will be used ; Definition at line 126 of file BayesianCalculator.h. ◆ SetShortestInterval(). void RooStats::BayesianCalculator::SetShortestInterval ; (; ). inline . set the Bayesian calculator to compute the shortest interval (default is central interval) to switch off SetLeftSideTailFraction to the right value ; Definition at line 118 of file BayesianCalculator.h. ◆ SetTestSize(). void RooStats::BayesianCalculator::SetTestSize ; (; double ; size). inlineoverridevirtual . set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval) ; Implements RooStats::IntervalCalculator.; Definition at line 99 of file BayesianCalculator.h. ◆ Size(). double RooStats::BayesianCalculator::Size ; (; ); const. inlineoverridevirtual . Get the size of the test (eg. rate of Type I error) ; Implements RooStats::IntervalCalculator.; Definition at line 106 of file BayesianCalculator.h. ◆ Streamer(). void RooStats::BayesianCalculator::Streamer ; (; TBuffer & ; ). overridevirtual . Reimplemented from RooStats::IntervalCalculator. ◆ StreamerNVirtual(). void RooStats::BayesianCalculator::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 194 of file BayesianCalculator.h. Member Data Documentation. ◆ fApproxPosterior. TF1* RooStats::BayesianCalculator::fApproxPosterior. mutableprivate . TF1 representing the scanned posterior function. ; Definition at line 179 of file BayesianCalculator.h. ◆ fBrfPrecision. double RooStats::BayesianCalculato,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1BayesianCalculator.html:34793,test,test,34793,doc/master/classRooStats_1_1BayesianCalculator.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1BayesianCalculator.html,1,['test'],['test']
Testability,"sicalShape::EManipTGLPhysicalShape::kScaleAll; static TGLPhysicalShape::EManipTGLPhysicalShape::kScaleX; static TGLPhysicalShape::EManipTGLPhysicalShape::kScaleY; static TGLPhysicalShape::EManipTGLPhysicalShape::kScaleZ; static TGLPhysicalShape::EManipTGLPhysicalShape::kTranslateAll; static TGLPhysicalShape::EManipTGLPhysicalShape::kTranslateX; static TGLPhysicalShape::EManipTGLPhysicalShape::kTranslateY; static TGLPhysicalShape::EManipTGLPhysicalShape::kTranslateZ. protected:. TGLClip::EModefMode; UInt_tfTimeStamp; Bool_tfValid. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLClip(const TGLLogicalShape& logical, const TGLMatrix& transform, const float[4] color); Construct a stand-alone physical clipping object. ~TGLClip(); Destroy clip object. void Setup(const TGLVector3& , const TGLVector3& ); Setup the clipping object with two vectors.; The interpretation of the two is different for plane and box; clipping objects. void Draw(TGLRnrCtx& rnrCtx) const; Draw out clipping object with blending and back + front filling.; Some clip objects are single face which we want to see both sides of. TGLClip(const TGLLogicalShape& logical, const TGLMatrix& transform, const float[4] color). void Modified(); { TGLPhysicalShape::Modified(); IncTimeStamp(); }. void Setup(const TGLBoundingBox& bbox). EMode GetMode() const; { return fMode; }. void SetMode(TGLClip::EMode mode). UInt_t TimeStamp() const; { return fTimeStamp; }. void IncTimeStamp(); { ++fTimeStamp; }. Bool_t IsValid() const; { return fValid; }. void Invalidate(); { fValid = kFALSE; }. void PlaneSet(TGLPlaneSet_t& set) const. TGLClipSet& operator=(const TGLClip& ). » Author: Richard Maunder 16/09/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-02 15:51; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGLClip.html:5101,log,logical,5101,root/html604/TGLClip.html,https://root.cern,https://root.cern/root/html604/TGLClip.html,1,['log'],['logical']
Testability,"sicalShape::EManipTGLPhysicalShape::kScaleAll; static TGLPhysicalShape::EManipTGLPhysicalShape::kScaleX; static TGLPhysicalShape::EManipTGLPhysicalShape::kScaleY; static TGLPhysicalShape::EManipTGLPhysicalShape::kScaleZ; static TGLPhysicalShape::EManipTGLPhysicalShape::kTranslateAll; static TGLPhysicalShape::EManipTGLPhysicalShape::kTranslateX; static TGLPhysicalShape::EManipTGLPhysicalShape::kTranslateY; static TGLPhysicalShape::EManipTGLPhysicalShape::kTranslateZ. protected:. TGLClip::EModefMode; UInt_tfTimeStamp; Bool_tfValid. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLClip(const TGLLogicalShape& logical, const TGLMatrix& transform, const float[4] color); Construct a stand-alone physical clipping object. ~TGLClip(); Destroy clip object. void Setup(const TGLVector3& , const TGLVector3& ); Setup the clipping object with two vectors.; The interpretation of the two is different for plane and box; clipping objects. void Draw(TGLRnrCtx& rnrCtx) const; Draw out clipping object with blending and back + front filling.; Some clip objects are single face which we want to see both sides of. TGLClip(const TGLLogicalShape& logical, const TGLMatrix& transform, const float[4] color). void Modified(); { TGLPhysicalShape::Modified(); IncTimeStamp(); }. void Setup(const TGLBoundingBox& bbox). EMode GetMode() const; { return fMode; }. void SetMode(TGLClip::EMode mode). UInt_t TimeStamp() const; { return fTimeStamp; }. void IncTimeStamp(); { ++fTimeStamp; }. Bool_t IsValid() const; { return fValid; }. void Invalidate(); { fValid = kFALSE; }. void PlaneSet(TGLPlaneSet_t& set) const. TGLClipSet& operator=(const TGLClip& ). » Author: Richard Maunder 16/09/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:52; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLClip.html:5101,log,logical,5101,root/html602/TGLClip.html,https://root.cern,https://root.cern/root/html602/TGLClip.html,1,['log'],['logical']
Testability,"sification with 2 classes. ;  ; virtual TClass * IsA () const;  ; void PrintCuts (Double_t effS) const;  print cuts ;  ; void ProcessOptions ();  process user options. ;  ; virtual void ReadWeightsFromStream (std::istream &)=0;  ; void ReadWeightsFromStream (std::istream &i);  read the cuts from stream ;  ; virtual void ReadWeightsFromStream (TFile &);  ; void ReadWeightsFromXML (void *wghtnode);  read coefficients from xml weight file ;  ; void SetTestSignalEfficiency (Double_t effS);  ; virtual void Streamer (TBuffer &);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void TestClassification ();  nothing to test ;  ; void Train (void);  training method: here the cuts are optimised for the training sample ;  ; void WriteMonitoringHistosToFile (void) const;  write histograms and PDFs to file for monitoring purposes ;  ;  Public Member Functions inherited from TMVA::MethodBase;  MethodBase (const TString &jobName, Types::EMVA methodType, const TString &methodTitle, DataSetInfo &dsi, const TString &theOption="""");  standard constructor ;  ;  MethodBase (Types::EMVA methodType, DataSetInfo &dsi, const TString &weightFile);  constructor used for Testing + Application of the MVA, only (no training), using given WeightFiles ;  ; virtual ~MethodBase ();  destructor ;  ; void AddOutput (Types::ETreeType type, Types::EAnalysisType analysisType);  ; TDirectory * BaseDir () const;  returns the ROOT directory where info/histograms etc of the corresponding MVA method instance are stored ;  ; DataSet * Data () const;  ; DataSetInfo & DataInfo () const;  ; virtual void DeclareCompatibilityOptions ();  options that are used ONLY for the READER to ensure backward compatibility they are hence without any effect (the reader is only reading the training options that HAD been used at the training of the .xml weight file at hand ;  ; void DisableWriting (Bool_t setter);  ; Bool_t DoMulticlass () const;  ; Bool_t DoRegression () const;  ; void ExitFromTraining ();  ; Typ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodCuts.html:5504,test,test,5504,doc/master/classTMVA_1_1MethodCuts.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodCuts.html,1,['test'],['test']
Testability,"sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. Scalar Dot(const OtherLorentzVector & q); ------ Operations combining two Lorentz vectors ------. scalar (Dot) product of two LorentzVector vectors (metric is -,-,-,+); Enable the product using any other LorentzVector implementing; the x(), y() , y() and t() member functions; \param q any LorentzVector implementing the x(), y() , z() and t(); member functions; \return the result of v.q of type according to the base scalar type of v. return operator*(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar& a) const; LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect() const; TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html:18765,log,log,18765,root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html,1,['log'],['log']
Testability,"sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. Scalar Dot(const OtherLorentzVector & q); ------ Operations combining two Lorentz vectors ------. scalar (Dot) product of two LorentzVector vectors (metric is -,-,-,+); Enable the product using any other LorentzVector implementing; the x(), y() , y() and t() member functions; \param q any LorentzVector implementing the x(), y() , z() and t(); member functions; \return the result of v.q of type according to the base scalar type of v. return operator*(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar& a) const; LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect() const; TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html:17159,log,log,17159,root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html,1,['log'],['log']
Testability,"signalFileName, const TString &backgroundFileName, Double_t signalWeight=1.0, Double_t backgroundWeight=1.0)Definition DataLoader.cxx:464; TMVA::DataLoader::~DataLoadervirtual ~DataLoader()Definition DataLoader.cxx:96; TMVA::DataLoader::AddTreevoid AddTree(TTree *tree, const TString &className, Double_t weight=1.0, const TCut &cut="""", Types::ETreeType tt=Types::kMaxTreeType)Definition DataLoader.cxx:351; TMVA::DataLoader::SetInputVariablesvoid SetInputVariables(std::vector< TString > *theVariables)deprecatedDefinition DataLoader.cxx:541; TMVA::DataLoader::SetCutvoid SetCut(const TString &cut, const TString &className="""")Definition DataLoader.cxx:575; TMVA::DataLoader::AddVariablevoid AddVariable(const TString &expression, const TString &title, const TString &unit, char type='F', Double_t min=0, Double_t max=0)user inserts discriminating variable in data set infoDefinition DataLoader.cxx:485; TMVA::DataLoader::PrepareFoldDataSetvoid PrepareFoldDataSet(CvSplit &s, UInt_t foldNumber, Types::ETreeType tt=Types::kTraining)Function for assigning the correct folds to the testing or training set.Definition DataLoader.cxx:670; TMVA::DataSetInfoClass that contains all the data information.Definition DataSetInfo.h:62; TMVA::DataSetManagerClass that contains all the data information.Definition DataSetManager.h:51; TMVA::MsgLogger::SetSourcevoid SetSource(const std::string &source)Definition MsgLogger.h:68; TMVA::Types::kMulticlass@ kMulticlassDefinition Types.h:129; TMVA::Types::kNoAnalysisType@ kNoAnalysisTypeDefinition Types.h:130; TMVA::Types::kRegression@ kRegressionDefinition Types.h:128; TMVA::Types::ETreeTypeETreeTypeDefinition Types.h:142; TMVA::Types::kMaxTreeType@ kMaxTreeTypealso used as temporary storage for trees not yet assigned for testing;training...Definition Types.h:145; TMVA::Types::kTraining@ kTrainingDefinition Types.h:143; TMVA::Types::kTesting@ kTestingDefinition Types.h:144; TMVA::VarTransformHandlerDefinition VarTransformHandler.h:41; TMVA::VarTransformH",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataLoader_8cxx_source.html:38143,test,testing,38143,doc/master/DataLoader_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataLoader_8cxx_source.html,1,['test'],['testing']
Testability,"signed nVertices);; ; private:; enum {; kNPointsDefault = 10000//minimal number of points.; };; ; std::vector<Double_t> fXs;; std::vector<Double_t> fYs;; };; ; //_____________________________________________________________; PolyTest1::PolyTest1(unsigned nVertices); : TNamed(""polygon_compression_test1"", ""polygon_compression_test1""); {; Reset(nVertices);; }; ; //_____________________________________________________________; void PolyTest1::Reset(unsigned nVertices); {; //Some canvas must already exist by this point.; assert(gPad != nullptr && ""Reset, gPad is null"");; //We need a gRandom to exist.; assert(gRandom != nullptr && ""Reset, gRandom is null"");; ; if (nVertices < kNPointsDefault) {; Warning(""Reset"", ""resetting nVertices parameter to %u"", unsigned(kNPointsDefault));; nVertices = kNPointsDefault;; }; ; fXs.resize(nVertices);; fYs.resize(nVertices);; ; Double_t xMin = 0., xMax = 0., yMin = 0., yMax = 0.;; gPad->GetRange(xMin, yMin, xMax, yMax);; assert(xMax - xMin > 0 && yMax - yMin > 0 && ""Reset, invalid canvas' ranges"");; ; const Double_t xCentre = xMin + 0.5 * (xMax - xMin);; const Double_t yCentre = yMin + 0.5 * (yMax - yMin);; ; const Double_t r = TMath::Min(xMax - xMin, yMax - yMin) * 0.8 / 2;; const Double_t angle = TMath::TwoPi() / (nVertices - 1);; ; for (unsigned i = 0; i < nVertices - 1; ++i) {; const Double_t currR = r + gRandom->Rndm() * r * 0.01;; fXs[i] = xCentre + currR * TMath::Cos(angle * i);; fYs[i] = yCentre + currR * TMath::Sin(angle * i);; }; ; fXs[nVertices - 1] = fXs[0];; fYs[nVertices - 1] = fYs[0];; }; ; //_____________________________________________________________; void PolyTest1::Paint(const Option_t * /*notUsed*/); {; assert(gPad != nullptr && ""Paint, gPad is null"");; ; TAttFill::Modify();; gPad->PaintFillArea((Int_t)fXs.size(), &fXs[0], &fYs[0]);; ; TAttLine::Modify();; gPad->PaintPolyLine((Int_t)fXs.size(), &fXs[0], &fYs[0]);; }; ; void polytest1(); {; TCanvas * const cnv = new TCanvas;; cnv->cd();; ; PolyTest1 * polygon = new Po",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/polytest1_8C.html:2296,assert,assert,2296,doc/master/polytest1_8C.html,https://root.cern,https://root.cern/doc/master/polytest1_8C.html,1,['assert'],['assert']
Testability,"significant; 8162/// physical effect (for example the experimental resolution) then the binning; 8163/// cannot have an important effect. Therefore, we believe that for all; 8164/// practical purposes, the probability value PROB is calculated correctly; 8165/// provided the user is aware that:; 8166///; 8167/// 1. The value of PROB should not be expected to have exactly the correct; 8168/// distribution for binned data.; 8169/// 2. The user is responsible for seeing to it that the bin widths are; 8170/// small compared with any physical phenomena of interest.; 8171/// 3. The effect of binning (if any) is always to make the value of PROB; 8172/// slightly too big. That is, setting an acceptance criterion of (PROB>0.05; 8173/// will assure that at most 5% of truly compatible histograms are rejected,; 8174/// and usually somewhat less.""; 8175///; 8176/// Note also that for GoF test of unbinned data ROOT provides also the class; 8177/// ROOT::Math::GoFTest. The class has also method for doing one sample tests; 8178/// (i.e. comparing the data with a given distribution).; 8179 ; 8180Double_t TH1::KolmogorovTest(const TH1 *h2, Option_t *option) const; 8181{; 8182 TString opt = option;; 8183 opt.ToUpper();; 8184 ; 8185 Double_t prob = 0;; 8186 TH1 *h1 = (TH1*)this;; 8187 if (h2 == nullptr) return 0;; 8188 const TAxis *axis1 = h1->GetXaxis();; 8189 const TAxis *axis2 = h2->GetXaxis();; 8190 Int_t ncx1 = axis1->GetNbins();; 8191 Int_t ncx2 = axis2->GetNbins();; 8192 ; 8193 // Check consistency of dimensions; 8194 if (h1->GetDimension() != 1 || h2->GetDimension() != 1) {; 8195 Error(""KolmogorovTest"",""Histograms must be 1-D\n"");; 8196 return 0;; 8197 }; 8198 ; 8199 // Check consistency in number of channels; 8200 if (ncx1 != ncx2) {; 8201 Error(""KolmogorovTest"",""Histograms have different number of bins, %d and %d\n"",ncx1,ncx2);; 8202 return 0;; 8203 }; 8204 ; 8205 // empty the buffer. Probably we could add as an unbinned test; 8206 if (fBuffer) ((TH1*)this)->BufferEmpty();; 82",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:321853,test,tests,321853,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['test'],['tests']
Testability,"sion. void OnApplyParallel(); Apply selected number of workers on current Proof session. void OnMultipleSelection(Bool_t on); Handle multiple selection check button. void OnStartupEnable(Bool_t on); Handle multiple selection check button. void UpdatePackages(); Update list of packages. void OnUploadPackages(); Upload selected package(s) to the current session. void OnEnablePackages(); Enable selected package(s) in the current session. void OnDisablePackages(); Disable selected package(s) in the current session. void OnClearPackages(); Clear (disable) all packages in the current session. void OnBtnAddClicked(); Open file dialog and add selected package file to the list. void OnBtnRemoveClicked(); Remove selected package from the list. void OnBtnUpClicked(); Move selected package entry one position up in the list. void OnBtnDownClicked(); Move selected package entry one position down in the list. void OnBtnDisconnectClicked(); Disconnect from current Proof session. void OnBtnShowLogClicked(); Show session log. void OnBtnNewQueryClicked(); Call ""New Query"" Dialog. void OnBtnGetQueriesClicked(); Get list of queries from current Proof server and populate the list tree. void OnCommandLine(); Command line handling. void SetLocal(Bool_t local = kTRUE); Switch widgets status/visibility for local/remote sessions. void ShutdownSession(); Shutdown current session. Int_t GetLogLevel() const; { return fLogLevel->GetIntNumber(); }. void SetLogLevel(Int_t log); { fLogLevel->SetIntNumber(log); }. TSessionFrame(TGWindow* parent, Int_t w, Int_t h). void CheckAutoEnPack(Bool_t checked = kTRUE). TGTab * GetTab() const; { return fTab; }. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id$ » Last generated: 2015-06-02 16:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT sup",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TSessionFrame.html:23718,log,log,23718,root/html604/TSessionFrame.html,https://root.cern,https://root.cern/root/html604/TSessionFrame.html,1,['log'],['log']
Testability,"sion. void OnApplyParallel(); Apply selected number of workers on current Proof session. void OnMultipleSelection(Bool_t on); Handle multiple selection check button. void OnStartupEnable(Bool_t on); Handle multiple selection check button. void UpdatePackages(); Update list of packages. void OnUploadPackages(); Upload selected package(s) to the current session. void OnEnablePackages(); Enable selected package(s) in the current session. void OnDisablePackages(); Disable selected package(s) in the current session. void OnClearPackages(); Clear (disable) all packages in the current session. void OnBtnAddClicked(); Open file dialog and add selected package file to the list. void OnBtnRemoveClicked(); Remove selected package from the list. void OnBtnUpClicked(); Move selected package entry one position up in the list. void OnBtnDownClicked(); Move selected package entry one position down in the list. void OnBtnDisconnectClicked(); Disconnect from current Proof session. void OnBtnShowLogClicked(); Show session log. void OnBtnNewQueryClicked(); Call ""New Query"" Dialog. void OnBtnGetQueriesClicked(); Get list of queries from current Proof server and populate the list tree. void OnCommandLine(); Command line handling. void SetLocal(Bool_t local = kTRUE); Switch widgets status/visibility for local/remote sessions. void ShutdownSession(); Shutdown current session. Int_t GetLogLevel() const; { return fLogLevel->GetIntNumber(); }. void SetLogLevel(Int_t log); { fLogLevel->SetIntNumber(log); }. TSessionFrame(TGWindow* parent, Int_t w, Int_t h). void CheckAutoEnPack(Bool_t checked = kTRUE). TGTab * GetTab() const; { return fTab; }. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id$ » Last generated: 2015-06-30 15:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT sup",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSessionFrame.html:23718,log,log,23718,root/html602/TSessionFrame.html,https://root.cern,https://root.cern/root/html602/TSessionFrame.html,1,['log'],['log']
Testability,"sion. void OnApplyParallel(); Apply selected number of workers on current Proof session. void OnMultipleSelection(Bool_t on); Handle multiple selection check button. void OnStartupEnable(Bool_t on); Handle multiple selection check button. void UpdatePackages(); Update list of packages. void OnUploadPackages(); Upload selected package(s) to the current session. void OnEnablePackages(); Enable selected package(s) in the current session. void OnDisablePackages(); Disable selected package(s) in the current session. void OnClearPackages(); Clear (disable) all packages in the current session. void OnBtnAddClicked(); Open file dialog and add selected package file to the list. void OnBtnRemoveClicked(); Remove selected package from the list. void OnBtnUpClicked(); Move selected package entry one position up in the list. void OnBtnDownClicked(); Move selected package entry one position down in the list. void OnBtnDisconnectClicked(); Disconnect from current Proof session. void OnBtnShowLogClicked(); Show session log. void OnBtnNewQueryClicked(); Call ""New Query"" Dialog. void OnBtnGetQueriesClicked(); Get list of queries from current Proof server and populate the list tree. void OnCommandLine(); Command line handling. void SetLocal(Bool_t local = kTRUE); Switch widgets status/visibility for local/remote sessions. void ShutdownSession(); Shutdown current session. Int_t GetLogLevel() const; { return fLogLevel->GetIntNumber(); }. void SetLogLevel(Int_t log); { fLogLevel->SetIntNumber(log); }. void CheckAutoEnPack(Bool_t checked = kTRUE). TGTab * GetTab() const; { return fTab; }. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TSessionViewer.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT supp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSessionFrame.html:22641,log,log,22641,root/html528/TSessionFrame.html,https://root.cern,https://root.cern/root/html528/TSessionFrame.html,1,['log'],['log']
Testability,"sion. void OnApplyParallel(); Apply selected number of workers on current Proof session. void OnMultipleSelection(Bool_t on); Handle multiple selection check button. void OnStartupEnable(Bool_t on); Handle multiple selection check button. void UpdatePackages(); Update list of packages. void OnUploadPackages(); Upload selected package(s) to the current session. void OnEnablePackages(); Enable selected package(s) in the current session. void OnDisablePackages(); Disable selected package(s) in the current session. void OnClearPackages(); Clear (disable) all packages in the current session. void OnBtnAddClicked(); Open file dialog and add selected package file to the list. void OnBtnRemoveClicked(); Remove selected package from the list. void OnBtnUpClicked(); Move selected package entry one position up in the list. void OnBtnDownClicked(); Move selected package entry one position down in the list. void OnBtnDisconnectClicked(); Disconnect from current Proof session. void OnBtnShowLogClicked(); Show session log. void OnBtnNewQueryClicked(); Call ""New Query"" Dialog. void OnBtnGetQueriesClicked(); Get list of queries from current Proof server and populate the list tree. void OnCommandLine(); Command line handling. void SetLocal(Bool_t local = kTRUE); Switch widgets status/visibility for local/remote sessions. void ShutdownSession(); Shutdown current session. Int_t GetLogLevel() const; { return fLogLevel->GetIntNumber(); }. void SetLogLevel(Int_t log); { fLogLevel->SetIntNumber(log); }. void CheckAutoEnPack(Bool_t checked = kTRUE). TGTab * GetTab() const; { return fTab; }. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TSessionViewer.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT supp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSessionFrame.html:22741,log,log,22741,root/html530/TSessionFrame.html,https://root.cern,https://root.cern/root/html530/TSessionFrame.html,1,['log'],['log']
Testability,"sion. void OnApplyParallel(); Apply selected number of workers on current Proof session. void OnMultipleSelection(Bool_t on); Handle multiple selection check button. void OnStartupEnable(Bool_t on); Handle multiple selection check button. void UpdatePackages(); Update list of packages. void OnUploadPackages(); Upload selected package(s) to the current session. void OnEnablePackages(); Enable selected package(s) in the current session. void OnDisablePackages(); Disable selected package(s) in the current session. void OnClearPackages(); Clear (disable) all packages in the current session. void OnBtnAddClicked(); Open file dialog and add selected package file to the list. void OnBtnRemoveClicked(); Remove selected package from the list. void OnBtnUpClicked(); Move selected package entry one position up in the list. void OnBtnDownClicked(); Move selected package entry one position down in the list. void OnBtnDisconnectClicked(); Disconnect from current Proof session. void OnBtnShowLogClicked(); Show session log. void OnBtnNewQueryClicked(); Call ""New Query"" Dialog. void OnBtnGetQueriesClicked(); Get list of queries from current Proof server and populate the list tree. void OnCommandLine(); Command line handling. void SetLocal(Bool_t local = kTRUE); Switch widgets status/visibility for local/remote sessions. void ShutdownSession(); Shutdown current session. Int_t GetLogLevel() const; { return fLogLevel->GetIntNumber(); }. void SetLogLevel(Int_t log); { fLogLevel->SetIntNumber(log); }. void CheckAutoEnPack(Bool_t checked = kTRUE). TGTab * GetTab() const; { return fTab; }. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TSessionViewer.h 40088 2011-06-30 15:10:06Z bellenot $ » Last generated: 2011-11-03 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSessionFrame.html:22741,log,log,22741,root/html532/TSessionFrame.html,https://root.cern,https://root.cern/root/html532/TSessionFrame.html,1,['log'],['log']
Testability,sion.cxx;  testIO.cxx;  testKalman.cxx;  testOperations.cxx;  testSMatrix.cxx;  TestTimer.h;  Track.h;  TrackLinkDef.h;  ► splot;  ► inc;  LinkDef.h;  TSPlot.h;  ► src;  TSPlot.cxx;  ► unuran;  ► inc;  LinkDef.h;  TUnuran.h;  TUnuranBaseDist.h;  TUnuranContDist.h;  TUnuranDiscrDist.h;  TUnuranEmpDist.h;  TUnuranMultiContDist.h;  TUnuranSampler.h;  ► src;  TUnuran.cxx;  TUnuranContDist.cxx;  TUnuranDiscrDist.cxx;  TUnuranEmpDist.cxx;  TUnuranMultiContDist.cxx;  TUnuranSampler.cxx;  UnuranDistr.h;  UnuranDistrAdapter.h;  UnuranRng.h;  ► test;  unuranDiscrete.cxx;  unuranDistr.cxx;  unuranHist.cxx;  unuranMulti2D.cxx;  unuranMultiDim.cxx;  unuranSimple.cxx;  ► vc;  ► examples;  ► buddhabrot;  main.cpp;  main.h;  ► finitediff;  main.cpp;  ► fit;  GaussFunction.h;  MinimizerTypes.h;  testFitPerf.cxx;  ► genvector;  vectorOperation.cxx;  ► mandelbrot;  main.cpp;  main.h;  mandel.cpp;  mandel.h;  ► matrix;  main.cpp;  ► polarcoord;  main.cpp;  ► smatrix;  matrix_op_vec.h;  matrix_util.h;  testKalman.cxx;  testOperations.cxx;  TestTimer.h;  tsc.h;  ► include;  ► Vc;  ► avx;  casts.h;  const.h;  const_data.h;  debug.h;  helperimpl.h;  intrinsics.h;  limits.h;  macros.h;  mask.h;  math.h;  shuffle.h;  sorthelper.h;  types.h;  undomacros.h;  vector.h;  vectorhelper.h;  writemaskedvector.h;  ► common;  aliasingentryhelper.h;  bitscanintrinsics.h;  deinterleave.h;  exponential.h;  fix_clang_emmintrin.h;  iif.h;  interleavedmemory.h;  logarithm.h;  macros.h;  memory.h;  memorybase.h;  memoryfwd.h;  operand.h;  operators.h;  storage.h;  support.h;  trigonometric.h;  types.h;  undomacros.h;  vectortuple.h;  windows_fix_intrin.h;  ► internal;  namespace.h;  ► scalar;  helperimpl.h;  limits.h;  macros.h;  mask.h;  math.h;  types.h;  undomacros.h;  vector.h;  writemaskedvector.h;  ► sse;  casts.h;  const.h;  const_data.h;  debug.h;  helperimpl.h;  intrinsics.h;  limits.h;  macros.h;  mask.h;  math.h;  shuffle.h;  types.h;  undomacros.h;  vector.h;  vectorhelper.h;  cpuid.h;  global.h; ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/files.html:58020,test,testKalman,58020,root/html606/files.html,https://root.cern,https://root.cern/root/html606/files.html,1,['test'],['testKalman']
Testability,"sionFrame; }. TSessionQueryFrame * GetQueryFrame() const; { return fQueryFrame; }. TSessionOutputFrame * GetOutputFrame() const; { return fOutputFrame; }. TSessionInputFrame * GetInputFrame() const; { return fInputFrame; }. TSessionDescription * GetActDesc() const; { return fActDesc; }. TList * GetSessions() const; { return fSessions; }. TGListTree * GetSessionHierarchy() const; { return fSessionHierarchy; }. TGListTreeItem * GetSessionItem() const; { return fSessionItem; }. const TGPicture * GetLocalPict() const; { return fLocal; }. const TGPicture * GetProofConPict() const; { return fProofCon; }. const TGPicture * GetProofDisconPict() const; { return fProofDiscon; }. const TGPicture * GetQueryConPict() const; { return fQueryCon; }. const TGPicture * GetQueryDisconPict() const; { return fQueryDiscon; }. const TGPicture * GetBasePict() const; { return fBaseIcon; }. TGPopupMenu * GetPopupSrv() const; { return fPopupSrv; }. TGPopupMenu * GetPopupQry() const; { return fPopupQry; }. TContextMenu * GetContextMenu() const; { return fContextMenu; }. TGStatusBar * GetStatusBar() const; { return fStatusBar; }. TGHProgressBar * GetConnectProg() const; { return fConnectProg; }. TGPopupMenu * GetCascadeMenu() const; { return fCascadeMenu; }. TGPopupMenu * GetOptionsMenu() const; { return fOptionsMenu; }. Bool_t IsBusy() const; { return fBusy; }. Bool_t IsAutoSave() const; { return fAutoSave; }. void SetBusy(Bool_t busy = kTRUE); { fBusy = busy; }. void SetChangePic(Bool_t change); { fChangePic = change;}. void SetLogWindow(TSessionLogView* log); { fLogWindow = log; }. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TSessionViewer.h 40088 2011-06-30 15:10:06Z bellenot $ » Last generated: 2011-11-03 20:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSessionViewer.html:30007,log,log,30007,root/html532/TSessionViewer.html,https://root.cern,https://root.cern/root/html532/TSessionViewer.html,2,['log'],['log']
Testability,"sions(). TList * TSessionViewer::GetSessions ; (; ); const. inline . Definition at line 580 of file TSessionViewer.h. ◆ GetStatusBar(). TGStatusBar * TSessionViewer::GetStatusBar ; (; ); const. inline . Definition at line 592 of file TSessionViewer.h. ◆ HandleTimer(). Bool_t TSessionViewer::HandleTimer ; (; TTimer * ; ). overridevirtual . Handle animation timer. ; Reimplemented from TGWindow.; Definition at line 5011 of file TSessionViewer.cxx. ◆ IsA(). TClass * TSessionViewer::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGMainFrame.; Definition at line 631 of file TSessionViewer.h. ◆ IsAutoSave(). Bool_t TSessionViewer::IsAutoSave ; (; ); const. inline . Definition at line 605 of file TSessionViewer.h. ◆ IsBusy(). Bool_t TSessionViewer::IsBusy ; (; ); const. inline . Definition at line 604 of file TSessionViewer.h. ◆ LogMessage(). void TSessionViewer::LogMessage ; (; const char * ; msg, . Bool_t ; all . ). Load/append a log msg in the log frame. ; Definition at line 5051 of file TSessionViewer.cxx. ◆ MyHandleMenu(). void TSessionViewer::MyHandleMenu ; (; Int_t ; id). Handle session viewer custom popup menus. ; Definition at line 5500 of file TSessionViewer.cxx. ◆ OnCascadeMenu(). void TSessionViewer::OnCascadeMenu ; (; ). Handle feedback histograms configuration menu. ; Definition at line 5564 of file TSessionViewer.cxx. ◆ OnListTreeClicked(). void TSessionViewer::OnListTreeClicked ; (; TGListTreeItem * ; entry, . Int_t ; btn, . Int_t ; x, . Int_t ; y . ). Handle mouse clicks in list tree. ; Definition at line 4635 of file TSessionViewer.cxx. ◆ OnListTreeDoubleClicked(). void TSessionViewer::OnListTreeDoubleClicked ; (; TGListTreeItem * ; entry, . Int_t ; btn . ). Handle mouse double clicks in list tree (connect to server). ; Definition at line 4895 of file TSessionViewer.cxx. ◆ ProcessMessage(). Bool_t TSessionViewer::ProcessMessage ; (; Longptr_t ; msg, . Longptr_t ; parm1, . Longptr_t ;  . ). overridevi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSessionViewer.html:46464,log,log,46464,doc/master/classTSessionViewer.html,https://root.cern,https://root.cern/doc/master/classTSessionViewer.html,2,['log'],['log']
Testability,"sis (small number means disfavored); Double_tfAlternatePValueErrorerror of p-value for the alternate hypothesis (small number means disfavored); Bool_tfBackgroundIsAlt; TStringTNamed::fNameobject identifier; RooStats::SamplingDistribution*fNullDistr; Double_tfNullPValuep-value for the null hypothesis (small number means disfavored); Double_tfNullPValueErrorerror of p-value for the null hypothesis (small number means disfavored); Bool_tfPValueIsRightTail; Double_tfTestStatisticDataresult of the test statistic evaluated on data; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; HypoTestResult(const char* name = 0); Default constructor. HypoTestResult(const char* name, Double_t nullp, Double_t altp); Alternate constructor. ~HypoTestResult(); Destructor. void Append(const RooStats::HypoTestResult* other); Add additional toy-MC experiments to the current results.; Use the data test statistics of the added object if it is not already; set (otherwise, ignore the new one). void SetAltDistribution(RooStats::SamplingDistribution* alt). void SetNullDistribution(RooStats::SamplingDistribution* null). void SetTestStatisticData(const Double_t tsd). void SetPValueIsRightTail(Bool_t pr). Bool_t HasTestStatisticData(void). Double_t NullPValueError() const; compute error on Null pvalue. Double_t CLbError() const; compute CLb error; Clb = 1 - NullPValue(); must use opposite condition that routine above. Double_t CLsplusbError() const. Double_t CLsError() const; Returns an estimate of the error on CLs through combination of the; errors on CLb and CLsplusb:. void UpdatePValue(const RooStats::SamplingDistribution* distr, Double_t& pvalue, Double_t& perror, Bool_t pIsRightTail); updates the pvalue if sufficient data is available. explicit HypoTestResult(const char* name = 0); default constructor. Double_t NullPValue() const; Return p-value for null hypothesis. { return fNullPValue; }. Double_t AlternatePValue() con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__HypoTestResult.html:8265,test,test,8265,root/html530/RooStats__HypoTestResult.html,https://root.cern,https://root.cern/root/html530/RooStats__HypoTestResult.html,2,['test'],['test']
Testability,"sitions ; Double_tfZcurrentcurrent Z position. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoXtru(); dummy ctor. TGeoXtru(Int_t nz); Default constructor. TGeoXtru(Double_t* param); Default constructor in GEANT3 style; param[0] = nz // number of z planes. param[1] = z1 // Z position of first plane; param[2] = x1 // X position of first plane; param[3] = y1 // Y position of first plane; param[4] = scale1 // scale factor for first plane. param[4*(nz-1]+1] = zn; param[4*(nz-1)+2] = xn; param[4*(nz-1)+3] = yn; param[4*(nz-1)+4] = scalen. TGeoXtru(const TGeoXtru& ); copy constructor. TGeoXtru& operator=(const TGeoXtru& ); assignment operator. ~TGeoXtru(); destructor. Double_t Capacity() const; Compute capacity [length^3] of this shape. void ComputeBBox(); compute bounding box of the pcon. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; Check Z range. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistToPlane(Double_t* point, Double_t* dir, Int_t iz, Int_t ivert, Double_t stepmax, Bool_t in) const; Compute distance to a Xtru lateral surface. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the polycone; locate Z segment. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; Warning(""DistFromOutside"", ""not implemented"");. Bool_t DefinePolygon(Int_t nvert, const Double_t* xv, const Double_t* yv); Creates the polygon representing the blueprint of any Xtru section.; nvert = number of vertices >2; xv[nvert] = array of X vertex positions; yv[nvert] = array of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoXtru.html:14866,test,test,14866,root/html528/TGeoXtru.html,https://root.cern,https://root.cern/root/html528/TGeoXtru.html,2,['test'],['test']
Testability,"sixMutex;  CTPosixThread;  CTPosixThreadCleanUp;  CTPosixThreadFactory;  CTPostScriptInterface to PostScript ;  CTPRegexp;  CTPrimaryOld version of a dynamic particle class created by event generators ;  CTPrincipalPrincipal Components Analysis (PCA) ;  CTProcessEventTimer;  CTProcessIDA TProcessID identifies a ROOT job in a unique way in time and space ;  CTProcessUUIDThis class is a specialized TProcessID managing the list of UUIDs ;  CTProfileProfile Histogram ;  CTProfile2DProfile2D histograms are used to display the mean value of Z and its RMS for each cell in X,Y ;  CTProfile2Poly;  CTProfile2PolyBin;  CTProfile3DProfile3D histograms are used to display the mean value of T and its RMS for each cell in X,Y,Z ;  CTProfileHelper;  ►CTProofThis class controls a Parallel ROOT Facility, PROOF, cluster ;  CMD5Mod_t;  CTProofBenchSteering class for PROOF benchmarks ;  CTProofBenchDataSetHandle operations on datasets used by ProofBench ;  CTProofBenchRunAbstract base class for PROOF benchmark runs ;  CTProofBenchRunCPUCPU-intensive PROOF benchmark test generates events and fill 1, 2, or 3-D histograms ;  CTProofBenchRunDataReadI/O-intensive PROOF benchmark test reads in event files distributed on the cluster ;  CTProofChain;  CTProofCondor;  CTProofDebug;  CTProofDesc;  CTProofDrawImplement Tree drawing using PROOF ;  CTProofDrawEntryList;  CTProofDrawEventList;  CTProofDrawGraph;  CTProofDrawHist;  ►CTProofDrawListOfGraphs;  CPoint3D_t;  ►CTProofDrawListOfPolyMarkers3D;  CPoint4D_t;  CTProofDrawPolyMarker3D;  CTProofDrawProfile;  CTProofDrawProfile2D;  CTProofInputHandler;  CTProofInterruptHandler;  CTProofLimitsFinderClass to find axis limits and synchronize them between workers ;  CTProofLiteThis class starts a PROOF session on the local machine: no daemons, client and master merged, communications via UNIX-like sockets ;  CTProofLockPath;  CTProofLockPathGuard;  CTProofLogImplementation of the PROOF session log handler ;  CTProofLogElem;  CTProofMergePrg;  CTProofM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:186432,benchmark,benchmark,186432,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,1,['benchmark'],['benchmark']
Testability,"size() );; 507 ; 508 return fBinEdge[icoord][ipoint];; 509 }; 510 ; 511 /**; 512 return an array containing the upper edge of the bin for coordinate i; 513 In case of empty bin they could be merged in a single larger bin; 514 Return a NULL pointer if the bin width is not stored; 515 */; 516 // not threadsafe, to be replaced with never constructs!; 517 // for example: just return std::array or std::vector, there's; 518 // is going to be only minor overhead in c++11.; 519 const double* BinUpEdge( unsigned int ipoint ) const; 520 {; 521 if ( fBinEdge.empty() || ipoint > fBinEdge.front().size() ); 522 return nullptr;; 523 ; 524 GetBinUpEdgeCoordinates(ipoint, fpTmpBinEdgeVector);; 525 ; 526 return fpTmpBinEdgeVector;; 527 }; 528 ; 529 /**; 530 * Thread save version of function retrieving the bin up-edge in case of multidimensions; 531 */; 532 void GetBinUpEdgeCoordinates(unsigned int ipoint, double * x) const; 533 {; 534 if (fBinEdge.empty() || ipoint > fBinEdge.front().size()) return;; 535 assert(!fBinEdge.empty());; 536 assert(ipoint < fMaxPoints);; 537 for (unsigned int i = 0; i < fDim; i++) {; 538 x[i] = fBinEdge[i][ipoint];; 539 }; 540 }; 541 ; 542 /**; 543 query if the data store the bin edges instead of the center; 544 */; 545 bool HasBinEdges() const {; 546 return fBinEdge.size() == fDim && !fBinEdge[0].empty();; 547 }; 548 ; 549 /**; 550 retrieve the reference volume used to normalize the data when the option bin volume is set; 551 */; 552 double RefVolume() const { return fRefVolume; }; 553 ; 554 /**; 555 set the reference volume used to normalize the data when the option bin volume is set; 556 */; 557 void SetRefVolume(double value) { fRefVolume = value; }; 558 ; 559 /**; 560 retrieve the errortype; 561 */; 562 ErrorType GetErrorType( ) const; 563 {; 564 return fErrorType;; 565 }; 566 ; 567 /**; 568 compute the total sum of the data content; 569 (sum of weights in case of weighted data set); 570 */; 571 double SumOfContent() const { return fSumContent; }; 572",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8h_source.html:19086,assert,assert,19086,doc/master/BinData_8h_source.html,https://root.cern,https://root.cern/doc/master/BinData_8h_source.html,1,['assert'],['assert']
Testability,"size_t _dropRepetitions)set the drop-out configuration (layer-wise)Definition NeuralNet.h:759; TMVA::DNN::Settings::createvoid create(std::string histoName, int bins, double min, double max, int bins2, double min2, double max2)for monitoringDefinition NeuralNet.h:820; TMVA::DNN::Settings::useMultithreadingbool useMultithreading() constis multithreading turned on?Definition NeuralNet.h:815; TMVA::DNN::Settings::regularizationEnumRegularization regularization() constsome regularization of the DNN is turned on?Definition NeuralNet.h:813; TMVA::DNN::Settings::convergenceCountsize_t convergenceCount() constreturns the current convergence countDefinition NeuralNet.h:827; TMVA::DNN::Settings::momentumdouble momentum() constget the momentum (e.g. for SGD)Definition NeuralNet.h:772; TMVA::DNN::Settings::count_Esize_t count_EDefinition NeuralNet.h:842; TMVA::DNN::Settings::m_timerTimer m_timertimer for monitoringDefinition NeuralNet.h:832; TMVA::DNN::Settings::testRepetitionssize_t testRepetitions() consthow often is the test data testedDefinition NeuralNet.h:768; TMVA::DNN::Settings::clearvoid clear(std::string histoName)for monitoringDefinition NeuralNet.h:824; TMVA::DNN::Settings::endTestCyclevirtual void endTestCycle()callback for monitoring and logggingDefinition NeuralNet.h:805; TMVA::DNN::Settings::fMinimizerTypeMinimizerType fMinimizerTypeDefinition NeuralNet.h:855; TMVA::DNN::Settings::addPointvoid addPoint(std::string histoName, double x, double y)for monitoringDefinition NeuralNet.h:822; TMVA::DNN::Settings::setMonitoringvoid setMonitoring(std::shared_ptr< Monitoring > ptrMonitoring)prepared for monitoringDefinition NeuralNet.h:764; TMVA::DNN::Settings::testIterationvirtual void testIteration()callback for monitoring and logggingDefinition NeuralNet.h:806; TMVA::DNN::Settings::m_convergenceStepssize_t m_convergenceStepsnumber of steps without improvement to consider the DNN to have convergedDefinition NeuralNet.h:837; TMVA::DNN::Settings::hasConvergedvirtual bool ha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:72338,test,testRepetitions,72338,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,3,['test'],"['test', 'testRepetitions', 'testedDefinition']"
Testability,"size_t size); Reflex::TypeToType(). protected:. voidEnableCallback(bool enable = true). Data Members; private:. boolfCallbackEnabled; Reflex::Class*fClass; Reflex::MemberfLastMember; boolfNewClass. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ClassBuilderImpl(const char* nam, const type_info& ti, size_t size, unsigned int modifiers = 0, Reflex::TYPE typ = CLASS); constructor . ClassBuilderImpl(Class* cl). virtual ~ClassBuilderImpl(); destructor . void AddBase(const Reflex::Type& bas, Reflex::OffsetFunction offsFP, unsigned int modifiers = 0). * AddBase will add the information about one BaseAt class; * @param Name of the BaseAt class; * @param OffsetFP function pointer for Offset calculation; * @param modifiers the modifiers of the class. void AddFunctionMember(const char* nam, const Reflex::Type& typ, Reflex::StubFunction stubFP, void* stubCtx = 0, const char* params = 0, unsigned int modifiers = 0); AddDataMember will add the information about one data; * MemberAt of the class; *; * @param Name of the data MemberAt; * @param At of the data MemberAt; * @param Offset of the data MemberAt; * @param modifiers the modifiers of the data MemberAt. AddFunctionMember will add the information about one; * function MemberAt of the class; *; * @param Name of the function MemberAt; * @param At of the function MemberAt; * @param stubFP Stub function pointer for the function; * @param stubCxt Stub user context for the stub function; * @param params parameter names and default values (semi-colon separated); * @param modifiers the modifiers of the function MemberAt. void AddEnum(const char* nam, const char* values, const type_info* ti, unsigned int modifiers = 0); This is for anonymous union support.; void addUnion(const char* nam, const char* values, const std::type_info& ti, unsigned int modifiers = 0);; AddProperty will add a PropertyNth to the PropertyNth stack; * which will be emtpied with the next call of a builder; * class and a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/Reflex__ClassBuilderImpl.html:2427,stub,stubFP,2427,root/html526/Reflex__ClassBuilderImpl.html,https://root.cern,https://root.cern/root/html526/Reflex__ClassBuilderImpl.html,10,['stub'],"['stubCtx', 'stubFP']"
Testability,"size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooMinuit&operator=(const RooMinuit&); voidoptimizeConst(Bool_t flag); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); RooFitResult*save(const char* name = 0, const char* title = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); Int_tseek(); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidsetEps(Double_t eps); voidsetErrorLevel(Double_t level); voidsetEvalErrorWall(Bool_t flag); Bool_tsetLogFile(const char* logfile = 0); voidsetNoWarn(); static voidTObject::SetObjectStat(Bool_t stat); voidsetPrintEvalErrors(Int_t numEvalErrors); Int_tsetPrintLevel(Int_t newLevel); voidsetProfile(Bool_t flag = kTRUE); voidsetStrategy(Int_t strat); virtual voidTObject::SetUniqueID(UInt_t uid); voidsetVerbose(Bool_t flag = kTRUE); Int_tsetWarnLevel(Int_t newLevel); virtual voidShowMembers(TMemberInspector& insp); Int_tsimplex(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooMinuit.html:5320,log,logfile,5320,root/html528/RooMinuit.html,https://root.cern,https://root.cern/root/html528/RooMinuit.html,1,['log'],['logfile']
Testability,"sk client needs to be initalized in a context; # Jupyter notebooks / Python session don't need this; if __name__ == ""__main__"":; # With an already setup cluster that exposes a Dask scheduler endpoint; client = Client(""dask_scheduler.domain.com:8786""); ; # The Dask RDataFrame constructor accepts the Dask Client object as an optional argument; df = RDataFrame(""mytree"",""myfile.root"", daskclient=client); # Proceed as usual; df.Define(""x"",""someoperation"").Histo1D((""name"", ""title"", 10, 0, 10), ""x""); If an instance of distributed.Client is not provided to the RDataFrame object, it will be created for you and it will run the computations in the local machine using all cores available. Choosing the number of distributed tasks; A distributed RDataFrame has internal logic to define in how many chunks the input dataset will be split before sending tasks to the distributed backend. Each task reads and processes one of said chunks. The logic is backend-dependent, but generically tries to infer how many cores are available in the cluster through the connection object. The number of tasks will be equal to the inferred number of cores. There are cases where the connection object of the chosen backend doesn't have information about the actual resources of the cluster. An example of this is when using Dask to connect to a batch system. The client object created at the beginning of the application does not automatically know how many cores will be available during distributed execution, since the jobs are submitted to the batch system after the creation of the connection. In such cases, the logic is to default to process the whole dataset in 2 tasks.; The number of tasks submitted for distributed execution can be also set programmatically, by providing the optional keyword argument npartitions when creating the RDataFrame object. This parameter is accepted irrespectively of the backend used:; import ROOT; ; # Define correct imports and access the distributed RDataFrame appropriate for ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:38669,log,logic,38669,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['log'],['logic']
Testability,"slot); TSlave*CreateSlave(const char* url, const char* ord, Int_t perf, const char* image, const char* workdir); TSlave*CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd, Int_t nwk = 1); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TList*GetEnabledPackages() const; static Bool_tGetFileInCmd(const char* cmd, TString& fn); static Int_tGetInputData(TList* input, const char* cachedir, TString& emsg); TList*GetListOfActiveSlaves() const; TVirtualProofPlayer*GetPlayer() const; TPluginHandler*GetProgressDialog() const; Int_tGetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidHandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tHandleOutputOptions(TString& opt, TString& target, Int_t action); Int_tInit(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidInitMembers(); virtual TVirtualProofPlayer*MakePlayer(const char* player = 0, TSocket* s = 0); voidTObject::MakeZombie(); virtual Int_tPollForNewWorkers(); voidPrepareInputDataFile(TString& dataFile); Int_tRemoveWorkers(TList* wrks); static Int_tSaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidSaveWorkerInfo(); Int_tSendFile(const char* file, Int_t opt = (kBinary | kForward | kCp | kCpBin), const char* rfile = 0, TSlave* sl = 0); static Int_tSendInputData(TQueryResult* qr, TProof* p, TString& emsg); virtual voidSendInputDataFile(); voidSetDSet(TDSet* dset); voidSetFeedback(TString& opt, TString& optfb, Int_t action); voidSetPlayer(TVirtualProofPlayer* player); voidSetupWorkersEnv(TList* wrks, Bool_t increasingpool = kFALSE); static void*SlaveStartupThread(void* arg); virtual Bool_tStartSlaves(Bool_t attach = kFALSE); static voidSystemCmd(const char* cmd, Int_t fdout); TProof(); voidUpdateDialog(); virtual voidValidateDSe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProof.html:20480,log,loglevel,20480,root/html604/TProof.html,https://root.cern,https://root.cern/root/html604/TProof.html,1,['log'],['loglevel']
Testability,"so for 2-dim); ""O"" include Overflows (also valid for 2-dim); ""N"" include comparison of normalizations; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob; ""X"" Run the pseudo experiments post-processor with the following procedure:; make pseudoexperiments based on random values from the parent; distribution and compare the KS distance of the pseudoexperiment; to the parent distribution. Bin the KS distances in a histogram,; and then take the integral of all the KS values above the value; obtained from the original data to Monte Carlo distribution.; The number of pseudo-experiments nEXPT is currently fixed at 1000.; The function returns the integral.; (thanks to Ben Kilminster to submit this procedure). Note that; this option ""X"" is much slower. The returned function value is the probability of test; (much less than one means NOT compatible). Code adapted by Rene Brun from original HBOOK routine HDIFF. NOTE1; A good description of the Kolmogorov test can be seen at:; http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm. NOTE2; see also alternative function TH1::Chi2Test; The Kolmogorov test is assumed to give better results than Chi2Test; in case of histograms with low statistics. NOTE3 (Jan Conrad, Fred James); ""The returned value PROB is calculated such that it will be; uniformly distributed between zero and one for compatible histograms,; provided the data are not binned (or the number of bins is very large; compared with the number of events). Users who have access to unbinned; data and wish exact confidence levels should therefore not put their data; into histograms, but should call directly TMath::KolmogorovTest. On; the other hand, since TH1 is a convenient way of collecting data and; saving space, this function has been provided. However, the values of; PROB for binned data will be shifted slightly higher than expected,; depending on the effects of the binning. For example, when comparing two; uniform ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:108518,test,test,108518,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,6,['test'],['test']
Testability,"some monitoring output); 279 *; 280 */; 281 void ClassificationSettings::startTrainCycle () ; 282 {; 283 if (fMonitoring); 284 {; 285 create (""ROC"", 100, 0, 1, 100, 0, 1);; 286 create (""Significance"", 100, 0, 1, 100, 0, 3);; 287 create (""OutputSig"", 100, 0, 1);; 288 create (""OutputBkg"", 100, 0, 1);; 289 fMonitoring->ProcessEvents ();; 290 }; 291 }; 292 ; 293 /** \brief action to be done when the training cycle is ended (e.g. update some monitoring output); 294 *; 295 */; 296 void ClassificationSettings::endTrainCycle (double /*error*/) ; 297 {; 298 if (fMonitoring) fMonitoring->ProcessEvents ();; 299 }; 300 ; 301 /** \brief action to be done after the computation of a test sample (e.g. update some monitoring output); 302 *; 303 */; 304 void ClassificationSettings::testSample (double /*error*/, double output, double target, double weight); 305 {; 306 ; 307 m_output.push_back (output);; 308 m_targets.push_back (target);; 309 m_weights.push_back (weight);; 310 }; 311 ; 312 ; 313 /** \brief action to be done when the test cycle is started (e.g. update some monitoring output); 314 *; 315 */; 316 void ClassificationSettings::startTestCycle () ; 317 {; 318 m_output.clear ();; 319 m_targets.clear ();; 320 m_weights.clear ();; 321 }; 322 ; 323 /** \brief action to be done when the training cycle is ended (e.g. update some monitoring output); 324 *; 325 */; 326 void ClassificationSettings::endTestCycle () ; 327 {; 328 if (m_output.empty ()); 329 return;; 330 double minVal = *std::min_element (begin (m_output), end (m_output));; 331 double maxVal = *std::max_element (begin (m_output), end (m_output));; 332 const size_t numBinsROC = 1000;; 333 const size_t numBinsData = 100;; 334 ; 335 std::vector<double> truePositives (numBinsROC+1, 0);; 336 std::vector<double> falsePositives (numBinsROC+1, 0);; 337 std::vector<double> trueNegatives (numBinsROC+1, 0);; 338 std::vector<double> falseNegatives (numBinsROC+1, 0);; 339 ; 340 std::vector<double> x (numBinsData, 0);; 341 std::vector<d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8cxx_source.html:11967,test,test,11967,doc/master/NeuralNet_8cxx_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8cxx_source.html,1,['test'],['test']
Testability,"son (unweighted-weighted). Note that; the first histogram should be unweighted; o ""WW"" = MC MC comparison (weighted-weighted); o ""NORM"" = to be used when one or both of the histograms is scaled; but the histogram originally was unweighted; o by default underflows and overlows are not included:; * ""OF"" = overflows included; * ""UF"" = underflows included; o ""P"" = print chi2, ndf, p_value, igood; o ""CHI2"" = returns chi2 instead of p-value; o ""CHI2/NDF"" = returns ; - res: not empty - computes normalized residuals and returns them in; this array. The current implementation is based on the papers test for comparison; of weighted and unweighted histograms"" in Proceedings of PHYSTAT05 and; ""Comparison weighted and unweighted histograms"", arXiv:physics/0605123; by N.Gagunashvili. This function has been implemented by Daniel Haertl in August 2006. Introduction:. A frequently used technique in data analysis is the comparison of; histograms. First suggested by Pearson [1] the test of; homogeneity is used widely for comparing usual (unweighted) histograms.; This paper describes the implementation modified tests; for comparison of weighted and unweighted histograms and two weighted; histograms [2] as well as usual Pearson's test for; comparison two usual (unweighted) histograms. Overview:. Comparison of two histograms expect hypotheses that two histograms; represent identical distributions. To make a decision p-value should; be calculated. The hypotheses of identity is rejected if the p-value is; lower then some significance level. Traditionally significance levels; 0.1, 0.05 and 0.01 are used. The comparison procedure should include an; analysis of the residuals which is often helpful in identifying the; bins of histograms responsible for a significant overall value.; Residuals are the difference between bin contents and expected bin; contents. Most convenient for analysis are the normalized residuals. If; hypotheses of identity are valid then normalized residuals are; approximat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:44774,test,test,44774,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,6,['test'],['test']
Testability,"sorFlow workflow. ;  ; file  tmva001_RTensor.C;   This tutorial illustrates the basic features of the RTensor class, RTensor is a std::vector-like container with additional shape information. ;  ; file  tmva002_RDataFrameAsTensor.C;   This tutorial shows how the content of an RDataFrame can be converted to an RTensor object. ;  ; file  tmva003_RReader.C;   This tutorial shows how to apply with the modern interfaces models saved in TMVA XML files. ;  ; file  tmva004_RStandardScaler.C;   This tutorial illustrates the usage of the standard scaler as preprocessing method. ;  ; file  tmva100_DataPreparation.py;   This tutorial illustrates how to prepare ROOT datasets to be nicely readable by most machine learning methods. ;  ; file  tmva101_Training.py;   This tutorial show how you can train a machine learning model with any package reading the training data directly from ROOT files. ;  ; file  tmva102_Testing.py;   This tutorial illustrates how you can test a trained BDT model using the fast tree inference engine offered by TMVA and external tools such as scikit-learn. ;  ; file  tmva103_Application.C;   This tutorial illustrates how you can conveniently apply BDTs in C++ using the fast tree inference engine offered by TMVA. ;  ; file  TMVA_CNN_Classification.C;   TMVA Classification Example Using a Convolutional Neural Network ;  ; file  TMVA_CNN_Classification.py;   TMVA Classification Example Using a Convolutional Neural Network ;  ; file  TMVA_Higgs_Classification.C;   Classification example of TMVA based on public Higgs UCI dataset ;  ; file  TMVA_Higgs_Classification.py;   Classification example of TMVA based on public Higgs UCI dataset ;  ; file  TMVA_RNN_Classification.C;   TMVA Classification Example Using a Recurrent Neural Network ;  ; file  TMVA_RNN_Classification.py;   TMVA Classification Example Using a Recurrent Neural Network ;  ; file  TMVA_SOFIE_Inference.py;   This macro provides an example of using a trained model with Keras and make inference using ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__tmva.html:1865,test,test,1865,doc/master/group__tutorial__tmva.html,https://root.cern,https://root.cern/doc/master/group__tutorial__tmva.html,1,['test'],['test']
Testability,"sorting index and; assumed to be >= n. If work=0, local storage is used, either on; the stack if n < kWorkMax or on the heap for n >= kWorkMax.; Note that the work index array will not contain the sorted indices but; all indeces of the smaller element in arbitrary order in work[0,...,k-1] and; all indeces of the larger element in arbitrary order in work[k+1,..,n-1]; work[k] will contain instead the index of the returned element. Taken from ""Numerical Recipes in C++"" without the index array; implemented by Anna Khreshuk. See also the declarations at the top of this file. Double_t Pi(). Fundamental constants. { return 3.14159265358979323846; }. Double_t TwoPi(); { return 2.0 * Pi(); }. Double_t PiOver2(); { return Pi() / 2.0; }. Double_t PiOver4(); { return Pi() / 4.0; }. Double_t InvPi(); { return 1.0 / Pi(); }. Double_t RadToDeg(); { return 180.0 / Pi(); }. Double_t DegToRad(); { return Pi() / 180.0; }. Double_t Sqrt2(); { return 1.4142135623730950488016887242097; }. Double_t E(); e (base of natural log). { return 2.71828182845904523536; }. Double_t Ln10(); natural log of 10 (to convert log to ln). { return 2.30258509299404568402; }. Double_t LogE(); base-10 log of e (to convert ln to log). { return 0.43429448190325182765; }. Double_t C(); velocity of light. { return 2.99792458e8; }. Double_t Ccgs(); { return 100.0 * C(); }. Double_t CUncertainty(); { return 0.0; }. Double_t G(); gravitational constant. { return 6.673e-11; }. Double_t Gcgs(); { return G() / 1000.0; }. Double_t GUncertainty(); { return 0.010e-11; }. Double_t GhbarC(); G over h-bar C. { return 6.707e-39; }. Double_t GhbarCUncertainty(); { return 0.010e-39; }. Double_t Gn(); standard acceleration of gravity. { return 9.80665; }. Double_t GnUncertainty(); { return 0.0; }. Double_t H(); Planck's constant. { return 6.62606876e-34; }. Double_t Hcgs(); { return 1.0e7 * H(); }. Double_t HUncertainty(); { return 0.00000052e-34; }. Double_t Hbar(); h-bar (h over 2 pi). { return 1.054571596e-34; }. Double_t Hbar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMath.html:45494,log,log,45494,root/html532/TMath.html,https://root.cern,https://root.cern/root/html532/TMath.html,2,['log'],['log']
Testability,"specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxymean; RooRealProxysigma; RooRealProxyx. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooGaussian(const char* name, const char* title, RooAbsReal& _x, RooAbsReal& _mean, RooAbsReal& _sigma). RooGaussian(const RooGaussian& other, const char* name = 0). Double_t evaluate() const. Double_t getLogVal(const RooArgSet* set) const; calculate and return the negative log-likelihood of the Poisson. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const. void generateEvent(Int_t code). RooGaussian(); { }. TObject* clone(const char* newname) const; { return new RooGaussian(*this,newname); }. virtual ~RooGaussian(); { }. » Last changed: Tue Jun 30 14:33:13 2015 » Last generated: 2015-06-30 14:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGaussian.html:44955,log,log-likelihood,44955,root/html602/RooGaussian.html,https://root.cern,https://root.cern/root/html602/RooGaussian.html,1,['log'],['log-likelihood']
Testability,"specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyk; RooRealProxym0; RooRealProxyx. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooLognormal(const char* name, const char* title, RooAbsReal& _x, RooAbsReal& _m0, RooAbsReal& _k). RooLognormal(const RooLognormal& other, const char* name = 0). Double_t evaluate() const; ln(k)<1 would correspond to sigma < 0 in the parametrization; resulting by transforming a normal random variable in its; standard parametrization to a lognormal random variable; => treat ln(k) as -ln(k) for k<1. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const. void generateEvent(Int_t code). RooLognormal(); {}. TObject* clone(const char* newname) const; { return new RooLognormal(*this,newname); }. virtual ~RooLognormal(); { }. » Last changed: Tue Mar 10 17:17:43 2015 » Last generated: 2015-03-10 17:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooLognormal.html:43738,log,lognormal,43738,root/html534/RooLognormal.html,https://root.cern,https://root.cern/root/html534/RooLognormal.html,1,['log'],['lognormal']
Testability,"sqrt{ m_t^2 = E^2 - p{_z}^2} X sign(E^ - p{_z}^2) \f]. { return fCoordinates.Mt(); }. Scalar Et2() const. return the transverse energy squared; \f[ e_t = \frac{E^2 p_{\perp}^2 }{ |p|^2 } \f]. { return fCoordinates.Et2(); }. Scalar Et() const. return the transverse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar& a) const; LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect() const; TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html:15473,log,log,15473,root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html,1,['log'],['log']
Testability,"sqrt{ m_t^2 = E^2 - p{_z}^2} X sign(E^ - p{_z}^2) \f]. { return fCoordinates.Mt(); }. Scalar Et2() const. return the transverse energy squared; \f[ e_t = \frac{E^2 p_{\perp}^2 }{ |p|^2 } \f]. { return fCoordinates.Et2(); }. Scalar Et() const. return the transverse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar& a) const; LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect() const; TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html:15473,log,log,15473,root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html,1,['log'],['log']
Testability,src;  TGondzioSolver.cxx;  TMehrotraSolver.cxx;  TQpDataBase.cxx;  TQpDataDens.cxx;  TQpDataSparse.cxx;  TQpLinSolverBase.cxx;  TQpLinSolverDens.cxx;  TQpLinSolverSparse.cxx;  TQpProbBase.cxx;  TQpProbDens.cxx;  TQpProbSparse.cxx;  TQpResidual.cxx;  TQpSolverBase.cxx;  TQpVar.cxx;  ► rtools;  ► inc;  ► Math;  RMinimizer.h;  ► src;  RMinimizer.cxx;  ► smatrix;  ► inc;  ► Math;  BinaryOperators.h;  BinaryOpPolicy.h;  CholeskyDecomp.hHeader file containing the templated implementation of matrix inversion routines for use with ROOT's SMatrix classes (symmetric positive definite case) ;  CramerInversion.icc;  CramerInversionSym.icc;  Dfact.h;  Dfactir.h;  Dfinv.h;  Dinv.h;  Dsfact.h;  Dsinv.h;  Expression.h;  Functions.h;  HelperOps.h;  MatrixFunctions.h;  MatrixInversion.icc;  MatrixRepresentationsStatic.h;  MConfig.h;  SMatrix.h;  SMatrix.icc;  SMatrixDfwd.h;  SMatrixFfwd.h;  StaticCheck.h;  SVector.h;  SVector.icc;  UnaryOperators.h;  LinkDefAll.h;  LinkDefD32.h;  ► src;  Dict.h;  ► test;  kalman.C;  matrix_op.h;  matrix_util.h;  matrixOperations.C;  stressKalman.cxx;  stressOperations.cxx;  testInversion.cxx;  testIO.cxx;  testKalman.cxx;  testOperations.cxx;  testSMatrix.cxx;  TestTimer.h;  Track.h;  TrackLinkDef.h;  ► splot;  ► inc;  TSPlot.h;  ► src;  TSPlot.cxx;  ► unuran;  ► inc;  TUnuran.h;  TUnuranBaseDist.h;  TUnuranContDist.h;  TUnuranDiscrDist.h;  TUnuranEmpDist.h;  TUnuranMultiContDist.h;  TUnuranSampler.h;  ► src;  TUnuran.cxx;  TUnuranContDist.cxx;  TUnuranDiscrDist.cxx;  TUnuranEmpDist.cxx;  TUnuranMultiContDist.cxx;  TUnuranSampler.cxx;  UnuranDistr.h;  UnuranDistrAdapter.h;  UnuranRng.h;  ► test;  unuranDiscrete.cxx;  unuranDistr.cxx;  unuranHist.cxx;  unuranMulti2D.cxx;  unuranMultiDim.cxx;  unuranSimple.cxx;  ► misc;  ► memstat;  ► inc;  TMemStat.h;  TMemStatBacktrace.h;  TMemStatDef.h;  TMemStatHelpers.h;  TMemStatHook.h;  TMemStatMng.h;  ► src;  TMemStat.cxx;  TMemStatBacktrace.cxx;  TMemStatHelpers.cxx;  TMemStatHook.cxx;  TMemStatMng.cxx;  ► tes,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:55753,test,test,55753,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['test'],['test']
Testability,"ss * IsA () const override;  ; Int_t RegularizeBins (int start, int step, int nbin, ERegMode regmode);  add regularisation conditions for a group of bins ;  ; Int_t RegularizeBins2D (int start_bin, int step1, int nbin1, int step2, int nbin2, ERegMode regmode);  add regularisation conditions for 2d unfolding ;  ; Int_t RegularizeCurvature (int left_bin, int center_bin, int right_bin, Double_t scale_left=1.0, Double_t scale_right=1.0);  add a regularisation condition on the curvature of three truth bin ;  ; Int_t RegularizeDerivative (int left_bin, int right_bin, Double_t scale=1.0);  add a regularisation condition on the difference of two truth bin ;  ; Int_t RegularizeSize (int bin, Double_t scale=1.0);  add a regularisation condition on the magnitude of a truth bin ;  ; virtual Int_t ScanLcurve (Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph **lCurve, TSpline **logTauX=nullptr, TSpline **logTauY=nullptr, TSpline **logTauCurvature=nullptr);  scan the L curve, determine tau and unfold at the final value of tau ;  ; virtual Int_t ScanSURE (Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph **logTauSURE=nullptr, TGraph **df_chi2A=nullptr, TGraph **lCurve=nullptr);  minimize Stein's unbiased risk estimator ""SURE"" using successive calls to DoUnfold at various tau. ;  ; void SetBias (const TH1 *bias);  set bias vector ;  ; void SetConstraint (EConstraint constraint);  set type of area constraint ;  ; void SetEpsMatrix (Double_t eps);  set numerical accuracy for Eigenvalue analysis when inverting matrices with rank problems ;  ; virtual Int_t SetInput (const TH1 *hist_y, Double_t scaleBias=0.0, Double_t oneOverZeroError=0.0, const TH2 *hist_vyy=nullptr, const TH2 *hist_vyy_inv=nullptr);  Define input data for subsequent calls to DoUnfold(tau) ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfold.html:7881,log,logTauX,7881,doc/master/classTUnfold.html,https://root.cern,https://root.cern/doc/master/classTUnfold.html,4,['log'],"['logTauCurvature', 'logTauSURE', 'logTauX', 'logTauY']"
Testability,"ss Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofLite(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); Create a PROOF environment. Starting PROOF involves either connecting; to a master server, which in turn will start a set of slave servers, or; directly starting as master server (if master = """"). Masterurl is of; the form: [proof[s]://]host[:port]. Conffile is the name of the config; file describing the remote PROOF cluster (this argument alows you to; describe different cluster configurations).; The default is proof.conf. Confdir is the directory where the config; file and other PROOF related files are (like motd and noproof files).; Loglevel is the log level (default = 1). User specified custom config; files will be first looked for in $HOME/.conffile. Int_t Init(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); Start the PROOF environment. Starting PROOF involves either connecting; to a master server, which in turn will start a set of slave servers, or; directly starting as master server (if master = """"). For a description; of the arguments see the TProof ctor. Returns the number of started; master or slave servers, returns 0 in case of error, in which case; fValid remains false. ~TProofLite(); Destructor. Int_t GetNumberOfWorkers(const char* url = 0); Static method to determine the number of workers giving priority to users request.; Otherwise use the system information, if available, or just start; the minimal number, i.e. 2 . Int_t SetupWorkers(Int_t opt = 0, TList* wrks = 0); Start up PROOF workers. void NotifyStartUp(const char* action, Int_t done, Int_t tot); Notify setting-up operation message. Int_t SetProofServEnv(const char* ord); Create environment files for worker 'ord'. void ResolveKeywords(TString& s, const char* logfile); Resolve som",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofLite.html:25711,log,loglevel,25711,root/html528/TProofLite.html,https://root.cern,https://root.cern/root/html528/TProofLite.html,3,['log'],['loglevel']
Testability,"ss Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofLite(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); Create a PROOF environment. Starting PROOF involves either connecting; to a master server, which in turn will start a set of slave servers, or; directly starting as master server (if master = """"). Masterurl is of; the form: [proof[s]://]host[:port]. Conffile is the name of the config; file describing the remote PROOF cluster (this argument alows you to; describe different cluster configurations).; The default is proof.conf. Confdir is the directory where the config; file and other PROOF related files are (like motd and noproof files).; Loglevel is the log level (default = 1). User specified custom config; files will be first looked for in $HOME/.conffile. Int_t Init(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); Start the PROOF environment. Starting PROOF involves either connecting; to a master server, which in turn will start a set of slave servers, or; directly starting as master server (if master = """"). For a description; of the arguments see the TProof ctor. Returns the number of started; master or slave servers, returns 0 in case of error, in which case; fValid remains false. ~TProofLite(); Destructor. Int_t GetNumberOfWorkers(const char* url = 0); Static method to determine the number of workers giving priority to users request.; Otherwise use the system information, if available, or just start; the minimal number, i.e. 2 . Int_t SetupWorkers(Int_t opt = 0, TList* wrks = 0); Start up PROOF workers. void NotifyStartUp(const char* action, Int_t done, Int_t tot); Notify setting-up operation message. Int_t SetProofServEnv(const char* ord); Create environment files for worker 'ord'. void ResolveKeywords(TString& s, const char* ord, const char* logf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofLite.html:28735,log,loglevel,28735,root/html534/TProofLite.html,https://root.cern,https://root.cern/root/html534/TProofLite.html,3,['log'],['loglevel']
Testability,"ss Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Private Member Functions |; List of all members ; ROOT::Math::GSLMultiRootBaseSolver Class ReferenceabstractMath » MathCore | Math » MathMore » Numerical Algorithms » Multidimensional ROOT finding. ; GSLMultiRootBaseSolver, internal class for implementing GSL multi-root finders This is the base class for GSLMultiRootSolver (solver not using derivatives) and GSLMUltiRootDerivSolver (solver using derivatives) ; Definition at line 57 of file GSLMultiRootSolver.h. Public Member Functions; virtual ~GSLMultiRootBaseSolver ();  virtual Destructor ;  ; const double * Dx () const;  return function steps ;  ; const double * FVal () const;  return function values ;  ; bool InitSolver (const std::vector< ROOT::Math::IMultiGenFunction * > &funcVec, const double *x);  init the solver with function list and initial values ;  ; virtual int Iterate ()=0;  perform an iteration ;  ; virtual const std::string & Name () const =0;  return name ;  ; int TestDelta (double absTol, double relTol) const;  test using abs and relative tolerance |dx| < absTol + relTol*|x| for every component ;  ; int TestResidual (double absTol) const;  test using abs tolerance Sum |f|_i < absTol ;  ; const double * X () const;  solution values at the current iteration ;  . Private Member Functions; virtual gsl_vector * GetDx () const =0;  ; virtual gsl_vector * GetF () const =0;  ; virtual gsl_vector * GetRoot () const =0;  ; virtual int SetSolver (const std::vector< ROOT::Math::IMultiGenFunction * > &funcVec, const double *x)=0;  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/math/mathmore/src/GSLMultiRootSolver.h>. Inheritance diagram for ROOT::Math::GSLMultiRootBaseSolver:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ ~GSLMultiRootBaseS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLMultiRootBaseSolver.html:1185,test,test,1185,doc/master/classROOT_1_1Math_1_1GSLMultiRootBaseSolver.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLMultiRootBaseSolver.html,2,['test'],['test']
Testability,"ss T > ; std::ostream & operator<< (std::ostream &os, const Translation3D< T > &t);  . Function Documentation. ◆ Eta_FromRhoZ(). template<typename Scalar > . Scalar ROOT::Math::Impl::Eta_FromRhoZ ; (; Scalar ; rho, . Scalar ; z . ). inline . Calculate eta given rho and zeta. ; This formula is faster than the standard calculation (below) from log(tan(theta/2) but one has to be careful when rho is much smaller than z (large eta values) Formula is eta = log( zs + sqrt(zs^2 + 1) ) where zs = z/rho; For large value of z_scaled (tan(theta) ) one can approximate the sqrt via a Taylor expansion We do the approximation of the sqrt if the numerical error is of the same order of second term of the sqrt.expansion: eps > 1/zs^4 => zs > 1/(eps^0.25); When rho == 0 we use etaMax (see definition in etaMax.h) ; Definition at line 48 of file eta.h. ◆ Eta_FromTheta(). template<typename Scalar > . Scalar ROOT::Math::Impl::Eta_FromTheta ; (; Scalar ; theta, . Scalar ; r . ). inline . Implementation of eta from -log(tan(theta/2)). ; This is convenient when theta is already known (for example in a polar coorindate system) ; Definition at line 85 of file eta.h. ◆ operator*() [1/34]. template<class T > . Transform3D< T > ROOT::Math::Impl::operator* ; (; const AxisAngle & ; r, . const Transform3D< T > & ; t . ). inline . Definition at line 1278 of file Transform3D.h. ◆ operator*() [2/34]. template<class T > . Transform3D< T > ROOT::Math::Impl::operator* ; (; const AxisAngle & ; r, . const Translation3D< T > & ; t . ). inline . Definition at line 1100 of file Transform3D.h. ◆ operator*() [3/34]. template<class T > . Transform3D< T > ROOT::Math::Impl::operator* ; (; const EulerAngles & ; r, . const Transform3D< T > & ; t . ). inline . Definition at line 1272 of file Transform3D.h. ◆ operator*() [4/34]. template<class T > . Transform3D< T > ROOT::Math::Impl::operator* ; (; const EulerAngles & ; r, . const Translation3D< T > & ; t . ). inline . Definition at line 1106 of file Transform3D.h. ◆ ope",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Math_1_1Impl.html:6214,log,log,6214,doc/master/namespaceROOT_1_1Math_1_1Impl.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Math_1_1Impl.html,1,['log'],['log']
Testability,"ss and -1 in case of error. Int_t BuildPackage(const char* package, TProof::EBuildPackageOpt opt = kBuildAll, Int_t chkveropt = kCheckROOT, TList* workers = 0); Build specified package. Executes the PROOF-INF/BUILD.sh; script if it exists on all unique nodes. If opt is kBuildOnSlavesNoWait; then submit build command to slaves, but don't wait; for results. If opt is kCollectBuildResults then collect result; from slaves. To be used on the master.; If opt = kBuildAll (default) then submit and wait for results; (to be used on the client).; Returns 0 in case of success and -1 in case of error. Int_t BuildPackageOnClient(const char* package, Int_t opt = 0, TString* path = 0, Int_t chkveropt = kCheckROOT); Build specified package on the client. Executes the PROOF-INF/BUILD.sh; script if it exists on the client.; If opt == 0, both the preparation and building phases are run.; If opt == 1, only the preparation phase (asserting and, eventually, downloading; of the package) is done; '*path' contains the full path to the; package to be passed in the next call; If opt == 2, only the building phase is run using *path .; Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::kBuildPackage; case). Keep in sync in case of changes. Int_t LoadPackage(const char* package, Bool_t notOnClient = kFALSE, TList* loadopts = 0, TList* workers = 0); Load specified package. Executes the PROOF-INF/SETUP.C script; on all active nodes. If notOnClient = true, don't load package; on the client. The default is to load the package also on the client.; The argument 'loadopts' specify a list of objects to be passed to the SETUP.; The objects in the list must be streamable; the SETUP macro will be executed; like this: SETUP.C(loadopts).; Returns 0 in case of success and -1 in case of error. Int_t LoadPackageOnClient(const char* package, TList* loadopts = 0); Load specified package in the client. Executes the PROOF-INF/SETUP.C; script on the clie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProof.html:74736,assert,asserting,74736,root/html604/TProof.html,https://root.cern,https://root.cern/root/html604/TProof.html,1,['assert'],['asserting']
Testability,"ss file creation mode mask.Definition TUnixSystem.cxx:1901; TUnixSystem::UnixFilestatstatic int UnixFilestat(const char *path, FileStat_t &buf)Get info about a file.Definition TUnixSystem.cxx:4039; TUnixSystem::UnixRecvstatic int UnixRecv(int sock, void *buf, int len, int flag)Receive exactly length bytes into buffer.Definition TUnixSystem.cxx:4508; TUnixSystem::GetEffectiveUidInt_t GetEffectiveUid() overrideReturns the effective user id.Definition TUnixSystem.cxx:2021; TUnixSystem::FillWithCwdvoid FillWithCwd(char *cwd) constFill buffer with current working directory.Definition TUnixSystem.cxx:1473; TUnixSystem::UnixWaitchildstatic int UnixWaitchild()Wait till child is finished.Definition TUnixSystem.cxx:4130; TUnixSystem::Unlinkint Unlink(const char *name) overrideUnlink, i.e.Definition TUnixSystem.cxx:1708; TUnixSystem::ListLibrariesvoid ListLibraries(const char *regexp="""") overrideList all loaded shared libraries.Definition TUnixSystem.cxx:2848; TUnixSystem::Closelogvoid Closelog() overrideClose connection to system log daemon.Definition TUnixSystem.cxx:2663; TUnixSystem::RedirectOutputInt_t RedirectOutput(const char *name, const char *mode=""a"", RedirectHandle_t *h=nullptr) overrideRedirect standard output (stdout, stderr) to the specified file.Definition TUnixSystem.cxx:2682; TUnixSystem::Sleepvoid Sleep(UInt_t milliSec) overrideSleep milliSec milliseconds.Definition TUnixSystem.cxx:1184; TUnixSystem::ResetSignalvoid ResetSignal(ESignals sig, Bool_t reset=kTRUE) overrideIf reset is true reset the signal handler for the specified signal to the default handler,...Definition TUnixSystem.cxx:875; TUnixSystem::TempDirectoryconst char * TempDirectory() const overrideReturn a user configured or systemwide directory to create temporary files in.Definition TUnixSystem.cxx:1503; TUnixSystem::DynFindSymbolFunc_t DynFindSymbol(const char *module, const char *entry) overridedynamic linking of moduleDefinition TUnixSystem.cxx:2814; TUnixSystem::GetDynamicPathconst char * GetD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:218448,log,log,218448,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,2,['log'],['log']
Testability,"ss that wraps another p.d.f and caches its output ; RooCatType Category state, (name,index) pair; RooCategory Discrete valued variable type; RooCategoryProxy Proxy for a RooAbsCategory object; RooCategorySharedProperties Shared properties of a RooCategory clone set; RooChangeTracker Meta object that tracks changes in set of other arguments; RooChebychev Chebychev polynomial PDF; RooChi2MCSModule MCStudy module to calculate chi2 between binned data and fit ; RooChi2Var Chi^2 function of p.d.f w.r.t a binned dataset; RooChiSquarePdf Chi Square distribution (eg. the PDF ); RooCintUtils ; RooClassFactory RooFit class code and instance factory ; RooCmdArg Generic named argument container; RooCmdConfig Configurable parse of RooCmdArg objects; RooComplex a non-persistent bare-bones complex class; RooCompositeDataStore Composite Data Storage class; RooConstVar Constant RooAbsReal value object; RooConstraintSum sum of -log of set of RooAbsPdf representing parameter constraints; RooConvCoefVar Auxiliary class representing the coefficient of a RooAbsAnaConvPdf as a RooAbsReal; RooConvGenContext Context for generating a dataset from a PDF; RooConvIntegrandBinding RooAbsFunc representation of convolution integrands; RooCurve 1-dimensional smooth curve for use in RooPlots; RooCustomizer Editing tool for RooAbsArg composite object expressions; RooDLLSignificanceMCSModule MCStudy module to calculate Delta(-logL) significance w.r.t given null hypothesis; RooDataHist Binned data set; RooDataHistSliceIter Iterator over a one-dimensional slice of a RooDataHist; RooDataProjBinding RealFunc/Dataset binding for data projection of a real function; RooDataSet Unbinned data set; RooDataWeightedAverage Optimized calculator of data weighted average of a RooAbsReal; RooDecay General decay function p.d.f ; RooDerivative Representation of derivative of any RooAbsReal; RooDirItem Base class for RooFit objects that are listed TDirectories; RooDouble Container class for Double_t; RooDstD0BG D*-D0 ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ClassIndex.html:31876,log,log,31876,root/html526/ClassIndex.html,https://root.cern,https://root.cern/root/html526/ClassIndex.html,10,['log'],"['log', 'logL']"
Testability,"ss, -1 on error ; Definition at line 2953 of file TProofServ.cxx. ◆ Streamer(). void TProofServ::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TApplication.; Reimplemented in TProofServLite. ◆ StreamerNVirtual(). void TProofServ::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 344 of file TProofServ.h. ◆ Terminate(). void TProofServ::Terminate ; (; Int_t ; status). overridevirtual . Terminate the proof server. ; Reimplemented from TApplication.; Reimplemented in TProofServLite.; Definition at line 3369 of file TProofServ.cxx. ◆ This(). TProofServ * TProofServ::This ; (; ). static . Static function returning pointer to global object gProofServ. ; Mainly for use via CINT, where the gProofServ symbol might be deleted from the symbol table. ; Definition at line 3483 of file TProofServ.cxx. ◆ TruncateLogFile(). void TProofServ::TruncateLogFile ; (; ). Truncate the log file to the 80% of the required max size if this is set. ; Definition at line 6023 of file TProofServ.cxx. ◆ UnlinkDataDir(). Bool_t TProofServ::UnlinkDataDir ; (; const char * ; path). protected . Scan recursively the datadir and unlink it if empty Return kTRUE if it can be unlinked, kFALSE otherwise. ; Definition at line 3437 of file TProofServ.cxx. ◆ UnloadPackage(). Int_t TProofServ::UnloadPackage ; (; const char * ; package). private . ◆ UnloadPackages(). Int_t TProofServ::UnloadPackages ; (; ). private . ◆ UpdateSessionStatus(). Int_t TProofServ::UpdateSessionStatus ; (; Int_t ; xst = -1). Update the session status in the relevant file. ; The status is taken from GetSessionStatus() unless xst >= 0, in which case xst is used. Return 0 on success, -errno if the file could not be opened. ; Definition at line 6799 of file TProofServ.cxx. ◆ WaitingQueries(). Int_t TProofServ::WaitingQueries ; (; ). private . Return the number of waiting queries. ; Definition at line 6846 of file TProofServ.cxx. Friends ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofServ.html:56345,log,log,56345,doc/master/classTProofServ.html,https://root.cern,https://root.cern/doc/master/classTProofServ.html,1,['log'],['log']
Testability,"ss.; TGLHistPainter allows to paint them using the OpenGL 3D graphics; library. The plotting options provided by TGLHistPainter start with; GL keyword.; General information: plot types and supported options; The following types of plots are provided:. Lego - (TGLLegoPainter); The supported options are:; ; ""GLLEGO"" : Draw a lego plot.; ""GLLEGO2"" : Bins with color levels.; ""GLLEGO3"" : Cylindrical bars.; ; Lego painter in cartesian supports logarithmic scales for X, Y, Z.; In polar only Z axis can be logarithmic, in cylindrical only Y (if you see; what it means).; Surfaces (TF2 and TH2 with ""GLSURF"" options) - (TGLSurfacePainter); The supported options are:; ; ""GLSURF"" : Draw a surface.; ""GLSURF1"" : Surface with color levels; ""GLSURF2"" : The same as ""GLSURF1"" but without polygon outlines.; ""GLSURF3"" : Color level projection on top of plot (works only in cartesian coordinate system).; ""GLSURF4"" : Same as ""GLSURF"" but without polygon outlines.; ; The surface painting in cartesian coordinates supports logarithmic scales along X, Y, Z axis.; In polar coordinates only the Z axis can be logarithmic, in cylindrical coordinates only the Y axis.; Additional options to SURF and LEGO - Coordinate systems:; The supported options are:; ; "" "" : Default, cartesian coordinates system.; ""POL"" : Polar coordinates system.; ""CYL"" : Cylindrical coordinates system.; ""SPH"" : Spherical coordinates system.; ; TH3 as boxes (spheres) - (TGLBoxPainter); The supported options are:; ; ""GLBOX"" : TH3 as a set of boxes, size of box is proportional to bin content.; ""GLBOX1"": the same as ""glbox"", but spheres are drawn instead of boxes.; ; TH3 as iso-surface(s) - (TGLIsoPainter); The supported option is:; ; ""GLISO"" : TH3 is drawn using iso-surfaces.; ; TF3 (implicit function) - (TGLTF3Painter); The supported option is:; ; ""GLTF3"" : Draw a TF3.; ; Parametric surfaces - (TGLParametricPlot); $ROOTSYS/tutorials/gl/glparametric.C shows how to create parametric equations and; visualize the surface. Interaction ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLHistPainter.html:1426,log,logarithmic,1426,root/html528/TGLHistPainter.html,https://root.cern,https://root.cern/root/html528/TGLHistPainter.html,1,['log'],['logarithmic']
Testability,"ss.; TGLHistPainter allows to paint them using the OpenGL 3D graphics; library. The plotting options provided by TGLHistPainter start with; GL keyword.; General information: plot types and supported options; The following types of plots are provided:. Lego - (TGLLegoPainter); The supported options are:; ; ""GLLEGO"" : Draw a lego plot.; ""GLLEGO2"" : Bins with color levels.; ""GLLEGO3"" : Cylindrical bars.; ; Lego painter in cartesian supports logarithmic scales for X, Y, Z.; In polar only Z axis can be logarithmic, in cylindrical only Y (if you see; what it means).; Surfaces (TF2 and TH2 with ""GLSURF"" options) - (TGLSurfacePainter); The supported options are:; ; ""GLSURF"" : Draw a surface.; ""GLSURF1"" : Surface with color levels; ""GLSURF2"" : The same as ""GLSURF1"" but without polygon outlines.; ""GLSURF3"" : Color level projection on top of plot (works only in cartesian coordinate system).; ""GLSURF4"" : Same as ""GLSURF"" but without polygon outlines.; ; The surface painting in cartesian coordinates supports logarithmic scales along X, Y, Z axis.; In polar coordinates only the Z axis can be logarithmic, in cylindrical coordinates only the Y axis.; Additional options to SURF and LEGO - Coordinate systems:; The supported options are:; ; "" "" : Default, cartesian coordinates system.; ""POL"" : Polar coordinates system.; ""CYL"" : Cylindrical coordinates system.; ""SPH"" : Spherical coordinates system.; ; TH3 as boxes (spheres) - (TGLBoxPainter); The supported options are:; ; ""GLBOX"" : TH3 as a set of boxes, size of box is proportional to bin content.; ""GLBOX1"": the same as ""glbox"", but spheres are drawn instead of boxes.; ; TH3 as iso-surface(s) - (TGLIsoPainter); The supported option is:; ; ""GLISO"" : TH3 is drawn using iso-surfaces.; ; TH3 as color boxes - (TGLVoxelPainter); The supported option is:; ; ""GLCOL"" : TH3 is drawn using semi-transparent colored boxes.; See $ROOTSYS/tutorials/gl/glvox1.C.; ; TF3 (implicit function) - (TGLTF3Painter); The supported option is:; ; ""GLTF3"" : Draw a ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGLHistPainter.html:1426,log,logarithmic,1426,root/html530/TGLHistPainter.html,https://root.cern,https://root.cern/root/html530/TGLHistPainter.html,5,['log'],['logarithmic']
Testability,"ssIndex!Index of TStreamerInfo classes written to this file; Int_tTFile::fCompressCompression level and algorithm; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; Int_tTFile::fDFile descriptor; TDatimeTDirectoryFile::fDatimeCDate and time when directory is created; TDatimeTDirectoryFile::fDatimeMDate and time of last modification; Long64_tTFile::fENDLast used byte in file; TFile*TDirectoryFile::fFilepointer to current file in memory; TList*TFile::fFreeFree segments linked list table; Bool_tfIdsTableExists! indicate if IdsTable exists; TList*TFile::fInfoCache!Cached list of the streamer infos in this file; Bool_tTFile::fInitDone!True if the file has been initialized; Bool_tTFile::fIsArchive!True if this is a pure archive file; Bool_tTFile::fIsRootFile!True is this is a ROOT file, raw file otherwise; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of objects in memory; ofstream*fLogFile! log file with SQL statements; Bool_tTDirectoryFile::fModifiedtrue if directory has been modified; Int_tfModifyCounter! indicates how many changes was done with database tables; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tTFile::fMustFlush!True if the file buffers must be flushed; Int_tTFile::fNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tTFile::fNbytesFreeNumber of bytes for free segments structure; Int_tTFile::fNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; Bool_tTFile::fNoAnchorInName!True if we don't want to force the anchor to be appended to the file name; Long64_tTFile::fOffset!Seek offset cache; TList*TFile::fOpenPhases!Time info about open phases; TStringTFile::fOptionFile options; const char**fOtherTypes! pointer on list of other SQL types like TEXT or blob; TStrin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSQLFile.html:29301,log,log,29301,root/html530/TSQLFile.html,https://root.cern,https://root.cern/root/html530/TSQLFile.html,3,['log'],['log']
Testability,"ssValidation_Fisher_fold2.class.C; <HEADER> Factory : Test all methods; <HEADER> Factory : Test method: Fisher_fold2 for Classification performance; : ; <HEADER> Fisher_fold2 : [datasetcv] : Evaluation of Fisher_fold2 on testing sample (1000 events); : Elapsed time for evaluation of 1000 events: 8.2e-05 sec ; <HEADER> Factory : Evaluate all methods; <HEADER> Factory : Evaluate classifier: Fisher_fold2; : ; <HEADER> Fisher_fold2 : [datasetcv] : Loop over test events and fill histograms with classifier response...; : ; : ; : Evaluation results ranked by best signal efficiency and purity (area); : -------------------------------------------------------------------------------------------------------------------; : DataSet MVA ; : Name: Method: ROC-integ; : datasetcv Fisher_fold2 : 0.966; : -------------------------------------------------------------------------------------------------------------------; : ; : Testing efficiency compared to training efficiency (overtraining check); : -------------------------------------------------------------------------------------------------------------------; : DataSet MVA Signal efficiency: from test sample (from training sample) ; : Name: Method: @B=0.01 @B=0.10 @B=0.30 ; : -------------------------------------------------------------------------------------------------------------------; : datasetcv Fisher_fold2 : 0.655 (0.645) 0.900 (0.928) 0.975 (0.977); : -------------------------------------------------------------------------------------------------------------------; : ; <HEADER> Factory : Thank you for using TMVA!; : For citation information, please visit: http://tmva.sf.net/citeTMVA.html; <HEADER> Factory : Booking method: Fisher; : ; : Reading weightfile: datasetcv/weights/TMVACrossValidation_Fisher_fold1.weights.xml; : Reading weight file: datasetcv/weights/TMVACrossValidation_Fisher_fold1.weights.xml; : Reading weightfile: datasetcv/weights/TMVACrossValidation_Fisher_fold2.weights.xml; : Reading weight file: dataset",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidation_8C.html:12630,test,test,12630,doc/master/TMVACrossValidation_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidation_8C.html,1,['test'],['test']
Testability,"ss_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; void GetHelpMessage () const;  ; virtual std::vector< Double_t > GetMvaValues (Long64_t firstEvt, Long64_t lastEvt, Bool_t logProgress);  Evaluate the DeepNet on a vector of input values stored in the TMVA Event class Here we will evaluate using a default batch size and the same architecture used for Training. ;  ;  Protected Member Functions inherited from TMVA::MethodBase; virtual std::vector< Double_t > GetDataMvaValues (DataSet *data=nullptr, Long64_t firstEvt=0, Long64_t lastEvt=-1, Bool_t logProgress=false);  get all the MVA values for the events of the given Data type ;  ; const TString & GetInternalVarName (Int_t ivar) const;  ; const TString & GetOriginalVarName (Int_t ivar) const;  ; const TString & GetWeightFileDir () const;  ; Bool_t HasTrainingTree () const;  ; Bool_t Help () const;  ; Bool_t IgnoreEventsWithNegWeightsInTraining () const;  ; Bool_t IsConstructedFromWeightFile () const;  ; Bool_t IsNormalised () const;  ; virtual void MakeClassSpecific (std::ostream &, const TString &="""") const;  ; virtual void MakeClassSpecificHeader (std::ostream &, const TString &="""") const;  ; void NoErrorCalc (Double_t *con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodDL.html:25252,log,logProgress,25252,doc/master/classTMVA_1_1MethodDL.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodDL.html,1,['log'],['logProgress']
Testability,"ss_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TEfficiency::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 193 of file TEfficiency.h. ◆ ClopperPearson(). Double_t TEfficiency::ClopperPearson ; (; Double_t ; total, . Double_t ; passed, . Double_t ; level, . Bool_t ; bUpper . ). static . Calculates the boundaries for the frequentist Clopper-Pearson interval. ; This interval is recommended by the PDG.; Parameters. [in]totalnumber of total events ; [in]passed0 <= number of passed events <= total ; [in]levelconfidence level ; [in]bUppertrue - upper boundary is returned ;false - lower boundary is returned. Calculation:; The lower boundary of the Clopper-Pearson interval is the ""exact"" inversion of the test: ; \begin{eqnarray*}; P(x \geq passed; total) &=& \frac{1 - level}{2}\\; P(x \geq passed; total) &=& 1 - P(x \leq passed - 1; total)\\; &=& 1 - \frac{1}{norm} * \int_{0}^{1 - \varepsilon} t^{total - passed} (1 - t)^{passed - 1} dt\\; &=& 1 - \frac{1}{norm} * \int_{\varepsilon}^{1} t^{passed - 1} (1 - t)^{total - passed} dt\\; &=& \frac{1}{norm} * \int_{0}^{\varepsilon} t^{passed - 1} (1 - t)^{total - passed} dt\\; &=& I_{\varepsilon}(passed,total - passed + 1); \end{eqnarray*}. The lower boundary is therefore given by the \( \frac{1 - level}{2}\) quantile of the beta distribution.; The upper boundary of the Clopper-Pearson interval is the ""exact"" inversion of the test: ; \begin{eqnarray*}; P(x \leq passed; total) &=& \frac{1 - level}{2}\\; P(x \leq passed; total) &=& \frac{1}{norm} * \int_{0}^{1 - \varepsilon} t^{total - passed - 1} (1 - t)^{passed} dt\\; &=& \frac{1}{norm} * \int_{\varepsilon}^{1} t^{passed} (1 - t)^{total - passed - 1} dt\\; &=& 1 - \frac{1}{norm} * \int_{0}^{\varepsilon} t^{passed} (1 - t)^{total - passed - 1} dt\\; \Rightarrow 1 - \frac{1 - level}{2} &=& \frac{1}{norm} * \int_{0}^{\varepsilon} t^{passed} (1 - t)^{total - passed -1} dt\\; \frac{1 + lev",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEfficiency.html:78255,test,test,78255,doc/master/classTEfficiency.html,https://root.cern,https://root.cern/doc/master/classTEfficiency.html,1,['test'],['test']
Testability,"ss_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TMVA::PDEFoamDensityBase; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; UInt_t fClass;  ;  Protected Attributes inherited from TMVA::PDEFoamDensityBase; BinarySearchTree * fBst;  Binary tree to find events within a volume. ;  ; MsgLogger * fLogger;  ! message logger ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TMVA::PDEFoamDensityBase; Double_t GetBoxVolume ();  Returns the volume of range searching box fBox. ;  ; MsgLogger & Log () const;  ;  Protected Member Functions inherited fro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1PDEFoamDecisionTreeDensity.html:10728,log,logger,10728,doc/master/classTMVA_1_1PDEFoamDecisionTreeDensity.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1PDEFoamDecisionTreeDensity.html,2,['log'],['logger']
Testability,"ss_Version(). static constexpr Version_t TProofPlayerLocal::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 258 of file TProofPlayer.h. ◆ DeclFileName(). static const char * TProofPlayerLocal::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 258 of file TProofPlayer.h. ◆ IsA(). TClass * TProofPlayerLocal::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TProofPlayer.; Definition at line 258 of file TProofPlayer.h. ◆ IsClient(). Bool_t TProofPlayerLocal::IsClient ; (; ); const. inlineoverridevirtual . Reimplemented from TProofPlayer.; Definition at line 247 of file TProofPlayer.h. ◆ Process() [1/4]. Long64_t TProofPlayerLocal::Process ; (; const char * ; selector, . Long64_t ; nentries = -1, . Option_t * ; option = """" . ). Process the specified TSelector file 'nentries' times. ; Used to test the PROOF interator mechanism for cycle-driven selectors in a local session. Process specified TDSet on PROOF worker with TSelector object The return value is -1 in case of error and TSelector::GetStatus() in case of success. ; Definition at line 1878 of file TProofPlayer.cxx. ◆ Process() [2/4]. Long64_t TProofPlayerLocal::Process ; (; TDSet * ; dset, . const char * ; selector_file, . Option_t * ; option = """", . Long64_t ; nentries = -1, . Long64_t ; first = 0 . ). inlineoverridevirtual . Process specified TDSet on PROOF worker. ; The return value is -1 in case of error and TSelector::GetStatus() in case of success. ; Reimplemented from TProofPlayer.; Definition at line 250 of file TProofPlayer.h. ◆ Process() [3/4]. Long64_t TProofPlayerLocal::Process ; (; TDSet * ; set, . TSelector * ; selector, . Option_t * ; option = """", . Long64_t ; nentries = -1, . Long64_t ; firstentry = 0 . ). inlineoverridevirtual . Process specified TDSet on PROOF worker with TSelector object The return value is -1 in case of error and TSe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerLocal.html:25774,test,test,25774,doc/master/classTProofPlayerLocal.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerLocal.html,1,['test'],['test']
Testability,"ssert( !fDataErrorPtr && !fDataErrorHighPtr && !fDataErrorLowPtr );; 334 assert( fDataError.empty() && fDataErrorHigh.empty() && fDataErrorLow.empty() );; 335 return 1.0;; 336 }; 337 ; 338 if ( fErrorType == kValueError ) // need to invert (inverror is stored); 339 {; 340 assert( fDataErrorPtr && !fDataErrorHighPtr && !fDataErrorLowPtr );; 341 assert( fDataErrorHigh.empty() && fDataErrorLow.empty() );; 342 assert( fDataError.empty() || &fDataError.front() == fDataErrorPtr );; 343 ; 344 double eval = fDataErrorPtr[ ipoint ];; 345 ; 346 // in case of wrapped data the pointer stores the error and; 347 // not the inverse; 348 if (fWrapped); 349 return 1.0 / eval;; 350 else; 351 return (eval != 0.0) ? eval : 0.0;; 352 }; 353 ; 354 if ( fErrorType == kAsymError ) {; 355 // return inverse of 1/2(el + eh); 356 assert( !fDataErrorPtr && fDataErrorHighPtr && fDataErrorLowPtr );; 357 assert( fDataError.empty() );; 358 assert( fDataErrorHigh.empty() || &fDataErrorHigh.front() == fDataErrorHighPtr );; 359 assert( fDataErrorLow.empty() || &fDataErrorLow.front() == fDataErrorLowPtr );; 360 assert( fDataErrorLow.empty() == fDataErrorHigh.empty() );; 361 ; 362 double eh = fDataErrorHighPtr[ ipoint ];; 363 double el = fDataErrorLowPtr[ ipoint ];; 364 ; 365 return 2.0 / (el+eh);; 366 }; 367 ; 368 assert( fErrorType == kCoordError );; 369 // for coordinate error we store the error and not the inverse; 370 return 1.0 / fDataErrorPtr[ ipoint ];; 371 }; 372 ; 373 ; 374 /**; 375 retrieve at the same time a pointer to the coordinate data and the fit value; 376 More efficient than calling Coords(i) and Value(i); 377 */; 378 // not threadsafe, to be replaced with never constructs!; 379 // for example: just return std::array or std::vector, there's; 380 // is going to be only minor overhead in c++11.; 381 const double * GetPoint( unsigned int ipoint, double & value ) const; 382 {; 383 assert( ipoint < fMaxPoints );; 384 value = Value( ipoint );; 385 ; 386 return Coords( ipoint );; 387 }; 388 ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8h_source.html:12608,assert,assert,12608,doc/master/BinData_8h_source.html,https://root.cern,https://root.cern/doc/master/BinData_8h_source.html,1,['assert'],['assert']
Testability,"ssert( kValueError == fErrorType || kCoordError == fErrorType ||; 266 kAsymError == fErrorType || kNoError == fErrorType );; 267 ; 268 if ( fErrorType == kNoError ); 269 {; 270 assert( !fDataErrorPtr && !fDataErrorHighPtr && !fDataErrorLowPtr );; 271 assert( fDataError.empty() && fDataErrorHigh.empty() && fDataErrorLow.empty() );; 272 return 1.0;; 273 }; 274 ; 275 if ( fErrorType == kValueError ) // need to invert (inverror is stored); 276 {; 277 assert( fDataErrorPtr && !fDataErrorHighPtr && !fDataErrorLowPtr );; 278 assert( fDataErrorHigh.empty() && fDataErrorLow.empty() );; 279 assert( fDataError.empty() || &fDataError.front() == fDataErrorPtr );; 280 ; 281 double eval = fDataErrorPtr[ ipoint ];; 282 ; 283 if (fWrapped); 284 return eval;; 285 else; 286 return (eval != 0.0) ? 1.0/eval : 0.0;; 287 }; 288 ; 289 if ( fErrorType == kAsymError ); 290 { // return 1/2(el + eh); 291 assert( !fDataErrorPtr && fDataErrorHighPtr && fDataErrorLowPtr );; 292 assert( fDataError.empty() );; 293 assert( fDataErrorHigh.empty() || &fDataErrorHigh.front() == fDataErrorHighPtr );; 294 assert( fDataErrorLow.empty() || &fDataErrorLow.front() == fDataErrorLowPtr );; 295 assert( fDataErrorLow.empty() == fDataErrorHigh.empty() );; 296 ; 297 double eh = fDataErrorHighPtr[ ipoint ];; 298 double el = fDataErrorLowPtr[ ipoint ];; 299 ; 300 return (el+eh) / 2.0;; 301 }; 302 ; 303 assert( fErrorType == kCoordError );; 304 return fDataErrorPtr[ ipoint ];; 305 }; 306 ; 307 void GetAsymError( unsigned int ipoint, double& lowError, double& highError ) const; 308 {; 309 assert( fErrorType == kAsymError );; 310 assert( !fDataErrorPtr && fDataErrorHighPtr && fDataErrorLowPtr );; 311 assert( fDataError.empty() );; 312 assert( fDataErrorHigh.empty() || &fDataErrorHigh.front() == fDataErrorHighPtr );; 313 assert( fDataErrorLow.empty() || &fDataErrorLow.front() == fDataErrorLowPtr );; 314 assert( fDataErrorLow.empty() == fDataErrorHigh.empty() );; 315 ; 316 lowError = fDataErrorLowPtr[ ipoint ];; 317 highE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8h_source.html:10042,assert,assert,10042,doc/master/BinData_8h_source.html,https://root.cern,https://root.cern/doc/master/BinData_8h_source.html,1,['assert'],['assert']
Testability,"sshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title; Double_t*TGeoPcon::fZ[fNz] pointer to array of Z planes positions . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoPgon(); dummy ctor. TGeoPgon(Double_t phi, Double_t dphi, Int_t nedges, Int_t nz); Default constructor. TGeoPgon(const char* name, Double_t phi, Double_t dphi, Int_t nedges, Int_t nz); Default constructor. TGeoPgon(Double_t* params); Default constructor in GEANT3 style; param[0] = phi1; param[1] = dphi; param[2] = nedges; param[3] = nz. param[4] = z1; param[5] = Rmin1; param[6] = Rmax1. ~TGeoPgon(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a polygone; Check if the sections are in increasing Z order. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; check total z range. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the polygone; first find out in which Z section the point is in. void LocatePhi(Double_t* point, Int_t& ipsec) const; Locates index IPSEC of the phi sector containing POINT. Int_t GetPhiCrossList(Double_t* point, Double_t* dir, Int_t istart, Double_t* sphi, Int_t* iphi, Double_t stepmax = TGeoShape::Big()) const; Returns lists of PGON phi crossings for a ray starting from POINT. Bool_t SliceCrossingInZ(Double_t* point, Double_t* dir, Int_t nphi, Int_t* iphi, Double_t* sphi, Double_t& snext, Double_t stepmax) const; Performs ray propagation between Z segments. Bool_t SliceCrossingZ(Double_t* point, Double_t* dir, Int_t nphi, Int_t* iphi, Double_t* sphi, Double_t& snext, Double_t stepmax) const; Performs ray propagation between Z segments. Bool_t SliceCrossingI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoPgon.html:14337,test,test,14337,root/html528/TGeoPgon.html,https://root.cern,https://root.cern/root/html528/TGeoPgon.html,3,['test'],['test']
Testability,"ssifier; TMVA::MethodLD Linear discriminant analysis; TMVA::MethodLikelihood Likelihood analysis (""non-parametric approach"") ; TMVA::MethodMLP Multi-layer perceptron implemented specifically for TMVA; TMVA::MethodPDEFoam Analysis of PDEFoam discriminant (PDEFoam or Mahalanobis approach) ; TMVA::MethodPDERS Multi-dimensional probability density estimator range search (PDERS) method; TMVA::MethodRuleFit Friedman's RuleFit method; TMVA::MethodSVM Support Vector Machine; TMVA::MethodSeedDistance Function Discriminant Analysis; TMVA::MethodTMlpANN Implementation of interface for TMultiLayerPerceptron; TMVA::MetricEuler calculates the ""distance"" between two points; TMVA::MetricManhattan calculates the ""distance"" between two points; TMVA::MinuitFitter Fitter using a Genetic Algorithm; TMVA::MinuitWrapper Wrapper around TMinuit; TMVA::MisClassificationError Implementation of the MisClassificationError as separation criterion; TMVA::MsgLogger Ostringstream derivative to redirect and format logging output ; TMVA::Node Node for the BinarySearch or Decision Trees; TMVA::PDEFoam ; TMVA::PDEFoamCell Single cell of FOAM; TMVA::PDEFoamDistr Class for Event density; TMVA::PDEFoamVect n-dimensional vector with dynamical allocation; TMVA::PDF PDF wrapper for histograms; TMVA::Ranking Method-specific ranking for input variables ; TMVA::Reader Interpret the trained MVAs in an analysis context; TMVA::RegressionVariance Interface to different separation critiera used in training algorithms; TMVA::RootFinder Root finding using Brents algorithm; TMVA::RuleFit Calculations for Friedman's RuleFit method; TMVA::RuleFitAPI Friedman's RuleFit method; TMVA::SVEvent Event for SVM; TMVA::SdivSqrtSplusB Implementation of the SdivSqrtSplusB as separation criterion; TMVA::SeedDistance ; TMVA::SeparationBase Interface to different separation critiera used in training algorithms; TMVA::SimulatedAnnealing Base class for Simulated Annealing fitting; TMVA::SimulatedAnnealingFitter Fitter using a Simulated ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ClassIndex.html:98567,log,logging,98567,root/html526/ClassIndex.html,https://root.cern,https://root.cern/root/html526/ClassIndex.html,2,['log'],['logging']
Testability,"ssifier; TMVA::MethodLD Linear discriminant analysis; TMVA::MethodLikelihood Likelihood analysis (""non-parametric approach"") ; TMVA::MethodMLP Multi-layer perceptron implemented specifically for TMVA; TMVA::MethodPDEFoam Analysis of PDEFoam discriminant (PDEFoam or Mahalanobis approach) ; TMVA::MethodPDERS Multi-dimensional probability density estimator range search (PDERS) method; TMVA::MethodRuleFit Friedman's RuleFit method; TMVA::MethodSVM Support Vector Machine; TMVA::MethodSeedDistance Function Discriminant Analysis; TMVA::MethodTMlpANN Implementation of interface for TMultiLayerPerceptron; TMVA::MetricEuler calculates the ""distance"" between two points; TMVA::MetricManhattan calculates the ""distance"" between two points; TMVA::MinuitFitter Fitter using a Genetic Algorithm; TMVA::MinuitWrapper Wrapper around TMinuit; TMVA::MisClassificationError Implementation of the MisClassificationError as separation criterion; TMVA::MsgLogger Ostringstream derivative to redirect and format logging output ; TMVA::Node Node for the BinarySearch or Decision Trees; TMVA::PDEFoam General purpose self-adapting binning; TMVA::PDEFoamCell Single cell of FOAM; TMVA::PDEFoamIntegrand n-dimensional real positive integrand of FOAM; TMVA::PDEFoamMaxwt Controlling of the MC weight (maximum weight); TMVA::PDEFoamVect n-dimensional vector with dynamical allocation; TMVA::PDF PDF wrapper for histograms; TMVA::Ranking Method-specific ranking for input variables ; TMVA::Reader Interpret the trained MVAs in an analysis context; TMVA::RegressionVariance Interface to different separation critiera used in training algorithms; TMVA::RootFinder Root finding using Brents algorithm; TMVA::RuleFit Calculations for Friedman's RuleFit method; TMVA::RuleFitAPI Friedman's RuleFit method; TMVA::SVEvent Event for SVM; TMVA::SdivSqrtSplusB Implementation of the SdivSqrtSplusB as separation criterion; TMVA::SeedDistance ; TMVA::SeparationBase Interface to different separation critiera used in training algorith",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:96518,log,logging,96518,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,1,['log'],['logging']
Testability,"ssignTypefDataAssignType! flags for data assigning; TMVA::DataInputHandler*fDataInputHandler; TMVA::DataSetManager*fDataSetManagerDSMTEST; vector<TMVA::VariableTransformBase*>fDefaultTrfs! list of transformations on default DataSet; TStringfJobName! jobname, used as extension in weight file names; TMVA::Factory::MVectorfMethods! all MVA methods; TStringfOptions! option string given by construction (presently only ""V""); vector<TTree*>fTestAssignTree! for each class: tmp tree if user wants to assign the events directly; vector<TTree*>fTrainAssignTree! for each class: tmp tree if user wants to assign the events directly; TStringfTransformations! List of transformations to test; Bool_tfVerbose! verbose mode; static TFile*fgTargetFile! ROOT output file. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Factory(TString theJobName, TFile* theTargetFile, TString theOption = """"); standard constructor; jobname : this name will appear in all weight file names produced by the MVAs; theTargetFile : output ROOT file; the test tree and all evaluation plots; will be stored here; theOption : option string; currently: ""V"" for verbose. void Greetings(); print welcome message; options are: kLogoWelcomeMsg, kIsometricWelcomeMsg, kLeanWelcomeMsg. ~Factory( void ); destructor; delete fATreeEvent;. void DeleteAllMethods( void ); delete methods. void SetVerbose(Bool_t v = kTRUE). TMVA::DataSetInfo& AddDataSet( DataSetInfo &dsi ). TMVA::DataSetInfo& AddDataSet(const TString& ). TTree* CreateEventAssignTrees(const TString& name); create the data assignment tree (for event-wise data assignment by user). void AddSignalTrainingEvent(const vector<Double_t>& event, Double_t weight = 1.0); add signal training event. void AddSignalTestEvent(const vector<Double_t>& event, Double_t weight = 1.0); add signal testing event. void AddBackgroundTrainingEvent(const vector<Double_t>& event, Double_t weight = 1.0); add signal training event. void AddBackgroundTestEvent",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__Factory.html:12917,test,test,12917,root/html530/TMVA__Factory.html,https://root.cern,https://root.cern/root/html530/TMVA__Factory.html,3,['test'],['test']
Testability,"ssignTypefDataAssignType! flags for data assigning; TMVA::DataInputHandler*fDataInputHandler; TMVA::DataSetManager*fDataSetManagerDSMTEST; vector<TMVA::VariableTransformBase*>fDefaultTrfs! list of transformations on default DataSet; TStringfJobName! jobname, used as extension in weight file names; TMVA::Factory::MVectorfMethods! all MVA methods; TStringfOptions! option string given by construction (presently only ""V""); vector<TTree*>fTestAssignTree! for each class: tmp tree if user wants to assign the events directly; vector<TTree*>fTrainAssignTree! for each class: tmp tree if user wants to assign the events directly; TStringfTransformations! List of transformations to test; Bool_tfVerbose! verbose mode; static TFile*fgTargetFile! ROOT output file. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Factory(TString theJobName, TFile* theTargetFile, TString theOption = """"); standard constructor; jobname : this name will appear in all weight file names produced by the MVAs; theTargetFile : output ROOT file; the test tree and all evaluation plots; will be stored here; theOption : option string; currently: ""V"" for verbose. void Greetings(); print welcome message; options are: kLogoWelcomeMsg, kIsometricWelcomeMsg, kLeanWelcomeMsg. ~Factory( void ); destructor; delete fATreeEvent;. void DeleteAllMethods( void ); delete methods. void SetVerbose(Bool_t v = kTRUE). TMVA::DataSetInfo& AddDataSet( DataSetInfo &dsi ); return DataSetManager::Instance().AddDataSetInfo(dsi); // DSMTEST replaced by following line. TMVA::DataSetInfo& AddDataSet(const TString& ); DataSetInfo* dsi = DataSetManager::Instance().GetDataSetInfo(dsiName); // DSMTEST replaced by following line. TTree* CreateEventAssignTrees(const TString& name); create the data assignment tree (for event-wise data assignment by user). void AddSignalTrainingEvent(const vector<Double_t>& event, Double_t weight = 1.0); add signal training event. void AddSignalTestEvent(const vector<Doubl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__Factory.html:12845,test,test,12845,root/html528/TMVA__Factory.html,https://root.cern,https://root.cern/root/html528/TMVA__Factory.html,1,['test'],['test']
Testability,"ssion_DNN_CPU.weights.xml␛[0m; Factory : Training finished; : ; Factory : Train method: BDTG for Regression; : ; : Regression Loss Function: Huber; : Training 2000 Decision Trees ... patience please; : Elapsed time for training with 1000 events: 1.58 sec ; : Dataset[datasetreg] : Create results for training; : Dataset[datasetreg] : Evaluation of BDTG on training sample; : Dataset[datasetreg] : Elapsed time for evaluation of 1000 events: 0.354 sec ; : Create variable histograms; : Create regression target histograms; : Create regression average deviation; : Results created; : Creating xml weight file: ␛[0;36mdatasetreg/weights/TMVARegression_BDTG.weights.xml␛[0m; : TMVAReg.root:/datasetreg/Method_BDT/BDTG; Factory : Training finished; : ; TH1.Print Name = TrainingHistory_DNN_CPU_trainingError, Entries= 0, Total sum= 3.72139e+06; TH1.Print Name = TrainingHistory_DNN_CPU_valError, Entries= 0, Total sum= 3.30469e+06; Factory : === Destroy and recreate all methods via weight files for testing ===; : ; : Reading weight file: ␛[0;36mdatasetreg/weights/TMVARegression_PDEFoam.weights.xml␛[0m; : Read foams from file: ␛[0;36mdatasetreg/weights/TMVARegression_PDEFoam.weights_foams.root␛[0m; : Reading weight file: ␛[0;36mdatasetreg/weights/TMVARegression_KNN.weights.xml␛[0m; : Creating kd-tree with 1000 events; : Computing scale factor for 1d distributions: (ifrac, bottom, top) = (80%, 10%, 90%); ModulekNN : Optimizing tree for 2 variables with 1000 values; : <Fill> Class 1 has 1000 events; : Reading weight file: ␛[0;36mdatasetreg/weights/TMVARegression_LD.weights.xml␛[0m; : Reading weight file: ␛[0;36mdatasetreg/weights/TMVARegression_DNN_CPU.weights.xml␛[0m; : Reading weight file: ␛[0;36mdatasetreg/weights/TMVARegression_BDTG.weights.xml␛[0m; Factory : ␛[1mTest all methods␛[0m; Factory : Test method: PDEFoam for Regression performance; : ; : Dataset[datasetreg] : Create results for testing; : Dataset[datasetreg] : Evaluation of PDEFoam on testing sample; : Dataset[datasetreg] ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:126323,test,testing,126323,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['test'],['testing']
Testability,ssions on the assigned machines; TList*fEnabledPackageslist of enabled packages; Bool_tfEndMastertrue for a master in direct contact only with workers; THashList*fGlobalPackageDirListlist of directories containing global packages libs; TStringfGroupgroup the user belongs to; Int_tfGroupIdslave unique id in the active slave group; Int_tfGroupPrioritypriority of group the user belongs to (0 - 100); Int_tfGroupSizesize of the active slave group; Long64_tfHWMBoxSizeHigh-Water-Mark on the sandbox size; Bool_tfIdleTRUE if idle; TIdleTOTimer*fIdleTOTimerTimer used to control children state; TStringfImageimage name of the session; Int_tfInflateFactorFactor in 1/1000 to inflate the CPU time; TFileHandler*fInputHandlerInput socket handler; Bool_tfInterruptif true macro execution will be stopped; TStopwatchfLatencymeasures latency of packet requests; FILE*fLogFilelog file; Int_tfLogFileDeslog file descriptor; Long64_tfLogFileMaxSizemax size for log files (enabled if > 0); Int_tfLogLeveldebug logging level; Bool_tfMasterServtrue if we are a master server; Long64_tfMaxBoxSizeMax size of the sandbox; Int_tfMaxQueriesMax number of queries fully kept; Int_tfMergedWorkersNumber of workers merged; TMonitor*fMergingMonitorMonitor for merging sockets; TServerSocket*fMergingSocketSocket used for merging outputs if submerger; Long64_tfMsgSizeHWMHigh-Water-Mark on the size of messages with results; Int_tfNcmdcommand history number; TStringfOrdinalslave ordinal number; TStringfOutputFilepath with the temporary results of the current or last query; TStringfPackageDirdirectory containing packages and user libs; TProofLockPath*fPackageLockpackage dir locker; TVirtualProofPlayer*fPlayeractual player; TStringfPrefixPrefix identifying the node; TProof*fProofPROOF talking to slave servers; Int_tfProtocolprotocol version number; TQueryResultManager*fQMgrQuery-result manager; TMutex*fQMtxTo protect async msg queue; TStringfQueryDirdirectory containing query results and status; TProofLockPath*fQuery,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofServ.html:18750,log,logging,18750,root/html534/TProofServ.html,https://root.cern,https://root.cern/root/html534/TProofServ.html,1,['log'],['logging']
Testability,ssions on the assigned machines; TList*fEnabledPackageslist of enabled packages; Bool_tfEndMastertrue for a master in direct contact only with workers; THashList*fGlobalPackageDirListlist of directories containing global packages libs; TStringfGroupgroup the user belongs to; Int_tfGroupIdslave unique id in the active slave group; Int_tfGroupPrioritypriority of group the user belongs to (0 - 100); Int_tfGroupSizesize of the active slave group; Long64_tfHWMBoxSizeHigh-Water-Mark on the sandbox size; Bool_tfIdleTRUE if idle; TIdleTOTimer*fIdleTOTimerTimer used to control children state; TStringfImageimage name of the session; Int_tfInflateFactorFactor in 1/1000 to inflate the CPU time; TFileHandler*fInputHandlerInput socket handler; Bool_tfInterruptif true macro execution will be stopped; TStopwatchfLatencymeasures latency of packet requests; FILE*fLogFilelog file; Int_tfLogFileDeslog file descriptor; Long64_tfLogFileMaxSizemax size for log files (enabled if > 0); Int_tfLogLeveldebug logging level; Bool_tfMasterServtrue if we are a master server; Long64_tfMaxBoxSizeMax size of the sandbox; Int_tfMaxQueriesMax number of queries fully kept; Int_tfMergedWorkersNumber of workers merged; TMonitor*fMergingMonitorMonitor for merging sockets; TServerSocket*fMergingSocketSocket used for merging outputs if submerger; Long64_tfMsgSizeHWMHigh-Water-Mark on the size of messages with results; Int_tfNcmdcommand history number; TStringfOrdinalslave ordinal number; TStringfPackageDirdirectory containing packages and user libs; TProofLockPath*fPackageLockpackage dir locker; TVirtualProofPlayer*fPlayeractual player; TStringfPrefixPrefix identifying the node; TProof*fProofPROOF talking to slave servers; Int_tfProtocolprotocol version number; TQueryResultManager*fQMgrQuery-result manager; TMutex*fQMtxTo protect async msg queue; TStringfQueryDirdirectory containing query results and status; TProofLockPath*fQueryLockquery dir locker; Int_tfQuerySeqNumsequential number of the current or last ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofServ.html:18214,log,logging,18214,root/html530/TProofServ.html,https://root.cern,https://root.cern/root/html530/TProofServ.html,2,['log'],['logging']
Testability,"st &vars, const char *tAxisLabel, const RooAbsBinning **bins);  Create a 1,2, or 3D-histogram with appropriate scale and labels. ;  ; static TH1 * createHistogram (const char *name, RooArgList &vars, const char *tAxisLabel, double *xlo, double *xhi, Int_t *nBins);  Create 1-, 2- or 3-d ROOT histogram with labels taken from the variables in 'vars' and the with range and binning specified in xlo,xhi and nBins. ;  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooErrorVar.html:54854,log,logging,54854,doc/master/classRooErrorVar.html,https://root.cern,https://root.cern/doc/master/classRooErrorVar.html,4,['log'],['logging']
Testability,"st & ; dist, . EUserDistribution ; userDist = kPDF, . Double_t ; xmin = 1, . Double_t ; xmax = 0 . ). inline . Sets the user input distribution function for 1-sample test as a generic functor object. ; Definition at line 118 of file GoFTest.h. ◆ SetUserPDF() [1/2]. void ROOT::Math::GoFTest::SetUserPDF ; (; const IGenFunction & ; pdf, . Double_t ; xmin = 1, . Double_t ; xmax = 0 . ). inline . Specialization to set the user input distribution as a probability density function for 1-sample tests using the ROOT::Math::IGenFunction interface. ; Definition at line 135 of file GoFTest.h. ◆ SetUserPDF() [2/2]. template<class Dist > . void ROOT::Math::GoFTest::SetUserPDF ; (; Dist & ; pdf, . Double_t ; xmin = 1, . Double_t ; xmax = 0 . ). inline . Sets the user input distribution as a probability density function for 1-sample tests. ; Definition at line 130 of file GoFTest.h. Member Data Documentation. ◆ fCDF. std::unique_ptr<IGenFunction> ROOT::Math::GoFTest::fCDF. private . Pointer to CDF used in 1-sample test. ; Definition at line 235 of file GoFTest.h. ◆ fCombinedSamples. std::vector<Double_t> ROOT::Math::GoFTest::fCombinedSamples. private . The combined data. ; Definition at line 241 of file GoFTest.h. ◆ fDist. EDistribution ROOT::Math::GoFTest::fDist. private . Type of distribution. ; Definition at line 238 of file GoFTest.h. ◆ fParams. std::vector<Double_t> ROOT::Math::GoFTest::fParams. private . The distribution parameters (e.g. fParams[0] = mean, fParams[1] = sigma for a Gaussian) ; Definition at line 239 of file GoFTest.h. ◆ fSamples. std::vector<std::vector<Double_t> > ROOT::Math::GoFTest::fSamples. private . The input data. ; Definition at line 243 of file GoFTest.h. ◆ fTestSampleFromH0. Bool_t ROOT::Math::GoFTest::fTestSampleFromH0. private . Definition at line 245 of file GoFTest.h. Libraries for ROOT::Math::GoFTest:. [legend]; The documentation for this class was generated from the following files:; math/mathcore/inc/Math/GoFTest.h; math/mathcore/src/GoFTest.c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GoFTest.html:20566,test,test,20566,doc/master/classROOT_1_1Math_1_1GoFTest.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GoFTest.html,1,['test'],['test']
Testability,"st ();  Destructor (no operations) ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TUnuranBaseDist; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Private Attributes; double fArea;  area below pdf ;  ; const ROOT::Math::IGenFunction * fCdf;  pointer to the cdf (cumulative dist.) ;  ; const ROOT::Math::IGenFunction * fDPdf;  pointer to the derivative of the pdf ;  ; bool fHasArea;  flag to control if distribution has a pre-computed area below the pdf ;  ; bool fHasDomain;  flag to control if distribution has a defined domain (otherwise is [-inf,+inf] ;  ; bool fHasMode;  flag to control if distribution has a pre-computed mode ;  ; bool fIsLogPdf;  flag to control if function pointer represent log of pdf ;  ; double fMode;  mode of the distribution ;  ; bool fOwnFunc;  flag to indicate if class manages the function pointers ;  ; const ROOT::Math::IGenFunction * fPdf;  pointer to the pdf ;  ; double fXmax;  upper value of the domain ;  ; double fXmin;  lower value of the domain ;  . #include <TUnuranContDist.h>. Inheritance diagram for TUnuranContDist:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TUnuranContDist() [1/5]. TUnuranContDist::TUnuranContDist ; (; TF1 * ; pdf = nullptr, . TF1 * ; deriv = nullptr, . bool ; isLogPdf = false . ). explicit . Constructor from a TF1 objects specifying the pdf and optionally from another function representing the derivative of the pdf. ; The flag isLogPdf can be used to pass instead of the pdf (and its derivative) the log (and the derivative of the log) of the pdf. By default the di",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnuranContDist.html:5028,log,log,5028,doc/master/classTUnuranContDist.html,https://root.cern,https://root.cern/doc/master/classTUnuranContDist.html,1,['log'],['log']
Testability,"st (int index) const;  return expected distribution of p-values (Cls or Clsplusb) ;  ; double GetExpectedUpperLimit (double nsig=0, const char *opt="""") const;  get Limit value corresponding at the desired nsigma level (0) is median -1 sigma is 1 sigma ;  ; InterpolOption_t GetInterpolationOption () const;  ; HypoTestResult * GetLastResult () const;  ; double GetLastXValue () const;  ; double GetLastYError () const;  ; double GetLastYValue () const;  ; SamplingDistribution * GetLowerLimitDistribution () const;  get expected lower limit distributions implemented using interpolation The size for the sampling distribution is given (by default is given by the average number of toy/point) ;  ; SamplingDistribution * GetNullTestStatDist (int index) const;  same in terms of alt and null ;  ; HypoTestResult * GetResult (int index) const;  return a pointer to the i^th result object ;  ; SamplingDistribution * GetSignalAndBackgroundTestStatDist (int index) const;  get the signal and background test statistic distribution ;  ; SamplingDistribution * GetUpperLimitDistribution () const;  get expected upper limit distributions implemented using interpolation ;  ; double GetXValue (int index) const;  function to return the value of the parameter of interest for the i^th entry in the results ;  ; double GetYError (int index) const;  function to return the estimated error on the value of the confidence level for the i^th entry in the results ;  ; double GetYValue (int index) const;  function to return the value of the confidence level for the i^th entry in the results ;  ; TClass * IsA () const override;  ; bool IsOneSided () const;  query if one sided result ;  ; bool IsTwoSided () const;  query if two sided result ;  ; double LowerLimit () override;  lower and upper bound of the confidence interval (to get upper/lower limits, multiply the size( = 1-confidence level ) by 2 ;  ; double LowerLimitEstimatedError ();  rough estimation of the error on the computed bound of the confidence ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1HypoTestInverterResult.html:4639,test,test,4639,doc/master/classRooStats_1_1HypoTestInverterResult.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1HypoTestInverterResult.html,1,['test'],['test']
Testability,"st *) elist->Clone();; }; if (elist); fOutput->Add(elist);; else; fillList = kFALSE;; } else elist = 0;; ; // case when one uses the entry list generated in a previous call; if (option.Contains(""useList"")) {; useList = kTRUE;; TFile f(""elist.root"");; elist = (TEntryList*)f.Get(""elist"");; if (elist) elist->SetDirectory(0); //otherwise the file destructor will delete elist; if (tree) tree->SetEntryList(elist);; else {; // Option ""useList"" not supported in PROOF directly; Warning(""Begin"", ""option 'useList' not supported in PROOF - ignoring"");; Warning(""Begin"", ""the entry list must be set on the chain *before* calling Process"");; }; }; ; }; ; Double_t h1analysisProxy() {; return 0;; }; ; ; Bool_t h1analysisProxy_Process(Long64_t entry); {; // entry is the entry number in the current Tree; // Selection function to select D* and D0.; ; //in case one entry list is given in input, the selection has already been done.; if (!useList) {; ; float f1 = md0_d;; float f2 = md0_d-1.8646;; bool test = TMath::Abs(md0_d-1.8646) >= 0.04;; if (gDebug>0) fprintf(stderr,""entry #%lld f1=%f f2=%f test=%d\n"",; fChain->GetReadEntry(),f1,f2,test);; ; if (TMath::Abs(md0_d-1.8646) >= 0.04) return kFALSE;; if (ptds_d <= 2.5) return kFALSE;; if (TMath::Abs(etads_d) >= 1.5) return kFALSE;; ; int cik = ik-1; //original ik used f77 convention starting at 1; int cipi = ipi-1; //original ipi used f77 convention starting at 1; ; f1 = nhitrp[cik];; f2 = nhitrp[cipi];; test = nhitrp[cik]*nhitrp[cipi] <= 1;; if (gDebug>0) fprintf(stderr,""entry #%lld f1=%f f2=%f test=%d\n"",; fChain->GetReadEntry(),f1,f2,test);; ; if (nhitrp[cik]*nhitrp[cipi] <= 1) return kFALSE;; if (rend[cik] -rstart[cik] <= 22) return kFALSE;; if (rend[cipi]-rstart[cipi] <= 22) return kFALSE;; if (nlhk[cik] <= 0.1) return kFALSE;; if (nlhpi[cipi] <= 0.1) return kFALSE;; // fix because read-only; if (nlhpi[ipis-1] <= 0.1) return kFALSE;; if (njets < 1) return kFALSE;; ; }; // if option fillList, fill the event list; if (fillList) elist->En",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1analysisProxy_8C.html:7658,test,test,7658,doc/master/h1analysisProxy_8C.html,https://root.cern,https://root.cern/doc/master/h1analysisProxy_8C.html,1,['test'],['test']
Testability,"st << "" index "" << p.second << std::endl;; 3735 ; 3736 fClingParameters.clear(); // need to be reset before re-initializing it; 3737 ; 3738 FillDefaults();; 3739 ; 3740 ; 3741 PreProcessFormula(fFormula);; 3742 ; 3743 //std::cout << ""Streamer::after pre-process the formula "" << fFormula << "" ndim = "" << fNdim << "" npar = "" << fNpar << std::endl;; 3744 ; 3745 PrepareFormula(fFormula);; 3746 ; 3747 //std::cout << ""Streamer::after prepared "" << fClingInput << "" ndim = "" << fNdim << "" npar = "" << fNpar << std::endl;; 3748 ; 3749 ; 3750 // restore parameter values; 3751 if (fNpar != (int) parValues.size() ) {; 3752 Error(""Streamer"",""number of parameters computed (%d) is not same as the stored parameters (%d)"",fNpar,int(parValues.size()) );; 3753 Print(""v"");; 3754 }; 3755 if (v > 11 && fNdim != ndim) {; 3756 Error(""Streamer"",""number of dimension computed (%d) is not same as the stored value (%d)"",fNdim, ndim );; 3757 Print(""v"");; 3758 }; 3759 }; 3760 else {; 3761 // we also delay the initialization of lamda expressions; 3762 if (!fLazyInitialization) {; 3763 bool ret = InitLambdaExpression(fFormula);; 3764 if (ret) {; 3765 fClingInitialized = true;; 3766 }; 3767 }else {; 3768 fReadyToExecute = true;; 3769 }; 3770 }; 3771 assert(fNpar == (int) parValues.size() );; 3772 std::copy( parValues.begin(), parValues.end(), fClingParameters.begin() );; 3773 // restore parameter names and order; 3774 if (fParams.size() != paramMap.size() ) {; 3775 Warning(""Streamer"",""number of parameters list found (%zu) is not same as the stored one (%zu) - use re-created list"",fParams.size(),paramMap.size()) ;; 3776 //Print(""v"");; 3777 }; 3778 else; 3779 //assert(fParams.size() == paramMap.size() );; 3780 fParams = paramMap;; 3781 ; 3782 // input formula into Cling; 3783 // need to replace in cling the name of the pointer of this object; 3784 // TString oldClingName = fClingName;; 3785 // fClingName.Replace(fClingName.Index(""_0x"")+1,fClingName.Length(), TString::Format(""%p"",this) );; 3786 // fCling",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFormula_8cxx_source.html:143175,assert,assert,143175,doc/master/TFormula_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html,1,['assert'],['assert']
Testability,"st Double_t kHzmp = 0.591923442;; 292 /*zhm 0.967882898*/; 293 ; 294 const Double_t kAs = 0.8853395638;; 295 const Double_t kBs = 0.2452635696;; 296 const Double_t kCs = 0.2770276848;; 297 const Double_t kB = 0.5029324303;; 298 const Double_t kX0 = 0.4571828819;; 299 const Double_t kYm = 0.187308492 ;; 300 const Double_t kS = 0.7270572718 ;; 301 const Double_t kT = 0.03895759111;; 302 ; 303 Double_t result;; 304 Double_t rn,x,y,z;; 305 ; 306 do {; 307 y = Rndm();; 308 ; 309 if (y>kHm1) {; 310 result = kHp*y-kHp1; break; }; 311 ; 312 else if (y<kZm) {; 313 rn = kZp*y-1;; 314 result = (rn>0) ? (1+rn) : (-1+rn);; 315 break;; 316 }; 317 ; 318 else if (y<kHm) {; 319 rn = Rndm();; 320 rn = rn-1+rn;; 321 z = (rn>0) ? 2-rn : -2-rn;; 322 if ((kC1-y)*(kC3+TMath::Abs(z))<kC2) {; 323 result = z; break; }; 324 else {; 325 x = rn*rn;; 326 if ((y+kD1)*(kD3+x)<kD2) {; 327 result = rn; break; }; 328 else if (kHzmp-y<exp(-(z*z+kPhln)/2)) {; 329 result = z; break; }; 330 else if (y+kHzm<exp(-(x+kPhln)/2)) {; 331 result = rn; break; }; 332 }; 333 }; 334 ; 335 while (true) {; 336 x = Rndm();; 337 y = kYm * Rndm();; 338 z = kX0 - kS*x - y;; 339 if (z>0); 340 rn = 2+y/x;; 341 else {; 342 x = 1-x;; 343 y = kYm-y;; 344 rn = -(2+y/x);; 345 }; 346 if ((y-kAs+x)*(kCs+x)+kBs<0) {; 347 result = rn; break; }; 348 else if (y<x+kT); 349 if (rn*rn<4*(kB-log(x))) {; 350 result = rn; break; }; 351 }; 352 } while(false);; 353 ; 354 return mean + sigma * result;; 355}; 356 ; 357////////////////////////////////////////////////////////////////////////////////; 358/// Returns a random integer uniformly distributed on the interval [ 0, imax-1 ].; 359/// Note that the interval contains the values of 0 and imax-1 but not imax.; 360 ; 361UInt_t TRandom::Integer(UInt_t imax); 362{; 363 UInt_t ui;; 364 ui = (UInt_t)(imax*Rndm());; 365 return ui;; 366}; 367 ; 368////////////////////////////////////////////////////////////////////////////////; 369/// Generate a random number following a Landau distribution; 370/// ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRandom_8cxx_source.html:15956,log,log,15956,doc/master/TRandom_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TRandom_8cxx_source.html,1,['log'],['log']
Testability,"st Element *a, Size k, Size *work); Returns k_th order statistic of the array a of size n; (k_th smallest element out of n elements). C-convention is used for array indexing, so if you want; the second smallest element, call KOrdStat(n, a, 1). If work is supplied, it is used to store the sorting index and; assumed to be >= n. If work=0, local storage is used, either on; the stack if n < kWorkMax or on the heap for n >= kWorkMax. Taken from ""Numerical Recipes in C++"" without the index array; implemented by Anna Khreshuk. See also the declarations at the top of this file. Double_t Pi(). Fundamental constants. { return 3.14159265358979323846; }. Double_t TwoPi(); { return 2.0 * Pi(); }. Double_t PiOver2(); { return Pi() / 2.0; }. Double_t PiOver4(); { return Pi() / 4.0; }. Double_t InvPi(); { return 1.0 / Pi(); }. Double_t RadToDeg(); { return 180.0 / Pi(); }. Double_t DegToRad(); { return Pi() / 180.0; }. Double_t Sqrt2(); { return 1.4142135623730950488016887242097; }. Double_t E(); e (base of natural log). { return 2.71828182845904523536; }. Double_t Ln10(); natural log of 10 (to convert log to ln). { return 2.30258509299404568402; }. Double_t LogE(); base-10 log of e (to convert ln to log). { return 0.43429448190325182765; }. Double_t C(); velocity of light. { return 2.99792458e8; }. Double_t Ccgs(); { return 100.0 * C(); }. Double_t CUncertainty(); { return 0.0; }. Double_t G(); gravitational constant. { return 6.673e-11; }. Double_t Gcgs(); { return G() / 1000.0; }. Double_t GUncertainty(); { return 0.010e-11; }. Double_t GhbarC(); G over h-bar C. { return 6.707e-39; }. Double_t GhbarCUncertainty(); { return 0.010e-39; }. Double_t Gn(); standard acceleration of gravity. { return 9.80665; }. Double_t GnUncertainty(); { return 0.0; }. Double_t H(); Planck's constant. { return 6.62606876e-34; }. Double_t Hcgs(); { return 1.0e7 * H(); }. Double_t HUncertainty(); { return 0.00000052e-34; }. Double_t Hbar(); h-bar (h over 2 pi). { return 1.054571596e-34; }. Double_t Hbar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMath.html:44911,log,log,44911,root/html528/TMath.html,https://root.cern,https://root.cern/root/html528/TMath.html,2,['log'],['log']
Testability,"st RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; virtual Bool_tisValid() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealIntegral.html:16454,log,logEvalError,16454,root/html532/RooRealIntegral.html,https://root.cern,https://root.cern/root/html532/RooRealIntegral.html,1,['log'],['logEvalError']
Testability,"st RooAbsArg& other) const; Bool_tisConstant() const; virtual Bool_tisDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tisFundamental() const; virtual Bool_tisLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tisShapeDirty() const; Bool_tisShapeServer(const RooAbsArg& arg) const; Bool_tisShapeServer(const char* name) const; virtual Bool_tIsSortable() const; Bool_tisValueDirty() const; Bool_tisValueServer(const RooAbsArg& arg) const; Bool_tisValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidleafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tnumCaches() const; Bool_tobservableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tobservableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeoperMode() const; virtual voidoptimizeCacheMode(const RooArgSet& observables); virtual voidoptimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_toverlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsArg.html:8334,test,testArg,8334,root/html526/RooAbsArg.html,https://root.cern,https://root.cern/root/html526/RooAbsArg.html,2,['test'],['testArg']
Testability,"st RooAbsArg& other) const; Bool_tisConstant() const; virtual Bool_tisDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tisFundamental() const; virtual Bool_tisLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tisShapeDirty() const; Bool_tisShapeServer(const RooAbsArg& arg) const; Bool_tisShapeServer(const char* name) const; virtual Bool_tIsSortable() const; Bool_tisValueDirty() const; Bool_tisValueServer(const RooAbsArg& arg) const; Bool_tisValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidleafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tnumCaches() const; Bool_tobservableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tobservableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeoperMode() const; virtual voidoptimizeCacheMode(const RooArgSet& observables); virtual voidoptimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_toverlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*ownedCompon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsArg.html:8469,test,testArg,8469,root/html530/RooAbsArg.html,https://root.cern,https://root.cern/root/html530/RooAbsArg.html,1,['test'],['testArg']
Testability,"st RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCachedReal&operator=(const RooCachedReal&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCachedReal.html:19621,test,testArg,19621,root/html602/RooCachedReal.html,https://root.cern,https://root.cern/root/html602/RooCachedReal.html,2,['test'],['testArg']
Testability,"st RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooSpHarmonic&operator=(const RooSpHarmonic&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSpHarmonic.html:20441,test,testArg,20441,root/html602/RooSpHarmonic.html,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html,2,['test'],['testArg']
Testability,"st RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooTFnBinding&operator=(const RooTFnBinding&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooTFnBinding.html:19334,test,testArg,19334,root/html602/RooTFnBinding.html,https://root.cern,https://root.cern/root/html602/RooTFnBinding.html,2,['test'],['testArg']
Testability,"st RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tdefaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAddition.html:8811,test,testArg,8811,root/html528/RooAddition.html,https://root.cern,https://root.cern/root/html528/RooAddition.html,22,['test'],['testArg']
Testability,"st RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooProfileLL.html:8993,test,testArg,8993,root/html528/RooProfileLL.html,https://root.cern,https://root.cern/root/html528/RooProfileLL.html,12,['test'],['testArg']
Testability,"st RooArgSet &iset, const RooNumIntConfig &cfg, const char *rangeName=nullptr) constCreate integral over observables in iset in range named rangeName using specified configuration for a...Definition RooAbsReal.h:220; RooAbsReal::_specIntegratorConfigstd::unique_ptr< RooNumIntConfig > _specIntegratorConfigDefinition RooAbsReal.h:540; RooAbsReal::getAnalyticalIntegralvirtual Int_t getAnalyticalIntegral(RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) constInterface function getAnalyticalIntergral advertises the analytical integrals that are supported.Definition RooAbsReal.cxx:368; RooAbsReal::evalErrorIterstatic std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter()Definition RooAbsReal.cxx:181; RooAbsReal::numEvalErrorsstatic Int_t numEvalErrors()Return the number of logged evaluation errors since the last clearing.Definition RooAbsReal.cxx:3624; RooAbsReal::setEvalErrorLoggingModestatic void setEvalErrorLoggingMode(ErrorLoggingMode m)Set evaluation error logging mode.Definition RooAbsReal.cxx:4316; RooAbsReal::_plotMaxdouble _plotMaxMaximum of plot range.Definition RooAbsReal.h:534; RooAbsReal::preferredObservableScanOrdervirtual void preferredObservableScanOrder(const RooArgSet &obs, RooArgSet &orderedObs) constInterface method for function objects to indicate their preferred order of observables for scanning t...Definition RooAbsReal.cxx:3694; RooAbsReal::maxValvirtual double maxVal(Int_t code) constReturn maximum value for set of observables identified by code assigned in getMaxVal.Definition RooAbsReal.cxx:3397; RooAbsReal::findInnerMostIntegrationvoid findInnerMostIntegration(const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) constUtility function for createIntObj() that aids in the construct of recursive integrals over functions ...Definition RooAbsReal.cxx:701; RooAbsReal::integralNameSuffixTString integralNameSuffix(const RooArgSet &iset, const RooArgSet *n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8h_source.html:48634,log,logging,48634,doc/master/RooAbsReal_8h_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html,1,['log'],['logging']
Testability,"st RooArgSet*fNuisancePars; const RooArgSet*fObservables; const RooArgSet*fParametersForTestStat; RooAbsPdf*fPdfmodel (can be alt or null); RooAbsPdf*fPriorNuisanceprior pdf for nuisance parameters; RooStats::ProofConfig*fProofConfig!; const RooDataSet*fProtoDatain dev; stringfSamplingDistNamename of the model; Double_tfSize; vector<RooStats::TestStatistic*>fTestStatistics; Double_tfToysInTails; Bool_tfUseMultiGenUse PrepareMultiGen?; static Bool_tfgAlwaysUseMultiGenUse PrepareMultiGen always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetAlwaysUseMultiGen(Bool_t flag); { fgAlwaysUseMultiGen = flag ; }. ToyMCSampler(); Proof constructor. Do not use. ToyMCSampler(RooStats::TestStatistic& ts, Int_t ntoys). ~ToyMCSampler(). Bool_t CheckConfig(void); only checks, no guessing/determination (do this in calculators,; e.g. using ModelConfig::GuessObsAndNuisance(...)). RooArgList* EvaluateAllTestStatistics(RooAbsData& data, const RooArgSet& poi); Evaluate all test statistics, returning result and any detailed output.; PDF parameter values are saved in case they are modified by; TestStatistic::Evaluate (eg. SimpleLikelihoodRatioTestStat). const RooArgList* EvaluateAllTestStatistics(RooAbsData& data, const RooArgSet& poi, RooStats::DetailedOutputAggregator& detOutAgg). SamplingDistribution* GetSamplingDistribution(RooArgSet& paramPoint). RooDataSet* GetSamplingDistributions(RooArgSet& paramPoint); Use for serial and parallel runs. RooDataSet* GetSamplingDistributionsSingleWorker(RooArgSet& paramPoint); This is the main function for serial runs. It is called automatically; from inside GetSamplingDistribution when no ProofConfig is given.; You should not call this function yourself. This function should; be used by ToyMCStudy on the workers (ie. when you explicitly want; a serial run although ProofConfig is present). void GenerateGlobalObservables(RooAbsPdf& pdf) const. RooAbsData* GenerateToyData(RooArgSet& paramPoint, double&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__ToyMCSampler.html:5830,test,test,5830,root/html602/RooStats__ToyMCSampler.html,https://root.cern,https://root.cern/root/html602/RooStats__ToyMCSampler.html,2,['test'],['test']
Testability,"st RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}) const;  As RooAbsPdf::generateBinned(const RooArgSet&, const RooCmdArg&,const RooCmdArg&, const RooCmdArg&,const RooCmdArg&, const RooCmdArg&,const RooCmdArg&) const. ;  ; virtual RooFit::OwningPtr< RooDataSet > generateSimGlobal (const RooArgSet &whatVars, Int_t nEvents);  Special generator interface for generation of 'global observables' – for RooStats tools. ;  ; RooArgSet * getAllConstraints (const RooArgSet &observables, RooArgSet &constrainedParams, bool stripDisconnected=true) const;  This helper function finds and collects all constraints terms of all component p.d.f.s and returns a RooArgSet with all those terms. ;  ; const RooNumGenConfig * getGeneratorConfig () const;  Return the numeric MC generator configuration used for this object. ;  ; void getLogProbabilities (std::span< const double > pdfValues, double *output) const;  ; virtual double getLogVal (const RooArgSet *set=nullptr) const;  Return the log of the current value with given normalization An error message is printed if the argument of the log is negative. ;  ; double getNorm (const RooArgSet &nset) const;  Get normalisation term needed to normalise the raw values returned by getVal(). ;  ; virtual double getNorm (const RooArgSet *set=nullptr) const;  Get normalisation term needed to normalise the raw values returned by getVal(). ;  ; const RooAbsReal * getNormIntegral (const RooArgSet &nset) const;  ; virtual const RooAbsReal * getNormObj (const RooArgSet *set, const RooArgSet *iset, const TNamed *rangeName=nullptr) const;  Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range rangeName, optionally taking the integrand normalized over observables nset. ;  ; double getValV (const RooArgSet *set=nullptr) const override;  Return current value, normalized by integrating over the observables in nset. ;  ; bool mustBeExtended () const;  If true PDF ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProdPdf.html:13623,log,log,13623,doc/master/classRooProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooProdPdf.html,2,['log'],['log']
Testability,"st TClass *base, void *obj, Bool_t up=kTRUE)Cast obj of this class type up to baseclass cl if up is true.Definition TClass.cxx:4982; TClass::GetDirectoryAutoAddROOT::DirAutoAdd_t GetDirectoryAutoAdd() constReturn the wrapper around the directory auto add function.Definition TClass.cxx:7554; TClass::kDummyNew@ kDummyNewDefinition TClass.h:107; TClass::GetSchemaRulesconst ROOT::Detail::TSchemaRuleSet * GetSchemaRules() constReturn the set of the schema rules if any.Definition TClass.cxx:1999; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2858; TClass::HasDefaultConstructorBool_t HasDefaultConstructor(Bool_t testio=kFALSE) constReturn true if we have access to a constructor usable for I/O.Definition TClass.cxx:7460; TClass::kEmulated@ kEmulatedDefinition TClass.h:125; TClass::GetActualClassTClass * GetActualClass(const void *object) constReturn a pointer to the real class of the object.Definition TClass.cxx:2674; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::Classstatic TClass * Class(); TDatimeThis class stores the date and time with a precision of one second in an unsigned 32 bit word (950130...Definition TDatime.h:37; TDatime::GetUInt_t Get() constReturn raw date/time as encoded by TDatime.Definition TDatime.cxx:240; TDatime::FillBuffervoid FillBuffer(char *&buffer)Encode Date/Time into buffer, used by I/O system.Definition TDatime.cxx:229; TDatime::SizeofInt_t Sizeof() constDefinition TDatime.h:81; TDatime::Streamervirtual void ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TKey_8cxx_source.html:60481,test,testio,60481,doc/master/TKey_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html,1,['test'],['testio']
Testability,"st TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tisFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual TStringoperator TString(); virtual RooAbsArg&operator=(const char* newValue); Bool_tRooAbsString::operator==(const char*) const; virtual Bool_tRooAbsString::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStringVar.html:8490,test,testArg,8490,root/html526/RooStringVar.html,https://root.cern,https://root.cern/root/html526/RooStringVar.html,2,['test'],['testArg']
Testability,"st TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tisFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual TStringoperator TString(); virtual RooAbsArg&operator=(const char* newValue); Bool_tRooAbsString::operator==(const char*) const; virtual Bool_tRooAbsString::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStringVar.html:8658,test,testArg,8658,root/html530/RooStringVar.html,https://root.cern,https://root.cern/root/html530/RooStringVar.html,1,['test'],['testArg']
Testability,"st char *binnedTag="""") const;  ; virtual RooAbsGenContext * binnedGenContext (const RooArgSet &vars, bool verbose=false) const;  Return a binned generator context. ;  ; bool canBeExtended () const;  If true, PDF can provide extended likelihood term. ;  ; RooFit::OwningPtr< RooAbsReal > createCdf (const RooArgSet &iset, const RooArgSet &nset=RooArgSet());  Create a cumulative distribution function of this p.d.f in terms of the observables listed in iset. ;  ; RooFit::OwningPtr< RooAbsReal > createCdf (const RooArgSet &iset, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Create an object that represents the integral of the function over one or more observables listed in iset. ;  ; template<typename... CmdArgs_t> ; RooFit::OwningPtr< RooAbsReal > createNLL (RooAbsData &data, CmdArgs_t const &... cmdArgs);  Construct representation of -log(L) of PDF with given dataset. ;  ; virtual RooAbsPdf * createProjection (const RooArgSet &iset);  Return a p.d.f that represent a projection of this p.d.f integrated over given observables. ;  ; RooFit::OwningPtr< RooAbsReal > createScanCdf (const RooArgSet &iset, const RooArgSet &nset, Int_t numScanBins, Int_t intOrder);  ; double expectedEvents (const RooArgSet &nset) const;  Return expected number of events to be used in calculation of extended likelihood. ;  ; double extendedTerm (double sumEntries, double expected, double sumEntriesW2=0.0, bool doOffset=false) const;  ; double extendedTerm (double sumEntries, RooArgSet const *nset, double sumEntriesW2=0.0, bool doOffset=false) const;  Return the extended likelihood term ( \( N_\mathrm{expect} - N_\mathrm{observed} \cdot \log(N_\mathrm{expect} \)) of this PDF for the given number of observed events. ;  ; double extendedTerm (RooAbsData const &data, bool weightSquared, bool doOffset=false) const;  Return the extended likelih",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:8231,log,log,8231,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,5,['log'],['log']
Testability,"st char *par, Long_t value);  Set an input list parameter. ;  ; void SetPerfTree (const char *pf=""perftree.root"", Bool_t withWrks=kFALSE);  Enable/Disable saving of the performance tree. ;  ; void SetPrintProgress (PrintProgress_t pp);  ; void SetProgressDialog (Bool_t on=kTRUE);  Enable/Disable the graphic progress dialog. ;  ; void SetQueryMode (EQueryMode mode);  Change query running mode to the one specified by 'mode'. ;  ; void SetRealTimeLog (Bool_t on=kTRUE);  Switch ON/OFF the real-time logging facility. ;  ; void ShowDataSet (const char *dataset="""", const char *opt=""filter:SsCc"");  display meta-info for given dataset usi ;  ; void ShowDataSetQuota (Option_t *opt=0);  shows the quota and usage of all groups if opt contains ""U"" shows also distribution of usage on user-level ;  ; void ShowEnabledPackages (Bool_t all=kFALSE);  List which packages are enabled. ;  ; void ShowFeedback () const;  Show items in feedback list. ;  ; void ShowLog (const char *queryref);  Display on screen the content of the temporary log file for query in reference. ;  ; void ShowLog (Int_t qry=-1);  Display on screen the content of the temporary log file. ;  ; void ShowMissingFiles (TQueryResult *qr=0);  Show information about missing files during query described by 'qr' or the last query if qr is null (default). ;  ; void ShowPackages (Bool_t all=kFALSE, Bool_t redirlog=kFALSE);  List contents of package directory. ;  ; void ShowParameters (const char *wildcard=""PROOF_*"") const;  Show the input list parameters specified by the wildcard. ;  ; void ShowQueries (Option_t *opt="""");  Ask the master for the list of queries. ;  ; virtual void ShowStagingStatusDataSet (const char *dataset, const char *optStr=""filter:SsCc"");  Like GetStagingStatusDataSet, but displays results immediately. ;  ; void StartupMessage (const char *msg, Bool_t status, Int_t done, Int_t total);  Send startup message. ;  ; void StopProcess (Bool_t abort, Int_t timeout=-1);  Send STOPPROCESS message to master and worke",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:18755,log,log,18755,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['log'],['log']
Testability,"st char* indent = """"); Add extra information on component test statistics when printing; itself as part of a tree structure. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Forward constant term optimization management calls to component; test statistics. void setMPSet(Int_t setNum, Int_t numSets); Set MultiProcessor set number identification of this instance. void initMPMode(RooAbsReal* real, RooAbsData* data, const RooArgSet* projDeps, const char* rangeName, const char* addCoefRangeName); Initialize multi-processor calculation mode. Create component test statistics in separate; processed that are connected to this process through a RooAbsRealMPFE front-end class. void initSimMode(RooSimultaneous* pdf, RooAbsData* data, const RooArgSet* projDeps, const char* rangeName, const char* addCoefRangeName); Initialize simultaneous p.d.f processing mode. Strip simultaneous; p.d.f into individual components, split dataset in subset; matching each component and create component test statistics for; each of them. Bool_t setData(RooAbsData& data, Bool_t cloneData = kTRUE); Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the test statistic was constructed with; a range specification on the data, the cloneData argument is ignore and; the data is always cloned. RooAbsTestStatistic* create(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t splitCutRange = kFALSE). Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const. Double_t globalNormalization() const; Default value of global normalization factor is 1.0. Double_t evaluatePartition(Int_t firstEvent, Int_t lastEvent, Int_t stepSize) const. void setSimCount(Int_t simCount); Store total number of components p.d.f. of a RooSimultane",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsTestStatistic.html:38669,test,test,38669,root/html532/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html532/RooAbsTestStatistic.html,1,['test'],['test']
Testability,"st char* indent = """"); Add extra information on component test statistics when printing; itself as part of a tree structure. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Forward constant term optimization management calls to component; test statistics. void setMPSet(Int_t setNum, Int_t numSets); Set MultiProcessor set number identification of this instance. void initMPMode(RooAbsReal* real, RooAbsData* data, const RooArgSet* projDeps, const char* rangeName, const char* addCoefRangeName); Initialize multi-processor calculation mode. Create component test statistics in separate; processed that are connected to this process through a RooAbsRealMPFE front-end class. void initSimMode(RooSimultaneous* pdf, RooAbsData* data, const RooArgSet* projDeps, const char* rangeName, const char* addCoefRangeName); Initialize simultaneous p.d.f processing mode. Strip simultaneous; p.d.f into individual components, split dataset in subset; matching each component and create component test statistics for; each of them. Bool_t setData(RooAbsData& data, Bool_t cloneData = kTRUE); Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the test statistic was constructed with; a range specification on the data, the cloneData argument is ignore and; the data is always cloned. void enableOffsetting(Bool_t flag); Apply internal value offsetting to control numeric precision. Double_t getCarry() const; { return _evalCarry; }. RooAbsTestStatistic* create(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t splitCutRange = kFALSE, Bool_t binnedL = kFALSE). Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const. Double_t globalNormalization() const; Default value of global normali",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsTestStatistic.html:40978,test,test,40978,root/html534/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html534/RooAbsTestStatistic.html,3,['test'],['test']
Testability,"st char* name); virtual voidSetTestSize(Double_t size); virtual voidSetTestStatistic(RooStats::TestStatistic*); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); RooStats::TestStatSamplerRooStats::TestStatSampler::TestStatSampler(); RooStats::TestStatSamplerRooStats::TestStatSampler::TestStatSampler(const RooStats::TestStatSampler&). Data Members; private:. TRandom*fRand; Double_tfSize; RooRealVar*fTestStatistic. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DebuggingSampler(). virtual ~DebuggingSampler(). SamplingDistribution* GetSamplingDistribution(RooArgSet& paramsOfInterest); Main interface to get a ConfInterval, pure virtual. Double_t EvaluateTestStatistic(RooAbsData& , RooArgSet& ); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetTestStatistic() const; Get the TestStatistic. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void Initialize(RooAbsArg& , RooArgSet& , RooArgSet& ); Common Initialization. void SetPdf(RooAbsPdf& ); Set the Pdf, add to the the workspace if not already there. {}. void SetParameters(RooArgSet& ); specify the parameters of interest in the interval. {}. void SetNuisanceParameters(const RooArgSet& ); specify the nuisance parameters (eg. the rest of the parameters). {}. void SetParametersForTestStat(const RooArgSet& ); specify the values of parameters used when evaluating test statistic. {}. void SetGlobalObservables(const RooArgSet& ); specify the conditional observables. {}. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size;}. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. void SetTestStatistic(RooStats::TestStatistic* ); Set the TestStatistic (wan",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__DebuggingSampler.html:2888,test,test,2888,root/html602/RooStats__DebuggingSampler.html,https://root.cern,https://root.cern/root/html602/RooStats__DebuggingSampler.html,2,['test'],['test']
Testability,"st char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsString::createFundamental(const char* newname = 0) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::Exe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStringVar.html:2912,test,testArg,2912,root/html526/RooStringVar.html,https://root.cern,https://root.cern/root/html526/RooStringVar.html,3,['test'],['testArg']
Testability,"st char* ord, Int_t perf, const char* image, const char* workdir); TSlave*TProof::CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd, Int_t nwk = 1); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; static Bool_tTProof::GetFileInCmd(const char* cmd, TString& fn); static Int_tTProof::GetInputData(TList* input, const char* cachedir, TString& emsg); TList*TProof::GetListOfActiveSlaves() const; TVirtualProofPlayer*TProof::GetPlayer() const; TPluginHandler*TProof::GetProgressDialog() const; Int_tTProof::GetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTProof::HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tTProof::HandleOutputOptions(TString& opt, TString& target, Int_t action); Int_tTProof::Init(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidTProof::InitMembers(); virtual TVirtualProofPlayer*MakePlayer(const char* player = 0, TSocket* s = 0); voidTObject::MakeZombie(); voidTProof::PrepareInputDataFile(TString& dataFile); Int_tTProof::RemoveWorkers(TList* wrks); static Int_tTProof::SaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidTProof::SaveWorkerInfo(); Int_tTProof::SendFile(const char* file, Int_t opt = (kBinary | kForward | kCp | kCpBin), const char* rfile = 0, TSlave* sl = 0); static Int_tTProof::SendInputData(TQueryResult* qr, TProof* p, TString& emsg); virtual voidTProof::SendInputDataFile(); voidTProof::SetDSet(TDSet* dset); voidTProof::SetFeedback(TString& opt, TString& optfb, Int_t action); voidTProof::SetPlayer(TVirtualProofPlayer* player); static void*TProof::SlaveStartupThread(void* arg); virtual Bool_tStartSlaves(Bool_t); static voidTProof::SystemCmd(const char* cmd, Int_t fdout); voidTProof::UpdateDialog(); virtual voidValidateDSet(TDSet* dset)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofSuperMaster.html:22161,log,loglevel,22161,root/html602/TProofSuperMaster.html,https://root.cern,https://root.cern/root/html602/TProofSuperMaster.html,1,['log'],['loglevel']
Testability,"st char* volref, const char* posref, const char* rotref, XMLNodePointer_t scaleN); Creates ""physvol"" node for GDML. XMLNodePointer_t CreateDivisionN(Double_t offset, Double_t width, Int_t number, const char* axis, const char* unit, const char* volref); Creates ""divisionvol"" node for GDML. XMLNodePointer_t ChooseObject(TGeoShape* geoShape); Chooses the object and method that should be used for processing object. TGeoCompositeShape* CreateFakeCtub(TGeoCtub* geoShape); Method creating cutTube as an intersection of tube and two boxes; - not used anymore because cutube is supported in Geant4 9.5. Bool_t IsInList(TGDMLWrite::NameList list, TString name2check); Checks whether name2check is in (NameList) list. TString GenName(TString oldname); NCNAME basic restrictions; Replace ""$"" character with empty character etc. TString GenName(TString oldname, TString objPointer); Important function which is responsible for naming volumes, solids and materials. Bool_t CanProcess(TObject* pointer); Method which tests whether solids can be processed. TString GetPattAxis(Int_t divAxis, const char* pattName, TString& unit); Method that retrieves axis and unit along which object is divided. Bool_t IsNullParam(Double_t parValue, TString parName, TString objName); Check for null parameter to skip the NULL objects. void UnsetTemporaryBits(TGeoManager* geoMng); Unsetting bits that were changed in gGeoManager during export so that export; can be run more times with the same instance of gGeoManager. TGDMLWrite(). void StartGDMLWriting(TGeoManager* geomanager, const char* filename, TString option); static function -; options:; g - set by default - geant4 compatibility; f,n - if none of this two is set then naming convention is; with incremental suffix, if ""f"" then suffix is pointer; if ""n"" then there is no suffix, but uniqness of names; is not secured. void SetG4Compatibility(Bool_t G4Compatible). Xyz GetXYZangles(const Double_t* rotationMatrix); II. Utility methods. » Author: Anton Pytel 15/9/201",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGDMLWrite.html:19372,test,tests,19372,root/html534/TGDMLWrite.html,https://root.cern,https://root.cern/root/html534/TGDMLWrite.html,3,['test'],['tests']
Testability,"st double * ROOT::Math::GSLMultiFit::Gradient ; (; ); const. inline . gradient value at the minimum ; Definition at line 158 of file GSLMultiFit.h. ◆ Iterate(). int ROOT::Math::GSLMultiFit::Iterate ; (; ). inline . Definition at line 145 of file GSLMultiFit.h. ◆ Name(). std::string ROOT::Math::GSLMultiFit::Name ; (; ); const. inline . Definition at line 140 of file GSLMultiFit.h. ◆ operator=() [1/2]. GSLMultiFit & ROOT::Math::GSLMultiFit::operator= ; (; const GSLMultiFit & ; rhs). delete . ◆ operator=() [2/2]. GSLMultiFit & ROOT::Math::GSLMultiFit::operator= ; (; GSLMultiFit && ; rhs). delete . ◆ Set(). template<class Func > . int ROOT::Math::GSLMultiFit::Set ; (; const std::vector< Func > & ; funcVec, . const double * ; x . ). inline . set the solver parameters ; Definition at line 111 of file GSLMultiFit.h. ◆ TestDelta(). int ROOT::Math::GSLMultiFit::TestDelta ; (; double ; absTol, . double ; relTol . ); const. inline . test using abs and relative tolerance |dx| < absTol + relTol*|x| for every component ; Definition at line 191 of file GSLMultiFit.h. ◆ TestGradient(). int ROOT::Math::GSLMultiFit::TestGradient ; (; double ; absTol); const. inline . test gradient (ask from solver gradient vector) ; Definition at line 183 of file GSLMultiFit.h. ◆ X(). const double * ROOT::Math::GSLMultiFit::X ; (; ); const. inline . parameter values at the minimum ; Definition at line 151 of file GSLMultiFit.h. Member Data Documentation. ◆ fCov. gsl_matrix* ROOT::Math::GSLMultiFit::fCov. mutableprivate . Definition at line 221 of file GSLMultiFit.h. ◆ fFunc. GSLMultiFitFunctionWrapper ROOT::Math::GSLMultiFit::fFunc. private . Definition at line 216 of file GSLMultiFit.h. ◆ fSolver. gsl_multifit_fdfsolver* ROOT::Math::GSLMultiFit::fSolver. private . Definition at line 217 of file GSLMultiFit.h. ◆ fTmp. gsl_vector* ROOT::Math::GSLMultiFit::fTmp. mutableprivate . Definition at line 220 of file GSLMultiFit.h. ◆ fType. const gsl_multifit_fdfsolver_type* ROOT::Math::GSLMultiFit::fType. priv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLMultiFit.html:4269,test,test,4269,doc/master/classROOT_1_1Math_1_1GSLMultiFit.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLMultiFit.html,1,['test'],['test']
Testability,st events and fill histograms with classifier response...; : ; <HEADER> TFHandler_Fisher : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: -0.014081 1.2910 [ -5.3119 4.5609 ]; : var2: -0.014399 1.3299 [ -4.7537 4.6723 ]; : var3: -0.027971 1.3779 [ -5.2892 4.7007 ]; : var4: 0.12966 1.4883 [ -5.1002 4.9767 ]; : -----------------------------------------------------------; <HEADER> Factory : Evaluate classifier: Likelihood; : ; <HEADER> Likelihood : [dataset] : Loop over test events and fill histograms with classifier response...; : ; <HEADER> TFHandler_Likelihood : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: -0.014081 1.2910 [ -5.3119 4.5609 ]; : var2: -0.014399 1.3299 [ -4.7537 4.6723 ]; : var3: -0.027971 1.3779 [ -5.2892 4.7007 ]; : var4: 0.12966 1.4883 [ -5.1002 4.9767 ]; : -----------------------------------------------------------; <HEADER> Factory : Evaluate classifier: FisherCat; : ; <HEADER> FisherCat : [dataset] : Loop over test events and fill histograms with classifier response...; : ; <HEADER> TFHandler_FisherCat : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: -0.014081 1.2910 [ -5.3119 4.5609 ]; : var2: -0.014399 1.3299 [ -4.7537 4.6723 ]; : var3: -0.027971 1.3779 [ -5.2892 4.7007 ]; : var4: 0.12966 1.4883 [ -5.1002 4.9767 ]; : -----------------------------------------------------------; <HEADER> Factory : Evaluate classifier: LikelihoodCat; : ; <HEADER> LikelihoodCat : [dataset] : Loop over test events and fill histograms with classifier response...; : ; <HEADER> TFHandler_LikelihoodCat : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: -0.014081 1.2910 [ -5.3119 4.5609 ]; : var2: -0.014399 1.3299 [ -4.7537 4.6723 ]; : var3: -0.027971 1.3779 [ -5.2892 4.7007 ]; : var4: 0.12966 1.4883 [ -5.1002 4.9767 ]; : ---------------------------------,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassificationCategory_8C.html:25159,test,test,25159,doc/master/TMVAClassificationCategory_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html,1,['test'],['test']
Testability,"st likely.; How do we do if there are points that are equi-probable?; use approximate posterior; t.b.d use real function to find the mode. void ComputeIntervalUsingRooFit(double c1, double c2) const; compute the interval using RooFit. void ComputeIntervalFromCdf(double c1, double c2) const; compute the interval using Cdf integration. void ApproximatePosterior() const; approximate posterior in nbins using a TF1 and; scan the values. void ComputeIntervalFromApproxPosterior(double c1, double c2) const; compute the interval using the approximate posterior function. void ComputeShortestInterval() const; compute the shortest interval. BayesianCalculator(); constructor. void SetData(RooAbsData& data). void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). { SetTestSize(1.-cl); }. Double_t Size() const; Get the size of the test (eg. rate of Type I error). { return fSize; }. Double_t ConfidenceLevel() const; Get the Confidence level for the test. { return 1.-fSize; }. void SetLeftSideTailFraction(Double_t leftSideFraction); set the fraction of probability content on the left tail; Central limits use 0.5 (default case); for upper limits it is 0 and 1 for lower limit; For shortest intervals a negative value (i.e. -1) must be given. {fLeftSideFraction = leftSideFraction;}. void SetShortestInterval(); set the Bayesian calculator to compute the shorest interval (default is central interval); to switch off SetLeftSideTailFraction to the rght value. { fLeftSideFraction = -1; }. void SetBrfPrecision(double precision); set the precision of the Root Finder. { fBrfPrecision = precision; }. void SetScanOfPosterior(int nbin = 100); use directly the approximate posterior function obtained by binning it in nbins; by default the cdf is used by integrating the posterior; if a value of nbin <= 0 the cdf fu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__BayesianCalculator.html:11162,test,test,11162,root/html528/RooStats__BayesianCalculator.html,https://root.cern,https://root.cern/root/html528/RooStats__BayesianCalculator.html,1,['test'],['test']
Testability,"st of parameters that are marginalised and the prior distribution of those parameters. HybridCalculator(RooAbsData& data, const RooStats::ModelConfig& sb_model, const RooStats::ModelConfig& b_model, bool GenerateBinned = false, int testStatistics = 1, int ntoys = 1000); Constructor with a ModelConfig object representing the signal + background model and; another model config representig the background only model; a Prior pdf for the nuiscane parameter of the signal and background can be specified in; the s+b model or the b model. If it is specified in the s+b model, the one of the s+b model will be used. ~HybridCalculator(); HybridCalculator destructor. void SetNullModel(const RooStats::ModelConfig& ); Set the model describing the null hypothesis. void SetAlternateModel(const RooStats::ModelConfig& ); Set the model describing the alternate hypothesis. void SetTestStatistic(int index); set the desired test statistics:; index=1 : likelihood ratio: 2 * log( L_sb / L_b ) (DEFAULT); index=2 : number of generated events; index=3 : profiled likelihood ratio; if the index is different to any of those values, the default is used. HybridResult* Calculate(TH1& data, unsigned int nToys, bool usePriors); first compute the test statistics for data and then prepare and run the toy-MC experiments. HybridResult* Calculate(RooAbsData& data, unsigned int nToys, bool usePriors); first compute the test statistics for data and then prepare and run the toy-MC experiments. HybridResult* Calculate(unsigned int nToys, bool usePriors) const. void RunToys(vector<double>& bVals, vector<double>& sbVals, unsigned int nToys, bool usePriors) const; do the actual run-MC processing. void PrintMore(const char* options) const; Print out some information about the input models. HybridResult* GetHypoTest() const; perform the hypothesis test and return result of hypothesis test. bool DoCheckInputs() const. explicit HybridCalculator(const char *name = 0); Dummy Constructor with only name. void SetCommonPdf(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__HybridCalculator.html:12229,test,test,12229,root/html526/RooStats__HybridCalculator.html,https://root.cern,https://root.cern/root/html526/RooStats__HybridCalculator.html,2,"['log', 'test']","['log', 'test']"
Testability,"st of transformations to test ;  ; Bool_t fVerbose;  ! verbose mode ;  ; TString fVerboseLevel;  ! verbosity level, controls granularity of logging ;  . Friends; class CrossValidation;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TMVA::Configurable; void EnableLooseOptions (Bool_t b=kTRUE);  ; const TString & GetReferenceFile () const;  ; Bool_t LooseOptionCheckingEnabled () const;  ; void ResetSetFlag ();  resets the IsSet flag for all declare options to be called before options are read from stream ;  ; void WriteOptionsReferenceToFile ();  write complete options to output stream ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TMVA::Configurable; MsgLogger * fLogger;  ! message logger ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . #include <TMVA/Factory.h>. Inheritance diagram for TMVA::Factory:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ MVector. typedef std::vector<IMethod*> TMVA::Factory::MVector. Definition at line 84 of file Factory.h. Constructor & Destructor Documentation. ◆ Factory() [1/2]. TMVA::Factory::Factory ; (; TString ; jobName, . TFile * ; theTargetFile, . TString ; theOption = """" . ). Standard constructor. . jobname : this name will appear in all weight file names produced by the MVAs; theTargetFile : output ROOT file; the test tree and all evaluation plots will be stored here; theOption : option string; currently: ""V"" for verbose . Definition at line 113 of file Factory.cxx. ◆ Factory() [2/2]. TMVA::Factory::Factory ; (; TString ; theJobName, . TString ; theOption = """" . ). Constructor. ; Definition at lin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Factory.html:20279,log,logger,20279,doc/master/classTMVA_1_1Factory.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Factory.html,1,['log'],['logger']
Testability,"st program for data fitting. tcollex.cxx; Example usage of the ROOT collection classes. tcollbm.cxx; Benchmarks of ROOT collection classes. ctorture.cxx; Test program for the class TComplex. tstring.cxx; Example usage of the ROOT string class. vmatrix.cxx; Verification program for the TMatrix class. vvector.cxx; Verification program for the TVectorclass. vlazy.cxx; Verification program for lazy matrices. hworld.cxx; Small program showing basic graphics. guitest.cxx; Example usage of the ROOT GUI classes. gui viewer .cxx; Another ROOT GUI example program. Hello.cxx; Dancing text example. Aclock.cxx; Analog clock (a la X11 xclock). Tetris.cxx; The known Tetris game based on the ROOT graphics. stress.cxx; Important ROOT stress testing program. stress*.cxx; Stress testing of different ROOT classes. bench.cxx; STL and ROOT container test and benchmarking program. QpRandomDriver.cx x; Verification program for Quadratic programming classes in Quadp library. DrawTest.sh; Entry script to extensive TTree query test suite. dt_*; Scripts used by DrawTest.sh. The $ROOTSYS/test directory is a gold mine of root-wisdom nuggets, and we encourage you to explore and exploit it. These instructions will compile all programs in $ROOTSYS/test:; If you do not have write permission in the $ROOTSYS/test directory, copy the entire $ROOTSYS/test directory to your area. The Makefile is a useful example of how ROOT applications are linked and built. Edit the Makefile to specify your architecture by changing the ARCH variable, for example, on an SGI machine type:ARCH = sgikcc.; Now compile all programs:; % gmake; This will build several applications and shared libraries. We are especially interested in Event, stress, and guitest.; 20.2.1 Event - An Example of a ROOT Application; Event is created by compiling MainEvent.cxx, and Event.cxx. It creates a ROOT file with a tree and two histograms. When running Event we have four optional arguments with defaults:. Argument; Default. 1; Number of Events (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1077006,test,test,1077006,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['test'],['test']
Testability,"st section. *NOTES*; Currently navigation functionality not fully implemented (only Contains()).; Decomposition in concave polygons not implemented - drawing in solid mode; within x3d produces incorrect end-faces. Function Members (Methods); public:. virtual~TGeoXtru(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidCreateThreadData(Int_t nthreads); Bool_tDefinePolygon(Int_t nvert, const Double_t* xv, const Double_t* yv); virtual voidDefineSection(Int_t snum, Double_t z, Double_t x0 = 0., Double_t y0 = 0., Double_t scale = 1.); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoXtru.html:2305,test,testNo,2305,root/html602/TGeoXtru.html,https://root.cern,https://root.cern/root/html602/TGeoXtru.html,2,['test'],['testNo']
Testability,"st() const; virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooJeffreysPrior.html:20688,test,testArg,20688,root/html528/RooJeffreysPrior.html,https://root.cern,https://root.cern/root/html528/RooJeffreysPrior.html,1,['test'],['testArg']
Testability,"st() const; virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooJeffreysPrior.html:20832,test,testArg,20832,root/html530/RooJeffreysPrior.html,https://root.cern,https://root.cern/root/html530/RooJeffreysPrior.html,2,['test'],['testArg']
Testability,"st();; TStreamerInfo *info = (TStreamerInfo*)list->FindObject(""MyClass"");; Int_t classversionid = info->GetClassVersion();; delete list;. void ls(Option_t* option = """") const; List File contents.; Indentation is used to identify the file tree.; Subdirectories are listed first, then objects in memory,; then objects on the file. Bool_t IsOpen() const; Returns kTRUE in case file is open and kFALSE if file is not open. void MakeFree(Long64_t first, Long64_t last); Mark unused bytes on the file.; The list of free segments is in the fFree linked list.; When an object is deleted from the file, the freed space is added; into the FREE linked list (fFree). The FREE list consists of a chain; of consecutive free segments on the file. At the same time, the first; 4 bytes of the freed record on the file are overwritten by GAPSIZE; where GAPSIZE = -(Number of bytes occupied by the record). void Map(); List the contents of a file sequentially.; For each logical record found, it prints:; Date/Time Record_Adress Logical_Record_Length ClassName CompressionFactor. Example of output; 20010404/150437 At:64 N=150 TFile; 20010404/150440 At:214 N=28326 TBasket CX = 1.13; 20010404/150440 At:28540 N=29616 TBasket CX = 1.08; 20010404/150440 At:58156 N=29640 TBasket CX = 1.08; 20010404/150440 At:87796 N=29076 TBasket CX = 1.10; 20010404/150440 At:116872 N=10151 TBasket CX = 3.15; 20010404/150441 At:127023 N=28341 TBasket CX = 1.13; 20010404/150441 At:155364 N=29594 TBasket CX = 1.08; 20010404/150441 At:184958 N=29616 TBasket CX = 1.08; 20010404/150441 At:214574 N=29075 TBasket CX = 1.10; 20010404/150441 At:243649 N=9583 TBasket CX = 3.34; 20010404/150442 At:253232 N=28324 TBasket CX = 1.13; 20010404/150442 At:281556 N=29641 TBasket CX = 1.08; 20010404/150442 At:311197 N=29633 TBasket CX = 1.08; 20010404/150442 At:340830 N=29091 TBasket CX = 1.10; 20010404/150442 At:369921 N=10341 TBasket CX = 3.09; 20010404/150442 At:380262 N=509 TH1F CX = 1.93; 20010404/150442 At:380771 N=1769 TH2F CX = 4.32; 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:31647,log,logical,31647,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,6,['log'],['logical']
Testability,"st); Bool_tSetRangesPolar(const TH1* hist); Bool_tSetRangesSpherical(const TH1* hist). Data Members; private:. EGLCoordTypefCoordType; Double_tfFactor; Bool_tfModified; pair<int,int>fXBins; Bool_tfXLog; pair<double,double>fXRange; pair<double,double>fXRangeScaled; Double_tfXScale; pair<int,int>fYBins; Bool_tfYLog; pair<double,double>fYRange; pair<double,double>fYRangeScaled; Double_tfYScale; pair<int,int>fZBins; Bool_tfZLog; pair<double,double>fZRange; pair<double,double>fZRangeScaled; Double_tfZScale. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPlotCoordinates(); Constructor. ~TGLPlotCoordinates(); Destructor. void SetCoordType(EGLCoordType type); If coord type was changed, plot must reset sections (if any),; set fModified. EGLCoordType GetCoordType() const; Get coordinates type. void SetXLog(Bool_t xLog); If log changed, sections must be reset,; set fModified. Bool_t GetXLog() const; Get X log. void SetYLog(Bool_t yLog); If log changed, sections must be reset,; set fModified. Bool_t GetYLog() const; Get Y log. void SetZLog(Bool_t zLog); If log changed, sections must be reset,; set fModified. Bool_t GetZLog() const; Get Z log. void ResetModified(); Reset modified. Bool_t Modified() const; Modified. Bool_t SetRanges(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Set bin ranges, ranges. Int_t GetNXBins() const; Number of X bins. Int_t GetNYBins() const; Number of Y bins. Int_t GetNZBins() const; Number of Z bins. const Rgl::BinRange_t & GetXBins() const; X bins range. const Rgl::BinRange_t & GetYBins() const; Y bins range. const Rgl::BinRange_t & GetZBins() const; Z bins range. const Rgl::Range_t & GetXRange() const; X range. Double_t GetXLength() const; X length. const Rgl::Range_t & GetYRange() const; Y range. Double_t GetYLength() const; Y length. const Rgl::Range_t & GetZRange() const; Z range. Double_t GetZLength() const; Z length. const Rgl::Range_t & GetXRangeScaled() const; Scaled range. const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLPlotCoordinates.html:3161,log,log,3161,root/html528/TGLPlotCoordinates.html,https://root.cern,https://root.cern/root/html528/TGLPlotCoordinates.html,4,['log'],['log']
Testability,"st, starting at firstentry, otherwise the loop is on the; specified Tree entries. void RecursiveRemove(TObject* obj); cleanup pointers in the player pointing to obj. Long64_t Scan(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Loop on Tree and print entries passing selection. If varexp is 0 (or """"); then print only first 8 columns. If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; The function returns the number of entries passing the selection. By default 50 rows are shown and you are asked for <CR>; to see the next 50 rows.; You can change the default number of rows to be shown before <CR>; via mytree->SetScanField(maxrows) where maxrows is 50 by default.; if maxrows is set to 0 all rows of the Tree are shown.; This option is interesting when dumping the contents of a Tree to; an ascii file, eg from the command line; tree->SetScanField(0);; tree->Scan(""*""); >tree.log; will create a file tree.log. Arrays (within an entry) are printed in their linear forms.; If several arrays with multiple dimensions are printed together,; they will NOT be synchronized. For example print; arr1[4][2] and arr2[2][3] will results in a printing similar to:. * Row * Instance * arr1 * arr2 *. * x * 0 * arr1[0][0]* arr2[0][0]*; * x * 1 * arr1[0][1]* arr2[0][1]*; * x * 2 * arr1[1][0]* arr2[0][2]*; * x * 3 * arr1[1][1]* arr2[1][0]*; * x * 4 * arr1[2][0]* arr2[1][1]*; * x * 5 * arr1[2][1]* arr2[1][2]*; * x * 6 * arr1[3][0]* *; * x * 7 * arr1[3][1]* *. However, if there is a selection criterion which is an array, then; all the formulas will be synchronized with the selection criterion; (see TTreePlayer::DrawSelect for more information). The options string can contains the following parameters:; lenmax=dd; Where 'dd' is the maximum number of elements per array that should; be printed. If 'dd' is 0, all elements are printed (this is the; default); colsize=ss; Where 'ss' will be used as the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreePlayer.html:52868,log,log,52868,root/html528/TTreePlayer.html,https://root.cern,https://root.cern/root/html528/TTreePlayer.html,6,['log'],['log']
Testability,"st.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:35168,test,test,35168,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,6,['test'],['test']
Testability,"st; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); RooAbsReal&pdf() const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNumConvolution.html:21931,test,testArg,21931,root/html534/RooNumConvolution.html,https://root.cern,https://root.cern/root/html534/RooNumConvolution.html,1,['test'],['testArg']
Testability,"st; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; const RooCatType*RooAbsCategory::lookupType(Int_t index, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const char* label, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; Int_tRooAbsCategory::numTypes(const char* = 0) const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& obser",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooBinningCategory.html:10481,test,testArg,10481,root/html534/RooBinningCategory.html,https://root.cern,https://root.cern/root/html534/RooBinningCategory.html,4,['test'],['testArg']
Testability,"st; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; const RooCatType*RooAbsCategory::lookupType(Int_t index, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const char* label, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; Int_tRooAbsCategory::numTypes(const char* = 0) const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooBinningCategory&operator=(const RooBinningCategory&); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBinningCategory.html:10236,test,testArg,10236,root/html602/RooBinningCategory.html,https://root.cern,https://root.cern/root/html602/RooBinningCategory.html,2,['test'],['testArg']
Testability,"st; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; const RooCatType*RooAbsCategory::lookupType(Int_t index, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const char* label, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; Int_tRooAbsCategory::numTypes(const char* = 0) const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooMultiCategory&operator=(const RooMultiCategory&); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMultiCategory.html:10467,test,testArg,10467,root/html602/RooMultiCategory.html,https://root.cern,https://root.cern/root/html602/RooMultiCategory.html,2,['test'],['testArg']
Testability,"st; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; const RooCatType*RooAbsCategory::lookupType(Int_t index, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const char* label, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; Int_tRooAbsCategory::numTypes(const char* = 0) const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooThresholdCategory&operator=(const RooThresholdCategory&); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooThresholdCategory.html:10331,test,testArg,10331,root/html602/RooThresholdCategory.html,https://root.cern,https://root.cern/root/html602/RooThresholdCategory.html,2,['test'],['testArg']
Testability,"st; TH1*TF1::GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*TFormula::GetLinearPart(Int_t i); virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual Double_tTF1::GetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMaximumStored() const; virtual Double_tTF1::GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; TMethodCall*TF1::GetMethodCall() const; virtual Double_tTF1::GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMinimumStored() const; virtual Double_tTF1::GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual const char*TNamed::GetName() const; virtual Int_tTF1::GetNDF() const; virtual Int_tTFormula::GetNdim() const; virtual Int_tTFormula::GetNpar() const; virtual Int_tTF1::GetNpx() const; virtual Int_tTFormula::GetNumber() const; virtual Int_tTF1::GetNumberFitPoints() const; virtual Int_tTF1::GetNumberFreeParameters() const; virtual char*TF1::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tTFormula::GetParameter(Int_t ipar) const; Double_tTFormula::GetParameter(const char* name) const; virtual Double_t*TFormula::GetParameters() const; virtual voidTFormula::GetParameters(Double_t* params); TObject*TF1::GetParent() const; virtual Double_tTF1::GetParError(Int_t ipar) const; virtual Double_t*TF1::GetParErrors() const; virtual voidTF1::GetParLimits(Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TF12.html:4897,log,logx,4897,root/html534/TF12.html,https://root.cern,https://root.cern/root/html534/TF12.html,1,['log'],['logx']
Testability,"st; TH1*TF1::GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*TFormula::GetLinearPart(Int_t i); virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual Double_tTF1::GetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMaximumStored() const; virtual Double_tTF1::GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; TMethodCall*TF1::GetMethodCall() const; virtual Double_tTF1::GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMinimumStored() const; virtual Double_tTF1::GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual voidGetMinimumXY(Double_t& x, Double_t& y); virtual const char*TNamed::GetName() const; virtual Int_tTF1::GetNDF() const; virtual Int_tTFormula::GetNdim() const; virtual Int_tTFormula::GetNpar() const; virtual Int_tTF1::GetNpx() const; Int_tGetNpy() const; virtual Int_tTFormula::GetNumber() const; virtual Int_tTF1::GetNumberFitPoints() const; virtual Int_tTF1::GetNumberFreeParameters() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tTFormula::GetParameter(Int_t ipar) const; Double_tTFormula::GetParameter(const char* name) const; virtual Double_t*TFormula::GetParameters() const; virtual voidTFormula::GetParameters(Double_t* params); TObject*TF1::GetParent() const; virtual Double_tTF1::GetParError(Int_t ipar) const; virtual Dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TF2.html:6002,log,logx,6002,root/html534/TF2.html,https://root.cern,https://root.cern/root/html534/TF2.html,1,['log'],['logx']
Testability,"st; TH1*TF1::GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*TFormula::GetLinearPart(Int_t i); virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual Double_tTF1::GetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMaximumStored() const; virtual Double_tTF1::GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; TMethodCall*TF1::GetMethodCall() const; virtual Double_tTF1::GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMinimumStored() const; virtual Double_tTF1::GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual voidTF2::GetMinimumXY(Double_t& x, Double_t& y); virtual voidGetMinimumXYZ(Double_t& x, Double_t& y, Double_t& z); virtual const char*TNamed::GetName() const; virtual Int_tTF1::GetNDF() const; virtual Int_tTFormula::GetNdim() const; virtual Int_tTFormula::GetNpar() const; virtual Int_tTF1::GetNpx() const; Int_tTF2::GetNpy() const; Int_tGetNpz() const; virtual Int_tTFormula::GetNumber() const; virtual Int_tTF1::GetNumberFitPoints() const; virtual Int_tTF1::GetNumberFreeParameters() const; virtual char*TF2::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tTFormula::GetParameter(Int_t ipar) const; Double_tTFormula::GetParameter(const char* name) const; virtual Double_t*TFormula::GetParameters() const; virtual voidTFormula::GetParameters(Double_t* pa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TF3.html:6593,log,logx,6593,root/html534/TF3.html,https://root.cern,https://root.cern/root/html534/TF3.html,1,['log'],['logx']
Testability,"st; of unique workers.; Use ord = ""*"" to deactivate all active workers. void ModifyWorkerLists(const char* ord, Bool_t add); Modify the worker active/inactive list by making the worker identified by; the ordinal number 'ord' active (add == TRUE) or inactive (add == FALSE).; If needed, the request will be forwarded to the master in direct contact; with the worker. The end-master will move the worker from one list to the; other active and rebuild the list of unique active workers.; Use ord = ""*"" to deactivate all active workers. TProof * Open(const char* url = 0, const char* conffile = 0, const char* confdir = 0, Int_t loglevel = 0); Start a PROOF session on a specific cluster. If cluster is 0 (the; default) then the PROOF Session Viewer GUI pops up and 0 is returned.; If cluster is """" (empty string) then we connect to a PROOF session; on the localhost (""proof://localhost""). Via conffile a specific; PROOF config file in the confir directory can be specified.; Use loglevel to set the default loging level for debugging.; The appropriate instance of TProofMgr is created, if not; yet existing. The instantiated TProof object is returned.; Use TProof::cd() to switch between PROOF sessions.; For more info on PROOF see the TProof ctor. TProofMgr * Mgr(const char* url); Get instance of the effective manager for 'url'; Return 0 on failure. void Reset(const char* url, Bool_t hard = kFALSE); Wrapper around TProofMgr::Reset(...). const TList * GetEnvVars(); Get environemnt variables. void AddEnvVar(const char* name, const char* value); Add an variable to the list of environment variables passed to proofserv; on the master and slaves. void DelEnvVar(const char* name); Remove an variable from the list of environment variables passed to proofserv; on the master and slaves. void ResetEnvVars(); Clear the list of environment variables passed to proofserv; on the master and slaves. void SaveWorkerInfo(); Save informations about the worker set in the file .workers in the working; dir. Cal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:84491,log,loglevel,84491,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,2,['log'],"['loging', 'loglevel']"
Testability,"st; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tisJacobianOK(const RooArgSet& depList) const; virtual Bool_tRooAbsRealLValue::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; virtual Bool_tRooAbsRealLValue::isValidReal(Double_t value, Bool_t printError = kFALSE) const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; virtual Double_tjacobian() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); virtual Int_tRooAbsRealLValue::numBins(const char* rangeName = 0) const; virtual Int_tRooAbsRealLValue::numBins(const RooAbsBinning& binning) const; Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooLinearVar.html:19998,log,logEvalError,19998,root/html526/RooLinearVar.html,https://root.cern,https://root.cern/root/html526/RooLinearVar.html,3,['log'],['logEvalError']
Testability,"st; virtual const TObject*TFormula::GetLinearPart(Int_t i); virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; static voidTFormula::GetMaxima(Int_t& maxop, Int_t& maxpar, Int_t& maxconst); virtual Double_tTF1::GetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.0E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMaximumStored() const; virtual Double_tTF1::GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.0E-10, Int_t maxiter = 100, Bool_t logx = false) const; TMethodCall*TF1::GetMethodCall() const; virtual Double_tTF1::GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.0E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMinimumStored() const; virtual Double_tTF1::GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.0E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual const char*TNamed::GetName() const; virtual Int_tTF1::GetNDF() const; virtual Int_tTFormula::GetNdim() const; virtual Int_tTFormula::GetNpar() const; virtual Int_tTF1::GetNpx() const; virtual Int_tTFormula::GetNumber() const; virtual Int_tTF1::GetNumberFitPoints() const; virtual Int_tTF1::GetNumberFreeParameters() const; virtual char*TF1::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tTFormula::GetParameter(Int_t ipar) const; Double_tTFormula::GetParameter(const char* name) const; virtual Double_t*TFormula::GetParameters() const; virtual voidTFormula::GetParameters(Double_t* params); TObject*TF1::GetParent() const; virtual Double_tTF1::GetParError(Int_t ipar) const; virtual Double_t*TF1::GetParErrors() const; virtual voidTF1::GetParLimits(Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF12.html:4890,log,logx,4890,root/html602/TF12.html,https://root.cern,https://root.cern/root/html602/TF12.html,1,['log'],['logx']
Testability,"st;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  ; Int_t GetNmeshVertices () const override;  ; virtual const Double_t * GetOrigin () const;  ; virtual Bool_t GetPointsOnFacet (Int_t index, Int_t npoints, Double_t *array) const;  ; Bool_t GetPointsOnSegments (Int_t npoints, Double_t *array) const override;  ; virtual Bool_t IsNullBox () const;  ; Bool_t IsValidBox () const override;  ; TBuffer3D * MakeBuffer3D () const override;  ; void SetBoxDimensions (Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ; void SetBoxPoints (Double_t *points) const;  ; void SetSegsAndPols (TBuffer3D &buffer) const override;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoShape;  TGeoShape ();  Default constructor. ;  ;  TGeoShape (const char *name);  Default constructor. ;  ;  ~TGeoShape () override;  Destructor. ;  ; virtual void AfterStreamer ();  ; void CheckShape (Int_t testNo, Int_t nsamples=10000, Option_t *option="""");  Test for shape navigation methods. ;  ; virtual void ClearThreadData () const;  ; virtual void CreateThreadData (Int_t);  ; void Draw (Option_t *option="""") override;  Draw this shape. ;  ; void ExecuteEvent (Int_t event, Int_t px, Int_t py) override;  Execute mouse actions on this shape. ;  ; Int_t GetId () const;  ; const char * GetName () const override;  Get the shape name. ;  ; const char * GetPointerName () const;  Provide a pointer name containing uid. ;  ; void InvertShapeBit (UInt_t f);  ; virtual Bool_t IsAssembly () const;  ; virtual Bool_t IsComposite () const;  ; virtual Bool_t IsReflected () const;  ; Bool_t IsRunTimeShape () const;  ; Bool_t IsValid () const;  ; virtual Bool_t IsVecGeom () const;  ; void Paint (Option_t *option="""") override;  Paint this shape. ;  ; void ResetShapeBit (UInt_t f);  ; void SetId (Int_t id);  ; void SetRuntime (Bool_t flag=kTRUE);  ; void SetShapeBit (UInt_t f);  ; void SetShapeBit (UInt_t f, Bool_t se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTrd1.html:5151,test,testNo,5151,doc/master/classTGeoTrd1.html,https://root.cern,https://root.cern/doc/master/classTGeoTrd1.html,2,['test'],['testNo']
Testability,"st<const IGradModel1DFunction*>(&func);; 91 if (gradFunc) {; 92 SetFunction(*gradFunc, true);; 93 return;; 94 }; 95 else {; 96 MATH_WARN_MSG(""Fitter::SetFunction"",""Requested function does not provide gradient - use it as non-gradient function "");; 97 }; 98 }; 99 fUseGradient = false;; 100 //std::cout << ""set a 1d function"" << std::endl;; 101 ; 102 // function is cloned when creating the adapter; 103 fFunc = std::shared_ptr<IModelFunction>(new ROOT::Math::MultiDimParamFunctionAdapter(func));; 104 ; 105 // creates the parameter settings; 106 fConfig.CreateParamsSettings(*fFunc);; 107 fFunc_v.reset();; 108}; 109 ; 110void Fitter::SetFunction(const IGradModelFunction & func, bool useGradient); 111{; 112 fUseGradient = useGradient;; 113 //std::cout << ""set a grad function"" << std::endl;; 114 // set the fit model function (clone the given one and keep a copy ); 115 fFunc = std::shared_ptr<IModelFunction>( dynamic_cast<IGradModelFunction *> ( func.Clone() ) );; 116 assert(fFunc);; 117 ; 118 // creates the parameter settings; 119 fConfig.CreateParamsSettings(*fFunc);; 120 fFunc_v.reset();; 121}; 122 ; 123 ; 124void Fitter::SetFunction(const IGradModel1DFunction & func, bool useGradient); 125{; 126 //std::cout << ""set a 1d grad function"" << std::endl;; 127 fUseGradient = useGradient;; 128 // function is cloned when creating the adapter; 129 fFunc = std::shared_ptr<IModelFunction>(new ROOT::Math::MultiDimParamGradFunctionAdapter(func));; 130 ; 131 // creates the parameter settings; 132 fConfig.CreateParamsSettings(*fFunc);; 133 fFunc_v.reset();; 134}; 135 ; 136 ; 137bool Fitter::DoSetFCN(bool extFcn, const ROOT::Math::IMultiGenFunction & fcn, const double * params, unsigned int dataSize, int fitType) {; 138 // Set the objective function for the fit. First parameter specifies if function object is managed external or internal.; 139 // In case of an internal function object we need to clone because it is a temporary one; 140 // if params is not NULL create the parameter settings",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8cxx_source.html:3977,assert,assert,3977,doc/master/Fitter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html,1,['assert'],['assert']
Testability,"stArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsString&operator=(const RooAbsString&); Bool_toperator==(const char*) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidRooAbsArg::printDirty(Bool_t depth = kTRUE) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsArg::printMetaArgs(ostream&) const; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsString.html:10580,test,testArg,10580,root/html602/RooAbsString.html,https://root.cern,https://root.cern/root/html602/RooAbsString.html,2,['test'],['testArg']
Testability,"stBit(kAxisRange)) return 1;; 461 return fFirst;; 462}; 463 ; 464////////////////////////////////////////////////////////////////////////////////; 465/// Return last bin on the axis; 466/// i.e. fNbins if no range defined; 467/// NOTE: in some cases a zero is returned (see TAxis::SetRange); 468 ; 469Int_t TAxis::GetLast() const; 470{; 471 if (!TestBit(kAxisRange)) return fNbins;; 472 return fLast;; 473}; 474 ; 475////////////////////////////////////////////////////////////////////////////////; 476/// Return center of bin; 477 ; 478Double_t TAxis::GetBinCenter(Int_t bin) const; 479{; 480 Double_t binwidth;; 481 if (!fXbins.fN || bin<1 || bin>fNbins) {; 482 binwidth = (fXmax - fXmin) / Double_t(fNbins);; 483 return fXmin + (bin-1) * binwidth + 0.5*binwidth;; 484 } else {; 485 binwidth = fXbins.fArray[bin] - fXbins.fArray[bin-1];; 486 return fXbins.fArray[bin-1] + 0.5*binwidth;; 487 }; 488}; 489 ; 490////////////////////////////////////////////////////////////////////////////////; 491/// Return center of bin in log; 492/// With a log-equidistant binning for a bin with low and up edges, the mean is :; 493/// 0.5*(ln low + ln up) i.e. sqrt(low*up) in logx (e.g. sqrt(10^0*10^2) = 10).; 494/// Imagine a bin with low=1 and up=100 :; 495/// - the center in lin is (100-1)/2=50.5; 496/// - the center in log would be sqrt(1*100)=10 (!=log(50.5)); 497///; 498/// NB: if the low edge of the bin is negative, the function returns the bin center; 499/// as computed by TAxis::GetBinCenter; 500 ; 501Double_t TAxis::GetBinCenterLog(Int_t bin) const; 502{; 503 Double_t low,up;; 504 if (!fXbins.fN || bin<1 || bin>fNbins) {; 505 Double_t binwidth = (fXmax - fXmin) / Double_t(fNbins);; 506 low = fXmin + (bin-1) * binwidth;; 507 up = low+binwidth;; 508 } else {; 509 low = fXbins.fArray[bin-1];; 510 up = fXbins.fArray[bin];; 511 }; 512 if (low <=0 ) return GetBinCenter(bin);; 513 return TMath::Sqrt(low*up);; 514}; 515////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TAxis_8cxx_source.html:15923,log,log,15923,doc/master/TAxis_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html,2,['log'],"['log', 'log-equidistant']"
Testability,"stLineColor(Color_t color=1)Definition TStyle.h:380; TStyle::fHeaderPSTString fHeaderPSUser defined additional Postscript header.Definition TStyle.h:131; TStyle::GetColorPaletteInt_t GetColorPalette(Int_t i) constReturn color number i in current palette.Definition TStyle.cxx:1101; TStyle::cdvirtual void cd()Change current style.Definition TStyle.cxx:543; TStyle::GetLineStyleStringconst char * GetLineStyleString(Int_t i=1) constReturn line style string (used by PostScript).Definition TStyle.cxx:1166; TStyle::SetLabelOffsetvoid SetLabelOffset(Float_t offset=0.005, Option_t *axis=""X"")Set offset between axis and axis labels.Definition TStyle.cxx:1429; TStyle::fPadColorColor_t fPadColorPad color.Definition TStyle.h:92; TStyle::SetFitFormatvoid SetFitFormat(const char *format=""5.4g"")Definition TStyle.h:301; TStyle::GetErrorXFloat_t GetErrorX() constDefinition TStyle.h:186; TStyle::fDateXFloat_t fDateXX position of the date in the canvas (in NDC)Definition TStyle.h:53; TStyle::fOptLogzInt_t fOptLogzTrue if log scale in z.Definition TStyle.h:41; TStyle::SetCanvasDefYvoid SetCanvasDefY(Int_t topy=10)Definition TStyle.h:349; TStyle::SetTitleSizevoid SetTitleSize(Float_t size=0.02, Option_t *axis=""X"")Definition TStyle.cxx:1817; TStyle::SetTitleFillColorvoid SetTitleFillColor(Color_t color=1)Definition TStyle.h:404; TStyle::fFitFormatTString fFitFormatPrinting format for fit parameters.Definition TStyle.h:133; TStyle::fPadBorderModeInt_t fPadBorderModePad border mode.Definition TStyle.h:94; TStyle::GetLegendTextSizeDouble_t GetLegendTextSize() constDefinition TStyle.h:206; TStyle::fNumberContoursInt_t fNumberContoursDefault number of contours for 2-d plots.Definition TStyle.h:51; TStyle::SetLineStyleStringvoid SetLineStyleString(Int_t i, const char *text)Set line style string using the PostScript convention.Definition TStyle.cxx:1483; TStyle::GetCandleBoxRangeDouble_t GetCandleBoxRange() constDefinition TStyle.h:291; TStyle::fPadLeftMarginFloat_t fPadLeftMarginPad left margin.De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStyle_8h_source.html:53048,log,log,53048,doc/master/TStyle_8h_source.html,https://root.cern,https://root.cern/doc/master/TStyle_8h_source.html,1,['log'],['log']
Testability,"stLineColor(Color_t color=1)Definition TStyle.h:380; TStyle::fHeaderPSTString fHeaderPSUser defined additional Postscript header.Definition TStyle.h:131; TStyle::GetColorPaletteInt_t GetColorPalette(Int_t i) constReturn color number i in current palette.Definition TStyle.cxx:1101; TStyle::cdvirtual void cd()Change current style.Definition TStyle.cxx:543; TStyle::GetLineStyleStringconst char * GetLineStyleString(Int_t i=1) constReturn line style string (used by PostScript).Definition TStyle.cxx:1166; TStyle::SetLabelOffsetvoid SetLabelOffset(Float_t offset=0.005, Option_t *axis=""X"")Set offset between axis and axis labels.Definition TStyle.cxx:1429; TStyle::fPadColorColor_t fPadColorPad color.Definition TStyle.h:92; TStyle::SetFitFormatvoid SetFitFormat(const char *format=""5.4g"")Definition TStyle.h:301; TStyle::GetErrorXFloat_t GetErrorX() constDefinition TStyle.h:186; TStyle::fDateXFloat_t fDateXX position of the date in the canvas (in NDC)Definition TStyle.h:53; TStyle::fOptLogzInt_t fOptLogzTrue if log scale in z.Definition TStyle.h:41; TStyle::SetTitleSizevoid SetTitleSize(Float_t size=0.02, Option_t *axis=""X"")Definition TStyle.cxx:1817; TStyle::SetTitleFillColorvoid SetTitleFillColor(Color_t color=1)Definition TStyle.h:404; TStyle::fFitFormatTString fFitFormatPrinting format for fit parameters.Definition TStyle.h:133; TStyle::fPadBorderModeInt_t fPadBorderModePad border mode.Definition TStyle.h:94; TStyle::GetLegendTextSizeDouble_t GetLegendTextSize() constDefinition TStyle.h:206; TStyle::fNumberContoursInt_t fNumberContoursDefault number of contours for 2-d plots.Definition TStyle.h:51; TStyle::SetLineStyleStringvoid SetLineStyleString(Int_t i, const char *text)Set line style string using the PostScript convention.Definition TStyle.cxx:1483; TStyle::GetCandleBoxRangeDouble_t GetCandleBoxRange() constDefinition TStyle.h:291; TStyle::fPadLeftMarginFloat_t fPadLeftMarginPad left margin.Definition TStyle.h:97; TStyle::fTitleYFloat_t fTitleYY position of top left corn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStyle_8cxx_source.html:115424,log,log,115424,doc/master/TStyle_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStyle_8cxx_source.html,1,['log'],['log']
Testability,"stMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; virtual Bool_tisValid() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); const Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealIntegral.html:15677,log,logEvalError,15677,root/html526/RooRealIntegral.html,https://root.cern,https://root.cern/root/html526/RooRealIntegral.html,1,['log'],['logEvalError']
Testability,"stOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. private:. Bool_tfInterruptflag interrupt state; Bool_tfIsValidflag validity; FILE*fLogFilelog file; Int_tfLogFileDeslog file descriptor; TStringfLogFilePathPath to log file; Int_tfProtocoluser protocol version number; Bool_tfRealTimeLogTRUE if log messages should be send back in real-time; TList*fSentCanvasesList of canvases already sent; TStringfSessIdIdentifier for this session; TSocket*fSocketsocket connection to user; TUrlfUrluser's url; TStringfWorkDirWorking dir; TRemoteObject*fWorkingDirWorking (remote) directory. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TApplicationServer(Int_t* argc, char** argv, FILE* flog, const char* logfile); Main constructor. Create an application environment. The TApplicationServer; environment provides an eventloop via inheritance of TApplication. Int_t Setup(); Print the Remote Server logo on standard output.; Return 0 on success, -1 on failure. ~TApplicationServer(); Cleanup. Not really necessary since after this dtor there is no; live anyway. void GetOptions(Int_t* argc, char** argv); Get and handle command line options. Fixed format:; ""protocol url"". void Run(Bool_t retrn = kFALSE); Main server eventloop. void HandleSocketInput(); Handle input coming from the client or from the master server. void HandleUrgentData(); Handle Out-Of-Band data sent by the master or client. void HandleSigPipe(); Called when the client is not alive anymore (i.e. when kKeepAlive; has failed). void Reset(const char* dir); Reset environment to be ready for execution of next command. Int_t ReceiveFile(const char* file, Bool_t bin, Long64_t size); Receive a file, eith",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TApplicationServer.html:13149,log,logfile,13149,root/html526/TApplicationServer.html,https://root.cern,https://root.cern/root/html526/TApplicationServer.html,7,['log'],['logfile']
Testability,"stStat. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::DebuggingTestStat. class RooStats::DebuggingTestStat: public RooStats::TestStatistic. DebuggingTestStat is a simple implementation of the DistributionCreator interface used for debugging.; The sampling distribution is uniformly random between [0,1] and is INDEPENDENT of the data. So it is not useful; for true statistical tests, but it is useful for debugging. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~DebuggingTestStat(); static TClass*Class(); virtual Double_tEvaluate(RooAbsData&, RooArgSet&); virtual const RooArgSet*RooStats::TestStatistic::GetDetailedOutput() const; virtual const TStringRooStats::TestStatistic::GetVarName() const; virtual TClass*IsA() const; RooStats::DebuggingTestStat&operator=(const RooStats::DebuggingTestStat&); virtual boolRooStats::TestStatistic::PValueIsRightTail() const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; private:. TRandom*fRand; RooRealVar*fTestStatistic. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~DebuggingTestStat(); delete fRand;; delete fTestStatistic;. Double_t Evaluate(RooAbsData& , RooArgSet& ); Main interface to evaluate the test statistic on a dataset. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id$ » Last generated: 2015-09-08 17:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__DebuggingTestStat.html:1635,test,test,1635,root/html534/RooStats__DebuggingTestStat.html,https://root.cern,https://root.cern/root/html534/RooStats__DebuggingTestStat.html,1,['test'],['test']
Testability,"stStatRatioOfProfiledLikelihoodsTestStat(); RooStats::RatioOfProfiledLikelihoodsTestStatRatioOfProfiledLikelihoodsTestStat(const RooStats::RatioOfProfiledLikelihoodsTestStat&); RooStats::RatioOfProfiledLikelihoodsTestStatRatioOfProfiledLikelihoodsTestStat(RooAbsPdf& nullPdf, RooAbsPdf& altPdf, const RooArgSet* altPOI = 0); voidSetSubtractMLE(bool subtract); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. RooArgSet*fAltPOI; RooAbsPdf*fAltPdf; RooAbsPdf*fNullPdf; Bool_tfSubtractMLE. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RatioOfProfiledLikelihoodsTestStat(); Proof constructor. Don't use. RatioOfProfiledLikelihoodsTestStat(RooAbsPdf& nullPdf, RooAbsPdf& altPdf, const RooArgSet* altPOI = 0). Calculates the ratio of profiled likelihoods. 	 By default the calculation is:. 	 Lambda(mu_alt , conditional MLE for alt nuisance); 	log --------------------------------------------; 	 Lambda(mu_null , conditional MLE for null nuisance). 	where Lambda is the profile likeihood ratio, so the; 	MLE for the null and alternate are subtracted off. 	If SetSubtractMLE(false) then it calculates:. 	 L(mu_alt , conditional MLE for alt nuisance); 	log --------------------------------------------; 	 L(mu_null , conditional MLE for null nuisance). 	The values of the parameters of interest for the alternative; 	hypothesis are taken at the time of the construction.; 	If empty, it treats all free parameters as nuisance parameters. 	The value of the parameters of interest for the null hypotheses; 	are given at each call of Evaluate(data,nullPOI). ~RatioOfProfiledLikelihoodsTestStat(void). Double_t ProfiledLikelihood(RooAbsData& data, RooArgSet& poi, RooAbsPdf& pdf). Double_t Evaluate(RooAbsData& data, RooArgSet& nullParamsOfInterest). const TString GetVarName() const. void SetSubtractMLE(bool subtract); const bool PValueIsRightTail(void) { return false; } //",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__RatioOfProfiledLikelihoodsTestStat.html:1958,log,log,1958,root/html528/RooStats__RatioOfProfiledLikelihoodsTestStat.html,https://root.cern,https://root.cern/root/html528/RooStats__RatioOfProfiledLikelihoodsTestStat.html,2,['log'],['log']
Testability,stStatistic::_nGofNumber of sub-contexts ; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooArgSet*RooAbsOptTestStatistic::_normSetPointer to set with observables used for normalization; Int_tRooAbsTestStatistic::_numSetsTotal number of partitions in parallel calculation mode; Double_tRooAbsTestStatistic::_offset! Offset; Double_tRooAbsTestStatistic::_offsetCarry! avoids loss of precision; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooAbsOptTestStatistic::_optimized!; RooAbsData*RooAbsOptTestStatistic::_origDataOriginal data ; RooAbsReal*RooAbsOptTestStatistic::_origFuncOriginal function ; Bool_tRooAbsOptTestStatistic::_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*RooAbsOptTestStatistic::_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; RooArgSet_rrvArgsSet of real-valued observables; TIterator*_rrvIter! Iterator over set of real-valued observables; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TStringRooAbsOptTestStatistic::_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_tRooAbsOptTestStatistic::_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooA,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooXYChi2Var.html:40203,test,test,40203,root/html534/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html534/RooXYChi2Var.html,3,['test'],['test']
Testability,"stTree ; (; const TCut & ; cut, . const TString & ; splitOpt . ). prepare the training and test trees -> same cuts for signal and background ; Definition at line 632 of file DataLoader.cxx. ◆ PrepareTrainingAndTestTree() [2/4]. void TMVA::DataLoader::PrepareTrainingAndTestTree ; (; const TCut & ; cut, . Int_t ; NsigTrain, . Int_t ; NbkgTrain, . Int_t ; NsigTest, . Int_t ; NbkgTest, . const TString & ; otherOpt = ""SplitMode=Random:!V"" . ). prepare the training and test trees ; Definition at line 602 of file DataLoader.cxx. ◆ PrepareTrainingAndTestTree() [3/4]. void TMVA::DataLoader::PrepareTrainingAndTestTree ; (; const TCut & ; cut, . Int_t ; Ntrain, . Int_t ; Ntest = -1 . ). prepare the training and test trees kept for backward compatibility ; Definition at line 618 of file DataLoader.cxx. ◆ PrepareTrainingAndTestTree() [4/4]. void TMVA::DataLoader::PrepareTrainingAndTestTree ; (; TCut ; sigcut, . TCut ; bkgcut, . const TString & ; splitOpt . ). prepare the training and test trees ; Definition at line 644 of file DataLoader.cxx. ◆ RecombineKFoldDataSet(). void TMVA::DataLoader::RecombineKFoldDataSet ; (; CvSplit & ; s, . Types::ETreeType ; tt = Types::kTraining . ). Recombines the dataset. ; The precise semantics depend on the actual split.; Similar to the inverse operation of MakeKFoldDataSet but will differ. See documentation for each particular split for more information. ; Definition at line 683 of file DataLoader.cxx. ◆ SetBackgroundTree(). void TMVA::DataLoader::SetBackgroundTree ; (; TTree * ; background, . Double_t ; weight = 1.0 . ). Definition at line 439 of file DataLoader.cxx. ◆ SetBackgroundWeightExpression(). void TMVA::DataLoader::SetBackgroundWeightExpression ; (; const TString & ; variable). Definition at line 556 of file DataLoader.cxx. ◆ SetCut() [1/2]. void TMVA::DataLoader::SetCut ; (; const TCut & ; cut, . const TString & ; className = """" . ). Definition at line 581 of file DataLoader.cxx. ◆ SetCut() [2/2]. void TMVA::DataLoader::SetCut ; (; co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DataLoader.html:31914,test,test,31914,doc/master/classTMVA_1_1DataLoader.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DataLoader.html,1,['test'],['test']
Testability,"stUnfold7b.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold7c.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  ► unuran;  unuranDemo.CExample macro to show unuran capabilities The results are compared with what is obtained using TRandom or TF1::GetRandom The macro is divided in 3 parts: ;  unuranFoamTest.CThis program must be compiled and executed with Aclic as follows ;  ► v7;  concurrentfill.cxx;  draw.cxx;  draw_th1.cxx;  draw_v6.cxx;  fitpanel.cxx;  histops.cxx;  perf.cxx;  perfcomp.cxx;  simple.cxx;  text.cxx;  ► xml;  DOMParsePerson.C ROOT implementation of a XML DOM Parser ;  DOMRecursive.C ROOT implementation of a XML DOM Parser ;  SAXHandler.C ROOT implementation of a simple SAX Handler ;  xmlnewfile.C Example to create a new xml file with the TXMLEngine class ;  xmlreadfile.C Example to read and parse any xml file, supported by TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ;  benchmarks.CThis macro run several tests and produces an benchmark report ;  demos.CThis macro shows a control bar to run some of the ROOT tutorials ;  demoshelp.CThis macro shows help on running the Demos ;  geant3tasks.CThis script is a representation using TTasks of the Geant3 simulation program This example uses directly TTask objects ;  hsimple.C This program creates : ;  htmlex.CThis file demonstrates how THtml can document sources ;  MyTasks.cxxA set of classes deriving from TTask ;  regexp.CA regular expression, often called a pattern, is an expression that describes a set of strings ;  regexp_pme.CClass TPMERegexp - API similar to PME - PCRE Made Easy Tries to be as close as possible to PERL syntax and functionality ;  rootalias.CDefines aliases: ;  rootenv.CProduce a picture of the ROOT environment ;  rootlogoff.CExample of rootlogoff.C ;  rootlogon.CExample of rootlogon.C ;  rootmarks.CPrints a summary of all ROOT benchmarks (must be run bef",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:162164,benchmark,benchmarks,162164,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,1,['benchmark'],['benchmarks']
Testability,"stUnfold7c.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  ► unuran;  unuranDemo.CExample macro to show unuran capabilities The results are compared with what is obtained using TRandom or TF1::GetRandom The macro is divided in 3 parts: ;  unuranFoamTest.CThis program must be compiled and executed with Aclic as follows ;  ► v7;  concurrentfill.cxx;  draw.cxx;  draw_th1.cxx;  draw_v6.cxx;  fitpanel.cxx;  histops.cxx;  perf.cxx;  perfcomp.cxx;  simple.cxx;  text.cxx;  ► xml;  DOMParsePerson.C ROOT implementation of a XML DOM Parser ;  DOMRecursive.C ROOT implementation of a XML DOM Parser ;  SAXHandler.C ROOT implementation of a simple SAX Handler ;  xmlnewfile.C Example to create a new xml file with the TXMLEngine class ;  xmlreadfile.C Example to read and parse any xml file, supported by TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ;  benchmarks.CThis macro run several tests and produces an benchmark report ;  demos.CThis macro shows a control bar to run some of the ROOT tutorials ;  demoshelp.CThis macro shows help on running the Demos ;  geant3tasks.CThis script is a representation using TTasks of the Geant3 simulation program This example uses directly TTask objects ;  hsimple.C This program creates : ;  htmlex.CThis file demonstrates how THtml can document sources ;  MyTasks.cxxA set of classes deriving from TTask ;  regexp.CA regular expression, often called a pattern, is an expression that describes a set of strings ;  regexp_pme.CClass TPMERegexp - API similar to PME - PCRE Made Easy Tries to be as close as possible to PERL syntax and functionality ;  rootalias.CDefines aliases: ;  rootenv.CProduce a picture of the ROOT environment ;  rootlogoff.CExample of rootlogoff.C ;  rootlogon.CExample of rootlogon.C ;  rootmarks.CPrints a summary of all ROOT benchmarks (must be run before) ;  tasks.CExample of TTasks . ROOT 6.12/07 - Reference Guide Generated on Sa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:162199,test,tests,162199,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,2,"['benchmark', 'test']","['benchmark', 'tests']"
