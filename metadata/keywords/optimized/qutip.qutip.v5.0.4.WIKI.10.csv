quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Modifiability,"rved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; >>> import time. >>> def func(x): time.sleep(1). >>> result = parallel_map(func, range(50), progress_bar=True). 10.0%. Run time: 3.10s. Est. time left: 00:00:00:27; 20.0%. Run time: 5.11s. Est. time left: 00:00:00:20; 30.0%. Run time: 8.11s. Est. time left: 00:00:00:18; 40.0%. Run time: 10.15s. Est. time left: 00:00:00:15; 50.0%. Run time: 13.15s. Est. time left: 00:00:00:13; 60.0%. Run time: 15.15s. Est. time left: 00:00:00:10; 70.0%. Run time: 18.15s. Est. time left: 00:00:00:07; 80.0%. Run time: 20.15s. Est. time left: 00:00:00:05; 90.0%. Run time: 23.15s. Est. time left: 00:00:00:02; 100.0%. Run time: 25.15s. Est. time left: 00:00:00:00; Total run time: 28.91s. Parallel processing is useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-based parallel_map¶; When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parallel_map. The advantage of this parallel_map implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-parfor.html:6052,config,configurations,6052,docs/4.6/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-parfor.html,1,['config'],['configurations']
Modifiability,ry() (Qobj method). check_unitarity() (DynamicsUnitary method). CircuitProcessor (class in qutip.qip.models). CircularSpinChain (class in qutip.qip.models.spinchain). clear() (Bloch method). (FidCompUnitary method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coefficient_matrix() (Dicke method). (Pim method). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). collapse_uncoupled() (in module qutip.piqs). combine_dyn_gen() (Dynamics method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method). controlled_gate() (in module qutip.qip.gates). convert_unit() (in module qutip.utilities). copy() (Qobj method). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_3op_1t() (in module qutip.correlation). correlation_3op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). cosm() (Qobj method). covariance_matrix() (in module qutip.continuous_variables). cphase() (in module qutip.qip.gates). create() (in module qutip.operators). create_dump_dir() (Dump method). create_new_stats() (HEOMSolver m,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/genindex.html:2982,config,configure,2982,docs/4.3/genindex.html,https://qutip.org,https://qutip.org/docs/4.3/genindex.html,2,['config'],['configure']
Modifiability,"ry(; self._dyn_gen_eigenvectors_adj[k]); else:; eigvecadj_unit = None; msg = (""prop unit: {}; H herm: {}; ""; ""eigval unit: {}; eigvec unit: {}; ""; ""eigvecadj_unit: {}"".format(; prop_unit, herm, eigval_unit, eigvec_unit,; eigvecadj_unit)); logger.info(msg). [docs]class DynamicsSymplectic(Dynamics):; """"""; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes; ----------; omega : array[drift_dyn_gen.shape]; matrix used in the calculation of propagators (time evolution); with symplectic systems. """""". def reset(self):; Dynamics.reset(self); self.id_text = 'SYMPL'; self._omega = None; self._omega_qobj = None; self._phase_application = 'postop'; self.grad_exact = True; self.apply_params(). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). @property; def omega(self):; if self._omega is None:; self._get_omega(); if self._omega_qobj is None:; self._omega_qobj = Qobj(self._omega, dims=self.dyn_dims); return self._omega_qobj. def _get_omega(self):; if self._omega is None:; n = self.get_drift_dim() // 2; omg = sympl.calc_omega(n); if self.oper_dtype == Qobj:; self._omega = Qobj(omg, dims=self.dyn_dims); self._omega_qobj = self._omega; elif self.oper_dtype == sp.csr_matrix:; self._omega = sp.csr_matrix(omg); else:; self._omega = omg; return self._omega. def _set_phase_application(self, value):; Dynamics._set_phase_application(self, value); if self._evo_initialized:; phase = self._get_dyn_gen_phase(); if phase",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html:52715,config,configuration,52715,docs/4.4/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html,2,['config'],['configuration']
Modifiability,"ry(; self._dyn_gen_eigenvectors_adj[k]); else:; eigvecadj_unit = None; msg = (""prop unit: {}; H herm: {}; ""; ""eigval unit: {}; eigvec unit: {}; ""; ""eigvecadj_unit: {}"".format(; prop_unit, herm, eigval_unit, eigvec_unit,; eigvecadj_unit)); logger.info(msg). [docs]class DynamicsSymplectic(Dynamics):; """"""; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes; ----------; omega : array[drift_dyn_gen.shape]; matrix used in the calculation of propagators (time evolution); with symplectic systems. """""". def reset(self):; Dynamics.reset(self); self.id_text = 'SYMPL'; self._omega = None; self._omega_qobj = None; self._phase_application = 'postop'; self.grad_exact = True; self.apply_params(). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). @property; def omega(self):; if self._omega is None:; self._get_omega(); if self._omega_qobj is None:; self._omega_qobj = Qobj(self._omega, dims=self.dyn_dims); return self._omega_qobj. def _get_omega(self):; if self._omega is None:; n = self.get_drift_dim() // 2; omg = sympl.calc_omega(n); if self.oper_dtype == Qobj:; self._omega = Qobj(omg, dims=self.dyn_dims); self._omega_qobj = self._omega; else:; self._omega = omg; return self._omega. def _set_phase_application(self, value):; Dynamics._set_phase_application(self, value); if self._evo_initialized:; phase = self._get_dyn_gen_phase(); if phase is not None:; self._dyn_gen_phase = phase. def _get_dyn_gen_phase(self):;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:52428,config,configuration,52428,docs/4.6/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html,2,['config'],['configuration']
Modifiability,"s (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. class LorentzianPadeBath(Q, gamma, w, mu, T, Nk, tag=None)[source]¶; A helper class for constructing a Padé expansion for Lorentzian fermionic; bath from the bath parameters (see parameters below).; A Padé approximant is a sum-over-poles expansion (; see https://en.wikipedia.org/wiki/Pad%C3%A9_approximant).; The application of the Padé method to spectrum decompoisitions is described; in “Padé spectrum decompositions of quantum distribution functions and; optimal hierarchical equations of motion construction for quantum open; systems” [1].; The implementation here follows the approach in the paper.; [1] J. Chem. Phys. 134, 244106 (2011); https://doi.org/10.1063/1.3602466; This is an alternative to the LorentzianBath which constructs; a simpler exponential expansion that converges much more slowly in; this particular case. Parameters. QQobjOperator describing the coupling between system and bath. gammafloatThe coupling strength between the system and the bath. wfloatThe width of the environment. mufloatThe chemical potential of the bath. TfloatBath temperature. NkintNumber of exponential terms used to approximate the bath correlation; functions. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. class HierarchyADOs(exponents, max_depth)[source]¶; A description of ADOs (auxilliary density operators) with the; hierarchical equations of motion.; The list of ADOs is constructed from a list of bath exponents; (corresponding to one or more baths). Each ADO is referred to by a label; that lists the number of “excitations” of each bath exponent. The; level of a label within the hierarchy is the sum of the “excitations”; within the label.; For example the label (0, 0, ..., 0) represents the density matrix; of th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:61987,coupling,coupling,61987,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,1,['coupling'],['coupling']
Modifiability,"s += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.argsort(-e_quasi); else:; order = list(range(len(evals))). # prepare a list of kets for the floquet states; new_dims = [U.dims[0], [1] * len(U.dims[0])]; new_shape = [U.shape[0], 1]; kets_order = [Qobj(np.array(evecs[:, o]).T,; dims=new_dims, shape=new_shape) for o in order]. return kets_order, e_quasi[order]. [docs]def floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None):; """"""; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. Returns; -------. output : list of kets. The Floquet modes as kets at time :math:`t`. """"""; # find t in [0,T] such that t_orig = t + n * T for integer n; t = t - int(t / T) * T; f_modes_t = []. # get the unitary propagator from 0 to t; if t > 0.0:; U = propagator(H, t, [], args). for n in np.arange(len(f_modes_0)):; f_modes_t.append(U * f_modes_0[n] * exp(1j * f_energies[n] * t)); else:; f_modes_t = f_modes_0. return f_modes_t. [docs]def floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None):; """"""; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. tlist : array; The list of times at which to evaluate the floquet modes. H : :class:`qutip.q",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/floquet.html:5677,variab,variables,5677,docs/4.6/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html,1,['variab'],['variables']
Modifiability,"s = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.ps",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:8759,config,config,8759,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"s = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(); ; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(); ; if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname); ; if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:17646,config,config,17646,docs/4.6/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html,2,['config'],['config']
Modifiability,"s = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=obje",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:9070,config,config,9070,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"s a bulk Hamiltonian; for a good quantum number k. cell_periodic_parts(self)[source]¶. Returns eigenvectors of the bulk Hamiltonian, i.e. the cell periodic; part($u_n(k)$) of the Bloch wavefunctios in a numpy.ndarray for; translationally symmetric lattices with periodic boundary condition. angle = |k; angle otimes | u_{n}(k); angle . u_{n}(k). angle = a_n(k)|a; angle + b_n(k)|b; angle . end{eqnarray}. Please see section 1.2 of Asbóth, J. K., Oroszlány, L., & Pályi, A.; (2016). A short course on topological insulators. Lecture notes in; physics, 919 for a review. Returns. knxanp.array; knxA[j][0] is the jth good Quantum number k. vec_knsnp.ndarray of Qobj’svec_kns[j] is the Oobj of type ket that holds an eigenvector of the; bulk Hamiltonian of the lattice. display_lattice(self)[source]¶; Produces a graphic portraying the lattice symbolically with a unit cell; marked in it. Returns. inter_TQobjThe coefficient of $psi_{i,N}^{dagger}psi_{0,i+1}$, i.e. the; coupling between the two boundary sites of the two unit cells i and; i+1. display_unit_cell(self, label_on=False)[source]¶; Produces a graphic displaying the unit cell features with labels on if; defined by user. Also returns a dict of Qobj’s corresponding to the; labeled elements on the display. Returns. HcelldictHcell[i][j] is the Hamiltonian segment for $H_{i,j}$ labeled on the; graphic. distribute_operator(self, op)[source]¶; A function that returns an operator matrix that applies op to all the; cells in the 1d lattice. Parameters; op (qutip.Qobj) – Qobj representing the operator to be applied at all cells. Returns. op_Hqutip.QobjQuantum object representing the operator with op applied at all; cells. get_dispersion(self, knpoints=0)[source]¶; Returns dispersion relationship for the lattice with the specified; number of unit cells with a k array and a band energy array. Returns. knxanp.arrayknxA[j][0] is the jth good Quantum number k. val_knsnp.arrayval_kns[j][:] is the array of band energies of the jth band good at",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:65301,coupling,coupling,65301,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,1,['coupling'],['coupling']
Modifiability,"s etc; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). optim = create_pulse_optimizer(; drift, ctrls, initial, target,; num_tslots=num_tslots, evo_time=evo_time, tau=tau,; amp_lbound=amp_lbound, amp_ubound=amp_ubound,; fid_err_targ=fid_err_targ, min_grad=min_grad,; max_iter=max_iter, max_wall_time=max_wall_time,; optim_alg=optim_alg, max_metric_corr=max_metric_corr,; accuracy_factor=accuracy_factor,; dyn_type=dyn_type, prop_type=prop_type,; fid_type=fid_type, phase_option=phase_option,; fid_err_scale_factor=fid_err_scale_factor,; amp_update_mode=amp_update_mode, init_pulse_type=init_pulse_type,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; log_level=log_level, gen_stats=gen_stats). dyn = optim.dynamics; p_gen = optim.pulse_generator. if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial operator:\n""; msg += str(dyn.initial); msg += ""\nTarget operator:\n""; msg += str(dyn.target); logger.info(msg). # Generate pulses for each control; init_amps = np.zeros([num_tslots, dyn.num_ctrls]); for j in range(dyn.num_ctrls):; init_amps[:, j] = p_gen.gen_pulse(). # Initialise the starting amplitudes; dyn.initialize_controls(init_amps). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:11805,config,configuration,11805,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['config'],['configuration']
Modifiability,"s for calculating; expectation values. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Set to None to disable the; progress bar. map_func: function; A map function for managing the calls to the single-trajactory solver. map_kwargs: dictionary; Optional keyword arguments to the map_func function. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation. .. note::. It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """""". if debug:; print(inspect.stack()[0][3]). if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:7536,config,config,7536,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"s for the ODE solver. Returns:output: qutip.solver. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors or density matrices corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops, e_ops, args={}, options=None, progress_bar=None)[source]¶; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H) and an [optional] set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows to solve master equations that are not on standard Lindblad; form by passing a custom Liouvillian in place of either the H or c_ops; elements.; Time-dependent operators; For time-dependent problems, H and c_ops can be callback; functions that takes two arguments, time and args, and returns the; Hamiltonian or Liouvillian for the system at that point in time; (callback format).; Alternatively, H and c_ops can be a specified in a nested-list format; where each element in the list is a l",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:44085,evolve,evolved,44085,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['evolve'],['evolved']
Modifiability,"s in the first period of the time-dependence. Parameters:; f_modes_table_t : nested list of qutip.qobj (kets); A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. t : float; The time for which to evaluate the Floquet modes. T : float; The period of the time-dependence of the hamiltonian. Returns:; output : nested list; A list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Evaluate the floquet states at time t given the initial Floquet modes. Parameters:; f_modes_t : list of qutip.qobj (kets); A list of initial Floquet modes (for time \(t=0\)). f_energies : array; The Floquet energies. t : float; The time for which to evaluate the Floquet states. H : qutip.qobj; System Hamiltonian, time-dependent with period T. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns:; output : list; A list of Floquet states for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters:; f_modes_t : list of qutip.qobj (kets); A list of initial Floquet modes (for time \(t=0\)). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. H : qutip.qobj; System Hamiltonian, time-dependent with period T. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns:; output : qutip.qobj; The wavefunction for the time \(t\). floquet_state_decomposition(f_states, f_energies, psi)[source]¶; Decompose the wavefunction psi (typically an initial state) in terms ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:74031,variab,variables,74031,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['variab'],['variables']
Modifiability,"s la_norm; from qutip.cy.stochastic import normalize_inplace; import qutip.settings as qset; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.cy.spconvert import dense1D_to_fastcsr_ket, dense2D_to_fastcsr_fmode; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state); from qutip.solver import Result, Options, config, solver_safe, SolverSystem; from qutip.superoperator import vec2mat; from qutip.ui.progressbar import (BaseProgressBar, TextProgressBar); from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. [docs]def sesolve(H, psi0, tlist, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Schrodinger equation evolution of a state vector or unitary matrix; for a given Hamiltonian. Evolve the state vector (`psi0`) using a given; Hamiltonian (`H`), by integrating the set of ordinary differential; equations that define the system. Alternatively evolve a unitary matrix in; solving the Schrodinger operator equation. The output is either the state vector or unitary matrix at arbitrary points; in time (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters; ----------. H : :class:`qutip.qobj`, :class:`qutip.qobjevo`, *list*, *callable*; system Hamiltonian as a Qobj, list of Qobj and coefficient, QobjEvo,; or a callback function for time-dependent Hamiltonians.; list format and options can be found in QobjEvo's description. psi0 : :class:`qutip.qobj`; initial state vector (ket); or initial unitary operator `psi0 = U`. tlist : *list* / *array*; list of times for :math:`t`. e_ops : None / list of :class:`qutip.qobj` / callback function; single operator or list of operators for which to eva",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/sesolve.html:3235,evolve,evolve,3235,docs/4.5/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/sesolve.html,1,['evolve'],['evolve']
Modifiability,"s matrices, often called superoperators.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; In [93]: X = sigmax(). In [94]: S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the to_super function when given; type='oper' input.; In [95]: S2 = to_super(X). In [96]: (S - S2).norm(); Out[96]: 0.0. Quantum objects representing superoperators are denoted by type='super':; In [97]: S; Out[97]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the iscp, istp; and iscptp attributes:; In [98]: S.iscp, S.istp, S.iscptp; Out[98]: (True, True, True). In addition, dynamical generators on this extended space, often called; Liouvillian superoperators, can be created using the liouvillian function. Each of these takes a Hamilonian along with; a list of collapse operators, and returns a type=""super"" object that can; be exponentiated to find the superoperator for that evolution.; In [99]: H = 10 * sigmaz(). In [100]: c1 = destroy(2). In [101]: L = liouvillian(H, [c1]). In [102]: L; Out[102]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j 1. +0.j]; [ 0. +0.j -0.5+20.j 0. +0.j 0. +0.j]; [ 0. +0.j 0. +0.j -0.5-20.j 0. +0.j]; [ 0. +0.j 0. +0.j 0. +0.j -1. +0.j]]. In [103]: S = (12 * L).expm(). For qubits, a particularly useful way to visualize superoperators is to plot them in the Pauli basis,; such that \(S_{\mu,\nu} = \langle\!\langle \sigma_{\mu} | S[\sigma_{\nu}] \rangle\!\rangle\). Because; the Pauli basis is Hermitian, \(S_{\mu,\nu}\) is a real number for all Hermitian-preserving superoperators; \(S\),; allowing us to ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-states.html:20367,extend,extended,20367,docs/4.3/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-states.html,1,['extend'],['extended']
Modifiability,"s matrices, often called superoperators.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; In [94]: X = sigmax(). In [95]: S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the to_super function when given; type='oper' input.; In [96]: S2 = to_super(X). In [97]: (S - S2).norm(); Out[97]: 0.0. Quantum objects representing superoperators are denoted by type='super':; In [98]: S; Out[98]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the iscp, istp; and iscptp attributes:; In [99]: S.iscp, S.istp, S.iscptp; Out[99]: (True, True, True). In addition, dynamical generators on this extended space, often called; Liouvillian superoperators, can be created using the liouvillian function. Each of these takes a Hamilonian along with; a list of collapse operators, and returns a type=""super"" object that can; be exponentiated to find the superoperator for that evolution.; In [100]: H = 10 * sigmaz(). In [101]: c1 = destroy(2). In [102]: L = liouvillian(H, [c1]). In [103]: L; Out[103]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j 1. +0.j]; [ 0. +0.j -0.5+20.j 0. +0.j 0. +0.j]; [ 0. +0.j 0. +0.j -0.5-20.j 0. +0.j]; [ 0. +0.j 0. +0.j 0. +0.j -1. +0.j]]. In [104]: S = (12 * L).expm(). For qubits, a particularly useful way to visualize superoperators is to plot them in the Pauli basis,; such that \(S_{\mu,\nu} = \langle\!\langle \sigma_{\mu} | S[\sigma_{\nu}] \rangle\!\rangle\). Because; the Pauli basis is Hermitian, \(S_{\mu,\nu}\) is a real number for all Hermitian-preserving superoperators; \(S\),; allowing us to",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-states.html:20678,extend,extended,20678,docs/4.4/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-states.html,2,['extend'],['extended']
Modifiability,"s of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:35347,config,config,35347,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"s shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above. TimeslotComputerHere the time evolution is computed by calling the methods of the other computer objects. OptimResultThe result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-control.html:17213,config,configuration,17213,docs/4.6/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html,2,['config'],"['configuration', 'configure']"
Modifiability,"s the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------. if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op # combine Hamiltonian and collapse terms into one; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:32028,config,config,32028,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"s the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:31008,config,config,31008,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"s trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, ...) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks listed above. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [9]. It has since been restructured and extended for flexibility and compatibility within QuTiP. Merging the GRAPE implementations is part of the near future plans. An implementation of the ‘dressed’ CRAB algorithm is also planned for the near future.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface (as in the notebook examples) then skip to the section on ‘Using the pulseoptim functions’.; !",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-control.html:13596,variab,variable,13596,docs/4.0.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html,2,['variab'],['variable']
Modifiability,"s will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:39971,coupling,coupling,39971,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,1,['coupling'],['coupling']
Modifiability,"s()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a master equation solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). rho_t = mesolve(H, rho0, tlist, c_ops, [],; args=args, options=options).states; corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); H_shifted, c_ops_shifted, _args = _transform_L_t_shift_new(H, c_ops, args); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). for t_idx, rho in enumerate(rho_t):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. corr_mat[t_idx, :] = mesolve(; H_shifted, c_op * rho * a_op, taulist, c_ops_shifted,; [b_op], args=_args, options=options; ).expect[0]. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # exponential series solvers. def _correlation_es_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using an exponential series solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). # contruct the Liouvillian; L = liouvillian(H, c_ops). corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex). # The user-facing eseries and ode2es are deprecated from QuTiP 4.6, pending; # removal in QuTiP 5.0, however they are being maintained for internal use; # in correlation, so should not raise warnings to the user not matter what; # their settings.; with warnings.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/correlation.html:32698,config,config,32698,docs/4.6/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html,1,['config'],['config']
Modifiability,"s()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a master equation solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). rho_t = mesolve(H, rho0, tlist, c_ops, [],; args=args, options=options).states; corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); H_shifted, c_ops_shifted, _args = _transform_L_t_shift_new(H, c_ops, args); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). for t_idx, rho in enumerate(rho_t):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. corr_mat[t_idx, :] = mesolve(; H_shifted, c_op * rho * a_op, taulist, c_ops_shifted,; [b_op], args=_args, options=options; ).expect[0]. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # exponential series solvers. def _correlation_es_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using an exponential series solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). # contruct the Liouvillian; L = liouvillian(H, c_ops). corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); solES_t = ode2es(L, rho0). # evaluate the correlation function; for t_idx in range(len(tlist)):; rho_t = esval(solES_t, [tlist[t_idx]]); solES_tau = ode2es(L, c_op * rho_t * a_op); corr_mat[t_idx, :] = esval(expect(b_op, solES_tau), taulist). return corr_mat. de",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/correlation.html:32790,config,config,32790,docs/4.5/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/correlation.html,1,['config'],['config']
Modifiability,"s()]; else:; e_ops_dict = None. config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:8861,config,config,8861,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,2,['config'],['config']
Modifiability,"s(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # ------------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:12728,config,config,12728,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"s(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TIME TLIST[k]; while ODE.t < tlist[k]:; t_prev = ODE.t; y_prev = ODE.y; norm2_prev = dznrm2(ODE._y) ** 2; # integrate up to tlist[k], one step at a time.; ODE.integrate(tlist[k], step=1); if not ODE.successful():; raise Exception(""ZVODE failed!""); norm2_psi = dznrm2(ODE._y) ** 2; if norm2_psi <= rand_vals[0]:; # collapse has occured:; # find collapse time to within ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:23912,config,config,23912,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,s). bures_dist() (in module qutip.metrics). C. calculate() (Stats method). charge() (in module qutip.operators). check_herm() (Qobj method). check_unitarity() (DynamicsUnitary method). CircuitProcessor (class in qutip.qip.models). CircularSpinChain (class in qutip.qip.models.spinchain). clear() (Bloch method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). combine_dyn_gen() (Dynamics method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method). controlled_gate() (in module qutip.qip.gates). convert_unit() (in module qutip.utilities). copy() (Qobj method). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_3op_1t() (in module qutip.correlation). correlation_3op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). cosm() (Qobj method). covariance_matrix() (in module qutip.continuous_variables). cphase() (in module qutip.qip.gates). create() (in module qutip.operators). create_dump_dir() (Dump method). create_new_stats() (HEOMSolver m,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/genindex.html:2653,config,configure,2653,docs/4.1/genindex.html,https://qutip.org,https://qutip.org/docs/4.1/genindex.html,2,['config'],['configure']
Modifiability,"s); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected string format)""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # ------------------------------------------------------------------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html:19763,config,config,19763,docs/3.1.0/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html,1,['config'],['config']
Modifiability,"s); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------. if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op # combine Hamiltonian and collapse terms into one; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # fin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:32293,config,config,32293,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"s); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:31273,config,config,31273,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"s, t); psi_t = psi0_fb.transform(f_states_t, True). if expt_callback:; # use callback method; e_ops(t, psi_t); else:; # calculate all the expectation values, or output psi if; # no expectation value operators where defined; if output.num_expect == 0:; output.states.append(Qobj(psi_t)); else:; for e_idx, e in enumerate(e_ops):; output.expect[e_idx][t_idx] = expect(e, psi_t). return output. def floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T,; args, J_cb, w_th, kmax=5,; f_modes_table_t=None):; """"""; Calculate the rates and matrix elements for the Floquet-Markov master; equation. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes. f_energies : array; The Floquet energies. c_op : :class:`qutip.qobj`; The collapse operators describing the dissipation. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. J_cb : callback functions; A callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator `c_op`. w_th : float; The temperature in units of frequency. k_max : int; The truncation of the number of sidebands (default 5). f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floquet.floquet_modes_table` (optional). Returns; -------. output : list. A list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. """""". N = len(f_energies); M = 2 * kmax + 1. omega = (2 * pi) / T. Delta = np.zeros((N, N, M)); X = np.zeros((N, N, M), dtype=complex); Gamma = np.zeros((N, N, M)); A = np.zeros((N, N)). nT = 100; dT = T / nT; tlist = np.arange(dT, T + dT / 2, dT). if f_modes_table_t is None:; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/floquet.html:15434,variab,variables,15434,docs/4.2/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/floquet.html,5,['variab'],['variables']
Modifiability,"s. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------. if config.cflag:; config.c_const_inds = np.arange(len(c_ops))",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:31592,config,config,31592,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"s. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops))",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:30572,config,config,30572,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"s. outputnested listA list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_states(f_modes_t, f_energies, t)[source]¶; Evaluate the floquet states at time t given the Floquet modes at that time. Parameters. f_modes_tlist of qutip.qobj (kets)A list of Floquet modes for time \(t\). f_energiesarrayThe Floquet energies. tfloatThe time for which to evaluate the Floquet states. Returns. outputlistA list of Floquet states for the time \(t\). floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Evaluate the floquet states at time t given the initial Floquet modes. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. tfloatThe time for which to evaluate the Floquet states. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. Returns. outputlistA list of Floquet states for the time \(t\). floquet_wavefunction(f_modes_t, f_energies, f_coeff, t)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the Floquet modes at time t. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition of the initial wavefunction. tfloatThe time for which to evaluate the Floquet states. Returns. outputqutip.qobjThe wavefunction for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:73016,variab,variables,73016,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['variab'],['variables']
Modifiability,"s. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Completed Development Projects¶. data layer abstraction¶. tag; dl-abs. status; completed. admin lead; Eric. main dev; Jake Lishman. Development completed as a GSoC project. Fully implemented in the dev.major; branch. Currently being used by some research groups.; Abstraction of the linear algebra data from code qutip components, allowing; for alternatives, such as sparse, dense etc. Difficult to summarize. Almost; every file in qutip affected in some way. A major milestone for qutip.; Significant performance improvements throughout qutip.; Some developments tasks remain, including providing full control over how the; data-layer dispatchers choose the most appropriate output type. qutip main reorganization¶. tag; qmain-reorg. statu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/roadmap.html:12929,config,configure,12929,docs/4.7/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html,1,['config'],['configure']
Modifiability,"s. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; Qtrl migration; HEOM revamp. The planned timeline for the release is:. alpha version, April 2021. Core features packaged and available for; experienced users to test.; beta version, July 2021. All required features and documentation complete,; packaged and ready for community testing.; full release, September 2021. Full tested version released. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Li",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/roadmap.html:15212,config,configure,15212,docs/4.6/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html,1,['config'],['configure']
Modifiability,"s.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expec",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:8985,config,config,8985,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"s: dictionary; Optional keyword arguments to the map_func function. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation. .. note::. It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """""". if debug:; print(inspect.stack()[0][3]); ; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, psi0, c_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # se",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:6878,config,config,6878,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,3,['config'],['config']
Modifiability,"s:Key word arguments for the random number generator. get_noisy_dynamics(dims=None, pulses=None, systematic_noise=None)[source]¶; Return a pulses list added with noise and; the pulse independent noise in a dummy Pulse object. Parameters. dims: list, optionalThe dimension of the components system, the default value is; [2,2…,2] for qubits system. pulses: list of :class:`.Pulse`The input pulses, on which the noise object is to be applied. systematic_noise: :class:`.Pulse`The dummy pulse with no ideal control element. Returns. noisy_pulses: list of PulseNoisy pulses. systematic_noise: PulseThe dummy pulse representing pulse independent noise. class Pulse(qobj, targets, tlist=None, coeff=None, spline_kind=None, label='')[source]¶; Representation of a control pulse and the pulse dependent noise.; The pulse is characterized by the ideal control pulse, the coherent; noise and the lindblad noise. The later two are lists of; noisy evolution dynamics.; Each dynamic element is characterized by four variables:; qobj, targets, tlist and coeff.; See examples for different construction behavior. Parameters. qobj: :class:’qutip.Qobj’The Hamiltonian of the ideal pulse. targets: listtarget qubits of the ideal pulse; (or subquantum system of other dimensions). tlist: array-like, optionaltlist of the ideal pulse.; A list of time at which the time-dependent coefficients are applied.; tlist does not have to be equidistant, but must have the same length; or one element shorter compared to coeff. See documentation for; the parameter spline_kind. coeff: array-like or bool, optionalTime-dependent coefficients of the ideal control pulse.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for the parameter spline_kind.; If a bool, the coefficient is a constant 1 or 0. spline_kind: str, optionalType of the coefficient interpolation:; “step_func” or “cubic”.; -“step_func”:; The coefficient will be treated as a step function.; E.g. tlist=[0,1,2] ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:167943,variab,variables,167943,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['variab'],['variables']
Modifiability,"s; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE solver; #; if",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:11652,config,config,11652,docs/4.0.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability,"s; (sqrt of the sum of the squares). fid_err_grad_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(self, params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear(self)[source]¶; clear any temporarily held status data. flag_system_changed(self)[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err(self)[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient(self)[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp(self)[source]¶; initialises the computer based on the configuration of the Dynamics. reset(self)[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear(self)[source]¶; clear any temporarily held status data. compute_fid_grad(self)[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Not",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:108541,config,configuration,108541,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['config'],['configuration']
Modifiability,"s; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, se",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:11678,config,config,11678,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"s; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; random_integers(1e8, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = random_integers(; 1e8, size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:12684,config,config,12684,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"s; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.conj().transpose(). # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH T",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:24488,config,config,24488,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"s=None, arg_value=None,; arg_label=None, index=None):; """"""; Adds a gate with specified parameters to the circuit. Parameters; ----------; gate: string or `Gate`; Gate name. If gate is an instance of `Gate`, parameters are; unpacked and added.; targets: list; Gate targets.; controls: list; Gate controls.; arg_value: float; Argument value(phi).; arg_label: string; Label for gate representation.; index : list; Positions to add the gate.; """"""; if isinstance(gate, Gate):; name = gate.name; targets = gate.targets; controls = gate.controls; arg_value = gate.arg_value; arg_label = gate.arg_label. else:; name = gate. if index is None:; self.gates.append(Gate(name, targets=targets, controls=controls,; arg_value=arg_value, arg_label=arg_label)). else:; for position in index:; self.gates.insert(position, Gate(name, targets=targets,; controls=controls,; arg_value=arg_value,; arg_label=arg_label)). [docs] def add_1q_gate(self, name, start=0, end=None, qubits=None,; arg_value=None, arg_label=None):; """"""; Adds a single qubit gate with specified parameters on a variable; number of qubits in the circuit. By default, it applies the given gate; to all the qubits in the register. Parameters; ----------; name : string; Gate name.; start : int; Starting location of qubits.; end : int; Last qubit for the gate.; qubits : list; Specific qubits for applying gates.; arg_value : float; Argument value(phi).; arg_label : string; Label for gate representation.; """"""; if name not in [""RX"", ""RY"", ""RZ"", ""SNOT"", ""SQRTNOT"", ""PHASEGATE""]:; raise ValueError(""%s is not a single qubit gate"" % name). if qubits is not None:; for i in range(len(qubits)):; self.gates.append(Gate(name, targets=qubits[i], controls=None,; arg_value=arg_value,; arg_label=arg_label)). else:; if end is None:; end = self.N - 1; for i in range(start, end):; self.gates.append(Gate(name, targets=i, controls=None,; arg_value=arg_value,; arg_label=arg_label)). [docs] def add_circuit(self, qc, start=0):; """"""; Adds a block of a qubit circuit",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qip/circuit.html:8419,variab,variable,8419,docs/4.4/modules/qutip/qip/circuit.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qip/circuit.html,1,['variab'],['variable']
Modifiability,"s=prev_result.seeds).; """""". if debug:; print(inspect.stack()[0][3]); ; if _safe_mode:; _solver_safety_check(H, psi0, c_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.td",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/mcsolve.html:7237,config,config,7237,docs/4.0.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"s={""11"": P11p, ""22"": P22p, ""12"": P12p}). # Plot the results:; fig, axes = plt.subplots(1, 1, sharex=True, figsize=(8,8)); axes.plot(result.times, result.expect[""11""], 'b', linewidth=2, label=""P11""); axes.plot(result.times, result.expect[""12""], 'r', linewidth=2, label=""P12""); axes.set_xlabel(r't', fontsize=28); axes.legend(loc=0, fontsize=12). Steady-state¶; Using the same solver, we can also determine the steady state of the; combined system and bath using:; steady_state, steady_ados = solver.steady_state(). where steady_state is the steady state of the system and steady_ados; if the steady state of the full hierarchy. The ADO states are; described more fully in Determining currents and; HierarchyADOsState. Matsubara Terminator¶; When constructing the Drude-Lorentz bath we have truncated the expansion at; Nk = 2 terms and ignore the remaining terms.; However, since the coupling to these higher order terms is comparatively weak,; we may consider the interaction with them to be Markovian, and construct an; additional Lindbladian term that captures their interaction with the system and; the lower order terms in the expansion.; This additional term is called the terminator because it terminates the; expansion.; The DrudeLorentzBath and; DrudeLorentzPadeBath both provide a means of; calculating the terminator for a given expansion:; # Matsubara expansion:; bath = DrudeLorentzBath(Q, lam, gamma, T, Nk). # Padé expansion:; bath = DrudeLorentzPadeBath(Q, lam, gamma, T, Nk). # Add terminator to the system Liouvillian:; delta, terminator = bath.terminator(); HL = liouvillian(H_sys) + terminator. # Construct solver:; solver = HEOMSolver(HL, bath, max_depth=max_depth, options=options). This captures the Markovian effect of the remaining terms in the expansion; without having to fully model many more terms.; The value delta is an approximation to the strength of the effect of; the remaining terms in the expansion (i.e. how strongly the terminator is; coupled to the rest of the sy",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/heom/bosonic.html:6919,coupling,coupling,6919,docs/4.7/guide/heom/bosonic.html,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html,1,['coupling'],['coupling']
Modifiability,"s[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:26463,config,config,26463,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"s]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectati",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:34638,config,config,34638,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"s_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); if (config.options.average_states and; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:22090,config,config,22090,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"s_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.optio",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:21098,config,config,21098,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"safe_mode:; _solver_safety_check(H, psi0, c_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:7520,config,config,7520,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,3,['config'],['config']
Modifiability,"scipy.optimize.minimize function. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. dumping¶. The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:61854,variab,variable,61854,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,4,['variab'],['variable']
Modifiability,"se operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. def _mc_dm_avg(psi_list):; """"""; Private function that averages density matrices in parallel; over all trajectories for a single time using parfor.; """"""; ln = len(psi_list); dims = psi_list[0].dims; shape = psi_list[0].shape; out_data = np.sum([psi.data for psi in psi_list])",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38768,config,config,38768,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"se the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options (qutip.solver) – options for the ODE solver.; k_max (int) – The truncation of the number of sidebands (default 5). Returns:output – An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. Return type:qutip.solver. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sorted in increasing quasienergies or not. Parameters:; H (qutip.qobj) – system Hamiltonian, time-dependent with period T; args (dictionary) – dictionary with variables required to evaluate H; T (float) – The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving.; U (qutip.qobj) – The propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns:output – Two lists: the Floquet modes as kets and the quasi energies. Return type:list of kets, list of quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters:; f_modes_0 (list of qutip.qobj (kets)) – Floquet modes at \(t\); f_energies (list) – Floquet energies.; t (float) – The time at which to evaluate the floquet modes.; H (qutip.qobj) – system Hamiltonian, time-dependent with period T; args (dictionary) – dictionary with variables required to evaluate H;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:70350,variab,variables,70350,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['variab'],['variables']
Modifiability,"se:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:26582,config,config,26582,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"se:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms), ; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms), ; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp, ; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus, ; atol=tol); ; cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(); ; _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method, ; order=options.order, atol=options.atol, ; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step, ; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_value(initial_vector, tlist[0]); exec(code, locals()); ; #; # prepare output array; #; n_tsteps = len(tlist); e_sops_data = []. output = Result(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; ou",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:15389,config,config,15389,docs/4.3/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html,3,['config'],['config']
Modifiability,"se_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:12454,config,config,12454,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"sed gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes:; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. evo_comp_summary : EvoCompSummary; A summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:108052,config,configuration,108052,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['config'],['configuration']
Modifiability,"seed = random_integers(1e8); if (self.serial_run):; # run in serial; sols = self.serial(); else:; # run in paralell; sols = self.parallel(); # gather data; self.sol = _gather(sols). def evolve_serial(self, args):. if debug:; print(inspect.stack()[0][3] + "":"" + str(os.getpid())). # run ntraj trajectories for one process via fortran; # get args; queue, ntraj, instanceno, rngseed = args; # initialize the problem in fortran; _init_tlist(); _init_psi0(); if (self.ptrace_sel != []):; _init_ptrace_stuff(self.ptrace_sel); _init_hamilt(); if (config.c_num != 0):; _init_c_ops(); if (config.e_num != 0):; _init_e_ops(); # set options; qtf90.qutraj_run.n_c_ops = config.c_num; qtf90.qutraj_run.n_e_ops = config.e_num; qtf90.qutraj_run.ntraj = ntraj; qtf90.qutraj_run.unravel_type = self.unravel_type; qtf90.qutraj_run.average_states = config.options.average_states; qtf90.qutraj_run.average_expect = config.options.average_expect; qtf90.qutraj_run.init_result(config.psi0_shape[0],; config.options.atol,; config.options.rtol, mf=self.mf,; norm_steps=config.norm_steps,; norm_tol=config.norm_tol); # set optional arguments; qtf90.qutraj_run.order = config.options.order; qtf90.qutraj_run.nsteps = config.options.nsteps; qtf90.qutraj_run.first_step = config.options.first_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_sparse = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run; show_progress = 1 if debug else 0; qtf90.qutraj_run.evolve(instanceno, rngseed, show_progress). # construct Result instance; sol = Result(); sol.ntraj = ntraj; # sol.col_times = qtf90.qutraj_run.col_times; # sol.col_which = qtf90.qutraj_run.col_which-1; sol.col_times, sol.col_which = self.get_collaps",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:12084,config,config,12084,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,"seeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in conf",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:13336,config,config,13336,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"self.Q; lam = self.lam; gamma = self.gamma; beta = 1 / self.T. delta = 2 * lam / (beta * gamma) - 1j * lam. for exp in exponents:; if exp.type == BathExponent.types[""R""]:; delta -= exp.ck / exp.vk; elif exp.type == BathExponent.types[""RI""]:; delta -= (exp.ck + 1j * exp.ck2) / exp.vk; else:; delta -= 1j * exp.ck / exp.vk. op = -2*spre(Q)*spost(Q.dag()) + spre(Q.dag()*Q) + spost(Q.dag()*Q); L_bnd = -delta * op. return delta, L_bnd. [docs]class UnderDampedBath(BosonicBath):; """"""; A helper class for constructing an under-damped bosonic bath from the; bath parameters (see parameters below). Parameters; ----------; Q : Qobj; Operator describing the coupling between system and bath. lam : float; Coupling strength. gamma : float; Bath spectral density cutoff frequency. w0 : float; Bath spectral density resonance frequency. T : float; Bath temperature. Nk : int; Number of exponential terms used to approximate the bath correlation; functions. combine : bool, default True; Whether to combine exponents with the same frequency (and coupling; operator). See :meth:`BosonicBath.combine` for details. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""; def __init__(; self, Q, lam, gamma, w0, T, Nk, combine=True, tag=None,; ):; ck_real, vk_real, ck_imag, vk_imag = self._matsubara_params(; lam=lam,; gamma=gamma,; w0=w0,; T=T,; Nk=Nk,; ). super().__init__(; Q, ck_real, vk_real, ck_imag, vk_imag, combine=combine, tag=tag,; ). def _matsubara_params(self, lam, gamma, w0, T, Nk):; """""" Calculate the Matsubara coefficents and frequencies. """"""; beta = 1/T; Om = np.sqrt(w0**2 - (gamma/2)**2); Gamma = gamma/2. ck_real = ([; (lam**2 / (4 * Om)); * (1 / np.tanh(beta * (Om + 1.0j * Gamma) / 2)),; (lam**2 / (4*Om)); * (1 / np.tanh(beta * (Om - 1.0j * Gamma) / 2)),; ]). ck_real.extend([; (-2 * lam**2 * gamma / beta) * (2 * np.pi * k / beta); / (; (",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html:16956,coupling,coupling,16956,docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,1,['coupling'],['coupling']
Modifiability,"self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'use",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:7657,config,configuration,7657,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,7,['config'],['configuration']
Modifiability,"self.num_tslots + 1)]; self.evo_t2targ[-1] = self.get_owd_evo_target(). if isinstance(self.prop_computer, propcomp.PropCompDiag):; self._create_decomp_lists(). def _create_decomp_lists(self):; """"""; Create lists that will hold the eigen decomposition; used in calculating propagators and gradients; Note: used with PropCompDiag propagator calcs; """"""; shp = self.drift_dyn_gen.shape; n_ts = self.num_tslots; self.decomp_curr = [False for x in range(n_ts)]; self.prop_eigen = \; [np.empty(shp[0], dtype=complex) for x in range(n_ts)]; self.dyn_gen_eigenvectors = \; [np.empty(shp, dtype=complex) for x in range(n_ts)]; self.dyn_gen_factormatrix = \; [np.empty(shp, dtype=complex) for x in range(n_ts)]. def _check_test_out_files(self):; cfg = self.config; if cfg.any_test_files():; if not cfg.check_create_test_out_dir():; cfg.reset_test_out_files(); else:; if self.stats is None:; logger.warn(""Cannot output test files when stats""; "" attribute is not set.""); self.config.test_out_amps = False; self.config.test_out_prop = False; self.config.test_out_prop_grad = False; self.config.test_out_evo = False. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; self._check_test_out_files(). if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FideliyComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; # Note this call is made just ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:14688,config,config,14688,docs/3.1.0/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html,1,['config'],['config']
Modifiability,"self.unravel_type = 1; if (config.e_num == 0):; # If we are returning states, and there are no; # collapse operators, set average_states to False to return; # ket vectors instead of density matrices; config.options.average_states = False; # generate a random seed, useful if e.g. running with MPI; self.seed = random_integers(1e8); if (self.serial_run):; # run in serial; sols = self.serial(); else:; # run in paralell; sols = self.parallel(); # gather data; self.sol = _gather(sols). def evolve_serial(self, args):. if debug:; print(inspect.stack()[0][3] + "":"" + str(os.getpid())). # run ntraj trajectories for one process via fortran; # get args; queue, ntraj, instanceno, rngseed = args; # initialize the problem in fortran; _init_tlist(); _init_psi0(); if (self.ptrace_sel != []):; _init_ptrace_stuff(self.ptrace_sel); _init_hamilt(); if (config.c_num != 0):; _init_c_ops(); if (config.e_num != 0):; _init_e_ops(); # set options; qtf90.qutraj_run.n_c_ops = config.c_num; qtf90.qutraj_run.n_e_ops = config.e_num; qtf90.qutraj_run.ntraj = ntraj; qtf90.qutraj_run.unravel_type = self.unravel_type; qtf90.qutraj_run.average_states = config.options.average_states; qtf90.qutraj_run.average_expect = config.options.average_expect; qtf90.qutraj_run.init_result(config.psi0_shape[0],; config.options.atol,; config.options.rtol, mf=self.mf,; norm_steps=config.norm_steps,; norm_tol=config.norm_tol); # set optional arguments; qtf90.qutraj_run.order = config.options.order; qtf90.qutraj_run.nsteps = config.options.nsteps; qtf90.qutraj_run.first_step = config.options.first_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_sparse = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:11783,config,config,11783,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,"serial.; ptrace_sel: list; This optional argument specifies a list of components to keep when; returning a partially traced density matrix. This can be convenient for; large systems where memory becomes a problem, but you are only; interested in parts of the density matrix.; calc_entropy : boolean; If ptrace_sel is specified, calc_entropy=True will have the solver; return the averaged entropy over trajectories in results.entropy. This; can be interpreted as a measure of entanglement. See Phys. Rev. Lett.; 93, 120408 (2004), Phys. Rev. A 86, 022310 (2012). Returns; -------; results : Result; Object storing all results from simulation. """"""; if ntraj is None:; ntraj = options.ntraj. if psi0.type != 'ket':; raise Exception(""Initial state must be a state vector.""); config.options = options; # set num_cpus to the value given in qutip.settings; # if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full(); else:; config.psi0 = psi0.full(); config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape; # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; raise Exception(""ntraj as list argument is not supported.""); else:; config.ntraj = ntraj; # ntraj_list = [ntraj]; # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. if not options.rhs_reuse:; config.soft_reset(); # no time dependence; config.tflag = 0; # check for collapse operators; if len(c_ops) > 0:; config.cflag = 1; else:; config.cflag = 0; # Configure data; _mc_data_config(H, psi0, [], c_ops, [], [], e_ops, options, config). # Load Monte Carlo class; mc = _MC_class(); # Set solver type; if (options.method == 'adams'):; mc.mf = 10; elif (options.method == 'bdf'):; mc.mf = 22; else:; if debug:; print('Unrecognized method for ode solver, using ""adams"".'); mc.mf = 10; # store ket and density matrix dims ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:5895,config,config,5895,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,"ses with strongly magnetic atoms"", ; Phys. Rev. A 96, 033602 (2017). 261. Poonia et al., ""Functional window of the avian compass"", ; Phys. Rev. E 95, 052417 (2017). 260. Su et al., ""Generating double NOON states of photons in circuit QED"", ; Phys. Rev. A 95, 022339 (2017). 259. Kiukas et al., ""Remote parameter estimation in a quantum spin chain enhanced by local control"", ; Phys. Rev. A 95, 052132 (2017). 258. Gely et al., ""Convergence of the multimode quantum Rabi model of circuit quantum electrodynamics"", ; Phys. Rev. B 95, 245115 (2017). 257. Radtke et al., ""Photonic Quantum Operations via the Quantum Carburettor Effect"", ; arXiv:1701.04251. 256. Lagoudakis et al., ""Observation of Mollow Triplets with Tunable Interactions in Double Lambda Systems of Individual Hole Spins"", ; Phys. Rev. Lett. 118, 013602 (2017). 255. Pucci et al., ""Quantum effects in the cooperative scattering of light by atomic clouds"", ; Phys. Rev. A 95, 053625 (2017). 254. Gessner et al., ""Resolution-enhanced entanglement detection"", ; Phys. Rev. A 95, 032326 (2017). 253. Nigg et al., ""Superconducting Grid-Bus Surface Code Architecture for Hole-Spin Qubits"", ; Phys. Rev. Lett. 118, 147701 (2017). 252. Lüer et al., ""Lévy Defects in Matrix-Immobilized J Aggregates: Tracing Intra-and Intersegmental Exciton Relaxation"", ; J. Phys. Chem. Lett. 8, 547 (2017). 251. Dive et al., ""In situ upgrade of quantum simulators to universal computers"", ; arXiv:1701.01723. 250. Barnes et al., ""Fast microwave-driven three-qubit gates for cavity-coupled superconducting qubits"", ; Phys. Rev. B 96, 024504 (2017). 249. Hu, ""Spin-based single-photon transistor, dynamic random access memory, diodes, and routers in semiconductors"", ; Phys. Rev. B 94, 245307 (2016). 248. Leung et al., ""Speedup for quantum optimal control from automatic differentiation based on graphics processing units"", ; Phys. Rev. A 95, 042318 (2017). 247. Bruhat et al., ""Strong coupling between an electron in a quantum dot circuit and a photon in a cavi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:15362,enhance,enhanced,15362,users.html,https://qutip.org,https://qutip.org/users.html,1,['enhance'],['enhanced']
Modifiability,"setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # Master equation solver; #; def _mesolve_const(H, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver, for constant hamiltonian; and collapse operators.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0 and isoper",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html:20227,config,config,20227,docs/3.1.0/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html,1,['config'],['config']
Modifiability,"sg + ""expected Qobj""). if c.isoper:; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif c.issuper:; L = c; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(msg + ""expected string format""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms + collapse; # operators); n_L_terms = len(Ldata). cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()). config.tdfunc = cy_td_ode_rhs. if cleanup:; try:; os.remove(config.tdname + "".pyx""); except:; pass. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):; h_obj.append(k); elif hasattr(H_k[1], '__call__'):; h_obj.append(k); elif isinstance(H_k[1], np.ndarray):; h_str.append(k); else:; raise TypeError(""Incorrect hamiltonian specification""); else:; raise TypeError(""Incorrect hamiltonian specification""",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/rhs_generate.html:6548,config,config,6548,docs/4.5/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/rhs_generate.html,2,['config'],['config']
Modifiability,"sg + ""expected Qobj""). if c.isoper:; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif c.issuper:; L = c; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(msg + ""expected string format""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms + collapse; # operators); n_L_terms = len(Ldata). cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()). config.tdfunc = cy_td_ode_rhs. if cleanup:; try:; os.remove(config.tdname + "".pyx""); except:; pass. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):; h_obj.append(k); elif isinstance(H_k[1], np.ndarray):; h_str.append(k); else:; raise TypeError(""Incorrect hamiltonian specification""); else:; raise TypeError(""Incorrect hamiltonian specification""). # the the whole thing again for c_ops; c_const = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:6352,config,config,6352,docs/4.2/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html,5,['config'],['config']
Modifiability,"sherm:; raise TypeError(""Operators in a_ops must be Hermitian Qobj.""). if c_ops is None:; c_ops = []. # use the eigenbasis; evals, ekets = H.eigenstates(). N = len(evals); K = len(a_ops); ; #only Lindblad collapse terms; if K==0:; Heb = H.transform(ekets); L = liouvillian(Heb, c_ops=[c_op.transform(ekets) for c_op in c_ops]); return L, ekets; ; ; A = np.array([a_ops[k][0].transform(ekets).full() for k in range(K)]); Jw = np.zeros((K, N, N), dtype=complex). # pre-calculate matrix elements and spectral densities; # W[m,n] = real(evals[m] - evals[n]); W = np.real(evals[:,np.newaxis] - evals[np.newaxis,:]). for k in range(K):; # do explicit loops here in case spectra_cb[k] can not deal with array arguments; for n in range(N):; for m in range(N):; Jw[k, n, m] = a_ops[k][1](W[n, m]). dw_min = np.abs(W[W.nonzero()]).min(). # pre-calculate mapping between global index I and system indices a,b; Iabs = np.empty((N*N,3),dtype=int); for I, Iab in enumerate(Iabs):; # important: use [:] to change array values, instead of creating new variable Iab; Iab[0] = I; Iab[1:] = vec2mat_index(N, I). # unitary part + dissipation from c_ops (if given):; Heb = H.transform(ekets); L = liouvillian(Heb, c_ops=[c_op.transform(ekets) for c_op in c_ops]); ; # dissipative part:; rows = []; cols = []; data = []; for I, a, b in Iabs:; # only check use_secular once per I; if use_secular:; # only loop over those indices J which actually contribute; Jcds = Iabs[np.where(np.abs(W[a, b] - W[Iabs[:,1], Iabs[:,2]]) < dw_min * sec_cutoff)]; else:; Jcds = Iabs; for J, c, d in Jcds:; elem = 0+0j; # summed over k, i.e., each operator coupling the system to the environment; elem += 0.5 * np.sum(A[:, a, c] * A[:, d, b] * (Jw[:, c, a] + Jw[:, d, b])); if b==d:; # sum_{k,n} A[k, a, n] * A[k, n, c] * Jw[k, c, n]); elem -= 0.5 * np.sum(A[:, a, :] * A[:, :, c] * Jw[:, c, :]); if a==c:; # sum_{k,n} A[k, d, n] * A[k, n, b] * Jw[k, d, n]); elem -= 0.5 * np.sum(A[:, d, :] * A[:, :, b] * Jw[:, d, :]); if elem != 0:; rows.app",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html:13656,variab,variable,13656,docs/4.2/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html,1,['variab'],['variable']
Modifiability,"si0 = Qobj(config.psi0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90.qutraj_run.init_hamiltonian(; _complexarray_to_fortran(config.h_data),; config.h_ind + 1, config.h_ptr + 1, d, d). def _init_c_ops():; d = np.size(config.psi0); n = config.c_num; first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(c_ops[i]); # qtf90.qutraj_run.init_c_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_c_ops(; i + 1, n, _complexarray_to_fortran(config.c_ops_data[i]),; config.c_ops_ind[i] + 1, config.c_ops_ptr[i] + 1, d, d, first); first = False. def _init_e_ops():; d = np.size(config.psi0); # n = config.e_num; n = len(config.e_ops_data); first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(e_ops[i]); # qtf90.qutraj_run.init_e_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_e_ops(; i + 1, n, _complexarray_to_fortran(config.e_ops_data[i]),; config.e_ops_ind[i] + 1, config.e_ops_ptr[i] + 1, d, d, first); first = False. #; # Misc. converison functions; #; def _realarray_to_fortran(a):; datad = np.array(a, dtype=wpr); return datad. def _complexarray_to_fortran(a):; datad = np.array(a, dtype=wpc); return datad. def _qobj_to_fortranfull(A):; datad = np.array(A.data.toarray(), dtype=wpc); return datad. def _qobj_to_fortrancsr(A):; data = np.array(A.data.data, dtype=wpc); indices = np.array(A.data.indices); indptr = np.array(A.data.indptr); m = A.data.shape[0]; k = A.data.shape[1]; return data, indices + 1, indptr + 1, m, k. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created u",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:19925,config,config,19925,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,"si0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90.qutraj_run.init_hamiltonian(; _complexarray_to_fortran(config.h_data),; config.h_ind + 1, config.h_ptr + 1, d, d). def _init_c_ops():; d = np.size(config.psi0); n = config.c_num; first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(c_ops[i]); # qtf90.qutraj_run.init_c_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_c_ops(; i + 1, n, _complexarray_to_fortran(config.c_ops_data[i]),; config.c_ops_ind[i] + 1, config.c_ops_ptr[i] + 1, d, d, first); first = False. def _init_e_ops():; d = np.size(config.psi0); # n = config.e_num; n = len(config.e_ops_data); first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(e_ops[i]); # qtf90.qutraj_run.init_e_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_e_ops(; i + 1, n, _complexarray_to_fortran(config.e_ops_data[i]),; config.e_ops_ind[i] + 1, config.e_ops_ptr[i] + 1, d, d, first); first = False. #; # Misc. converison functions; #; def _realarray_to_fortran(a):; datad = np.array(a, dtype=wpr); return datad. def _complexarray_to_fortran(a):; datad = np.array(a, dtype=wpc); return datad. def _qobj_to_fortranfull(A):; datad = np.array(A.data.toarray(), dtype=wpc); return datad. def _qobj_to_fortrancsr(A):; data = np.array(A.data.data, dtype=wpc); indices = np.array(A.data.indices); indptr = np.array(A.data.indptr); m = A.data.shape[0]; k = A.data.shape[1]; return data, indices + 1, indptr + 1, m, k. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:19967,config,config,19967,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,4,['config'],['config']
Modifiability,"si_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_dat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:29459,config,config,29459,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"signal; import qutip.settings as qset; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. def _task_wrapper(args):; try:; return args[0](*args[1]); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). def _task_wrapper_with_args(args, user_args):; try:; return args[0](*args[1], **user_args); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). [docs]def parfor(func, *args, **kwargs):; """"""Executes a multi-variable function in parallel on the local machine. Parallel execution of a for-loop over function `func` for multiple input; arguments and keyword arguments. .. note::. From QuTiP 3.1, we recommend to use :func:`qutip.parallel_map`; instead of this function. Parameters; ----------; func : function_type; A function to run in parallel on the local machine. The function 'func'; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:. num_cpus : int; Number of CPU's to use. Default uses maximum number of CPU's.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns; -------; result : list; A ``list`` with length equal to number of input parameters; containing the output from `func`. """"""; kw = _default_kwargs(); if 'num_cpus' in kwargs.keys():; kw['num_cpus'] = kwargs['num_cpus']; del kwargs['num_cpus']; if len(kwargs) != 0:; task_func = partial(_task_wrapper_with_args, user_args=kwargs); else:; task_func = _task_wrapper. if kw['num_cpus'] > qset.num_cpus:; print(""Requested number of CPUs (%s) "" % kw['num_cpus'] +; ""is larger than physical number (%s)."" % qset.num_cpus); print(""Reduce 'num_cpus' for greater performance.""). pool = Pool(processes=kw['num_cpus']); args = [list(a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/parallel.html:3345,variab,variables,3345,docs/4.0.2/modules/qutip/parallel.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/parallel.html,1,['variab'],['variables']
Modifiability,"signal; import qutip.settings as qset; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. def _task_wrapper(args):; try:; return args[0](*args[1]); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). def _task_wrapper_with_args(args, user_args):; try:; return args[0](*args[1], **user_args); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). [docs]def parfor(func, *args, **kwargs):; """"""Executes a multi-variable function in parallel on the local machine. Parallel execution of a for-loop over function `func` for multiple input; arguments and keyword arguments. .. note::. From QuTiP 3.1, we recommend to use :func:`qutip.parallel_map`; instead of this function. Parameters; ----------; func : function_type; A function to run in parallel on the local machine. The function 'func'; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:. num_cpus : int; Number of CPU's to use. Default uses maximum number of CPU's.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns; -------; result : list; A ``list`` with length equal to number of input parameters; containing the output from `func`. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs.keys():; kw['num_cpus'] = kwargs['num_cpus']; del kwargs['num_cpus']; if len(kwargs) != 0:; task_func = partial(_task_wrapper_with_args, user_args=kwargs); else:; task_func = _task_wrapper. if kw['num_cpus'] > qset.num_cpus:; print(""Requested number of CPUs (%s) "" % kw['num_cpus'] +; ""is larger than physical number (%s)."" % qset.num_cpus); print(""Reduce 'num_cpus' for greater performance.""). pool = Pool",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/parallel.html:3345,variab,variables,3345,docs/4.2/modules/qutip/parallel.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/parallel.html,5,['variab'],['variables']
Modifiability,"simulation. Returns. output: ResultAn instance of the class Options, which; contains either an array of expectation values for the times; specified by tlist, or an array or state vectors; corresponding to the times in tlist (if e_ops is an empty; list), or nothing if a callback function was given inplace of; operators for which to calculate the expectation values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops=None, e_ops=None, args=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian or Liouvillian (H) and an optional set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form.; Time-dependent operators; For time-dependent problems, H and c_ops can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (qutip.qobj) at the first element and where; the second element is either a string (list string format), a callback; function (list callback format) that evaluates to the time-dependent; coefficient for the corresponding oper",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:81845,evolve,evolved,81845,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['evolve'],['evolved']
Modifiability,"sing Parfor. Bloch-Redfield master equation; Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The time-evolutions solvers qutip.mesolve, qutip.mcsolve, qutip.sesolve, and qutip.brmesolve are all capable of handling time-dependent Hamiltonians and collapse terms. There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Give",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html:1781,coupling,coupling,1781,docs/4.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html,1,['coupling'],['coupling']
Modifiability,"sing QuTiP; Job Announcements. Devs. Code of conduct; As contributors and maintainers of this project, and in the interest of fostering an open and welcoming community, we pledge to respect all people who contribute through reporting issues, posting feature requests, updating documentation, submitting pull requests or patches, and other activities.; We are committed to making participation in this project a harassment-free experience for everyone, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, or nationality.; Examples of unacceptable behavior by participants include:. The use of sexualized language or imagery; Personal attacks; Trolling or insulting/derogatory comments; Public or private harassment; Publishing other’s private information, such as physical or electronic addresses, without explicit permission; Other unethical or unprofessional conduct. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct. By adopting this Code of Conduct, project maintainers commit themselves to fairly and consistently applying these principles to every aspect of managing this project. Project maintainers who do not follow or enforce the Code of Conduct may be permanently removed from the project team.; This code of conduct applies both within project spaces and in public spaces when an individual is representing the project or its community.; Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by opening an issue or contacting one or more of the project maintainers.; This Code of Conduct is adapted from the Contributor Covenant, version 1.2.0, available at https://www.contributor-covenant.org/version/1/2/0/code-of-conduct.html. © 2011 to 2024 inclusive, QuTiP developers and contributors. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/cofc.html:2040,adapt,adapted,2040,cofc.html,https://qutip.org,https://qutip.org/cofc.html,1,['adapt'],['adapted']
Modifiability,"sing task_kwargs argument, so there is no special reserved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; In [23]: import time. In [24]: def func(x): time.sleep(1). In [25]: result = parallel_map(func, range(50), progress_bar=True); 10.0%. Run time: 3.01s. Est. time left: 00:00:00:27; 20.0%. Run time: 5.01s. Est. time left: 00:00:00:20; 30.0%. Run time: 8.02s. Est. time left: 00:00:00:18; 40.0%. Run time: 10.02s. Est. time left: 00:00:00:15; 50.0%. Run time: 13.02s. Est. time left: 00:00:00:13; 60.0%. Run time: 15.03s. Est. time left: 00:00:00:10; 70.0%. Run time: 18.03s. Est. time left: 00:00:00:07; 80.0%. Run time: 20.03s. Est. time left: 00:00:00:05; 90.0%. Run time: 23.04s. Est. time left: 00:00:00:02; 100.0%. Run time: 25.04s. Est. time left: 00:00:00:00; Total run time: 25.07s. Parallel processing is useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-based parallel_map¶. Note; New in QuTiP 3. When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parallel_map. The advantage of this parallel_map implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-parfor.html:6809,config,configurations,6809,docs/4.3/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-parfor.html,1,['config'],['configurations']
Modifiability,"sing:; In [17]: expt10 = data.expect[1] # <- expectation values avg. over 10 trajectories. In [18]: expt100 = data.expect[2] # <- expectation values avg. over 100 trajectories. In [19]: expt1000 = data.expect[3] # <- expectation values avg. over 1000 trajectories. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; In [20]: options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; In [21]: psi0 = tensor(fock(2, 0), fock(10, 5)). In [22]: a = tensor(qeye(2), destroy(10)). In [23]: sm = tensor(destroy(2), qeye(10)). In [24]: H = 2 * np.pi * a.dag() * a + 2 * np.pi * sm.dag() * sm + \; ....: 2 * np.pi * 0.25 * (sm * a.dag() + sm.dag() * a); ....: . In [25]: data1 = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); 10.0%. Run time: 0.60s. Est. time left: 00:00:00:05; 20.0%. Run time: 1.13s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-monte.html:16674,config,configuration,16674,docs/4.2/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-monte.html,1,['config'],['configuration']
Modifiability,"sing:; In [17]: expt10 = data.expect[1] # <- expectation values avg. over 10 trajectories. In [18]: expt100 = data.expect[2] # <- expectation values avg. over 100 trajectories. In [19]: expt1000 = data.expect[3] # <- expectation values avg. over 1000 trajectories. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; In [20]: options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; In [21]: psi0 = tensor(fock(2, 0), fock(10, 5)). In [22]: a = tensor(qeye(2), destroy(10)). In [23]: sm = tensor(destroy(2), qeye(10)). In [24]: H = 2 * np.pi * a.dag() * a + 2 * np.pi * sm.dag() * sm + \; ....: 2 * np.pi * 0.25 * (sm * a.dag() + sm.dag() * a); ....: . In [25]: data1 = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); 10.0%. Run time: 0.62s. Est. time left: 00:00:00:05; 20.0%. Run time: 1.17s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/dynamics/dynamics-monte.html:16670,config,configuration,16670,docs/4.1/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.1/guide/dynamics/dynamics-monte.html,1,['config'],['configuration']
Modifiability,"sing:; In [17]: expt10 = data.expect[1] # <- expectation values avg. over 10 trajectories. In [18]: expt100 = data.expect[2] # <- expectation values avg. over 100 trajectories. In [19]: expt1000 = data.expect[3] # <- expectation values avg. over 1000 trajectories. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; In [20]: options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; In [21]: psi0 = tensor(fock(2, 0), fock(10, 5)). In [22]: a = tensor(qeye(2), destroy(10)). In [23]: sm = tensor(destroy(2), qeye(10)). In [24]: H = 2 * np.pi * a.dag() * a + 2 * np.pi * sm.dag() * sm + \; ....: 2 * np.pi * 0.25 * (sm * a.dag() + sm.dag() * a); ....: . In [25]: data1 = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); 10.0%. Run time: 1.20s. Est. time left: 00:00:00:10; 20.0%. Run time: 2.49s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-monte.html:12996,config,configuration,12996,docs/3.1.0/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-monte.html,1,['config'],['configuration']
Modifiability,"sing:; In [17]: expt10 = data.expect[1] # <- expectation values avg. over 10 trajectories. In [18]: expt100 = data.expect[2] # <- expectation values avg. over 100 trajectories. In [19]: expt1000 = data.expect[3] # <- expectation values avg. over 1000 trajectories. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; In [20]: options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; In [21]: psi0 = tensor(fock(2, 0), fock(10, 5)). In [22]: a = tensor(qeye(2), destroy(10)). In [23]: sm = tensor(destroy(2), qeye(10)). In [24]: H = 2 * np.pi * a.dag() * a + 2 * np.pi * sm.dag() * sm + \; ....: 2 * np.pi * 0.25 * (sm * a.dag() + sm.dag() * a); ....: . In [25]: data1 = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); 10.0%. Run time: 1.78s. Est. time left: 00:00:00:15; 20.0%. Run time: 3.93s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html:16540,config,configuration,16540,docs/4.3/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html,1,['config'],['configuration']
Modifiability,"sing:; In [17]: expt10 = data.expect[1] # <- expectation values avg. over 10 trajectories. In [18]: expt100 = data.expect[2] # <- expectation values avg. over 100 trajectories. In [19]: expt1000 = data.expect[3] # <- expectation values avg. over 1000 trajectories. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; In [20]: options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; In [21]: psi0 = tensor(fock(2, 0), fock(10, 5)). In [22]: a = tensor(qeye(2), destroy(10)). In [23]: sm = tensor(destroy(2), qeye(10)). In [24]: H = 2 * np.pi * a.dag() * a + 2 * np.pi * sm.dag() * sm + \; ....: 2 * np.pi * 0.25 * (sm * a.dag() + sm.dag() * a); ....: . In [25]: data1 = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); 10.0%. Run time: 6.57s. Est. time left: 00:00:00:59; 20.0%. Run time: 15.65",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-monte.html:16700,config,configuration,16700,docs/4.0.2/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-monte.html,1,['config'],['configuration']
Modifiability,"sinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H, chi_0/chi_0.norm(), taulist + tlist[t_idx], c_ops,; [b_op],; args=args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H, chi/chi.norm(), taulist + tlist[t_idx], c_ops,; [b_op],; args=args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat_add = np.asarray(; 1.0 / (4*options.ntraj[0]) *; (c_tau[0] - c_tau[2] - 1j*c_tau[1] + 1j*c_tau[3]),; dtype=corr_mat.dtype; ); corr_mat[t_idx, :] += corr_mat_add. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # pseudo-inverse solvers; def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; r""""""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\tau)B(0)\right>`.; """""". L = H if issuper(H) else liouvillian(H, c_ops). tr_mat = tensor([qeye(n) for n in L.dims[0][0]]); N = np.prod(L.dims[0][0]). A = L.full(); b = spre(b_op).full(); a = spre(a_op).full(). tr_vec = np.tr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/correlation.html:35526,evolve,evolve,35526,docs/4.7/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html,1,['evolve'],['evolve']
Modifiability,"sinstance(gate, Gate):; name = gate.name; targets = gate.targets; controls = gate.controls; arg_value = gate.arg_value; arg_label = gate.arg_label; classical_controls = gate.classical_controls; control_value = gate.control_value. else:; name = gate. if index is None:; gate = Gate(name, targets=targets, controls=controls,; arg_value=arg_value, arg_label=arg_label,; classical_controls=classical_controls,; control_value=control_value); self.gates.append(gate). else:; # NOTE: Every insertion shifts the indices in the original list of; # gates by an additional position to the right.; shifted_inds = np.sort(index) + np.arange(len(index)); for position in shifted_inds:; gate = Gate(name, targets=targets, controls=controls,; arg_value=arg_value, arg_label=arg_label,; classical_controls=classical_controls,; control_value=control_value); self.gates.insert(position, gate). [docs] def add_1q_gate(self, name, start=0, end=None, qubits=None,; arg_value=None, arg_label=None,; classical_controls=None, control_value=None):; """"""; Adds a single qubit gate with specified parameters on a variable; number of qubits in the circuit. By default, it applies the given gate; to all the qubits in the register. Parameters; ----------; name : string; Gate name.; start : int; Starting location of qubits.; end : int; Last qubit for the gate.; qubits : list; Specific qubits for applying gates.; arg_value : float; Argument value(phi).; arg_label : string; Label for gate representation.; """"""; if name not in _single_qubit_gates:; raise ValueError(""%s is not a single qubit gate"" % name). if qubits is not None:; for _, i in enumerate(qubits):; gate = Gate(name, targets=qubits[i], controls=None,; arg_value=arg_value, arg_label=arg_label,; classical_controls=classical_controls,; control_value=control_value); self.gates.append(gate). else:; if end is None:; end = self.N - 1; for i in range(start, end+1):; gate = Gate(name, targets=i, controls=None,; arg_value=arg_value, arg_label=arg_label,; classical_contr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/circuit.html:15039,variab,variable,15039,docs/4.7/modules/qutip/qip/circuit.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/circuit.html,1,['variab'],['variable']
Modifiability,"sional array of covariance values. logarithmic_negativity(V)[source]¶; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see qutip.continous_variables.covariance_matrix. Note that; the two-mode field state that is described by V must be Gaussian for this; function to applicable. Parameters:; V : 2d array; The covariance matrix. Returns:; N : float; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. Dynamics and Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, psi0, tlist, e_ops=[], args={}, options=None, progress_bar=None, _safe_mode=True)[source]¶; Schrodinger equation evolution of a state vector or unitary matrix; for a given Hamiltonian.; Evolve the state vector (psi0) using a given; Hamiltonian (H), by integrating the set of ordinary differential; equations that define the system. Alternatively evolve a unitary matrix in; solving the Schrodinger operator equation.; The output is either the state vector or unitary matrix at arbitrary points; in time (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters:; H : qutip.qobj; system Hamiltonian, or a callback function for time-dependent; Hamiltonians. psi0 : qutip.qobj; initial state vector (ket); or initial unitary operator psi0 = U. tlist : list / array; list of times for \(t\). e_ops : list of qutip.qobj / callback function single; single operator or list of operators for which to evaluate; expectation values.; Must be empty list operator evolution. args : dictionary; dictionary of parameters for time-dependent Hamiltonians. options : qutip.Qdeoptions; with options for the ODE solver. progr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:53363,evolve,evolve,53363,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['evolve'],['evolve']
Modifiability,"sis. lindbladian(self)[source]¶; Build the Lindbladian superoperator of the dissipative dynamics. Returns. lindbladianqutip.QobjThe Lindbladian matrix as a qutip.Qobj. liouvillian(self)[source]¶; Build the total Liouvillian using the Dicke basis. Returns. liouvqutip.QobjThe Liouvillian matrix for the system. pisolve(self, initial_state, tlist, options=None)[source]¶; Solve for diagonal Hamiltonians and initial states faster. Parameters. initial_statequtip.QobjAn initial state specified as a density matrix of; qutip.Qbj type. tlist: ndarrayA 1D numpy array of list of timesteps to integrate. optionsqutip.solver.OptionsThe options for the solver. Returns. result: listA dictionary of the type qutip.solver.Result which holds the; results of the evolution. class Pim(N, emission=0.0, dephasing=0, pumping=0, collective_emission=0, collective_pumping=0, collective_dephasing=0)[source]¶; The Permutation Invariant Matrix class.; Initialize the class with the parameters for generating a Permutation; Invariant matrix which evolves a given diagonal initial state p as:. dp/dt = Mp. Parameters. N: intThe number of two-level systems. emission: floatIncoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: floatLocal dephasing coefficient.; default: 0.0. pumping: floatIncoherent pumping coefficient.; default: 0.0. collective_emission: floatCollective (superradiant) emmission coefficient.; default: 0.0. collective_pumping: floatCollective pumping coefficient.; default: 0.0. collective_dephasing: floatCollective dephasing coefficient.; default: 0.0. Attributes. N: intThe number of two-level systems. emission: floatIncoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: floatLocal dephasing coefficient.; default: 0.0. pumping: floatIncoherent pumping coefficient.; default: 0.0. collective_emission: floatCollective (superradiant) emmission coefficient.; default: 0.0. collective_dephasing: floatCollective dephasing coefficient.;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:54614,evolve,evolves,54614,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['evolve'],['evolves']
Modifiability,"sition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """"""; return sum([f_modes_t[i] * exp(-1j * f_energies[i] * t) * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None):; """"""; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """""". f_states_t = floquet_states_t(f_modes_0, f_energies, t, H, T, args); return sum([f_states_t[i] * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_state_decomposition(f_states, f_energies, psi):; """"""; Decompose the wavefunction `psi` (typically an initial state) in terms of; the Floquet states, :math:`\psi = \sum_\\alpha c_\\alpha \psi_\\alpha(0)`. Parameters; ----------. f_states : list of :class:`qutip.qobj` (kets); A list of Floquet modes. f_energies : array; The Floquet energies. psi : :class:`qutip.qobj`; The wavefunction to decompose in the Floquet state basis. Returns; -------. output : array. The coefficients :math:`c_\\alpha` in the Floquet state decomposition. """"""; # [:1,:1][0, 0] patch around scipy 1.3.0 bug; return [(f_states[i].dag() * psi).data[:1, :1][0, 0]; for i in np.arange(len(f_energies))]. [docs]def fsesolve(H, psi0, tl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/floquet.html:11394,variab,variables,11394,docs/4.5/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/floquet.html,1,['variab'],['variables']
Modifiability,"sition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """"""; return sum([f_modes_t[i] * exp(-1j * f_energies[i] * t) * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None):; """"""; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """""". f_states_t = floquet_states_t(f_modes_0, f_energies, t, H, T, args); return sum([f_states_t[i] * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_state_decomposition(f_states, f_energies, psi):; """"""; Decompose the wavefunction `psi` (typically an initial state) in terms of; the Floquet states, :math:`\psi = \sum_\\alpha c_\\alpha \psi_\\alpha(0)`. Parameters; ----------. f_states : list of :class:`qutip.qobj` (kets); A list of Floquet modes. f_energies : array; The Floquet energies. psi : :class:`qutip.qobj`; The wavefunction to decompose in the Floquet state basis. Returns; -------. output : array. The coefficients :math:`c_\\alpha` in the Floquet state decomposition. """"""; # [:1,:1][0, 0] patch around scipy 1.3.0 bug; return [(f_states[i].dag() * psi).data[:1,:1][0, 0]; for i in np.arange(len(f_energies))]. [docs]def fsesolve(H, psi0, tli",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/floquet.html:11381,variab,variables,11381,docs/4.4/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/floquet.html,1,['variab'],['variables']
Modifiability,"sition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """"""; return sum([f_modes_t[i] * exp(-1j * f_energies[i] * t) * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None):; """"""; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """""". f_states_t = floquet_states_t(f_modes_0, f_energies, t, H, T, args); return sum([f_states_t[i] * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_state_decomposition(f_states, f_energies, psi):; """"""; Decompose the wavefunction `psi` (typically an initial state) in terms of; the Floquet states, :math:`\psi = \sum_\\alpha c_\\alpha \psi_\\alpha(0)`. Parameters; ----------. f_states : list of :class:`qutip.qobj` (kets); A list of Floquet modes. f_energies : array; The Floquet energies. psi : :class:`qutip.qobj`; The wavefunction to decompose in the Floquet state basis. Returns; -------. output : array. The coefficients :math:`c_\\alpha` in the Floquet state decomposition. """"""; return [(f_states[i].dag() * psi).data[0, 0]; for i in np.arange(len(f_energies))]. [docs]def fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100):; """"""; Sol",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/floquet.html:11286,variab,variables,11286,docs/4.2/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/floquet.html,5,['variab'],['variables']
Modifiability,"sition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """"""; return sum([f_modes_t[i] * exp(-1j * f_energies[i] * t) * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None):; """"""; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """""". f_states_t = floquet_states_t(f_modes_0, f_energies, t, H, T, args); return sum([f_states_t[i] * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_state_decomposition(f_states, f_energies, psi):; r""""""; Decompose the wavefunction `psi` (typically an initial state) in terms of; the Floquet states, :math:`\psi = \sum_\alpha c_\alpha \psi_\alpha(0)`. Parameters; ----------. f_states : list of :class:`qutip.qobj` (kets); A list of Floquet modes. f_energies : array; The Floquet energies. psi : :class:`qutip.qobj`; The wavefunction to decompose in the Floquet state basis. Returns; -------. output : array. The coefficients :math:`c_\alpha` in the Floquet state decomposition. """"""; # [:1,:1][0, 0] patch around scipy 1.3.0 bug; return [(f_states[i].dag() * psi).data[:1, :1][0, 0]; for i in np.arange(len(f_energies))]. [docs]def fsesolve(H, psi0, tlist",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/floquet.html:11413,variab,variables,11413,docs/4.6/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html,1,['variab'],['variables']
Modifiability,"solver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """""". if debug:; print(inspect.stack()[0][3]); ; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, psi0, c_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:7159,config,config,7159,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,3,['config'],['config']
Modifiability,"solver does not currently support time-dependent Hamiltonians. Parameters:; H (qutip.Qobj) – System Hamiltonian.; / psi0 (rho0) – Initial density matrix or state vector (ket).; tlist (list / array) – List of times for \(t\).; a_ops (list of qutip.qobj) – List of system operators that couple to bath degrees of freedom.; e_ops (list of qutip.qobj / callback function) – List of operators for which to evaluate expectation values.; c_ops (list of qutip.qobj) – List of system collapse operators.; args (dictionary) – Placeholder for future implementation, kept for API consistency.; options (qutip.solver.Options) – Options for the solver. Returns:result – An instance of the class qutip.solver.Result, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by tlist. Return type:qutip.solver.Result. bloch_redfield_tensor(H, a_ops, spectra_cb, c_ops=[], use_secular=True)[source]¶; Calculate the Bloch-Redfield tensor for a system given a set of operators; and corresponding spectral functions that describes the system’s coupling; to its environment. Note; This tensor generation requires a time-independent Hamiltonian. Parameters:; H (qutip.qobj) – System Hamiltonian.; a_ops (list of qutip.qobj) – List of system operators that couple to the environment.; spectra_cb (list of callback functions) – List of callback functions that evaluate the noise power spectrum; at a given frequency.; c_ops (list of qutip.qobj) – List of system collapse operators.; use_secular (bool) – Flag (True of False) that indicates if the secular approximation should; be used. Returns:R, kets – R is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. Return type:qutip.Qobj, list of qutip.Qobj. bloch_redfield_solve(R, ekets, rho0, tlist, e_ops=[], options=None)[source]¶; Evolve the ODEs defined by Bloch-Redfield master equation. The; Bloch-Redfield tensor can be calculated by the function; bloch_redfield_tensor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:66466,coupling,coupling,66466,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['coupling'],['coupling']
Modifiability,"solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix represenation to. msg = ""Incorrect specification of time-dependence: "". for h_spec in H:; if isinstance(h_spec, Qobj):; h = h_spec. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; Lconst += -1j * (spre(h) - spost(h)); elif h.issuper:; Lconst += h; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; L = -1j * (spre(h) - spost(h)); elif h.issuper:; L = h; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/rhs_generate.html:3917,config,config,3917,docs/4.4/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/rhs_generate.html,3,['config'],['config']
Modifiability,"source]¶; Calculate the process fidelity given two process operators. tracedist(A, B, sparse=False, tol=0)[source]¶; Calculates the trace distance between two density matrices..; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters. AqobjDensity matrix or state vector. BqobjDensity matrix or state vector with same dimensions as A. tolfloatTolerance used by sparse eigensolver, if used. (0=Machine precision). sparse{False, True}Use sparse eigensolver. Returns. tracedistfloatTrace distance between A and B. Examples; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> np.testing.assert_almost_equal(tracedist(x,y), 0.9705143161472971). unitarity(oper)[source]¶; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map’s superoperator representation. Parameters. operQobjQuantum map under consideration. Returns. ufloatUnitarity of oper. Continuous Variables¶; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields. correlation_matrix(basis, rho=None)[source]¶; Given a basis set of operators \(\{a\}_n\), calculate the correlation; matrix:. \[C_{mn} = \langle a_m a_n \rangle\]. Parameters. basislistList of operators that defines the basis for the correlation matrix. rhoQobjDensity matrix for which to calculate the correlation matrix. If; rho is None, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns. corr_matndarrayA 2-dimensional array of correlation values or operators. correlation_matrix_field(a1, a2, rho=None)[source]¶; Calculates the correlation matrix for given field operators \(a_1\) and; \(a_2\). If a density matrix is given the expectation values are; calculated, otherwise a matrix with operators is returned. Parameters. a1QobjField operator for mode 1. a2QobjField operator for mode 2. rhoQobjDensity matrix for which to calculate the ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:67176,variab,variable,67176,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['variab'],['variable']
Modifiability,"source]¶; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters. dynmapslist of qutip.QobjList of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0qutip.QobjInitial density matrix or state vector (ket). timesarray_likelist of times \(t_n\) at which to compute \(\rho(t_n)\).; Must be uniformily spaced. e_opslist of qutip.Qobj / callback functionsingle operator or list of operators for which to evaluate; expectation values. learningtimesarray_likelist of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The C",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:155351,config,configuration,155351,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,3,['config'],['configuration']
Modifiability,"spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected string format)""). L = -1j * h. Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(h_coeff). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; norm, dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (un",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html:12177,config,config,12177,docs/3.1.0/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability,"specified tolerance; # ------------------------------------------------; ii = 0; t_final = ODE.t; while ii < config.norm_steps:; ii += 1; t_guess = t_prev + \; np.log(norm2_prev / rand_vals[0]) / \; np.log(norm2_prev / norm2_psi) * (t_final - t_prev); ODE._y = y_prev; ODE.t = t_prev; ODE._integrator.call_args[3] = 1; ODE.integrate(t_guess, step=0); if not ODE.successful():; raise Exception(; ""ZVODE failed after adjusting step size!""); norm2_guess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:25931,config,config,25931,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"spect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(self, term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to defi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:81232,config,config,81232,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['config'],['config']
Modifiability,"spect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:195093,config,config,195093,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['config'],['config']
Modifiability,"spect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes:; max_metric_corr : integer; The maximum number of variable metric corrections used to defi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:75331,config,config,75331,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['config'],['config']
Modifiability,"spect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. max_metric_corr¶; integer – The maximum number of variable metric corrections used to define; the limi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:67448,config,config,67448,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['config'],['config']
Modifiability,"spect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm; Attributes. max_metric_corr; (integer) The maximum number of variable metric corrections used to defin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:64446,config,config,64446,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['config'],['config']
Modifiability,"sphere function. (by Nithin Ramu).; ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits.; QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by Boxi Li).; Added the quantum Hellinger distance to qutip.metrics (by Wojciech Rzadkowski).; Implemented possibility of choosing a random seed (by Marek Marekyggdrasil).; Added a code of conduct to Github. Bug Fixes¶. Fixed bug that made QuTiP incompatible with SciPy 1.3. Version 4.3.0 (July 14, 2018)¶. Improvements¶. MAJOR FEATURE: Added the Permutational Invariant Quantum Solver (PIQS) module (by Nathan Shammah and Shahnawaz Ahmed) which allows the simluation of large TLSs ensembles including collective and local Lindblad dissipation. Applications range from superradiance to spin squeezing.; MAJOR FEATURE: Added a photon scattering module (by Ben Bartlett) which can be used to study scattering in arbitrary driven systems coupled to some configuration of output waveguides.; Cubic_Spline functions as time-dependent arguments for the collapse operators in mesolve are now allowed.; Added a faster version of bloch_redfield_tensor, using components from the time-dependent version. About 3x+ faster for secular tensors, and 10x+ faster for non-secular tensors.; Computing Q.overlap() [inner product] is now ~30x faster.; Added projector method to Qobj class.; Added fast projector method, Q.proj().; Computing matrix elements, Q.matrix_element is now ~10x faster.; Computing expectation values for ket vectors using expect is now ~10x faster.; Q.tr() is now faster for small Hilbert space dimensions.; Unitary operator evolution added to sesolve; Use OPENMP for tidyup if installed. Bug Fixes¶. Fixed bug that stopped simdiag working for python 3.; Fixed semidefinite cvxpy Variable and Parameter.; Fixed iterative lu solve atol keyword issue.; Fixed unitary op evolution rhs matrix",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/changelog.html:7293,config,configuration,7293,docs/4.5/changelog.html,https://qutip.org,https://qutip.org/docs/4.5/changelog.html,3,['config'],['configuration']
Modifiability,"spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:17692,config,config,17692,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,10,['config'],['config']
Modifiability,"sponding ceofficients are passed; as ck_plus. ck_minuslist of complexThe coefficients of the expansion terms for the - part of the; correlation function. The corresponding frequencies are passed as; vk_minus. vk_minuslist of complexThe frequencies (exponents) of the expansion terms for the - part; of the correlation function. The corresponding ceofficients are passed; as ck_minus. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. class LorentzianBath(Q, gamma, w, mu, T, Nk, tag=None)[source]¶; A helper class for constructing a Lorentzian fermionic bath from the; bath parameters (see parameters below). Note; This Matsubara expansion used in this bath converges very slowly; and Nk > 20 may be required to get good convergence. The; Padé expansion used by LorentzianPadeBath converges much; more quickly. Parameters. QQobjOperator describing the coupling between system and bath. gammafloatThe coupling strength between the system and the bath. wfloatThe width of the environment. mufloatThe chemical potential of the bath. TfloatBath temperature. NkintNumber of exponential terms used to approximate the bath correlation; functions. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. class LorentzianPadeBath(Q, gamma, w, mu, T, Nk, tag=None)[source]¶; A helper class for constructing a Padé expansion for Lorentzian fermionic; bath from the bath parameters (see parameters below).; A Padé approximant is a sum-over-poles expansion (; see https://en.wikipedia.org/wiki/Pad%C3%A9_approximant).; The application of the Padé method to spectrum decompoisitions is described; in “Padé spectrum decompositions of quantum distribution functions and; optimal hierarchical equations of motion construction for ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:60628,coupling,coupling,60628,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,1,['coupling'],['coupling']
Modifiability,"sr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.conj().transpose(),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.conj().transpose(). # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:22732,config,config,22732,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"sr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_op",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:21740,config,config,21740,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"sr_matrix; System Hamiltonian.; psi0: np.ndarray; Initial state vector.; krylov_basis: np.ndarray; Krylov basis projector operator.; tlist: list; List of timesteps for the time evolution.; t0: float; Initial time for the time evolution.; psi_norm: float (optional, default False); Norm-2 of psi0.; krylov_basis: np.ndarray (optional, default None); Krylov basis projector operator. If 'krylov_basis' is None, perform; a lanczos iteration.; T_m: np.ndarray (optional, default None); Tridiagonal matrix decomposition of the system given by lanczos; algorithm. If 'T_m' is None, perform a lanczos iteration.; Returns; ---------; psi_list: List[np.ndarray]; List of evolved states at times t in 'tlist'.; """""". if psi_norm is None:; psi_norm = np.linalg.norm(psi0). if psi_norm != 1:; psi = psi0 / psi_norm; else:; psi = psi0. if (krylov_basis is None) or (T_m is None):; krylov_basis, T_m = lanczos_algorithm(; H=H, psi=psi, krylov_dim=krylov_dim, sparse=sparse; ). evolve = _evolve(t0, krylov_basis, T_m); psi_list = list(map(evolve, tlist)). return psi_list. # ----------------------------------------------------------------------; # Auxiliar functions. def _check_inputs(H, psi0, krylov_dim):; """"""Check that the inputs 'H' and 'psi0' have the correct structures.""""""; if not isinstance(H, Qobj):; raise TypeError(; ""krylovsolve currently supports Hamiltonian Qobj operators only""; ). if not H.isherm:; raise TypeError(""Hamiltonian 'H' must be hermician.""). if not isinstance(psi0, Qobj):; raise TypeError(""'psi0' must be a Qobj.""). if not psi0.isket:; raise TypeError(""Initial state must be a ket Qobj.""). if not ((len(H.shape) == 2) and (H.shape[0] == H.shape[1])):; raise ValueError(""the Hamiltonian must be 2-dimensional square Qobj.""). if not (psi0.dims[0] == H.dims[0]):; raise ValueError(; ""'psi0' and the Hamiltonian must share the same dimension.""; ). if not (H.shape[0] >= krylov_dim):; raise ValueError(; ""the Hamiltonian dimension must be greater or equal to the maximum""; "" allowed krylov ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:10829,evolve,evolve,10829,docs/4.7/modules/qutip/krylovsolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html,2,['evolve'],['evolve']
Modifiability,"ss HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4).; Attributes. cut_freq; (float) Bath spectral density cutoff frequency. renorm; (bool) Apply renormalisation to coupling terms Can be useful if using SI units for planck and boltzmann. bnd_cut_approx; (bool) Use boundary cut off approximation Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters:rho0 : Qobj. Initial state (density matrix) of the system. tlist : list. Time over which system evolves. Returns:results : qutip.solver.Result. Object storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback.; Attributes. H_S; (qutip.Qobj) System Hamiltonian (can also be a Liouvillian). L1; (qutip.Qobj / list of qutip.Qobj) System operators coupling into the feedback loop. Can be a single operator or a list of operators. L2; (qutip.Qobj / list of qutip.Qobj) System",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:26626,config,configure,26626,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,4,['config'],['configure']
Modifiability,"ssary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = BR_Codegen(h_terms=len(H_terms), ; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms), ; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; use_openmp=options.use_openmp, ; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus, ; atol=tol); ; cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; ; initial_vector = mat2vec(rho0.full()).ravel(); ; _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method, ; order=options.order, atol=options.atol, ; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step, ; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_value(initial_vector, tlist[0]); exec(code, locals()); ; #; # prepare output array; #; n_tsteps = len(tlist); e_sops_data = []. output = Result(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html:18682,config,config,18682,docs/4.2/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html,1,['config'],['config']
Modifiability,"st : list of qutip.qobj. list of qutip.qobj collapse operators. e_ops : list of qutip.qobj. list of qutip.qobj operators for which to evaluate; expectation values. Returns:expt_array : array. Expectation values of wavefunctions/density matrices for the; times specified in tlist. Note; This solver does not support time-dependent Hamiltonians. ode2es(L, rho0)[source]¶; Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) rho0, given the Liouvillian; (or Hamiltonian) L. Parameters:L : qobj. Liouvillian of the system. rho0 : qobj. Initial state vector or density matrix. Returns:eseries : qutip.eseries. eseries represention of the system dynamics. Bloch-Redfield Master Equation¶. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Exam",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:63462,coupling,coupling,63462,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,1,['coupling'],['coupling']
Modifiability,"st Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). ; # Remove RHS cython file if necessary; if not opt.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname); ; #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, arg",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/sesolve.html:12582,config,config,12582,docs/4.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html,2,['config'],['config']
Modifiability,"st with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'). if opt.rhs_reuse and config.tdfunc is None:; rhs_generate(H_func, args). lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; L_func = [[liouvillian(H_func[0][0], c_op_list)], H_func[1]]; for m in range(1, lenh):; L_func[0].append(liouvillian(H_func[0][m], [])). # create data arrays for time-dependent RHS function; Ldata = [L_func[0][k].data.data for k in range(lenh)]; Linds = [L_func[0][k].data.indices for k in range(lenh)]; Lptrs = [L_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Ldata[%d], Linds[%d], Lptrs[%d],"" % (k, k, k)). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depend",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:32327,config,config,32327,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,5,['config'],['config']
Modifiability,"stance between two density matrices A & B. Parameters:; A : qobj; Density matrix or state vector. B : qobj; Density matrix or state vector with same dimensions as A. Returns:; dist : float; Hilbert-Schmidt distance between density matrices. Notes; See V. Vedral and M. B. Plenio, Phys. Rev. A 57, 1619 (1998). average_gate_fidelity(oper, target=None)[source]¶; Given a Qobj representing the supermatrix form of a map, returns the; average gate fidelity (pseudo-metric) of that map. Parameters:; A : Qobj; Quantum object representing a superoperator. target : Qobj; Quantum object representing the target unitary; the inverse; is applied before evaluating the fidelity. Returns:; fid : float; Fidelity pseudo-metric between A and the identity superoperator,; or between A and the target superunitary. process_fidelity(U1, U2, normalize=True)[source]¶; Calculate the process fidelity given two process operators. Continuous Variables¶; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields. correlation_matrix(basis, rho=None)[source]¶; Given a basis set of operators \(\{a\}_n\), calculate the correlation; matrix:. \[C_{mn} = \langle a_m a_n \rangle\]. Parameters:; basis : list; List of operators that defines the basis for the correlation matrix. rho : Qobj; Density matrix for which to calculate the correlation matrix. If; rho is None, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns:; corr_mat : ndarray; A 2-dimensional array of correlation values or operators. covariance_matrix(basis, rho, symmetrized=True)[source]¶; Given a basis set of operators \(\{a\}_n\), calculate the covariance; matrix:. \[V_{mn} = \frac{1}{2}\langle a_m a_n + a_n a_m \rangle -; \langle a_m \rangle \langle a_n\rangle\]; or, if of the optional argument symmetrized=False,. \[V_{mn} = \langle a_m a_n\rangle -; \langle a_m \rangle \langle a_n\ra",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:48966,variab,variable,48966,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['variab'],['variable']
Modifiability,"stance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; sparse : bool (default False); Use np.array to represent system Hamiltonians. If True, scipy sparse; arrays are used instead. Returns; -------; result: :class:`qutip.solver.Result`; An instance of the class :class:`qutip.solver.Result`, which contains; either an *array* `result.expect` of expectation values for the times; `tlist`, or an *array* `result.states` of state vectors corresponding; to the times `tlist` [if `e_ops` is an empty list].; """"""; # check the physics; _check_inputs(H, psi0, krylov_dim). # check extra inputs; e_ops, e_ops_dict = _check_e_ops(e_ops); pbar = _check_progress_bar(progress_bar). # transform inputs type from Qobj to np.ndarray/csr_matrix; if sparse:; _H = H.get_data() # (fast_) csr_matrix; else:; _H = H.full().copy() # np.ndarray; _psi = psi0.full().copy(); _psi = _psi / np.linalg.norm(_psi). # create internal variable and output containers; if options is None:; options = Options(nsteps=10000); krylov_results = Result(); krylov_results.solver = ""krylovsolve"". # handle particular cases of an empty tlist or single element; n_tlist_steps = len(tlist); if n_tlist_steps < 1:; return krylov_results. if n_tlist_steps == 1: # if tlist has only one element, return it; krylov_results = particular_tlist_or_happy_breakdown(; tlist, n_tlist_steps, options, psi0, e_ops, krylov_results, pbar; ) # this will also raise a warning; return krylov_results. tf = tlist[-1]; t0 = tlist[0]. # optimization step using Lanczos, then reuse it for the first partition; dim_m = krylov_dim; krylov_basis, T_m = lanczos_algorithm(; _H, _psi, krylov_dim=dim_m, sparse=sparse; ). # check if a happy breakdown occurred; if T_m.shape[0] < krylov_dim + 1:; if T_m.shape[0] == 1:; # this means that the state does not evolve in time, it lies in a; # symmetry of H subspace. Thus, theres no work to be done.; krylov_results = particular_tlist_or_happy_breakdown(; tlist,; n_tlist_steps,; optio",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:3485,variab,variable,3485,docs/4.7/modules/qutip/krylovsolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html,1,['variab'],['variable']
Modifiability,"stance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz, sxsy)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class CircularSpinChain(N, correct_global_phase=True, sx=0.25, sz=1.0, sxsy=0.1, t1=None, t2=None)[source]¶; A processor based on the physical implementation of; a circular spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically. Parameters. N: intThe number of qubits in the system. correct_global_phase: floatSave the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. sx: int or listThe delta for each of the qubits in the system. sz: int or listThe e",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:138453,coupling,coupling,138453,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,1,['coupling'],['coupling']
Modifiability,"stance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz, sxsy)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class DispersiveCavityQED(N, correct_global_phase=True, num_levels=10, deltamax=1.0, epsmax=9.5, w0=10.0, wq=None, eps=9.5, delta=0.0, g=0.01, t1=None, t2=None)[source]¶; The processor based on the physical implementation of; a dispersive cavity QED system.; The available Hamiltonian of the system is predefined.; For a given pulse amplitude matrix, the processor can; calculate the state evolution under the given control pulse,; either analytically or numerically.; (Only additional attributes are documented here, for others please; refer to the parent class ModelProcessor). Parameters. N: intThe number of qubits in the system. correct_global_ph",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:148895,coupling,coupling,148895,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,1,['coupling'],['coupling']
Modifiability,"stance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:8695,config,config,8695,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,2,['config'],['config']
Modifiability,"stance(c_ops[ii], list):; if isinstance(c_ops[ii][0], Qobj):; _temp_state = c_ops[ii][0]; elif isinstance(c_ops[ii][0], tuple):; do_tests = False; for kk in range(len(c_ops[ii][0])):; _temp_state = c_ops[ii][0][kk]; _structure_check(Hdims, Htype, _temp_state); else:; raise Exception('Invalid td-list element.'); if do_tests:; _structure_check(Hdims, Htype, _temp_state). if isinstance(e_ops, list):; for ii in range(len(e_ops)):; if isinstance(e_ops[ii], Qobj):; _temp_state = e_ops[ii]; elif isinstance(e_ops[ii], list):; _temp_state = e_ops[ii][0]; else:; raise Exception('Invalid td-list element.'); _structure_check(Hdims,Htype,_temp_state); elif isinstance(e_ops, FunctionType):; pass; else:; raise Exception('Invalid e_ops specification.'). def _structure_check(Hdims, Htype, state):; if state is not None:; # Input state is a ket vector; if state.type == 'ket':; # Input is Hamiltonian; if Htype == 'oper':; if Hdims[1] != state.dims[0]:; raise Exception('Input operator and ket do not '; 'share same structure.'); # Input is super and state is ket; elif Htype == 'super':; if Hdims[1][1] != state.dims[0]:; raise Exception('Input operator and ket do not '; 'share same structure.'); else:; raise Exception('Invalid input operator.'); # Input state is a density matrix; elif state.type == 'oper':; # Input is Hamiltonian and state is density matrix; if Htype == 'oper':; if Hdims[1] != state.dims[0]:; raise Exception('Input operators do not '; 'share same structure.'); # Input is super op. and state is density matrix; elif Htype == 'super':; if Hdims[1] != state.dims:; raise Exception('Input operators do not '; 'share same structure.'). #; # create a global instance of the SolverConfiguration class; #; config = SolverConfiguration(). # for backwards compatibility; Odeoptions = Options; Odedata = Result. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/solver.html:28161,config,config,28161,docs/4.7/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html,1,['config'],['config']
Modifiability,"state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs'",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:28530,config,config,28530,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object at 0x2b225f631c18>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters. HqobjSystem Hamiltonian. c_opslistlist of collapse operators. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. name: strName of generated RHS. cleanup: boolWhether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). temporal_basis_vector(waveguide_emission_indices, n_time_bins)[source]¶; Generate a temporal basis vector for emissions at specified time bins into; specified waveguides. Parameters. waveguide_emission_indiceslist or tupleList of indices where photon emission occurs for each waveguide,; e.g. [[t1_wg1], [t1_wg2, t2_wg2], [], [t1_wg4, t2_wg4, t3_wg4]]. n_time_binsintNumber of time bins; the range over which each index can vary. Returns. temporal_basis_vector:class: qutip.QobjA basis vector representing photon scattering at the specified indices.; If there are W waveguides, T times, and N photon emissions, then the; basis vector has dimensionality (W*T)^N. temporal",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:112012,config,configuration,112012,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['config'],['configuration']
Modifiability,"state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:28357,config,config,28357,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); O",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:22528,config,config,22528,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"states[i] = Qobj(qtf90.qutraj_run.sol[0, i, :, :],; dims=self.dm_dims, shape=self.dm_shape); else:; # all trajectories as kets; if (ntraj == 1):; states = np.array([Qobj()] * nstep, dtype=object); for i in range(nstep):; states[i] = Qobj(np.matrix(; qtf90.qutraj_run.sol[0, 0, i, :]).transpose(),; dims=self.psi0_dims, shape=self.psi0_shape); else:; states = np.array([np.array([Qobj()] * nstep, dtype=object)] *; ntraj); for traj in range(ntraj):; for i in range(nstep):; states[traj][i] = Qobj(np.matrix(; qtf90.qutraj_run.sol[0, traj, i, :]).transpose(),; dims=self.psi0_dims, shape=self.psi0_shape); return states. def get_expect(self, nstep, ntraj):. if debug:; print(inspect.stack()[0][3]). if (config.options.average_expect):; expect = []; for j in range(config.e_num):; if config.e_ops_isherm[j]:; expect += [np.real(qtf90.qutraj_run.sol[j, 0, :, 0])]; else:; expect += [qtf90.qutraj_run.sol[j, 0, :, 0]]; else:; expect = np.array([[np.array([0. + 0.j] * nstep)] *; config.e_num] * ntraj); for j in range(config.e_num):; expect[:, j, :] = qtf90.qutraj_run.sol[j, :, :, 0]; return expect. def get_entropy(self, nstep):. if debug:; print(inspect.stack()[0][3]). if (not self.calc_entropy):; raise Exception('get_entropy: calc_entropy=False. Aborting.'); entropy = np.array([0.] * nstep); entropy[:] = qtf90.qutraj_run.reduced_state_entropy[:]; return entropy. def finalize():; # not in use... if debug:; print(inspect.stack()[0][3]). qtf90.qutraj_run.finalize_work(); qtf90.qutraj_run.finalize_sol(). def _gather(sols):; # gather list of Result objects, sols, into one.; sol = Result(); # sol = sols[0]; ntraj = sum([a.ntraj for a in sols]); sol.col_times = np.zeros((ntraj), dtype=np.ndarray); sol.col_which = np.zeros((ntraj), dtype=np.ndarray); sol.col_times[0:sols[0].ntraj] = sols[0].col_times; sol.col_which[0:sols[0].ntraj] = sols[0].col_which; sol.states = np.array(sols[0].states, dtype=object); sol.expect = np.array(sols[0].expect); if (hasattr(sols[0], 'entropy')):; sol.entropy = np",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:15750,config,config,15750,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,"states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:29173,config,config,29173,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"stem evolution is checked at at; evolution recomputation.; level 1 checks all propagators; level 2 checks eigen basis as well; Default is 0. unitarity_tol :; Tolerance used in checking if operator is unitary; Default is 1e-10. dump : :class:`qutip.control.dump.DynamicsDump`; Store of historical calculation data.; Set to None (Default) for no storing of historical data; Use dumping property to set level of data dumping. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the calculations; dumping will be set to SUMMARY during init_evo if dump_to_file is True; and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; dyn_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. """"""; def __init__(self, optimconfig, params=None):; self.config = optimconfig; self.params = params; self.reset(). def reset(self):; # Link to optimiser object if self is linked to one; self.parent = None; # Main functional attributes; self.time = None; self.initial = None; self.target = None; self.ctrl_amps = None; self.initial_ctrl_scaling = 1.0; self.initial_ctrl_offset = 0.0; self.drift_dyn_gen = None; self.ctrl_dyn_gen = None; self._tau = None; self._evo_time = None; self._num_ctrls = None; self._num_tslots = None; # attributes used for processing evolution; self.memory_optimization = 0; self.oper_dtype = None; self.cache_phased_dyn_gen = None; self.cache_prop_grad = None; self.cache_dyn_gen_eigenvectors_adj = None; self.sparse_eigen_decomp = None; self.dyn_dims = None; self.dyn_shape = None; self.sys_dims = None; self.sys_shape = None; self.time_depend_drift = False; self.time_depend_ctrl_dyn_gen = False; # These internal attributes will be of the internal operator data type; # used to compute the evolution; # This will be either ndarray or Qobj; se",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/dynamics.html:12094,config,config,12094,docs/4.7/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/dynamics.html,1,['config'],['config']
Modifiability,"str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:37023,config,config,37023,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,8,['config'],['config']
Modifiability,"such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; N = 10 # number of basis states to consider. a = destroy(N). H = a.dag() * a. psi0 = basis(N, 9) # initial state. kappa = 0.2 # coupling to oscillator. a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:15890,coupling,coupling,15890,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,2,['coupling'],['coupling']
Modifiability,"sult in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14217,config,config,14217,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"sult in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:15209,config,config,15209,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"sult. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14300,config,config,14300,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"sult. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:15292,config,config,15292,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"sults in Floquet basis or computational basis; (optional). k_maxintThe truncation of the number of sidebands (default 5). options_modesqutip.solver.Optionsoptions for the ODE solver. For computing Floquet modes. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which contains; either an array of expectation values for the times specified; by tlist. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100, options_modes=None)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters. Hqutip.QobjSystem Hamiltonian, time-dependent with period T. psi0qutip.qobjInitial state vector (ket). tlistlist / arraylist of times for \(t\). e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. TstepsintegerThe number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. options_modesqutip.solver.Optionsoptions for the ODE solver. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶. general_stochastic(state0, times, d1, d2, e_ops=[], m_ops=[], _safe_mode=True, len_d2=1, args={}, **kwargs)[source]¶; Solve stochastic general equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. state0qutip.QobjInitial state vector (ket) or density matrix as a vector. timeslist / arrayList of times for \(t\). Must be uniformly spaced. d1function, callable classFunction representing the deterministic evolution of the system. def d1(time (double), state (as",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:109832,variab,variables,109832,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['variab'],['variables']
Modifiability,"sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse ope",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15390,config,config,15390,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse ope",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:16382,config,config,16382,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"sume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns. ideal_evo: qutip.QobjEvoA QobjEvo representing the ideal evolution. get_noisy_qobjevo(self, dims)[source]¶; Get the QobjEvo representation of the noisy evolution. The result; can be used directly as input for the qutip solvers. Parameters. dims: int or listDimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns. noisy_evo: qutip.QobjEvoA QobjEvo representing the ideal evolution and coherent noise. c_ops: list of qutip.QobjEvoA list of (time-dependent) lindbald operators. print_info(self)[source]¶; Print the information of the pulse, including the ideal dynamics,; the coherent noise and the lindblad noise. property qobj¶; See parameter qobj. property targets¶; See parameter targets. property tlist¶; See parameter tlist. Optimal control¶. class Optimizer(config, dyn, params=None)[source]¶; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system. to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. algstringAlg",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:143473,config,config,143473,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,1,['config'],['config']
Modifiability,"t = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.conj().transpose(),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.conj().transpose(). # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:23731,config,config,23731,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"t Hamiltonians and; collapse operators. optionsqutip.Optionswith options for the ODE solver. unitary_mode = str (‘batch’, ‘single’)Solve all basis vectors simulaneously (‘batch’) or individually; (‘single’). parallelbool {False, True}Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns. aqobjInstance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters. UqobjOperator representing the propagator. Returns. aqobjInstance representing the steady-state density matrix. Time-dependent problems¶. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters. HqobjSystem Hamiltonian. c_opslistlist of collapse operators. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. name: strName of generated RHS. cleanup: boolWhether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:141434,config,config,141434,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['config'],['config']
Modifiability,"t RHS function; Ldata = [L_func[0][k].data.data for k in range(lenh)]; Linds = [L_func[0][k].data.indices for k in range(lenh)]; Lptrs = [L_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Ldata[%d], Linds[%d], Lptrs[%d],"" % (k, k, k)). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; def odesolve(H, rho0, tlist, c_op_list, e_ops, args=None, options=None):; """"""; Master equation evolution of a density matrix for a given Hamiltonian. Evolution of a state vector or density matrix (`rho0`) for a given; Hamiltonian (`H`) and set of collapse operators (`c_op_list`), by; integrating the set of ordinary differential equations that define the; system. T",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:32744,config,config,32744,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,5,['config'],['config']
Modifiability,"t an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(config, 'blas_opt_info'):; blas_info = config.blas_opt_info; else:; blas_info = {}; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas_info.keys() and ('-Wl,Accelerate' in blas_info['extra_link_args']):; blas = 'Accelerate'; else:; blas = 'Generic'; return blas. def available_cpu_count():; """"""; Get the number of cpus.; It tries to only get the number available to qutip.; """"""; import os; import multiprocessing; try:; import psutil; except ImportError:; psutil = None; num_cpu = 0. if 'QUTIP_NUM_PROCESSES' in os.environ:; # We consider QUTIP_NUM_PROCESSES=0 as unset.; num_cpu = int(os.environ['QUTIP_NUM_PROCESSES']). if num_cpu == 0 and 'SLURM_CPUS_PER_TASK' in os.environ:; num_cpu = int(os",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/utilities.html:8737,config,config,8737,docs/4.6/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html,4,['config'],['config']
Modifiability,"t integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, …) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The; first is an implementation of first order GRAPE, and is not further described; here, but there are the example notebooks. The second is referred to as Qtrl; (when a distinction needs to be made) as this was its name before it was; integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the; multi-variable optimisation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrap",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-control.html:13697,extend,extended,13697,docs/4.7/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html,1,['extend'],['extended']
Modifiability,"t of qutip.qobj (kets). Floquet modes at \(t\). f_energies : list. Floquet energies. t : float. The time at which to evaluate the floquet modes. H : qutip.qobj. system Hamiltonian, time-dependent with period T. args : dictionary. dictionary with variables required to evaluate H. T : float. The period of the time-dependence of the hamiltonian. Returns:output : list of kets. The Floquet modes as kets at time \(t\). floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters:f_modes_0 : list of qutip.qobj (kets). Floquet modes at \(t\). f_energies : list. Floquet energies. tlist : array. The list of times at which to evaluate the floquet modes. H : qutip.qobj. system Hamiltonian, time-dependent with period T. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. dictionary with variables required to evaluate H. Returns:output : nested list. A nested list of Floquet modes as kets for each time in tlist. floquet_modes_t_lookup(f_modes_table_t, t, T)¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters:f_modes_table_t : nested list of qutip.qobj (kets). A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. t : float. The time for which to evaluate the Floquet modes. T : float. The period of the time-dependence of the hamiltonian. Returns:output : nested list. A list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)¶; Evaluate the floquet states at time t given the initial Floquet modes. Parameters:f_modes_t : list of qutip.qobj (kets). A list of initial Floquet modes (for time \(t=0\)). f_energies : array. The Floquet energ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:50841,variab,variables,50841,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,2,['variab'],['variables']
Modifiability,"t rewrite our string term to read: 'A * exp(-(t / sig) ** 2)':; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e or pi will mess things up when using the string-based format. Collapse operators are handled in the exact same way. Function Based Hamiltonian¶; In the previous version of QuTiP, the simulation of time-dependent problems required writing the Hamiltonian itself as a Python function. However, this method does not allow for time-dependent collapse operators, and is therefore more restrictive. Furthermore, it is less efficient than the other methods for all but the most basic of Hamiltonians (see the next section for a comparison of times.). In this format, the entire Hamiltonian is written as a Python function:; def Hfunc(t, args):; H0 = args[0]; H1 = args[1]; w = 9 * exp(-(t/5.)**2); return H0 - w * H1. where the args variable must always be given, and is now a list of Hamiltonian terms: args=[H0, H1]. In this format, our call to the master equation is now:; >>> output = mesolve(Hfunc, psi0, times, c_ops, [a.dag() * a], args=[H0, H1]). We cannot evaluate time-dependent collapse operators in this format, so we can not simulate the previous harmonic oscillator decay example. A Quick Comparison of Simulation Times¶; Here we give a table of simulation times for the single-photon example using the different time-dependent formats and both the master equation and Monte Carlo solver. Format; Master Equation; Monte Carlo. Python Function; 2.1 sec; 27 sec. Cython String; 1.4 sec; 9 sec. Hamiltonian Function; 1.0 sec; 238 sec. For the current example, the table indicates that the Hamiltonian function method is in fact the fastest when using the master equation solver. This is because the simulation is quite small. In contrast, the Hamiltonian function is over 26x slower than the compiled string version when using the Monte Carlo solver. In thi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html:13898,variab,variable,13898,docs/3.0.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html,2,['variab'],['variable']
Modifiability,"t the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:; ; BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.du",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:3839,variab,variables,3839,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,5,['variab'],['variables']
Modifiability,"t the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:; ; BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.contr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:3848,variab,variables,3848,docs/4.5/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html,1,['variab'],['variables']
Modifiability,"t with period T. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. U : qutip.qobj; The propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns:; output : list of kets, list of quasi energies; Two lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters:; f_modes_0 : list of qutip.qobj (kets); Floquet modes at \(t\). f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : qutip.qobj; system Hamiltonian, time-dependent with period T. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. Returns:; output : list of kets; The Floquet modes as kets at time \(t\). floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters:; f_modes_0 : list of qutip.qobj (kets); Floquet modes at \(t\). f_energies : list; Floquet energies. tlist : array; The list of times at which to evaluate the floquet modes. H : qutip.qobj; system Hamiltonian, time-dependent with period T. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; dictionary with variables required to evaluate H. Returns:; output : nested list; A nested list of Floquet modes as kets for each time in tlist. floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:72008,variab,variables,72008,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['variab'],['variables']
Modifiability,"t(final_states, probabilities, cbits=None)[source]¶. get_cbits(index=None)[source]¶; Return list of classical bit outputs corresponding to the results. Parameters. index: intIndicates i-th output, probability pair to be returned. Returns. cbits: list of int or list of list of intlist of classical bit outputs. get_final_states(index=None)[source]¶; Return list of output states. Parameters. index: intIndicates i-th state to be returned. Returns. final_states: Qobj or list of Qobj.List of output kets or density matrices. get_probabilities(index=None)[source]¶; Return list of probabilities corresponding to the output states. Parameters. index: intIndicates i-th probability to be returned. Returns. probabilities: float or list of floatProbabilities associated with each output state. class CircuitSimulator(qc, state=None, cbits=None, U_list=None, measure_results=None, mode='state_vector_simulator', precompute_unitary=False)[source]¶. initialize(state=None, cbits=None, measure_results=None)[source]¶; Reset Simulator state variables to start a new run. Parameters. state: ket or operket or density matrix. cbits: list of int, optionalinitial value of classical bits. U_list: list of Qobj, optionallist of predefined unitaries corresponding to circuit. measure_resultstuple of ints, optionaloptional specification of each measurement result to enable; post-selection. If specified, the measurement results are; set to the tuple of bits (sequentially) instead of being; chosen at random. run(state, cbits=None, measure_results=None)[source]¶; Calculate the result of one instance of circuit run. Parameters. stateket or operstate vector or density matrix input. cbitsList of ints, optionalinitialization of the classical bits. measure_resultstuple of ints, optionaloptional specification of each measurement result to enable; post-selection. If specified, the measurement results are; set to the tuple of bits (sequentially) instead of being; chosen at random. Returns. result: CircuitResultRetu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:86262,variab,variables,86262,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['variab'],['variables']
Modifiability,"t)""). L = -1j * h. Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_coeff, Cubic_Spline):; Lobj.append(h_coeff.coeffs); Lcoeff.append(h_coeff). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution usin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:11244,config,config,11244,docs/4.0.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability,"t)); C_imag(t) = sum(ck_imag * exp(- vk_imag * t)). Defines the coefficients ck and the frequencies vk.; Note that the ck and vk may be complex, even through C_real(t); and C_imag(t) (i.e. the sum) is real. Parameters. QQobjThe coupling operator for the bath. ck_reallist of complexThe coefficients of the expansion terms for the real part of the; correlation function. The corresponding frequencies are passed as; vk_real. vk_reallist of complexThe frequencies (exponents) of the expansion terms for the real part of; the correlation function. The corresponding ceofficients are passed as; ck_real. ck_imaglist of complexThe coefficients of the expansion terms in the imaginary part of the; correlation function. The corresponding frequencies are passed as; vk_imag. vk_imaglist of complexThe frequencies (exponents) of the expansion terms for the imaginary; part of the correlation function. The corresponding ceofficients are; passed as ck_imag. combinebool, default TrueWhether to combine exponents with the same frequency (and coupling; operator). See combine for details. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. classmethod combine(exponents, rtol=1e-05, atol=1e-07)[source]¶; Group bosonic exponents with the same frequency and return a; single exponent for each frequency present.; Exponents with the same frequency are only combined if they share the; same coupling operator .Q.; Note that combined exponents take their tag from the first; exponent in the group being combined (i.e. the one that occurs first; in the given exponents list). Parameters. exponentslist of BathExponentThe list of exponents to combine. rtolfloat, default 1e-5The relative tolerance to use to when comparing frequencies and; coupling operators. atolfloat, default 1e-7The absolute tolerance to use to when comparing frequencies and; coupling operators. Ret",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:53123,coupling,coupling,53123,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,1,['coupling'],['coupling']
Modifiability,"t). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE fo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14590,config,config,14590,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"t). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE fo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:15582,config,config,15582,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"t):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(). progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(). if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname). if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:15990,config,config,15990,docs/4.7/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html,2,['config'],['config']
Modifiability,"t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14897,config,config,14897,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:15889,config,config,15889,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"t, st_time, end_time). return result. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; By default (as used in GRAPE) these are the control amplitudes; in each timeslot; """"""; return self.dynamics.ctrl_amps.reshape([-1]). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(e",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:20589,variab,variable,20589,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,8,['variab'],['variable']
Modifiability,"t. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs)",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:11993,config,config,11993,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"t. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; random_integers(1e8, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = random_integers(; 1e8, size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:12999,config,config,12999,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"t. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname); ; if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html:20765,config,config,20765,docs/4.2/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html,2,['config'],['config']
Modifiability,"t.append(np.real(expt_data[k])); else:; data_list.append(expt_data[k]); else:; data_list = [data for data in expt_data]; output.expect.append(data_list); else:; # no averaging for single trajectory or if average_expect flag; # (Options) is off; if mc.expect_out is not None:; output.expect = mc.expect_out. # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = ra",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:11302,config,config,11302,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,12,"['config', 'variab']","['config', 'variables']"
Modifiability,"t.append(np.real(expt_data[k])); else:; data_list.append(expt_data[k]); else:; data_list = [data for data in expt_data]; output.expect.append(data_list); else:; # no averaging for single trajectory or if average_expect flag; # (Options) is off; if mc.expect_out is not None:; output.expect = mc.expect_out. # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; random_integers(1e8, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = random_in",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:12308,config,config,12308,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,3,"['config', 'variab']","['config', 'variables']"
Modifiability,"t.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expect = []; for num in ntraj:; expt_data = np.mean(mc.expect_out[:num], axis=0); data_list = []; if any([not op.isherm for op in e_ops]):; for k in range(len(e_ops)):; if e_ops[k].isherm:; data_list.append(np.real(expt_data[k])); else:; data_list.append(expt_data[k]); else:; data_list = [data for data in expt_data]; output.expect.append(data_list); else:; # no averaging for single trajectory or if average_expect flag; # (Options) is off; if mc.expect_out is not None:; output.expect = mc.expect_out. # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:10766,config,config,10766,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"t=0\) and \(U(t)\) is a unitary operator on the Hilbert space containing the states. \(U(t)\) is a solution to the Schrödinger operator equation. \[\tfrac{d}{dt}U = -i H(t)U ,\quad U(0) = \mathbb{1}\]; We can use optimal control algorithms to determine a set of \(u_j\) that will drive our system from \(\ket{\psi_0}\) to \(\ket{\psi_1}\), this is state-to-state transfer, or drive the system from some arbitary state to a given state \(\ket{\psi_1}\), which is state preparation, or effect some unitary transformation \(U_{target}\), called gate synthesis. The latter of these is most important in quantum computation. The GRAPE algorithm¶; The GRadient Ascent Pulse Engineering was first proposed in [NKanej]. Solutions to Schrödinger’s equation for a time-dependent Hamiltonian are not generally possible to obtain analytically. Therefore, a piecewise constant approximation to the pulse amplitudes is made. Time allowed for the system to evolve \(T\) is split into \(M\) timeslots (typically these are of equal duration), during which the control amplitude is assumed to remain constant. The combined Hamiltonian can then be approximated as:. \[H(t) \approx H(t_k) = H_0 + \sum_{j=1}^N u_{jk} H_j\quad\]; where \(k\) is a timeslot index, \(j\) is the control index, and \(N\) is the number of controls. Hence \(t_k\) is the evolution time at the start of the timeslot, and \(u_{jk}\) is the amplitude of control \(j\) throughout timeslot \(k\). The time evolution operator, or propagator, within the timeslot can then be calculated as:. \[X_k:=e^{-iH(t_k)\Delta t_k}\]; where \(\Delta t_k\) is the duration of the timeslot. The evolution up to (and including) any timeslot \(k\) (including the full evolution \(k=M\)) can the be calculated as. \[X(t_k):=X_k X_{k-1}\cdots X_1 X_0\]; If the objective is state-to-state transfer then \(X_0=\ket{\psi_0}\) and the target \(X_{targ}=\ket{\psi_1}\), for gate synthesis \(X_0 = U(0) = \mathbb{1}\) and the target \(X_{targ}=U_{targ}\).; A figure of meri",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-control.html:4478,evolve,evolve,4478,docs/4.7/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html,1,['evolve'],['evolve']
Modifiability,"t[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.conj().transpose(),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.conj().transpose(). # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:23051,config,config,23051,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"t_file_ext, gen_stats=gen_stats). [docs]def create_pulse_optimizer(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, gen_stats=False):. """"""; Generate the objects of the appropriate subclasses required for the pulse; optmisation based on the parameters given Note this method may be; preferable to calling optimize_pulse if more detailed configuration is; required before running the optmisation algorthim, or the algorithm will be; run many times, for instances when trying to finding global the optimum or; minimum time optimisation. Parameters; ----------; drift : Qobj or list of Qobj; The underlying dynamics generator of the system can provide list (of; length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time dependent control generators. initial : Qobj; Starting point for the evolution. Typically the identity matrix. target : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau array. evo_time : float or None; Total time for the evolution. ``None`` implies that timeslots will be; given in the tau ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:51691,config,configuration,51691,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,2,['config'],['configuration']
Modifiability,"t_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. def _mc_dm_avg(psi_list):; """"""; Private function that averages density matrices in parallel; over all trajectories for a single time using parfor.; """"""; ln = len(psi_list); dims = psi_list[0].dims; shape = psi_list[0].shape; out_data = np.sum([psi.data for psi in psi_list]) / ln; return Qobj(out_data, dims=dims, shape=shape, fast='mc-dm'). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on D",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:39733,config,config,39733,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"t_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. def _mc_dm_avg(psi_list):; """"""; Private function that averages density matrices in parallel; over all trajectories for a single time using parfor.; """"""; ln = len(psi_list); dims = psi_list[0].dims; shape = psi_list[0].shape; out_data = np.sum([psi.data for psi in psi_list]) / ln; return Qobj(out_data, dims=dims, shape=shape, fast='mc-dm'). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38925,config,config,38925,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"t_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:27446,config,config,27446,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"t_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = sp.csr_matrix(np.reshape(out_psi,; (out_psi.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.conj().transpose(),; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.conj().transpose())). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:28449,config,config,28449,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"t_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; norm, dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE solver; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if (not isinstance(H_func[0], (list, np.ndarray))) or \; (len(H_func[0]) <= 1):; raise TypeError('Time-dependent Hamiltonians must be a list with two '; + 'or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html:13510,config,configure,13510,docs/3.1.0/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html,1,['config'],['configure']
Modifiability,"t_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which opera",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:22236,config,config,22236,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"ta = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, H_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:37466,config,config,37466,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"ta = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:36464,config,config,36464,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"ta); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata); ; # Check which components should use OPENMP; omp_components = None; if qset.has_openmp:; if opt.use_openmp:; omp_components = openmp_components(Lptrs). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_td_ode_rhs_super); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_st",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:21099,config,config,21099,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,2,['config'],['config']
Modifiability,"ta.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------. if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op # combine Hamiltonian and collapse terms into one; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.in",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:32902,config,config,32902,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"ta.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, H_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:37245,config,config,37245,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"ta.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:36243,config,config,36243,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"ta[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, H_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:37701,config,config,37701,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"ta_{\alpha \beta k}|)(\gamma_{\alpha \beta k} + \gamma_{\alpha \beta -k})\]; The density matrix of the system then evolves according to:. \[\dot{\rho}_{\alpha \alpha}(t) = \sum_\nu (A_{\alpha \nu} \rho_{\nu \nu}(t) - A_{\nu \alpha} \rho_{\alpha \alpha} (t))\]. \[\dot{\rho}_{\alpha \beta}(t) = -\frac{1}{2} \sum_\nu (A_{\nu \alpha} + A_{\nu \beta}) \rho_{\alpha \beta}(t) \qquad \alpha \neq \beta\]. The Floquet-Markov master equation in QuTiP¶; The QuTiP function qutip.floquet.fmmesolve implements the Floquet-Markov master equation. It calculates the dynamics of a system given its initial state, a time-dependent Hamiltonian, a list of operators through which the system couples to its environment and a list of corresponding spectral-density functions that describes the environment. In contrast to the qutip.mesolve and qutip.mcsolve, and the qutip.floquet.fmmesolve does characterize the environment with dissipation rates, but extract the strength of the coupling to the environment from the noise spectral-density functions and the instantaneous Hamiltonian parameters (similar to the Bloch-Redfield master equation solver qutip.bloch_redfield.brmesolve). Note; Currently the qutip.floquet.fmmesolve can only accept a single environment coupling operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python callback function that is passed to the solver. For example:; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solver.Result. The following example extends the example studied above, and uses qutip.floquet.fmmesolve to introduce dissipation into the calculation; import numpy as np; from matplotlib import pyplot; import qutip. delta = 0.0 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 0.25 * 2*np.pi; omega = 1.0 * 2*np.pi; T = 2*np.pi / omega; tlist = np.linspace(0.0, 20 * ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:17427,coupling,coupling,17427,docs/4.7/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html,1,['coupling'],['coupling']
Modifiability,"table of simulation times for the single-photon example using the different time-dependent formats and both the master equation and Monte Carlo solver. Format; Master Equation; Monte Carlo. Python Function; 2.1 sec; 27 sec. Cython String; 1.4 sec; 9 sec. Hamiltonian Function; 1.0 sec; 238 sec. For the current example, the table indicates that the Hamiltonian function method is in fact the fastest when using the master equation solver. This is because the simulation is quite small. In contrast, the Hamiltonian function is over 26x slower than the compiled string version when using the Monte Carlo solver. In this case, the 500 trajectories needed in the simulation highlights the inefficient nature of the Python function calls. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do:; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); opts = Options(rhs_reuse=True); args = {'A': 10, 'sig': 3}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args, options=opts). In this case, the second call to qutip.mcsolve takes 3 seconds less than the first. Of course our parameters are different, but this also shows how much time one can save by not reorganizing the data, and in the case of the string format, not recompiling the code. If you need to call the solvers many times for different parameters, this savings will obviously start to add",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html:15249,variab,variables,15249,docs/3.0.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html,2,['variab'],['variables']
Modifiability,"tack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:18256,config,config,18256,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"tall.; If you have created a specific conda environment, or you have installed Miniconda, then you will need to install the required packages for QuTiP.; recommended:; conda install numpy scipy cython matplotlib nose jupyter notebook spyder. minimum (recommended):; conda install numpy scipy cython nose matplotlib. absolute mimimum:; conda install numpy scipy cython. The jupyter and notebook packages are for working with Jupyter notebooks (fka IPython notebooks). Spyder is an IDE for scientific development with Python. Adding the conda-forge channel¶; If you have conda 4.1.0 or later then, add the conda-forge channel with lowest priority using:; conda config --append channels conda-forge. Otherwise you should consider reinstalling Anaconda / Miniconda. In theory:; conda update conda. will update your conda to the latest version, but this can lead to breaking your default Ananconda enviroment.; Alternatively, this will add conda-forge as the highest priority channel.; conda config --add channels conda-forge. It is almost certainly better to have defaults as the highest priority channel.; You can edit your .condarc (user home folder) file manually, so that conda-forge is below defaults in the channels list. Installing via pip¶; For other types of installation, it is often easiest to use the Python package manager pip.; pip install qutip. More detailed platform-dependent installation alternatives are given below. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html. and the latest source code is available in our Github repository. http://github.com/qutip. In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository.; Installing QuTiP from source requires that all the dependencies are satisfied. To instal",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/installation.html:4198,config,config,4198,docs/4.4/installation.html,https://qutip.org,https://qutip.org/docs/4.4/installation.html,1,['config'],['config']
Modifiability,"tall.; If you have created a specific conda environment, or you have installed Miniconda, then you will need to install the required packages for QuTiP.; recommended:; conda install numpy scipy cython matplotlib nose jupyter notebook spyder. minimum (recommended):; conda install numpy scipy cython nose matplotlib. absolute mimimum:; conda install numpy scipy cython. The jupyter and notebook packages are for working with Jupyter notebooks (fka IPython notebooks). Spyder is an IDE for scientific development with Python. Adding the conda-forge channel¶; If you have conda 4.1.0 or later then, add the conda-forge channel with lowest priority using:; conda config --append channels conda-forge. Otherwise you should consider reinstalling Anaconda / Miniconda. In theory:; conda update conda. will update your conda to the latest version, but this can lead to breaking your default Ananconda enviroment.; Alternatively, this will add conda-forge as the highest priority channel.; conda config --add channels conda-forge. It is almost certainly better to have defaults as the highest priority channel.; You can edit your .condarc (user home folder) file manually, so that conda-forge is below defaults in the channels list. Installing via pip¶; For other types of installation, it is often easiest to use the Python package manager pip.; pip install qutip. More detailed platform-dependent installation alternatives are given below. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository.; Installing QuTiP from source requires that all the dependencies are satisfied. To instal",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/installation.html:4102,config,config,4102,docs/4.1/installation.html,https://qutip.org,https://qutip.org/docs/4.1/installation.html,3,['config'],['config']
Modifiability,"tance measure for dynamics described by matrices; Note the gradient calculation is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:18597,config,configuration,18597,docs/4.3/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html,5,['config'],['configuration']
Modifiability,"tance of the class; qutip.solver.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class LinearSpinChain(N, correct_global_phase=True, sx=0.25, sz=1.0, sxsy=0.1, t1=None, t2=None)[source]¶; A processor based on the physical implementation of; a linear spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically. Parameters. N: intThe number of qubits in the system. correct_global_phase: floatSave the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. sx: int or listThe delta for each of the qubits in the system. sz: int or listThe epsil",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:160396,coupling,coupling,160396,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,1,['coupling'],['coupling']
Modifiability,"target \(\newcommand{\ket}[1]{\left|{#1}\right\rangle} X_{targ}=\ket{\psi_1}\), for gate synthesis \(X_0 = U(0) = \mathbb{1}\) and the target \(X_{targ}=U_{targ}\).; A figure of merit or fidelity is some measure of how close the evolution is to the target, based on the control amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. \[\newcommand{\tr}[0]{\operatorname{tr}} f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|\]; where \(d\) is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one parameter to minimise \(\varepsilon\), then the problem becomes a finite multi-variable optimisation problem, for which there are many established methods, often referred to as ‘hill-climbing’ methods. The simplest of these to understand is that of steepest ascent (or descent). The gradient of the fidelity with respect to all the variables is calculated (or approximated) and a step is made in the variable space in the direction of steepest ascent (or descent). This method is a first order gradient method. In two dimensions this describes a method of climbing a hill by heading in the direction where the ground rises fastest. This analogy also clearly illustrates one of the main challenges in multi-variable optimisation, which is that all methods have a tendency to get stuck in local maxima. It is hard to determine whether one has found a global maximum or not - a local peak is likely not to be the highest mountain in the region. In quantum optimal control we can typically define an infidelity that has a lower bound of zero. We can then look to minimis",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-control.html:6450,variab,variables,6450,docs/4.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-control.html,12,['variab'],"['variable', 'variables']"
Modifiability,"tate = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = sp.csr_matrix(np.reshape(out_psi,; (out_psi.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.conj().transpose(),; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.conj().transpose())). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:29377,config,config,29377,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"tate must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:7855,config,config,7855,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,3,['config'],['config']
Modifiability,"tate. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, ...) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hol",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-control.html:13570,variab,variable,13570,docs/4.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-control.html,1,['variab'],['variable']
Modifiability,"tate_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; con",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14255,config,config,14255,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"tate_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; con",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:15247,config,config,15247,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"tational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.brmesolve; qutip.ssesolve, qutip.photocurrent_sesolve, qutip.smesolve, and qutip.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Array Based: The Hamiltonian and/or collapse operators are expressed as a list ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-time.html:1936,coupling,coupling,1936,docs/4.5/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-time.html,1,['coupling'],['coupling']
Modifiability,"tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H_shifted, chi/chi.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat_add = np.asarray(; 1.0 / (4*options.ntraj[0]) *; (c_tau[0] - c_tau[2] - 1j*c_tau[1] + 1j*c_tau[3]),; dtype=corr_mat.dtype; ); corr_mat[t_idx, :] += corr_mat_add; ; if t_idx == 1:; options.rhs_reuse = True; ; if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # pseudo-inverse solvers. def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; """"""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\\tau)B(0)\\right>`.; """""". L = H if issuper(H) else liouvillian(H, c_ops). tr_mat = tensor([qeye(n) for n in L.dims[0][0]]); N = np.prod(L.dims[0][0]). A = L.full(); b = spre(b_op).full(); a = spre(a_op).full(). tr_vec = np.transpose(mat2vec(tr_mat.full())). rho_ss = steadystate(L); rho = np.transpose(mat2vec(rho_ss.full())). I = np.identity(N * N); P = np.kron(np.transpose(rho), tr_vec); Q = I - P. spectrum = np.zeros(len(wlist)). for idx, w in enumerate(wlist):; if use_pinv:; MMR = np.linalg.pinv(-1.0j * w * I + A); else:; MMR = np.dot(Q, np.linalg.solve(-1.0j * w * I + A, Q)). s = np.dot(tr_vec,; np.dot(a, np.dot(MMR, np.dot(b, np.transpose(rho))))); spectrum[idx] = -2 * np.real(s[0, 0]). return spectrum. # au",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/correlation.html:37034,config,config,37034,docs/4.2/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/correlation.html,4,['config'],['config']
Modifiability,"tcomes given a two-mode wavefunction. update_rho(rho)¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode density matrix. class HarmonicOscillatorWaveFunction(psi=None, omega=1.0, extent=[-5, 5], steps=250)¶; Methods. update(psi)¶; Calculate the wavefunction for the given state of an harmonic; oscillator. class HarmonicOscillatorProbabilityFunction(rho=None, omega=1.0, extent=[-5, 5], steps=250)¶; Methods. update(rho)¶; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix). Quantum information processing¶. class Gate(name, targets=None, controls=None, arg_value=None, arg_label=None)¶; Representation of a quantum gate, with its required parametrs, and target; and control qubits. class QubitCircuit(N, reverse_states=True)¶; Representation of a quantum program/algorithm, maintaining a sequence; of gates.; Methods. add_1q_gate(name, start=0, end=None, qubits=None, arg_value=None, arg_label=None)¶; Adds a single qubit gate with specified parameters on a variable; number of qubits in the circuit. By default, it applies the given gate; to all the qubits in the register. Parameters:name: String :. Gate name. start: Integer :. Starting location of qubits. end: Integer :. Last qubit for the gate. qubits: List :. Specific qubits for applying gates. arg_value: Float :. Argument value(phi). arg_label: String :. Label for gate representation. add_circuit(qc, start=0)¶; Adds a block of a qubit circuit to the main circuit.; Globalphase gates are not added. Parameters:qc: QubitCircuit :. The circuit block to be added to the main circuit. start: Integer :. The qubit on which the first gate is applied. add_gate(name, targets=None, controls=None, arg_value=None, arg_label=None)¶; Adds a gate with specified parameters to the circuit. Parameters:name: String :. Gate name. targets: List :. Gate targets. controls: List :. Gate controls. arg_value: Float :. Argument value(phi). arg_label: String :. Label f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/classes.html:34454,variab,variable,34454,docs/3.0.0/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html,2,['variab'],['variable']
Modifiability,"te implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file.; Optimizer; This acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm.; Dynamics; This is mainly a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-control.html:14245,flexible,flexible,14245,docs/4.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-control.html,2,['flexible'],['flexible']
Modifiability,"te it is (usually) shared with the Dynamics instance. dump : :class:`dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent iteration.; Note this is only set if dummping is on; ; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:9501,config,config,9501,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,6,['config'],['config']
Modifiability,"te probability distribution for quadrature measurement; outcomes given a two-mode density matrix. class HarmonicOscillatorWaveFunction(psi=None, omega=1.0, extent=[-5, 5], steps=250)[source]¶. update(psi)[source]¶; Calculate the wavefunction for the given state of an harmonic; oscillator. class HarmonicOscillatorProbabilityFunction(rho=None, omega=1.0, extent=[-5, 5], steps=250)[source]¶. update(rho)[source]¶; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix). Quantum information processing¶. class Gate(name, targets=None, controls=None, arg_value=None, arg_label=None)[source]¶; Representation of a quantum gate, with its required parametrs, and target; and control qubits. class QubitCircuit(N, input_states=None, output_states=None, reverse_states=True)[source]¶; Representation of a quantum program/algorithm, maintaining a sequence; of gates. add_1q_gate(name, start=0, end=None, qubits=None, arg_value=None, arg_label=None)[source]¶; Adds a single qubit gate with specified parameters on a variable; number of qubits in the circuit. By default, it applies the given gate; to all the qubits in the register. Parameters:; name : String; Gate name. start : Integer; Starting location of qubits. end : Integer; Last qubit for the gate. qubits : List; Specific qubits for applying gates. arg_value : Float; Argument value(phi). arg_label : String; Label for gate representation. add_circuit(qc, start=0)[source]¶; Adds a block of a qubit circuit to the main circuit.; Globalphase gates are not added. Parameters:; qc : QubitCircuit; The circuit block to be added to the main circuit. start : Integer; The qubit on which the first gate is applied. add_gate(gate, targets=None, controls=None, arg_value=None, arg_label=None)[source]¶; Adds a gate with specified parameters to the circuit. Parameters:; gate: String or `Gate`; Gate name. If gate is an instance of Gate, parameters are; unpacked and added. targets: List; Gate targets. controls: ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:57634,variab,variable,57634,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['variab'],['variable']
Modifiability,"te probability distribution for quadrature measurement; outcomes given a two-mode density matrix. class HarmonicOscillatorWaveFunction(psi=None, omega=1.0, extent=[-5, 5], steps=250)[source]¶. update(psi)[source]¶; Calculate the wavefunction for the given state of an harmonic; oscillator. class HarmonicOscillatorProbabilityFunction(rho=None, omega=1.0, extent=[-5, 5], steps=250)[source]¶. update(rho)[source]¶; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix). Quantum information processing¶. class Gate(name, targets=None, controls=None, arg_value=None, arg_label=None)[source]¶; Representation of a quantum gate, with its required parametrs, and target; and control qubits. class QubitCircuit(N, input_states=None, output_states=None, reverse_states=True)[source]¶; Representation of a quantum program/algorithm, maintaining a sequence; of gates. add_1q_gate(name, start=0, end=None, qubits=None, arg_value=None, arg_label=None)[source]¶; Adds a single qubit gate with specified parameters on a variable; number of qubits in the circuit. By default, it applies the given gate; to all the qubits in the register. Parameters:name : String. Gate name. start : Integer. Starting location of qubits. end : Integer. Last qubit for the gate. qubits : List. Specific qubits for applying gates. arg_value : Float. Argument value(phi). arg_label : String. Label for gate representation. add_circuit(qc, start=0)[source]¶; Adds a block of a qubit circuit to the main circuit.; Globalphase gates are not added. Parameters:qc : QubitCircuit. The circuit block to be added to the main circuit. start : Integer. The qubit on which the first gate is applied. add_gate(gate, targets=None, controls=None, arg_value=None, arg_label=None)[source]¶; Adds a gate with specified parameters to the circuit. Parameters:gate: String or `Gate`. Gate name. If gate is an instance of Gate, parameters are; unpacked and added. targets: List. Gate targets. controls: List. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:49016,variab,variable,49016,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,1,['variab'],['variable']
Modifiability,"te the bath expansion coefficients and to; use those coefficients to construct your own bath description so that you can; implement your own bosonic baths.; Finally, we will demonstrate how to simulate a system coupled to multiple; independent baths, as occurs, for example, in certain photosynthesis processes.; A notebook containing a complete example similar to this one implemented in; BoFiN can be found in; example notebook 1a. Describing the system and bath¶; First, let us construct the system Hamiltonian, \(H_{sys}\), and the initial; system state, rho0:; from qutip import basis, sigmax, sigmaz. # The system Hamiltonian:; eps = 0.5 # energy of the 2-level system; Del = 1.0 # tunnelling term; H_sys = 0.5 * eps * sigmaz() + 0.5 * Del * sigmax(). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:; # Bath properties:; gamma = 0.5 # cut off frequency; lam = 0.1 # coupling strength; T = 0.5 # temperature. # System-bath coupling operator:; Q = sigmaz(). where \(\gamma\) (gamma), \(\lambda\) (lam) and \(T\) are; the parameters of a Drude-Lorentz bath, and Q is the coupling operator; between the system and the bath.; We may the pass these parameters to either; DrudeLorentzBath or; DrudeLorentzPadeBath to construct an expansion of; the bath correlations:; from qutip.nonmarkov.heom import DrudeLorentzBath; from qutip.nonmarkov.heom import DrudeLorentzPadeBath. # Number of expansion terms to retain:; Nk = 2. # Matsubara expansion:; bath = DrudeLorentzBath(Q, lam, gamma, T, Nk). # Padé expansion:; bath = DrudeLorentzPadeBath(Q, lam, gamma, T, Nk). Where Nk is the number of terms to retain within the expansion of the; bath. System and bath dynamics¶; Now we are ready to construct a solver:; from qutip.nonmarkov.heom import HEOMSolver; from qutip import Options. max_depth = 5 # maximum hierarchy depth to retain; options = Options(nsteps=15_000). solver = HEOMSolver(H_sys, bath, max_depth=max_depth, options=options). a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/heom/bosonic.html:3148,coupling,coupling,3148,docs/4.7/guide/heom/bosonic.html,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html,1,['coupling'],['coupling']
Modifiability,"te(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_k",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:11957,config,config,11957,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"te(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; random_integers(1e8, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = random_integers(; 1e8, size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:12963,config,config,12963,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"te,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:19670,config,config,19670,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"te; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state; state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables exp, sin, pi etc. will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶; Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes its own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; t = np.linspace(-15, 15, 100); func = lambda t: 9*np.exp(-(t / 5)** 2); noisy_func = la",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:13725,variab,variable,13725,docs/4.7/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html,2,"['rewrite', 'variab']","['rewrite', 'variable']"
Modifiability,"ted during the optimisation. This object is shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above. TimeslotComputerHere the time evolution is computed by calling the methods of the other computer objects. OptimResultThe result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-control.html:17555,config,configuration,17555,docs/4.5/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-control.html,2,['config'],"['configuration', 'configure']"
Modifiability,"ted with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact : boolean; indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/propcomp.html:4323,config,configuration,4323,docs/4.1/modules/qutip/control/propcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/propcomp.html,8,['config'],['configuration']
Modifiability,"tep=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). ; # Remove RHS cython file if necessary; if not opt.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname); ; #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE solver; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if (not isinstance(H_func[0], (list, np.ndarray))) or \; (len(H_func[0]) <= 1):; raise TypeError('Time-dependent Hamiltonians must be a list with two '; + 'or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/sesolve.html:13767,config,configure,13767,docs/4.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html,2,['config'],['configure']
Modifiability,"ter Equation¶. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj or; nested list in string-based format. psi0: QobjInitial density matrix or state vector (ket). tlistarray_likeList of times for evaluating evolution. a_opslistNested list of Hermi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:63811,variab,variable,63811,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,6,['variab'],"['variable', 'variables']"
Modifiability,"ter Equation¶. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]; where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters:; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list; Ne",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:64831,variab,variable,64831,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,3,['variab'],"['variable', 'variables']"
Modifiability,"teration.; Note this is only set if dummping is on; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:11375,config,config,11375,docs/4.6/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html,2,['config'],['config']
Modifiability,"terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters:f_states : list of qutip.qobj (kets). A list of Floquet modes. f_energies : array. The Floquet energies. psi : qutip.qobj. The wavefunction to decompose in the Floquet state basis. Returns:output : array. The coefficients \(c_\alpha\) in the Floquet state decomposition. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters:H : qutip.qobj.Qobj. System Hamiltonian, time-dependent with period T. psi0 : qutip.qobj. Initial state vector (ket). tlist : list / array. list of times for \(t\). e_ops : list of qutip.qobj / callback function. list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. Dictionary with variables required to evaluate H. Tsteps : integer. The number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns:output : qutip.solver.Result. An instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶; This module contains functions for solving stochastic schrodinger and master; equations. The API should not be considered stable, and is subject to change; when we work more on optimizing this module for performance and features. smesolve(H, rho0, times, c_ops, sc_ops, e_ops, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters:H : qutip.Qobj. System Hamiltonian. rho0 : qutip.Qobj. Initial density matrix or state vector (ket). times : list / array. List of times for \(t\)",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:64232,variab,variables,64232,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['variab'],['variables']
Modifiability,"terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters:f_states : list of qutip.qobj (kets). A list of Floquet modes. f_energies : array. The Floquet energies. psi : qutip.qobj. The wavefunction to decompose in the Floquet state basis. Returns:output : array. The coefficients \(c_\alpha\) in the Floquet state decomposition. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters:H : qutip.qobj.Qobj. System Hamiltonian, time-dependent with period T. psi0 : qutip.qobj. Initial state vector (ket). tlist : list / array. list of times for \(t\). e_ops : list of qutip.qobj / callback function. list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. Dictionary with variables required to evaluate H. Tsteps : integer. The number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns:output : qutip.solver.Result. An instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶; This module contains functions for solving stochastic schrodinger and master; equations. The API should not be considered stable, and is subject to change; when we work more on optimizing this module for performance and features. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters:H : qutip.Qobj. System Hamiltonian. rho0 : qutip.Qobj. Initial density matrix or state vector (ket). times : list / arra",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:75292,variab,variables,75292,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['variab'],['variables']
Modifiability,"terms.append(h.full('f')); H_td_terms.append('1'); elif isinstance(h, list):; H_terms.append(h[0].full('f')); if isinstance(h[1], Cubic_Spline):; H_obj.append(h[1].coeffs); spline_count[0] += 1; H_td_terms.append(h[1]); else:; raise Exception('Invalid Hamiltonian specification.'). for kk, c in enumerate(c_ops):; if isinstance(c, Qobj):; C_terms.append(c.full('f')); C_td_terms.append('1'); elif isinstance(c, list):; C_terms.append(c[0].full('f')); if isinstance(c[1], Cubic_Spline):; CA_obj.append(c[1].coeffs); spline_count[0] += 1; C_td_terms.append(c[1]); else:; raise Exception('Invalid collapse operator specification.'). coupled_offset = 0; for kk, a in enumerate(a_ops):; if isinstance(a, list):; if isinstance(a[0], Qobj):; A_terms.append(a[0].full('f')); A_td_terms.append(a[1]); if isinstance(a[1], tuple):; if not len(a[1])==2:; raise Exception('Tuple must be len=2.'); if isinstance(a[1][0],Cubic_Spline):; spline_count[1] += 1; if isinstance(a[1][1],Cubic_Spline):; spline_count[1] += 1; elif isinstance(a[0], tuple):; if not isinstance(a[1], tuple):; raise Exception('Invalid bath-coupling specification.'); if (len(a[0])+1) != len(a[1]):; raise Exception('BR a_ops tuple lengths not compatible.'). coupled_ops.append(kk+coupled_offset); coupled_lengths.append(len(a[0])); coupled_spectra.append(a[1][0]); coupled_offset += len(a[0])-1; if isinstance(a[1][0],Cubic_Spline):; spline_count[1] += 1. for nn, _a in enumerate(a[0]):; A_terms.append(_a.full('f')); A_td_terms.append(a[1][nn+1]); if isinstance(a[1][nn+1],Cubic_Spline):; CA_obj.append(a[1][nn+1].coeffs); spline_count[1] += 1. else:; raise Exception('Invalid bath-coupling specification.'). string_list = []; for kk,_ in enumerate(H_td_terms):; string_list.append(""H_terms[{0}]"".format(kk)); for kk,_ in enumerate(H_obj):; string_list.append(""H_obj[{0}]"".format(kk)); for kk,_ in enumerate(C_td_terms):; string_list.append(""C_terms[{0}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(k",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/bloch_redfield.html:13028,coupling,coupling,13028,docs/4.4/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/bloch_redfield.html,2,['coupling'],['coupling']
Modifiability,"terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. def _mc_dm_avg(psi_list):; """"""; Private function that averages density matrices in parallel; over all trajectories for a single time using parfor.; """"""; ln = len(psi_list); dims = psi_list[0].dims; shape = psi_list[0].shape; out_data = np.sum([psi.data for psi in psi_list]) / ln; return Qobj(out_data, dims=dims, shape=shape, fast='mc-dm'). Back to t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:39655,config,config,39655,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. def _mc_dm_avg(psi_list):; """"""; Private function that averages density matrices in parallel; over all trajectories for a single time using parfor.; """"""; ln = len(psi_list); dims = psi_list[0].dims; shape = psi_list[0].shape; out_data = np.sum([psi.data for psi in psi_list]) / ln; return Qobj(out_data, dims=dims, shape=shape, fast='mc-dm'). © Copyrig",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38847,config,config,38847,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"tfrac{d}{dt}U = -i H(t)U ,\quad U(0) = \mathbb{1}\]; We can use optimal control algorithms to determine a set of \(u_j\) that will drive our system from \(\newcommand{\ket}[1]{\left|{#1}\right\rangle} \ket{\psi_0}\) to \(\newcommand{\ket}[1]{\left|{#1}\right\rangle} \ket{\psi_1}\), this is state-to-state transfer, or drive the system from some arbitary state to a given state \(\newcommand{\ket}[1]{\left|{#1}\right\rangle} \ket{\psi_1}\), which is state preparation, or effect some unitary transformation \(U_{target}\), called gate synthesis. The latter of these is most important in quantum computation. The GRAPE algorithm¶; The **GR**adient **A**scent **P**ulse **E**ngineering was first proposed in [2]. Solutions to Schrödinger’s equation for a time-dependent Hamiltonian are not generally possible to obtain analytically. Therefore, a piecewise constant approximation to the pulse amplitudes is made. Time allowed for the system to evolve \(T\) is split into \(M\) timeslots (typically these are of equal duration), during which the control amplitude is assumed to remain constant. The combined Hamiltonian can then be approximated as:. \[H(t) \approx H(t_k) = H_0 + \sum_{j=1}^N u_{jk} H_j\quad\]; where \(k\) is a timeslot index, \(j\) is the control index, and \(N\) is the number of controls. Hence \(t_k\) is the evolution time at the start of the timeslot, and \(u_{jk}\) is the amplitude of control \(j\) throughout timeslot \(k\). The time evolution operator, or propagator, within the timeslot can then be calculated as:. \[X_k:=e^{-iH(t_k)\Delta t_k}\]; where \(\Delta t_k\) is the duration of the timeslot. The evolution up to (and including) any timeslot \(k\) (including the full evolution \(k=M\)) can the be calculated as. \[X(t_k):=X_k X_{k-1}\cdots X_1 X_0\]; If the objective is state-to-state transfer then \(\newcommand{\ket}[1]{\left|{#1}\right\rangle} X_0=\ket{\psi_0}\) and the target \(\newcommand{\ket}[1]{\left|{#1}\right\rangle} X_{targ}=\ket{\psi_1}\), for gate s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-control.html:4633,evolve,evolve,4633,docs/4.0.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html,2,['evolve'],['evolve']
Modifiability,"th = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = random_integers(; 1e8, size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, conf",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:14139,config,config,14139,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"th \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make use of the args variable; def H1_coeff(t, args):; return args['A'] * np.exp(-(t/args['sigma'])**2). or equivalently,; def H1_coeff(t, args):; A = args['A']; sig = args['sigma']; return A * np.exp(-(t / sig) ** 2). where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively. Of course, we can always hardcode the values in the dictionary as well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty; args = {'A': 9, 'sigma': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:10904,variab,variables,10904,docs/4.7/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html,1,['variab'],['variables']
Modifiability,"th psi0’s dimensions. state as matrix; name+""=mat"":psi0; mat_t=args[name]; The state as a matrix, equivalent to state.full(). state as vector; name+""=vec"":psi0; vec_t=args[name]; The state as a vector, equivalent to state.full().ravel('F'). expectation value; name+""=expect"":O; e=args[name]; Expectation value of the operator O, either; \(\left<\psi(t)|O|\psi(t)\right>\); or \(\rm{tr}\left(O \rho(t)\right)\). collpases; name+""=collapse"":[]; col=args[name]; List of collapse,; each collapse is a tuple of the pair (time, which); which being the indice of the collapse operator.; mcsolve only. Here psi0 is the initial value used for tests before the evolution begins.; qutip.bloch_redfield.brmesolve does not support these arguments. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.solver.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); opts = Options(rhs_reuse=True); args = {'A': 10, 'sig': 3}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args, options=opts). The second call to qutip.mcsolve does not reorganize the data, and in the case of the string format, does not recompile the Cython code. For the small system here, the savings in computation time is quite small, however, if you need to call the solvers many times for different parameters, this savings will obviously start to add up. Next ; Previous. © Copyright 2011",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:17838,variab,variables,17838,docs/4.7/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html,1,['variab'],['variables']
Modifiability,"the Bloch-Redfeild master equation. Note; This solver does not currently support time-dependent Hamiltonian or; collapse operators. Parameters:H : qutip.qobj. System Hamiltonian. rho0 / psi0: :class:`qutip.qobj` :. Initial density matrix or state vector (ket). tlist : list / array. List of times for \(t\). a_ops : list of qutip.qobj. List of system operators that couple to bath degrees of freedom. e_ops : list of qutip.qobj / callback function. List of operators for which to evaluate expectation values. args : dictionary. Dictionary of parameters for time-dependent Hamiltonians and collapse; operators. options : qutip.Qdeoptions. Options for the ODE solver. Returns:output: :class:`qutip.solver` :. An instance of the class qutip.solver, which contains either; a list of expectation values, for operators given in e_ops, or a list; of states for the times specified by tlist. bloch_redfield_tensor(H, a_ops, spectra_cb, use_secular=True)¶; Calculate the Bloch-Redfield tensor for a system given a set of operators; and corresponding spectral functions that describes the system’s coupling; to its environment. Parameters:H : qutip.qobj. System Hamiltonian. a_ops : list of qutip.qobj. List of system operators that couple to the environment. spectra_cb : list of callback functions. List of callback functions that evaluate the noise power spectrum; at a given frequency. use_secular : bool. Flag (True of False) that indicates if the secular approximation should; be used. Returns:R, kets: :class:`qutip.qobj`, list of :class:`qutip.qobj` :. R is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. bloch_redfield_solve(R, ekets, rho0, tlist, e_ops=, []options=None)¶; Evolve the ODEs defined by Bloch-Redfield master equation. The; Bloch-Redfield tensor can be calculated by the function; bloch_redfield_tensor. Parameters:R : qutip.qobj. Bloch-Redfield tensor. ekets : array of qutip.qobj. Array of kets that make up a basis tranformation for the eigenbasis. rho0",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:45474,coupling,coupling,45474,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,2,['coupling'],['coupling']
Modifiability,"the control amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. \[f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|\]; where \(d\) is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one parameter to minimise \(\varepsilon\), then the problem becomes a finite multi-variable optimisation problem, for which there are many established methods, often referred to as ‘hill-climbing’ methods. The simplest of these to understand is that of steepest ascent (or descent). The gradient of the fidelity with respect to all the variables is calculated (or approximated) and a step is made in the variable space in the direction of steepest ascent (or descent). This method is a first order gradient method. In two dimensions this describes a method of climbing a hill by heading in the direction where the ground rises fastest. This analogy also clearly illustrates one of the main challenges in multi-variable optimisation, which is that all methods have a tendency to get stuck in local maxima. It is hard to determine whether one has found a global maximum or not - a local peak is likely not to be the highest mountain in the region. In quantum optimal control we can typically define an infidelity that has a lower bound of zero. We can then look to minimise the infidelity (from here on we will only consider optimising for infidelity minima). This means that we can terminate any pulse optimisation when the infidelity reaches zero (to a sufficient precision). This is however only possible for fully controllable systems; otherwise it is hard (if not impossib",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-control.html:6518,variab,variables,6518,docs/4.6/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html,2,['variab'],"['variable', 'variables']"
Modifiability,"the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent iteration.; Note this is only set if dummping is on; ; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @l",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:9667,config,config,9667,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,6,['config'],['config']
Modifiability,"the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. J_cb : callback functions; A callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator `c_op`. w_th : float; The temperature in units of frequency. kmax : int; The truncation of the number of sidebands (default 5). f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floquet.floquet_modes_table` (optional). options : :class:`qutip.solver.Options`; options for the ODE solver. Returns; -------. output : list. A list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. """""". N = len(f_energies); M = 2 * kmax + 1. omega = (2 * pi) / T. Delta = np.zeros((N, N, M)); X = np.zeros((N, N, M), dtype=complex); Gamma = np.zeros((N, N, M)); A = np.zeros((N, N)). # time steps for integration of coupling operator; nT = int(np.max([20 * kmax, 100])); dT = T / nT; tlist = np.arange(dT, T + dT / 2, dT). if f_modes_table_t is None:; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; np.linspace(0, T, nT + 1), H, T,; args). for t in tlist:; # TODO: repeated invocations of floquet_modes_t is; # inefficient... make a and b outer loops and use the mesolve; # instead of the propagator. f_modes_t = np.hstack([f.full() for f in floquet_modes_t_lookup(; f_modes_table_t, t, T)]); FF = f_modes_t.T.conj() @ c_op.full() @ f_modes_t; phi = exp(-1j * np.arange(-kmax, kmax+1) * omega * t); X += (dT / T) * np.einsum(""ij,k->ijk"", FF, phi). Heaviside = lambda x: ((np.sign(x) + 1) / 2.0); for a in range(N):; for b in range(N):; k_idx = 0; for k in range(-kmax, kmax + 1, 1):; Delta[a, b, k_idx] = f_energies[a] - f_energies[b] + k * omega; Gamma[a, b, k_idx] = 2 * pi * Heaviside(Delta[a, b, k_idx]) * \; J_cb(Delta[a, b, k_idx]) * abs(X[a, b, k_idx]) ** 2; k_idx += 1. for a in range(N):; fo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/floquet.html:15739,coupling,coupling,15739,docs/4.7/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html,1,['coupling'],['coupling']
Modifiability,"the incomplete LU decomposition method algorithm used. Further information can be found in the qutip.steadystate.steadystate docstrings. Example: Harmonic Oscillator in Thermal Bath¶; A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the \(\left|10\right>\) number state, and weakly coupled to a thermal environment characterized by an average particle expectation value of \(\left<n\right>=2\). We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perform only a few Monte Carlo trajectories so we can distinguish this evolution from the master-equation solution.; import numpy as np; import pylab as plt; from qutip import *; # Define paramters; N = 20 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 10) # initial state; kappa = 0.1 # coupling to oscillator. # collapse operators; c_op_list = []; n_th_a = 2 # temperature with average of 2 excitations; rate = kappa * (1 + n_th_a); if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a) # decay operators; rate = kappa * n_th_a; if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a.dag()) # excitation operators. # find steady-state solution; final_state = steadystate(H, c_op_list); # find expectation value for particle number in steady state; fexpt = expect(a.dag() * a, final_state). tlist = np.linspace(0, 50, 100); # monte-carlo; mcdata = mcsolve(H, psi0, tlist, c_op_list, [a.dag() * a], ntraj=100); # master eq.; medata = mesolve(H, psi0, tlist, c_op_list, [a.dag() * a]). plt.plot(tlist, mcdata.expect[0], tlist, medata.expect[0], lw=2); # plot steady-state expt. value as horizontal line (should be = 2); plt.axhline(y=fexpt, color='r', lw=1.5); plt.ylim([0, 10]); plt.xlabel('Time', fontsize=14); plt.ylabel('Number of excitations', fontsize=14); plt.legend(('Monte-Carlo', 'Master Equatio",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-steady.html:10388,coupling,coupling,10388,docs/4.2/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-steady.html,6,['coupling'],['coupling']
Modifiability,"the most recent iteration.; Note this is only set if dummping is on; ; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of da",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:10390,config,config,10390,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,6,['config'],['config']
Modifiability,"the save() method and generate a series of images to convert into an animation. However, as of Matplotlib version 1.1, creating animations is built-in. We will demonstrate both methods by looking at the decay of a qubit on the bloch sphere. Example: Qubit Decay¶; The code for calculating the expectation values for the Pauli spin operators of a qubit decay is given below. This code is common to both animation examples.; import numpy as np; import qutip. def qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist):; # operators and the hamiltonian; sx = qutip.sigmax(); sy = qutip.sigmay(); sz = qutip.sigmaz(); sm = qutip.sigmam(); H = w * (np.cos(theta) * sz + np.sin(theta) * sx); # collapse operators; c_op_list = []; n_th = 0.5 # temperature; rate = gamma1 * (n_th + 1); if rate > 0.0: c_op_list.append(np.sqrt(rate) * sm); rate = gamma1 * n_th; if rate > 0.0: c_op_list.append(np.sqrt(rate) * sm.dag()); rate = gamma2; if rate > 0.0: c_op_list.append(np.sqrt(rate) * sz); # evolve and calculate expectation values; output = qutip.mesolve(H, psi0, tlist, c_op_list, [sx, sy, sz]); return output.expect[0], output.expect[1], output.expect[2]. ## calculate the dynamics; w = 1.0 * 2 * np.pi # qubit angular frequency; theta = 0.2 * np.pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a*qutip.basis(2, 0) + (1-a)*qutip.basis(2, 1))/np.sqrt(a**2 + (1-a)**2); tlist = np.linspace(0, 4, 250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; import numpy as np; b = qutip.Bloch(); b.vector_color = ['r']; b.view = [-40, 30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta), 0, np.cos(theta)]); b.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); b.save(dirc='temp') # saving images to te",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-bloch.html:13209,evolve,evolve,13209,docs/4.6/guide/guide-bloch.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html,2,['evolve'],['evolve']
Modifiability,"the scattering operator for a system emitting into multiple; waveguides. Parameters; ----------; evolver : :class: qutip.scattering.Evolver; Evolver-wrapped Hamiltonian describing the system.; c_ops : list; list of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; :math:`\\sigma = \\sqrt \\gamma \\cdot a`; taus_list : list-like; List of (list of emission times) for each waveguide. Returns; -------; omega : :class: qutip.Qobj; The temporal scattering operator with dimensionality equal to the; system state.; """"""; omega = 1. # Extract the full list of taus; taus = [(0.0, -1)] # temporal ""ground state"" for arbitrary waveguide; for i, tau_wg in enumerate(taus_list):; for tau in tau_wg:; taus.append((tau, i)); taus.sort(key = lambda tup: tup[0]) # sort taus by time. # Compute Prod Ueff(tq, tq-1); for i in range(1, len(taus)):; tq, q = taus[i]; tprev, _ = taus[i - 1]; omega = c_ops[q] * evolver.prop(tq, tprev) * omega. # Add the <0|Uff(TP, tm)|0> term; tmax = evolver.tlist[-1]; taumax, _ = taus[-1]; # if taus[-1] < tmax:; omega = evolver.prop(tmax, taumax) * omega. return omega. [docs]def temporal_basis_vector(waveguide_emission_indices, n_time_bins):; """"""; Generate a temporal basis vector for emissions at specified time bins into; specified waveguides. Parameters; ----------; waveguide_emission_indices : list or tuple; List of indices where photon emission occurs for each waveguide,; e.g. [[t1_wg1], [t1_wg2, t2_wg2], [], [t1_wg4, t2_wg4, t3_wg4]].; n_time_bins : int; Number of time bins; the range over which each index can vary. Returns; -------; temporal_basis_vector : :class: qutip.Qobj; A basis vector representing photon scattering at the specified indices.; If there are W waveguides, T times, and N photon emissions, then the; basis vector has dimensionality (W*T)^N.; """"""; # Cast waveguide_emission_indices to list for mutability; waveguide_emission_indices = [list(i) for i in waveguide_emission_indices]. # Calculate tot",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/scattering.html:6585,evolve,evolver,6585,docs/4.3/modules/qutip/scattering.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/scattering.html,5,['evolve'],['evolver']
Modifiability,"the time-dependence. Parameters:; f_modes_table_t (nested list of qutip.qobj (kets)) – A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table.; t (float) – The time for which to evaluate the Floquet modes.; T (float) – The period of the time-dependence of the hamiltonian. Returns:output – A list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. Return type:nested list. floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Evaluate the floquet states at time t given the initial Floquet modes. Parameters:; f_modes_t (list of qutip.qobj (kets)) – A list of initial Floquet modes (for time \(t=0\)).; f_energies (array) – The Floquet energies.; t (float) – The time for which to evaluate the Floquet states.; H (qutip.qobj) – System Hamiltonian, time-dependent with period T.; T (float) – The period of the time-dependence of the hamiltonian.; args (dictionary) – Dictionary with variables required to evaluate H. Returns:output – A list of Floquet states for the time \(t\). Return type:list. floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters:; f_modes_t (list of qutip.qobj (kets)) – A list of initial Floquet modes (for time \(t=0\)).; f_energies (array) – The Floquet energies.; f_coeff (array) – The coefficients for Floquet decomposition of the initial wavefunction.; t (float) – The time for which to evaluate the Floquet states.; H (qutip.qobj) – System Hamiltonian, time-dependent with period T.; T (float) – The period of the time-dependence of the hamiltonian.; args (dictionary) – Dictionary with variables required to evaluate H. Returns:output – The wavefunction for the time \(t\). Return type:qutip.qobj. floquet_state_decomposition(f_states, f_energies, psi)[source]¶; Decompose the wavefunction psi (typ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:73399,variab,variables,73399,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['variab'],['variables']
Modifiability,"the two-mode field state that is described by V must be Gaussian for this; function to applicable. Parameters. V2d arrayThe covariance matrix. gfloatScaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2).; The value of g is related to the value of hbar in the commutation; relation [x, y] = i * hbar via hbar=2/g ** 2 giving the default; value hbar=1. Returns. NfloatThe logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. Dynamics and Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, psi0, tlist, e_ops=None, args=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Schrodinger equation evolution of a state vector or unitary matrix; for a given Hamiltonian.; Evolve the state vector (psi0) using a given; Hamiltonian (H), by integrating the set of ordinary differential; equations that define the system. Alternatively evolve a unitary matrix in; solving the Schrodinger operator equation.; The output is either the state vector or unitary matrix at arbitrary points; in time (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters. Hqutip.qobj, qutip.qobjevo, list, callablesystem Hamiltonian as a Qobj, list of Qobj and coefficient, QobjEvo,; or a callback function for time-dependent Hamiltonians.; list format and options can be found in QobjEvo’s description. psi0qutip.qobjinitial state vector (ket); or initial unitary operator psi0 = U. tlistlist / arraylist of times for \(t\). e_opsNone / list of qutip.qobj / callback functionsingle operator or list of operators for which to evaluate; expectation values.; For list operator evolution, the overlapse is computed:. tr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:62341,evolve,evolve,62341,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,1,['evolve'],['evolve']
Modifiability,"think its core library files have been updated, triggering a complete, slow rebuild of everything. Code Style¶; The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next.; All new contributions must follow PEP 8 style; all pull requests will be passed through a linter that will complain if you violate it.; You should use the pycodestyle package locally (available on pip) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the best way to split it up with the aim of making the code readable, not just the first thing that doesn’t generate a warning.; Try to stay consistent with the style of the surrounding code.; This includes using the same variable names, especially if they are function arguments, even if these “break” PEP 8 guidelines.; Do not change existing parameter, attribute or method names to “match” PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP.; Other than this, general “good-practice” Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting¶; When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the AP",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/contributing.html:7212,variab,variable,7212,docs/4.6/development/contributing.html,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html,2,['variab'],['variable']
Modifiability,"this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve); This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate.; There are opportunities to develop a more general spectral density code. Attributes. H_sysQobjSystem Hamiltonian. coup_opQobjOperator describing the coupling between system and bath. coup_strengthfloatCoupling strength. temperaturefloatBath temperature, in units corresponding to planck. N_cutintCutoff parameter for the bath. N_expintNumber of exponential terms used to approximate the bath correlation; functions. planckfloatreduced Planck constant. boltzmannfloatBoltzmann’s constant. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. statsqutip.solver.Statsoptional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coefflist of complexCoefficients for the exponential series terms. exp_freqlist of complexFrequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=N",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:37224,coupling,coupling,37224,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['coupling'],['coupling']
Modifiability,"this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve); This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate.; There are opportunities to develop a more general spectral density code. Attributes. H_sysQobjSystem Hamiltonian. coup_opQobjOperator describing the coupling between system and bath. coup_strengthfloatCoupling strength. temperaturefloatBath temperature, in units corresponding to planck. N_cutintCutoff parameter for the bath. N_expintNumber of exponential terms used to approximate the bath correlation; functions. planckfloatreduced Planck constant. boltzmannfloatBoltzmann’s constant. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. statsqutip.solver.Statsoptional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coefflist of complexCoefficients for the exponential series terms. exp_freqlist of complexFrequencies for the exponential series terms. configure(self, H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, re",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:30199,coupling,coupling,30199,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['coupling'],['coupling']
Modifiability,"tim_method=optim_method, method_params=method_params,; dyn_type=dyn_type, dyn_params=dyn_params, ; prop_type=prop_type, prop_params=prop_params,; fid_type=fid_type, fid_params=fid_params,; init_pulse_type=init_pulse_type, init_pulse_params=init_pulse_params,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; ramping_pulse_type=ramping_pulse_type, ; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, gen_stats=gen_stats). dyn = optim.dynamics. dyn.init_timeslots(); # Generate initial pulses for each control; init_amps = np.zeros([dyn.num_tslots, dyn.num_ctrls]); ; if alg == 'CRAB':; for j in range(dyn.num_ctrls):; pgen = optim.pulse_generator[j]; pgen.init_pulse(); init_amps[:, j] = pgen.gen_pulse(); else:; pgen = optim.pulse_generator; for j in range(dyn.num_ctrls):; init_amps[:, j] = pgen.gen_pulse(); ; # Initialise the starting amplitudes; dyn.initialize_controls(init_amps); ; if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:17561,config,configuration,17561,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,5,['config'],['configuration']
Modifiability,"time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; Options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; ``alg_params`` (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by ``alg_params`` (if given there). optim_method : string; Multi-variable optimisation method. The only tested options are 'fmin'; and 'Nelder-mead'. In theory any non-gradient method implemented in; ``scipy.optimize.minimize`` could be used. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~Optimizer` object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the ``scipy.optimize.minimize``; method. The commonly used parameter are:. - xtol - limit on variable change for convergence; - ftol - limit on fidelity error change for convergence. phase_option : string; Determines how global phase is treated in fidelity calculations; (``fid_type='UNIT'`` only). Options:. - PSU - global phase ignored; - SU - global phase included. dyn_params : dict; Parameters for the :obj:`~Dynamics` object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_para",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:44646,variab,variable,44646,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,1,['variab'],['variable']
Modifiability,"time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; Options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; ``alg_params`` (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by ``alg_params`` (if given there). optim_method : string; Multi-variable optimisation method. The only tested options are 'fmin'; and 'Nelder-mead'. In theory any non-gradient method implemented in; ``scipy.optimize.minimize`` could be used. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~qutip.control.optimizer.Optimizer` object or; the termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; ``scipy.optimize.minimize`` method. The commonly used parameter are:. - xtol - limit on variable change for convergence; - ftol - limit on fidelity error change for convergence. phase_option : string; Determines how global phase is treated in fidelity calculations; (``fid_type='UNIT'`` only). Options:. - PSU - global phase ignored; - SU - global phase included. dyn_params : dict; Parameters for the :obj:`~qutip.control.dynamics.Dynamics` object.; The key value pairs are assumed to be attribute name value pairs.; They",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:43576,variab,variable,43576,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,1,['variab'],['variable']
Modifiability,"time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as loggin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:3544,variab,variables,3544,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,10,['variab'],['variables']
Modifiability,"time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as l",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:3553,variab,variables,3553,docs/4.5/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html,2,['variab'],['variables']
Modifiability,"time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; In [42]: H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [43]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [44]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [45]: args = {'A': 9, 'sig': 5}. In [46]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e, j or pi will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶. Note; New in QuTiP 4.1. Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes it own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; In [47]: t = np.linspace(-15, 15, 100). In [48]: func = lambda t: 9*np.exp(-(t / 5)** 2). In [49]: noisy_func = lambda t: func(t)+(0.05*func(t))*np.random.randn(t.shape[0]). In [50]: noisy_data = noisy_func(t). In [51]: plt.figure(); Out[51]: <Figure size 640x480 with 0 A",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:13340,variab,variables,13340,docs/4.3/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html,1,['variab'],['variables']
Modifiability,"time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; In [42]: H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [43]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [44]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [45]: args = {'A': 9, 'sig': 5}. In [46]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e, j or pi will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶. Note; New in QuTiP 4.1. Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes it own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; In [47]: t = np.linspace(-15, 15, 100). In [48]: func = lambda t: 9*np.exp(-(t / 5)** 2). In [49]: noisy_func = lambda t: func(t)+(0.05*func(t))*np.random.randn(t.shape[0]). In [50]: noisy_data = noisy_func(t). In [51]: plt.figure(); Out[51]: <matplotlib.figure.Figure at ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html:13314,variab,variables,13314,docs/4.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html,1,['variab'],['variables']
Modifiability,"time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; In [44]: H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [45]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [46]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [47]: args = {'A': 9, 'sig': 5}. In [48]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e, j or pi will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶. Note; New in QuTiP 4.1. Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes it own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; In [49]: t = np.linspace(-15, 15, 100). In [50]: func = lambda t: 9*np.exp(-(t / 5)** 2). In [51]: noisy_func = lambda t: func(t)+(0.05*func(t))*np.random.randn(t.shape[0]). In [52]: noisy_data = noisy_func(t). In [53]: plt.plot(t, func(t)); Out[53]: [<matplotlib.lines.Li",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html:13574,variab,variables,13574,docs/4.1/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html,1,['variab'],['variables']
Modifiability,"time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; In [44]: H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [45]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [46]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [47]: args = {'A': 9, 'sig': 5}. In [48]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e, j or pi will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; In [49]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [50]: args = {'A': 9, 'sig': 5}. In [51]: output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); 10.0%. Run time: 0.36s. Est. time left: 00:00:00:03; 20.0%. Run time: 0.64s. Est. time left: 00:00:00:02; 30.0%. Run",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html:13937,variab,variables,13937,docs/3.1.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html,1,['variab'],['variables']
Modifiability,"time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; In [44]: H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [45]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [46]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [47]: args = {'A': 9, 'sig': 5}. In [48]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e, j or pi will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; In [49]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [50]: args = {'A': 9, 'sig': 5}. In [51]: output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); 10.0%. Run time: 0.95s. Est. time left: 00:00:00:08; 20.0%. Run time: 1.81s. Est. time left: 00:00:00:07; 30.0%. Run",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html:13477,variab,variables,13477,docs/4.0.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html,1,['variab'],['variables']
Modifiability,"time t given the Floquet modes at that time. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of Floquet modes for time :math:`t`. f_energies : array; The Floquet energies. t : float; The time for which to evaluate the Floquet states. Returns; -------. output : list. A list of Floquet states for the time :math:`t`. """""". return [(f_modes_t[i] * exp(-1j * f_energies[i] * t)); for i in np.arange(len(f_energies))]. [docs]def floquet_states_t(f_modes_0, f_energies, t, H, T, args=None):; """"""; Evaluate the floquet states at time t given the initial Floquet modes. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. t : float; The time for which to evaluate the Floquet states. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns; -------. output : list. A list of Floquet states for the time :math:`t`. """""". f_modes_t = floquet_modes_t(f_modes_0, f_energies, t, H, T, args); return [(f_modes_t[i] * exp(-1j * f_energies[i] * t)); for i in np.arange(len(f_energies))]. [docs]def floquet_wavefunction(f_modes_t, f_energies, f_coeff, t):; """"""; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the Floquet modes at time `t`. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """"""; return sum([f_modes_t[i] * exp(-1j * f_energies[i] * t) * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/floquet.html:9687,variab,variables,9687,docs/4.4/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/floquet.html,3,['variab'],['variables']
Modifiability,"time t given the Floquet modes at that time. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of Floquet modes for time :math:`t`. f_energies : array; The Floquet energies. t : float; The time for which to evaluate the Floquet states. Returns; -------. output : list. A list of Floquet states for the time :math:`t`. """""". return [(f_modes_t[i] * exp(-1j * f_energies[i] * t)); for i in np.arange(len(f_energies))]. [docs]def floquet_states_t(f_modes_0, f_energies, t, H, T, args=None):; """"""; Evaluate the floquet states at time t given the initial Floquet modes. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. t : float; The time for which to evaluate the Floquet states. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns; -------. output : list. A list of Floquet states for the time :math:`t`. """""". f_modes_t = floquet_modes_t(f_modes_0, f_energies, t, H, T, args); return [(f_modes_t[i] * exp(-1j * f_energies[i] * t)); for i in np.arange(len(f_energies))]. def floquet_wavefunction(f_modes_t, f_energies, f_coeff, t):; """"""; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the Floquet modes at time `t`. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """"""; return sum([f_modes_t[i] * exp(-1j * f_energies[i] * t) * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def fl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/floquet.html:9598,variab,variables,9598,docs/4.2/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/floquet.html,5,['variab'],['variables']
Modifiability,"ting This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organization:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/frontmatter.html:1841,coupling,coupling,1841,docs/4.3/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.3/frontmatter.html,3,['coupling'],['coupling']
Modifiability,"tio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state; state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. (png, hires.png, pdf). H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. (png, hires.png, pdf). Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). (png, hires.png, pdf). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). (png, hires.png, pdf). Important; Naming your args variables exp, sin, pi etc. will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶; Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes it own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; t = np.linspace(-15, 15, 100); func = lambda t: 9*np.exp(-(t / 5)",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:13885,variab,variable,13885,docs/4.6/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html,2,"['rewrite', 'variab']","['rewrite', 'variable']"
Modifiability,"tion algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self.iter_summary:; self.iter_summary.grad_func_call_num = self.num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReachedTerminate(fid_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.w",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:22906,config,config,22906,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,8,['config'],['config']
Modifiability,"tion for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a master equation solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). rho_t = mesolve(H, rho0, tlist, c_ops, [],; args=args, options=options).states; corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); H_shifted, c_ops_shifted, _args = _transform_L_t_shift_new(H, c_ops, args); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). for t_idx, rho in enumerate(rho_t):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. corr_mat[t_idx, :] = mesolve(; H_shifted, c_op * rho * a_op, taulist, c_ops_shifted,; [b_op], args=_args, options=options; ).expect[0]. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # exponential series solvers. def _correlation_es_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using an exponential series solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). # contruct the Liouvillian; L = liouvillian(H, c_ops). corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex). # The user-facing eseries and ode2es are deprecated from QuTiP 4.6, pending; # removal in QuTiP 5.0, however they are being maintained for internal use; # in correlation, so should not raise warnings to the user not matter what; # their settings.; with warnings.catch_warnings():; warni",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/correlation.html:32736,config,config,32736,docs/4.6/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html,1,['config'],['config']
Modifiability,"tion for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a master equation solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). rho_t = mesolve(H, rho0, tlist, c_ops, [],; args=args, options=options).states; corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); H_shifted, c_ops_shifted, _args = _transform_L_t_shift_new(H, c_ops, args); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). for t_idx, rho in enumerate(rho_t):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. corr_mat[t_idx, :] = mesolve(; H_shifted, c_op * rho * a_op, taulist, c_ops_shifted,; [b_op], args=_args, options=options; ).expect[0]. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # exponential series solvers. def _correlation_es_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using an exponential series solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). # contruct the Liouvillian; L = liouvillian(H, c_ops). corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); solES_t = ode2es(L, rho0). # evaluate the correlation function; for t_idx in range(len(tlist)):; rho_t = esval(solES_t, [tlist[t_idx]]); solES_tau = ode2es(L, c_op * rho_t * a_op); corr_mat[t_idx, :] = esval(expect(b_op, solES_tau), taulist). return corr_mat. def _spectrum_es(H, wlist,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/correlation.html:32828,config,config,32828,docs/4.5/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/correlation.html,1,['config'],['config']
Modifiability,"tion in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:198998,variab,variables,198998,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['variab'],['variables']
Modifiability,"tion in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:142876,variab,variables,142876,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,12,['variab'],['variables']
Modifiability,"tion so that you can; implement your own fermionic baths.; Our implementation of fermionic baths primarily follows the definitions used by; Christian Schinabeck in his dissertation (; https://opus4.kobv.de/opus4-fau/files/10984/DissertationChristianSchinabeck.pdf; ) and related publications.; A notebook containing a complete example similar to this one implemented in; BoFiN can be found in example notebook 4b. Describing the system and bath¶; First, let us construct the system Hamiltonian, \(H_{sys}\), and the initial; system state, rho0:; from qutip import basis, destroy. # The system Hamiltonian:; e1 = 1. # site energy; H_sys = e1 * destroy(2).dag() * destroy(2). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:; # Shared bath properties:; gamma = 0.01 # coupling strength; W = 1.0 # cut-off; T = 0.025851991 # temperature; beta = 1. / T. # Chemical potentials for the two baths:; mu_L = 1.; mu_R = -1. # System-bath coupling operator:; Q = destroy(2). where \(\Gamma\) (gamma), \(W\) and \(T\) are the parameters of; an Lorentzian bath, \(\mu_L\) (mu_L) and \(\mu_R\) (mu_R) are; the chemical potentials of the left and right baths, and Q is the coupling; operator between the system and the baths.; We may the pass these parameters to either LorentzianBath or; LorentzianPadeBath to construct an expansion of the bath correlations:; from qutip.nonmarkov.heom import LorentzianBath; from qutip.nonmarkov.heom import LorentzianPadeBath. # Number of expansion terms to retain:; Nk = 2. # Matsubara expansion:; bath_L = LorentzianBath(Q, gamma, W, mu_L, T, Nk, tag=""L""); bath_R = LorentzianBath(Q, gamma, W, mu_R, T, Nk, tag=""R""). # Padé expansion:; bath_L = LorentzianPadeBath(Q, gamma, W, mu_L, T, Nk, tag=""L""); bath_R = LorentzianPadeBath(Q, gamma, W, mu_R, T, Nk, tag=""R""). Where Nk is the number of terms to retain within the expansion of the; bath.; Note that we haved labelled each bath with a tag (either “L” or “R”) so t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/heom/fermionic.html:3357,coupling,coupling,3357,docs/4.7/guide/heom/fermionic.html,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/fermionic.html,1,['coupling'],['coupling']
Modifiability,"tion uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]¶. normalize_SU(A)[source]¶. normalize_gradient_PSU(grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(phase_option=None)[source]¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:224861,config,configuration,224861,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['config'],['configuration']
Modifiability,"tion uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]¶. normalize_SU(A)[source]¶. normalize_gradient_PSU(grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(phase_option=None)[source]¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes:; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If No",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:105591,config,configuration,105591,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['config'],['configuration']
Modifiability,"tion values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expect = []; for num in ntraj:; expt_data = np.mean(mc.expect_out[:num], axis=0); data_list = []; if any([not op.isherm for op in e_ops]):; for k in range(len(e_ops)):; if e_ops[k].isherm:; data_list.append(np.real(expt_data[k])); else:; data_list.append(expt_data[k]); else:; data_list = [data for data in expt_data]; output.expect.append(data_list); else:; # no averaging for single trajectory or if average_expect flag; # (Options) is off; if mc.expect_out is not None:; output.expect = mc.expect_out. # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:10795,config,config,10795,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"tion. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:drift : Qobj or list of Qobj. the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj. a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics. initial : Qobj. starting point for the evolution.; Typically the identity matrix. target : Qobj. target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None. number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None. total time for the evolution; None implies that times",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/apidoc/functions.html:167685,variab,variables,167685,docs/4.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.1/apidoc/functions.html,1,['variab'],['variables']
Modifiability,"tion. update_rho(rho)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode density matrix. class HarmonicOscillatorWaveFunction(psi=None, omega=1.0, extent=[-5, 5], steps=250)[source]¶. update(psi)[source]¶; Calculate the wavefunction for the given state of an harmonic; oscillator. class HarmonicOscillatorProbabilityFunction(rho=None, omega=1.0, extent=[-5, 5], steps=250)[source]¶. update(rho)[source]¶; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix). Quantum information processing¶. class Gate(name, targets=None, controls=None, arg_value=None, arg_label=None)[source]¶; Representation of a quantum gate, with its required parametrs, and target; and control qubits. class QubitCircuit(N, reverse_states=True)[source]¶; Representation of a quantum program/algorithm, maintaining a sequence; of gates. add_1q_gate(name, start=0, end=None, qubits=None, arg_value=None, arg_label=None)[source]¶; Adds a single qubit gate with specified parameters on a variable; number of qubits in the circuit. By default, it applies the given gate; to all the qubits in the register. Parameters:; name (String) – Gate name.; start (Integer) – Starting location of qubits.; end (Integer) – Last qubit for the gate.; qubits (List) – Specific qubits for applying gates.; arg_value (Float) – Argument value(phi).; arg_label (String) – Label for gate representation. add_circuit(qc, start=0)[source]¶; Adds a block of a qubit circuit to the main circuit.; Globalphase gates are not added. Parameters:; qc (QubitCircuit) – The circuit block to be added to the main circuit.; start (Integer) – The qubit on which the first gate is applied. add_gate(gate, targets=None, controls=None, arg_value=None, arg_label=None)[source]¶; Adds a gate with specified parameters to the circuit. Parameters:; gate (String or Gate) – Gate name. If gate is an instance of Gate, parameters are; unpacked and added.; targets (List) – Gate ta",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:52276,variab,variable,52276,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['variab'],['variable']
Modifiability,"tion. update_rho(rho)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode density matrix. class HarmonicOscillatorWaveFunction(psi=None, omega=1.0, extent=[-5, 5], steps=250)[source]¶. update(psi)[source]¶; Calculate the wavefunction for the given state of an harmonic; oscillator. class HarmonicOscillatorProbabilityFunction(rho=None, omega=1.0, extent=[-5, 5], steps=250)[source]¶. update(rho)[source]¶; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix). Quantum information processing¶. class Gate(name, targets=None, controls=None, arg_value=None, arg_label=None)[source]¶; Representation of a quantum gate, with its required parametrs, and target; and control qubits. class QubitCircuit(N, reverse_states=True)[source]¶; Representation of a quantum program/algorithm, maintaining a sequence; of gates. add_1q_gate(name, start=0, end=None, qubits=None, arg_value=None, arg_label=None)[source]¶; Adds a single qubit gate with specified parameters on a variable; number of qubits in the circuit. By default, it applies the given gate; to all the qubits in the register. Parameters:name : String. Gate name. start : Integer. Starting location of qubits. end : Integer. Last qubit for the gate. qubits : List. Specific qubits for applying gates. arg_value : Float. Argument value(phi). arg_label : String. Label for gate representation. add_circuit(qc, start=0)[source]¶; Adds a block of a qubit circuit to the main circuit.; Globalphase gates are not added. Parameters:qc : QubitCircuit. The circuit block to be added to the main circuit. start : Integer. The qubit on which the first gate is applied. add_gate(gate, targets=None, controls=None, arg_value=None, arg_label=None)[source]¶; Adds a gate with specified parameters to the circuit. Parameters:gate: String or `Gate`. Gate name. If gate is an instance of Gate, parameters are; unpacked and added. targets: List. Gate targets. controls: List. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/apidoc/classes.html:48817,variab,variable,48817,docs/4.1/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.1/apidoc/classes.html,1,['variab'],['variable']
Modifiability,"tion; GPU implementation of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Pulse level description of quantum circuits. Pulse level description of quantum circuits¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The aim of this proposal is to enhance QuTiP quantum-circuit compilation; features with regard to quantum information processing. While QuTiP core modules; deal with dynamics simulation, there is also a module for quantum circuits; simulation. The two subsequent Google Summer of Code projects, in 2019 and 2020,; enhanced them in capabilities and features, allowing the simulation both at the; level of gates and at the level of time evolution. To connect them, a compiler; is implemented to compile quantum gates into the Hamiltonian model. We would; like to further enhance this feature in QuTiP and the connection with other; libraries. Expected outcomes¶. APIs to import and export pulses to other libraries. Quantum compiler is a; current research topic in quantum engineering. Although QuTiP has a simple; compiler, many may want to try their own compiler which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; libraries, such as qiskit.pulse and OpenPulse 1, comparing them with; qutip.qip.pulse module and building a more general and comprehensive; description of the pulse.; More examples of quantum system in the qutip.qip.device module. The circuit; simulation and compilation depend strongly on the physical system. At the; moment, we have two models: spin chain and cavity QED. We would like to; include some other commonly used planform such as Superconducting system 2,; Ion trap system 3 or silicon system. Each model will need a new set of; control Ham",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/ideas/pulse-level-quantum-circuits.html:1485,enhance,enhance,1485,docs/4.6/development/ideas/pulse-level-quantum-circuits.html,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/pulse-level-quantum-circuits.html,1,['enhance'],['enhance']
Modifiability,"tion; Solving for Steady-State Solutions; Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function; Example: first-order optical coherence function; Example: second-order optical coherence function. Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Two-time correlation functions. Two-time correlation functions¶; With the QuTiP time-evolution functions (for example qutip.mesolve and qutip.mcsolve), a state vector or density matrix can be evolved from an initial state at \(t_0\) to an arbitrary time \(t\), \(\rho(t)=V(t, t_0)\left\{\rho(t_0)\right\}\), where \(V(t, t_0)\) is the propagator defined by the equation of motion. The resulting density matrix can then be used to evaluate the expectation values of arbitrary combinations of same-time operators.; To calculate two-time correlation functions on the form \(\left<A(t+\tau)B(t)\right>\), we can use the quantum regression theorem (see, e.g., [Gar03]) to write. \[\left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho(t)\right\}\right]; = {\rm Tr}\left[A V(t+\tau, t)\left\{BV(t, 0)\left\{\rho(0)\right\}\right\}\right]\]; We therefore first calculate \(\rho(t)=V(t, 0)\left\{\rho(0)\right\}\) using one of the QuTiP evolution solvers with \(\rho(0)\) as initial state, and then again use the same solver to calculate \(V(t+\tau, t)\left\{B\rho(t)\right\}\) using \(B\rho(t)\) as initial state.; Note that if the initial state is the steady state, then \(\rho(t)=V(t, 0)\left\{\rho_{\rm ss}\right\}=\rho_{\rm ss}\) and. \[\left<A(t+\",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-correlation.html:1280,evolve,evolved,1280,docs/4.7/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-correlation.html,1,['evolve'],['evolved']
Modifiability,"tions is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check fo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:7585,config,config,7585,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,3,['config'],['config']
Modifiability,"tions()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a master equation solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). rho_t = mesolve(H, rho0, tlist, c_ops, [],; args=args, options=options).states; corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); H_shifted, c_ops_shifted, _args = _transform_L_t_shift(H, c_ops, args); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). for t_idx, rho in enumerate(rho_t):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. corr_mat[t_idx, :] = mesolve(; H_shifted, c_op * rho * a_op, taulist, c_ops_shifted,; [b_op], args=_args, options=options; ).expect[0]. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # exponential series solvers. def _correlation_es_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using an exponential series solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). # contruct the Liouvillian; L = liouvillian(H, c_ops). corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); solES_t = ode2es(L, rho0). # evaluate the correlation function; for t_idx in range(len(tlist)):; rho_t = esval(solES_t, [tlist[t_idx]]); solES_tau = ode2es(L, c_op * rho_t * a_op); corr_mat[t_idx, :] = esval(expect(b_op, solES_tau), taulist). return corr_mat. de",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/correlation.html:32414,config,config,32414,docs/4.2/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/correlation.html,5,['config'],['config']
Modifiability,"tions.average_states):; # collect states, averaged over trajectories; sol.states += np.array(sols[j].states); else:; # collect states, all trajectories; sol.states = np.vstack((sol.states,; np.array(sols[j].states))); else:; if (config.options.average_expect):; # collect expectation values, averaged; for i in range(config.e_num):; sol.expect[i] += np.array(sols[j].expect[i]); else:; # collect expectation values, all trajectories; sol.expect = np.vstack((sol.expect,; np.array(sols[j].expect))); if (hasattr(sols[j], 'entropy')):; if (config.options.average_states or; config.options.average_expect):; # collect entropy values, averaged; sol.entropy += np.array(sols[j].entropy); else:; # collect entropy values, all trajectories; sol.entropy = np.vstack((sol.entropy,; np.array(sols[j].entropy))); if (config.options.average_states or config.options.average_expect):; if (config.e_num == 0):; sol.states = sol.states / len(sols); else:; sol.expect = list(sol.expect / len(sols)); inds = np.where(config.e_ops_isherm)[0]; for jj in inds:; sol.expect[jj] = np.real(sol.expect[jj]); if (hasattr(sols[0], 'entropy')):; sol.entropy = sol.entropy / len(sols). # convert sol.expect array to list and fix dtypes of arrays; if (not config.options.average_expect) and config.e_num != 0:; temp = [list(sol.expect[ii]) for ii in range(ntraj)]; for ii in range(ntraj):; for jj in np.where(config.e_ops_isherm)[0]:; temp[ii][jj] = np.real(temp[ii][jj]); sol.expect = temp; # convert to list/array to be consistent with qutip mcsolve; sol.states = list(sol.states); return sol. #; # Functions to initialize the problem in fortran; #; def _init_tlist():; Of = _realarray_to_fortran(config.tlist); qtf90.qutraj_run.init_tlist(Of, np.size(Of)). def _init_psi0():; # Of = _qobj_to_fortranfull(config.psi0); Of = _complexarray_to_fortran(config.psi0); qtf90.qutraj_run.init_psi0(Of, np.size(Of)). def _init_ptrace_stuff(sel):; psi0 = Qobj(config.psi0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:18014,config,config,18014,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,"tions.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # S",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:8550,config,config,8550,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"tions=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset(self)[source]¶; Reset any attributes to default values. run(self, rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_lo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:34239,coupling,coupling,34239,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['coupling'],['coupling']
Modifiability,"tip.control.dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent iteration.; Note this is only set if dummping is on; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_uboun",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/optimizer.html:8803,config,config,8803,docs/4.7/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/optimizer.html,2,['config'],['config']
Modifiability,"tip.rhs_generate — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.rhs_generate. Source code for qutip.rhs_generate; __all__ = ['rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config, solver_safe; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html:1002,config,config,1002,docs/4.7/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html,1,['config'],['config']
Modifiability,"tip.solver.Result`, which; contains either an *array* of expectation values or an array of; state vectors, for the times specified by `tlist`.; """"""; opt = options or Options(); if opt.tidy:; R.tidyup(); rho0 = rho0.proj() if rho0.isket else rho0. # Prepare output object.; dt = tlist[1] - tlist[0]; output = Result(); output.solver = ""fmmesolve""; output.times = tlist; if isinstance(e_ops, FunctionType):; expt_callback = True; store_states = opt.store_states or False; else:; expt_callback = False; try:; e_ops = list(e_ops); except TypeError:; raise TypeError(""`e_ops` must be iterable or a function"") from None; n_expt_op = len(e_ops); if n_expt_op == 0:; store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; dtype = np.float64 if op.isherm else np.complex128; output.expect.append(np.zeros(len(tlist), dtype=dtype)); store_states = opt.store_states or (n_expt_op == 0); if store_states:; output.states = []. # Choose which frame transformations should be done on the initial and; # evolved states.; lab_lookup = [f_modes_table_t, f_energies, T]; if (; any(x is None for x in lab_lookup); and not all(x is None for x in lab_lookup); ):; warnings.warn(; ""if transformation back to the computational basis in the lab""; ""frame is desired, all of `f_modes_t`, `f_energies` and `T` must""; ""be supplied.""; ); f_modes_table_t = f_energies = T = None. # Initial state.; if f_modes_0 is not None:; rho0 = rho0.transform(f_modes_0). # Evolved states.; if floquet_basis:; def transform(rho, t):; return rho; elif f_modes_table_t is not None:; # Lab frame, computational basis.; def transform(rho, t):; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); f_states_t = floquet_states(f_modes_t, f_energies, t); return rho.transform(f_states_t, True); elif f_modes_0 is not None:; # Interaction picture, computational basis.; def transform(rho, t):; return rho.transform(f_modes_0, False); else:; raise ValueError(; ""cannot transform out of the Floquet basis w",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/floquet.html:22570,evolve,evolved,22570,docs/4.7/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html,1,['evolve'],['evolved']
Modifiability,"tlist, taulist,; c_ops, a_op, b_op, c_op,; args=args, options=options); elif solver == ""es"":; return _correlation_es_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use me, mc, or es)."" % solver). # master equation solvers. def _correlation_me_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a master equation solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). rho_t = mesolve(H, rho0, tlist, c_ops, [],; args=args, options=options).states; corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); H_shifted, c_ops_shifted, _args = _transform_L_t_shift_new(H, c_ops, args); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). for t_idx, rho in enumerate(rho_t):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. corr_mat[t_idx, :] = mesolve(; H_shifted, c_op * rho * a_op, taulist, c_ops_shifted,; [b_op], args=_args, options=options; ).expect[0]. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # exponential series solvers. def _correlation_es_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using an exponential series solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/correlation.html:32447,config,config,32447,docs/4.5/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/correlation.html,2,['config'],['config']
Modifiability,"tlist, taulist,; c_ops, a_op, b_op, c_op,; args=args, options=options); elif solver == ""es"":; return _correlation_es_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use me, mc, or es)."" % solver). # master equation solvers. def _correlation_me_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a master equation solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). rho_t = mesolve(H, rho0, tlist, c_ops, [],; args=args, options=options).states; corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); taulist = np.asarray(taulist); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). for t_idx, rho in enumerate(rho_t):; corr_mat[t_idx, :] = mesolve(; H, c_op * rho * a_op, taulist + tlist[t_idx], c_ops,; [b_op], args=args, options=options; ).expect[0]. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # exponential series solvers. def _correlation_es_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using an exponential series solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). # contruct the Liouvillian; L = liouvillian(H, c_ops). corr_mat = np.zeros([np.size(tlist), np.si",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/correlation.html:30575,config,config,30575,docs/4.7/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html,1,['config'],['config']
Modifiability,"to keep when; returning a partially traced density matrix. This can be convenient for; large systems where memory becomes a problem, but you are only; interested in parts of the density matrix.; calc_entropy : boolean; If ptrace_sel is specified, calc_entropy=True will have the solver; return the averaged entropy over trajectories in results.entropy. This; can be interpreted as a measure of entanglement. See Phys. Rev. Lett.; 93, 120408 (2004), Phys. Rev. A 86, 022310 (2012). Returns; -------; results : Result; Object storing all results from simulation. """"""; if ntraj is None:; ntraj = options.ntraj. if psi0.type != 'ket':; raise Exception(""Initial state must be a state vector.""); config.options = options; # set num_cpus to the value given in qutip.settings; # if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full(); else:; config.psi0 = psi0.full(); config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape; # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; raise Exception(""ntraj as list argument is not supported.""); else:; config.ntraj = ntraj; # ntraj_list = [ntraj]; # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. if not options.rhs_reuse:; config.soft_reset(); # no time dependence; config.tflag = 0; # check for collapse operators; if len(c_ops) > 0:; config.cflag = 1; else:; config.cflag = 0; # Configure data; _mc_data_config(H, psi0, [], c_ops, [], [], e_ops, options, config). # Load Monte Carlo class; mc = _MC_class(); # Set solver type; if (options.method == 'adams'):; mc.mf = 10; elif (options.method == 'bdf'):; mc.mf = 22; else:; if debug:; print('Unrecognized method for ode solver, using ""adams"".'); mc.mf = 10; # store ket and density matrix dims and shape for convenience; mc.psi0_dims = psi0.dims; mc.psi0_shape = psi0.shape; m",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:5977,config,config,5977,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,"to make a Permutational Invariant matrix; # ============================================================================; def tau_column(tau, k, j):; """"""; Determine the column index for the non-zero elements of the matrix for a; particular row `k` and the value of `j` from the Dicke space. Parameters; ----------; tau: str; The tau function to check for this `k` and `j`. k: int; The row of the matrix M for which the non zero elements have; to be calculated. j: float; The value of `j` for this row.; """"""; # In the notes, we indexed from k = 1, here we do it from k = 0; k = k + 1; mapping = {""tau3"": k-(2 * j + 3),; ""tau2"": k-1,; ""tau4"": k+(2 * j - 1),; ""tau5"": k-(2 * j + 2),; ""tau1"": k,; ""tau6"": k+(2 * j),; ""tau7"": k-(2 * j + 1),; ""tau8"": k+1,; ""tau9"": k+(2 * j + 1)}; # we need to decrement k again as indexing is from 0; return int(mapping[tau] - 1). [docs]class Pim(object):; """"""; The Permutation Invariant Matrix class. Initialize the class with the parameters for generating a Permutation; Invariant matrix which evolves a given diagonal initial state `p` as:. dp/dt = Mp. Parameters; ----------; N: int; The number of two-level systems. emission: float; Incoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: float; Local dephasing coefficient.; default: 0.0. pumping: float; Incoherent pumping coefficient.; default: 0.0. collective_emission: float; Collective (superradiant) emmission coefficient.; default: 0.0. collective_pumping: float; Collective pumping coefficient.; default: 0.0. collective_dephasing: float; Collective dephasing coefficient.; default: 0.0. Attributes; ----------; N: int; The number of two-level systems. emission: float; Incoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: float; Local dephasing coefficient.; default: 0.0. pumping: float; Incoherent pumping coefficient.; default: 0.0. collective_emission: float; Collective (superradiant) emmission coefficient.; default: 0.0. collective_d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/piqs.html:34055,evolve,evolves,34055,docs/4.3/modules/qutip/piqs.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/piqs.html,2,['evolve'],['evolves']
Modifiability,"to projectors). targetslist of ints, optionalSpecifies a list of target “qubit” indices on which to apply; the measurement using qutip.qip.operations.gates.expand_operator; to expand ops into full dimension. Returns. collapsed_stateslist of QobjThe collapsed states obtained after measuring the qubits and obtaining; the qubit specified by the target in the state specified by the index. probabilitieslist of floatsThe probability of measuring a state in a the state specified by the; index. Dynamics and Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, psi0, tlist, e_ops=None, args=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian.; Evolve the state vector (psi0) using a given Hamiltonian (H), by; integrating the set of ordinary differential equations that define the; system. Alternatively evolve a unitary matrix in solving the Schrodinger; operator equation.; The output is either the state vector or unitary matrix at arbitrary points; in time (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters. HQobj, QobjEvo, list, or callableSystem Hamiltonian as a Qobj , list of; Qobj and coefficient, QobjEvo,; or a callback function for time-dependent Hamiltonians. List format; and options can be found in QobjEvo’s description. psi0QobjInitial state vector (ket) or initial unitary operator psi0 = U. tlistarray_like of floatList of times for \(t\). e_opsNone / list / callback function, optionalA list of operators as Qobj and/or callable functions (can be mixed); or a single callable function. For callable functions, they are called; as f(t, s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:79203,evolve,evolve,79203,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['evolve'],['evolve']
Modifiability,"to start "" + str(self.nprocs) + "" process(es).""); print(""Number of trajectories for each process: "" +; str(self.ntrajs)). for i in range(self.nprocs):; p = Process(target=self.evolve_serial,; args=((resq, self.ntrajs[i], i, self.seed * (i + 1)),)); p.start(); processes.append(p); cnt = 0. while True:; try:; sols.append(resq.get()); resq.task_done(); cnt += 1; if (cnt >= self.nprocs):; break; except KeyboardInterrupt:; break; except:; pass. resq.join(); for proc in processes:; try:; proc.join(); except KeyboardInterrupt:; if debug:; print(""Cancel thread on keyboard interrupt""); proc.terminate(); proc.join(); resq.close(); return sols. def serial(self):. if debug:; print(inspect.stack()[0][3]). self.nprocs = 1; self.ntrajs = [self.ntraj]; if debug:; print(""Running in serial.""); print(""Number of trajectories: "" + str(self.ntraj)); sol = self.evolve_serial((0, self.ntraj, 0, self.seed)); return [sol]. def run(self):. if debug:; print(inspect.stack()[0][3]). from numpy.random import random_integers; if (config.c_num == 0):; # force one trajectory if no collapse operators; config.ntraj = 1; self.ntraj = 1; # Set unravel_type to 1 to integrate without collapses; self.unravel_type = 1; if (config.e_num == 0):; # If we are returning states, and there are no; # collapse operators, set average_states to False to return; # ket vectors instead of density matrices; config.options.average_states = False; # generate a random seed, useful if e.g. running with MPI; self.seed = random_integers(1e8); if (self.serial_run):; # run in serial; sols = self.serial(); else:; # run in paralell; sols = self.parallel(); # gather data; self.sol = _gather(sols). def evolve_serial(self, args):. if debug:; print(inspect.stack()[0][3] + "":"" + str(os.getpid())). # run ntraj trajectories for one process via fortran; # get args; queue, ntraj, instanceno, rngseed = args; # initialize the problem in fortran; _init_tlist(); _init_psi0(); if (self.ptrace_sel != []):; _init_ptrace_stuff(self.ptrace_sel); _in",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:10621,config,config,10621,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,"to; :math:`\\psi(t_0)`; construct_effective_hamiltonian : bool; Whether an effective Hamiltonian should be constructed from H and c_ops:; :math:`H_{eff} = H - \\frac{i}{2} \\sum_n \\sigma_n^\\dagger \\sigma_n`; Default: True. Returns; -------; phi_n : :class: qutip.Qobj; The scattered bath state projected onto the temporal basis given by; tlist. If there are W waveguides, T times, and N photon emissions, then; the state is a tensor product state with dimensionality T^(W*N).; """"""; T = len(tlist); W = len(c_ops). if n_emissions == 0:; phi_n = zero_ket(W * T); else:; phi_n = tensor([zero_ket(W * T)] * n_emissions). if construct_effective_hamiltonian:; # Construct an effective Hamiltonian from system hamiltonian and c_ops; if type(H) is Qobj:; Heff = H - 1j / 2 * sum([op.dag() * op for op in c_ops]); elif type(H) is list:; Heff = H + [-1j / 2 * sum([op.dag() * op for op in c_ops])]; else:; raise TypeError(""Hamiltonian must be Qobj or list-callback format""); else:; Heff = H. evolver = Evolver(Heff, tlist). all_emission_indices = combinations_with_replacement(range(T), n_emissions). if system_zero_state is None:; system_zero_state = psi0. # Compute <omega_tau> for all combinations of tau; for emission_indices in all_emission_indices:; # Consider unique partitionings of emission times into waveguides; partition = tuple(set(set_partition(emission_indices, W))); # Consider all possible partitionings of time bins by waveguide; for indices in partition:; taus = [[tlist[i] for i in wg_indices] for wg_indices in indices]; omega = photon_scattering_operator(evolver, c_ops, taus); phi_n_amp = system_zero_state.dag() * omega * psi0; # Add scatter amplitude times temporal basis to overall state; phi_n += phi_n_amp * temporal_basis_vector(indices, T). return phi_n. [docs]def scattering_probability(H, psi0, n_emissions, c_ops, tlist,; system_zero_state=None,; construct_effective_hamiltonian=True):; """"""; Compute the integrated probability of scattering n photons in an arbitrary; system",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/scattering.html:10177,evolve,evolver,10177,docs/4.3/modules/qutip/scattering.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/scattering.html,3,['evolve'],['evolver']
Modifiability,"tochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver - Photocurrent. Stochastic Solver - Photocurrent¶; Photocurrent method, like monte-carlo method, allows for simulating an; individual realization of the system evolution under continuous measurement. Closed system¶; Photocurrent evolution have the state evolve deterministically between quantum jumps.; During the deterministic part, the system evolve by schrodinger equation with a; non-hermitian, norm conserving effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}+; \frac{i\hbar}{2}\left( -\sum_{n}C^{+}_{n}C_{n}+ |C_{n} \psi |^2\right).\]; With \(C_{n}\), the collapse operators.; This effective Hamiltonian is equivalent to the monte-carlo effective; Hamiltonian with an extra term to keep the state normalized.; At each time step of \(\delta t\), the wave function has a probability. (2)¶\[\delta p_{n} = \left<\psi(t)|C_{n}^{+}C_{n}|\psi(t)\right> \delta t\]; of making a quantum jump. \(\delta t\) must be chosen small enough to keep; that probability small \(\delta p << 1\). If multiple jumps happen at the; same time step, the state become unphysical.; Each jump result in a sharp variation of the state by,. (3)¶\[\delta \psi = \left( \frac{C_n \psi} {\left| C_n \psi \right|} - \psi \right)\]; The basic photocurrent method directly int",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-photocurrent.html:1474,evolve,evolve,1474,docs/4.5/guide/dynamics/dynamics-photocurrent.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-photocurrent.html,1,['evolve'],['evolve']
Modifiability,"tonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); H_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:35248,config,config,35248,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"tonians and; collapse operators. optionsqutip.solver.Optionswith options for the ODE solver. unitary_mode = str (‘batch’, ‘single’)Solve all basis vectors simulaneously (‘batch’) or individually; (‘single’). parallelbool {False, True}Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns. aqobjInstance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters. UqobjOperator representing the propagator. Returns. aqobjInstance representing the steady-state density matrix. Time-dependent problems¶. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). scattering_probability(H, psi0, n_emissions, c_ops, tlist, system_zero_state=None, construct_effective_hamiltonian=True)[source]¶; Compute the integrated probability of scattering n photons in an arbitrary; system. This function accepts a nonlinearly spaced array of times. Parameters. H:class: qutip.Qobj or listSystem-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is constructed from H and; c_o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:151177,config,config,151177,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['config'],['config']
Modifiability,"tonians; Note a matrix diagonalisation is used to compute the exponent; The eigen decomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes; ----------; drift_ham : Qobj; This is the drift Hamiltonian for unitary dynamics; It is mapped to drift_dyn_gen during initialize_controls. ctrl_ham : List of Qobj; These are the control Hamiltonians for unitary dynamics; It is mapped to ctrl_dyn_gen during initialize_controls. H : List of Qobj; The combined drift and control Hamiltonians for each timeslot; These are the dynamics generators for unitary dynamics.; It is mapped to dyn_gen during initialize_controls; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'UNIT'; self.drift_ham = None; self.ctrl_ham = None; self.H = None. def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.amp_update_mode == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). # set the default fidelity computer; self.fid_computer = fidcomp.FidCompUnitary(self); # set the default propagator computer; self.prop_computer = propcomp.PropCompDiag(self). def initialize_controls(self, amplitudes, init_tslots=True):; # Either the _dyn_gen or _ham names can be used; # This assumes that one or other has been set in the configuration. self._map_dyn_gen_to_ham(); Dynamics.initialize_controls(self, amplitudes, init_tslots=init_tslots); self.H = self.dyn_gen. def _map_dyn_gen_to_ham(self):; if self.drift_dyn_gen is None:; self.drift_dyn_gen = self.drift_ham; else:; self.drift_ham = self.drift_dyn_gen. if self.ctrl_dyn_gen is None:; self.ctrl_dyn_gen = self.ctrl_ham; else:; self.ctrl_ham = self.ctrl_dyn_gen. self._dyn_gen_mapped = True. [docs] def get_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:23546,config,configuration,23546,docs/3.1.0/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html,1,['config'],['configuration']
Modifiability,"tors; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function; Example: first-order optical coherence function; Example: second-order optical coherence function. Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Two-time correlation functions. Two-time correlation functions¶; With the QuTiP time-evolution functions (for example qutip.mesolve and qutip.mcsolve), a state vector or density matrix can be evolved from an initial state at \(t_0\) to an arbitrary time \(t\), \(\rho(t)=V(t, t_0)\left\{\rho(t_0)\right\}\), where \(V(t, t_0)\) is the propagator defined by the equation of motion. The resulting density matrix can then be used to evaluate the expectation values of arbitrary combinations of same-time operators.; To calculate two-time correlation functions on the form \(\left<A(t+\tau)B(t)\right>\), we can use the quantum regression theorem (see, e.g., [Gar03]) to write. \[\left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho(t)\right\}\right]; = {\rm Tr}\left[A V(t+\tau, t)\left\{BV(t, 0)\left\{\rho(0)\right\}\right\}\right]\]; We therefore first calculate \(\rho(t)=V(t, 0)\left\{\rho(0)\right\}\) using one of the QuTiP evolution solvers with \(\rho(0)\) as initial state, and then again use the same solver to calculate \(V(t+\tau, t)\left\{B\rho(t)\right\}\) using \(B\rho(t)\) as initial state.; Note that if the initial state is the steady state, then \(\rho(t)=V(t, 0)\left\{\rho_{\rm ss}\right\}=\rho_{\rm ss}\) and. \[\left<A(t+\",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-correlation.html:1163,evolve,evolved,1163,docs/4.2/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-correlation.html,5,['evolve'],['evolved']
Modifiability,"tors; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expect = []; for num in ntraj:; expt_data = np.mean(mc.expect_out[:num], axis=0); data_list = []; if any([not op.isherm for op in e_ops]):; for k in range(len(e_ops)):; if e_ops[k].isherm:; data_list.append(np.real(expt_data[k])); else:; data_list.append(expt_data[k]); else:; data_list = [data for data in expt_data]; output.expect.append(data_list); else:; # no averaging for single trajectory or if average_expect flag; # (Options) is off; if mc.exp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:9611,config,config,9611,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"tr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + '",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:19059,config,config,19059,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"trength. temperaturefloatBath temperature, in units corresponding to planck. N_cutintCutoff parameter for the bath. N_expintNumber of exponential terms used to approximate the bath correlation; functions. planckfloatreduced Planck constant. boltzmannfloatBoltzmann’s constant. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. statsqutip.solver.Statsoptional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coefflist of complexCoefficients for the exponential series terms. exp_freqlist of complexFrequencies for the exponential series terms. configure(self, H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats(self)[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset(self)[source]¶; Reset any attributes to default values. class HSolv",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:31093,config,configure,31093,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['config'],['configure']
Modifiability,"trices, often called superoperators.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; In [93]: X = sigmax(). In [94]: S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the to_super function when given; type='oper' input.; In [95]: S2 = to_super(X). In [96]: (S - S2).norm(); Out[96]: 0.0. Quantum objects representing superoperators are denoted by type='super':; In [97]: S; Out[97]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[ 0. 0. 0. 1.]; [ 0. 0. 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the iscp, istp; and iscptp attributes:; In [98]: S.iscp, S.istp, S.iscptp; Out[98]: (True, True, True). In addition, dynamical generators on this extended space, often called; Liouvillian superoperators, can be created using the liouvillian function. Each of these takes a Hamilonian along with; a list of collapse operators, and returns a type=""super"" object that can; be exponentiated to find the superoperator for that evolution.; In [99]: H = 10 * sigmaz(). In [100]: c1 = destroy(2). In [101]: L = liouvillian(H, [c1]). In [102]: L; Out[102]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0.0 +0.j 0.0 +0.j 0.0 +0.j 1.0 +0.j]; [ 0.0 +0.j -0.5+20.j 0.0 +0.j 0.0 +0.j]; [ 0.0 +0.j 0.0 +0.j -0.5-20.j 0.0 +0.j]; [ 0.0 +0.j 0.0 +0.j 0.0 +0.j -1.0 +0.j]]. In [103]: S = (12 * L).expm(). For qubits, a particularly useful way to visualize superoperators is to plot them in the Pauli basis,; such that \(S_{\mu,\nu} = \langle\!\langle \sigma_{\mu} | S[\sigma_{\nu}] \rangle\!\rangle\). Because; the Pauli basis is Hermitian, \(S_{\mu,\nu}\) is a real number for all Hermitian-preserving superoperators; \(S\),; a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-states.html:20532,extend,extended,20532,docs/4.2/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-states.html,3,['extend'],['extended']
Modifiability,"tring of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix represenation to. msg = ""Incorrect specification of time-dependence: "". for h_spec in H:; if isinstance(h_spec, Qobj):; h = h_spec. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; Lconst += -1j * (spre(h) - spost(h)); elif h.issuper:; Lconst += h; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; L = -1j * (spre(h) - spost(h)); elif h.issuper:; L = h; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/rhs_generate.html:3881,config,config,3881,docs/4.4/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/rhs_generate.html,3,['config'],['config']
Modifiability,"trols=None, arg_value=None,; arg_label=None, index=None):; """"""; Adds a gate with specified parameters to the circuit. Parameters; ----------; gate: string or `Gate`; Gate name. If gate is an instance of `Gate`, parameters are; unpacked and added.; targets: list; Gate targets.; controls: list; Gate controls.; arg_value: float; Argument value(phi).; arg_label: string; Label for gate representation.; index : list; Positions to add the gate.; """"""; if isinstance(gate, Gate):; name = gate.name; targets = gate.targets; controls = gate.controls; arg_value = gate.arg_value; arg_label = gate.arg_label. else:; name = gate. if index is None:; self.gates.append(Gate(name, targets=targets, controls=controls,; arg_value=arg_value, arg_label=arg_label)). else:; for position in index:; self.gates.insert(position, Gate(name, targets=targets,; controls=controls,; arg_value=arg_value,; arg_label=arg_label)). def add_1q_gate(self, name, start=0, end=None, qubits=None,; arg_value=None, arg_label=None):; """"""; Adds a single qubit gate with specified parameters on a variable; number of qubits in the circuit. By default, it applies the given gate; to all the qubits in the register. Parameters; ----------; name : string; Gate name.; start : int; Starting location of qubits.; end : int; Last qubit for the gate.; qubits : list; Specific qubits for applying gates.; arg_value : float; Argument value(phi).; arg_label : string; Label for gate representation.; """"""; if name not in [""RX"", ""RY"", ""RZ"", ""SNOT"", ""SQRTNOT"", ""PHASEGATE""]:; raise ValueError(""%s is not a single qubit gate"" % name). if qubits is not None:; for i in range(len(qubits)):; self.gates.append(Gate(name, targets=qubits[i], controls=None,; arg_value=arg_value,; arg_label=arg_label)). else:; if end is None:; end = self.N - 1; for i in range(start, end):; self.gates.append(Gate(name, targets=i, controls=None,; arg_value=arg_value,; arg_label=arg_label)). def add_circuit(self, qc, start=0):; """"""; Adds a block of a qubit circuit to the mai",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qip/circuit.html:8597,variab,variable,8597,docs/4.5/modules/qutip/qip/circuit.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/circuit.html,1,['variab'],['variable']
Modifiability,"tropy = np.array([0.] * nstep); entropy[:] = qtf90.qutraj_run.reduced_state_entropy[:]; return entropy. def finalize():; # not in use... if debug:; print(inspect.stack()[0][3]). qtf90.qutraj_run.finalize_work(); qtf90.qutraj_run.finalize_sol(). def _gather(sols):; # gather list of Result objects, sols, into one.; sol = Result(); # sol = sols[0]; ntraj = sum([a.ntraj for a in sols]); sol.col_times = np.zeros((ntraj), dtype=np.ndarray); sol.col_which = np.zeros((ntraj), dtype=np.ndarray); sol.col_times[0:sols[0].ntraj] = sols[0].col_times; sol.col_which[0:sols[0].ntraj] = sols[0].col_which; sol.states = np.array(sols[0].states, dtype=object); sol.expect = np.array(sols[0].expect); if (hasattr(sols[0], 'entropy')):; sol.entropy = np.array(sols[0].entropy); sofar = 0; for j in range(1, len(sols)):; sofar = sofar + sols[j - 1].ntraj; sol.col_times[sofar:sofar + sols[j].ntraj] = (; sols[j].col_times); sol.col_which[sofar:sofar + sols[j].ntraj] = (; sols[j].col_which); if (config.e_num == 0):; if (config.options.average_states):; # collect states, averaged over trajectories; sol.states += np.array(sols[j].states); else:; # collect states, all trajectories; sol.states = np.vstack((sol.states,; np.array(sols[j].states))); else:; if (config.options.average_expect):; # collect expectation values, averaged; for i in range(config.e_num):; sol.expect[i] += np.array(sols[j].expect[i]); else:; # collect expectation values, all trajectories; sol.expect = np.vstack((sol.expect,; np.array(sols[j].expect))); if (hasattr(sols[j], 'entropy')):; if (config.options.average_states or; config.options.average_expect):; # collect entropy values, averaged; sol.entropy += np.array(sols[j].entropy); else:; # collect entropy values, all trajectories; sol.entropy = np.vstack((sol.entropy,; np.array(sols[j].entropy))); if (config.options.average_states or config.options.average_expect):; if (config.e_num == 0):; sol.states = sol.states / len(sols); else:; sol.expect = list(sol.expect / len(sols)); in",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:17005,config,config,17005,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,"trs.append(L.data.indptr); Lcoeff.append(h_coeff). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; norm, dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html:12441,config,config,12441,docs/3.1.0/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability,"truction.; An exact copy of the QuTiP 4.6 HSolverDL is provided in; qutip.nonmarkov.dlheom_solver for cases where the functionality of; the older solver is required. The older solver will be completely; removed in QuTiP 5. Note; Unlike the version of HSolverDL in QuTiP 4.6, this solver; supports supplying a time-dependent or Liouvillian H_sys. Note; For compatibility with HSolverDL in QuTiP 4.6 and below, the; parameter N_exp specifying the number of exponents to keep in; the expansion of the bath correlation function is one more than; the equivalent Nk used in the DrudeLorentzBath. I.e.,; Nk = N_exp - 1. The Nk parameter in the; DrudeLorentzBath does not count the zeroeth exponent in; order to better match common usage in the literature. Note; The stats and renorm arguments accepted in QuTiP 4.6 and below; are no longer supported. Parameters. H_sysQobj or QobjEvo or listThe system Hamiltonian or Liouvillian. See HEOMSolver for; a complete description. coup_opQobjOperator describing the coupling between system and bath.; See parameter Q in BosonicBath for a complete description. coup_strengthfloatCoupling strength. Referred to as lam in DrudeLorentzBath. temperaturefloatBath temperature. Referred to as T in DrudeLorentzBath. N_cutintThe maximum depth of the hierarchy. See max_depth in; HEOMSolver for a full description. N_expintNumber of exponential terms used to approximate the bath correlation; functions. The equivalent Nk in DrudeLorentzBath is one; less than N_exp (see note above). cut_freqfloatBath spectral density cutoff frequency. Referred to as gamma in; DrudeLorentzBath. bnd_cut_approxboolUse boundary cut off approximation. If true, the Matsubara; terminator is added to the system Liouvillian (and H_sys is; promoted to a Liouvillian if it was a Hamiltonian). optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_barNone, True or BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:48210,coupling,coupling,48210,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,1,['coupling'],['coupling']
Modifiability,"ts corresponding to planck. N_cut¶; int – Cutoff parameter for the bath. N_exp¶; int – Number of exponential terms used to approximate the bath correlation; functions. planck¶; float – reduced Planck constant. boltzmann¶; float – Boltzmann’s constant. options¶; qutip.solver.Options – Generic solver options.; If set to None the default options will be used. progress_bar¶; BaseProgressBar – Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats¶; qutip.solver.Stats – optional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coeff¶; list of complex – Coefficients for the exponential series terms. exp_freq¶; list of complex – Frequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters:; options (qutip.solver.Options) – Generic solver options.; If set to None the default options will be used; progress_bar (BaseProgressBar) – Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar; stats (qutip.solver.Stats) – Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:27798,config,configure,27798,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['config'],['configure']
Modifiability,"ts the run_optimization method using the L-BFGS-B algorithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BF",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:29024,config,config,29024,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,8,['config'],['config']
Modifiability,"ts will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command.; You should not need to use sudo (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. Installation on Windows¶; As with other operating systems, the easiest method is to use pip install qutip, or use the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/installation.html:7517,config,configure,7517,docs/4.6/installation.html,https://qutip.org,https://qutip.org/docs/4.6/installation.html,2,['config'],['configure']
Modifiability,"tum operator for pre-multiplication. BQobj or QobjEvoQuantum operator for post-multiplication. Returns. superQobj or QobjEvoSuperoperator formed from input quantum objects. vector_to_operator(op)[source]¶; Create a matrix representation given a quantum operator in vector form.; The passed object should have a Qobj.type of ‘operator-ket’; this; function is not designed for general-purpose matrix reshaping. Parameters. opQobj or QobjEvoQuantum operator in column-stacked-vector form. This must have a type; of ‘operator-ket’. Returns. Qobj or QobjEvoThe same object, but re-cast into “standard” operator form. The output; is the same type as the passed object. Superoperator Representations¶; This module implements transformations between superoperator representations,; including supermatrix, Kraus, Choi and Chi (process) matrix formalisms. chi_to_choi(q_oper)[source]¶; Converts a Chi matrix to a Choi matrix.; NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions. choi_to_chi(q_oper)[source]¶; Converts a Choi matrix to a Chi matrix in the Pauli basis.; NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions. choi_to_kraus(q_oper, tol=1e-09)[source]¶; Takes a Choi matrix and returns a list of Kraus operators.; TODO: Create a new class structure for quantum channels, perhaps as a; strict sub-class of Qobj. choi_to_super(q_oper)[source]¶; Takes a Choi matrix to a superoperator; TODO: Sanitize input, Abstract-ify application of channels to states. kraus_to_choi(kraus_list)[source]¶; Takes a list of Kraus operators and returns the Choi matrix for the channel; represented by the Kraus operators in kraus_list. kraus_to_super(kraus_list)[source]¶; Converts a list of Kraus operators and returns a super operator. super_to_choi(q_oper)[source]¶; Takes a superoperator to a Choi matrix; TODO: Sanitize input, incorporate as method on Qobj if type==’super’. to_chi(q_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:47187,extend,extend,47187,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['extend'],['extend']
Modifiability,"tum operator for pre-multiplication. BQobj or QobjEvoQuantum operator for post-multiplication. Returns. superQobj or QobjEvoSuperoperator formed from input quantum objects. vector_to_operator(op)[source]¶; Create a matrix representation given a quantum operator in vector form.; The passed object should have a Qobj.type of ‘operator-ket’; this; function is not designed for general-purpose matrix reshaping. Parameters. opQobj or QobjEvoQuantum operator in column-stacked-vector form. This must have a type; of ‘operator-ket’. Returns. Qobj or QobjEvoThe same object, but re-cast into “standard” operator form. The output; is the same type as the passed object. Superoperator Representations¶; This module implements transformations between superoperator representations,; including supermatrix, Kraus, Choi and Chi (process) matrix formalisms. chi_to_choi(q_oper)[source]¶; Converts a Chi matrix to a Choi matrix.; NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions. choi_to_chi(q_oper)[source]¶; Converts a Choi matrix to a Chi matrix in the Pauli basis.; NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions. choi_to_kraus(q_oper, tol=1e-09)[source]¶; Takes a Choi matrix and returns a list of Kraus operators.; TODO: Create a new class structure for quantum channels, perhaps as a; strict sub-class of Qobj. choi_to_super(q_oper)[source]¶; Takes a Choi matrix to a superoperator; TODO: Sanitize input, Abstract-ify application of channels to states. kraus_to_choi(kraus_ops)[source]¶; Convert a list of Kraus operators into Choi representation of the channel.; Essentially, kraus operators are a decomposition of a Choi matrix,; so in this function we build Choi matrix from vector representation of Kraus operators. Parameters. kraus_opslist[Qobj]The list of Kraus operators to be converted to Choi representation. Returns. choiQobjA quantum object representing the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:47109,extend,extend,47109,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['extend'],['extend']
Modifiability,"tum states and processes; Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Parallel computation. Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; In [1]: def func1(x): return x, x**2, x**3. In [2]: a, b, c = parfor(func1, range(10)). In [3]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [4]: print(b); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-parfor.html:1488,variab,variables,1488,docs/4.2/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-parfor.html,10,['variab'],['variables']
Modifiability,"tuple(indices) for indices in partition). def photon_scattering_operator(evolver, c_ops, taus_list):; """"""; Compute the scattering operator for a system emitting into multiple; waveguides. Parameters; ----------; evolver : :class: qutip.scattering.Evolver; Evolver-wrapped Hamiltonian describing the system.; c_ops : list; list of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; :math:`\\sigma = \\sqrt \\gamma \\cdot a`; taus_list : list-like; List of (list of emission times) for each waveguide. Returns; -------; omega : :class: qutip.Qobj; The temporal scattering operator with dimensionality equal to the; system state.; """"""; omega = 1. # Extract the full list of taus; taus = [(0.0, -1)] # temporal ""ground state"" for arbitrary waveguide; for i, tau_wg in enumerate(taus_list):; for tau in tau_wg:; taus.append((tau, i)); taus.sort(key = lambda tup: tup[0]) # sort taus by time. # Compute Prod Ueff(tq, tq-1); for i in range(1, len(taus)):; tq, q = taus[i]; tprev, _ = taus[i - 1]; omega = c_ops[q] * evolver.prop(tq, tprev) * omega. # Add the <0|Uff(TP, tm)|0> term; tmax = evolver.tlist[-1]; taumax, _ = taus[-1]; # if taus[-1] < tmax:; omega = evolver.prop(tmax, taumax) * omega. return omega. [docs]def temporal_basis_vector(waveguide_emission_indices, n_time_bins):; """"""; Generate a temporal basis vector for emissions at specified time bins into; specified waveguides. Parameters; ----------; waveguide_emission_indices : list or tuple; List of indices where photon emission occurs for each waveguide,; e.g. [[t1_wg1], [t1_wg2, t2_wg2], [], [t1_wg4, t2_wg4, t3_wg4]].; n_time_bins : int; Number of time bins; the range over which each index can vary. Returns; -------; temporal_basis_vector : :class: qutip.Qobj; A basis vector representing photon scattering at the specified indices.; If there are W waveguides, T times, and N photon emissions, then the; basis vector has dimensionality (W*T)^N.; """"""; # Cast waveguide_emission_indices t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/scattering.html:6511,evolve,evolver,6511,docs/4.3/modules/qutip/scattering.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/scattering.html,5,['evolve'],['evolver']
Modifiability,"ture is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : qutip.solver. options for the ODE solver. k_max : int. The truncation of the number of sidebands (default 5). Returns:output : qutip.solver. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. floquet_modes(H, T, args=None, sort=False, U=None)¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sorted in increasing quasienergies or not. Parameters:H : qutip.qobj. system Hamiltonian, time-dependent with period T. args : dictionary. dictionary with variables required to evaluate H. T : float. The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. U : qutip.qobj. The propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns:output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters:f_modes_0 : list of qutip.qobj (kets). Floquet modes at \(t\). f_energies : list. Floquet energies. t : float. The time at which to evaluate the floquet modes. H : qutip.qobj. system Hamiltonian, time-dependent with period T. args : dictionary. dictionary with variables required to evaluate H. T : float. The period of the time-de",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:49157,variab,variables,49157,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,2,['variab'],['variables']
Modifiability,"turns; -------. output: :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`, or; an *array* or state vectors or density matrices corresponding to the; times in `tlist` [if `e_ops` is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. """""". if _safe_mode:; _solver_safety_check(H, rho0, c_ops=[], e_ops=e_ops, args=args); ; if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. # convert array based time-dependence to string format; H, _, args = _td_wrap_array_str(H, [], args, tlist); # check for type (if any) of time-dependent inputs; n_const, n_func, n_str = _td_format_check(H, []). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config time-dependence flags to default values; config.reset(). if n_func > 0:; res = _sesolve_list_func_td(H, rho0, tlist, e_ops, args, options,; progress_bar). elif n_str > 0:; res = _sesolve_list_str_td(H, rho0, tlist, e_ops, args, options,; progress_bar). elif isinstance(H, (types.FunctionType,; types.BuiltinFunctionType,; partial)):; res = _sesolve_func_td(H, rho0, tlist, e_ops, args, options,; progress_bar). else:; res = _sesolve_const(H, rho0, tlist, e_ops, args, options,; progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent unitary wavefunction equation on the list-function format; #; def _sesolve_list_func_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if not isket(psi0",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:5039,config,config,5039,docs/4.0.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html,2,['config'],['config']
Modifiability,"turns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation. .. note::. It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """""". if debug:; print(inspect.stack()[0][3]). if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:8045,config,config,8045,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"tween the; true correlation function of the Drude-Lorentz bath and the sum of; the Nk exponential terms is approximately 2 * delta *; dirac(t), where dirac(t) denotes the Dirac delta function. terminatorQobjThe Padé terminator – i.e. a liouvillian term representing; the contribution to the system-bath dynamics of all exponential; expansion terms beyond Nk. It should be used by adding it to; the system liouvillian (i.e. liouvillian(H_sys)). class UnderDampedBath(Q, lam, gamma, w0, T, Nk, combine=True, tag=None)[source]¶; A helper class for constructing an under-damped bosonic bath from the; bath parameters (see parameters below). Parameters. QQobjOperator describing the coupling between system and bath. lamfloatCoupling strength. gammafloatBath spectral density cutoff frequency. w0floatBath spectral density resonance frequency. TfloatBath temperature. NkintNumber of exponential terms used to approximate the bath correlation; functions. combinebool, default TrueWhether to combine exponents with the same frequency (and coupling; operator). See BosonicBath.combine for details. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. class FermionicBath(Q, ck_plus, vk_plus, ck_minus, vk_minus, tag=None)[source]¶; A helper class for constructing a fermionic bath from the expansion; coefficients and frequencies for the + and - modes of; the bath correlation function.; There must be the same number of + and - modes and their; coefficients must be specified in the same order so that ck_plus[i],; vk_plus[i] are the plus coefficient and frequency corresponding; to the minus mode ck_minus[i], vk_minus[i].; In the fermionic case the order in which excitations are created or; destroyed is important, resulting in two different correlation functions; labelled C_plus(t) and C_plus(t):; C_plus(t) = sum(ck_plus * exp(- vk_plus * t)); C_minus(t) = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:58205,coupling,coupling,58205,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,1,['coupling'],['coupling']
Modifiability,"ty matrices during computation "" +; ""when performing partial trace. Setting sparse_dms = False""); print(""This feature is experimental.""); mc.sparse_dms = False; mc.dm_dims = psi0.ptrace(ptrace_sel).dims; mc.dm_shape = psi0.ptrace(ptrace_sel).shape; if (calc_entropy):; if (ptrace_sel == []):; if debug:; print(""calc_entropy = True, but ptrace_sel = []. Please set "" +; ""a list of components to keep when calculating average"" +; "" entropy of reduced density matrix in ptrace_sel. "" +; ""Setting calc_entropy = False.""); calc_entropy = False; mc.calc_entropy = calc_entropy. # construct output Result object; output = Result(). # Run; mc.run(); output.states = mc.sol.states; output.expect = mc.sol.expect; output.col_times = mc.sol.col_times; output.col_which = mc.sol.col_which; if (hasattr(mc.sol, 'entropy')):; output.entropy = mc.sol.entropy. output.solver = 'Fortran 90 Monte Carlo solver'; # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj. return output. class _MC_class():; def __init__(self):; self.cpus = config.options.num_cpus; self.nprocs = self.cpus; self.sol = Result(); self.mf = 10; # If returning density matrices, return as sparse or dense?; self.sparse_dms = True; # Run in serial?; self.serial_run = False; self.ntraj = config.ntraj; self.ntrajs = []; self.seed = None; self.psi0_dims = None; self.psi0_shape = None; self.dm_dims = None; self.dm_shape = None; self.unravel_type = 2; self.ptrace_sel = []; self.calc_entropy = False. def parallel(self):; from multiprocessing import Process, Queue, JoinableQueue. if debug:; print(inspect.stack()[0][3]). self.ntrajs = []; for i in range(self.cpus):; self.ntrajs.append(min(int(np.floor(float(self.ntraj); / self.cpus)),; self.ntraj - sum(self.ntrajs))); cnt = sum(self.ntrajs); while cnt < self.ntraj:; for i in range(self.cpus):; self.ntrajs[i] += 1; cnt += 1; if (cnt >= self.ntraj):; break; self.ntrajs = np.array(self.ntrajs);",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:8391,config,config,8391,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,"ty of the system evolution is checked at at; evolution recomputation.; level 1 checks all propagators; level 2 checks eigen basis as well; Default is 0. unitarity_tol :; Tolerance used in checking if operator is unitary; Default is 1e-10. dump : :class:`dump.DynamicsDump`; Store of historical calculation data.; Set to None (Default) for no storing of historical data; Use dumping property to set level of data dumping. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the calculations; dumping will be set to SUMMARY during init_evo if dump_to_file is True; and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; dyn_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path; ; """"""; def __init__(self, optimconfig, params=None):; self.config = optimconfig; self.params = params; self.reset(). def reset(self):; # Link to optimiser object if self is linked to one; self.parent = None; # Main functional attributes; self.time = None; self.initial = None; self.target = None; self.ctrl_amps = None; self.initial_ctrl_scaling = 1.0; self.initial_ctrl_offset = 0.0; self.drift_dyn_gen = None; self.ctrl_dyn_gen = None; self._tau = None; self._evo_time = None; self._num_ctrls = None; self._num_tslots = None; # attributes used for processing evolution; self.memory_optimization = 0; self.oper_dtype = None; self.cache_phased_dyn_gen = None; self.cache_prop_grad = None; self.cache_dyn_gen_eigenvectors_adj = None; self.sparse_eigen_decomp = None; self.dyn_dims = None; self.dyn_shape = None; self.sys_dims = None; self.sys_shape = None; self.time_depend_drift = False; # These internal attributes will be of the internal operator data type; # used to compute the evolution; # Note this maybe ndarray, Qobj or some other depending on oper_dtype; self._dri",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html:12663,config,config,12663,docs/4.1/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html,2,['config'],['config']
Modifiability,"ty of the system evolution is checked at at; evolution recomputation.; level 1 checks all propagators; level 2 checks eigen basis as well; Default is 0. unitarity_tol :; Tolerance used in checking if operator is unitary; Default is 1e-10. dump : :class:`dump.DynamicsDump`; Store of historical calculation data.; Set to None (Default) for no storing of historical data; Use dumping property to set level of data dumping. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the calculations; dumping will be set to SUMMARY during init_evo if dump_to_file is True; and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; dyn_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path; ; """"""; def __init__(self, optimconfig, params=None):; self.config = optimconfig; self.params = params; self.reset(). def reset(self):; # Link to optimiser object if self is linked to one; self.parent = None; # Main functional attributes; self.time = None; self.initial = None; self.target = None; self.ctrl_amps = None; self.initial_ctrl_scaling = 1.0; self.initial_ctrl_offset = 0.0; self.drift_dyn_gen = None; self.ctrl_dyn_gen = None; self._tau = None; self._evo_time = None; self._num_ctrls = None; self._num_tslots = None; # attributes used for processing evolution; self.memory_optimization = 0; self.oper_dtype = None; self.cache_phased_dyn_gen = None; self.cache_prop_grad = None; self.cache_dyn_gen_eigenvectors_adj = None; self.sparse_eigen_decomp = None; self.dyn_dims = None; self.dyn_shape = None; self.sys_dims = None; self.sys_shape = None; self.time_depend_drift = False; self.time_depend_ctrl_dyn_gen = False; # These internal attributes will be of the internal operator data type; # used to compute the evolution; # Note this maybe ndarray, Qobj or some o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:13839,config,config,13839,docs/4.2/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html,2,['config'],['config']
Modifiability,"tzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters:; options : qutip.solver.Options; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes:; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:26452,config,config,26452,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['config'],['config']
Modifiability,"uTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Parallel computation. Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; >>> def func1(x): return x, x**2, x**3. >>> a, b, c = parfor(func1, range(10)). >>> print(a); [0 1 2 3 4 5 6 7 8 9]. >>> print(b); [ 0 1 4 9 16 25 36 49 64 81]. >>> print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; >>> result = parallel_map(func1, range(10)). >>> result_array = np.array(result). >>> print(result_array[:, 0]) # == a; [0 1 2 3 4 5 6 7 8 9]. >>> print(result_array[:, 1]) # == b; [ 0 1 4 9 16 25 36 49 64 81]. >>> print(result_array[:, 2]) # == c; [ 0 1 8 27 64 125 216 343 512 729]. Note that the return values are arranged differently for the qutip.parallel.parallel_map and the qutip.parallel.parfor functions, as illustrated below. In particular, the return value of qutip.parallel.parallel_map is not enforced to be NumPy arrays, which can avoid unnecessary copying if all that is needed is to iterate over the resulting list:; >>> result = parfor(func1, range(5)). >>> print(result); [ar",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-parfor.html:1606,variab,variables,1606,docs/4.7/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-parfor.html,2,['variab'],['variables']
Modifiability,"uTiP: Quantum Toolbox in Python. »; Module code »; qutip.correlation. Source code for qutip.correlation; __all__ = ['correlation_2op_1t', 'correlation_2op_2t', 'correlation_3op_1t',; 'correlation_3op_2t', 'coherence_function_g1',; 'coherence_function_g2', 'spectrum', 'spectrum_correlation_fft',; 'correlation_ss', 'correlation', 'correlation_4op_1t',; 'correlation_4op_2t', 'spectrum_ss', 'spectrum_pi']. from re import sub; from warnings import warn; import warnings; import types. import numpy as np; import scipy.fftpack. from qutip.eseries import esval, esspec; from qutip.essolve import ode2es; from qutip.expect import expect; from qutip.mesolve import mesolve; from qutip.mcsolve import mcsolve; from qutip.operators import qeye; from qutip.qobj import Qobj, isket, issuper; from qutip.qobjevo import QobjEvo; from qutip.rhs_generate import rhs_clear, _td_wrap_array_str; from qutip.cy.utilities import _cython_build_cleanup; from qutip.settings import debug; from qutip.solver import Options, config; from qutip.steadystate import steadystate; from qutip.states import ket2dm; from qutip.superoperator import liouvillian, spre, mat2vec; from qutip.tensor import tensor. if debug:; import inspect. # -----------------------------------------------------------------------------; # PUBLIC API; # -----------------------------------------------------------------------------. # low level correlation. [docs]def correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\tau)B(t)\right>`; along one time axis using the quantum regression theorem and the evolution; solver indicated by the `solver` parameter. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'No",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/correlation.html:1255,config,config,1255,docs/4.7/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html,1,['config'],['config']
Modifiability,"ual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update; (float) Mean average number of control amplitudes that are changed per update. calculate()[source]¶; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report. report()[source]¶; Print a report of the stats to the console. class Dump[source]¶; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class; Attributes. level. parent; (some control object (Dynamics or Optimizer)) aka the host. Object that generates the data that is dumped and is host to this dump object. dump_dir; (str) directory where files (if any) will be written out the path and be relative or absolute use ~/ to specify user home directory Note: files are only written when write_to_file is True of writeout is called explicitly Defaults to ~/.qtrl_dump. write_to_file; (bool) When set True data and summaries (as configured) will be written interactively to file during the processing Set during instantiation by the host based on its dump_to_file attrib. dump_file_ext; (str) Default file extension for any file names that are auto generated. fname_base; (str) First part of any auto generated file names. This is usually overridden in the subclass. dump_summary; (bool) If True a summary is recorded each time a new item is added to the the dump. Default is True. summary_sep; (str) delimiter for the summary file. default is a space. data_sep; (str) delimiter for the data files (arrays saved to file). default is a space. summary_file; (str) File path for summary file. Automatically generated. Can be set specifically. create_dump_dir()[source]¶; Checks dump directory exists, creates it if not. level¶. The level of data dumping that will occur. SUMMARY : A summary will be recorded; FULL : All possible dumping; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specif",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:110793,config,configured,110793,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['config'],['configured']
Modifiability,"ually) shared with the Dynamics instance. dump : :class:`qutip.control.dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent iteration.; Note this is only set if dummping is on; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/optimizer.html:8749,config,config,8749,docs/4.7/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/optimizer.html,1,['config'],['config']
Modifiability,"uantum Dynamics: Will It Blend?"", ; Phys. Rev. X 7, 041015 (2017). 336. Dhand et al., ""Quantum simulation via all-optically generated tensor network states"", ; arXiv:1710.06103. 335. Poonia et al., ""Quantum Biomimetic Modeling of Diamond NV- Center Spin Dynamics"", ; arXiv:1709.07632. 334. Nimmrichter et al., ""Quantum and classical dynamics of a three-mode absorption refrigerator"", ; Quantum 1, 37 (2017). 333. Qin et al., ""Exponentially-Enhanced Light-Matter Interaction, Cooperativities, and Steady-State Entanglement Using Parametric Amplification"", ; arXiv:1709.09555. 332. Ishibashi et al., ""Oscillation collapse in coupled quantum van der Pol oscillators"", ; Phys. Rev. E 96, 052210 (2017). 331. Elbin et al., ""Rényi Entropies from Random Quenches in Atomic Hubbard and Spin Models"", ; arXiv:1709.05060. 330. Li et al., ""Quantum microwave-optical interface with nitrogen-vacancy centers in diamond"", ; Phys. Rev. A 96, 032342 (2017). 329. Diguna et al., ""The coupling of single-photon exciton–biexciton quantum dot and cavity"", ; J. Nonlinear Optic. Phys. Mat. 1750029, (2017). 328. Lee et al., ""Effective formalism for open-quantum-system dynamics: Time-coarse-graining approach"", ; Phys. Rev. A 97, 012102 (2018). 327. de Moraes Neto et al., ""Steady many-body entanglements in dissipative systems"", ; Phys. Rev. A 96, 062313 (2017). 326. Zhang et al., ""Efficient numerical solution of excitation number conserving quantum systems"", ; AIP Advances 7, 085225 (2017). 325. Heuck et al., ""Temporally and frequency multiplexed single photon source using quantum feedback control for scalable photonic quantum technologies"", ; arXiv:1708.08875. 324. Kurian et al., ""Oxidative species-induced excitonic transport in tubulin aromatic networks: Potential implications for neurodegenerative disease"", ; J. Photochem. Photobiol. B: Biology (2017). 323. Hwang et al., ""Dissipative phase transition in the open quantum Rabi model"", ; Phys. Rev. A 97, 013825 (2018). 322. Higgins et al., ""Coherent Contro",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:5614,coupling,coupling,5614,users.html,https://qutip.org,https://qutip.org/users.html,1,['coupling'],['coupling']
Modifiability,"ub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/qutip-feedstock; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Generate a new sha256 code from the gztar for this version, e.g.; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version. Update the sha256 code.; Check that the recipe package version requirements at least match those in the setup.cfg.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process.; If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority; $ conda config --append channels conda-forge. This should mean that the prerequistes come from the default channel, but the qutip packages are found in conda-forge. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/release_distribution.html:13761,config,config,13761,docs/4.6/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html,1,['config'],['config']
Modifiability,"ubic_Spline):; Lobj.append(h_coeff.coeffs); Lcoeff.append(h_coeff). # the total number of Hamiltonian terms; n_L_terms = len(Ldata). # Check which components should use OPENMP; omp_components = None; if qset.has_openmp:; if opt.use_openmp:; omp_components = openmp_components(Lptrs). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k). for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; if oper_evo:; initial_vector = psi0.full().ravel('F'); r = scipy.integrate.ode(_td_ode_rhs_oper); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/sesolve.html:14782,config,config,14782,docs/4.3/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability,"uch] complete. admin lead; Neill. main dev; Tarun Raheja. An overhaul of the HEOM solver. C++ components used to speed up construction of; the hierarchy. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status mes",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/roadmap.html:11973,variab,variables,11973,docs/4.6/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html,1,['variab'],['variables']
Modifiability,"ue to; finite numerical precision, for ranks less than full-rank,; zero eigenvalues may become slightly negative, such that the; returned operator is not actually completely positive. Parameters. NintSquare root of the dimension of the superoperator to be returned. enforce_tpboolIf True, the trace-preserving condition of [BCSZ08] is enforced;; otherwise only complete positivity is enforced. rankint or NoneRank of the sampled superoperator. If None, a full-rank; superoperator is generated. dimslistDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[[N],[N]], [[N],[N]]]. Returns. rhoQobjA superoperator acting on vectorized dim × dim density operators,; sampled from the BCSZ distribution. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; The naming of qutip operators follows the convention in [R0be8dcf25d86-1] . R0be8dcf25d86-1; Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns. statesarrayarray of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns. opsarrayarray of three level operators. Superoperators and Liouvillians¶. operator_to_vector(op)[source]¶; Create a vector representation of a quantum operator given; the matrix representation. vecto",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:34775,config,configuration,34775,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['config'],['configuration']
Modifiability,"ue will have the solver; return the averaged entropy over trajectories in results.entropy. This; can be interpreted as a measure of entanglement. See Phys. Rev. Lett.; 93, 120408 (2004), Phys. Rev. A 86, 022310 (2012). Returns; -------; results : Result; Object storing all results from simulation. """"""; if ntraj is None:; ntraj = options.ntraj. if psi0.type != 'ket':; raise Exception(""Initial state must be a state vector.""); config.options = options; # set num_cpus to the value given in qutip.settings; # if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full(); else:; config.psi0 = psi0.full(); config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape; # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; raise Exception(""ntraj as list argument is not supported.""); else:; config.ntraj = ntraj; # ntraj_list = [ntraj]; # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. if not options.rhs_reuse:; config.soft_reset(); # no time dependence; config.tflag = 0; # check for collapse operators; if len(c_ops) > 0:; config.cflag = 1; else:; config.cflag = 0; # Configure data; _mc_data_config(H, psi0, [], c_ops, [], [], e_ops, options, config). # Load Monte Carlo class; mc = _MC_class(); # Set solver type; if (options.method == 'adams'):; mc.mf = 10; elif (options.method == 'bdf'):; mc.mf = 22; else:; if debug:; print('Unrecognized method for ode solver, using ""adams"".'); mc.mf = 10; # store ket and density matrix dims and shape for convenience; mc.psi0_dims = psi0.dims; mc.psi0_shape = psi0.shape; mc.dm_dims = (psi0 * psi0.dag()).dims; mc.dm_shape = (psi0 * psi0.dag()).shape; # use sparse density matrices during computation?; mc.sparse_dms = sparse_dms; # run in serial?; mc.serial_run = serial or (ntraj == 1); # are we doing a partial trace for returned s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:6269,config,config,6269,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,"ue):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.OptimDump):; self.dump = qtrldump.OptimDump(self, level=lvl); else:; self.dump.level = lvl; @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the current amplitudes; """"""; result = optimresult.OptimResult(); result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.time = self.dynamics.time; result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:13000,config,configuration,13000,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,3,['config'],['configuration']
Modifiability,"ue, Nres=None, deltamax=None, epsmax=None, w0=None, wq=None, eps=None, delta=None, g=None)[source]¶; Representation of the physical implementation of a quantum; program/algorithm on a dispersive cavity-QED system. dispersive_gate_correction(qc1, rwa=True)[source]¶; Method to resolve ISWAP and SQRTISWAP gates in a cQED system by adding; single qubit gates to get the correct output matrix. Parameters:; qc (Qobj) – The circular spin chain circuit to be resolved; rwa (Boolean) – Specify if RWA is used or not. Returns:qc – Returns QubitCircuit of resolved gates for the qubit circuit in the; desired basis. Return type:QubitCircuit. Optimal control¶. class Optimizer(config, dyn, params=None)[source]¶; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system. to be control optimised. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params¶; Dictionary – The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg¶; string – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params¶; Dictionary – options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg¶; bool – Set true to display a converge",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:59491,config,configuration,59491,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['config'],['configuration']
Modifiability,"uency (and coupling; operator). See :meth:`combine` for details. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""; def _check_cks_and_vks(self, ck_real, vk_real, ck_imag, vk_imag):; if len(ck_real) != len(vk_real) or len(ck_imag) != len(vk_imag):; raise ValueError(; ""The bath exponent lists ck_real and vk_real, and ck_imag and""; "" vk_imag must be the same length.""; ). def _check_coup_op(self, Q):; if not isinstance(Q, Qobj):; raise ValueError(""The coupling operator Q must be a Qobj.""). def __init__(; self, Q, ck_real, vk_real, ck_imag, vk_imag, combine=True,; tag=None,; ):; self._check_cks_and_vks(ck_real, vk_real, ck_imag, vk_imag); self._check_coup_op(Q). exponents = []; exponents.extend(; BathExponent(""R"", None, Q, ck, vk, tag=tag); for ck, vk in zip(ck_real, vk_real); ); exponents.extend(; BathExponent(""I"", None, Q, ck, vk, tag=tag); for ck, vk in zip(ck_imag, vk_imag); ). if combine:; exponents = self.combine(exponents). super().__init__(exponents). [docs] @classmethod; def combine(cls, exponents, rtol=1e-5, atol=1e-7):; """"""; Group bosonic exponents with the same frequency and return a; single exponent for each frequency present. Exponents with the same frequency are only combined if they share the; same coupling operator ``.Q``. Note that combined exponents take their tag from the first; exponent in the group being combined (i.e. the one that occurs first; in the given exponents list). Parameters; ----------; exponents : list of BathExponent; The list of exponents to combine. rtol : float, default 1e-5; The relative tolerance to use to when comparing frequencies and; coupling operators. atol : float, default 1e-7; The absolute tolerance to use to when comparing frequencies and; coupling operators. Returns; -------; list of BathExponent; The new reduced list of exponents.; """"""; groups = []; remaining = expo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html:6987,extend,extend,6987,docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,1,['extend'],['extend']
Modifiability,"ues. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). cut_freq¶; float – Bath spectral density cutoff frequency. renorm¶; bool – Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx¶; bool – Use boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters:; rho0 (Qobj) – Initial state (density matrix) of the system.; tlist (list) – Time over which system evolves. Returns:results – Object storing all results from the simulation. Return type:qutip.solver.Result. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. H_S¶; qutip.Qobj – System Hamiltonian (can also be a Liouvillian). L1¶; qutip.Qobj / list of qutip.Qobj – System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2¶; qutip.Qobj / list of qutip.Qobj ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:29799,config,configure,29799,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,2,['config'],['configure']
Modifiability,"uess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state =",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:26363,config,config,26363,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"ulses.append(; Pulse(sigmax(), [m+1], spline_kind=self.spline_kind)); self.pulse_dict[""sx"" + str(m)] = index; index += 1; for m in range(N):; self.pulses.append(; Pulse(sigmaz(), [m+1], spline_kind=self.spline_kind)); self.pulse_dict[""sz"" + str(m)] = index; index += 1; # coupling terms; a = tensor(; [destroy(self.num_levels)] +; [identity(2) for n in range(N)]); for n in range(N):; sm = tensor([identity(self.num_levels)] +; [destroy(2) if m == n else identity(2); for m in range(N)]); self.pulses.append(; Pulse(a.dag() * sm + a * sm.dag(),; list(range(N+1)), spline_kind=self.spline_kind)); self.pulse_dict[""g"" + str(n)] = index; index += 1. [docs] def set_up_params(; self, N, num_levels, deltamax,; epsmax, w0, wq, eps, delta, g):; """"""; Save the parameters in the attribute `params` and check the validity.; The keys of `params` including ""sx"", ""sz"", ""w0"", ""eps"", ""delta""; and ""g"", each; mapped to a list for parameters corresponding to each qubits.; For coupling strength ""g"", list element i is the interaction; between qubits i and i+1. Parameters; ----------; N: int; The number of qubits in the system. num_levels: int; The number of energy levels in the resonator. deltamax: list; The coefficients of sigma-x for each of the qubits in the system. epsmax: list; The coefficients of sigma-z for each of the qubits in the system. wo: int; The base frequency of the resonator. wq: list; The frequency of the qubits. eps: list; The epsilon for each of the qubits in the system. delta: list; The delta for each of the qubits in the system. g: list; The interaction strength for each of the qubit with the resonator. Notes; -----; All parameters will be multiplied by 2*pi for simplicity; """"""; sx_para = 2 * np.pi * self.to_array(deltamax, N); self._params[""sx""] = sx_para; sz_para = 2 * np.pi * self.to_array(epsmax, N); self._params[""sz""] = sz_para; w0 = 2 * np.pi * w0; self._params[""w0""] = w0; eps = 2 * np.pi * self.to_array(eps, N); self._params[""eps""] = eps; delta = 2 * np.pi * self.to_ar",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/device/cavityqed.html:6731,coupling,coupling,6731,docs/4.6/modules/qutip/qip/device/cavityqed.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/cavityqed.html,2,['coupling'],['coupling']
Modifiability,"ult in a recursive loop.; Fixed args=None -> args={} in correlation functions to be compatible with mesolve.; Fixed depreciation warnings in mcsolve.; Fixed neagtive only real parts in rand_ket.; Fixed a complicated list-cast-map-list antipattern in super operator reps. (Fixed by Stefan Krastanov); Fixed incorrect isherm for sigmam spin operator.; Fixed the dims when using final_state_output in mesolve and sesolve. Version 3.1.0 (January 1, 2015)¶. New Features¶. MAJOR FEATURE: New module for quantum control (qutip.control).; NAMESPACE CHANGE: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; New module for counting statistics.; Stochastic solvers now run trajectories in parallel.; New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; New logging module for debugging (qutip.logging).; New user-available API for parallelization (parallel_map).; New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); Faster Python based monte carlo solver (mcsolve).; Support for progress bars in propagator function.; Time-dependent Cython code now calls complex cmath functions.; Random numbers seeds can now be reused for successive calls to mcsolve.; The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; Improved handling of ODE integration errors in mesolve.; Improved correlation function module (for example, improved support for time-dependent problems).; Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady state solver.; mcsolve now supports Options(store_states=True); Fixed bug in hadamard gate function.; Fixed compatibility",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:34516,enhance,enhanced,34516,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['enhance'],['enhanced']
Modifiability,"ult: ""input"". """"""; if state_type == ""input"":; for i in targets:; self.input_states[i] = state; if state_type == ""output"":; for i in targets:; self.output_states[i] = state. [docs] def add_gate(self, gate, targets=None, controls=None, arg_value=None,; arg_label=None):; """"""; Adds a gate with specified parameters to the circuit. Parameters; ----------; gate: String or `Gate`; Gate name. If gate is an instance of `Gate`, parameters are; unpacked and added.; targets: List; Gate targets.; controls: List; Gate controls.; arg_value: Float; Argument value(phi).; arg_label: String; Label for gate representation.; """"""; if isinstance(gate, Gate):; name = gate.name; targets = gate.targets; controls = gate.controls; arg_value = gate.arg_value; arg_label = gate.arg_label. else:; name = gate; self.gates.append(Gate(name, targets=targets, controls=controls,; arg_value=arg_value, arg_label=arg_label)). [docs] def add_1q_gate(self, name, start=0, end=None, qubits=None,; arg_value=None, arg_label=None):; """"""; Adds a single qubit gate with specified parameters on a variable; number of qubits in the circuit. By default, it applies the given gate; to all the qubits in the register. Parameters; ----------; name : String; Gate name.; start : Integer; Starting location of qubits.; end : Integer; Last qubit for the gate.; qubits : List; Specific qubits for applying gates.; arg_value : Float; Argument value(phi).; arg_label : String; Label for gate representation.; """"""; if name not in [""RX"", ""RY"", ""RZ"", ""SNOT"", ""SQRTNOT"", ""PHASEGATE""]:; raise ValueError(""%s is not a single qubit gate"" % name). if qubits is not None:; for i in range(len(qubits)):; self.gates.append(Gate(name, targets=qubits[i], controls=None,; arg_value=arg_value,; arg_label=arg_label)). else:; if end is None:; end = self.N - 1; for i in range(start, end):; self.gates.append(Gate(name, targets=i, controls=None,; arg_value=arg_value,; arg_label=arg_label)). [docs] def add_circuit(self, qc, start=0):; """"""; Adds a block of a qubit",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/qip/circuit.html:7175,variab,variable,7175,docs/4.2/modules/qutip/qip/circuit.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qip/circuit.html,2,['variab'],['variable']
Modifiability,"um States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function; Example: first-order optical coherence function; Example: second-order optical coherence function. « An Overview of t... Plotting on the ... ». Two-time correlation functions¶; With the QuTiP time-evolution functions (for example qutip.mesolve and qutip.mcsolve), a state vector or density matrix can be evolved from an initial state at \(t_0\) to an arbitrary time \(t\), \(\rho(t)=V(t, t_0)\left\{\rho(t_0)\right\}\), where \(V(t, t_0)\) is the propagator defined by the equation of motion. The resulting density matrix can then be used to evaluate the expectation values of arbitrary combinations of same-time operators.; To calculate two-time correlation functions on the form \(\left<A(t+\tau)B(t)\right>\), we can use the quantum regression theorem (see, e.g., [Gar03]) to write. \[\begin{split}\left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho(t)\right\}\right]; = {\rm Tr}\left[A V(t+\tau, t)\left\{BV(t, 0)\left\{\rho(0)\right\}\right\}\right]\end{split}\]; We therefore first calculate \(\rho(t)=V(t, 0)\left\{\rho(0)\right\}\) using one of the QuTiP evolution solvers with \(\rho(0)\) as initial state, and then again use the same solver to calculate \(V(t+\tau, t)\left\{B\rho(t)\right\}\) using \(B\rho(t)\) as initial state.; Note that if the intial state is the steady state, then \(\rho(t)=V(t, 0)\left\{\rho_{\rm ss}\right\}=\rho_{\rm s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-correlation.html:1861,evolve,evolved,1861,docs/3.0.0/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-correlation.html,1,['evolve'],['evolved']
Modifiability,"um allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The ke",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:44381,variab,variable,44381,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,6,['variab'],['variable']
Modifiability,"um allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:33745,variab,variable,33745,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,6,['variab'],['variable']
Modifiability,"um control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qut",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:3714,variab,variables,3714,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,5,['variab'],['variables']
Modifiability,"um control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; impor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:3723,variab,variables,3723,docs/4.5/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html,1,['variab'],['variables']
Modifiability,"um):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:17836,config,config,17836,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"um; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:11740,config,config,11740,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"um; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; random_integers(1e8, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = random_integers(; 1e8, size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:12746,config,config,12746,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"um_optim_vars)); ; # def generate_guess_pulse(self); # if isinstance(self.guess_pulsegen, PulseGen):; # self.guess_pulse = self.guess_pulsegen.gen_pulse(); # return self.guess_pulse; ; [docs] def init_coeffs(self, num_coeffs=None):; """"""; Generate the initial ceofficent values.; ; Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs; ; if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)); ; if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs, ; self.num_basis_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulsegen.html:30372,variab,variables,30372,docs/4.1/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulsegen.html,5,['variab'],['variables']
Modifiability,"umentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function; Example: first-order optical coherence function; Example: second-order optical coherence function. « An Overview of t... Plotting on the ... ». Two-time correlation functions¶; With the QuTiP time-evolution functions (for example qutip.mesolve and qutip.mcsolve), a state vector or density matrix can be evolved from an initial state at \(t_0\) to an arbitrary time \(t\), \(\rho(t)=V(t, t_0)\left\{\rho(t_0)\right\}\), where \(V(t, t_0)\) is the propagator defined by the equation of motion. The resulting density matrix can then be used to evaluate the expectation values of arbitrary combinations of same-time operators.; To calculate two-time correlation functions on the form \(\left<A(t+\tau)B(t)\right>\), we can use the quantum regression theorem (see, e.g., [Gar03]) to write. \[\begin{split}\left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho(t)\right\}\right]; = {\rm Tr}\left[A V(t+\tau, t)\left\{BV(t, 0)\left\{\rho(0)\right\}\right\}\right]\end{split}\]; We therefore first calculate \(\rho(t)=V(t, 0)\left\{\rho(0)\right\}\) using one of the QuTiP evolution solvers with \(\rho(0)\) as initial state, and then again use the same solver to calculate \(V(t+\tau, t)\left\{B\rho(t)\right\}\) using \(B\rho(t)\) as initial state.; Note that if the intial state is the steady state, then \(\rho(t)=V(t, 0)\left\{\rho_{\rm ss}\right\}=\rho_{\rm s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-correlation.html:1962,evolve,evolved,1962,docs/3.1.0/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-correlation.html,1,['evolve'],['evolved']
Modifiability,"umpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a; ; OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg : bool;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:5424,config,configuration,5424,docs/4.5/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html,1,['config'],['configuration']
Modifiability,"unc_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:22007,variab,variable,22007,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,8,['variab'],['variable']
Modifiability,"unction for managing the calls to the single-trajactory solver. map_kwargs: dictionary; Optional keyword arguments to the map_func function. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation. .. note::. It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """""". if debug:; print(inspect.stack()[0][3]). if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # se",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:7884,config,config,7884,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"up seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, confi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:12930,config,config,12930,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"up_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters:; rho0 (Qobj) – Initial state (density matrix) of the system.; tlist (list) – Time over which system evolves. Returns:results – Object storing all results from the simulation. Return type:qutip.solver.Result. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. H_S¶; qutip.Qobj – System Hamiltonian (can also be a Liouvillian). L1¶; qutip.Qobj / list of qutip.Qobj – System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2¶; qutip.Qobj / list of qutip.Qobj – System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix¶; array – S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov¶; qutip.Qobj / list of qutip.Qobj – Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator¶; str {‘propagator’, ‘mesolve’} – Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallel¶; bool – Run integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. options¶; qutip.solver.Options – Generic solver options. outfieldcorr(rho0, blist, tlist, t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:30823,coupling,coupling,30823,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['coupling'],['coupling']
Modifiability,"ures; Improvements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Change Log. Change Log¶. Version 4.3.0 (July 14, 2018)¶. Improvements¶. MAJOR FEATURE: Added the Permutational Invariant Quantum Solver (PIQS) module (by Nathan Shammah and Shahnawaz Ahmed) which allows the simluation of large TLSs ensembles including collective and local Lindblad dissipation. Applications range from superradiance to spin squeezing.; MAJOR FEATURE: Added a photon scattering module (by Ben Bartlett) which can be used to study scattering in arbitrary driven systems coupled to some configuration of output waveguides.; Cubic_Spline functions as time-dependent arguments for the collapse operators in mesolve are now allowed.; Added a faster version of bloch_redfield_tensor, using components from the time-dependent version. About 3x+ faster for secular tensors, and 10x+ faster for non-secular tensors.; Computing Q.overlap() [inner product] is now ~30x faster.; Added projector method to Qobj class.; Added fast projector method, Q.proj().; Computing matrix elements, Q.matrix_element is now ~10x faster.; Computing expectation values for ket vectors using expect is now ~10x faster.; Q.tr() is now faster for small Hilbert space dimensions.; Unitary operator evolution added to sesolve; Use OPENMP for tidyup if installed. Bug Fixes¶. Fixed bug that stopped simdiag working for python 3.; Fixed semidefinite cvxpy Variable and Parameter.; Fixed iterative lu solve atol keyword issue.; Fixed unitary op evolution rhs matrix",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/changelog.html:1713,config,configuration,1713,docs/4.3/changelog.html,https://qutip.org,https://qutip.org/docs/4.3/changelog.html,1,['config'],['configuration']
Modifiability,"urn h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:17194,config,config,17194,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"urns; -------. R, kets: :class:`qutip.Qobj`, list of :class:`qutip.Qobj`. R is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. """""". # Sanity checks for input parameters; if not isinstance(H, Qobj):; raise TypeError(""H must be an instance of Qobj""). for a in a_ops:; if not isinstance(a, Qobj) or not a.isherm:; raise TypeError(""Operators in a_ops must be Hermitian Qobj.""). # default spectrum; if not spectra_cb:; spectra_cb = [lambda w: 1.0 for _ in a_ops]. # use the eigenbasis; evals, ekets = H.eigenstates(). N = len(evals); K = len(a_ops); A = np.zeros((K, N, N), dtype=complex) # TODO: use sparse here; W = np.zeros((N, N)). # pre-calculate matrix elements; for n in range(N):; for m in range(N):; W[m, n] = np.real(evals[m] - evals[n]). for k in range(K):; # A[k,n,m] = a_ops[k].matrix_element(ekets[n], ekets[m]); A[k, :, :] = a_ops[k].transform(ekets).full(). dw_min = abs(W[W.nonzero()]).min(). # unitary part; Heb = H.transform(ekets); if c_ops is not None:; R = liouvillian(Heb, c_ops=[c_op.transform(ekets) for c_op in c_ops]); else:; R = -1.0j * (spre(Heb) - spost(Heb)); R.data = R.data.tolil(); for I in range(N * N):; a, b = vec2mat_index(N, I); for J in range(N * N):; c, d = vec2mat_index(N, J). # unitary part: use spre and spost above, same as this:; # R.data[I,J] = -1j * W[a,b] * (a == c) * (b == d). if use_secular is False or abs(W[a, b] - W[c, d]) < dw_min / 10.0:. # dissipative part:; for k in range(K):; # for each operator coupling the system to the environment. R.data[I, J] += ((A[k, a, c] * A[k, d, b] / 2) *; (spectra_cb[k](W[c, a]) +; spectra_cb[k](W[d, b]))); s1 = s2 = 0; for n in range(N):; s1 += A[k, a, n] * A[k, n, c] * spectra_cb[k](W[c, n]); s2 += A[k, d, n] * A[k, n, b] * spectra_cb[k](W[d, n]). R.data[I, J] += - (b == d) * s1 / 2 - (a == c) * s2 / 2. R.data = R.data.tocsr(); return R, ekets. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/bloch_redfield.html:10464,coupling,coupling,10464,docs/3.1.0/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/bloch_redfield.html,1,['coupling'],['coupling']
Modifiability,"use it create a Bloch sphere with; ``b = Bloch(..., fig=fig)`` and then call ``b.show()`` in the same; cell, then the figure will be displayed twice. If you do create your; own figure, the simplest solution to this is to not call ``.show()``; in the cell you create the figure in.; """"""; self.render(); if self.run_from_ipython():; display(self.fig); else:; self.fig.show(). [docs] def save(self, name=None, format='png', dirc=None, dpin=None):; """"""Saves Bloch sphere to file of type ``format`` in directory ``dirc``. Parameters; ----------. name : str; Name of saved image. Must include path and format as well.; i.e. '/Users/Paul/Desktop/bloch.png'; This overrides the 'format' and 'dirc' arguments.; format : str; Format of output image.; dirc : str; Directory for output images. Defaults to current working directory.; dpin : int; Resolution in dots per inch. Returns; -------; File containing plot of Bloch sphere. """"""; self.render(); # Conditional variable for first argument to savefig; # that is set in subsequent if-elses; complete_path = """"; if dirc:; if not os.path.isdir(os.getcwd() + ""/"" + str(dirc)):; os.makedirs(os.getcwd() + ""/"" + str(dirc)); if name is None:; if dirc:; complete_path = os.getcwd() + ""/"" + str(dirc) + '/bloch_' \; + str(self.savenum) + '.' + format; else:; complete_path = os.getcwd() + '/bloch_' + \; str(self.savenum) + '.' + format; else:; complete_path = name. if dpin:; self.fig.savefig(complete_path, dpi=dpin); else:; self.fig.savefig(complete_path); self.savenum += 1; if self.fig:; plt.close(self.fig). def _hide_tick_lines_and_labels(axis):; '''; Set visible property of ticklines and ticklabels of an axis to False; '''; for a in axis.get_ticklines() + axis.get_ticklabels():; a.set_visible(False). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/bloch.html:23229,variab,variable,23229,docs/4.6/modules/qutip/bloch.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch.html,1,['variab'],['variable']
Modifiability,"use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; if oper_evo:; initial_vector = psi0.full().ravel('F'); r = scipy.integrate.ode(_td_ode_rhs_oper); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). exec(code, locals(), args). # Remove RHS cython file if necessary; if not opt.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # TODO cythonize this?; def _td_ode_rhs_oper(t, y, arglist):; N = int(np.sqrt(len(y))); out = np.zeros(N, dtype=complex); y2 = np.zeros(len(y), dtype=complex); for i in range(N):; out = cy_td_ode_rhs(t, y[i*N:(i+1)*N], *arglist); y2[i*N:(i+1)*N] = out; return y2. # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent Hamiltonians; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; Note: Deprecated method; """""". if debug:; print(inspect.stack()[0][3]). if psi0.isket:; pass; elif psi0.isunitary:; raise TypeError(""The unitary operator evolution is not supported""; "" in the list td method.""); else:; raise TypeError(""The u",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/sesolve.html:15907,config,config,15907,docs/4.3/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability,"ust be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; norm, dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unita",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html:14985,config,config,14985,docs/3.1.0/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability,"ust be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary qu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/sesolve.html:15242,config,config,15242,docs/4.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html,4,['config'],['config']
Modifiability,"ut.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TIME TLIST[k]; while ODE.t < tlist[k]:; t_prev = ODE.t; y_prev = ODE.y; norm2_prev = dznrm2(ODE._y) ** 2; # integrate up to tlist[k], one step at a time.; ODE.integrate(tlist[k], step=1); if not ODE.successful():; raise Exception(""ZVODE failed!""); norm2_psi = dznrm2(ODE._y) ** 2; if norm2_psi <= rand_vals[0]:; # collapse has occured:; # find collap",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:23897,config,config,23897,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"ut:; Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. or equivalently using the list format:; print(tensor([basis(2, 0), basis(2, 0)])). Output:; Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the qutip.tensor.tensor function, as illustrated in the following example:; print(tensor((basis(2, 0) + basis(2, 1)).unit(), (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0))). Output:; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state.; To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the qutip.tensor.tensor function. For example, to form the operator that represents the simultaneous action of the \(\sigma_x\) operator on two qubits:; print(tensor(sigmax(), sigmax())). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; print(tensor(sigmaz(), identity(2))). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-tensor.html:3277,extend,extended,3277,docs/4.7/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-tensor.html,1,['extend'],['extended']
Modifiability,"ut:; Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. or equivalently using the list format:; print(tensor([basis(2, 0), basis(2, 0)])). Output:; Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the qutip.tensor.tensor function, as illustrated in the following example:; print(tensor((basis(2, 0) + basis(2, 1)).unit(), (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0))). Output:; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state.; To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the qutip.tensor.tensor function. For example, to form the operator that represents the simultaneous action of the \(\sigma_x\) operator on two qubits:; print(tensor(sigmax(), sigmax())). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act only on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; print(tensor(sigmaz(), identity(2))). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-tensor.html:3217,extend,extended,3217,docs/4.6/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-tensor.html,1,['extend'],['extended']
Modifiability,"utput of files. gen_stats : boolean. if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:Returns instance of OptimResult, which has attributes giving the. reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=-inf, amp_ubound=inf, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=10000000.0, dyn_type='GEN_MAT', prop_type='DEF', fid_type='DEF', phase_option=None, fid_err_scale_factor=None, amp_update_mode='ALL', init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0, log_level=0, gen_stats=False)[source]¶; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optimize_pulse; if more detailed configuration is required before running the; optmisation algorthim, or the algorithm will be run many times,; for instances when trying to finding global the optimum or; minimum time optimisation. Parameters:drift : Qobj. the underlying dynamics generator of the system. ctrls : List of Qobj. a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics. initial : Qobj. starting point for the evolution.; Typically the identity matrix. target : Qobj. target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None. number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None. total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None. durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:142591,config,configuration,142591,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['config'],['configuration']
Modifiability,"uture.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface (as in the notebook examples) then skip to the section on ‘Using the pulseoptim functions’.; ![qtrl-code_obj_model](./images/qtrl-code_object_model.png “Qtrl code object model”). The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file.; Optimizer; This acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm.; Dynamics; This is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators.; PulseGen; There are many subclasses that of pulse generators that generate different types of puls",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-control.html:15095,config,configuration,15095,docs/4.0.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html,2,['config'],['configuration']
Modifiability,"vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:26490,config,config,26490,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table()¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:version_table: string :. Return an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. parfor(func, *args, **kwargs)¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Parameters:func : function_type. A function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved: :; num_cpus : int. Number of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns:result : list. A list with length equal to number of input parameters; containing the output from func. about()¶; About box for qutip. Gives version numbers for; QuTiP, NumPy, SciPy, Cython, and MatPlotLib. simdiag(ops, evals=True)¶; Simulateous diagonalization of communting Hermitian matrices.. Parameters:ops : list/array. list or array of qobjs representing commuting Hermitian; operators. Returns:eigs : tuple. Tuple of arrays representing eigvecs and eigvals of quantum objects; corresponding to simultaneous eigenvectors and eigenvalues for each; operator. Back to top. © Copyright 2011 and later, P.D. Nation, J",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:110063,variab,variables,110063,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,2,['variab'],['variables']
Modifiability,"values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, H_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:37612,config,config,37612,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(self, H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset(self)[source]¶; Reset any attributes to default values. run(self, rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coup",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:33096,config,configure,33096,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,4,['config'],['configure']
Modifiability,"values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); el",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:22564,config,config,22564,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"values]. Parameters. taska Python functionThe function that is to be called for each value in task_vec. valuesarray / listThe list or array of values for which the task function is to be; evaluated. task_argslist / dictionaryThe optional additional argument to the task function. task_kwargslist / dictionaryThe optional additional keyword argument to the task function. progress_barProgressBarProgress bar class instance for showing progress. Returns. resultlistThe result list contains the value of; task(value, *task_args, **task_kwargs) for; each value in values. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1, we recommend to use qutip.parallel_map; instead of this function. Parameters. funcfunction_typeA function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:; num_cpusintNumber of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns. resultlistA list with length equal to number of input parameters; containing the output from func. serial_map(task, values, task_args=(), task_kwargs={}, **kwargs)[source]¶; Serial mapping function with the same call signature as parallel_map, for; easy switching between serial and parallel execution. This; is functionally equivalent to:; result = [task(value, *task_args, **task_kwargs) for value in values]. This function work as a drop-in replacement of qutip.parallel_map. Parameters. tas",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:250355,variab,variables,250355,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['variab'],['variables']
Modifiability,"variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. Uqutip.qobjThe propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. optionsqutip.solver.Optionsoptions for the ODE solver. For the propagator U. Returns. outputlist of kets, list of quasi energiesTwo lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None, options=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tfloatThe time at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. optionsqutip.solver.Optionsoptions for the ODE solver. For the propagator. Returns. outputlist of ketsThe Floquet modes as kets at time \(t\). floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters. f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. tfloatThe time for which to evaluate the Floquet modes. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputnested listA list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None, options=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:102907,variab,variables,102907,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['variab'],['variables']
Modifiability,"ve import sesolve; from qutip.rhs_generate import rhs_clear; from qutip.steadystate import steadystate; from qutip.states import ket2dm; from qutip.states import projection; from qutip.solver import Options; from qutip.propagator import propagator; from qutip.solver import Result, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.expect import expect; from qutip.utilities import n_thermal. [docs]def floquet_modes(H, T, args=None, sort=False, U=None):; """"""; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T. Returns a list of :class:`qutip.qobj` instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter `sort`; decides if the output is to be sorted in increasing quasienergies or not. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. U : :class:`qutip.qobj`; The propagator for the time-dependent Hamiltonian with period `T`.; If U is `None` (default), it will be calculated from the Hamiltonian; `H` using :func:`qutip.propagator.propagator`. Returns; -------. output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. """""". if U is None:; # get the unitary propagator; U = propagator(H, T, [], args). # find the eigenstates for the propagator; evals, evecs = la.eig(U.full()). eargs = angle(evals). # make sure that the phase is in the interval [-pi, pi], so that; # the quasi energy is in the interval [-pi/T, pi/T] where T is the; # period of the driving. eargs += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/floquet.html:3773,variab,variables,3773,docs/4.4/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/floquet.html,3,['variab'],['variables']
Modifiability,"ve knowledge of the dynamical; maps \(E(t_k)\).; tensors (array_like) – optional list of precomputed tensors \(T_k\); kwargs (dictionary) – Optional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns:output – An instance of the class qutip.solver.Result. Return type:qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dyna",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:144154,variab,variables,144154,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['variab'],['variables']
Modifiability,"ve() method and generate a series of images to convert into an animation. However, as of Matplotlib version 1.1, creating animations is built-in. We will demonstrate both methods by looking at the decay of a qubit on the bloch sphere. Example: Qubit Decay¶; The code for calculating the expectation values for the Pauli spin operators of a qubit decay is given below. This code is common to both animation examples.; from qutip import *; from scipy import *; def qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist):; # operators and the hamiltonian; sx = sigmax(); sy = sigmay(); sz = sigmaz(); sm = sigmam(); H = w * (cos(theta) * sz + sin(theta) * sx); # collapse operators; c_op_list = []; n_th = 0.5 # temperature; rate = gamma1 * (n_th + 1); if rate > 0.0: c_op_list.append(sqrt(rate) * sm); rate = gamma1 * n_th; if rate > 0.0: c_op_list.append(sqrt(rate) * sm.dag()); rate = gamma2; if rate > 0.0: c_op_list.append(sqrt(rate) * sz). # evolve and calculate expectation values; output = mesolve(H, psi0, tlist, c_op_list, [sx, sy, sz]); return output.expect[0], output.expect[1], output.expect[2]. ## calculate the dynamics; w = 1.0 * 2 * pi # qubit angular frequency; theta = 0.2 * pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a* basis(2,0) + (1-a)*basis(2,1))/(sqrt(a**2 + (1-a)**2)); tlist = linspace(0,4,250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; import numpy as np; b = Bloch(); b.vector_color = ['r']; b.view = [-40,30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp') #saving images to temp directory in current working directory. Generating an animation using ffmpeg (",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-bloch.html:14664,evolve,evolve,14664,docs/4.4/guide/guide-bloch.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-bloch.html,1,['evolve'],['evolve']
Modifiability,"ve_serial(self, args):. if debug:; print(inspect.stack()[0][3] + "":"" + str(os.getpid())). # run ntraj trajectories for one process via fortran; # get args; queue, ntraj, instanceno, rngseed = args; # initialize the problem in fortran; _init_tlist(); _init_psi0(); if (self.ptrace_sel != []):; _init_ptrace_stuff(self.ptrace_sel); _init_hamilt(); if (config.c_num != 0):; _init_c_ops(); if (config.e_num != 0):; _init_e_ops(); # set options; qtf90.qutraj_run.n_c_ops = config.c_num; qtf90.qutraj_run.n_e_ops = config.e_num; qtf90.qutraj_run.ntraj = ntraj; qtf90.qutraj_run.unravel_type = self.unravel_type; qtf90.qutraj_run.average_states = config.options.average_states; qtf90.qutraj_run.average_expect = config.options.average_expect; qtf90.qutraj_run.init_result(config.psi0_shape[0],; config.options.atol,; config.options.rtol, mf=self.mf,; norm_steps=config.norm_steps,; norm_tol=config.norm_tol); # set optional arguments; qtf90.qutraj_run.order = config.options.order; qtf90.qutraj_run.nsteps = config.options.nsteps; qtf90.qutraj_run.first_step = config.options.first_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_sparse = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run; show_progress = 1 if debug else 0; qtf90.qutraj_run.evolve(instanceno, rngseed, show_progress). # construct Result instance; sol = Result(); sol.ntraj = ntraj; # sol.col_times = qtf90.qutraj_run.col_times; # sol.col_which = qtf90.qutraj_run.col_which-1; sol.col_times, sol.col_which = self.get_collapses(ntraj); if (config.e_num == 0):; sol.states = self.get_states(len(config.tlist), ntraj); else:; sol.expect = self.get_expect(len(config.tlist), ntraj); if (self.calc_entropy):; sol.entrop",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:12275,config,config,12275,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,"ver. Returns:output: :class:`qutip.solver` :. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors or density matrices corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops, e_ops, args={}, options=None, progress_bar=<qutip.ui.progressbar.BaseProgressBar object at 0x2ac6866d3c10>)¶; Master equation evolution of a density matrix for a given Hamiltonian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H) and an [optional] set of collapse operators; (c_op_list), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; Time-dependent operators; For problems with time-dependent problems H and c_ops can be callback; functions that takes two arguments, time and args, and returns the; Hamiltonian or Liouvillian for the system at that point in time; (callback format).; Alternatively, H and c_ops can be a specified in a nested-list format; where each element in the list is a list of length 2, containing an; operator (qutip.qobj) at the first element and where the; second element is either a string (list string format), a callback; function (list callback format) that evaluates to the time-dependent; coefficient for the corresponding operator, or a numpy ar",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:35609,evolve,evolved,35609,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,1,['evolve'],['evolved']
Modifiability,"ver. Returns:output: :class:`qutip.solver` :. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors or density matrices corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops, e_ops, args={}, options=None, progress_bar=<qutip.ui.progressbar.BaseProgressBar object at 0x2b11f65d3b10>)¶; Master equation evolution of a density matrix for a given Hamiltonian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H) and an [optional] set of collapse operators; (c_op_list), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; Time-dependent operators; For problems with time-dependent problems H and c_ops can be callback; functions that takes two arguments, time and args, and returns the; Hamiltonian or Liouvillian for the system at that point in time; (callback format).; Alternatively, H and c_ops can be a specified in a nested-list format; where each element in the list is a list of length 2, containing an; operator (qutip.qobj) at the first element and where the; second element is either a string (list string format), a callback; function (list callback format) that evaluates to the time-dependent; coefficient for the corresponding operator, or a numpy ar",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/apidoc/functions.html:35671,evolve,evolved,35671,docs/3.0.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/functions.html,1,['evolve'],['evolved']
Modifiability,"ver=""pi"", use_pinv=use_pinv). # -----------------------------------------------------------------------------; # PRIVATE SOLVER METHODS; # -----------------------------------------------------------------------------. # master 2t correlation solver. def _correlation_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args={}, options=Options()):; """"""; Internal function for calling solvers in order to calculate the; three-operator two-time correlation function:; <A(t)B(t+tau)C(t)>; """""". # Note: the current form of the correlator is sufficient for all possible; # two-time correlations (incuding those with 2ops vs 3). Ex: to compute a; # correlation of the form <A(t+tau)B(t)>: a_op = identity, b_op = A,; # and c_op = B. if debug:; print(inspect.stack()[0][3]). if min(tlist) != 0:; raise TypeError(""tlist must be positive and contain the element 0.""); if min(taulist) != 0:; raise TypeError(""taulist must be positive and contain the element 0.""). if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(); H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). if solver == ""me"":; return _correlation_me_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op,; args=args, options=options); elif solver == ""mc"":; return _correlation_mc_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op,; args=args, options=options); elif solver == ""es"":; return _correlation_es_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use me, mc, or es)."" % solver). # master equation solvers. def _correlation_me_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a master equation solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/correlation.html:30746,config,config,30746,docs/4.2/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/correlation.html,8,['config'],['config']
Modifiability,"ver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.superoperator import liouvillian; from qutip.interpolate import Cubic_Spline; from qutip.cy.spconvert import arr_coo2fast; from qutip.cy.br_codegen import BR_Codegen; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated ; spectrum functions, as well as possible Lindblad collapse operators.; ; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable.; ; *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]] ; ; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the ; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:; ; *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]; ; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html:3541,coupling,coupling,3541,docs/4.2/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html,1,['coupling'],['coupling']
Modifiability,"vers. def _correlation_me_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a master equation solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). rho_t = mesolve(H, rho0, tlist, c_ops, [],; args=args, options=options).states; corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); taulist = np.asarray(taulist); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). for t_idx, rho in enumerate(rho_t):; corr_mat[t_idx, :] = mesolve(; H, c_op * rho * a_op, taulist + tlist[t_idx], c_ops,; [b_op], args=args, options=options; ).expect[0]. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # exponential series solvers. def _correlation_es_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using an exponential series solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). # contruct the Liouvillian; L = liouvillian(H, c_ops). corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex). # The user-facing eseries and ode2es are deprecated from QuTiP 4.6, pending; # removal in QuTiP 5.0, however they are being maintained for internal use; # in correlation, so should not raise warnings to the user not matter what; # their settings.; with warnings.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/correlation.html:30858,config,config,30858,docs/4.7/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html,1,['config'],['config']
Modifiability,"volve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.conj().transpose(),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.conj().transpose(). # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:23495,config,config,23495,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"w properly handle multiple time dependant functions (Thank taw181 for reporting).; Removed mutable default values in mesolve/sesolve (by Michael Goerz).; Fixed simdiag bug (Thank Croydon-Brixton for reporting).; Better support of constant QobjEvo (by Boxi Li).; Fixed potential cyclic import in the control module (by Alexander Pitchford). Version 4.4.0 (July 03, 2019)¶. Improvements¶. MAJOR FEATURE: Added methods and techniques to the stochastic solvers (by Eric Giguère) which allows to use a much broader set of solvers and much more efficiently.; MAJOR FEATURE: Optimization of the montecarlo solver (by Eric Giguère). Computation are faster in many cases. Collapse information available to time dependant information.; Added the QObjEvo class and methods (by Eric Giguère), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficients.; The coefficients can be made from interpolated array with variable timesteps and can obtain state information more easily. Time-dependant collapse operator can have multiple terms.; New wigner_transform and plot_wigner_sphere function. (by Nithin Ramu).; ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits.; QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by Boxi Li).; Added the quantum Hellinger distance to qutip.metrics (by Wojciech Rzadkowski).; Implemented possibility of choosing a random seed (by Marek Marekyggdrasil).; Added a code of conduct to Github. Bug Fixes¶. Fixed bug that made QuTiP incompatible with SciPy 1.3. Version 4.3.0 (July 14, 2018)¶. Improvements¶. MAJOR FEATURE: Added the Permutational Invariant Quantum Solver (PIQS) module (by Nathan Shammah and Shahnawaz Ahmed) which allows the simluation of large TLSs ensembles including collective and local Lindblad di",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/changelog.html:6074,variab,variable,6074,docs/4.5/changelog.html,https://qutip.org,https://qutip.org/docs/4.5/changelog.html,3,['variab'],['variable']
Modifiability,"w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(config, 'blas_opt_info'):; blas_info = config.blas_opt_info; else:; blas_info = {}; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas_info.keys() and ('-Wl,Accelerate' in blas_info['extra_link_args']):; blas = 'Accelerate'; else:; blas = 'Generic'; return blas. def available_cpu_count():; """"""; Get the number of cpus.; It tries to only get the number available to qutip.; """"""; import os; import multiprocessing; try:; import psutil; except ImportError:; psutil = None; num_cpu = 0. if 'QUTIP_NUM_PROCESSES' in os.environ:; # We consider QUTIP_NUM_PROCESSES=0 as unset.; num_cpu = int(os.environ['QUTIP_NUM_PROCESSES']",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/utilities.html:8651,config,config,8651,docs/4.6/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html,4,['config'],['config']
Modifiability,"wall_time = max_wall_time; optim.termination_conditions = tc. if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that parameters have been supplied to generate the; # timeslot durations; try:; evo_time / num_tslots; except:; raise errors.UsageError(; ""Either the timeslot durations should be supplied as an ""; ""array 'tau' or the number of timeslots 'num_tslots' ""; ""and the evolution time 'evo_time' must be given.""). dyn.num_tslots = num_tslots; dyn.evo_time = evo_time; else:; dyn.tau = tau. # this function is called, so that the num_ctrls attribute will be set; dyn.get_num_ctrls(). # Create a pulse generator of the type specified; p_gen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn); p_gen.scaling = pulse_scaling; p_gen.offset = pulse_offset; p_gen.lbound = amp_lbound; p_gen.ubound = amp_ubound. # If the pulse is a periodic type, then set the pulse to be one complete; # wave; if isinstance(p_gen, pulsegen.PulseGenPeriodic):; p_gen.num_waves = 1.0; optim.pulse_generator = p_gen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + p_gen.__class__.__name__). return optim. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:31400,config,config,31400,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['config'],['config']
Modifiability,"wave function using an ODE solver with time-dependent; Hamiltonian.; Note: Deprecated method; """""". if debug:; print(inspect.stack()[0][3]). if psi0.isket:; pass; elif psi0.isunitary:; raise TypeError(""The unitary operator evolution is not supported""; "" in the list td method.""); else:; raise TypeError(""The unitary solver requires psi0 to be""; "" a ket as initial state""; "" or a unitary as initial operator.""). #; # configure time-dependent terms and setup ODE solver; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if (not isinstance(H_func[0], (list, np.ndarray))) or \; (len(H_func[0]) <= 1):; raise TypeError('Time-dependent Hamiltonians must be a list with two '; + 'or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/sesolve.html:17591,config,config,17591,docs/4.3/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability,"waveguides. Parameters; ----------; evolver : :class: qutip.scattering.Evolver; Evolver-wrapped Hamiltonian describing the system.; c_ops : list; list of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; :math:`\\sigma = \\sqrt \\gamma \\cdot a`; taus_list : list-like; List of (list of emission times) for each waveguide. Returns; -------; omega : :class: qutip.Qobj; The temporal scattering operator with dimensionality equal to the; system state.; """"""; omega = 1. # Extract the full list of taus; taus = [(0.0, -1)] # temporal ""ground state"" for arbitrary waveguide; for i, tau_wg in enumerate(taus_list):; for tau in tau_wg:; taus.append((tau, i)); taus.sort(key = lambda tup: tup[0]) # sort taus by time. # Compute Prod Ueff(tq, tq-1); for i in range(1, len(taus)):; tq, q = taus[i]; tprev, _ = taus[i - 1]; omega = c_ops[q] * evolver.prop(tq, tprev) * omega. # Add the <0|Uff(TP, tm)|0> term; tmax = evolver.tlist[-1]; taumax, _ = taus[-1]; # if taus[-1] < tmax:; omega = evolver.prop(tmax, taumax) * omega. return omega. [docs]def temporal_basis_vector(waveguide_emission_indices, n_time_bins):; """"""; Generate a temporal basis vector for emissions at specified time bins into; specified waveguides. Parameters; ----------; waveguide_emission_indices : list or tuple; List of indices where photon emission occurs for each waveguide,; e.g. [[t1_wg1], [t1_wg2, t2_wg2], [], [t1_wg4, t2_wg4, t3_wg4]].; n_time_bins : int; Number of time bins; the range over which each index can vary. Returns; -------; temporal_basis_vector : :class: qutip.Qobj; A basis vector representing photon scattering at the specified indices.; If there are W waveguides, T times, and N photon emissions, then the; basis vector has dimensionality (W*T)^N.; """"""; # Cast waveguide_emission_indices to list for mutability; waveguide_emission_indices = [list(i) for i in waveguide_emission_indices]. # Calculate total number of waveguides; W = len(waveguide_emission_indices).",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/scattering.html:6657,evolve,evolver,6657,docs/4.3/modules/qutip/scattering.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/scattering.html,5,['evolve'],['evolver']
Modifiability,"we have knowledge of the dynamical; maps \(E(t_k)\). tensors : array_like; optional list of precomputed tensors \(T_k\). kwargs : dictionary; Optional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns:; output: :class:`qutip.solver.Result`; An instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dyna",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:157092,variab,variables,157092,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['variab'],['variables']
Modifiability,"will hold the eigen decomposition; used in calculating propagators and gradients; Note: used with PropCompDiag propagator calcs; """"""; shp = self.drift_dyn_gen.shape; n_ts = self.num_tslots; self.decomp_curr = [False for x in range(n_ts)]; self.prop_eigen = \; [np.empty(shp[0], dtype=complex) for x in range(n_ts)]; self.dyn_gen_eigenvectors = \; [np.empty(shp, dtype=complex) for x in range(n_ts)]; self.dyn_gen_factormatrix = \; [np.empty(shp, dtype=complex) for x in range(n_ts)]. def _check_test_out_files(self):; cfg = self.config; if cfg.any_test_files():; if not cfg.check_create_test_out_dir():; cfg.reset_test_out_files(); else:; if self.stats is None:; logger.warn(""Cannot output test files when stats""; "" attribute is not set.""); self.config.test_out_amps = False; self.config.test_out_prop = False; self.config.test_out_prop_grad = False; self.config.test_out_evo = False. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; self._check_test_out_files(). if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FideliyComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; # Note this call is made just to initialise the num_ctrls attrib; self.get_num_ctrls(). if init_tslots:; self.init_time_slots(); self._init_lists(); self.tslot_computer.init_comp(); self.fid_computer.init_comp(); self._ctrls_initialized = True; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:14947,config,configuration,14947,docs/3.1.0/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html,1,['config'],['configuration']
Modifiability,"written if they do. dumping¶. The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:62258,variab,variables,62258,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,4,['variab'],['variables']
Modifiability,"ws for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, …) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file.; Optimizer; This acts as a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-control.html:13840,extend,extended,13840,docs/4.3/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html,1,['extend'],['extended']
Modifiability,"ws for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, …) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrap",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-control.html:13838,extend,extended,13838,docs/4.4/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-control.html,3,['extend'],['extended']
Modifiability,"x=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dag",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:41234,coupling,coupling,41234,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,1,['coupling'],['coupling']
Modifiability,"xample, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; In [20]: N = 10 # number of basis states to consider. In [21]: a = destroy(N). In [22]: H = a.dag() * a. In [23]: psi0 = basis(N, 9) # initial state. In [24]: kappa = 0.2 # coupling to oscillator. In [25]: a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. In [26]: tlist = np.linspace(0, 10, 100). In [27]: out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). In [28]: actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). In [29]: plt.figure(); Out[29]: <Figure size 640x480 with 0 Axes>. In [30]: plt.plot(tlist, out.expect[0]); Out[30]: [<matplotlib.lines.Line2D at 0x1a251955c0>]. In [31]: plt.plot(tlist, actual_answer); Out[31]: [<matplotlib.lines.Line2D at 0x1a254cc860>]. In [32]: plt.show(). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form exp(1j*t)*a + exp(-1j*t)* a.dag(). In this example, the a_ops list would be:; In [33]: a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)'), gives the noise power spectrum, and time-dependence of each operator. Note that the noise spectrum must always come first in this second tuple. A full example is:; In [34]: N = 10. In [35]: w0 = 1.0 * 2 * np.pi. In [36]: g = 0.05 * w0. In [37]: kappa = 0.15. In [38]: times = np.linspace(0, 25, 1000). In [39]: a = destroy(N). In [40]",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-bloch-redfield.html:17669,coupling,coupling,17669,docs/4.5/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-bloch-redfield.html,1,['coupling'],['coupling']
Modifiability,"xecuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:36576,config,config,36576,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"xecution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact¶; boolean – indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶. Frechet method for calculating the propagator:; exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of mess",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:91192,config,configuration,91192,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['config'],['configuration']
Modifiability,"xp(-iH)\) where H is a randomly generated; Hermitian operator. Parameters. NintShape of output quantum operator. densityfloatDensity between [0,1] of output Unitary operator. dimslistDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns. operqobjNxN Unitary quantum operator. rand_unitary_haar(N=2, dims=None, seed=None)[source]¶; Returns a Haar random unitary matrix of dimension; dim, using the algorithm of [Mez07]. Parameters. NintDimension of the unitary to be returned. dimslist of lists of int, or NoneDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns. UQobjUnitary of dims [[dim], [dim]] drawn from the Haar; measure. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; The naming of qutip operators follows the convention in [1] . 1; Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns. statesarrayarray of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns. opsarrayarray of three level operators. Superoperators and Liouvillians¶. lindblad_dissipator(a, b=None, data_only=False, chi=None)[source]¶; Lindblad dissipator (generalized) for a single pair of collapse operators; (a, b), or",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:43267,config,configuration,43267,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['config'],['configuration']
Modifiability,"xp1.Q, ck, exp1.vk, tag=exp1.tag,; )); else:; # the group includes both type I and R exponents; ck_R = (; sum(exp.ck for exp in combine if exp.type == exp.types.R) +; sum(exp.ck for exp in combine if exp.type == exp.types.RI); ); ck_I = (; sum(exp.ck for exp in combine if exp.type == exp.types.I) +; sum(exp.ck2 for exp in combine if exp.type == exp.types.RI); ); new_exponents.append(BathExponent(; ""RI"", None, exp1.Q, ck_R, exp1.vk, ck2=ck_I,; tag=exp1.tag,; )). return new_exponents. [docs]class DrudeLorentzBath(BosonicBath):; """"""; A helper class for constructing a Drude-Lorentz bosonic bath from the; bath parameters (see parameters below). Parameters; ----------; Q : Qobj; Operator describing the coupling between system and bath. lam : float; Coupling strength. gamma : float; Bath spectral density cutoff frequency. T : float; Bath temperature. Nk : int; Number of exponential terms used to approximate the bath correlation; functions. combine : bool, default True; Whether to combine exponents with the same frequency (and coupling; operator). See :meth:`BosonicBath.combine` for details. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""; def __init__(; self, Q, lam, gamma, T, Nk, combine=True, tag=None,; ):; ck_real, vk_real, ck_imag, vk_imag = self._matsubara_params(; lam=lam,; gamma=gamma,; T=T,; Nk=Nk,; ). super().__init__(; Q, ck_real, vk_real, ck_imag, vk_imag, combine=combine, tag=tag,; ). self._dl_terminator = _DrudeLorentzTerminator(; Q=Q, lam=lam, gamma=gamma, T=T,; ). [docs] def terminator(self):; """"""; Return the Matsubara terminator for the bath and the calculated; approximation discrepancy. Returns; -------; delta: float. The approximation discrepancy. That is, the difference between the; true correlation function of the Drude-Lorentz bath and the sum of; the ``Nk`` exponential terms is approximately ``2 ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html:9609,coupling,coupling,9609,docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,1,['coupling'],['coupling']
Modifiability,"xpect[1], '--', lw=2); Out[31]: ; [<matplotlib.lines.Line2D at 0x1096d45d0>,; <matplotlib.lines.Line2D at 0x1096d47d0>]. In [32]: title('Monte Carlo time evolution'); Out[32]: <matplotlib.text.Text at 0x107db4790>. In [33]: xlabel('Time', fontsize=14); Out[33]: <matplotlib.text.Text at 0x1078fcd10>. In [34]: ylabel('Expectation values', fontsize=14); Out[34]: <matplotlib.text.Text at 0x107df7150>. In [35]: legend((""cavity photon number"", ""atom excitation probability"")); Out[35]: <matplotlib.legend.Legend at 0x107a31b90>. In [36]: show(). In addition to the initial state, one may reuse the Hamiltonian data when changing the number of trajectories ntraj or simulation times times. The reusing of Hamiltonian data is also supported for time-dependent Hamiltonians. See Solving Problems with Time-dependent Hamiltonians for further details. Fortran Based Monte Carlo Solver¶. Note; In order to use the Fortran Monte Carlo solver, you must have the blas development libraries, and installed QuTiP using the flag: --with-f90mc. In performing time-independent Monte Carlo simulations with QuTiP, systems with small Hilbert spaces suffer from poor performance as the ODE solver must exit the ODE solver at each time step and check for the state vector norm. To correct this, QuTiP now includes an optional Fortran based Monte Carlo solver that has enhanced performance for systems with small Hilbert space dimensionality. Using the Fortran based solver is extremely simple; one just needs to replace mcsolve with mcsolve_f90. For example, from our previous demonstration; In [37]: data1 = mcsolve_f90(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]). In using the Fortran solver, there are a few limitations that must be kept in mind. First, this solver only works for time-independent systems. Second, you can not pass a list of trajectories to ntraj. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-monte.html:16898,enhance,enhanced,16898,docs/3.1.0/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-monte.html,1,['enhance'],['enhanced']
Modifiability,"xpect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:20329,config,config,20329,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"xpect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:17921,config,config,17921,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"xperimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements¶; Core libraries. Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (Added by Kevin Fischer); The code for the inverse-power method for the steady state solver has been simplified.; Bloch-Redfield tensor creation is now up to an order of magnitude faster. (Added by Johannes Feist); Q.transform now works properly for arrays directly from sp_eigs (or eig).; Q.groundstate now checks for degeneracy.; Added sinm and cosm methods to the Qobj class.; Added charge and tunneling operators.; Time-dependent Cython code is now easier to read and debug. Control modules. The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been ‘private’.; Accessors to the properties that could be useful outside of the library have been added. These always return Qobj. If the internal operator data type is not Qobj, then there could be signicant overhead in the conversion, and so this should be avoided during pulse optimisation.; If custom sub-classes are developed that use Qobj properties and methods (e.g. partial trace), then it is very likely that it will be more efficient to set the internal data type to Qobj.; The internal operator data will be chosen automatically based on the size and sparsity of the dynamics generator. It can be forced by setting dynamics.oper_dtype = <type>; Note this can be done by passing dyn_params={'oper_dtype':<type>} in any of the pulseoptim functions.; Some other properties a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/changelog.html:4112,config,configuration,4112,docs/4.0.2/changelog.html,https://qutip.org,https://qutip.org/docs/4.0.2/changelog.html,8,['config'],['configuration']
Modifiability,"y output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:12383,config,config,12383,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"y setup (r). Calculate the; # required expectation values or invoke callback function at each time step.; #; def _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; state_norm_func=None, dims=None):; """"""; Internal function for solving ODEs.; """""". #; # prepare output array; #; n_tsteps = len(tlist); output = Result(); output.solver = ""sesolve""; output.times = tlist. if opt.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fallback on storing states; output.states = []; opt.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if state_norm_func:; data = r.y / state_norm_func(r.y); r.set_initial_value(data, r.t). if opt.store_states:; output.states.append(Qobj(r.y, dims=dims)). if expt_callback:; # use callback method; e_ops(t, Qobj(r.y, dims=psi0.dims)). for m in range(n_expt_op):; output.expect[m][t_idx] = cy_expect_psi(e_ops[m].data,; r.y, e_ops[m].isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if not opt.rhs_reuse and config.tdname is not None:; try:; os.remove(config.tdname + "".pyx""); except:; pass. if opt.store_final_state:; output.final_state = Qobj(r.y). return output. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html:19469,config,config,19469,docs/3.1.0/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html,2,['config'],['config']
Modifiability,"y states"", ; arXiv:1608.05074. 208. Zhu et al., ""Implementing phase-covariant cloning in circuit quantum electrodynamics"", ; Annals of Physics 373, 512 (2016). 207. Fischer et al., ""Dynamical modeling of pulsed two-photon interference"", ; New J. Phys. 18, 113053 (2016).; Notebook1; Notebook2. 206. Seifoory et al., ""The properties of squeezed optical states created in lossy cavities"", ; arXiv:1608.05005. 205. Qin et al., ""Heralded quantum controlled-phase gates with dissipative dynamics in macroscopically distant resonators"", ; Phys. Rev. A 96, 012315 (2017). 204. Cruzeiro et al., ""Interactively Applying the Variational Method to the Dihydrogen Molecule: Exploring Bonding and Antibonding"", ; Journal of Chemical Education (2016). 203. Pleinert et al., ""Quantum signatures of collective behavior of a coherently driven two atom system coupled to a single-mode of the electromagnetic field"", ; arXiv:1608.00137. 202. Wang et al., ""Multiple-output microwave single-photon source using superconducting circuits with longitudinal and transverse couplings"", ; Phys. Rev. A 94, 053858 (2016). 201. Marshall et al., ""Continuous-variable quantum computing on encrypted data"", ; Nat. Comm. 7, 13795 (2016). 200. Dajka et al., ""Leggett–Garg inequalities for a quantum top affected by classical noise"", ; J. Quantum Inf. Process. (2016). 199. Rouxinol et al., ""Measurements of nanoresonator-qubit interactions in a hybrid quantum electromechanical system"", ; Nanotechnology 27, 364003 (2016). 198. Hocker et al., ""PEET: a Matlab tool for estimating physical gate errors in quantum information processing systems"", ; Quantum Information Processing (2016). 197. Daskin, ""Quantum eigenvalue estimation for irreducible non-negative matrices"", ; Int. J. Quantum Inform. 14, 1650005 (2016). 196. Dlaska et al., ""Robust quantum state transfer via topologically protected edge channels in dipolar arrays"", ; Quantum Sci. Technol. 2, 015001 (2017). 195. Juliusson et al., ""Manipulating Fock states of a harmonic os",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:22451,coupling,couplings,22451,users.html,https://qutip.org,https://qutip.org/users.html,1,['coupling'],['couplings']
Modifiability,"y values, averaged; sol.entropy += np.array(sols[j].entropy); else:; # collect entropy values, all trajectories; sol.entropy = np.vstack((sol.entropy,; np.array(sols[j].entropy))); if (config.options.average_states or config.options.average_expect):; if (config.e_num == 0):; sol.states = sol.states / len(sols); else:; sol.expect = list(sol.expect / len(sols)); inds = np.where(config.e_ops_isherm)[0]; for jj in inds:; sol.expect[jj] = np.real(sol.expect[jj]); if (hasattr(sols[0], 'entropy')):; sol.entropy = sol.entropy / len(sols). # convert sol.expect array to list and fix dtypes of arrays; if (not config.options.average_expect) and config.e_num != 0:; temp = [list(sol.expect[ii]) for ii in range(ntraj)]; for ii in range(ntraj):; for jj in np.where(config.e_ops_isherm)[0]:; temp[ii][jj] = np.real(temp[ii][jj]); sol.expect = temp; # convert to list/array to be consistent with qutip mcsolve; sol.states = list(sol.states); return sol. #; # Functions to initialize the problem in fortran; #; def _init_tlist():; Of = _realarray_to_fortran(config.tlist); qtf90.qutraj_run.init_tlist(Of, np.size(Of)). def _init_psi0():; # Of = _qobj_to_fortranfull(config.psi0); Of = _complexarray_to_fortran(config.psi0); qtf90.qutraj_run.init_psi0(Of, np.size(Of)). def _init_ptrace_stuff(sel):; psi0 = Qobj(config.psi0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90.qutraj_run.init_hamiltonian(; _complexarray_to_fortran(config.h_data),; config.h_ind + 1, config.h_ptr + 1, d, d). def _init_c_ops():; d = np.size(config.psi0); n = config.c_num; first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:18684,config,config,18684,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,"y([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, H_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:36969,config,config,36969,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"y([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:35967,config,config,35967,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"y(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, H_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(H",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:37529,config,config,37529,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"y-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Bosonic Environments. Bosonic Environments¶; In this section we consider a simple two-level system coupled to a; Drude-Lorentz bosonic bath. The system Hamiltonian, \(H_{sys}\), and the bath; spectral density, \(J_D\), are. \[ \begin{align}\begin{aligned}H_{sys} &= \frac{\epsilon \sigma_z}{2} + \frac{\Delta \sigma_x}{2}\\J_D &= \frac{2\lambda \gamma \omega}{(\gamma^2 + \omega^2)},\end{aligned}\end{align} \]; We will demonstrate how to describe the bath using two different expansions; of the spectral density correlation function (Matsubara’s expansion and; a Padé expansion), how to evolve the system in time, and how to calculate; the steady state.; First we will do this in the simplest way, using the built-in implementations of; the two bath expansions, DrudeLorentzBath and; DrudeLorentzPadeBath. We will do this both with a; truncated expansion and show how to include an approximation to all of the; remaining terms in the bath expansion.; Afterwards, we will show how to calculate the bath expansion coefficients and to; use those coefficients to construct your own bath description so that you can; implement your own bosonic baths.; Finally, we will demonstrate how to simulate a system coupled to multiple; independent baths, as occurs, for example, in certain photosynthesis processes.; A notebook containing a complete example similar to this one implemented in; BoFiN can be found in; example notebook 1a. Describing the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/heom/bosonic.html:1754,evolve,evolve,1754,docs/4.7/guide/heom/bosonic.html,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html,1,['evolve'],['evolve']
Modifiability,"y=False. Aborting.'); entropy = np.array([0.] * nstep); entropy[:] = qtf90.qutraj_run.reduced_state_entropy[:]; return entropy. def finalize():; # not in use... if debug:; print(inspect.stack()[0][3]). qtf90.qutraj_run.finalize_work(); qtf90.qutraj_run.finalize_sol(). def _gather(sols):; # gather list of Result objects, sols, into one.; sol = Result(); # sol = sols[0]; ntraj = sum([a.ntraj for a in sols]); sol.col_times = np.zeros((ntraj), dtype=np.ndarray); sol.col_which = np.zeros((ntraj), dtype=np.ndarray); sol.col_times[0:sols[0].ntraj] = sols[0].col_times; sol.col_which[0:sols[0].ntraj] = sols[0].col_which; sol.states = np.array(sols[0].states, dtype=object); sol.expect = np.array(sols[0].expect); if (hasattr(sols[0], 'entropy')):; sol.entropy = np.array(sols[0].entropy); sofar = 0; for j in range(1, len(sols)):; sofar = sofar + sols[j - 1].ntraj; sol.col_times[sofar:sofar + sols[j].ntraj] = (; sols[j].col_times); sol.col_which[sofar:sofar + sols[j].ntraj] = (; sols[j].col_which); if (config.e_num == 0):; if (config.options.average_states):; # collect states, averaged over trajectories; sol.states += np.array(sols[j].states); else:; # collect states, all trajectories; sol.states = np.vstack((sol.states,; np.array(sols[j].states))); else:; if (config.options.average_expect):; # collect expectation values, averaged; for i in range(config.e_num):; sol.expect[i] += np.array(sols[j].expect[i]); else:; # collect expectation values, all trajectories; sol.expect = np.vstack((sol.expect,; np.array(sols[j].expect))); if (hasattr(sols[j], 'entropy')):; if (config.options.average_states or; config.options.average_expect):; # collect entropy values, averaged; sol.entropy += np.array(sols[j].entropy); else:; # collect entropy values, all trajectories; sol.entropy = np.vstack((sol.entropy,; np.array(sols[j].entropy))); if (config.options.average_states or config.options.average_expect):; if (config.e_num == 0):; sol.states = sol.states / len(sols); else:; sol.expect = list(sol",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:16980,config,config,16980,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,"y_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, H_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:37831,config,config,37831,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,2,['config'],['config']
Modifiability,"y_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:22082,config,config,22082,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"y_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:18269,config,config,18269,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"y_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:20767,config,config,20767,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"ynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation. - NONE : No processing data dumped (Default); - SUMMARY : A summary at each it",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:11485,config,config,11485,docs/4.6/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html,2,['config'],['config']
Modifiability,"ynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation; - NONE : No processing data dumped (Default); - SUMMARY : A summary at each it",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:10532,config,config,10532,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,6,['config'],['config']
Modifiability,"ynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.mesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver. Alternatively, we can use the function qutip.essolve, which uses the exponential-series technique to calculate the time evolution of a system. The qutip.mesolve and qutip.essolve functions take the same arguments and it is therefore easy switch between the two solvers.; For example, the time evolution of a quantum spin-1/2 system with tunneling rate 0.1 that initially is in the up state is calculated, and the expectation values of the \(\sigma_z\) operator evaluated, with the following code:; >>> H = 2 * pi * 0.1 * sigmax(); >>> psi0 = basis(2, 0); >>> times = linspace(0.0, 10.0, 20.0); >>> result = mesolve(H, psi0, times, [], [sigmaz()]); >>> result; Result object with mesolve data.; ---------------------------------; expect = True; num_expect = 1, num_collapse = 0; >>> result.expect[0]; array([ 1.00000000+0.j, 0.78914229+0.j, 0.24548596+0.j, -0.40169696+0.j,; -0.87947669+0.j, -0.98636356+0.j",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html:3629,evolve,evolves,3629,docs/3.0.0/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html,2,['evolve'],['evolves']
Modifiability,"ynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.mesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver. Alternatively, we can use the function qutip.essolve, which uses the exponential-series technique to calculate the time evolution of a system. The qutip.mesolve and qutip.essolve functions take the same arguments and it is therefore easy switch between the two solvers.; For example, the time evolution of a quantum spin-1/2 system with tunneling rate 0.1 that initially is in the up state is calculated, and the expectation values of the \(\sigma_z\) operator evaluated, with the following code; In [1]: H = 2 * np.pi * 0.1 * sigmax(). In [2]: psi0 = basis(2, 0). In [3]: times = np.linspace(0.0, 10.0, 20). In [4]: result = sesolve(H, psi0, times, [sigmaz()]). The brackets in the fourth argument is an empty list of collapse operators, since we consider unitary evolution in this example. See the next section for examples on how dissipation is included by defining a list of collapse operators.; The fu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-master.html:3275,evolve,evolves,3275,docs/4.4/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-master.html,2,['evolve'],['evolves']
Modifiability,"ynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.mesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver. Alternatively, we can use the function qutip.essolve, which uses the exponential-series technique to calculate the time evolution of a system. The qutip.mesolve and qutip.essolve functions take the same arguments and it is therefore easy switch between the two solvers.; For example, the time evolution of a quantum spin-1/2 system with tunneling rate 0.1 that initially is in the up state is calculated, and the expectation values of the \(\sigma_z\) operator evaluated, with the following code; In [1]: H = 2 * np.pi * 0.1 * sigmax(). In [2]: psi0 = basis(2, 0). In [3]: times = np.linspace(0.0, 10.0, 20.0). In [4]: result = mesolve(H, psi0, times, [], [sigmaz()]). The brackets in the fourth argument is an empty list of collapse operators, since we consider unitary evolution in this example. See the next section for examples on how dissipation is included by defining a list of collapse operators.; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-master.html:3180,evolve,evolves,3180,docs/4.2/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-master.html,5,['evolve'],['evolves']
Modifiability,"ynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.mesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver.; For example, the time evolution of a quantum spin-1/2 system with tunneling rate 0.1 that initially is in the up state is calculated, and the expectation values of the \(\sigma_z\) operator evaluated, with the following code; >>> H = 2*np.pi * 0.1 * sigmax(); >>> psi0 = basis(2, 0); >>> times = np.linspace(0.0, 10.0, 20); >>> result = sesolve(H, psi0, times, [sigmaz()]). The brackets in the fourth argument is an empty list of collapse operators, since we consider unitary evolution in this example. See the next section for examples on how dissipation is included by defining a list of collapse operators.; The function returns an instance of qutip.solver.Result, as described in the previous section Dynamics Simulation Results. The attribute expect in result is a list of expectation values for the operators that are included in the list in the fifth argument. Adding operators to this list results",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html:3319,evolve,evolves,3319,docs/4.6/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html,1,['evolve'],['evolves']
Modifiability,"ynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.sesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver.; For example, the time evolution of a quantum spin-1/2 system with tunneling rate 0.1 that initially is in the up state is calculated, and the expectation values of the \(\sigma_z\) operator evaluated, with the following code; >>> H = 2*np.pi * 0.1 * sigmax(); >>> psi0 = basis(2, 0); >>> times = np.linspace(0.0, 10.0, 20); >>> result = sesolve(H, psi0, times, [sigmaz()]). See the next section for examples on how dissipation is included by defining a list of collapse operators and using qutip.mesolve instead.; The function qutip.sesolve returns an instance of qutip.solver.Result, as described in the previous section Dynamics Simulation Results. The attribute expect in result is a list of expectation values for the operators that are included in the list in the fourth argument. Adding operators to this list results in a larger output list returned by the function (one array of numbers, correspon",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:3406,evolve,evolves,3406,docs/4.7/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html,1,['evolve'],['evolves']
Modifiability,"ype to 1 to integrate without collapses; self.unravel_type = 1; if (config.e_num == 0):; # If we are returning states, and there are no; # collapse operators, set average_states to False to return; # ket vectors instead of density matrices; config.options.average_states = False; # generate a random seed, useful if e.g. running with MPI; self.seed = random_integers(1e8); if (self.serial_run):; # run in serial; sols = self.serial(); else:; # run in paralell; sols = self.parallel(); # gather data; self.sol = _gather(sols). def evolve_serial(self, args):. if debug:; print(inspect.stack()[0][3] + "":"" + str(os.getpid())). # run ntraj trajectories for one process via fortran; # get args; queue, ntraj, instanceno, rngseed = args; # initialize the problem in fortran; _init_tlist(); _init_psi0(); if (self.ptrace_sel != []):; _init_ptrace_stuff(self.ptrace_sel); _init_hamilt(); if (config.c_num != 0):; _init_c_ops(); if (config.e_num != 0):; _init_e_ops(); # set options; qtf90.qutraj_run.n_c_ops = config.c_num; qtf90.qutraj_run.n_e_ops = config.e_num; qtf90.qutraj_run.ntraj = ntraj; qtf90.qutraj_run.unravel_type = self.unravel_type; qtf90.qutraj_run.average_states = config.options.average_states; qtf90.qutraj_run.average_expect = config.options.average_expect; qtf90.qutraj_run.init_result(config.psi0_shape[0],; config.options.atol,; config.options.rtol, mf=self.mf,; norm_steps=config.norm_steps,; norm_tol=config.norm_tol); # set optional arguments; qtf90.qutraj_run.order = config.options.order; qtf90.qutraj_run.nsteps = config.options.nsteps; qtf90.qutraj_run.first_step = config.options.first_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_sparse = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:11742,config,config,11742,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,"ype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TIME TLIST[k]; while ODE.t < tlist[k]:; t_prev = ODE.t; y_prev = ODE.y; norm2_prev = dznrm2(ODE._y) ** 2; # integrate up to tlist[k], one step at a time.; ODE.integrate(tlist[k], step=1); if not ODE.successful():; raise Exception(""ZVODE failed!""); norm2_psi = dznrm2(ODE._y) ** 2; if norm2_psi <= rand_vals[0]:; # collapse has occured:; # find collapse time to within specified toler",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:23927,config,config,23927,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"ys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; The development of QuTiP has been partially supported by the Japanese Society for the Promotion of Science Foreign Postdoctoral Fellowship Program under grants P11202 (PDN) and P11501 (JRJ). Additional funding comes from RIKEN, Kakenhi grant Nos. 2301202 (PDN), 2302501 (JRJ), and Korea University. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/frontmatter.html:3334,coupling,coupling,3334,docs/3.0.0/frontmatter.html,https://qutip.org,https://qutip.org/docs/3.0.0/frontmatter.html,5,['coupling'],['coupling']
Modifiability,"ystem; Open system. Stochastic Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver - Photocurrent. Stochastic Solver - Photocurrent¶; Photocurrent method, like monte-carlo method, allows for simulating an; individual realization of the system evolution under continuous measurement. Closed system¶; Photocurrent evolution have the state evolve deterministically between quantum jumps.; During the deterministic part, the system evolve by schrodinger equation with a; non-hermitian, norm conserving effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}+; \frac{i\hbar}{2}\left( -\sum_{n}C^{+}_{n}C_{n}+ |C_{n} \psi |^2\right).\]; With \(C_{n}\), the collapse operators.; This effective Hamiltonian is equivalent to the monte-carlo effective; Hamiltonian with an extra term to keep the state normalized.; At each time step of \(\delta t\), the wave function has a probability. (2)¶\[\delta p_{n} = \left<\psi(t)|C_{n}^{+}C_{n}|\psi(t)\right> \delta t\]; of making a quantum jump. \(\delta t\) must be chosen small enough to keep; that probability small \(\delta p << 1\). If multiple jumps happen at the; same time step, the state become unphysical.; Each jump result in a sharp variation of the state by,. (3)¶\[\delta \psi = \left( \frac{C_n \psi} {\left| C_n \psi \right|} - \psi \right)\]; The basic photocurrent method directly int",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-photocurrent.html:1449,evolve,evolve,1449,docs/4.4/guide/dynamics/dynamics-photocurrent.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-photocurrent.html,1,['evolve'],['evolve']
Modifiability,"ze function. apply_params(self, params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. property dumping¶. The level of data dumping that will occur during the optimisation; NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(self, *args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(self, *args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisatio",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:78616,variab,variable,78616,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['variab'],['variable']
Modifiability,"znrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = sp.csr_matrix(np.reshape(out_psi,; (out_psi.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.conj().transpose(),; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.conj().transpose())). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs'",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:29550,config,config,29550,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); for name, value in args.items():; if isinstance(value, np.ndarray):; raise TypeError('NumPy arrays not valid args for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms),; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms),; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp,; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus,; atol=tol). cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(). _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method,; order=options.order, atol=options.atol,; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step,; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_value(initia",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/bloch_redfield.html:14944,config,config,14944,docs/4.4/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/bloch_redfield.html,4,['config'],['config']
Modifiability,"é expansion used by :class:`LorentzianPadeBath` converges much; more quickly. Parameters; ----------; Q : Qobj; Operator describing the coupling between system and bath. gamma : float; The coupling strength between the system and the bath. w : float; The width of the environment. mu : float; The chemical potential of the bath. T : float; Bath temperature. Nk : int; Number of exponential terms used to approximate the bath correlation; functions. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""; def __init__(self, Q, gamma, w, mu, T, Nk, tag=None):; ck_plus, vk_plus = self._corr(gamma, w, mu, T, Nk, sigma=1.0); ck_minus, vk_minus = self._corr(gamma, w, mu, T, Nk, sigma=-1.0). super().__init__(; Q, ck_plus, vk_plus, ck_minus, vk_minus, tag=tag,; ). def _corr(self, gamma, w, mu, T, Nk, sigma):; beta = 1. / T; kappa = [0.]; kappa.extend([1. for _ in range(1, Nk + 1)]); epsilon = [0]; epsilon.extend([(2 * ll - 1) * np.pi for ll in range(1, Nk + 1)]). def f(x):; return 1 / (np.exp(x) + 1). eta_list = [0.5 * gamma * w * f(1.0j * beta * w)]; gamma_list = [w - sigma * 1.0j * mu]. for ll in range(1, Nk + 1):; eta_list.append(; -1.0j * (kappa[ll] / beta) * gamma * w**2 /; (-(epsilon[ll]**2 / beta**2) + w**2); ); gamma_list.append(epsilon[ll] / beta - sigma * 1.0j * mu). return eta_list, gamma_list. [docs]class LorentzianPadeBath(FermionicBath):; """"""; A helper class for constructing a Padé expansion for Lorentzian fermionic; bath from the bath parameters (see parameters below). A Padé approximant is a sum-over-poles expansion (; see https://en.wikipedia.org/wiki/Pad%C3%A9_approximant). The application of the Padé method to spectrum decompoisitions is described; in ""Padé spectrum decompositions of quantum distribution functions and; optimal hierarchical equations of motion construction for quantum open; systems"" [1]. The imp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html:22553,extend,extend,22553,docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,1,['extend'],['extend']
Modifiability,"﻿. Pulse level description of quantum circuits — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Pulse level description of quantum circuits. Pulse level description of quantum circuits¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The aim of this proposal is to enhance QuTiP quantum-circuit compilation; features with regard to quantum information processing. While QuTiP core modules; deal with dynamics simulation, there is also a module for quantum circuits; simulation. The two subsequent Google Summer of Code projects, in 2019 and 2020,; enhanced them in capabilities and features, allowing the simulation both at the; level of gates and at the level of time evolution. To connect them, a compiler; is implemented to compile quantum gates into the Hamiltonian model. We would; like to further enhance this feature in QuTiP and the connection with other; libraries. Expected outcomes¶. APIs to import and export pulses to other libraries. Quantum compiler is a; current research topic in quantum engineering. Although QuTiP has a simple; compiler, many may want to try their own compiler which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; libraries, such as qiskit.pulse and OpenPulse ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/ideas/pulse-level-quantum-circuits.html:947,enhance,enhance,947,docs/4.6/development/ideas/pulse-level-quantum-circuits.html,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/pulse-level-quantum-circuits.html,1,['enhance'],['enhance']
Modifiability,"﻿. Quantum Error Mitigation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Quantum Error Mitigation. Quantum Error Mitigation¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; Processor and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pul",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html:995,enhance,enhanced,995,docs/4.6/development/ideas/quantum-error-mitigation.html,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html,1,['enhance'],['enhanced']
Performance," # @supervisor: Daniel Burgarth. """"""; Classes containing termination conditions for the control pulse optimisation; i.e. attributes that will be checked during the optimisation, that; will determine if the algorithm has completed its task / exceeded limits; """""". [docs]class TerminationConditions(object):; """"""; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes; ----------; fid_err_targ : float; Target fidelity error. fid_goal : float; goal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_time : float; # maximum time for optimisation (seconds). min_gradient_norm : float; Minimum normalised gradient after which optimisation will terminate. max_iterations : integer; Maximum iterations of the optimisation algorithm. max_fid_func_calls : integer; Maximum number of calls to the fidelity function during; the optimisation algorithm; ; accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user; """"""; def __init__(self):; self.reset(). def reset(self):; self.fid_err_targ = 1e-5; self.fid_goal = None; self.max_wall_time = 60*60.0; self.min_gradient_norm = 1e-5; self.max_iterations = 1e10; self.max_fid_func_calls = 1e10. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/termcond.html:3485,optimiz,optimize,3485,docs/4.6/modules/qutip/control/termcond.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/termcond.html,1,['optimiz'],['optimize']
Performance, (FidCompUnitary method). normalize_SU() (FidCompUnitary method). num() (in module qutip.operators). num_ctrls() (Dynamics property). (DynamicsUnitary property). num_dicke_ladders() (in module qutip.piqs). num_dicke_states() (in module qutip.piqs). num_tls() (in module qutip.piqs). O. ode2es() (in module qutip.essolve). onto_evo() (Dynamics property). onwd_evo() (Dynamics property). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircuitProcessor method). (DispersivecQED method). (SpinChain method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). phase() (in module qutip.operators). phase_application() (Dynamics property). phase_basis() (in module qutip.states). phasegate() (in module qutip.qip.gates). Pim (class in qutip.piqs). pisolve() (Dicke method). plot_energy_levels() (in module qutip.visualization). plot_expectation_values() (in module qutip.visualization). plot_fock_distribution() (in module qutip.visualization). plot_pulses() (CircuitProcessor method). plot_qubis,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/genindex.html:12464,optimiz,optimizer,12464,docs/4.4/genindex.html,https://qutip.org,https://qutip.org/docs/4.4/genindex.html,1,['optimiz'],['optimizer']
Performance," * B.dag(); eigs = U.eigenenergies(); eig_distances = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A); ; if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (∞-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Thus, we must yet again go dense.; return la.norm(op.data.todense(), 2). # If we're still here, we need to actually solve the problem. # Assume square...; dim = np.prod(J.dims[0][0]); ; # The constraints only depend on the dimension, so; # we can cache them efficiently.; problem, Jr, Ji, X, rho0, rho1 = dnorm_problem(dim); ; # Load the parameters with the Choi matrix passed in.; J_dat = J.data; Jr.value, Ji.value = J_dat.real, J_dat.imag; ; # Finally, set up and run the problem.; problem.solve(solver=solver, verbose=verbose). return problem.value. def unitarity(oper):; """"""; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map's superoperator representation. Parameters; ----------; oper : Qobj; Quantum map under consideration. Returns; -------; u : float; Unitarity of ``oper``.; """"""; Eu = _super_to_superpauli(oper).full()[1:, 1:]; #return np.real(np.trace(np.dot(Eu, Eu.conj().T))) / len(Eu); return np.linalg.norm(Eu, 'fro')**2 / len(Eu). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/metrics.html:11978,cache,cache,11978,docs/4.0.2/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/metrics.html,1,['cache'],['cache']
Performance," * B.dag(); eigs = U.eigenenergies(); eig_distances = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A); ; if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (∞-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Thus, we must yet again go dense.; return la.norm(op.data.todense(), 2). # If we're still here, we need to actually solve the problem. # Assume square...; dim = np.prod(J.dims[0][0]); ; # The constraints only depend on the dimension, so; # we can cache them efficiently.; problem, Jr, Ji, X, rho0, rho1 = dnorm_problem(dim); ; # Load the parameters with the Choi matrix passed in.; J_dat = J.data; Jr.value, Ji.value = J_dat.real, J_dat.imag; ; # Finally, set up and run the problem.; problem.solve(solver=solver, verbose=verbose). return problem.value. def unitarity(oper):; """"""; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map's superoperator representation. Parameters; ----------; oper : Qobj; Quantum map under consideration. Returns; -------; u : float; Unitarity of ``oper``.; """"""; Eu = _super_to_superpauli(oper).full()[1:, 1:]; #return np.real(np.trace(np.dot(Eu, Eu.conj().T))) / len(Eu); return np.linalg.norm(Eu, 'fro')**2 / len(Eu). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/metrics.html:11978,cache,cache,11978,docs/4.2/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/metrics.html,1,['cache'],['cache']
Performance," * B.dag(); eigs = U.eigenenergies(); eig_distances = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A); ; if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (∞-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Thus, we must yet again go dense.; return la.norm(op.data.todense(), 2). # If we're still here, we need to actually solve the problem. # Assume square...; dim = np.prod(J.dims[0][0]); ; # The constraints only depend on the dimension, so; # we can cache them efficiently.; problem, Jr, Ji, X, rho0, rho1 = dnorm_problem(dim); ; # Load the parameters with the Choi matrix passed in.; J_dat = J.data; Jr.value, Ji.value = J_dat.real, J_dat.imag; ; # Finally, set up and run the problem.; problem.solve(solver=solver, verbose=verbose). return problem.value. def unitarity(oper):; """"""; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map's superoperator representation. Parameters; ----------; oper : Qobj; Quantum map under consideration. Returns; -------; u : float; Unitarity of ``oper``.; """"""; Eu = _super_to_superpauli(oper).full()[1:, 1:]; #return np.real(np.trace(np.dot(Eu, Eu.conj().T))) / len(Eu); return np.linalg.norm(Eu, 'fro')**2 / len(Eu). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/metrics.html:11978,cache,cache,11978,docs/4.1/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/metrics.html,1,['cache'],['cache']
Performance," - 1:; lw, lc, alpha = 2.0, 'k', 1.0. axes[j, 0].set_ylabel(labels[j], fontsize=18); axes[j, 0].set_xlabel(r'$t$', fontsize=18); axes[j, 0].set_xlim(0, times[-1]). else:; lw, lc, alpha = 0.5, 'b', 0.25. axes[j, 0].step(times, u[r, j, :], lw=lw, color=lc, alpha=alpha). if uniform_axes:; axes[j, 0].set_ylim(-y_max, y_max). fig.tight_layout(). return fig, axes. def _overlap(A, B):; return (A.dag() * B).tr() / A.shape[0]; # return cy_overlap(A.data, B.data). [docs]def grape_unitary(U, H0, H_ops, R, times, eps=None, u_start=None,; u_limits=None, interp_kind='linear', use_interp=False,; alpha=None, beta=None, phase_sensitive=True,; progress_bar=BaseProgressBar()):; """"""; Calculate control pulses for the Hamiltonian operators in H_ops so that the; unitary U is realized. Experimental: Work in progress. Parameters; ----------; U : Qobj; Target unitary evolution operator. H0 : Qobj; Static Hamiltonian (that cannot be tuned by the control fields). H_ops: list of Qobj; A list of operators that can be tuned in the Hamiltonian via the; control fields. R : int; Number of GRAPE iterations. time : array / list; Array of time coordinates for control pulse evalutation. u_start : array; Optional array with initial control pulse values. Returns; -------; Instance of GRAPEResult, which contains the control pulses calculated; with GRAPE, a time-dependent Hamiltonian that is defined by the; control pulses, as well as the resulting propagator.; """""". if eps is None:; eps = 0.1 * (2 * np.pi) / (times[-1]). M = len(times); J = len(H_ops). u = np.zeros((R, J, M)). if u_limits and len(u_limits) != 2:; raise ValueError(""u_limits must be a list with two values""). if u_limits:; warnings.warn(""Caution: Using experimental feature u_limits""). if u_limits and u_start:; # make sure that no values in u0 violates the u_limits conditions; u_start = np.array(u_start); u_start[u_start < u_limits[0]] = u_limits[0]; u_start[u_start > u_limits[1]] = u_limits[1]. if u_start is not None:; for idx, u0 in enumerate(u",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:6076,tune,tuned,6076,docs/3.1.0/modules/qutip/control/grape.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html,1,['tune'],['tuned']
Performance," 0. +0.j ]; [0. +0.j 0. -0.1j 0.1+0.j 0. +0.j ]; [0.1+0.j 0. +0.j 0. +0.j 0.1+0.j ]]. One convenient property of the \(\chi\) matrix is that the average; gate fidelity with the identity map can be read off directly from; the \(\chi_{00}\) element:; In [126]: print(average_gate_fidelity(S)); 0.9499999999999998. In [127]: print(chi[0, 0] / 4); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-states.html:35118,perform,perform,35118,docs/4.4/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-states.html,1,['perform'],['perform']
Performance," 0. +0.j ]; [0. +0.j 0. -0.1j 0.1+0.j 0. +0.j ]; [0.1+0.j 0. +0.j 0. +0.j 0.1+0.j ]]. One convenient property of the \(\chi\) matrix is that the average; gate fidelity with the identity map can be read off directly from; the \(\chi_{00}\) element:; In [134]: print(average_gate_fidelity(S)); 0.9499999999999998. In [135]: print(chi[0, 0] / 4); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-states.html:34804,perform,perform,34804,docs/4.3/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-states.html,1,['perform'],['perform']
Performance," 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. « Parallel computa... Generating Rando... ». Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calcula",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-saving.html:2383,load,loading,2383,docs/3.1.0/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-saving.html,2,['load'],"['load', 'loading']"
Performance," 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. « Running Problems... Generating Rando... ». Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [2]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [3]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [4]: qsave(rho_ss, 'steadystate'). In [5]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calcula",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-saving.html:2281,load,loading,2281,docs/3.0.0/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-saving.html,4,['load'],"['load', 'loading']"
Performance," : float. Variance of operator ‘oper’ for given state. Partial Transpose¶. partial_transpose(rho, mask, method='dense')¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:rho : qutip.qobj. A density matrix. mask : list / array. A mask that selects which subsystems should be transposed. method : str. choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr: :class:`qutip.qobj` :. A density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state : qobj. Ket, bra, or density matrix for a two-qubit state. Returns:concur : float. Concurrence. References. [R2]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a slected density matrix component. Parameters:rho : qobj. Density matrix of composite object. selB : int/list. Selected components for density matrix B. base : {e,2}. Base of logarithm. sparse : {False,True}. Use sparse eigensolver. Returns:ent_cond : float. Value of conditional entropy. entropy_linear(rho)¶; Linear entropy of a density matrix. Parameters:rho : qobj. sensity matrix or ket/bra vector. Returns:entropy : float. Linear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)¶; Calculates the mutual i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:26202,concurren,concurrence,26202,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,4,['concurren'],['concurrence']
Performance," : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:77293,optimiz,optimize,77293,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['optimiz'],['optimize']
Performance," = ""complex""; else:; numtype = ""np.real"". # check format; if (""e"" in line_vec[0]) or (""E"" in line_vec[0]):; numformat = ""exp""; else:; numformat = ""decimal"". elif N != n:; raise ValueError(""Badly formatted data file: "" +; ""unequal number of columns""); M += 1. #; # read data and store in a matrix; #; f.seek(0). if numtype == ""complex"":; data = np.zeros((M, N), dtype=""complex""); m = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = complex(item); n += 1; m += 1. else:; data = np.zeros((M, N), dtype=""float""); m = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = float(item); n += 1; m += 1. f.close(). return data. [docs]def qsave(data, name='qutip_data'):; """"""; Saves given data to file named 'filename.qu' in current directory. Parameters; ----------; data : instance/array_like; Input Python object to be stored.; filename : str or pathlib.Path; Name of output data file. """"""; # open the file for writing; path = Path(name); path = path.with_suffix(path.suffix + "".qu""). with open(path, ""wb"") as fileObject:; # this writes the object a to the file named 'filename.qu'; pickle.dump(data, fileObject). [docs]def qload(name):; """"""; Loads data file from file named 'filename.qu' in current directory. Parameters; ----------; name : str or pathlib.Path; Name of data file to be loaded. Returns; -------; qobject : instance / array_like; Object retrieved from requested file. """"""; path = Path(name); path = path.with_suffix(path.suffix + "".qu""). with open(path, ""rb"") as fileObject:; if sys.version_info >= (3, 0):; out = pickle.load(fileObject, encoding='latin1'); else:; out = pickle.load(fileObject). return out. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/fileio.html:5340,load,loaded,5340,docs/4.7/modules/qutip/fileio.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/fileio.html,3,['load'],"['load', 'loaded']"
Performance," = 0.5 * g * (x + iy), default g = sqrt(2). method : string {‘clenshaw’, ‘iterative’, ‘laguerre’, ‘fft’}. Select method ‘clenshaw’ ‘iterative’, ‘laguerre’, or ‘fft’, where ‘clenshaw’; and ‘iterative’ use an iterative method to evaluate the Wigner functions for density; matrices \(|m><n|\), while ‘laguerre’ uses the Laguerre polynomials; in scipy for the same task. The ‘fft’ method evaluates the Fourier; transform of the density matrix. The ‘iterative’ method is default, and; in general recommended, but the ‘laguerre’ method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The ‘clenshaw’ method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). ‘clenshaw’ is a fast and numerically stable method. sparse : bool {False, True}. Tells the default solver whether or not to keep the input density; matrix in sparse format. As the dimensions of the density matrix; grow, setthing this flag can result in increased performance. parfor : bool {False, True}. Flag for calculating the Laguerre polynomial based Wigner function; method=’laguerre’ in parallel using the parfor function. Returns:W : array. Values representing the Wigner function calculated over the specified; range [xvec,yvec]. yvex : array. FFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; The ‘fft’ method accepts only an xvec input for the x-coordinate.; The y-coordinates are calculated internally.; References; Ulf Leonhardt,; Measuring the Quantum State of Light, (Cambridge University Press, 1997). Graphs and Visualization¶; Functions for visualizing results of quantum dynamics simulations,; visualizations of quantum states and processes. hinton(rho, xlabels=None, ylabels=None, title=None, ax=None, cmap=None, label_top=True)[source]¶; Draws a Hinton diagram for visualizing a density matrix or superoperator. Parameters:rho : qobj. Input density matrix or supero",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:112716,perform,performance,112716,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['perform'],['performance']
Performance," = 0.5 * g * (x + iy), default g = sqrt(2). method : string {‘clenshaw’, ‘iterative’, ‘laguerre’, ‘fft’}; Select method ‘clenshaw’ ‘iterative’, ‘laguerre’, or ‘fft’, where ‘clenshaw’; and ‘iterative’ use an iterative method to evaluate the Wigner functions for density; matrices \(|m><n|\), while ‘laguerre’ uses the Laguerre polynomials; in scipy for the same task. The ‘fft’ method evaluates the Fourier; transform of the density matrix. The ‘iterative’ method is default, and; in general recommended, but the ‘laguerre’ method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The ‘clenshaw’ method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). ‘clenshaw’ is a fast and numerically stable method. sparse : bool {False, True}; Tells the default solver whether or not to keep the input density; matrix in sparse format. As the dimensions of the density matrix; grow, setthing this flag can result in increased performance. parfor : bool {False, True}; Flag for calculating the Laguerre polynomial based Wigner function; method=’laguerre’ in parallel using the parfor function. Returns:; W : array; Values representing the Wigner function calculated over the specified; range [xvec,yvec]. yvex : array; FFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; The ‘fft’ method accepts only an xvec input for the x-coordinate.; The y-coordinates are calculated internally.; References; Ulf Leonhardt,; Measuring the Quantum State of Light, (Cambridge University Press, 1997). Graphs and Visualization¶; Functions for visualizing results of quantum dynamics simulations,; visualizations of quantum states and processes. hinton(rho, xlabels=None, ylabels=None, title=None, ax=None, cmap=None, label_top=True)[source]¶; Draws a Hinton diagram for visualizing a density matrix or superoperator. Parameters:; rho : qobj; Input density matrix or su",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:127315,perform,performance,127315,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['perform'],['performance']
Performance," = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refine : int {10}; MKL ONLY. Max. number of iterative refinements to perform. scaling_vectors : bool {True, False}; MKL ONLY. Scale matrix to unit norm columns and rows. weighted_matching : bool {True, False}; MKL ONLY. Use weighted matching to better condition diagonal. x0 : ndarray, optional; ITERATIVE ONLY. Initial guess for solution vector. maxiter : int, optional, default=1000; ITERATIVE ONLY. Maximum number of iterations to perform. tol : float, optional, default=1e-12; ITERATIVE ONLY. Tolerance used for terminating solver. mtol : float, optional, default=None; ITERATIVE 'power' methods ONLY. Tolerance for lu solve method.; If None given then `max(0.1*tol, 1e-15)` is used. matol : float, optional, default=1e-15; ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_spec : str, optional, default='COLAMD'; ITERATIVE ONLY. Column ordering used internally by superLU for the; 'direct' LU decomposition method. Options include 'COLAMD' and; 'NATURAL'. If using RCM then this is set to 'NATURAL' automatically; unless explicitly specif",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:6887,perform,perform,6887,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,3,['perform'],['perform']
Performance," = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = complex(item); n += 1; m += 1. else:; data = np.zeros((M, N), dtype=""float""); m = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = float(item); n += 1; m += 1. f.close(). return data. [docs]def qsave(data, name='qutip_data'):; """"""; Saves given data to file named 'filename.qu' in current directory. Parameters; ----------; data : instance/array_like; Input Python object to be stored.; filename : str; Name of output data file. """"""; # open the file for writing; fileObject = open(name + '.qu', 'wb'); # this writes the object a to the file named 'filename.qu'; pickle.dump(data, fileObject); fileObject.close(). [docs]def qload(name):; """"""; Loads data file from file named 'filename.qu' in current directory. Parameters; ----------; name : str; Name of data file to be loaded. Returns; -------; qobject : instance / array_like; Object retrieved from requested file. """"""; fileObject = open(name + '.qu', 'rb') # open the file for reading; if sys.version_info >= (3, 0):; out = pickle.load(fileObject, encoding='latin1') # return the object from the file; else:; out = pickle.load(fileObject); if isinstance(out, Qobj): # for quantum objects; print('Loaded Qobj object:'); str1 = ""Quantum object: "" + ""dims = "" + str(out.dims) \; + "", shape = "" + str(out.shape) + "", type = "" + out.type; if out.type == 'oper' or out.type == 'super':; str1 += "", isHerm = "" + str(out.isherm) + ""\n""; else:; str1 += ""\n""; print(str1); elif isinstance(out, Result):; print('Loaded Result object:'); print(out); else:; print(""Loaded "" + str(type(out).__name__) + "" object.""); return out. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/fileio.html:6983,load,loaded,6983,docs/4.5/modules/qutip/fileio.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/fileio.html,1,['load'],['loaded']
Performance," = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = complex(item); n += 1; m += 1. else:; data = np.zeros((M, N), dtype=""float""); m = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = float(item); n += 1; m += 1. f.close(). return data. [docs]def qsave(data, name='qutip_data'):; """"""; Saves given data to file named 'filename.qu' in current directory. Parameters; ----------; data : instance/array_like; Input Python object to be stored.; filename : str; Name of output data file. """"""; # open the file for writing; fileObject = open(name + '.qu', 'wb'); # this writes the object a to the file named 'filename.qu'; pickle.dump(data, fileObject); fileObject.close(). [docs]def qload(name):; """"""; Loads data file from file named 'filename.qu' in current directory. Parameters; ----------; name : str; Name of data file to be loaded. Returns; -------; qobject : instance / array_like; Object retrieved from requested file. """"""; fileObject = open(name + '.qu', 'rb') # open the file for reading; if sys.version_info >= (3, 0):; out = pickle.load(fileObject, encoding='latin1') # return the object from the file; else:; out = pickle.load(fileObject); if isinstance(out, Qobj): # for quantum objects; print('Loaded Qobj object:'); str1 = ""Quantum object: "" + ""dims = "" + str(out.dims) \; + "", shape = "" + str(out.shape) + "", type = "" + out.type; if out.type == 'oper' or out.type == 'super':; str1 += "", isHerm = "" + str(out.isherm) + ""\n""; else:; str1 += ""\n""; print(str1); elif isinstance(out, Result):; print('Loaded Result object:'); print(out); else:; print(""Loaded "" + str(type(out).__name__) + "" object.""); return out. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/fileio.html:6970,load,loaded,6970,docs/4.4/modules/qutip/fileio.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/fileio.html,1,['load'],['loaded']
Performance," = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = complex(item); n += 1; m += 1. else:; data = np.zeros((M, N), dtype=""float""); m = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = float(item); n += 1; m += 1. f.close(). return data. [docs]def qsave(data, name='qutip_data'):; """"""; Saves given data to file named 'filename.qu' in current directory. Parameters; ----------; data : instance/array_like; Input Python object to be stored.; filename : str; Name of output data file. """"""; # open the file for writing; fileObject = open(name + '.qu', 'wb'); # this writes the object a to the file named 'filename.qu'; pickle.dump(data, fileObject); fileObject.close(). [docs]def qload(name):; """"""; Loads data file from file named 'filename.qu' in current directory. Parameters; ----------; name : str; Name of data file to be loaded. Returns; -------; qobject : instance / array_like; Object retrieved from requested file. """"""; fileObject = open(name + '.qu', 'rb') # open the file for reading; if sys.version_info >= (3, 0):; out = pickle.load(fileObject, encoding='latin1') # return the object from the file; else:; out = pickle.load(fileObject); if isinstance(out, Qobj): # for quantum objects; print('Loaded Qobj object:'); str1 = ""Quantum object: "" + ""dims = "" + str(out.dims) \; + "", shape = "" + str(out.shape) + "", type = "" + out.type; if out.type == 'oper' or out.type == 'super':; str1 += "", isHerm = "" + str(out.isherm) + ""\n""; else:; str1 += ""\n""; print(str1); elif isinstance(out, Result):; print('Loaded Result object:'); print(out); else:; print(""Loaded "" + str(type(out).__name__) + "" object.""); return out. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provid",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/fileio.html:6974,load,loaded,6974,docs/4.0.2/modules/qutip/fileio.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/fileio.html,1,['load'],['loaded']
Performance," = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = complex(item); n += 1; m += 1. else:; data = np.zeros((M, N), dtype=""float""); m = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = float(item); n += 1; m += 1. f.close(). return data. [docs]def qsave(data, name='qutip_data'):; """"""; Saves given data to file named 'filename.qu' in current directory. Parameters; ----------; data : instance/array_like; Input Python object to be stored.; filename : str; Name of output data file. """"""; # open the file for writing; fileObject = open(name + '.qu', 'wb'); # this writes the object a to the file named 'filename.qu'; pickle.dump(data, fileObject); fileObject.close(). [docs]def qload(name):; """"""; Loads data file from file named 'filename.qu' in current directory. Parameters; ----------; name : str; Name of data file to be loaded. Returns; -------; qobject : instance / array_like; Object retrieved from requested file. """"""; fileObject = open(name + '.qu', 'rb') # open the file for reading; if sys.version_info >= (3, 0):; out = pickle.load(fileObject, encoding='latin1') # return the object from the file; else:; out = pickle.load(fileObject); if isinstance(out, Qobj): # for quantum objects; print('Loaded Qobj object:'); str1 = ""Quantum object: "" + ""dims = "" + str(out.dims) \; + "", shape = "" + str(out.shape) + "", type = "" + out.type; if out.type == 'oper' or out.type == 'super':; str1 += "", isHerm = "" + str(out.isherm) + ""\n""; else:; str1 += ""\n""; print(str1); elif isinstance(out, Result):; print('Loaded Result object:'); print(out); else:; print(""Loaded "" + str(type(out).__name__) + "" object.""); return out. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provid",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/fileio.html:6974,load,loaded,6974,docs/4.2/modules/qutip/fileio.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/fileio.html,1,['load'],['loaded']
Performance," = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = complex(item); n += 1; m += 1. else:; data = np.zeros((M, N), dtype=""float""); m = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = float(item); n += 1; m += 1. f.close(). return data. [docs]def qsave(data, name='qutip_data'):; """"""; Saves given data to file named 'filename.qu' in current directory. Parameters; ----------; data : instance/array_like; Input Python object to be stored.; filename : str; Name of output data file. """"""; # open the file for writing; fileObject = open(name + '.qu', 'wb'); # this writes the object a to the file named 'filename.qu'; pickle.dump(data, fileObject); fileObject.close(). [docs]def qload(name):; """"""; Loads data file from file named 'filename.qu' in current directory. Parameters; ----------; name : str; Name of data file to be loaded. Returns; -------; qobject : instance / array_like; Object retrieved from requested file. """"""; fileObject = open(name + '.qu', 'rb') # open the file for reading; if sys.version_info >= (3, 0):; out = pickle.load(fileObject, encoding='latin1') # return the object from the file; else:; out = pickle.load(fileObject); if isinstance(out, Qobj): # for quantum objects; print('Loaded Qobj object:'); str1 = ""Quantum object: "" + ""dims = "" + str(out.dims) \; + "", shape = "" + str(out.shape) + "", type = "" + out.type; if out.type == 'oper' or out.type == 'super':; str1 += "", isHerm = "" + str(out.isherm) + ""\n""; else:; str1 += ""\n""; print(str1); elif isinstance(out, Result):; print('Loaded Result object:'); print(out); else:; print(""Loaded "" + str(type(out).__name__) + "" object.""); return out. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provid",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/fileio.html:6974,load,loaded,6974,docs/4.1/modules/qutip/fileio.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/fileio.html,1,['load'],['loaded']
Performance," = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = complex(item); n += 1; m += 1. else:; data = np.zeros((M, N), dtype=""float""); m = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = float(item); n += 1; m += 1. f.close(). return data. [docs]def qsave(data, name='qutip_data'):; """"""; Saves given data to file named 'filename.qu' in current directory. Parameters; ----------; data : instance/array_like; Input Python object to be stored.; filename : str; Name of output data file. """"""; # open the file for writing; fileObject = open(name + '.qu', 'wb'); # this writes the object a to the file named 'filename.qu'; pickle.dump(data, fileObject); fileObject.close(). [docs]def qload(name):; """"""; Loads data file from file named 'filename.qu' in current directory. Parameters; ----------; name : str; Name of data file to be loaded. Returns; -------; qobject : instance / array_like; Object retrieved from requested file. """"""; fileObject = open(name + '.qu', 'rb') # open the file for reading; if sys.version_info >= (3, 0):; out = pickle.load(fileObject, encoding='latin1') # return the object from the file; else:; out = pickle.load(fileObject); if isinstance(out, Qobj): # for quantum objects; print('Loaded Qobj object:'); str1 = ""Quantum object: "" + ""dims = "" + str(out.dims) \; + "", shape = "" + str(out.shape) + "", type = "" + out.type; if out.type == 'oper' or out.type == 'super':; str1 += "", isHerm = "" + str(out.isherm) + ""\n""; else:; str1 += ""\n""; print(str1); elif isinstance(out, Result):; print('Loaded Result object:'); print(out); else:; print(""Loaded "" + str(type(out).__name__) + "" object.""); return out. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provide",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/fileio.html:6974,load,loaded,6974,docs/4.3/modules/qutip/fileio.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/fileio.html,1,['load'],['loaded']
Performance," = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = complex(item); n += 1; m += 1. else:; data = np.zeros((M, N), dtype=""float""); m = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = float(item); n += 1; m += 1. f.close(). return data. [docs]def qsave(data, name='qutip_data'):; """"""; Saves given data to file named 'filename.qu' in current directory. Parameters; ----------; data : instance/array_like; Input Python object to be stored.; filename : str; Name of output data file. """"""; # open the file for writing; fileObject = open(name + '.qu', 'wb'); # this writes the object a to the file named 'filename.qu'; pickle.dump(data, fileObject); fileObject.close(). [docs]def qload(name):; """"""; Loads data file from file named 'filename.qu' in current directory. Parameters; ----------; name : str; Name of data file to be loaded. Returns; -------; qobject : instance / array_like; Object retrieved from requested file. """"""; with open(name + "".qu"", ""rb"") as fileObject:; if sys.version_info >= (3, 0):; out = pickle.load(fileObject, encoding='latin1'); else:; out = pickle.load(fileObject); if isinstance(out, Qobj): # for quantum objects; print('Loaded Qobj object:'); str1 = ""Quantum object: "" + ""dims = "" + str(out.dims) \; + "", shape = "" + str(out.shape) + "", type = "" + out.type; if out.type == 'oper' or out.type == 'super':; str1 += "", isHerm = "" + str(out.isherm) + ""\n""; else:; str1 += ""\n""; print(str1); elif isinstance(out, Result):; print('Loaded Result object:'); print(out); else:; print(""Loaded "" + str(type(out).__name__) + "" object.""); return out. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built wit",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/fileio.html:7003,load,loaded,7003,docs/4.6/modules/qutip/fileio.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/fileio.html,1,['load'],['loaded']
Performance," == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = complex(item); n += 1; m += 1. else:; data = np.zeros((M, N), dtype=""float""); m = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = float(item); n += 1; m += 1. f.close(). return data. [docs]def qsave(data, name='qutip_data'):; """"""; Saves given data to file named 'filename.qu' in current directory. Parameters; ----------; data : instance/array_like; Input Python object to be stored.; filename : str; Name of output data file. """"""; # open the file for writing; fileObject = open(name + '.qu', 'wb'); # this writes the object a to the file named 'filename.qu'; pickle.dump(data, fileObject); fileObject.close(). [docs]def qload(name):; """"""; Loads data file from file named 'filename.qu' in current directory. Parameters; ----------; name : str; Name of data file to be loaded. Returns; -------; qobject : instance / array_like; Object retrieved from requested file. """"""; with open(name + "".qu"", ""rb"") as fileObject:; if sys.version_info >= (3, 0):; out = pickle.load(fileObject, encoding='latin1'); else:; out = pickle.load(fileObject); if isinstance(out, Qobj): # for quantum objects; print('Loaded Qobj object:'); str1 = ""Quantum object: "" + ""dims = "" + str(out.dims) \; + "", shape = "" + str(out.shape) + "", type = "" + out.type; if out.type == 'oper' or out.type == 'super':; str1 += "", isHerm = "" + str(out.isherm) + ""\n""; else:; str1 += ""\n""; print(str1); elif isinstance(out, Result):; print('Loaded Result object:'); print(out); else:; print(""Loaded "" + str(type(out).__name__) + "" object.""); return out. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/fileio.html:7196,load,load,7196,docs/4.6/modules/qutip/fileio.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/fileio.html,2,['load'],['load']
Performance," == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; ; optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is no",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:65265,optimiz,optimizer,65265,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,2,['optimiz'],['optimizer']
Performance," == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:64871,optimiz,optimizer,64871,docs/4.2/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html,3,['optimiz'],['optimizer']
Performance," B. Ucar, “Design, Implementation, and. Analysis of Maximum Transversal Algorithms”, ACM Trans. Math. Softw.; 38, no. 2, (2011). weighted_bipartite_matching(A, perm_type='row')[source]¶; Returns an array of row permutations that attempts to maximize; the product of the ABS values of the diagonal elements in; a nonsingular square CSC sparse matrix. Such a permutation is; always possible provided that the matrix is nonsingular.; This function looks at both the structure and ABS values of the; underlying matrix. Parameters:A : csc_matrix. Input matrix. perm_type : str {‘row’, ‘column’}. Type of permutation to generate. Returns:perm : array. Array of row or column permutations. Notes; This function uses a weighted maximum cardinality bipartite matching; algorithm based on breadth-first search (BFS). The columns are weighted; according to the element of max ABS value in the associated rows and; are traversed in descending order by weight. When performing the BFS; traversal, the row associated to a given column is the one with maximum; weight. Unlike other techniques[R4]_, this algorithm does not guarantee the; product of the diagonal is maximized. However, this limitation is offset; by the substantially faster runtime of this method.; References. [R4]. Duff and J. Koster, “The design and use of algorithms for. permuting large entries to the diagonal of sparse matrices”, SIAM J.; Matrix Anal. and Applics. 20, no. 4, 889 (1997). Utility Functions¶; This module contains utility functions that are commonly needed in other; qutip modules. n_thermal(w, w_th)[source]¶; Return the number of photons in thermal equilibrium for an harmonic; oscillator mode with frequency ‘w’, at the temperature described by; ‘w_th’ where \(\omega_{\rm th} = k_BT/\hbar\). Parameters:w : float or array. Frequency of the oscillator. w_th : float. The temperature in units of frequency (or the same units as w). Returns:n_avg : float or array. Return the number of average photons in thermal equilibrium f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:153345,perform,performing,153345,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['perform'],['performing']
Performance," B. Ucar, “Design, Implementation, and; Analysis of Maximum Transversal Algorithms”, ACM Trans. Math. Softw.; 38, no. 2, (2011). weighted_bipartite_matching(A, perm_type='row')[source]¶; Returns an array of row permutations that attempts to maximize; the product of the ABS values of the diagonal elements in; a nonsingular square CSC sparse matrix. Such a permutation is; always possible provided that the matrix is nonsingular.; This function looks at both the structure and ABS values of the; underlying matrix. Parameters:A : csc_matrix. Input matrix. perm_type : str {‘row’, ‘column’}. Type of permutation to generate. Returns:perm : array. Array of row or column permutations. Notes; This function uses a weighted maximum cardinality bipartite matching; algorithm based on breadth-first search (BFS). The columns are weighted; according to the element of max ABS value in the associated rows and; are traversed in descending order by weight. When performing the BFS; traversal, the row associated to a given column is the one with maximum; weight. Unlike other techniques[1]_, this algorithm does not guarantee the; product of the diagonal is maximized. However, this limitation is offset; by the substantially faster runtime of this method.; References; I. S. Duff and J. Koster, “The design and use of algorithms for; permuting large entries to the diagonal of sparse matrices”, SIAM J.; Matrix Anal. and Applics. 20, no. 4, 889 (1997). Utility Functions¶; This module contains utility functions that are commonly needed in other; qutip modules. n_thermal(w, w_th)[source]¶; Return the number of photons in thermal equilibrium for an harmonic; oscillator mode with frequency ‘w’, at the temperature described by; ‘w_th’ where \(\omega_{\rm th} = k_BT/\hbar\). Parameters:w : float or array. Frequency of the oscillator. w_th : float. The temperature in units of frequency (or the same units as w). Returns:n_avg : float or array. Return the number of average photons in thermal equilibrium fo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:190740,perform,performing,190740,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['perform'],['performing']
Performance," Biamonte, D. G. Cory, Tensor networks and graphical calculus for; open quantum systems. arXiv:1111.6950. dAless08. d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). Byrd95. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. Flo12. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. Lloyd14. Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. Doria11. Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. Caneva11. Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. Rach15. Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. DYNAMO. Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Wis09; Wiseman, H. M. & Milburn, G. J. Quantum Measurement and Control, (Cambridge University Press, 2009). NKanej; N Khaneja et. al. Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005). doi:10.1016/j.jmr.2004.11.004. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/biblio.html:2498,optimiz,optimization,2498,docs/4.7/biblio.html,https://qutip.org,https://qutip.org/docs/4.7/biblio.html,1,['optimiz'],['optimization']
Performance," CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, gen_stats=False)[source]¶; Generate the objects of the appropriate subclasses required for the pulse; optmisation based on the parameters given Note this method may be; preferable to calling optimize_pulse if more detailed",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:199815,optimiz,optimization,199815,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['optimiz'],['optimization']
Performance," CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:143693,optimiz,optimization,143693,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,6,['optimiz'],['optimization']
Performance, Documentation; An Overview of the Eseries Class — QuTiP 4.1 Documentation; Guide Overview — QuTiP 4.1 Documentation; Parallel computation — QuTiP 4.1 Documentation; Generating Random Quantum States & Operators — QuTiP 4.1 Documentation; Saving QuTiP Objects and Data Sets — QuTiP 4.1 Documentation; Modifying Internal QuTiP Settings — QuTiP 4.1 Documentation; Manipulating States and Operators — QuTiP 4.1 Documentation; guide-states-1.pdf; guide-states-1.py; Solving for Steady-State Solutions — QuTiP 4.1 Documentation; Using Tensor Products and Partial Traces — QuTiP 4.1 Documentation; Visualization of quantum states and processes — QuTiP 4.1 Documentation. /images; ; qutip_tree.pdf. QuTiP: Quantum Toolbox in Python (4.1) — QuTiP 4.1 Documentation; Installation — QuTiP 4.1 Documentation. /modules; . /qutip; . /control; ; qutip.control.dump — QuTiP 4.1 Documentation; qutip.control.dynamics — QuTiP 4.1 Documentation; qutip.control.fidcomp — QuTiP 4.1 Documentation; qutip.control.optimizer — QuTiP 4.1 Documentation; qutip.control.optimresult — QuTiP 4.1 Documentation; qutip.control.propcomp — QuTiP 4.1 Documentation; qutip.control.pulsegen — QuTiP 4.1 Documentation; qutip.control.pulseoptim — QuTiP 4.1 Documentation; qutip.control.stats — QuTiP 4.1 Documentation; qutip.control.termcond — QuTiP 4.1 Documentation; qutip.control.tslotcomp — QuTiP 4.1 Documentation. /nonmarkov; ; qutip.nonmarkov.heom — QuTiP 4.1 Documentation; qutip.nonmarkov.memorycascade — QuTiP 4.1 Documentation; qutip.nonmarkov.transfertensor — QuTiP 4.1 Documentation. /qip; . /algorithms; ; qutip.qip.algorithms.qft — QuTiP 4.1 Documentation. /models; ; qutip.qip.models.circuitprocessor — QuTiP 4.1 Documentation; qutip.qip.models.cqed — QuTiP 4.1 Documentation; qutip.qip.models.spinchain — QuTiP 4.1 Documentation. qutip.qip.circuit — QuTiP 4.1 Documentation; qutip.qip.gates — QuTiP 4.1 Documentation; qutip.qip.qubits — QuTiP 4.1 Documentation. qutip.about — QuTiP 4.1 Documentation; qutip.bloch — QuTiP 4.,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/index-wcopy.html:18448,optimiz,optimizer,18448,index-wcopy.html,https://qutip.org,https://qutip.org/index-wcopy.html,1,['optimiz'],['optimizer']
Performance, Documentation; An Overview of the Eseries Class — QuTiP 4.2 Documentation; Guide Overview — QuTiP 4.2 Documentation; Parallel computation — QuTiP 4.2 Documentation; Generating Random Quantum States & Operators — QuTiP 4.2 Documentation; Saving QuTiP Objects and Data Sets — QuTiP 4.2 Documentation; Modifying Internal QuTiP Settings — QuTiP 4.2 Documentation; Manipulating States and Operators — QuTiP 4.2 Documentation; guide-states-1.pdf; guide-states-1.py; Solving for Steady-State Solutions — QuTiP 4.2 Documentation; Using Tensor Products and Partial Traces — QuTiP 4.2 Documentation; Visualization of quantum states and processes — QuTiP 4.2 Documentation. /images; ; qutip_tree.pdf. QuTiP: Quantum Toolbox in Python (4.2) — QuTiP 4.2 Documentation; Installation — QuTiP 4.2 Documentation. /modules; . /qutip; . /control; ; qutip.control.dump — QuTiP 4.2 Documentation; qutip.control.dynamics — QuTiP 4.2 Documentation; qutip.control.fidcomp — QuTiP 4.2 Documentation; qutip.control.optimizer — QuTiP 4.2 Documentation; qutip.control.optimresult — QuTiP 4.2 Documentation; qutip.control.propcomp — QuTiP 4.2 Documentation; qutip.control.pulsegen — QuTiP 4.2 Documentation; qutip.control.pulseoptim — QuTiP 4.2 Documentation; qutip.control.stats — QuTiP 4.2 Documentation; qutip.control.termcond — QuTiP 4.2 Documentation; qutip.control.tslotcomp — QuTiP 4.2 Documentation. /nonmarkov; ; qutip.nonmarkov.heom — QuTiP 4.2 Documentation; qutip.nonmarkov.memorycascade — QuTiP 4.2 Documentation; qutip.nonmarkov.transfertensor — QuTiP 4.2 Documentation. /qip; . /algorithms; ; qutip.qip.algorithms.qft — QuTiP 4.2 Documentation. /models; ; qutip.qip.models.circuitprocessor — QuTiP 4.2 Documentation; qutip.qip.models.cqed — QuTiP 4.2 Documentation; qutip.qip.models.spinchain — QuTiP 4.2 Documentation. qutip.qip.circuit — QuTiP 4.2 Documentation; qutip.qip.gates — QuTiP 4.2 Documentation; qutip.qip.qubits — QuTiP 4.2 Documentation. qutip.about — QuTiP 4.2 Documentation; qutip.bloch — QuTiP 4.,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/index-wcopy.html:24015,optimiz,optimizer,24015,index-wcopy.html,https://qutip.org,https://qutip.org/index-wcopy.html,1,['optimiz'],['optimizer']
Performance, Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Gallery; Quantum Information Processing. API documentation; Classes; Qobj; QobjEvo; eseries; Bloch sphere; Distributions; Cubic Spline; Non-Markovian Solvers; Solver Options and Results; Permutational Invariance; One-Dimensional Lattice; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and ,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/index.html:2640,load,loading,2640,docs/4.6/index.html,https://qutip.org,https://qutip.org/docs/4.6/index.html,2,['load'],['loading']
Performance," In [4]: qsave(rho_ss, 'steadystate'). In [5]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [6]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = [10, 10], type = oper, isHerm = True. In [7]: a = destroy(10). In [8]: expect(a.dag() * a, rho_ss_loaded); Out[8]: 0.9902248289345018. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [9]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [10]: psi0 = rand_ket(10). In [11]: times = np.linspace(0, 10, 10). In [12]: dm_list = mesolve(H, psi0, times, c_ops, []). In [13]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [14]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [15]: a = destroy(10). In [16]: expect(a.dag() * a, dm_list_loaded.states); Out[16]: ; array([ 3.87543797, 3.11893669, 2.5717301 , 2.17012827, 1.87240607,; 1.65062668, 1.48498272, 1.36107052, 1.26828395, 1.19875921]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store take",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-saving.html:4081,load,loaded,4081,docs/3.0.0/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-saving.html,1,['load'],['loaded']
Performance," In [4]: qsave(rho_ss, 'steadystate'). In [5]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [6]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = [10, 10], type = oper, isHerm = True. In [7]: a = destroy(10). In [8]: expect(a.dag() * a, rho_ss_loaded); Out[8]: 0.9902248289345064. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [9]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [10]: psi0 = rand_ket(10). In [11]: times = np.linspace(0, 10, 10). In [12]: dm_list = mesolve(H, psi0, times, c_ops, []). In [13]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [14]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [15]: a = destroy(10). In [16]: expect(a.dag() * a, dm_list_loaded.states); Out[16]: ; array([ 5.05864971, 3.933244 , 3.16570274, 2.60846057, 2.19781898,; 1.8930801 , 1.66604188, 1.49648702, 1.36966702, 1.27471483]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/guide-saving.html:4143,load,loaded,4143,docs/3.0.1/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-saving.html,1,['load'],['loaded']
Performance," K. Kaya, and B. Ucar, “Design, Implementation, and; Analysis of Maximum Transversal Algorithms”, ACM Trans. Math. Softw.; 38, no. 2, (2011). weighted_bipartite_matching(A, perm_type='row')[source]¶; Returns an array of row permutations that attempts to maximize; the product of the ABS values of the diagonal elements in; a nonsingular square CSC sparse matrix. Such a permutation is; always possible provided that the matrix is nonsingular.; This function looks at both the structure and ABS values of the; underlying matrix. Parameters. Acsc_matrixInput matrix. perm_typestr {‘row’, ‘column’}Type of permutation to generate. Returns. permarrayArray of row or column permutations. Notes; This function uses a weighted maximum cardinality bipartite matching; algorithm based on breadth-first search (BFS). The columns are weighted; according to the element of max ABS value in the associated rows and; are traversed in descending order by weight. When performing the BFS; traversal, the row associated to a given column is the one with maximum; weight. Unlike other techniques[1]_, this algorithm does not guarantee the; product of the diagonal is maximized. However, this limitation is offset; by the substantially faster runtime of this method.; References; I. S. Duff and J. Koster, “The design and use of algorithms for; permuting large entries to the diagonal of sparse matrices”, SIAM J.; Matrix Anal. and Applics. 20, no. 4, 889 (1997). Utility Functions¶; This module contains utility functions that are commonly needed in other; qutip modules. n_thermal(w, w_th)[source]¶; Return the number of photons in thermal equilibrium for an harmonic; oscillator mode with frequency ‘w’, at the temperature described by; ‘w_th’ where \(\omega_{\rm th} = k_BT/\hbar\). Parameters. wfloat or arrayFrequency of the oscillator. w_thfloatThe temperature in units of frequency (or the same units as w). Returns. n_avgfloat or arrayReturn the number of average photons in thermal equilibrium for a; an oscil",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:203383,perform,performing,203383,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['perform'],['performing']
Performance," Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. « Parallel computa... Generating Rando... ». Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.filei",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-saving.html:1587,load,loading,1587,docs/3.1.0/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-saving.html,2,['load'],['loading']
Performance," Moreover initial guesses, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, ...) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-control.html:12961,optimiz,optimization,12961,docs/4.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-control.html,1,['optimiz'],['optimization']
Performance," Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Performance (QuTiP vs. qotoolbox); Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Running Problems in Parallel; QuTiP’s Built-in Parallel for-loop; IPython-Based parfor; Parallel picloud Computations. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/guide.html:3185,load,loading,3185,docs/3.0.1/guide/guide.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide.html,2,['load'],['loading']
Performance," Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Performance (QuTiP vs. qotoolbox); Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Running Problems in Parallel; QuTiP’s Built-in Parallel for-loop; IPython-Based parfor; Parallel picloud Computations. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 17, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide.html:3123,load,loading,3123,docs/3.0.0/guide/guide.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide.html,2,['load'],['loading']
Performance," Q.tr() is now faster for small Hilbert space dimensions. Bug Fixes¶. Fixed bug in trace-norm for non-Hermitian operators. Version 4.2.0 (July 28, 2017)¶. Improvements¶. MAJOR FEATURE: Initial implementation of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization. This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputing a list. with Python functions as time-dependence. Fixed non-int issue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/changelog.html:2452,load,loading,2452,docs/4.2/changelog.html,https://qutip.org,https://qutip.org/docs/4.2/changelog.html,1,['load'],['loading']
Performance," Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Performance (QuTiP vs. qotoolbox). « Floquet Formalis... Setting Options ... ». Performance (QuTiP vs. qotoolbox)¶; Here we compare the performance of the master equation and Monte Carlo solvers to their quantum optics toolbox counterparts.; In this example, we calculate the time evolution of the density matrix for a coupled oscillator system using the qutip.mesolve function, and compare it to the quantum optics toolbox (qotoolbox). Here, we see that the QuTiP solver out performs its qotoolbox counterpart by a substantial margin as the system size increases. To test the Monte Carlo solvers, here we simulate a trilinear Hamiltonian over a range of Hilbert space sizes. Since QuTiP uses multiprocessing, we can measure the performance gain when using several CPU’s. In contrast, the qotoolbox is limited to a single processor only. In the legend, we show the speed-up factor in the parenthesis, which should ideally be equal to the number of processors. Finally, we have included the results using hyperthreading, written here as 4+(x) where x is the number of hyperthreads, found in some newer Intel processors. We see however that the performance benefits from hy",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-performance.html:1634,perform,performance,1634,docs/3.0.1/guide/dynamics/dynamics-performance.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-performance.html,1,['perform'],['performance']
Performance," RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. optim_method : string; A ``scipy.optimize.minimize`` method that will be used to optimise the; pulse for minimum fidelity error Note that ``FMIN``, ``FMIN_BFGS`` &; ``FMIN_L_BFGS_B`` will all result in calling these specific; scipy.optimize methods Note the ``LBFGSB`` is equivalent to; ``FMIN_L_BFGS_B`` for backwards compatibility reasons. Supplying; ``DEF`` will given algorithm-dependent result:. - GRAPE - Default ``optim_method`` is FMIN_L_BFGS_B; - CRAB - Default ``optim_method`` is FMIN. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~qutip.control.optimizer.Optimizer` object or; the ``termination_conditions`` matching the key that attribute.; Otherwise, and in some case also, they are assumed to be; method_options for the ``scipy.optimize.minimize`` method. optim_alg : string; Deprecated. Use ``optim_method``. max_metric_corr : integer; Deprecated. Use ``method_params`` instead. accuracy_factor : float; Deprecated. Use ``method_params`` instead. phase_option : string; Determines how global phase is treated in fidelity calculations; (``fid_type='UNIT'`` only). Options:. - PSU - global phase ignored; - SU - global phase included. dyn_params : dict; Parameters for the :obj:`~qutip.control.dynamics.Dynamics` object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_params : dict; Parameters for the :obj:`~qutip.control.propcomp.PropagatorComputer`; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. fid_params",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:22155,optimiz,optimizer,22155,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimizer']
Performance," Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. « Guide Overview. Manipulating Sta... ». Basic Operations on Quantum Objects¶. First things first¶. Important; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the Numpy and Matplotlib libraries with:; In [2]: import numpy as np. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt or a Python script. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsulating the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this using matrix r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-basics.html:1889,load,load,1889,docs/3.0.0/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-basics.html,1,['load'],['load']
Performance," Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. « Basic Operations... Using Tensor Pro... ». Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the tutorials web page. State Vectors (kets or bras)¶; Here we begin by creating a Fock qutip.states.basis vacuum state vector \(\left|0\right>\) with in a Hilbert space with 5 number states, from 0 to 4:; In [1]: vac = basis(5, 0). In [2]: vac; Out[2]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. and then create a lowering operator \(\left(\hat{a}\right)\) corresponding to 5 number states using the qutip.operators.destroy function:; In [3]: a = destroy(5). In [4]: a; Out[4]: ; Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isherm = False; Qobj data =; [[ 0. 1. 0. 0. 0. ]; [ 0. 0. 1.41421356 0. 0. ]; [ 0. 0. 0. 1.73205081 0. ]; [ 0. 0. 0. 0. 2. ]; [ 0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state vac,; In [5]: a * vac; Out[5",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-states.html:2013,perform,performing,2013,docs/3.1.0/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-states.html,1,['perform'],['performing']
Performance," The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object,; e.g. optimizer.dynamics.fid_computer The optimisation can be run; through the optimizer.run_optimization. """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""). # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""). if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in method_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:58264,optimiz,optimizer,58264,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimizer']
Performance," Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refine : int {10}; MKL ONLY. Max. number of iterative refinements to perform. scaling_vectors : bool {True, False}; MKL ONLY. Scale matrix to unit norm columns and rows. weighted_matching : bool {True, False}; MKL ONLY. Use weighted matching to better condition diagonal. x0 : ndarray, optional; ITERATIVE ONLY. Initial guess for solution vector. maxiter : int, optional, default=1000; ITERATIVE ONLY. Maximum number of iterations to perform. tol : float, optional, default=1e-12; ITERATIVE ONLY. Tolerance used for terminating solver. mtol : float, optional, default=None; ITERATIVE 'power' methods ONLY. Tolerance for lu solve method.; If None given then `max(0.1*tol, 1e-15)` is used. matol : float, optional, default=1e-15; ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_spec : str, optional, default='COLAMD'; ITERATIVE ONLY. Column ordering used internally by superLU for the; 'direct' LU decomposition method. Options include 'COLAMD' and; 'NATURAL'. If using RCM then this is set to 'NATURAL' automatically; unless explicitly specified. use_precond : bool optional, default = False; ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the 'iterative' GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional; ITERATIVE ONLY. Preconditioner for A. The preconditioner should; a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:7252,perform,perform,7252,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,3,['perform'],['perform']
Performance," Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q – A new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Return type:Qobj. Notes; Experimental. full(squeeze=False)[source]¶; Dense array from quantum object. Returns:data – Array of complex data from quantum objects data attribute. Return type:array. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters:; sparse (bool) – Use sparse Eigensolver; tol (float) – Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter (int) – Maximum number of iterations performed by sparse solver (if used).; safe (bool (default=True)) – Check for degenerate ground state. Returns:; eigval (float) – Eigenvalue for the ground state of quantum operator.; eigvec (qobj) – Eigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:; bra (qobj) – Quantum object of type ‘bra’.; ket (qobj) – Quantum object of type ‘ket’. Returns:elem – Complex valued matrix element. Return type:complex. Raises:TypeError – Can only calculate matrix elements between a bra and ket; quantum object. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:10385,perform,performed,10385,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['perform'],['performed']
Performance," What if instead of just making; a single measurement, we want to determine the probability distribution of; a large number of measurements?; One way would be to repeat the measurement many times – and this is what; happens in many quantum experiments. In QuTiP one could simulate this using:; results = {1.0: 0, -1.0: 0} # 1 and -1 are the possible outcomes; for _ in range(1000):; value, new_state = measure(up, spin_x); results[round(value)] += 1; print(results). Output:; {1.0: 497, -1.0: 503}. which measures the x-component of the spin of the up state 1000 times and; stores the results in a dictionary. Afterwards we expect to have seen the; result 1.0 (i.e. left) roughly 500 times and the result -1.0 (i.e. right); roughly 500 times, but, of course, the number of each will vary slightly; each time we run it.; But what if we want to know the distribution of results precisely? In a; physical system, we would have to perform the measurement many many times,; but in QuTiP we can peak at the state itself and determine the probability; distribution of the outcomes exactly in a single line:; >>> eigenvalues, eigenstates, probabilities = measurement_statistics(up, spin_x). >>> eigenvalues ; array([-1., 1.]). >>> eigenstates ; array([Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 0.70710678]; [-0.70710678]],; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.70710678]; [0.70710678]]], dtype=object). >>> probabilities ; [0.5000000000000001, 0.4999999999999999]. The measurement_statistics function then returns three values; when called with a single observable:. eigenvalues is an array of eigenvalues of the measurement operator, i.e.; a list of the possible measurement results. In our example; the value is array([-1., -1.]).; eigenstates is an array of the eigenstates of the measurement operator, i.e.; a list of the possible final states after the measurement is complete.; Each element of the array is a Qobj.; probab",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-measurement.html:8031,perform,perform,8031,docs/4.6/guide/guide-measurement.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-measurement.html,2,['perform'],['perform']
Performance," \(\ket{1}\bra{1} \otimes I\).; PZ1 = [tensor(Z0, identity(2)), tensor(Z1, identity(2))]. PZ2 = [tensor(identity(2), Z0), tensor(identity(2), Z1)]. Now, as in the previous example, we can measure by supplying a list of projection operators; and the state.; measure(state_0plus, PZ1) == (0, state_0plus). The output of the measurement is the index of the measurement outcome as well; as the output state on the full Hilbert space of the input state. It is crucial to; note that we do not discard the measured qubit after measurement (as opposed to; when measuring on quantum hardware). Note; When measure is invoked with the second argument; being a list of projectors, it acts as an alias to; measure_povm. The measure function can perform measurements on; density matrices too. You can read about these and other details at; measure_povm and measure_observable.; Now you know how to measure quantum states in QuTiP!. Obtaining measurement statistics(Observable)¶; You’ve just learned how to perform measurements in QuTiP, but you’ve also; learned that measurements are probabilistic. What if instead of just making; a single measurement, we want to determine the probability distribution of; a large number of measurements?; One way would be to repeat the measurement many times – and this is what; happens in many quantum experiments. In QuTiP one could simulate this using:; results = {1.0: 0, -1.0: 0} # 1 and -1 are the possible outcomes; for _ in range(1000):; value, new_state = measure(up, spin_x); results[round(value)] += 1; print(results). Output:; {1.0: 497, -1.0: 503}. which measures the x-component of the spin of the up state 1000 times and; stores the results in a dictionary. Afterwards we expect to have seen the; result 1.0 (i.e. left) roughly 500 times and the result -1.0 (i.e. right); roughly 500 times, but, of course, the number of each will vary slightly; each time we run it.; But what if we want to know the distribution of results precisely? In a; physical system, we woul",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-measurement.html:7072,perform,perform,7072,docs/4.7/guide/guide-measurement.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html,1,['perform'],['perform']
Performance," \(\ket{1}\bra{1} \otimes I\).; PZ1 = [tensor(Z0, identity(2)), tensor(Z1, identity(2))]. PZ2 = [tensor(identity(2), Z0), tensor(identity(2), Z1)]. Now, as in the previous example, we can measure by supplying a list of projection operators; and the state.; measure(state_0plus, PZ1) == (0, state_0plus). The output of the measurement is the index of the measurement outcome as well; as the output state on the full hilbert space of the input state. It is crucial to; note that we do not discard the measured qubit after measurement (as opposed to; when measuring on quantum hardware). Note; When measure is invoked with the second argument; being a list of projectors, it acts as an alias to; measure_povm. The measure function can perform measurements on; density matrices too. You can read about these and other details at; measure_povm and measure_observable.; Now you know how to measure quantum states in QuTiP!. Obtaining measurement statistics(Observable)¶; You’ve just learned how to perform measurements in QuTiP, but you’ve also; learned that measurements are probabilistic. What if instead of just making; a single measurement, we want to determine the probability distribution of; a large number of measurements?; One way would be to repeat the measurement many times – and this is what; happens in many quantum experiments. In QuTiP one could simulate this using:; results = {1.0: 0, -1.0: 0} # 1 and -1 are the possible outcomes; for _ in range(1000):; value, new_state = measure(up, spin_x); results[round(value)] += 1; print(results). Output:; {1.0: 497, -1.0: 503}. which measures the x-component of the spin of the up state 1000 times and; stores the results in a dictionary. Afterwards we expect to have seen the; result 1.0 (i.e. left) roughly 500 times and the result -1.0 (i.e. right); roughly 500 times, but, of course, the number of each will vary slightly; each time we run it.; But what if we want to know the distribution of results precisely? In a; physical system, we woul",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-measurement.html:7012,perform,perform,7012,docs/4.6/guide/guide-measurement.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-measurement.html,1,['perform'],['perform']
Performance," \(\sigma_x \sigma_x + \sigma_y \sigma_y\). This processor will first decompose the gate into the universal gate set with ISWAP and SQRTISWAP as two-qubit gates, resolve them into quantum gates of adjacent qubits and then calculate the pulse coefficients. DispersivecQED¶; Same as above, qutip.qip.device.DispersivecQED is a simulator based on Cavity Quantum Electrodynamics. The workflow is similar to the one for the spin chain, except that the component systems are a multi-level cavity and a qubits system. The control Hamiltonians are the single-qubit rotation together with the qubits-cavity interaction \(a^{\dagger} \sigma^{-} + a \sigma^{+}\). The device parameters including the cavity frequency, qubits frequency, detuning and interaction strength etc. OptPulseProcessor¶; The qutip.qip.device.OptPulseProcessor uses the function in qutip.control.pulseoptim.optimize_pulse_unitary in the optimal control module to find the control pulses. The Hamiltonian includes a drift part and a control part and only the control part will be optimized. The unitary evolution follows. \[U(\Delta t)=\exp(\rm{i} \cdot \Delta t [H_d + \sum_j u_j H_j] )\]; To let it find the optimal pulses, we need to give the parameters for qutip.control.pulseoptim.optimize_pulse_unitary as keyword arguments to qutip.qip.device.OptPulseProcessor.load_circuit. Usually the minimal requirements are the evolution time evo_time and the number of time slices num_tslots for each gate. Other parameters can also be given in the keyword arguments. For available choices, see qutip.control.pulseoptim.optimize_pulse_unitary. It is also possible to specify different parameters for different gates, as shown in the following example:; >>> from qutip.qip.device import OptPulseProcessor; >>> from qutip.operators import sigmaz, sigmax, sigmay; >>> from qutip.tensor import tensor; >>>; >>> # Same parameter for all the gates; ... qc = QubitCircuit(N=1); >>> qc.add_gate(""SNOT"", 0); >>>; >>> num_tslots = 10; >>> evo_time = 10;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-qip.html:11344,optimiz,optimized,11344,docs/4.5/guide/guide-qip.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-qip.html,1,['optimiz'],['optimized']
Performance," a complex open quantum system"", ; Comput. Phys. Commun. 220, 81 (2017). 223. Lahoz-Beltra, ""Quantum Genetic Algorithms for Computer Scientists"", ; Computers 5, 24 (2016). 222. Davis-Tilley et al., ""Synchronization of micromasers"", ; Phys. Rev. A 94, 063819 (2016). 221. Weinberg et al., ""QuSpin: a Python package for dynamics and exact diagonalisation of quantum many body systems part I: spin chains"", ; SciPost Phys. 2, 003 (2017). 220. Dory et al., ""Tuning the photon statistics of a strongly coupled nanophotonic system"", ; Phys. Rev. A 95, 023804 (2017). 219. Lachance-Quirion et al., ""Resolving quanta of collective spin excitations in a millimeter-sized ferromagnet"", ; Science Advances 3, (2017). 218. Doyeux et al., ""Excitation injector in an atomic chain: Long-range transport and efficiency amplification"", ; Phys. Rev. A 95, 012138 (2017). 217. Roulet et al., ""Autonomous Rotor Heat Engine"", ; Phys. Rev. E 95, 062131 (2017). 216. Nigg et al., ""Robust quantum optimizer with full connectivity"", ; Science Advances 3, 1602273 (2017). 215. Puri et al., ""Quantum annealing with all-to-all connected nonlinear oscillators"", ; Nat. Commun. 8, 15785 (2017).>. 214. Shi et al., ""Model reduction of cavity nonlinear optics for photonic logic: a quasi-principal components approach"", ; J. Phys. D: Appl. Phys. 49, 465501 (2016). 213. McNally et al., ""Performance of 1D quantum cellular automata in the presence of error"", ; AIP Advances 6, 095115 (2016). 212. Zhong et al., ""Towards quantum entanglement of micromirrors via a two-level atom and radiation pressure"", ; arXiv:1609.00590. 211. Roth et al., ""Synchronization of active atomic clocks via quantum and classical channels"", ; Phys. Rev. A 94, 043841 (2016). 210. Jarlov et al., ""Effect of Pure Dephasing and Phonon Scattering on the Coupling of Semiconductor Quantum Dots to Optical Cavities"", ; Phys. Rev. Lett. 117, 076801 (2016). 209. Mahajan et al., ""Entanglement structure of non-equilibrium steady states"", ; arXiv:1608.05074. 208. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:20412,optimiz,optimizer,20412,users.html,https://qutip.org,https://qutip.org/users.html,1,['optimiz'],['optimizer']
Performance," a development debugging; but could be used for status information during a long optimisation. dumpingstringThe level of data dumping that will occur during the optimisation. dump_to_fileboolIf set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dirstringBasically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summaryOptimIterSummarySummary of the most recent iteration.; Note this is only set if dummping is on. apply_method_params(params=None)[source]¶; Loops through all the method_params; (either passed here or the method_params attribute); If the name matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. property dumping¶; The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the curre",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:191492,optimiz,optimize,191492,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['optimiz'],['optimize']
Performance," a leaky cavity with three different relaxation rates.; times = np.linspace(0,10.0,200); a = destroy(10); x = a.dag() + a; H = a.dag() * a. corr1 = correlation_2op_1t(H, None, times, [np.sqrt(0.5) * a], x, x); corr2 = correlation_2op_1t(H, None, times, [np.sqrt(1.0) * a], x, x); corr3 = correlation_2op_1t(H, None, times, [np.sqrt(2.0) * a], x, x). plt.figure(); plt.plot(times, np.real(corr1), times, np.real(corr2), times, np.real(corr3)); plt.legend(['0.5','1.0','2.0']); plt.xlabel(r'Time $t$'); plt.ylabel(r'Correlation $\left<x(t)x(0)\right>$'); plt.show(). (png, hires.png, pdf)¶. (png, hires.png, pdf)¶. Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using one of the time-dependent solvers and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; import numpy as np; from matplotlib import pyplot; import qutip. N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * np.pi # cavity and atom frequency; g = 0.1 * 2 * np.pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = qutip.tensor(qutip.destroy(N), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(N), qutip.destroy(2)); H = wc*a.dag()*a + wa*sm.dag()*sm + g*(a.dag()*sm + a*sm.dag()). # collapse operators; n_th = 0.25; c_ops = [; np.sqrt(kappa * (1 + n_th)) * a,; np.sqrt(kappa * n_th) * a.dag(),; np.sqrt(gamma) * sm,; ]. # calculate the correlation function using the mesolve",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-correlation.html:4851,perform,performs,4851,docs/4.6/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-correlation.html,1,['perform'],['performs']
Performance," a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:. BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm. This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS. This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import functools; import numpy as np; import timeit; import warnings; from packaging.version import parse as _parse_version; import scipy; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. # Older versions of SciPy use the method numpy.ndarray.tostring(), whic",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:4093,optimiz,optimize,4093,docs/4.6/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html,2,['optimiz'],['optimize']
Performance," a work of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work.; “You” means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation.; “Publicly Perform” means to perform public recitations of the Work and to; communicate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images.; “Reproduce” means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws.; License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/copyright-1.html:5534,perform,perform,5534,docs/4.7/copyright-1.html,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html,10,['perform'],"['perform', 'performance', 'performances']"
Performance," a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum processor, Nature 567, 491 (2019). 3. Endo, S.C. Benjamin, Y. Li, Practical quantum error mitigation for near-future appli",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:2394,perform,perform,2394,docs/4.7/development/ideas/quantum-error-mitigation.html,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html,1,['perform'],['perform']
Performance," above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_typestringFidelity error (and fidelity error gradient) com",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:203988,optimiz,optimize,203988,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['optimiz'],['optimize']
Performance," above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_typestringFidelity error (and fidelity error gradient) com",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:216068,optimiz,optimize,216068,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['optimiz'],['optimize']
Performance," above. optim_paramsDictionaryThe key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_typestringFidelity error (and fidelity error gradient) com",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:178056,optimiz,optimize,178056,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['optimiz'],['optimize']
Performance," algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation. References; ----------; 1. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:4413,optimiz,optimization,4413,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,2,['optimiz'],['optimization']
Performance," all dependencies). Optional Installation Options¶. UMFPACK Linear Solver¶; As of SciPy 0.14+, the umfpack linear solver routines for solving large-scale sparse linear systems have been replaced due to licensing restrictions. The default method for all sparse linear problems is now the SuperLU library. However, scipy still includes the ability to call the umfpack library via the scikits.umfpack module. In our experience, the umfpack solver is 2-5x faster than the SuperLU routines, which is a very noticeable performance increase when used for solving steady state solutions. We have an updated scikits.umfpack module available at http://github.com/nonhermitian/umfpack that can be installed to have SciPy find and use the umfpack library. Optimized BLAS Libraries¶; QuTiP is designed to take advantage of some of the optimized BLAS libraries that are available for NumPy. At present, this includes the OPENBLAS and MKL libraries. If NumPy is built against these libraries, then QuTiP will take advantage of the performance gained by using these optimized tools. As these libraries are multi-threaded, you can change the number of threads used in these packages by adding:; >>> import os; >>> os.environ['OPENBLAS_NUM_THREADS'] = '4'; >>> os.environ['MKL_NUM_THREADS'] = '4'. at the top of your Python script files, or iPython notebooks, and then loading the QuTiP framework. If these commands are not present, then QuTiP automatically sets the number of threads to one. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; >>> import qutip.testing as qt; >>> qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that you have installed all of the required modules. See t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/installation.html:11939,perform,performance,11939,docs/3.1.0/installation.html,https://qutip.org,https://qutip.org/docs/3.1.0/installation.html,2,"['optimiz', 'perform']","['optimized', 'performance']"
Performance," all dependencies). Optional Installation Options¶. UMFPACK Linear Solver¶; As of SciPy 0.14+, the umfpack linear solver routines for solving large-scale sparse linear systems have been replaced due to licensing restrictions. The default method for all sparse linear problems is now the SuperLU library. However, scipy still includes the ability to call the umfpack library via the scikits.umfpack module. In our experience, the umfpack solver is 2-5x faster than the SuperLU routines, which is a very noticeable performance increase when used for solving steady state solutions. We have an updated scikits.umfpack module available at http://github.com/nonhermitian/umfpack that can be installed to have SciPy find and use the umfpack library. Optimized BLAS Libraries¶; QuTiP is designed to take advantage of some of the optimized BLAS libraries that are available for NumPy. At present, this includes the OPENBLAS and MKL libraries. If NumPy is built against these libraries, then QuTiP will take advantage of the performance gained by using these optimized tools. As these libraries are multi-threaded, you can change the number of threads used in these packages by adding:; >>> import os; >>> os.environ['OPENBLAS_NUM_THREADS'] = '4'; >>> os.environ['MKL_NUM_THREADS'] = '4'. at the top of your Python script files, or iPython notebooks, and then loading the QuTiP framework. If these commands are not present, then QuTiP automatically sets the number of threads to one. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; >>> import qutip.testing as qt; >>> qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that your have installed all of the required modules. See ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/installation.html:10950,perform,performance,10950,docs/3.0.1/installation.html,https://qutip.org,https://qutip.org/docs/3.0.1/installation.html,2,"['optimiz', 'perform']","['optimized', 'performance']"
Performance," all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:; rho : qutip.qobj; A density matrix. mask : list / array; A mask that selects which subsystems should be transposed. method : str; choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:; rho_pr: :class:`qutip.qobj`; A density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns:; concur : float; Concurrence. References. [1]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters:; rho : qobj; Density matrix of composite object. selB : int/list; Selected components for density matrix B. base : {e,2}; Base of logarithm. sparse : {False,True}; Use sparse eigensolver. Returns:; ent_cond : float; Value of conditional entropy. entropy_linear(rho)[source]¶; Linear entropy of a density matrix. Parameters:; rho : qobj; sensity matrix or ket/bra vector. Returns:; entropy : float; Linear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:44115,concurren,concurrence,44115,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,2,['concurren'],['concurrence']
Performance," amp_ubound : float or list of floats. upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float. Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float. Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer. Maximum number of iterations of the optimisation algorithm. max_wall_time : float. Maximum allowed elapsed time for the optimisation algorithm. optim_alg : string. Multi-variable optimisation algorithm; options are BFGS, LBFGSB; (see Optimizer classes for details). max_metric_corr : integer. The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float. Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; (used only in L-BFGS-B). dyn_type : string. Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). prop_type : string. Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). fid_type : string. Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FideliyComputer classes for d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:133130,optimiz,optimize,133130,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,2,['optimiz'],['optimize']
Performance," amp_ubound : float or list of floats. upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float. Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float. Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer. Maximum number of iterations of the optimisation algorithm. max_wall_time : float. Maximum allowed elapsed time for the optimisation algorithm. optim_alg : string. Multi-variable optimisation algorithm; options are BFGS, LBFGSB; (see Optimizer classes for details). max_metric_corr : integer. The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float. Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; (used only in L-BFGS-B). phase_option : string. determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. amp_update_mode : string. determines whether propagators are calculated; Options: DEF, ALL, DYNAMIC (needs work); DEF will use the default for the specific dyn_type; (See TimeslotComputer classes for details). init_pulse_type : string. type / shape of pulse(s) used to initialise the; the control amplitudes. Options include:. RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW. (see PulseGen classes for details). pulse_scaling : float. Linear scale factor for generated pulses;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:139671,optimiz,optimize,139671,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['optimiz'],['optimize']
Performance," amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. optim_alg : string; Multi-variable optimisation algorithm; options are BFGS, LBFGSB; (see Optimizer classes for details). max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; (used only in L-BFGS-B). dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FideliyComputer classes for d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:7622,optimiz,optimize,7622,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,2,['optimiz'],['optimize']
Performance," amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. optim_alg : string; Multi-variable optimisation algorithm; options are BFGS, LBFGSB; (see Optimizer classes for details). max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; (used only in L-BFGS-B). phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. amp_update_mode : string; determines whether propagators are calculated; Options: DEF, ALL, DYNAMIC (needs work); DEF will use the default for the specific dyn_type; (See TimeslotComputer classes for details). init_pulse_type : string; type / shape of pulse(s) used to initialise the; the control amplitudes. Options include:; RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW; (see PulseGen classes for details). pulse_scaling : float; Linear scale factor for generated pulses;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:16357,optimiz,optimize,16357,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimize']
Performance," and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. « Guide Overview. Manipulating Sta... ». Basic Operations on Quantum Objects¶. First things first¶. Important; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the Numpy and Matplotlib libraries with:; In [2]: import numpy as np. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt or a Python script. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsulating the properties of a quantum operator and ket/bra vect",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-basics.html:1784,load,load,1784,docs/3.0.0/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-basics.html,1,['load'],['load']
Performance," and qutip.parallel.parfor functions behaves differently:; While qutip.parallel.parallel_map only iterate over the values arguments, the qutip.parallel.parfor function simultaneously iterates over all arguments:; In [20]: def sum_diff(x, y, z=0): return x + y, x - y, z. In [21]: parfor(sum_diff, [1, 2, 3], [4, 5, 6], z=5.0); Out[21]: [array([5, 7, 9]), array([-3, -3, -3]), array([5., 5., 5.])]. In [22]: parallel_map(sum_diff, [1, 2, 3], task_args=(np.array([4, 5, 6]),), task_kwargs=dict(z=5.0)); Out[22]: ; [(array([5, 6, 7]), array([-3, -4, -5]), 5.0),; (array([6, 7, 8]), array([-2, -3, -4]), 5.0),; (array([7, 8, 9]), array([-1, -2, -3]), 5.0)]. Note that the keyword arguments can be anything you like, but the keyword values are not iterated over. The keyword argument num_cpus is reserved as it sets the number of CPU’s used by parfor. By default, this value is set to the total number of physical processors on your system. You can change this number to a lower value, however setting it higher than the number of CPU’s will cause a drop in performance. In qutip.parallel.parallel_map, keyword arguments to the task function are specified using task_kwargs argument, so there is no special reserved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; In [23]: import time. In [24]: def func(x): time.sleep(1). In [25]: result = parallel_map(func, range(50), progress_bar=True); 10.0%. Run time: 3.02s. Est. time left: 00:00:00:27; 20.0%. Run time: 5.02s. Est. time left: 00:00:00:20; 30.0%. Run time: 8.02s. Est. time left: 00:00:00:18; 40.0%. Run time: 10.02s. Est. time left: 00:00:00:15; 50.0%. Run time: 13.02s. Est. ti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-parfor.html:4749,perform,performance,4749,docs/4.5/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-parfor.html,1,['perform'],['performance']
Performance," be attribute name value pairs; They applied after the object is created. log_level : integer. level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean. if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt : Optimizer. Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitud",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/apidoc/functions.html:166644,optimiz,optimizer,166644,docs/4.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.1/apidoc/functions.html,1,['optimiz'],['optimizer']
Performance," be attribute name value pairs; They applied after the object is created. log_level : integer. level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean. if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt : Optimizer. Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:169059,optimiz,optimizer,169059,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,1,['optimiz'],['optimizer']
Performance," be recorded - FULL : All logs will be generated and dumped - CUSTOM : Some customised level of dumping When first set to CUSTOM this is equivalent to SUMMARY. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary : OptimIterSummary; Summary of the most recent iteration.; Note this is only set if dummping is on. apply_method_params(params=None)[source]¶; Loops through all the method_params; (either passed here or the method_params attribute); If the name matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. dumping¶. The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; varia",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:71739,optimiz,optimize,71739,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['optimiz'],['optimize']
Performance," by Neill Lambert, Anubhav Vardhan,; and Alexander Pitchford and is still available as; qutip.nonmarkov.dlheom_solver.HSolverDL and only directly provided; support for the Drude-Lorentz bath although there was the possibility of; sub-classing the solver to implement other baths.; A compatible interface using the current implementation is available under the; same name in qutip.nonmarkov.heom.HSolverDL. BoFiN-HEOM¶; BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP HSolverDL that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors were; Neill Lambert, Tarun Raheja, Shahnawaz Ahmed, and Alexander Pitchford.; BoFiN was written outside of QuTiP and is can still be found in its original; repository at https://github.com/tehruhn/bofin.; The construction of the right-hand side matrix for BoFiN was slow, so; BoFiN-fast, a hybrid C++ and Python implementation, was written that performed; the right-hand side construction in C++. It was otherwise identical to the; pure Python version. BoFiN-fast can be found at; https://github.com/tehruhn/bofin_fast.; BoFiN also came with an extensive set of example notebooks that are available; at https://github.com/tehruhn/bofin/tree/main/examples. Current implementation¶; The current implementation is a rewrite of BoFiN in pure Python. It’s; right-hand side construction has similar speed to BoFiN-fast, but is written; in pure Python. Built-in implementations of a variety of different baths; are provided, and a single solver is used for both fermionic and bosonic baths.; Multiple baths of the same kind (either fermionic or bosonic) may be; specified in a single problem, and there is good support for working with; the auxiliary density operator (ADO) state and extracting information from it.; The code was written by Neill Lambert and Simon Cross. Next ; Previous. © Copyright 2011 t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/heom/history.html:2346,perform,performed,2346,docs/4.7/guide/heom/history.html,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/history.html,1,['perform'],['performed']
Performance," c2=None, notrace=False)[source]¶; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters:blist : array_like. List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlist : array_like. list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float. time-delay. c1 : qutip.Qobj. system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : qutip.Qobj. system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notrace : bool {False}. If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns:: qutip.Qobj. time-propagator for computing field correlation function. propagator(t, tau, notrace=False)[source]¶; Compute propagator for time t and time-delay tau. Parameters:t : float. current time. tau : float. time-delay. notrace : bool {False}. If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; ——-; : :class:`qutip.Qobj`. time-propagator for reduced system dynamics. rhot(rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters:rho0 : qutip.Qobj. initial density matrix or state vector (ket). t : float. current time. tau : float. time-delay. Returns:: qutip.Qobj. density matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:30581,perform,performed,30581,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['perform'],['performed']
Performance," calculations were taken from DYNAMO; (see file header). phase_option¶; string –. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm¶; complex – Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current¶; boolean – flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:95825,cache,cached,95825,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['cache'],['cached']
Performance," called for each value in task_vec. values : array / list. The list or array of values for which the task function is to be; evaluated. task_args : list / dictionary. The optional additional argument to the task function. task_kwargs : list / dictionary. The optional additional keyword argument to the task function. progress_bar : ProgressBar. Progress bar class instance for showing progress. Returns:result : list. The result list contains the value of; task(value, *task_args, **task_kwargs) for each; value in values. IPython Notebook Tools¶; This module contains utility functions for using QuTiP with IPython notebooks. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:task: a Python function. The function that is to be called for each value in task_vec. task_vec: array / list. The list or array of values for which the task function is to be; evaluated. args: list / dictionary. The optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.Client. The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view. The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False. Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_pr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:198021,load,load-balanced,198021,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['load'],['load-balanced']
Performance," class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:; from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-basics.html:1206,load,load,1206,docs/4.7/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-basics.html,1,['load'],['load']
Performance," computer the fidelity error and the fidelity error; gradient. memory_optimization¶; int – Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype¶; type – Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_gen¶; bool – If True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_grad¶; bool – If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj¶; bool – If True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp¶; bool – If True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:78188,perform,perform,78188,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,2,['perform'],['perform']
Performance," density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate.; There are opportunities to develop a more general spectral density code. Attributes. H_sysQobjSystem Hamiltonian. coup_opQobjOperator describing the coupling between system and bath. coup_strengthfloatCoupling strength. temperaturefloatBath temperature, in units corresponding to planck. N_cutintCutoff parameter for the bath. N_expintNumber of exponential terms used to approximate the bath correlation; functions. planckfloatreduced Planck constant. boltzmannfloatBoltzmann’s constant. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. statsqutip.solver.Statsoptional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coefflist of complexCoefficients for the exponential series terms. exp_freqlist of complexFrequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:37853,perform,performance,37853,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['perform'],['performance']
Performance," density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate.; There are opportunities to develop a more general spectral density code. Attributes. H_sysQobjSystem Hamiltonian. coup_opQobjOperator describing the coupling between system and bath. coup_strengthfloatCoupling strength. temperaturefloatBath temperature, in units corresponding to planck. N_cutintCutoff parameter for the bath. N_expintNumber of exponential terms used to approximate the bath correlation; functions. planckfloatreduced Planck constant. boltzmannfloatBoltzmann’s constant. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. statsqutip.solver.Statsoptional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coefflist of complexCoefficients for the exponential series terms. exp_freqlist of complexFrequencies for the exponential series terms. configure(self, H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:30828,perform,performance,30828,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['perform'],['performance']
Performance," described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file.; Optimizer; This acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm.; Dynamics; This is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators.; PulseGen; There are many subclasses of pulse generators that generate different types of pulses as",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-control.html:14751,load,loadparams,14751,docs/4.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-control.html,2,['load'],['loadparams']
Performance," dumping level or set directly. Note this is mainly intended for user and a development debugging but could be used for status information during a long optimisation. dump_to_file; (bool) If set True then data will be dumped to file during the optimisation dumping will be set to SUMMARY during init_optim if dump_to_file is True and dumping not set. Default is False. dump_dir; (string) Basically a link to dump.dump_dir. Exists so that it can be set through optim_params. If dump is None then will return None or will set dumping to SUMMARY when setting a path. iter_summary; (OptimIterSummary) Summary of the most recent iteration. Note this is only set if dummping is on. apply_method_params(params=None)[source]¶; Loops through all the method_params; (either passed here or the method_params attribute); If the name matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. dumping¶. The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; varia",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:60854,optimiz,optimize,60854,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['optimiz'],['optimize']
Performance," dyn.fid_computer.set_phase_option(phase_option). if isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer.scale_factor = fid_err_scale_factor. # Create the Optimiser instance; # The class of the object will determine which multivar optimisation; # algorithm is used; if optim_alg == 'BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_alg == 'LBFGSB':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_alg is None:; raise errors.UsageError(""Optimisation algorithm must be specified ""; ""via 'optim_alg' parameter""); else:; raise errors.UsageError(""No option for optim_alg: "" + optim_alg). # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc. if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that parameters have been supplied to generate the; # timeslot durations; try:; evo_time / num_tslots; except:; raise errors.UsageError(; ""Either the timeslot durations should be supplied as an ""; ""array 'tau' or the number of timeslots 'num_tslots' ""; ""and the evolution time 'evo_time' must be given.""). dyn.num_tslots = num_tslots; dyn.evo_time = evo_time; else:; dyn.tau = tau. # this function is called, so that the num_ctrls attribute will be set; dyn.get_num_ctrls(). # Create a pulse generator of the type specified; p_gen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn); p_gen.scaling = pulse_scaling; p_gen.offset =",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:30151,perform,performance,30151,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['perform'],['performance']
Performance," eigenvalues. tol : float. Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigvals: array :. Array of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters:sparse : bool. Use sparse Eigensolver. sort : str. Sort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvals : int. Number of requested eigenvalues. Default is all eigenvalues. tol : float. Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigvals : array. Array of eigenvalues for operator. eigvecs : array. Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eliminate_states(states_inds, normalize=False)¶; Creates a new quantum object with states in state_inds eliminated. Parameters:states_inds : list of integer. The states that should be removed. normalize : True / False. Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q : qutip.Qobj. A new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. .. note:",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/classes.html:5721,perform,performed,5721,docs/3.0.0/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html,2,['perform'],['performed']
Performance," elements removed. tr()¶; Trace of a quantum object. Returns:trace: float :. Returns real if operator is Hermitian, returns complex; otherwise. trans()¶; Transposed operator. Returns:oper : qobj. Transpose of input operator. transform(inpt, inverse=False)¶; Basis transform defined by input array.; Input array can be a matrix defining the transformation,; or a list of kets that defines the new basis. Parameters:inpt : array_like. A matrix or list of kets defining the transformation. inverse : bool. Whether to return inverse transformation. Returns:oper : qobj. Operator in new basis. Notes; This function is still in development. unit(norm=None, sparse=False, tol=0, maxiter=100000)¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters:norm : str. Requested norm for states / operators. sparse : bool. Use sparse eigensolver for trace norm. Does not affect other norms. tol : float. Tolerance used by sparse eigensolver. maxiter: int :. Number of maximum iterations performed by sparse eigensolver. Returns:oper : qobj. Normalized quantum object. eseries¶. class eseries(q=array(, []dtype=float64), s=array(, []dtype=float64))¶; Class representation of an exponential-series expansion of; time-dependent quantum objects.; Attributes. ampl; ndarray; Array of amplitudes for exponential series. rates; ndarray; Array of rates for exponential series. dims; list; Dimensions of exponential series components. shape; list; Shape corresponding to exponential series components. Methods. value(tlist); Evaluate an exponential series at the times listed in tlist. spec(wlist); Evaluate the spectrum of an exponential series at frequencies in wlist. tidyup(); Returns a tidier version of the exponential series. spec(wlist)¶; Evaluate the spectrum of an exponential series at frequencies; in wlist. Parameters:wlist : array_like. Array/list of frequenies. Returns:val_list : ndarray. Values of exponential series at frequencies in wlist. tidyup(*args)¶; Returns a tidier versi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/classes.html:13506,perform,performed,13506,docs/3.0.0/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html,2,['perform'],['performed']
Performance," error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; ; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:9137,optimiz,optimize,9137,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,6,['optimiz'],['optimize']
Performance," error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm; ; alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; - GRAPE - Default optim_method is FMIN_L_BFGS_B; - CRAB - Default optim_method is Nelder-Mead; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamic",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:53866,optimiz,optimize,53866,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,6,['optimiz'],['optimize']
Performance," et al., ""Realizing dipolar spin models with arrays of superconducting qubits"", ; Phys. Rev. B 92, 174507 (2015). 75. Neilinger et al., ""Two-photon lasing by a superconducting qubit"", ; Phys. Rev. B 91, 104516 (2015). 74. Elliott et al., ""Enhancement and state tomography of a squeezed vacuum with circuit quantum electrodynamics"", ; Phys. Rev. A 92, 013826 (2015). 73. Borregaard et al., ""Heralded Quantum Gates with Integrated Error Detection in Optical Cavities"", ; Phys. Rev. Lett. 114, 110502 (2015). 72. Killoran et al., ""Enhancing light-harvesting power with coherent vibrational interactions: a quantum heat engine picture"", ; J. Chem. Phys. 143, 155102 (2015). 71. Lu et al., ""Squeezed Optomechanics with Phase-Matched Amplification and Dissipation"", ; Phys. Rev. Lett. 114, 093602 (2015). 70. Hush et al., ""Spin correlations as a probe of quantum synchronization in trapped-ion phonon lasers"", ; Phys. Rev. A 91, 061401(R) (2015). 69. Hauke et al., ""Probing entanglement in adiabatic quantum optimization with trapped ions"", ; Front. Phys. 3, 21 (2015). 68. Nation et al., ""Iterative solutions to the steady-state density matrix for optomechanical systems"", ; Phys. Rev. E 91, 013307 (2015). 67. Schlawin et al., ""Nonlinear spectroscopy of trapped ions"", ; Phys. Rev. A 90, 023603 (2014). 66. Dunning et al., ""Composite pulses for interferometry in a thermal cold atom cloud"", ; Phys. Rev. A 90, 033608 (2014). 65. Rosado et al., ""Upper-bounded and sliced Jaynes- and anti-Jaynes-Cummings Hamiltonians and Liouvillians in cavity quantum electrodynamics"", ; J. Modern Optics 62, 1561 (2015). 64. Braumüller et al., ""Multiphoton dressing of an anharmonic superconducting many-level quantum circuit"", ; Phys. Rev. B 91, 054523 (2015). 63. Hu et al., ""Quantum coherence in ultrastrong optomechanics"", ; Phys. Rev. A 91, 013812 (2015). 62. Weimer, ""Variational Principle for Steady States of Dissipative Quantum Many-Body Systems"", ; Phys. Rev. Lett. 114, 040402 (2015). 61. Ardelt et al., ""Diss",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:40305,optimiz,optimization,40305,users.html,https://qutip.org,https://qutip.org/users.html,1,['optimiz'],['optimization']
Performance," factorial was moved to scipy.misc module.; Added tidyup function to tensor function output.; Removed openmp flags from setup.py as new Mac Xcode compiler does not recognize them.; Qobj diag method now returns real array if all imaginary parts are zero.; Examples GUI now links to new documentation.; Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011)¶. Bug Fixes¶. Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011)¶; THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE. New Functions¶. Added linear entropy function.; Number of CPU’s can now be changed. Bug Fixes¶. Metrics no longer use dense matrices.; Fixed Bloch sphere grid issue with matplotlib 1.1.; Qobj trace operation uses only sparse matrices.; Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011)¶; THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED. New Functions¶. tidyup function to remove small elements from a Qobj.; Added concurrence function.; Added simdiag for simultaneous diagonalization of operators.; Added eigenstates method returning eigenstates and eigenvalues to Qobj class.; Added fileio for saving and loading data sets and/or Qobj’s.; Added hinton function for visualizing density matrices. Bug Fixes¶. Switched Examples to new Signals method used in PySide 1.0.6+.; Switched ProgressBar to new Signals method.; Fixed memory issue in expm functions.; Fixed memory bug in isherm.; Made all Qobj data complex by default.; Reduced ODE tolerance levels in Odeoptions.; Fixed bug in ptrace where dense matrix was used instead of sparse.; Fixed issue where PyQt4 version would not be displayed in about box.; Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011)¶. Initial release. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/changelog.html:12881,concurren,concurrence,12881,docs/3.0.1/changelog.html,https://qutip.org,https://qutip.org/docs/3.0.1/changelog.html,2,"['concurren', 'load']","['concurrence', 'loading']"
Performance," factorial was moved to scipy.misc module.; Added tidyup function to tensor function output.; Removed openmp flags from setup.py as new Mac Xcode compiler does not recognize them.; Qobj diag method now returns real array if all imaginary parts are zero.; Examples GUI now links to new documentation.; Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011)¶. Bug Fixes¶. Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011)¶; THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE. New Functions¶. Added linear entropy function.; Number of CPU’s can now be changed. Bug Fixes¶. Metrics no longer use dense matrices.; Fixed Bloch sphere grid issue with matplotlib 1.1.; Qobj trace operation uses only sparse matrices.; Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011)¶; THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED. New Functions¶. tidyup function to remove small elements from a Qobj.; Added concurrence function.; Added simdiag for simultaneous diagonalization of operators.; Added eigenstates method returning eigenstates and eigenvalues to Qobj class.; Added fileio for saving and loading data sets and/or Qobj’s.; Added hinton function for visualizing density matrices. Bug Fixes¶. Switched Examples to new Signals method used in PySide 1.0.6+.; Switched ProgressBar to new Signals method.; Fixed memory issue in expm functions.; Fixed memory bug in isherm.; Made all Qobj data complex by default.; Reduced ODE tolerance levels in Odeoptions.; Fixed bug in ptrace where dense matrix was used instead of sparse.; Fixed issue where PyQt4 version would not be displayed in about box.; Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011)¶. Initial release. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/changelog.html:14781,concurren,concurrence,14781,docs/3.1.0/changelog.html,https://qutip.org,https://qutip.org/docs/3.1.0/changelog.html,2,"['concurren', 'load']","['concurrence', 'loading']"
Performance," factorial was moved to scipy.misc module.; Added tidyup function to tensor function output.; Removed openmp flags from setup.py as new Mac Xcode compiler does not recognize them.; Qobj diag method now returns real array if all imaginary parts are zero.; Examples GUI now links to new documentation.; Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011)¶. Bug Fixes¶. Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011)¶; THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE. New Functions¶. Added linear entropy function.; Number of CPU’s can now be changed. Bug Fixes¶. Metrics no longer use dense matrices.; Fixed Bloch sphere grid issue with matplotlib 1.1.; Qobj trace operation uses only sparse matrices.; Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011)¶; THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED. New Functions¶. tidyup function to remove small elements from a Qobj.; Added concurrence function.; Added simdiag for simultaneous diagonalization of operators.; Added eigenstates method returning eigenstates and eigenvalues to Qobj class.; Added fileio for saving and loading data sets and/or Qobj’s.; Added hinton function for visualizing density matrices. Bug Fixes¶. Switched Examples to new Signals method used in PySide 1.0.6+.; Switched ProgressBar to new Signals method.; Fixed memory issue in expm functions.; Fixed memory bug in isherm.; Made all Qobj data complex by default.; Reduced ODE tolerance levels in Odeoptions.; Fixed bug in ptrace where dense matrix was used instead of sparse.; Fixed issue where PyQt4 version would not be displayed in about box.; Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011)¶. Initial release. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 17, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/changelog.html:12216,concurren,concurrence,12216,docs/3.0.0/changelog.html,https://qutip.org,https://qutip.org/docs/3.0.0/changelog.html,2,"['concurren', 'load']","['concurrence', 'loading']"
Performance," float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPD",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:44829,optimiz,optimize,44829,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,6,['optimiz'],['optimize']
Performance," float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; Fidelity error (and fidelity error gradient",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:34193,optimiz,optimize,34193,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,6,['optimiz'],['optimize']
Performance," for ind1, ind2 in constraint_dependency:; self.nodes[ind1].successors.add(ind2); self.nodes[ind2].predecessors.add(ind1). # Update the start and end nodes of the graph; start = []; end = []; for i, instruction in enumerate(self.nodes):; if not instruction.successors:; end.append(i); if not instruction.predecessors:; start.append(i); self.start = start; self.end = end. [docs]class Scheduler():; """"""; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419. The scheduler includes two methods,; ""ASAP"", as soon as possible, and ""ALAP"", as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits. The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters; ----------; method: str; ""ASAP"" for as soon as possible.; ""ALAP"" for as late as possible.; constraint_functions: list, optional; A list of hardware constraint functions.; Default includes a function `qubit_contraint`,; i.e. one qubit cannot be used by two gates at the same time.; """"""; def __init__(self, method=""ALAP"", constraint_functions=None):; self.method = method; if constraint_functions is None:; self.constraint_functions = [qubit_constraint]; else:; return constraint_functions. [docs] def schedule(self, circuit, gates_schedule=False,; return_cycles_list=False, random_shuffle=False,; repeat_num=0):; """"""; Schedule a `QubitCircuit`,; a list of `Gates` or a list of `Instruction`.; For pulse schedule, the execution time for each `Instruction`; is given in its `duration` attributes. The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some oth",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:13062,optimiz,optimized,13062,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,2,['optimiz'],['optimized']
Performance," for which we have knowledge of the dynamical; maps \(E(t_k)\). tensors : array_like. optional list of precomputed tensors \(T_k\). kwargs : dictionary. Optional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns:output: qutip.solver.Result. An instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dyna",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:142237,optimiz,optimize,142237,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['optimiz'],['optimize']
Performance," for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.transfertensor.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dyna",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:210439,optimiz,optimize,210439,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['optimiz'],['optimize']
Performance," g * (x + iy)`, default `g = sqrt(2)`. method : string {'clenshaw', 'iterative', 'laguerre', 'fft'}; Select method 'clenshaw' 'iterative', 'laguerre', or 'fft', where 'clenshaw' ; and 'iterative' use an iterative method to evaluate the Wigner functions for density; matrices :math:`|m><n|`, while 'laguerre' uses the Laguerre polynomials; in scipy for the same task. The 'fft' method evaluates the Fourier; transform of the density matrix. The 'iterative' method is default, and; in general recommended, but the 'laguerre' method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The 'clenshaw' method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). 'clenshaw' is a fast and numerically stable method. sparse : bool {False, True}; Tells the default solver whether or not to keep the input density; matrix in sparse format. As the dimensions of the density matrix; grow, setthing this flag can result in increased performance.; ; parfor : bool {False, True}; Flag for calculating the Laguerre polynomial based Wigner function; method='laguerre' in parallel using the parfor function. Returns; -------. W : array; Values representing the Wigner function calculated over the specified; range [xvec,yvec]. yvex : array; FFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; -----; The 'fft' method accepts only an xvec input for the x-coordinate.; The y-coordinates are calculated internally. References; ----------. Ulf Leonhardt,; Measuring the Quantum State of Light, (Cambridge University Press, 1997). """""". if not (psi.type == 'ket' or psi.type == 'oper' or psi.type == 'bra'):; raise TypeError('Input state is not a valid operator.'). if method == 'fft':; return _wigner_fourier(psi, xvec, g). if psi.type == 'ket' or psi.type == 'bra':; rho = ket2dm(psi); else:; rho = psi. if method == 'iterative':; return _wigner_iterative(rho, xvec, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/wigner.html:4210,perform,performance,4210,docs/4.1/modules/qutip/wigner.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/wigner.html,5,['perform'],['performance']
Performance," has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate.; There are opportunities to develop a more general spectral density code. Attributes:; H_sys : Qobj; System Hamiltonian. coup_op : Qobj; Operator describing the coupling between system and bath. coup_strength : float; Coupling strength. temperature : float; Bath temperature, in units corresponding to planck. N_cut : int; Cutoff parameter for the bath. N_exp : int; Number of exponential terms used to approximate the bath correlation; functions. planck : float; reduced Planck constant. boltzmann : float; Boltzmann’s constant. options : qutip.solver.Options; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats : qutip.solver.Stats; optional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coeff : list of complex; Coefficients for the exponential series terms. exp_freq : list of complex; Frequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters:; options : qutip.solver.Options; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:25101,perform,performance,25101,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['perform'],['performance']
Performance," hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_gen : bool; If True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_grad : bool; If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: bool; If True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: bool; If True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_optimization<=1, otherwise False. num_tslots : integer; Number of timeslots (aka timeslices). num_ctrls : integer; Number of controls.; Note this is calculated as the length of ctrl_dyn_gen when first used.; And is recalculated during initialise_controls only. evo_time : float; Total time for the evolution. tau : array[num_tslots] of float; Duration of each timeslot; Note that if this is set before initialize_controls is called; then num_tslots",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:8967,cache,cache,8967,docs/4.6/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html,2,['cache'],['cache']
Performance," implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a; ; OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:4479,optimiz,optimize,4479,docs/4.5/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html,1,['optimiz'],['optimize']
Performance," in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Introduction. Introduction¶; Although in some cases, we want to find the stationary states of; a quantum system, often we are interested in the dynamics:; how the state of a system or an ensemble of systems evolves with time. QuTiP provides; many ways to model dynamics.; Broadly speaking, there are two categories; of dynamical models: unitary and non-unitary. In unitary evolution,; the state of the system remains normalized. In non-unitary, or; dissipative, systems, it does not.; There are two kinds of quantum systems: open systems that interact; with a larger environment and closed systems that do not.; In a closed system, the state can be described by a state vector,; although when there is entanglement a density matrix may be; needed instead. When we are modeling an open system, or an ensemble; of systems, the use of the density matrix is mandatory.; Collapse operators are used to model the collapse of the state vector; that can occur when a measurement is performed.; The following tables lists some of the solvers QuTiP provides for dynamic quantum systems and indicates the type of object; returned by the solver:. QuTiP Solvers¶. Solver; Returns; Remarks. sesolve(); qutip.solver.Result; Unitary evolution, single system. mesolve(); qutip.solver.Result; Lindblad master eqn. or Von Neuman eqn. Density matrix. mcsolve(); qutip.solver.Result; Monte Carlo with collapse operators. essolve(); Array of expectation values; Exponential series with collapse operators. bloch_redfield_solve(); qutip.solver. floquet_markov_solve(); qutip.solver.Result; Floquet-Markov master equation. fmmesolve(); qutip.solver; Floquet-Markov master equation. smesolve(); qutip.solver.Result; Stochastic master equation. ssesolve(); qutip.solver.Result; Stochastic Schrödinger equation. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built wit",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-intro.html:2234,perform,performed,2234,docs/4.7/guide/dynamics/dynamics-intro.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-intro.html,1,['perform'],['performed']
Performance," in the subclass. dump_summary : bool; If True a summary is recorded each time a new item is added to the; the dump.; Default is True. summary_sep : str; delimiter for the summary file.; default is a space. data_sep : str; delimiter for the data files (arrays saved to file).; default is a space. summary_file : str; File path for summary file.; Automatically generated. Can be set specifically. create_dump_dir()[source]¶; Checks dump directory exists, creates it if not. level¶. The level of data dumping that will occur. SUMMARY : A summary will be recorded; FULL : All possible dumping; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped. class OptimDump(optim, level='SUMMARY')[source]¶; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes:; dump_summary : bool; When True summary items are appended to the iter_summary. iter_summary : list of optimizer.OptimIterSummary; Summary at each iteration. dump_fid_err : bool; When True values are appended to the fid_err_log. fid_err_log : list of float; Fidelity error at each call of the fid_err_func. dump_grad_norm : bool; When True values are appended to the fid_err_log. grad_norm_log : list of float; Gradient norm at each call of the grad_norm_log. dump_grad : bool; When True values are appended to the grad_log. grad_log : list of ndarray; Gradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. dump_all¶; True if everything (ignoring the summary) is to be dumped. dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out to fil",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:125486,optimiz,optimizer,125486,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['optimiz'],['optimizer']
Performance," is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar duing the execution of the parfor; loop. Returns:; result : list; The result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. parallel_map(task, values, task_args=None, task_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:; task: a Python function; The function that is to be called for each value in task_vec. values: array / list; The list or array of values for which the task function is to be; evaluated. task_args: list / dictionary; The optional additional argument to the task function. task_kwargs: list / dictionary; The optional additional keyword argument to the task function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) wa",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:214577,load,load-balanced,214577,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['load'],['load-balanced']
Performance," is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(self, term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB.; Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:83852,optimiz,optimize,83852,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['optimiz'],['optimize']
Performance," is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimizati",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:70044,optimiz,optimize,70044,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['optimiz'],['optimize']
Performance," is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB.; Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimizat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:67049,optimiz,optimize,67049,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,3,['optimiz'],['optimize']
Performance," is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011). run_opti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:197695,optimiz,optimize,197695,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['optimiz'],['optimize']
Performance," largest quantum mechanical calculations. ; . In addition to custom algorithms, QuTiP is capable of leveraging the multiprocessing power inside every modern computer. Taking advantage of the Python multiprocessing library, OPENMP, SSE3 processor extensions, and the Intel MKL, if available, allows for faster manipulation of quantum objects, and increased performance of evolution equations, without any work at all.; . QuTiP includes a variety of builtin solvers for dynamical simulations. In addition to the standard Lindblad and Monte Carlo Solvers, QuTiP includes routines for Bloch-Redfield evolution, periodic systems using the Floquet formalism, and stochastic solvers. Add to this, steady state analysis and non-Markovian techniques, and you have a wide variety of tools from which to explore your systems behavior. A wide range of time-dependent evolution simulations can be runtime compiled into C++ behind the scenes using Cython. Thus, you get the ease of use of the Python programming language, and the performance of compiled code, all for free. What can be better than that?; . Can't express your time-dependence analytically, or need to construct a function from a data set? No problem. QuTiP allows for passing interpolating functions as time-dependent arguments to the evolution solvers. Even better, these interpolating functions can be runtime compiled into C++, and support both real and complex data.; . From Bloch spheres to nonlinear colormaps for Wigner functions, QuTiP includes a host of built-in visualization routines that help bring your data to life. Our plotting utilities have been used by Fortune 500 companies, government research labs, and countless research groups around the globe. If you don't look good, we don't look good. ; . QuTiP is thoroughly tested, both by its thousands of users, and by the large collection of built in test scripts. QuTiP includes over a thousand such tests, covering nearly all of the builtin functions. These tests are run over and ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/features.html:2015,perform,performance,2015,features.html,https://qutip.org,https://qutip.org/features.html,1,['perform'],['performance']
Performance," maxiter=100000); Returns normalized quantum object. checkherm()¶; Check if the quantum object is hermitian. Returns:isherm: bool :. Returns the new value of isherm property. conj()¶; Conjugate operator of quantum object. dag()¶; Adjoint operator of quantum object. diag()¶; Diagonal elements of quantum object. Returns:diags: array :. Returns array of real values if operators is Hermitian,; otherwise complex values are returned. eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)¶; Eigenenergies of a quantum object.; Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters:sparse : bool. Use sparse Eigensolver. sort : str. Sort eigenvalues ‘low’ to high, or ‘high’ to low. eigvals : int. Number of requested eigenvalues. Default is all eigenvalues. tol : float. Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigvals: array :. Array of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters:sparse : bool. Use sparse Eigensolver. sort : str. Sort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvals : int. Number of requested eigenvalues. Default is all eigenvalues. tol : float. Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigvals : array. Array of eigenvalues for operator. eigvecs : array. Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/classes.html:4924,perform,performed,4924,docs/3.0.0/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html,2,['perform'],['performed']
Performance," maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtypetypeData type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_genboolIf True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_gradboolIf the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: boolIf True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: boolIf True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_optimization<=1, otherwise False. num_tslotsintegerNumber of timeslots (aka timeslices). num_ctrlsintegercalculate the of controls from the length of the control list. evo_timefloatTotal time for the evolution. tauarray[num_tslots] of floatDuration of each timeslot; Note that if this is set before initialize_controls is called; then num_tslots and evo_time are calculated from tau, otherwise; tau is generated from num_tslots and evo_time, that is; equ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:92452,cache,cache,92452,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['cache'],['cache']
Performance, module qutip.qip.gates). Bloch (class in qutip.bloch). Bloch3d (class in qutip.bloch3d). bloch_redfield_solve() (in module qutip.bloch_redfield). bloch_redfield_tensor() (in module qutip.bloch_redfield). breadth_first_search() (in module qutip.graph). brmesolve() (in module qutip.bloch_redfield). build_preconditioner() (in module qutip.steadystate). bures_angle() (in module qutip.metrics). bures_dist() (in module qutip.metrics). C. checkherm() (Qobj method). CircuitProcessor (class in qutip.qip.models). CircularSpinChain (class in qutip.qip.models.spinchain). clear() (Bloch method). (Bloch3d method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). combine_dyn_gen() (Dynamics method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). concurrence() (in module qutip.entropy). conj() (Qobj method). controlled_gate() (in module qutip.qip.gates). convert_unit() (in module qutip.utilities). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_3op_1t() (in module qutip.correlation). correlation_3op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). covariance_matrix() (in module qutip.continuous_variables). cphase() (in module qutip.qip.gates). create() (in module qutip.operators). create_pulse_gen() (in module qutip.control.pulsegen). create_pulse_optimizer() (in module qutip.control.pulseoptim). cs,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/genindex.html:3117,concurren,concurrence,3117,docs/3.1.0/genindex.html,https://qutip.org,https://qutip.org/docs/3.1.0/genindex.html,1,['concurren'],['concurrence']
Performance," name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns:value_new_unit : float / array. The energy in the new unit. File I/O Functions¶. file_data_read(filename, sep=None)¶; Retrieves an array of data from the requested file. Parameters:filename : str. Name of file containing reqested data. sep : str. Seperator used to store data. Returns:data : array_like. Data from selected file. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=', ')¶; Stores a matrix of data to a file to be read by an external program. Parameters:filename : str. Name of data file to be stored, including extension. data: array_like :. Data to be written to file. numtype : str {‘complex, ‘real’}. Type of numerical data. numformat : str {‘decimal’,’exp’}. Format for written data. sep : str. Single-character field seperator. Usually a tab, space, comma,; or semicolon. qload(name)¶; Loads data file from file named ‘filename.qu’ in current directory. Parameters:name : str. Name of data file to be loaded. Returns:qobject : instance / array_like. Object retrieved from requested file. qsave(data, name='qutip_data')¶; Saves given data to file named ‘filename.qu’ in current directory. Parameters:data : instance/array_like. Input Python object to be stored. filename : str. Name of output data file. IPython Notebook Tools¶; This module contains utility functions for using QuTiP with IPython notebooks. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:task: a Python function :. The function that is to be called for each value in task_vec. task_vec: array / list :. Th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:107100,load,loaded,107100,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,2,['load'],['loaded']
Performance," name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""). # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""). if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in method_params:; method_params['accuracy_factor'] = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:58623,optimiz,optimizer,58623,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimizer']
Performance," name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); ; # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""); ; if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in method_params:; method_params['accuracy_facto",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:58705,optimiz,optimizer,58705,docs/4.2/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html,3,['optimiz'],['optimizer']
Performance," name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; if not isinstance(drift, Qobj):; if not isinstance(drift, (list, tuple)):; raise TypeError(""drift should be a Qobj or a list of Qobj""); else:; for d in drift:; if not isinstance(d, Qobj):; raise TypeError(""drift should be a Qobj or a list of Qobj""). if not isinstance(ctrls, (list, tuple)):; raise TypeError(""ctrls should be a list of Qobj""); else:; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""ctrls should be a list of Qobj""). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); ; # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:58801,optimiz,optimizer,58801,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,2,['optimiz'],['optimizer']
Performance," need to store both the real and imaginary parts, so instead we could use the numtype=”real” option:; In [26]: file_data_store('expect.dat', output_data.T, numtype=""real""). In [27]: !head -n5 expect.dat; # Generated by QuTiP: 100x4 real matrix in decimal format [',' separated values].; 0.0000000000,4.1806530217,-1.6468057879,-0.1184956481; 1.0101010101,3.3732071060,-0.7721165691,1.1079090288; 2.0202020202,2.8025239639,0.4712121856,1.0675527183; 3.0303030303,2.3752310795,1.0037440470,0.1395209926. and if we prefer scientific notation we can request that using the numformat=”exp” option; In [28]: file_data_store('expect.dat', output_data.T, numtype=""real"", numformat=""exp""). In [29]: !head -n 5 expect.dat; # Generated by QuTiP: 100x4 real matrix in exp format [',' separated values].; 0.0000000000e+00,4.1806530217e+00,-1.6468057879e+00,-1.1849564809e-01; 1.0101010101e+00,3.3732071060e+00,-7.7211656913e-01,1.1079090288e+00; 2.0202020202e+00,2.8025239639e+00,4.7121218559e-01,1.0675527183e+00; 3.0303030303e+00,2.3752310795e+00,1.0037440470e+00,1.3952099261e-01. Loading data previously stored using qutip.fileio.file_data_store (or some other software) is a even easier. Regardless of which deliminator was used, if data was stored as complex or real numbers, if it is in decimal or exponential form, the data can be loaded using the qutip.fileio.file_data_read, which only takes the filename as mandatory argument.; In [30]: input_data = file_data_read('expect.dat'). In [31]: shape(input_data); Out[31]: (100, 4). In [32]: from pylab import *. In [33]: plot(input_data[:,0], input_data[:,1]); # plot the data. (If a particularly obscure choice of deliminator was used it might be necessary to use the optional second argument, for example sep=”_” if _ is the deliminator). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-saving.html:8317,load,loaded,8317,docs/4.0.2/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-saving.html,1,['load'],['loaded']
Performance," normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns; -------; q : :class:`qutip.Qobj`; A new instance of :class:`qutip.Qobj` that contains only the states; corresponding to indices that are **not** in `state_inds`. Notes; -----; Experimental. """"""; keep_indices = np.array([s not in states_inds; for s in range(self.shape[0])]).nonzero()[0]. return self.extract_states(keep_indices, normalize=normalize). [docs] def dnorm(self, B=None):; """"""Calculates the diamond norm, or the diamond distance to another; operator. Parameters; ----------; B : :class:`qutip.Qobj` or None; If B is not None, the diamond distance d(A, B) = dnorm(A - B) between; this operator and B is returned instead of the diamond norm. Returns; -------; d : float; Either the diamond norm of this operator, or the diamond distance; from this operator to B. """"""; return mts.dnorm(self, B). @property; def ishp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = sr.to_choi(self); return J.isherm; except:; return False; else:; return False. @property; def iscp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = (; self; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.superrep in ('choi', 'chi'); else sr.to_choi(self); ); # If J isn't hermitian, then that could indicate either; # that J is not normal, or is normal, but has complex eigenvalues.; # In either case, it makes no sense to then demand that the; # eigenvalues be non-negative.; if not J.isherm:; return False; eigs = J.eigenenergies(); return all(eigs >= -settings.atol); except:; return False; else:; return False. @property; def istp(self):; import qutip.superop_reps as sr; if self.type in [""super"", ""oper""]:; try:; # Normalize to ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobj.html:46502,cache,cached,46502,docs/4.4/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobj.html,1,['cache'],['cached']
Performance," normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns; -------; q : :class:`qutip.Qobj`; A new instance of :class:`qutip.Qobj` that contains only the states; corresponding to indices that are **not** in `state_inds`. Notes; -----; Experimental. """"""; keep_indices = np.array([s not in states_inds; for s in range(self.shape[0])]).nonzero()[0]. return self.extract_states(keep_indices, normalize=normalize). [docs] def dnorm(self, B=None):; """"""Calculates the diamond norm, or the diamond distance to another; operator. Parameters; ----------; B : :class:`qutip.Qobj` or None; If B is not None, the diamond distance d(A, B) = dnorm(A - B); between this operator and B is returned instead of the diamond norm. Returns; -------; d : float; Either the diamond norm of this operator, or the diamond distance; from this operator to B. """"""; return mts.dnorm(self, B). @property; def ishp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = sr.to_choi(self); return J.isherm; except:; return False; else:; return False. @property; def iscp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = (; self; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.superrep in ('choi', 'chi'); else sr.to_choi(self); ); # If J isn't hermitian, then that could indicate either; # that J is not normal, or is normal,; # but has complex eigenvalues.; # In either case, it makes no sense to then demand that the; # eigenvalues be non-negative.; if not J.isherm:; return False; eigs = J.eigenenergies(); return all(eigs >= -settings.atol); except:; return False; else:; return False. @property; def istp(self):; import qutip.superop_reps as sr; if self.type in [""super"", ""oper""]:; try:; # Normalize ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobj.html:47999,cache,cached,47999,docs/4.5/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobj.html,1,['cache'],['cached']
Performance," object sandwiched between a; bra and ket vector. Parameters:; bra (qobj) – Quantum object of type ‘bra’.; ket (qobj) – Quantum object of type ‘ket’. Returns:elem – Complex valued matrix element. Return type:complex. Raises:TypeError – Can only calculate matrix elements between a bra and ket; quantum object. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters:; norm (str) – Which norm to use for ket/bra vectors: L2 ‘l2’, max norm ‘max’,; or for operators: trace ‘tr’, Frobius ‘fro’, one ‘one’, or max; ‘max’.; sparse (bool) – Use sparse eigenvalue solver for trace norm. Other norms are not; affected by this parameter.; tol (float) – Tolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low.; maxiter (int) – Maximum number of iterations performed by sparse solver (if used); for trace norm. Returns:norm – The requested norm of the operator or state quantum object. Return type:float. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. overlap(state)[source]¶; Overlap between two state vectors.; Gives the overlap (scalar product) for the quantum object and state; state vector. Parameters:state (qobj) – Quantum object for a state vector of type ‘ket’ or ‘bra’. Returns:overlap – Complex valued overlap. Return type:complex. Raises:TypeError – Can only calculate overlap between a bra and ket quantum objects. permute(order)[source]¶; Permutes a composite quantum object. Parameters:order (list/array) – List specifying new tensor order. Returns:P – Permuted quantum object. Return type:qobj. ptrace(sel)[source]¶; Partial trace of the quantum object. Parameters:sel (int/list) – An int or list of components to keep after partial trace. Returns:oper – Quantum object r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:11858,perform,performed,11858,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['perform'],['performed']
Performance," of data dumping that will occur. SUMMARYA summary will be recorded. FULLAll possible dumping. CUSTOMSome customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped. class OptimDump(optim, level='SUMMARY')[source]¶; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes. dump_summaryboolWhen True summary items are appended to the iter_summary. iter_summarylist of optimizer.OptimIterSummarySummary at each iteration. dump_fid_errboolWhen True values are appended to the fid_err_log. fid_err_loglist of floatFidelity error at each call of the fid_err_func. dump_grad_normboolWhen True values are appended to the fid_err_log. grad_norm_loglist of floatGradient norm at each call of the grad_norm_log. dump_gradboolWhen True values are appended to the grad_log. grad_loglist of ndarrayGradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. property dump_all¶; True if everything (ignoring the summary) is to be dumped. property dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out to file(s). Parameters. ffilename or filehandleIf specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DynamicsDump(dynamics, level='SUMMARY')[source]¶; A container for dumps of dynamics data. Mainly time evolution calculations. Attributes. dump_summaryboolIf True a summary is recorded. evo_summarylist of tslotcomp.Evo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:244773,optimiz,optimizer,244773,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,1,['optimiz'],['optimizer']
Performance," of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:; from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this using matrix representation.; To begin, let us create a blank Qobj:; print(Qobj()). Output:; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank Qobj object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. Hint; By convention, the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-basics.html:1615,load,loaded,1615,docs/4.6/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html,1,['load'],['loaded']
Performance," of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators. PulseGenThere are many subclasses of pulse generators that generate different types of pulses as the initial amplitudes for the optimisation. Often the goal cannot be achieved from all starting conditions, and then typically some k",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-control.html:14865,optimiz,optimize,14865,docs/4.4/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-control.html,8,"['optimiz', 'perform']","['optimize', 'perform']"
Performance," offset=0):; '''Creation (raising) operator. Parameters; ----------; N : int; Dimension of Hilbert space. Returns; -------; oper : qobj; Qobj for raising operator. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the operator. Examples; --------; >>> create(4); Quantum object: dims = [[4], [4]], \; shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0.j]]. '''; if not isinstance(N, (int, np.integer)): # raise error if N not integer; raise ValueError(""Hilbert space dimension must be integer value""); qo = destroy(N, offset=offset) # create operator using destroy function; return qo.dag(). def _implicit_tensor_dimensions(dimensions):; """"""; Total flattened size and operator dimensions for operator creation routines; that automatically perform tensor products. Parameters; ----------; dimensions : (int) or (list of int) or (list of list of int); First dimension of an operator which can create an implicit tensor; product. If the type is `int`, it is promoted first to `[dimensions]`.; From there, it should be one of the two-elements `dims` parameter of a; `qutip.Qobj` representing an `oper` or `super`, with possible tensor; products. Returns; -------; size : int; Dimension of backing matrix required to represent operator.; dimensions : list; Dimension list in the form required by ``Qobj`` creation.; """"""; if not isinstance(dimensions, list):; dimensions = [dimensions]; flat = flatten(dimensions); if not all(isinstance(x, numbers.Integral) and x >= 0 for x in flat):; raise ValueError(""All dimensions must be integers >= 0""); return np.prod(flat), [dimensions, dimensions]. [docs]def qzero(dimensions):; """"""; Zero operator. Parameters; ----------; dimensions : (int",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/operators.html:10058,perform,perform,10058,docs/4.5/modules/qutip/operators.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/operators.html,1,['perform'],['perform']
Performance," on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:; from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-basics.html:1147,load,load,1147,docs/4.6/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html,1,['load'],['load']
Performance," operator in column vector form. isoperbra; (bool) Indicates if the quantum object represents an operator in row vector form. Methods. conj(); Conjugate of quantum object. dag(); Adjoint (dagger) of quantum object. eigenenergies(sparse=False, sort=’low’, eigvals=0, tol=0, maxiter=100000); Returns eigenenergies (eigenvalues) of a quantum object. eigenstates(sparse=False, sort=’low’, eigvals=0, tol=0, maxiter=100000); Returns eigenenergies and eigenstates of quantum object. expm(); Matrix exponential of quantum object. full(); Returns dense array of quantum object data attribute. groundstate(sparse=False,tol=0,maxiter=100000); Returns eigenvalue and eigenket for the groundstate of a quantum object. matrix_element(bra, ket); Returns the matrix element of operator between bra and ket vectors. norm(norm=’tr’, sparse=False, tol=0, maxiter=100000); Returns norm of a ket or an operator. permute(order); Returns composite qobj with indices reordered. ptrace(sel); Returns quantum object for selected dimensions after performing partial trace. sqrtm(); Matrix square root of quantum object. tidyup(atol=1e-12); Removes small elements from quantum object. tr(); Trace of quantum object. trans(); Transpose of quantum object. transform(inpt, inverse=False); Performs a basis transformation defined by inpt matrix. unit(norm=’tr’, sparse=False, tol=0, maxiter=100000); Returns normalized quantum object. checkherm()¶; Check if the quantum object is hermitian. Returns:isherm: bool. Returns the new value of isherm property. conj()¶; Conjugate operator of quantum object. dag()¶; Adjoint operator of quantum object. diag()¶; Diagonal elements of quantum object. Returns:diags: array. Returns array of real values if operators is Hermitian,; otherwise complex values are returned. eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)¶; Eigenenergies of a quantum object.; Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters:sparse : bool. Use ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/classes.html:4729,perform,performing,4729,docs/3.1.0/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/classes.html,1,['perform'],['performing']
Performance," operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element); c2 (qutip.Qobj) – system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element); notrace (bool {False}) – If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns:time-propagator for computing field correlation function. Return type:qutip.Qobj. propagator(t, tau, notrace=False)[source]¶; Compute propagator for time t and time-delay tau. Parameters:; t (float) – current time; tau (float) – time-delay; notrace (bool {False}) – If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns:time-propagator for reduced system dynamics. Return type:qutip.Qobj. rhot(rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters:; rho0 (qutip.Qobj) – initial density matrix or state vector (ket); t (float) – current time; tau (float) – time-delay. Returns:density matrix at time \(t\). Return type:qutip.Qobj. class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options for the Transfer Tensor Method solver. dynmaps¶; list of qutip.Qobj – List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times¶; array_like – List of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimes¶; array_like – List of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thres¶; float – Threshold for halting. Halts if \(||T_{n}-T_{n-1}||\) i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:34315,perform,performed,34315,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['perform'],['performed']
Performance," operators.; Fixed bug related to args not being passed to coherence_function_g2; Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017)¶. Improvements¶. MAJOR FEATURE: Initial implementation of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization. This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputing a list. with Python functions as time-dependence. Fixed non-int issue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/changelog.html:3936,load,loading,3936,docs/4.3/changelog.html,https://qutip.org,https://qutip.org/docs/4.3/changelog.html,3,['load'],['loading']
Performance," optimisation so far; (in seconds of elapsed time). class TerminationConditions[source]¶; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes:; fid_err_targ : float; Target fidelity error. fid_goal : float; goal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_time : float; # maximum time for optimisation (seconds). min_gradient_norm : float; Minimum normalised gradient after which optimisation will terminate. max_iterations : integer; Maximum iterations of the optimisation algorithm. max_fid_func_calls : integer; Maximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]¶; Attributes give the result of the pulse optimisation attempt. Attributes:; termination_reason : string; Description of the reason for terminating the optimisation. fidelity : float; final (normalised) fidelity that was achieved. initial_fid_err : float; fidelity error before optimisation starting. fid_err : float; final fidelity error that was achieved. goal_achieved : boolean; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:81383,optimiz,optimize,81383,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['optimiz'],['optimize']
Performance," options.rhs_reuse:; config.soft_reset(); # no time dependence; config.tflag = 0; # check for collapse operators; if len(c_ops) > 0:; config.cflag = 1; else:; config.cflag = 0; # Configure data; _mc_data_config(H, psi0, [], c_ops, [], [], e_ops, options, config). # Load Monte Carlo class; mc = _MC_class(); # Set solver type; if (options.method == 'adams'):; mc.mf = 10; elif (options.method == 'bdf'):; mc.mf = 22; else:; if debug:; print('Unrecognized method for ode solver, using ""adams"".'); mc.mf = 10; # store ket and density matrix dims and shape for convenience; mc.psi0_dims = psi0.dims; mc.psi0_shape = psi0.shape; mc.dm_dims = (psi0 * psi0.dag()).dims; mc.dm_shape = (psi0 * psi0.dag()).shape; # use sparse density matrices during computation?; mc.sparse_dms = sparse_dms; # run in serial?; mc.serial_run = serial or (ntraj == 1); # are we doing a partial trace for returned states?; mc.ptrace_sel = ptrace_sel; if (ptrace_sel != []):; if debug:; print(""ptrace_sel set to "" + str(ptrace_sel)); print(""We are using dense density matrices during computation "" +; ""when performing partial trace. Setting sparse_dms = False""); print(""This feature is experimental.""); mc.sparse_dms = False; mc.dm_dims = psi0.ptrace(ptrace_sel).dims; mc.dm_shape = psi0.ptrace(ptrace_sel).shape; if (calc_entropy):; if (ptrace_sel == []):; if debug:; print(""calc_entropy = True, but ptrace_sel = []. Please set "" +; ""a list of components to keep when calculating average"" +; "" entropy of reduced density matrix in ptrace_sel. "" +; ""Setting calc_entropy = False.""); calc_entropy = False; mc.calc_entropy = calc_entropy. # construct output Result object; output = Result(). # Run; mc.run(); output.states = mc.sol.states; output.expect = mc.sol.expect; output.col_times = mc.sol.col_times; output.col_which = mc.sol.col_which; if (hasattr(mc.sol, 'entropy')):; output.entropy = mc.sol.entropy. output.solver = 'Fortran 90 Monte Carlo solver'; # simulation parameters; output.times = config.tlist; output.num_expect",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:7429,perform,performing,7429,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['perform'],['performing']
Performance, property). (OptPulseProcessor property). (Processor property). (SpinChain property). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). collapse_dims_oper() (in module qutip.dimensions). collapse_dims_super() (in module qutip.dimensions). collapse_uncoupled() (in module qutip.piqs). combine_dyn_gen() (Dynamics method). commutation_rules() (Scheduler method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). compile() (CavityQEDCompiler method). (GateCompiler method). (QobjEvo method). (SpinChainCompiler method). complex_phase_cmap() (in module qutip.matplotlib_utilities). composite() (in module qutip.tensor). compress() (QobjEvo method). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method). (QobjEvo method). ControlAmpNoise (class in qutip.qip.noise). controlled_gate() (in module qutip.qip.operations.gates). convert_unit() (in module qutip.utilities). copy() (Qobj method). (QobjEvo method). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_3op_1t() (in module qutip.correlation). correlation_3op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). cosm() (Qobj method). covariance_matrix() (in module qutip.continuous_variables). cphase(),MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/genindex.html:5191,concurren,concurrence,5191,docs/4.6/genindex.html,https://qutip.org,https://qutip.org/docs/4.6/genindex.html,1,['concurren'],['concurrence']
Performance, property). num_dicke_ladders() (in module qutip.piqs). num_tls() (in module qutip.piqs). O. ode2es() (in module qutip.essolve). onto_evo() (Dynamics property). onwd_evo() (Dynamics property). operator_at_cells() (Lattice1d method). operator_between_cells() (Lattice1d method). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircularSpinChain method). (LinearSpinChain method). (SpinChain method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). OptPulseProcessor (class in qutip.qip.device). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). phase() (in module qutip.operators). phase_application() (Dynamics property). phase_basis() (in module qutip.states). phasegate() (in module qutip.qip.gates). photocurrent_mesolve() (in module qutip.stochastic). photocurrent_sesolve() (in module qutip.stochastic). Pim (class in qutip.piqs). pisolve() (Dicke method). plot_berry_curvature() (in module qutip.topology). plot_dispersion() (Lattice1d method). plot_energy_levels() (in module qutip.visualization). plot_expectation_values() (in mo,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/genindex.html:16206,optimiz,optimizer,16206,docs/4.5/genindex.html,https://qutip.org,https://qutip.org/docs/4.5/genindex.html,1,['optimiz'],['optimizer']
Performance," psi0, tlist, a_ops=[[sigmax(),ohmic_spectrum]], e_ops=e_ops). where the resulting output is an instance of the class qutip.solver.Result. Time-dependent Bloch-Redfield Dynamics¶. Warning; It takes ~3-5 seconds (~30 if using Visual Studio) to compile a time-dependent Bloch-Redfield problem. Therefore,; if you are doing repeated simulations by varying parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, exc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:14460,scalab,scalability,14460,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,2,['scalab'],['scalability']
Performance," pulse optimisation so far; (in seconds of elapsed time). class TerminationConditions[source]¶; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. fid_err_targ¶; float – Target fidelity error. fid_goal¶; float – goal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_time¶; float – # maximum time for optimisation (seconds). min_gradient_norm¶; float – Minimum normalised gradient after which optimisation will terminate. max_iterations¶; integer – Maximum iterations of the optimisation algorithm. max_fid_func_calls¶; integer – Maximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factor¶; float – Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]¶; Attributes give the result of the pulse optimisation attempt. termination_reason¶; string – Description of the reason for terminating the optimisation. fidelity¶; float – final (normalised) fidelity that was achieved. initial_fid_err¶; float – fidelity error before optimisation starting. fid_err¶; float – final fidelity error that was achieved. goal_achieved¶; boolean – True is the fidely error achieved was below the target. grad_norm_final¶; float – Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached¶; float – True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter¶; integer – Number of iterations of the optimisati",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:73474,optimiz,optimize,73474,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['optimiz'],['optimize']
Performance," qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; """"""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/memorycascade.html:5223,perform,performed,5223,docs/4.1/modules/qutip/nonmarkov/memorycascade.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/memorycascade.html,5,['perform'],['performed']
Performance," qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; r""""""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:5252,perform,performed,5252,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html,2,['perform'],['performed']
Performance," qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; """"""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/nonmarkov/memorycascade.html:5219,perform,performed,5219,docs/4.4/modules/qutip/nonmarkov/memorycascade.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/nonmarkov/memorycascade.html,1,['perform'],['performed']
Performance," quantum object. cosm(); Cosine of quantum object. dag(); Adjoint (dagger) of quantum object. dnorm(); Diamond norm of quantum operator. dual_chan(); Dual channel of quantum object representing a CP map. eigenenergies(sparse=False, sort=’low’, eigvals=0, tol=0, maxiter=100000); Returns eigenenergies (eigenvalues) of a quantum object. eigenstates(sparse=False, sort=’low’, eigvals=0, tol=0, maxiter=100000); Returns eigenenergies and eigenstates of quantum object. expm(); Matrix exponential of quantum object. full(order=’C’); Returns dense array of quantum object data attribute. groundstate(sparse=False, tol=0, maxiter=100000); Returns eigenvalue and eigenket for the groundstate of a quantum object. matrix_element(bra, ket); Returns the matrix element of operator between bra and ket vectors. norm(norm=’tr’, sparse=False, tol=0, maxiter=100000); Returns norm of a ket or an operator. permute(order); Returns composite qobj with indices reordered. ptrace(sel); Returns quantum object for selected dimensions after performing partial trace. sinm(); Sine of quantum object. sqrtm(); Matrix square root of quantum object. tidyup(atol=1e-12); Removes small elements from quantum object. tr(); Trace of quantum object. trans(); Transpose of quantum object. transform(inpt, inverse=False); Performs a basis transformation defined by inpt matrix. trunc_neg(method=’clip’); Removes negative eigenvalues and returns a new Qobj that is a valid density operator. unit(norm=’tr’, sparse=False, tol=0, maxiter=100000); Returns normalized quantum object. check_herm()[source]¶; Check if the quantum object is hermitian. Returns:isherm : bool. Returns the new value of isherm property. conj()[source]¶; Conjugate operator of quantum object. copy()[source]¶; Create identical copy. cosm()[source]¶; Cosine of a quantum operator.; Operator must be square. Returns:oper : qobj. Matrix cosine of operator. Raises:TypeError. Quantum object is not square. Notes; Uses the Q.expm() method. dag()[source]¶; Adjoint o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:3911,perform,performing,3911,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,1,['perform'],['performing']
Performance," qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator; >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations; >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True; >>> a = destroy(10); >>> np.testing.assert_almost_equal(expect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve; >>> a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> psi0 = rand_ket(10); >>> times = np.linspace(0, 10, 10); >>> dm_list = mesolve(H, psi0, times, c_ops, []); >>> qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program; >>> dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0; >>> a = destroy(10); >>> expect(a.dag() * a, dm_list_loaded.states) ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-saving.html:2629,load,loaded,2629,docs/4.6/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-saving.html,2,['load'],['loaded']
Performance," range(len(c_ops)):; if isinstance(c_ops[k], Qobj):; c_const.append(k); elif isinstance(c_ops[k], list):; if len(c_ops[k]) != 2 or not isinstance(c_ops[k][0], Qobj):; raise TypeError(; ""Incorrect collapse operator specification""); else:; if isinstance(c_ops[k][1], (FunctionType,; BuiltinFunctionType, partial)):; c_func.append(k); elif isinstance(c_ops[k][1], str):; c_str.append(k); elif isinstance(H_k[1], Cubic_Spline):; c_obj.append(k); elif isinstance(c_ops[k][1], np.ndarray):; c_str.append(k); else:; raise TypeError(; ""Incorrect collapse operator specification""); else:; raise TypeError(""Incorrect collapse operator specification""). #; # if n_str == 0 and n_func == 0:; # # no time-dependence at all; #; if ((len(h_str) > 0 and len(h_func) > 0) or; (len(c_str) > 0 and len(c_func) > 0)):; raise TypeError(; ""Cannot mix string and function type time-dependence formats""). # check to see if Cython is installed and version is high enough.; if len(h_str) > 0 or len(c_str) > 0:; try:; import Cython; except:; raise Exception(; ""Unable to load Cython. Use Python function format.""); else:; if Cython.__version__ < '0.21':; raise Exception(""Cython version (%s) is too old. Upgrade to "" +; ""version 0.21+"" % Cython.__version__); ; # If only time-dependence is in Objects, then prefer string based format; if (len(h_func) + len(c_func) + len(h_str) + len(c_str)) == 0:; h_str += h_obj #Does nothing if not objects; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj; ; #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)); ; elif solver == 'mc':. # H C_ops #; # -- ----- --; # NO NO 00; # NO STR 01; # NO FUNC 02; #; # STR NO 10; # STR STR 11; #; # FUNC NO 20; #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; elif ((len(h_func) == len(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html:8474,load,load,8474,docs/4.0.2/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/rhs_generate.html,2,['load'],['load']
Performance," represented; using the isomorphism; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\) [Hav03], [Wat13].; To represent superoperators acting on \(\mathcal{L}(\mathcal{H}_1 \otimes \mathcal{H}_2)\) thus takes some tensor rearrangement to get the desired ordering; \(\mathcal{H}_1 \otimes \mathcal{H}_2 \otimes \mathcal{H}_1 \otimes \mathcal{H}_2\).; In particular, this means that qutip.tensor does not act as; one might expect on the results of qutip.to_super:; In [27]: A = qeye([2]). In [28]: B = qeye([3]). In [29]: to_super(tensor(A, B)).dims; Out[29]: [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. In [30]: tensor(to_super(A), to_super(B)).dims; Out[30]: [[[2], [2], [3], [3]], [[2], [2], [3], [3]]]. In the former case, the result correctly has four copies; of the compound index with dims [2, 3]. In the latter; case, however, each of the Hilbert space indices is listed; independently and in the wrong order.; The qutip.super_tensor function performs the needed; rearrangement, providing the most direct analog to qutip.tensor on; the underlying Hilbert space. In particular, for any two type=""oper""; Qobjs A and B, to_super(tensor(A, B)) == super_tensor(to_super(A), to_super(B)) and; operator_to_vector(tensor(A, B)) == super_tensor(operator_to_vector(A), operator_to_vector(B)). Returning to the previous example:; In [31]: super_tensor(to_super(A), to_super(B)).dims; Out[31]: [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. The qutip.composite function automatically switches between; qutip.tensor and qutip.super_tensor based on the type; of its arguments, such that composite(A, B) returns an appropriate Qobj to; represent the composition of two systems.; In [32]: composite(A, B).dims; Out[32]: [[2, 3], [2, 3]]. In [33]: composite(to_super(A), to_super(B)).dims; Out[33]: [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. QuTiP also allows more general tensor manipulations that are; useful for converting between superoperator representations [WBC11].; In particular, the tensor_co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-tensor.html:10166,perform,performs,10166,docs/4.5/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-tensor.html,2,['perform'],['performs']
Performance," resultsqutip.solver.ResultObject storing all results from the simulation. class HEOMSolver[source]¶; This is superclass for all solvers that use the HEOM method for; calculating the dynamics evolution. There are many references for this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve); This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate.; There are opportunities to develop a more general spectral density code. Attributes. H_sysQobjSystem Hamiltonian. coup_opQobjOperator describing the coupling between system and bath. coup_strengthfloatCoupling strength. temperaturefloatBath temperature, in units corresponding to planck. N_cutintCutoff parameter for the bath. N_expintNumber of exponential terms used to approximate the bath correlation; functions. planckfloatreduced Planck constant. boltzmannfloatBoltzmann’s constant. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. statsqutip.solver.Statsoptional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coefflis",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:70684,perform,performance,70684,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,1,['perform'],['performance']
Performance," self.dump_grad):; return True; else:; return False. @property; def dump_all(self):; """"""True if everything (ignoring the summary) is to be dumped""""""; if (self.dump_fid_err and self.dump_grad_norm and self.dump_grad):; return True; else:; return False. def _apply_level(self, level=None):; if level is None:; level = self._level. if not _is_string(level):; raise ValueError(""Dump level must be a string""); level = level.upper(); if level == 'CUSTOM':; if self._level == 'CUSTOM':; # dumping level has not changed keep the same specific config; pass; else:; # Switching to custom, start from SUMMARY; level = 'SUMMARY'. if level == 'SUMMARY':; self.dump_summary = True; self.dump_fid_err = False; self.dump_grad_norm = False; self.dump_grad = False; elif level == 'FULL':; self.dump_summary = True; self.dump_fid_err = True; self.dump_grad_norm = True; self.dump_grad = True; else:; raise ValueError(""No option for dumping level '{}'"".format(level)). [docs] def add_iter_summary(self):; """"""add copy of current optimizer iteration summary""""""; optim = self.parent; if optim.iter_summary is None:; raise RuntimeError(""Cannot add iter_summary as not available""); ois = copy.copy(optim.iter_summary); ois.idx = len(self.iter_summary); self.iter_summary.append(ois); if self.write_to_file:; if ois.idx == 0:; f = open(self.summary_file, 'w'); f.write(""{}\n{}\n"".format(; ois.get_header_line(self.summary_sep),; ois.get_value_line(self.summary_sep))); else:; f = open(self.summary_file, 'a'); f.write(""{}\n"".format(; ois.get_value_line(self.summary_sep))). f.close(); return ois. @property; def fid_err_file(self):; if self._fid_err_file is None:; fname = ""{}-fid_err_log.{}"".format(self.fname_base,; self.dump_file_ext); self._fid_err_file = os.path.join(self.dump_dir, fname); return self._fid_err_file. [docs] def update_fid_err_log(self, fid_err):; """"""add an entry to the fid_err log""""""; self.fid_err_log.append(fid_err); if self.write_to_file:; if len(self.fid_err_log) == 1:; mode = 'w'; else:; mode = 'a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dump.html:9714,optimiz,optimizer,9714,docs/4.1/modules/qutip/control/dump.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dump.html,8,['optimiz'],['optimizer']
Performance," shape.; if dims is None and self.shape[0] == self.shape[1]:; sub_shape = np.sqrt(self.shape[0]); # check if root of shape is int; if (sub_shape % 1) != 0:; raise Exception('Invalid shape for a super operator.'); else:; sub_shape = int(sub_shape); self.dims = [[[sub_shape], [sub_shape]]]*2. if superrep:; self.superrep = superrep; else:; if self.type == 'super' and self.superrep is None:; self.superrep = 'super'. # While the obvious check would be != that would fail valid; # use cases such as enr_fock and other enr_ functions.; # This does leave open the possibility of data still being; # misused such as Qobj(complex[n**2][1], dims = [[n],[n]]); dims_size = (; np.prod(flatten(self.dims[0]), dtype=np.int64),; np.prod(flatten(self.dims[1]), dtype=np.int64); ); shape = self._data.shape; if (; (shape[0] > dims_size[0] or shape[1] > dims_size[1]); and self.type != 'super'; ):; raise ValueError(f""Qobj has smaller dims {self.dims} "" +; f""than underlying shape {self._data.shape}""). # clear type cache; self._type = None. [docs] def copy(self):; """"""Create identical copy""""""; return Qobj(inpt=self). def get_data(self):; return self._data. # Here we perfrom a check of the csr matrix type during setting of Q.data; def set_data(self, data):; if not isinstance(data, fast_csr_matrix):; raise TypeError('Qobj data must be in fast_csr format.'); else:; self._data = data; data = property(get_data, set_data). def __add__(self, other):; """"""; ADDITION with Qobj on LEFT [ ex. Qobj+4 ]; """"""; self._isunitary = None. if isinstance(other, eseries):; return other.__radd__(self). if not isinstance(other, Qobj):; if isinstance(other, (int, float, complex, np.integer, np.floating,; np.complexfloating, np.ndarray, list, tuple)) \; or sp.issparse(other):; other = Qobj(other); else:; return NotImplemented. if np.prod(other.shape) == 1 and np.prod(self.shape) != 1:; # case for scalar quantum object; dat = other.data[0, 0]; if dat == 0:; return self. out = Qobj(). if self.type in ['oper', 'super']:; out.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qobj.html:10529,cache,cache,10529,docs/4.7/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html,1,['cache'],['cache']
Performance," solving large-scale sparse linear systems have been replaced due to licensing restrictions. The default method for all sparse linear problems is now the SuperLU library. However, scipy still includes the ability to call the umfpack library via the scikits.umfpack module. In our experience, the umfpack solver is 2-5x faster than the SuperLU routines, which is a very noticeable performance increase when used for solving steady state solutions. We have an updated scikits.umfpack module available at http://github.com/nonhermitian/umfpack that can be installed to have SciPy find and use the umfpack library. Optimized BLAS Libraries¶; QuTiP is designed to take advantage of some of the optimized BLAS libraries that are available for NumPy. At present, this includes the OPENBLAS and MKL libraries. If NumPy is built against these libraries, then QuTiP will take advantage of the performance gained by using these optimized tools. As these libraries are multi-threaded, you can change the number of threads used in these packages by adding:; >>> import os; >>> os.environ['OPENBLAS_NUM_THREADS'] = '4'; >>> os.environ['MKL_NUM_THREADS'] = '4'. at the top of your Python script files, or iPython notebooks, and then loading the QuTiP framework. If these commands are not present, then QuTiP automatically sets the number of threads to one. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; >>> import qutip.testing as qt; >>> qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that you have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/installation.html:12013,multi-thread,multi-threaded,12013,docs/3.1.0/installation.html,https://qutip.org,https://qutip.org/docs/3.1.0/installation.html,1,['multi-thread'],['multi-threaded']
Performance," solving large-scale sparse linear systems have been replaced due to licensing restrictions. The default method for all sparse linear problems is now the SuperLU library. However, scipy still includes the ability to call the umfpack library via the scikits.umfpack module. In our experience, the umfpack solver is 2-5x faster than the SuperLU routines, which is a very noticeable performance increase when used for solving steady state solutions. We have an updated scikits.umfpack module available at http://github.com/nonhermitian/umfpack that can be installed to have SciPy find and use the umfpack library. Optimized BLAS Libraries¶; QuTiP is designed to take advantage of some of the optimized BLAS libraries that are available for NumPy. At present, this includes the OPENBLAS and MKL libraries. If NumPy is built against these libraries, then QuTiP will take advantage of the performance gained by using these optimized tools. As these libraries are multi-threaded, you can change the number of threads used in these packages by adding:; >>> import os; >>> os.environ['OPENBLAS_NUM_THREADS'] = '4'; >>> os.environ['MKL_NUM_THREADS'] = '4'. at the top of your Python script files, or iPython notebooks, and then loading the QuTiP framework. If these commands are not present, then QuTiP automatically sets the number of threads to one. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; >>> import qutip.testing as qt; >>> qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that your have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/installation.html:11024,multi-thread,multi-threaded,11024,docs/3.0.1/installation.html,https://qutip.org,https://qutip.org/docs/3.0.1/installation.html,1,['multi-thread'],['multi-threaded']
Performance," squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error. Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods. Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying DEF; will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the scipy.optimize.minimize; method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics; classes for details). dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. pr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:228119,optimiz,optimize,228119,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['optimiz'],['optimize']
Performance," squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error. Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods. Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying DEF; will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or; the termination_conditions matching the key that attribute.; Otherwise, and in some case also, they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. pr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:240234,optimiz,optimize,240234,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['optimiz'],['optimize']
Performance," state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q : Qobj. A new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(order='C', squeeze=False)[source]¶; Dense array from quantum object. Parameters:order : str {‘C’, ‘F’}. Return array in C (default) or Fortran ordering. squeeze : bool {False, True}. Squeeze output array. Returns:data : array. Array of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters:sparse : bool. Use sparse Eigensolver. tol : float. Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). safe : bool (default=True). Check for degenerate ground state. Returns:eigval : float. Eigenvalue for the ground state of quantum operator. eigvec : qobj. Eigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:bra : qobj. Quantum object of type ‘bra’. ket : qobj. Quantum object of type ‘ket’. Returns:elem : complex. Complex valued matrix element. Raises:TypeError. Can only calculate matrix elements between a bra and ket; quantum object. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters:no",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:10414,perform,performed,10414,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,1,['perform'],['performed']
Performance," status information during a long optimisation. dumping¶; string – level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file¶; bool – If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir¶; string – Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary¶; OptimIterSummary – Summary of the most recent iteration.; Note this is only set if dummping is on. apply_method_params(params=None)[source]¶; Loops through all the method_params; (either passed here or the method_params attribute); If the name matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. dumping¶. The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; varia",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:63856,optimiz,optimize,63856,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['optimiz'],['optimize']
Performance," summary will be recorded; FULL : All possible dumping; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped. class OptimDump(optim, level='SUMMARY')[source]¶; A container for dumps of optimisation data generated during the pulse; optimisation. dump_summary¶; bool – When True summary items are appended to the iter_summary. iter_summary¶; list of optimizer.OptimIterSummary – Summary at each iteration. dump_fid_err¶; bool – When True values are appended to the fid_err_log. fid_err_log¶; list of float – Fidelity error at each call of the fid_err_func. dump_grad_norm¶; bool – When True values are appended to the fid_err_log. grad_norm_log¶; list of float – Gradient norm at each call of the grad_norm_log. dump_grad¶; bool – When True values are appended to the grad_log. grad_log¶; list of ndarray – Gradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. dump_all¶; True if everything (ignoring the summary) is to be dumped. dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out to file(s). Parameters:f (filename or filehandle) – If specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DynamicsDump(dynamics, level='SUMMARY')[source]¶; A container for dumps of dynamics data.; Mainly time evolution calculations. dump_summary¶; bool – If True a summary is recorded. evo_summary¶; list of :class:`tslotcomp.EvoCompSum",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:117180,optimiz,optimizer,117180,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['optimiz'],['optimizer']
Performance," system at time \(\tau\) into one of the renormalized states given by Eq. (3). The corresponding collapse operator \(C_{n}\) is chosen such that \(n\) is the smallest integer satisfying:. (5)¶\[\sum_{i=1}^{n} P_{n}(\tau) \ge r\]; where the individual \(P_{n}\) are given by Eq. (4). Note that the left hand side of Eq. (5) is, by definition, normalized to unity. IV: Using the renormalized state from step III as the new initial condition at time \(\tau\), draw a new random number, and repeat the above procedure until the final simulation time is reached. Monte Carlo in QuTiP¶; In QuTiP, Monte Carlo evolution is implemented with the qutip.mcsolve function. It takes nearly the same arguments as the qutip.mesolve; function for master-equation evolution, except that the initial state must be a ket vector, as oppose to a density matrix, and there is an optional keyword parameter ntraj that defines the number of stochastic trajectories to be simulated. By default, ntraj=500 indicating that 500 Monte Carlo trajectories will be performed.; To illustrate the use of the Monte Carlo evolution of quantum systems in QuTiP, let’s again consider the case of a two-level atom coupled to a leaky cavity. The only differences to the master-equation treatment is that in this case we invoke the qutip.mcsolve function instead of qutip.mesolve; In [1]: times = np.linspace(0.0, 10.0, 200). In [2]: psi0 = tensor(fock(2, 0), fock(10, 5)). In [3]: a = tensor(qeye(2), destroy(10)). In [4]: sm = tensor(destroy(2), qeye(10)). In [5]: H = 2 * np.pi * a.dag() * a + 2 * np.pi * sm.dag() * sm + 2 * np.pi * 0.25 * (sm * a.dag() + sm.dag() * a). In [6]: data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); 10.0%. Run time: 0.58s. Est. time left: 00:00:00:05; 20.0%. Run time: 1.12s. Est. time left: 00:00:00:04; 30.0%. Run time: 1.65s. Est. time left: 00:00:00:03; 40.0%. Run time: 2.18s. Est. time left: 00:00:00:03; 50.0%. Run time: 2.70s. Est. time left: 00:00:00:02; 60.0%. Run ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-monte.html:4794,perform,performed,4794,docs/4.2/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-monte.html,1,['perform'],['performed']
Performance," system at time \(\tau\) into one of the renormalized states given by Eq. (3). The corresponding collapse operator \(C_{n}\) is chosen such that \(n\) is the smallest integer satisfying:. (5)¶\[\sum_{i=1}^{n} P_{n}(\tau) \ge r\]; where the individual \(P_{n}\) are given by Eq. (4). Note that the left hand side of Eq. (5) is, by definition, normalized to unity. IV: Using the renormalized state from step III as the new initial condition at time \(\tau\), draw a new random number, and repeat the above procedure until the final simulation time is reached. Monte Carlo in QuTiP¶; In QuTiP, Monte Carlo evolution is implemented with the qutip.mcsolve function. It takes nearly the same arguments as the qutip.mesolve; function for master-equation evolution, except that the initial state must be a ket vector, as oppose to a density matrix, and there is an optional keyword parameter ntraj that defines the number of stochastic trajectories to be simulated. By default, ntraj=500 indicating that 500 Monte Carlo trajectories will be performed.; To illustrate the use of the Monte Carlo evolution of quantum systems in QuTiP, let’s again consider the case of a two-level atom coupled to a leaky cavity. The only differences to the master-equation treatment is that in this case we invoke the qutip.mcsolve function instead of qutip.mesolve; In [1]: times = np.linspace(0.0, 10.0, 200). In [2]: psi0 = tensor(fock(2, 0), fock(10, 5)). In [3]: a = tensor(qeye(2), destroy(10)). In [4]: sm = tensor(destroy(2), qeye(10)). In [5]: H = 2 * np.pi * a.dag() * a + 2 * np.pi * sm.dag() * sm + 2 * np.pi * 0.25 * (sm * a.dag() + sm.dag() * a). In [6]: data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); 10.0%. Run time: 0.80s. Est. time left: 00:00:00:07; 20.0%. Run time: 1.52s. Est. time left: 00:00:00:06; 30.0%. Run time: 2.22s. Est. time left: 00:00:00:05; 40.0%. Run time: 2.99s. Est. time left: 00:00:00:04; 50.0%. Run time: 3.75s. Est. time left: 00:00:00:03; 60.0%. Run ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/dynamics/dynamics-monte.html:4794,perform,performed,4794,docs/4.1/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.1/guide/dynamics/dynamics-monte.html,1,['perform'],['performed']
Performance," system at time \(\tau\) into one of the renormalized states given by Eq. (3). The corresponding collapse operator \(C_{n}\) is chosen such that \(n\) is the smallest integer satisfying:. (5)¶\[\sum_{i=1}^{n} P_{n}(\tau) \ge r\]; where the individual \(P_{n}\) are given by Eq. (4). Note that the left hand side of Eq. (5) is, by definition, normalized to unity. IV: Using the renormalized state from step III as the new initial condition at time \(\tau\), draw a new random number, and repeat the above procedure until the final simulation time is reached. Monte Carlo in QuTiP¶; In QuTiP, Monte Carlo evolution is implemented with the qutip.mcsolve function. It takes nearly the same arguments as the qutip.mesolve; function for master-equation evolution, except that the initial state must be a ket vector, as oppose to a density matrix, and there is an optional keyword parameter ntraj that defines the number of stochastic trajectories to be simulated. By default, ntraj=500 indicating that 500 Monte Carlo trajectories will be performed.; To illustrate the use of the Monte Carlo evolution of quantum systems in QuTiP, let’s again consider the case of a two-level atom coupled to a leaky cavity. The only differences to the master-equation treatment is that in this case we invoke the qutip.mcsolve function instead of qutip.mesolve; In [1]: times = np.linspace(0.0, 10.0, 200). In [2]: psi0 = tensor(fock(2, 0), fock(10, 5)). In [3]: a = tensor(qeye(2), destroy(10)). In [4]: sm = tensor(destroy(2), qeye(10)). In [5]: H = 2 * np.pi * a.dag() * a + 2 * np.pi * sm.dag() * sm + 2 * np.pi * 0.25 * (sm * a.dag() + sm.dag() * a). In [6]: data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); 10.0%. Run time: 0.87s. Est. time left: 00:00:00:07; 20.0%. Run time: 1.72s. Est. time left: 00:00:00:06; 30.0%. Run time: 2.92s. Est. time left: 00:00:00:06; 40.0%. Run time: 4.12s. Est. time left: 00:00:00:06; 50.0%. Run time: 5.09s. Est. time left: 00:00:00:05; 60.0%. Run ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-monte.html:4925,perform,performed,4925,docs/4.4/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-monte.html,1,['perform'],['performed']
Performance," system at time \(\tau\) into one of the renormalized states given by Eq. (3). The corresponding collapse operator \(C_{n}\) is chosen such that \(n\) is the smallest integer satisfying:. (5)¶\[\sum_{i=1}^{n} P_{n}(\tau) \ge r\]; where the individual \(P_{n}\) are given by Eq. (4). Note that the left hand side of Eq. (5) is, by definition, normalized to unity. IV: Using the renormalized state from step III as the new initial condition at time \(\tau\), draw a new random number, and repeat the above procedure until the final simulation time is reached. Monte Carlo in QuTiP¶; In QuTiP, Monte Carlo evolution is implemented with the qutip.mcsolve function. It takes nearly the same arguments as the qutip.mesolve; function for master-equation evolution, except that the initial state must be a ket vector, as oppose to a density matrix, and there is an optional keyword parameter ntraj that defines the number of stochastic trajectories to be simulated. By default, ntraj=500 indicating that 500 Monte Carlo trajectories will be performed.; To illustrate the use of the Monte Carlo evolution of quantum systems in QuTiP, let’s again consider the case of a two-level atom coupled to a leaky cavity. The only differences to the master-equation treatment is that in this case we invoke the qutip.mcsolve function instead of qutip.mesolve; In [1]: times = np.linspace(0.0, 10.0, 200). In [2]: psi0 = tensor(fock(2, 0), fock(10, 5)). In [3]: a = tensor(qeye(2), destroy(10)). In [4]: sm = tensor(destroy(2), qeye(10)). In [5]: H = 2 * np.pi * a.dag() * a + 2 * np.pi * sm.dag() * sm + 2 * np.pi * 0.25 * (sm * a.dag() + sm.dag() * a). In [6]: data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); 10.0%. Run time: 1.31s. Est. time left: 00:00:00:11; 20.0%. Run time: 2.60s. Est. time left: 00:00:00:10; 30.0%. Run time: 3.91s. Est. time left: 00:00:00:09; 40.0%. Run time: 5.26s. Est. time left: 00:00:00:07; 50.0%. Run time: 6.64s. Est. time left: 00:00:00:06; 60.0%. Run ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html:4820,perform,performed,4820,docs/4.3/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html,1,['perform'],['performed']
Performance," system at time \(\tau\) into one of the renormalized states given by Eq. (3). The corresponding collapse operator \(C_{n}\) is chosen such that \(n\) is the smallest integer satisfying:. (5)¶\[\sum_{i=1}^{n} P_{n}(\tau) \ge r\]; where the individual \(P_{n}\) are given by Eq. (4). Note that the left hand side of Eq. (5) is, by definition, normalized to unity. IV: Using the renormalized state from step III as the new initial condition at time \(\tau\), draw a new random number, and repeat the above procedure until the final simulation time is reached. Monte Carlo in QuTiP¶; In QuTiP, Monte Carlo evolution is implemented with the qutip.mcsolve function. It takes nearly the same arguments as the qutip.mesolve; function for master-equation evolution, except that the initial state must be a ket vector, as oppose to a density matrix, and there is an optional keyword parameter ntraj that defines the number of stochastic trajectories to be simulated. By default, ntraj=500 indicating that 500 Monte Carlo trajectories will be performed.; To illustrate the use of the Monte Carlo evolution of quantum systems in QuTiP, let’s again consider the case of a two-level atom coupled to a leaky cavity. The only differences to the master-equation treatment is that in this case we invoke the qutip.mcsolve function instead of qutip.mesolve; In [1]: times = np.linspace(0.0, 10.0, 200). In [2]: psi0 = tensor(fock(2, 0), fock(10, 5)). In [3]: a = tensor(qeye(2), destroy(10)). In [4]: sm = tensor(destroy(2), qeye(10)). In [5]: H = 2 * np.pi * a.dag() * a + 2 * np.pi * sm.dag() * sm + 2 * np.pi * 0.25 * (sm * a.dag() + sm.dag() * a). In [6]: data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); 10.0%. Run time: 1.98s. Est. time left: 00:00:00:17; 20.0%. Run time: 3.26s. Est. time left: 00:00:00:13; 30.0%. Run time: 4.54s. Est. time left: 00:00:00:10; 40.0%. Run time: 5.87s. Est. time left: 00:00:00:08; 50.0%. Run time: 7.19s. Est. time left: 00:00:00:07; 60.0%. Run ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-monte.html:4914,perform,performed,4914,docs/4.5/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-monte.html,1,['perform'],['performed']
Performance," system at time \(\tau\) into one of the renormalized states given by Eq. (3). The corresponding collapse operator \(C_{n}\) is chosen such that \(n\) is the smallest integer satisfying:. (5)¶\[\sum_{i=1}^{n} P_{n}(\tau) \ge r\]; where the individual \(P_{n}\) are given by Eq. (4). Note that the left hand side of Eq. (5) is, by definition, normalized to unity. IV: Using the renormalized state from step III as the new initial condition at time \(\tau\), draw a new random number, and repeat the above procedure until the final simulation time is reached. Monte Carlo in QuTiP¶; In QuTiP, Monte Carlo evolution is implemented with the qutip.mcsolve function. It takes nearly the same arguments as the qutip.mesolve; function for master-equation evolution, except that the initial state must be a ket vector, as oppose to a density matrix, and there is an optional keyword parameter ntraj that defines the number of stochastic trajectories to be simulated. By default, ntraj=500 indicating that 500 Monte Carlo trajectories will be performed.; To illustrate the use of the Monte Carlo evolution of quantum systems in QuTiP, let’s again consider the case of a two-level atom coupled to a leaky cavity. The only differences to the master-equation treatment is that in this case we invoke the qutip.mcsolve function instead of qutip.mesolve; In [1]: times = np.linspace(0.0, 10.0, 200). In [2]: psi0 = tensor(fock(2, 0), fock(10, 5)). In [3]: a = tensor(qeye(2), destroy(10)). In [4]: sm = tensor(destroy(2), qeye(10)). In [5]: H = 2 * np.pi * a.dag() * a + 2 * np.pi * sm.dag() * sm + 2 * np.pi * 0.25 * (sm * a.dag() + sm.dag() * a). In [6]: data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); 10.0%. Run time: 9.16s. Est. time left: 00:00:01:22; 20.0%. Run time: 18.00s. Est. time left: 00:00:01:12; 30.0%. Run time: 27.34s. Est. time left: 00:00:01:03; 40.0%. Run time: 36.22s. Est. time left: 00:00:00:54; 50.0%. Run time: 45.27s. Est. time left: 00:00:00:45; 60.0%. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-monte.html:4794,perform,performed,4794,docs/4.0.2/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-monte.html,1,['perform'],['performed']
Performance," system is in the quantum state \(\left|\psi_n\right>\). The time evolution of a density matrix \(\rho\) is the topic of the remaining portions of this section. The Lindblad Master equation¶; The standard approach for deriving the equations of motion for a system interacting with its environment is to expand the scope of the system to include the environment. The combined quantum system is then closed, and its evolution is governed by the von Neumann equation. (2)\[\dot \rho_{\rm tot}(t) = -\frac{i}{\hbar}[H_{\rm tot}, \rho_{\rm tot}(t)],\]; the equivalent of the Schrödinger equation (1) in the density matrix formalism. Here, the total Hamiltonian. \[H_{\rm tot} = H_{\rm sys} + H_{\rm env} + H_{\rm int},\]; includes the original system Hamiltonian \(H_{\rm sys}\), the Hamiltonian for the environment \(H_{\rm env}\), and a term representing the interaction between the system and its environment \(H_{\rm int}\). Since we are only interested in the dynamics of the system, we can at this point perform a partial trace over the environmental degrees of freedom in Eq. (2), and thereby obtain a master equation for the motion of the original system density matrix. The most general trace-preserving and completely positive form of this evolution is the Lindblad master equation for the reduced density matrix \(\rho = {\rm Tr}_{\rm env}[\rho_{\rm tot}]\). (3)\[\dot\rho(t)=-\frac{i}{\hbar}[H(t),\rho(t)]+\sum_n \frac{1}{2} \left[2 C_n \rho(t) C_n^{+} - \rho(t) C_n^{+} C_n - C_n^{+} C_n \rho(t)\right]\]; where the \(C_n = \sqrt{\gamma_n} A_n\) are collapse operators, and \(A_n\) are the operators through which the environment couples to the system in \(H_{\rm int}\), and \(\gamma_n\) are the corresponding rates. The derivation of Eq. (3) may be found in several sources, and will not be reproduced here. Instead, we emphasize the approximations that are required to arrive at the master equation in the form of Eq. (3) from physical arguments, and hence perform a calculation in QuTiP:.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html:9489,perform,perform,9489,docs/3.0.0/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html,3,['perform'],['perform']
Performance," the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1]_, [2]_.; It uses the ``scipy.optimize.fmin`` function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB. References; ----------; .. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011).; .. [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011).; """""". def reset(self):; OptimizerCrab.reset(self); self.id_text = 'CRAB_FMIN'; self.xtol = 1e-4; self.ftol = 1e-4. [docs] def run_optimization(self, term_conds=None):; """"""; This function optimisation method is a wrapper to the; scipy.optimize.fmin function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:37287,optimiz,optimize,37287,docs/4.6/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html,2,['optimiz'],['optimize']
Performance," the diamond distance to another operator. Parameters:B (Qobj or None) – If B is not None, the diamond distance d(A, B) = dnorm(A - B) between; this operator and B is returned instead of the diamond norm. Returns:d – Either the diamond norm of this operator, or the diamond distance; from this operator to B. Return type:float. dual_chan()[source]¶; Dual channel of quantum object representing a completely positive; map. eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]¶; Eigenenergies of a quantum object.; Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters:; sparse (bool) – Use sparse Eigensolver; sort (str) – Sort eigenvalues ‘low’ to high, or ‘high’ to low.; eigvals (int) – Number of requested eigenvalues. Default is all eigenvalues.; tol (float) – Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter (int) – Maximum number of iterations performed by sparse solver (if used). Returns:eigvals – Array of eigenvalues for operator. Return type:array. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters:; sparse (bool) – Use sparse Eigensolver; sort (str) – Sort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low.; eigvals (int) – Number of requested eigenvalues. Default is all eigenvalues.; tol (float) – Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter (int) – Maximum number of iterations performed by sparse solver (if used). Returns:; eigvals (array) – Array of eigenvalues for operator.; eigvecs (array) – Array of quantum operators representing the oprat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:6134,perform,performed,6134,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['perform'],['performed']
Performance," this can be very expensive, and can; lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [Lloyd14], the dimension of a quantum optimal control; problem is a polynomial function of the dimension of the manifold of the; time-polynomial reachable states, when allowing for a finite control precision; and evolution time. You can think of this as the information content of the; pulse (as being the only effective input) being very limited e.g. the pulse is; compressible to a few bytes without loosing the target.; This is where the Chopped RAndom Basis (CRAB) algorithm; [Doria11], [Caneva11] comes into play: Since the pulse complexity is usually; very low, it is sufficient to transform the optimal control problem to a few; parameter search by introducing a physically motivated function basis that; builds up the pulse. Compared to the number of time slices needed to accurately; simulate quantum dynamics (often equals basis dimension for Gradient based; algorithms), this number is lower by orders of magnitude, allowing CRAB to; efficiently optimize smooth pulses with realistic experimental constraints. It; is important to point out, that CRAB does not make any suggestion on the basis; function to be used. The basis must be chosen carefully considered, taking into; account a priori knowledge of the system (such as symmetries, magnitudes of; scales,…) and solution (e.g. sign, smoothness, bang-bang behavior,; singularities, maximum excursion or rate of change,….). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has; recently been introduced",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-control.html:11164,optimiz,optimize,11164,docs/4.7/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html,1,['optimiz'],['optimize']
Performance," this case we didn’t really need to store both the real and imaginary parts, so instead we could use the numtype=”real” option:; In [26]: file_data_store('expect.dat', output_data.T, numtype=""real""). In [27]: !head -n5 expect.dat; # Generated by QuTiP: 100x4 real matrix in decimal format [',' separated values].; 0.0000000000,3.0955765962,2.3114466232,-0.2208505556; 1.0101010101,2.5836572767,0.8657267558,-1.7468558726; 2.0202020202,2.2083149044,-0.8847004889,-1.4419458039; 3.0303030303,1.9242964668,-1.4729939509,-0.0149042695. and if we prefer scientific notation we can request that using the numformat=”exp” option; In [28]: file_data_store('expect.dat', output_data.T, numtype=""real"", numformat=""exp""). In [29]: !head -n 5 expect.dat; # Generated by QuTiP: 100x4 real matrix in exp format [',' separated values].; 0.0000000000e+00,3.0955765962e+00,2.3114466232e+00,-2.2085055556e-01; 1.0101010101e+00,2.5836572767e+00,8.6572675578e-01,-1.7468558726e+00; 2.0202020202e+00,2.2083149044e+00,-8.8470048890e-01,-1.4419458039e+00; 3.0303030303e+00,1.9242964668e+00,-1.4729939509e+00,-1.4904269545e-02. Loading data previously stored using qutip.fileio.file_data_store (or some other software) is a even easier. Regardless of which deliminator was used, if data was stored as complex or real numbers, if it is in decimal or exponential form, the data can be loaded using the qutip.fileio.file_data_read, which only takes the filename as mandatory argument.; In [30]: input_data = file_data_read('expect.dat'). In [31]: shape(input_data); Out[31]: (100, 4). In [32]: from pylab import *. In [33]: plot(input_data[:,0], input_data[:,1]); # plot the data; Out[33]: [<matplotlib.lines.Line2D at 0x10d8f65d0>]. (If a particularly obscure choice of deliminator was used it might be necessary to use the optional second argument, for example sep=”_” if _ is the deliminator). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-saving.html:9093,load,loaded,9093,docs/3.1.0/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-saving.html,1,['load'],['loaded']
Performance," this case we didn’t really need to store both the real and imaginary parts, so instead we could use the numtype=”real” option:; In [26]: file_data_store('expect.dat', output_data.T, numtype=""real""). In [27]: !head -n5 expect.dat; # Generated by QuTiP: 100x4 real matrix in decimal format [',' separated values].; 0.0000000000,3.6870391934,1.1374497054,-0.2951078367; 1.0101010101,2.9640773506,0.1508687185,-0.7403170813; 2.0202020202,2.4767636492,-0.4453067188,-0.3988135953; 3.0303030303,2.1208678804,-0.4752005651,0.1465727136. and if we prefer scientific notation we can request that using the numformat=”exp” option; In [28]: file_data_store('expect.dat', output_data.T, numtype=""real"", numformat=""exp""). In [29]: !head -n 5 expect.dat; # Generated by QuTiP: 100x4 real matrix in exp format [',' separated values].; 0.0000000000e+00,3.6870391934e+00,1.1374497054e+00,-2.9510783673e-01; 1.0101010101e+00,2.9640773506e+00,1.5086871853e-01,-7.4031708128e-01; 2.0202020202e+00,2.4767636492e+00,-4.4530671880e-01,-3.9881359529e-01; 3.0303030303e+00,2.1208678804e+00,-4.7520056508e-01,1.4657271365e-01. Loading data previously stored using qutip.fileio.file_data_store (or some other software) is a even easier. Regardless of which deliminator was used, if data was stored as complex or real numbers, if it is in decimal or exponential form, the data can be loaded using the qutip.fileio.file_data_read, which only takes the filename as mandatory argument.; In [30]: input_data = file_data_read('expect.dat'). In [31]: shape(input_data); Out[31]: (100, 4). In [32]: plot(input_data[:,0], input_data[:,1]); # plot the data. (If a particularly obscure choice of deliminator was used it might be necessary to use the optional second argument, for example sep=”_” if _ is the deliminator). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-saving.html:8339,load,loaded,8339,docs/4.3/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-saving.html,1,['load'],['loaded']
Performance," times: the times t (i.e. the tlist).; states: the system state at each time t (only available; if e_ops was None or if the solver option; store_states was set to True).; ado_states: the full ADO state at each time (only available; if ado_return was set to True). Each element is an; instance of HierarchyADOsState. .; The state of a particular ADO may be extracted from; result.ado_states[i] by calling extract.; expect: the value of each e_ops at time t (only; available if e_ops were given). If e_ops was passed; as a dictionary, then expect will be a dictionary with; the same keys as e_ops and values giving the list of; outcomes for the corresponding key. steady_state(use_mkl=True, mkl_max_iter_refine=100, mkl_weighted_matching=False)[source]¶; Compute the steady state of the system. Parameters. use_mklbool, default=FalseWhether to use mkl or not. If mkl is not installed or if; this is false, use the scipy splu solver instead. mkl_max_iter_refineintSpecifies the the maximum number of iterative refinement steps that; the MKL PARDISO solver performs.; For a complete description, see iparm(8) in; http://cali2.unilim.fr/intel-xe/mkl/mklman/GUID-264E311E-ACED-4D56-AC31-E9D3B11D1CBF.htm. mkl_weighted_matchingboolMKL PARDISO can use a maximum weighted matching algorithm to; permute large elements close the diagonal. This strategy adds an; additional level of reliability to the factorization methods.; For a complete description, see iparm(13) in; http://cali2.unilim.fr/intel-xe/mkl/mklman/GUID-264E311E-ACED-4D56-AC31-E9D3B11D1CBF.htm. Returns. steady_stateQobjThe steady state density matrix of the system. steady_adosHierarchyADOsStateThe steady state of the full ADO hierarchy. A particular ADO may be; extracted from the full state by calling extract. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, bnd_cut_approx=False, options=None, progress_bar=None, combine=True)[source]¶; A helper class for creating an HEOMSolver that is backwards; compa",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:46080,perform,performs,46080,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,1,['perform'],['performs']
Performance," to approximate the gradients, but this can be very expensive, and can lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [5], the dimension of a quantum optimal control problem is a polynomial function of the dimension of the manifold of the time-polynomial reachable states, when allowing for a finite control precision and evolution time. You can think of this as the information content of the pulse (as being the only effective input) being very limited e.g. the pulse is compressible to a few bytes without loosing the target.; This is where the Chopped RAndom Basis (CRAB) algorithm [6,7] comes into play: Since the pulse complexity is usually very low, it is sufficient to transform the optimal control problem to a few parameter search by introducing a physically motivated function basis that builds up the pulse. Compared to the number of time slices needed to accurately simulate quantum dynamics (often equals basis dimension for Gradient based algorithms), this number is lower by orders of magnitude, allowing CRAB to efficiently optimize smooth pulses with realistic experimental constraints. It is important to point out, that CRAB does not make any suggestion on the basis function to be used. The basis must be chosen carefully considered, taking into account a priori knowledge of the system (such as symmetries, magnitudes of scales,...) and solution (e.g. sign, smoothness, bang-bang behavior, singularities, maximum excursion or rate of change,....). By doing so, this algorithm allows for native integration of experimental constraints such as maximum frequencies allowed, maximum amplitude, smooth ramping up and down of the pulse and many more. Moreover initial guesses, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [8] that",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-control.html:11355,optimiz,optimize,11355,docs/4.0.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html,2,['optimiz'],['optimize']
Performance," to get the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:. BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm. This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS. This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import functools; import numpy as np; import timeit; import warnings; from packaging.version import parse as _parse_version; import scipy; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import quti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:3814,perform,performs,3814,docs/4.6/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html,2,['perform'],['performs']
Performance," to tensor function output.; Removed openmp flags from setup.py as new Mac Xcode compiler does not recognize them.; Qobj diag method now returns real array if all imaginary parts are zero.; Examples GUI now links to new documentation.; Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011)¶. Bug Fixes¶. Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011)¶; THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE. New Functions¶. Added linear entropy function.; Number of CPU’s can now be changed. Bug Fixes¶. Metrics no longer use dense matrices.; Fixed Bloch sphere grid issue with matplotlib 1.1.; Qobj trace operation uses only sparse matrices.; Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011)¶; THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED. New Functions¶. tidyup function to remove small elements from a Qobj.; Added concurrence function.; Added simdiag for simultaneous diagonalization of operators.; Added eigenstates method returning eigenstates and eigenvalues to Qobj class.; Added fileio for saving and loading data sets and/or Qobj’s.; Added hinton function for visualizing density matrices. Bug Fixes¶. Switched Examples to new Signals method used in PySide 1.0.6+.; Switched ProgressBar to new Signals method.; Fixed memory issue in expm functions.; Fixed memory bug in isherm.; Made all Qobj data complex by default.; Reduced ODE tolerance levels in Odeoptions.; Fixed bug in ptrace where dense matrix was used instead of sparse.; Fixed issue where PyQt4 version would not be displayed in about box.; Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011)¶. Initial release. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:46527,concurren,concurrence,46527,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,1,['concurren'],['concurrence']
Performance," to tensor function output.; Removed openmp flags from setup.py as new Mac Xcode compiler does not recognize them.; Qobj diag method now returns real array if all imaginary parts are zero.; Examples GUI now links to new documentation.; Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011)¶. Bug Fixes¶. Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011)¶; THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE. New Functions¶. Added linear entropy function.; Number of CPU’s can now be changed. Bug Fixes¶. Metrics no longer use dense matrices.; Fixed Bloch sphere grid issue with matplotlib 1.1.; Qobj trace operation uses only sparse matrices.; Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011)¶; THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED. New Functions¶. tidyup function to remove small elements from a Qobj.; Added concurrence function.; Added simdiag for simultaneous diagonalization of operators.; Added eigenstates method returning eigenstates and eigenvalues to Qobj class.; Added fileio for saving and loading data sets and/or Qobj’s.; Added hinton function for visualizing density matrices. Bug Fixes¶. Switched Examples to new Signals method used in PySide 1.0.6+.; Switched ProgressBar to new Signals method.; Fixed memory issue in expm functions.; Fixed memory bug in isherm.; Made all Qobj data complex by default.; Reduced ODE tolerance levels in Odeoptions.; Fixed bug in ptrace where dense matrix was used instead of sparse.; Fixed issue where PyQt4 version would not be displayed in about box.; Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011)¶. Initial release. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 20",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/changelog.html:29643,concurren,concurrence,29643,docs/4.5/changelog.html,https://qutip.org,https://qutip.org/docs/4.5/changelog.html,1,['concurren'],['concurrence']
Performance," to tensor function output.; Removed openmp flags from setup.py as new Mac Xcode compiler does not recognize them.; Qobj diag method now returns real array if all imaginary parts are zero.; Examples GUI now links to new documentation.; Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011)¶. Bug Fixes¶. Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011)¶; THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE. New Functions¶. Added linear entropy function.; Number of CPU’s can now be changed. Bug Fixes¶. Metrics no longer use dense matrices.; Fixed Bloch sphere grid issue with matplotlib 1.1.; Qobj trace operation uses only sparse matrices.; Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011)¶; THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED. New Functions¶. tidyup function to remove small elements from a Qobj.; Added concurrence function.; Added simdiag for simultaneous diagonalization of operators.; Added eigenstates method returning eigenstates and eigenvalues to Qobj class.; Added fileio for saving and loading data sets and/or Qobj’s.; Added hinton function for visualizing density matrices. Bug Fixes¶. Switched Examples to new Signals method used in PySide 1.0.6+.; Switched ProgressBar to new Signals method.; Fixed memory issue in expm functions.; Fixed memory bug in isherm.; Made all Qobj data complex by default.; Reduced ODE tolerance levels in Odeoptions.; Fixed bug in ptrace where dense matrix was used instead of sparse.; Fixed issue where PyQt4 version would not be displayed in about box.; Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011)¶. Initial release. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 20",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/changelog.html:25689,concurren,concurrence,25689,docs/4.4/changelog.html,https://qutip.org,https://qutip.org/docs/4.4/changelog.html,1,['concurren'],['concurrence']
Performance," to tensor function output.; Removed openmp flags from setup.py as new Mac Xcode compiler does not recognize them.; Qobj diag method now returns real array if all imaginary parts are zero.; Examples GUI now links to new documentation.; Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011)¶. Bug Fixes¶. Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011)¶; THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE. New Functions¶. Added linear entropy function.; Number of CPU’s can now be changed. Bug Fixes¶. Metrics no longer use dense matrices.; Fixed Bloch sphere grid issue with matplotlib 1.1.; Qobj trace operation uses only sparse matrices.; Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011)¶; THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED. New Functions¶. tidyup function to remove small elements from a Qobj.; Added concurrence function.; Added simdiag for simultaneous diagonalization of operators.; Added eigenstates method returning eigenstates and eigenvalues to Qobj class.; Added fileio for saving and loading data sets and/or Qobj’s.; Added hinton function for visualizing density matrices. Bug Fixes¶. Switched Examples to new Signals method used in PySide 1.0.6+.; Switched ProgressBar to new Signals method.; Fixed memory issue in expm functions.; Fixed memory bug in isherm.; Made all Qobj data complex by default.; Reduced ODE tolerance levels in Odeoptions.; Fixed bug in ptrace where dense matrix was used instead of sparse.; Fixed issue where PyQt4 version would not be displayed in about box.; Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011)¶. Initial release. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/changelog.html:20213,concurren,concurrence,20213,docs/4.0.2/changelog.html,https://qutip.org,https://qutip.org/docs/4.0.2/changelog.html,1,['concurren'],['concurrence']
Performance," to tensor function output.; Removed openmp flags from setup.py as new Mac Xcode compiler does not recognize them.; Qobj diag method now returns real array if all imaginary parts are zero.; Examples GUI now links to new documentation.; Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011)¶. Bug Fixes¶. Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011)¶; THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE. New Functions¶. Added linear entropy function.; Number of CPU’s can now be changed. Bug Fixes¶. Metrics no longer use dense matrices.; Fixed Bloch sphere grid issue with matplotlib 1.1.; Qobj trace operation uses only sparse matrices.; Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011)¶; THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED. New Functions¶. tidyup function to remove small elements from a Qobj.; Added concurrence function.; Added simdiag for simultaneous diagonalization of operators.; Added eigenstates method returning eigenstates and eigenvalues to Qobj class.; Added fileio for saving and loading data sets and/or Qobj’s.; Added hinton function for visualizing density matrices. Bug Fixes¶. Switched Examples to new Signals method used in PySide 1.0.6+.; Switched ProgressBar to new Signals method.; Fixed memory issue in expm functions.; Fixed memory bug in isherm.; Made all Qobj data complex by default.; Reduced ODE tolerance levels in Odeoptions.; Fixed bug in ptrace where dense matrix was used instead of sparse.; Fixed issue where PyQt4 version would not be displayed in about box.; Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011)¶. Initial release. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/changelog.html:22579,concurren,concurrence,22579,docs/4.2/changelog.html,https://qutip.org,https://qutip.org/docs/4.2/changelog.html,1,['concurren'],['concurrence']
Performance," to tensor function output.; Removed openmp flags from setup.py as new Mac Xcode compiler does not recognize them.; Qobj diag method now returns real array if all imaginary parts are zero.; Examples GUI now links to new documentation.; Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011)¶. Bug Fixes¶. Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011)¶; THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE. New Functions¶. Added linear entropy function.; Number of CPU’s can now be changed. Bug Fixes¶. Metrics no longer use dense matrices.; Fixed Bloch sphere grid issue with matplotlib 1.1.; Qobj trace operation uses only sparse matrices.; Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011)¶; THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED. New Functions¶. tidyup function to remove small elements from a Qobj.; Added concurrence function.; Added simdiag for simultaneous diagonalization of operators.; Added eigenstates method returning eigenstates and eigenvalues to Qobj class.; Added fileio for saving and loading data sets and/or Qobj’s.; Added hinton function for visualizing density matrices. Bug Fixes¶. Switched Examples to new Signals method used in PySide 1.0.6+.; Switched ProgressBar to new Signals method.; Fixed memory issue in expm functions.; Fixed memory bug in isherm.; Made all Qobj data complex by default.; Reduced ODE tolerance levels in Odeoptions.; Fixed bug in ptrace where dense matrix was used instead of sparse.; Fixed issue where PyQt4 version would not be displayed in about box.; Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011)¶. Initial release. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/changelog.html:20917,concurren,concurrence,20917,docs/4.1/changelog.html,https://qutip.org,https://qutip.org/docs/4.1/changelog.html,1,['concurren'],['concurrence']
Performance," to tensor function output.; Removed openmp flags from setup.py as new Mac Xcode compiler does not recognize them.; Qobj diag method now returns real array if all imaginary parts are zero.; Examples GUI now links to new documentation.; Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011)¶. Bug Fixes¶. Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011)¶; THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE. New Functions¶. Added linear entropy function.; Number of CPU’s can now be changed. Bug Fixes¶. Metrics no longer use dense matrices.; Fixed Bloch sphere grid issue with matplotlib 1.1.; Qobj trace operation uses only sparse matrices.; Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011)¶; THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED. New Functions¶. tidyup function to remove small elements from a Qobj.; Added concurrence function.; Added simdiag for simultaneous diagonalization of operators.; Added eigenstates method returning eigenstates and eigenvalues to Qobj class.; Added fileio for saving and loading data sets and/or Qobj’s.; Added hinton function for visualizing density matrices. Bug Fixes¶. Switched Examples to new Signals method used in PySide 1.0.6+.; Switched ProgressBar to new Signals method.; Fixed memory issue in expm functions.; Fixed memory bug in isherm.; Made all Qobj data complex by default.; Reduced ODE tolerance levels in Odeoptions.; Fixed bug in ptrace where dense matrix was used instead of sparse.; Fixed issue where PyQt4 version would not be displayed in about box.; Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011)¶. Initial release. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided b",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/changelog.html:24063,concurren,concurrence,24063,docs/4.3/changelog.html,https://qutip.org,https://qutip.org/docs/4.3/changelog.html,1,['concurren'],['concurrence']
Performance," to tensor function output.; Removed openmp flags from setup.py as new Mac Xcode compiler does not recognize them.; Qobj diag method now returns real array if all imaginary parts are zero.; Examples GUI now links to new documentation.; Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011)¶. Bug Fixes¶. Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011)¶; THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE. New Functions¶. Added linear entropy function.; Number of CPU’s can now be changed. Bug Fixes¶. Metrics no longer use dense matrices.; Fixed Bloch sphere grid issue with matplotlib 1.1.; Qobj trace operation uses only sparse matrices.; Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011)¶; THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED. New Functions¶. tidyup function to remove small elements from a Qobj.; Added concurrence function.; Added simdiag for simultaneous diagonalization of operators.; Added eigenstates method returning eigenstates and eigenvalues to Qobj class.; Added fileio for saving and loading data sets and/or Qobj’s.; Added hinton function for visualizing density matrices. Bug Fixes¶. Switched Examples to new Signals method used in PySide 1.0.6+.; Switched ProgressBar to new Signals method.; Fixed memory issue in expm functions.; Fixed memory bug in isherm.; Made all Qobj data complex by default.; Reduced ODE tolerance levels in Odeoptions.; Fixed bug in ptrace where dense matrix was used instead of sparse.; Fixed issue where PyQt4 version would not be displayed in about box.; Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011)¶. Initial release. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. .",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/changelog.html:59015,concurren,concurrence,59015,docs/4.7/changelog.html,https://qutip.org,https://qutip.org/docs/4.7/changelog.html,1,['concurren'],['concurrence']
Performance," values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Manipulating States and Operators. Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the tutorials web page. State Vectors (kets or bras)¶; Here we begin by creating a Fock qutip.states.basis vacuum state vector \(\left|0\right>\) with in a Hilbert space with 5 number states, from 0 to 4:; In [1]: vac = basis(5, 0). In [2]: vac; Out[2]: ; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator \(\left(\hat{a}\right)\) corresponding to 5 number states using the qutip.operators.destroy function:; In [3]: a = destroy(5). In [4]: a; Out[4]: ; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. 0. ]; [0. 0. 1.41421356 0. 0. ]; [0. 0. 0. 1.73205081 0. ]; [0. 0. 0. 0. 2. ]; [0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state vac,; In [5]: a * vac; Out[5]: ; Quant",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-states.html:1338,perform,performing,1338,docs/4.5/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-states.html,1,['perform'],['performing']
Performance," when the dimension of the Hamiltonian is very large, a point at which exact calculations on the complete subspace are practically impossible.; One of the biggest problems with this type of method is the control of the error. After a short time, the error starts to grow exponentially. However, this can be easily corrected by restarting the subspace when the error reaches a certain threshold. Therefore, a series of \(M\) Krylov-subspace time evolutions provides accurate solutions for the complete time evolution. Within this scheme, the magic of Krylov resides not only in its ability to capture complex time evolutions from very large Hilbert spaces with very small dimenions \(M\), but also in the computing speed-up it presents.; For exceptional cases, the Lanczos algorithm might arrive at the exact evolution of the initial state at a dimension \(M_{hb}<M\). This is called a happy breakdown. For example, if a Hamiltonian has a symmetry subspace \(D_{\text{sim}}<M\), then the algorithm will optimize using the value math:M_{hb}<M:, at which the evolution is not only exact but also cheap. Krylov Solver in QuTiP¶; In QuTiP, Krylov-subspace evolution is implemented as the function qutip.krylovsolve. Arguments are nearly the same as qutip.mesolve; function for master-equation evolution, except that the initial state must be a ket vector, as opposed to a density matrix, and the additional parameter krylov_dim that defines the maximum allowed Krylov-subspace dimension. The maximum number of allowed Lanczos partitions can also be determined using the qutip.solver.options.nsteps parameter, which defaults to ‘10000’.; Let’s solve a simple example using the algorithm in QuTiP to get familiar with the method.; >>> from qutip import jmat, rand_ket, krylovsolve; >>> import numpy as np; >>> import matplotlib.pyplot as plt; >>> dim = 100; >>> e_ops = [jmat((dim - 1) / 2.0, ""x""), jmat((dim - 1) / 2.0, ""y""), jmat((dim - 1) / 2.0, ""z"")]; >>> H = .5*jmat((dim - 1) / 2.0, ""z"") + .5*jmat((di",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html:3863,optimiz,optimize,3863,docs/4.7/guide/dynamics/dynamics-krylov.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html,1,['optimiz'],['optimize']
Performance,"""Can only calculate overlap for state vector Qobjs""; raise TypeError(err). elif self.isoper:; if other.isket or other.isbra:; return (self.dag() * qutip.states.ket2dm(other)).tr(); elif other.isoper:; return (self.dag() * other).tr(); else:; err = ""Can only calculate overlap for state vector Qobjs""; raise TypeError(err). raise TypeError(""Can only calculate overlap for state vector Qobjs""). [docs] def eigenstates(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenstates and eigenenergies. Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver. sort : str; Sort eigenvalues (and vectors) 'low' to high, or 'high' to low. eigvals : int; Number of requested eigenvalues. Default is all eigenvalues. tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. eigvecs : array; Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; evals, evecs = sp_eigs(self.data, self.isherm, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol,; maxiter=maxiter); new_dims = [self.dims[0], [1] * len(self.dims[0])]; ekets = np.array([Qobj(vec, dims=new_dims) for vec in evecs],; dtype=object); norms = np.array([ket.norm() for ket in ekets]); return evals, ekets / norms. [docs] def eigenenergies(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; sort : str; Sort",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobj.html:42406,perform,performed,42406,docs/4.5/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobj.html,1,['perform'],['performed']
Performance,"""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params). # Currently the only working option for tslot computer is; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params). # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn). optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params). # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc. optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.targ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:65650,optimiz,optimizer,65650,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,2,['optimiz'],['optimizer']
Performance,"#####################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; """"""; import numpy as np; # QuTiP; from qutip import Qobj; import qutip.logging as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen. [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=-np.Inf, amp_ubound=np.Inf,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=1e7,; dyn_type='GEN_MAT', prop_type='DEF',; fid_type='DEF', phase_option=None, fid_err_scale_factor=None,; amp_update_mode='ALL',; init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piec",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:4251,optimiz,optimizer,4251,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,2,['optimiz'],['optimizer']
Performance,"#########. __all__ = ['mcsolve']. import os; from types import FunctionType; import numpy as np; from numpy.random import RandomState, random_integers; from scipy.integrate import ode; import scipy.sparse as sp; from scipy.integrate._ode import zvode; from scipy.linalg.blas import get_blas_funcs; from qutip.qobj import Qobj; from qutip.parallel import parfor, parallel_map, serial_map; from qutip.cy.spmatfuncs import cy_ode_rhs, cy_expect_psi_csr, spmv, spmv_csr; from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup; from qutip.solver import Options, Result, config; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; import qutip.settings. dznrm2 = get_blas_funcs(""znrm2"", dtype=np.float64). if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions; #; _cy_col_spmv_func = None; _cy_col_expect_func = None; _cy_col_spmv_call_func = None; _cy_col_expect_call_func = None; _cy_rhs_func = None. class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops, e_ops, ntraj=None,; args={}, options=None, progress_bar=True,; map_func=None, map_kwargs=None):; """"""Monte Carlo evolution of a state vector :math:`|\psi \\rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, consider a Hamiltonian with two; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:4249,load,loaded,4249,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['load'],['loaded']
Performance,"() * sm]). # change initial state; psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j)). # run again, reusing data; options = Options(rhs_reuse=True); data2 = mcsolve(H, psi1, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm],; options=options). # plot both results; plot(times, data1.expect[0], times, data1.expect[1], lw=2); plot(times, data2.expect[0], '--', times, data2.expect[1], '--', lw=2); title('Monte Carlo time evolution'); xlabel('Time', fontsize=14); ylabel('Expectation values', fontsize=14); legend((""cavity photon number"", ""atom excitation probability"")); show(). In addition to the initial state, one may reuse the Hamiltonian data when changing the number of trajectories ntraj or simulation times times. The reusing of Hamiltonian data is also supported for time-dependent Hamiltonians. See Solving Problems with Time-dependent Hamiltonians for further details. Fortran Based Monte Carlo Solver¶. Note; In order to use the Fortran Monte Carlo solver, you must have the blas development libraries, and installed QuTiP using the flag: --with-f90mc. In performing time-independent Monte Carlo simulations with QuTiP, systems with small Hilbert spaces suffer from poor performance as the ODE solver must exit the ODE solver at each time step and check for the state vector norm. To correct this, QuTiP now includes an optional Fortran based Monte Carlo solver that has markedly enhanced performance for smaller systems. Using the Fortran based solver is extremely simple; one just needs to replace mcsolve with mcsolve_f90. For example, from our previous demonstation:; data1 = mcsolve_f90(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]). In using the Fortran solver, there are a few limitations that must be kept in mind. First, this solver only works for time-independent systems. Second, you can not pass a list of trajectories to ntraj. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-monte.html:12873,perform,performing,12873,docs/3.0.1/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-monte.html,3,['perform'],"['performance', 'performing']"
Performance,"() * sm]). # change initial state; psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j)). # run again, reusing data; options = Options(rhs_reuse=True); data2 = mcsolve(H, psi1, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm],; options=options). # plot both results; plot(times, data1.expect[0], times, data1.expect[1], lw=2); plot(times, data2.expect[0], '--', times, data2.expect[1], '--', lw=2); title('Monte Carlo time evolution'); xlabel('Time', fontsize=14); ylabel('Expectation values', fontsize=14); legend((""cavity photon number"", ""atom excitation probability"")); show(). In addition to the initial state, one may reuse the Hamiltonian data when changing the number of trajectories ntraj or simulation times times. The reusing of Hamiltonian data is also supported for time-dependent Hamiltonians. See Solving Problems with Time-dependent Hamiltonians for further details. Fortran Based Monte Carlo Solver¶. Note; In order to use the Fortran Monte Carlo solver, you must have the blas development libraries, and installed QuTiP using the flag: --with-f90mc. In performing time-independent Monte Carlo simulations with QuTiP, systems with small Hilbert spaces suffer from poor performance as the ODE solver must exit the ODE solver at each time step and check for the state vector norm. To correct this, QuTiP now includes an optional Fortran based Monte Carlo solver that has markedly enhanced performance for smaller systems. Using the Fortran based solver is extremely simple; one just needs to replace mcsolve with mcsolve_f90. For example, from our previous demonstation:; data1 = mcsolve_f90(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]). In using the Fortran solver, there are a few limitations that must be kept in mind. First, this solver only works for time-independent systems. Second, you can not pass a list of trajectories to ntraj. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html:12811,perform,performing,12811,docs/3.0.0/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html,3,['perform'],"['performance', 'performing']"
Performance,"() requires CVXPY to be installed.""). # We follow the strategy of using Watrous' simpler semidefinite; # program in its primal form. This is the same strategy used,; # for instance, by both pyGSTi and SchattenNorms.jl. (By contrast,; # QETLAB uses the dual problem.). # Check if A and B are both unitaries. If so, then we can without; # loss of generality choose B to be the identity by using the; # unitary invariance of the diamond norm,; # || A - B ||_♢ = || A B⁺ - I ||_♢.; # Then, using the technique mentioned by each of Johnston and; # da Silva,; # || A B⁺ - I ||_♢ = max_{i, j} | \lambda_i(A B⁺) - \lambda_j(A B⁺) |,; # where \lambda_i(U) is the ith eigenvalue of U. if (; # There's a lot of conditions to check for this path.; not force_solve and B is not None and; # Only check if they aren't superoperators.; A.type == ""oper"" and B.type == ""oper"" and; # The difference of unitaries optimization is currently; # only implemented for d == 2. Much of the code below is more general,; # though, in anticipation of generalizing the optimization.; A.shape[0] == 2; ):; # Make an identity the same size as A and B to; # compare against.; I = qeye(A.dims[0]); # Compare to B first, so that an error is raised; # as soon as possible.; Bd = B.dag(); if (; (B * Bd - I).norm() < 1e-6 and; (A * A.dag() - I).norm() < 1e-6; ):; # Now we are on the fast path, so let's compute the; # eigenvalues, then find the diameter of the smallest circle; # containing all of them.; #; # For now, this is only implemented for dim = 2, such that; # generalizing here will allow for generalizing the optimization.; # A reasonable approach would probably be to use Welzl's algorithm; # (https://en.wikipedia.org/wiki/Smallest-circle_problem).; U = A * B.dag(); eigs = U.eigenenergies(); eig_distances = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A). if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/metrics.html:11778,optimiz,optimization,11778,docs/4.4/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/metrics.html,3,['optimiz'],['optimization']
Performance,"() requires CVXPY to be installed.""). # We follow the strategy of using Watrous' simpler semidefinite; # program in its primal form. This is the same strategy used,; # for instance, by both pyGSTi and SchattenNorms.jl. (By contrast,; # QETLAB uses the dual problem.). # Check if A and B are both unitaries. If so, then we can without; # loss of generality choose B to be the identity by using the; # unitary invariance of the diamond norm,; # || A - B ||_♢ = || A B⁺ - I ||_♢.; # Then, using the technique mentioned by each of Johnston and; # da Silva,; # || A B⁺ - I ||_♢ = max_{i, j} | \lambda_i(A B⁺) - \lambda_j(A B⁺) |,; # where \lambda_i(U) is the ith eigenvalue of U. if (; # There's a lot of conditions to check for this path.; not force_solve and B is not None and; # Only check if they aren't superoperators.; A.type == ""oper"" and B.type == ""oper"" and; # The difference of unitaries optimization is currently; # only implemented for d == 2. Much of the code below is more general,; # though, in anticipation of generalizing the optimization.; A.shape[0] == 2; ):; # Make an identity the same size as A and B to; # compare against.; I = qeye(A.dims[0]); # Compare to B first, so that an error is raised; # as soon as possible.; Bd = B.dag(); if (; (B * Bd - I).norm() < 1e-6 and; (A * A.dag() - I).norm() < 1e-6; ):; # Now we are on the fast path, so let's compute the; # eigenvalues, then find the diameter of the smallest circle; # containing all of them.; #; # For now, this is only implemented for dim = 2, such that; # generalizing here will allow for generalizing the optimization.; # A reasonable approach would probably be to use Welzl's algorithm; # (https://en.wikipedia.org/wiki/Smallest-circle_problem).; U = A * B.dag(); eigs = U.eigenenergies(); eig_distances = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A); ; if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/metrics.html:10238,optimiz,optimization,10238,docs/4.2/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/metrics.html,5,['optimiz'],['optimization']
Performance,"(October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Wigner function; Custom Color Maps. Husimi Q-function. Visualizing operators; Quantum process tomography; Implementation in QuTiP. « Plotting on the ... Parallel computa... ». Visualization of quantum states and processes¶; Visualization is often an important complement to a simulation of a quantum; mechanical system. The first method of visualization that come to mind might be; to plot the expectation values of a few selected operators. But on top of that,; it can often be instructive to visualize for example the state vectors or; density matices that describe the state of the system, or how the state is; transformed as a function of time (see process tomography below). In this; section we demonstrate how QuTiP and matplotlib can be used to perform a few; types of visualizations that often can provide additional understanding of; quantum system. Fock-basis probability distribution¶; In quantum mechanics probability distributions plays an important role, and as; in statistics, the expectation values computed from a probability distribution; does not reveal the full story. For example, consider an quantum harmonic; oscillator mode with Hamiltonian \(H = \hbar\omega a^\dagger a\), which is; in a state described by its density matrix \(\rho\), and which on average; is occupied by two photons, \(\mathrm{Tr}[\rho a^\dagger a] = 2\). Given; this information we cannot say whether the oscillator is in a Fock state,; a thermal state, a coherent state, etc. By visualizing the photon distribution; in the Fock state basis important clues about the underlying state can be; obtained.; One convenient way to visualize a probability distribution is to use histograms.; Consider the following histogram visualization of the number-basis probability; distribut",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-visualization.html:2419,perform,perform,2419,docs/3.1.0/guide/guide-visualization.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-visualization.html,1,['perform'],['perform']
Performance,"(October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Wigner function; Custom Color Maps. Husimi Q-function. Visualizing operators; Quantum process tomography; Implementation in QuTiP. « Plotting on the ... Running Problems... ». Visualization of quantum states and processes¶; Visualization is often an important complement to a simulation of a quantum; mechanical system. The first method of visualization that come to mind might be; to plot the expectation values of a few selected operators. But on top of that,; it can often be instructive to visualize for example the state vectors or; density matices that describe the state of the system, or how the state is; transformed as a function of time (see process tomography below). In this; section we demonstrate how QuTiP and matplotlib can be used to perform a few; types of visualizations that often can provide additional understanding of; quantum system. Fock-basis probability distribution¶; In quantum mechanics probability distributions plays an important role, and as; in statistics, the expectation values computed from a probability distribution; does not reveal the full story. For example, consider an quantum harmonic; oscillator mode with Hamiltonian \(H = \hbar\omega a^\dagger a\), which is; in a state described by its density matrix \(\rho\), and which on average; is occupied by two photons, \(\mathrm{Tr}[\rho a^\dagger a] = 2\). Given; this information we cannot say whether the oscillator is in a Fock state,; a thermal state, a coherent state, etc. By visualizing the photon distribution; in the Fock state basis important clues about the underlying state can be; obtained.; One convenient way to visualize a probability distribution is to use histograms.; Consider the following histogram visualization of the number-basis probability; distribut",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-visualization.html:2317,perform,perform,2317,docs/3.0.0/guide/guide-visualization.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-visualization.html,2,['perform'],['perform']
Performance,(in module qutip.mesolve). momentum() (in module qutip.operators). N. n_thermal() (in module qutip.utilities). norm() (Qobj method). normalize_gradient_PSU() (FidCompUnitary method). normalize_gradient_SU() (FidCompUnitary method). normalize_PSU() (FidCompUnitary method). normalize_SU() (FidCompUnitary method). num() (in module qutip.operators). num_ctrls (Dynamics attribute). O. ode2es() (in module qutip.essolve). onto_evo (Dynamics attribute). onwd_evo (Dynamics attribute). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircuitProcessor method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). phase() (in module qutip.operators). phase_basis() (in module qutip.states). phasegate() (in module qutip.qip.gates). plot_energy_levels() (in module qutip.visualization). plot_expectation_values() (in module qutip.visualization). plot_fock_distribution() (in module qutip.visualization). plot_pulses() (CircuitProcessor method). plot_qubism() (in module qutip.visualization). plot_sc,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/genindex.html:10912,optimiz,optimizer,10912,docs/4.1/genindex.html,https://qutip.org,https://qutip.org/docs/4.1/genindex.html,2,['optimiz'],['optimizer']
Performance,"(inpt.shape[0])], [int(inpt.shape[1])]]; else:; self.dims = dims. elif isinstance(inpt, (int, float, complex,; np.integer, np.floating, np.complexfloating)):; # if input is int, float, or complex then convert to array; _tmp = sp.csr_matrix([[inpt]], dtype=complex); self._data = fast_csr_matrix((_tmp.data, _tmp.indices, _tmp.indptr),; shape=_tmp.shape); if not np.any(dims):; self.dims = [[1], [1]]; else:; self.dims = dims. else:; warnings.warn(""Initializing Qobj from unsupported type: %s"" %; builtins.type(inpt)); inpt = np.array([[0]]); _tmp = sp.csr_matrix(inpt, dtype=complex, copy=copy); self._data = fast_csr_matrix((_tmp.data, _tmp.indices, _tmp.indptr),; shape = _tmp.shape); self.dims = [[int(inpt.shape[0])], [int(inpt.shape[1])]]. if type == 'super':; if self.type == 'oper':; self.dims = [[[d] for d in self.dims[0]],; [[d] for d in self.dims[1]]]. if superrep:; self.superrep = superrep; else:; if self.type == 'super' and self.superrep is None:; self.superrep = 'super'. # clear type cache; self._type = None. [docs] def copy(self):; """"""Create identical copy""""""; return Qobj(inpt=self). def get_data(self):; return self._data; #Here we perfrom a check of the csr matrix type during setting of Q.data; def set_data(self, data):; if not isinstance(data, fast_csr_matrix):; raise TypeError('Qobj data must be in fast_csr format.'); else:; self._data = data; data = property(get_data, set_data). def __add__(self, other):; """"""; ADDITION with Qobj on LEFT [ ex. Qobj+4 ]; """"""; if isinstance(other, eseries):; return other.__radd__(self). if not isinstance(other, Qobj):; other = Qobj(other). if np.prod(other.shape) == 1 and np.prod(self.shape) != 1:; # case for scalar quantum object; dat = other.data[0, 0]; if dat == 0:; return self. out = Qobj(). if self.type in ['oper', 'super']:; out.data = self.data + dat * fast_identity(; self.shape[0]); else:; out.data = self.data; out.data.data = out.data.data + dat. out.dims = self.dims; ; if settings.auto_tidyup: out.tidyup(); ; if isinst",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/qobj.html:10685,cache,cache,10685,docs/4.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html,1,['cache'],['cache']
Performance,"(inpt.shape[0])], [int(inpt.shape[1])]]; else:; self.dims = dims. elif isinstance(inpt, (int, float, complex,; np.integer, np.floating, np.complexfloating)):; # if input is int, float, or complex then convert to array; _tmp = sp.csr_matrix([[inpt]], dtype=complex); self._data = fast_csr_matrix((_tmp.data, _tmp.indices, _tmp.indptr),; shape=_tmp.shape); if not np.any(dims):; self.dims = [[1], [1]]; else:; self.dims = dims. else:; warnings.warn(""Initializing Qobj from unsupported type: %s"" %; builtins.type(inpt)); inpt = np.array([[0]]); _tmp = sp.csr_matrix(inpt, dtype=complex, copy=copy); self._data = fast_csr_matrix((_tmp.data, _tmp.indices, _tmp.indptr),; shape = _tmp.shape); self.dims = [[int(inpt.shape[0])], [int(inpt.shape[1])]]. if type == 'super':; if self.type == 'oper':; self.dims = [[[d] for d in self.dims[0]],; [[d] for d in self.dims[1]]]. if superrep:; self.superrep = superrep; else:; if self.type == 'super' and self.superrep is None:; self.superrep = 'super'. # clear type cache; self._type = None. [docs] def copy(self):; """"""Create identical copy""""""; return Qobj(inpt=self). def get_data(self):; return self._data; #Here we perfrom a check of the csr matrix type during setting of Q.data; def set_data(self, data):; if not isinstance(data, fast_csr_matrix):; raise TypeError('Qobj data must be in fast_csr format.'); else:; self._data = data; data = property(get_data, set_data). def __add__(self, other):; """"""; ADDITION with Qobj on LEFT [ ex. Qobj+4 ]; """"""; if isinstance(other, eseries):; return other.__radd__(self). if not isinstance(other, Qobj):; other = Qobj(other). if np.prod(other.shape) == 1 and np.prod(self.shape) != 1:; # case for scalar quantum object; dat = other.data[0, 0]; if dat == 0:; return self. out = Qobj(). if self.type in ['oper', 'super']:; out.data = self.data + dat * fast_identity(; self.shape[0]); else:; out.data = self.data; out.data.data = out.data.data + dat. out.dims = self.dims; if isinstance(dat, (int, float)):; out._isherm = sel",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/qobj.html:10631,cache,cache,10631,docs/4.1/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/qobj.html,1,['cache'],['cache']
Performance,"(self.data,bra.data,ket.data,1). elif bra.isket and ket.isket:; return zcsr_mat_elem(self.data,bra.data,ket.data,0); else:; raise TypeError(""Can only calculate matrix elements for bra and ket vectors.""). [docs] def overlap(self, other):; """"""Overlap between two state vectors. Gives the overlap (inner product) between the current bra or ket Qobj; and and another bra or ket Qobj. Parameters; -----------; other : qobj; Quantum object for a state vector of type 'ket' or 'bra'. Returns; -------; overlap : complex; Complex valued overlap. Raises; ------; TypeError; Can only calculate overlap between a bra and ket quantum objects. Notes; -----; Since QuTiP mainly deals with ket vectors, the most efficient inner product; call is the ket-ket version that computes the product <self|other> with; both vectors expressed as kets. """""". if isinstance(other, Qobj):. if self.isbra:; if other.isket:; return zcsr_inner(self.data, other.data, 1); elif other.isbra:; #Since we deal mainly with ket vectors, the bra-bra combo; #is not common, and not optimized.; return zcsr_inner(self.data, other.dag().data, 1); else:; raise TypeError(""Can only calculate overlap for state vector Qobjs""). elif self.isket:; if other.isbra:; return zcsr_inner(other.data, self.data, 1); elif other.isket:; return zcsr_inner(self.data, other.data, 0); else:; raise TypeError(""Can only calculate overlap for state vector Qobjs""). raise TypeError(""Can only calculate overlap for state vector Qobjs""). [docs] def eigenstates(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenstates and eigenenergies. Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver. sort : str; Sort eigenvalues (and vectors) 'low' to high, or 'high' to low. eigvals : int; Number of requested eigenvalues. Default is all eigenvalues. tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not conv",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/qobj.html:38861,optimiz,optimized,38861,docs/4.3/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/qobj.html,1,['optimiz'],['optimized']
Performance,"(value):; raise ValueError(""File name base must be a string""); self._fname_base = value; self._summary_file_path = None. @property; def summary_file(self):; if self._summary_file_path is None:; fname = ""{}-summary.{}"".format(self._fname_base, self.dump_file_ext); self._summary_file_path = os.path.join(self.dump_dir, fname); return self._summary_file_path. @summary_file.setter; def summary_file(self, value):; if not _is_string(value):; raise ValueError(""File path must be a string""); self._summary_file_specified = True; if os.path.abspath(value):; self._summary_file_path = value; elif '~' in value:; self._summary_file_path = os.path.expanduser(value); else:; self._summary_file_path = os.path.join(self.dump_dir, value). [docs]class OptimDump(Dump):; """"""; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes; ----------; dump_summary : bool; When True summary items are appended to the iter_summary. iter_summary : list of :class:`qutip.control.optimizer.OptimIterSummary`; Summary at each iteration. dump_fid_err : bool; When True values are appended to the fid_err_log. fid_err_log : list of float; Fidelity error at each call of the fid_err_func. dump_grad_norm : bool; When True values are appended to the fid_err_log. grad_norm_log : list of float; Gradient norm at each call of the grad_norm_log. dump_grad : bool; When True values are appended to the grad_log. grad_log : list of ndarray; Gradients at each call of the fid_grad_func. """"""; def __init__(self, optim, level='SUMMARY'):; from qutip.control.optimizer import Optimizer; if not isinstance(optim, Optimizer):; raise TypeError(""Must instantiate with {} type"".format(; Optimizer)); self.parent = optim; self._level = level; self.reset(). def reset(self):; Dump.reset(self); self._apply_level(); self.iter_summary = []; self.fid_err_log = []; self.grad_norm_log = []; self.grad_log = []; self._fname_base = 'optimdump'; self._fid_err_file = None; self._grad_norm_file = None. def clear(s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/dump.html:5799,optimiz,optimizer,5799,docs/4.7/modules/qutip/control/dump.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/dump.html,1,['optimiz'],['optimizer']
Performance,"(“J”, “eV”, “meV”, “GHz”, “mK”). Returns:value_new_unit : float / array. The energy in the new unit. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters:filename : str. Name of file containing reqested data. sep : str. Seperator used to store data. Returns:data : array_like. Data from selected file. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=', ')[source]¶; Stores a matrix of data to a file to be read by an external program. Parameters:filename : str. Name of data file to be stored, including extension. data: array_like. Data to be written to file. numtype : str {‘complex, ‘real’}. Type of numerical data. numformat : str {‘decimal’,’exp’}. Format for written data. sep : str. Single-character field seperator. Usually a tab, space, comma,; or semicolon. qload(name)[source]¶; Loads data file from file named ‘filename.qu’ in current directory. Parameters:name : str. Name of data file to be loaded. Returns:qobject : instance / array_like. Object retrieved from requested file. qsave(data, name='qutip_data')[source]¶; Saves given data to file named ‘filename.qu’ in current directory. Parameters:data : instance/array_like. Input Python object to be stored. filename : str. Name of output data file. Parallelization¶; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1, we recommend to use qutip.parallel_map; instead of this function. Parameters:func : function_type. A function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:194245,load,loaded,194245,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['load'],['loaded']
Performance,"(“J”, “eV”, “meV”, “GHz”, “mK”). Returns:value_new_unit : float / array. The energy in the new unit. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters:filename : str. Name of file containing reqested data. sep : str. Seperator used to store data. Returns:data : array_like. Data from selected file. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=', ')[source]¶; Stores a matrix of data to a file to be read by an external program. Parameters:filename : str. Name of data file to be stored, including extension. data: array_like. Data to be written to file. numtype : str {‘complex, ‘real’}. Type of numerical data. numformat : str {‘decimal’,’exp’}. Format for written data. sep : str. Single-character field seperator. Usually a tab, space, comma,; or semicolon. qload(name)[source]¶; Loads data file from file named ‘filename.qu’ in current directory. Parameters:name : str. Name of data file to be loaded. Returns:qobject : instance / array_like. Object retrieved from requested file. qsave(data, name='qutip_data')[source]¶; Saves given data to file named ‘filename.qu’ in current directory. Parameters:data : instance/array_like. Input Python object to be stored. filename : str. Name of output data file. Parallelization¶; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1.0, we recommend to use qutip.parallel_map; instead of this function. Parameters:func : function_type. A function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have mul",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:156851,load,loaded,156851,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['load'],['loaded']
Performance,) (FidCompUnitary method). normalize_gradient_SU() (FidCompUnitary method). normalize_PSU() (FidCompUnitary method). normalize_SU() (FidCompUnitary method). num() (in module qutip.operators). num_ctrls (Dynamics attribute). O. ode2es() (in module qutip.essolve). onto_evo (Dynamics attribute). onwd_evo (Dynamics attribute). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircuitProcessor method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). phase() (in module qutip.operators). phase_basis() (in module qutip.states). phasegate() (in module qutip.qip.gates). plot_energy_levels() (in module qutip.visualization). plot_expectation_values() (in module qutip.visualization). plot_fock_distribution() (in module qutip.visualization). plot_pulses() (CircuitProcessor method). plot_qubism() (in module qutip.visualization). plot_schmidt() (in module qutip.visualization). plot_spin_distribution_2d() (in module qutip.visualization). plot_spin_distribution_3d() (in module qutip.visualiza,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/genindex.html:11068,optimiz,optimizer,11068,docs/4.1/genindex.html,https://qutip.org,https://qutip.org/docs/4.1/genindex.html,2,['optimiz'],['optimizer']
Performance,) (in module qutip.piqs). num_tls() (in module qutip.piqs). O. ode2es() (in module qutip.essolve). onto_evo() (Dynamics property). onwd_evo() (Dynamics property). operator_at_cells() (Lattice1d method). operator_between_cells() (Lattice1d method). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircularSpinChain method). (DispersiveCavityQED method). (LinearSpinChain method). (SpinChain method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). OptPulseProcessor (class in qutip.qip.device). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). (QobjEvo method). phase() (in module qutip.operators). phase_application() (Dynamics property). phase_basis() (in module qutip.states). phasegate() (in module qutip.qip.operations.gates). photocurrent_mesolve() (in module qutip.stochastic). photocurrent_sesolve() (in module qutip.stochastic). Pim (class in qutip.piqs). pisolve() (Dicke method). plot_berry_curvature() (in module qutip.topology). plot_dispersion() (Lattice1d method). plot_energy_levels() (in module qutip.visualization). plo,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/genindex.html:19986,optimiz,optimizer,19986,docs/4.6/genindex.html,https://qutip.org,https://qutip.org/docs/4.6/genindex.html,2,['optimiz'],['optimizer']
Performance,") system; to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the pulse optim algorithm alg. disp_conv_msgboolSet true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_paramsDictionaryOptions for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_gradboolIf set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. boundsList of floatsBounds ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:188360,optimiz,optimize,188360,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['optimiz'],['optimize']
Performance,") – Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter (int) – Maximum number of iterations performed by sparse solver (if used). Returns:eigvals – Array of eigenvalues for operator. Return type:array. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters:; sparse (bool) – Use sparse Eigensolver; sort (str) – Sort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low.; eigvals (int) – Number of requested eigenvalues. Default is all eigenvalues.; tol (float) – Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter (int) – Maximum number of iterations performed by sparse solver (if used). Returns:; eigvals (array) – Array of eigenvalues for operator.; eigvecs (array) – Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eliminate_states(states_inds, normalize=False)[source]¶; Creates a new quantum object with states in state_inds eliminated. Parameters:; states_inds (list of integer) – The states that should be removed.; normalize (True / False) – Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q – A new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:6960,perform,performed,6960,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['perform'],['performed']
Performance,"). Returns:value_new_unit – The energy in the new unit. Return type:float / array. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters:; filename (str) – Name of file containing reqested data.; sep (str) – Seperator used to store data. Returns:data – Data from selected file. Return type:array_like. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=', ')[source]¶; Stores a matrix of data to a file to be read by an external program. Parameters:; filename (str) – Name of data file to be stored, including extension.; data (array_like) – Data to be written to file.; numtype (str {'complex, 'real'}) – Type of numerical data.; numformat (str {'decimal','exp'}) – Format for written data.; sep (str) – Single-character field seperator. Usually a tab, space, comma,; or semicolon. qload(name)[source]¶; Loads data file from file named ‘filename.qu’ in current directory. Parameters:name (str) – Name of data file to be loaded. Returns:qobject – Object retrieved from requested file. Return type:instance / array_like. qsave(data, name='qutip_data')[source]¶; Saves given data to file named ‘filename.qu’ in current directory. Parameters:; data (instance/array_like) – Input Python object to be stored.; filename (str) – Name of output data file. Parallelization¶; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1, we recommend to use qutip.parallel_map; instead of this function. Parameters:; func (function_type) – A function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In gene",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:196006,load,loaded,196006,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['load'],['loaded']
Performance,). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coeff() (Pulse property). coefficient_matrix() (Dicke method). (Pim method). coeffs() (CircularSpinChain property). (LinearSpinChain property). (ModelProcessor property). (OptPulseProcessor property). (Processor property). (SpinChain property). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). collapse_dims_oper() (in module qutip.dimensions). collapse_dims_super() (in module qutip.dimensions). collapse_uncoupled() (in module qutip.piqs). combine_dyn_gen() (Dynamics method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method). ControlAmpNoise (class in qutip.qip.noise). controlled_gate() (in module qutip.qip.gates). convert_unit() (in module qutip.utilities). copy() (Qobj method). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_3op_1t() (in module qutip.correlation). correlation_3op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). cosm() (Qobj method). covariance_matrix() (in module qutip.continuous_variables). cphase() (in module qutip.qip.gates). create() (in modu,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/genindex.html:4232,concurren,concurrence,4232,docs/4.5/genindex.html,https://qutip.org,https://qutip.org/docs/4.5/genindex.html,1,['concurren'],['concurrence']
Performance,). normalize_PSU() (FidCompUnitary method). normalize_SU() (FidCompUnitary method). num() (in module qutip.operators). num_ctrls (Dynamics attribute). (DynamicsUnitary attribute). num_dicke_ladders() (in module qutip.piqs). num_dicke_states() (in module qutip.piqs). num_tls() (in module qutip.piqs). O. ode2es() (in module qutip.essolve). onto_evo (Dynamics attribute). onwd_evo (Dynamics attribute). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircuitProcessor method). (CircularSpinChain method). (DispersivecQED method). (LinearSpinChain method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). phase() (in module qutip.operators). phase_application (Dynamics attribute). phase_basis() (in module qutip.states). phasegate() (in module qutip.qip.gates). Pim (class in qutip.piqs). pisolve() (Dicke method). plot_energy_levels() (in module qutip.visualization). plot_expectation_values() (in module qutip.visualization). plot_fock_distribution() (in module qutip.visualization). pl,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/genindex.html:12069,optimiz,optimizer,12069,docs/4.3/genindex.html,https://qutip.org,https://qutip.org/docs/4.3/genindex.html,1,['optimiz'],['optimizer']
Performance,). num_ctrls() (Dynamics property). (DynamicsUnitary property). num_dicke_ladders() (in module qutip.piqs). num_tls() (in module qutip.piqs). O. ode2es() (in module qutip.essolve). onto_evo() (Dynamics property). onwd_evo() (Dynamics property). operator_at_cells() (Lattice1d method). operator_between_cells() (Lattice1d method). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircularSpinChain method). (LinearSpinChain method). (SpinChain method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). OptPulseProcessor (class in qutip.qip.device). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). phase() (in module qutip.operators). phase_application() (Dynamics property). phase_basis() (in module qutip.states). phasegate() (in module qutip.qip.gates). photocurrent_mesolve() (in module qutip.stochastic). photocurrent_sesolve() (in module qutip.stochastic). Pim (class in qutip.piqs). pisolve() (Dicke method). plot_berry_curvature() (in module qutip.topology). plot_dispersion() (Lattice1d method). plot_energy_levels() (in module qu,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/genindex.html:16154,optimiz,optimizer,16154,docs/4.5/genindex.html,https://qutip.org,https://qutip.org/docs/4.5/genindex.html,1,['optimiz'],['optimizer']
Performance,"). num_waves (PulseGenPeriodic attribute). O. ode2es() (in module qutip.essolve). offset (PulseGen attribute). omega (DynamicsSymplectic attribute). onto_evo (Dynamics attribute), [1]. onwd_evo (Dynamics attribute), [1]. oper_dtype (Dynamics attribute). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). optim_method (Optimizer attribute). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircuitProcessor method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). optimizer (OptimResult attribute). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). options (HEOMSolver attribute). (MemoryCascade attribute). (StochasticSolverOptions attribute). (TTMSolverOptions attribute). orbital() (in module qutip.orbital). order (Options attribute). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel (MemoryCascade attribute). parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). params (Dynamics attribute). (Optimizer attribute). parent (Dump attribute). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). periodic (PulseGen attribute). permute() (Qobj method), [1]. phase() (in module qutip.operators). phase_basis() (in module qutip.states). phase_option (FidCompUnitary attribute). phasegate() (in module qutip.qip.gates). planck (HEOMSolver attribute). plot_energy_levels() (in module qutip.visualizat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/genindex.html:19066,optimiz,optimizer,19066,docs/4.0.2/genindex.html,https://qutip.org,https://qutip.org/docs/4.0.2/genindex.html,1,['optimiz'],['optimizer']
Performance,"+0.1j 0. +0.j ]; [0. +0.j 0. -0.1j 0.1+0.j 0. +0.j ]; [0.1+0.j 0. +0.j 0. +0.j 0.1+0.j ]]. One convenient property of the \(\chi\) matrix is that the average; gate fidelity with the identity map can be read off directly from; the \(\chi_{00}\) element:; np.testing.assert_almost_equal(average_gate_fidelity(S), 0.9499999999999998). print(chi[0, 0] / 4). Output:; (0.925+0j). Here, the factor of 4 comes from the dimension of the underlying; Hilbert space \(\mathcal{H}\). As with the superoperator; and Choi representations, the \(\chi\) representation is; denoted by the superrep, such that to_super,; to_choi, to_kraus,; to_stinespring and to_chi; all convert from the \(\chi\) representation appropriately. Properties of Quantum Maps¶; In addition to converting between the different representations of quantum maps,; QuTiP also provides attributes to make it easy to check if a map is completely; positive, trace preserving and/or hermicity preserving. Each of these attributes; uses superrep to automatically perform any needed conversions.; In particular, a quantum map is said to be positive (but not necessarily completely; positive) if it maps all positive operators to positive operators. For instance, the; transpose map \(\Lambda(\rho) = \rho^{\mathrm{T}}\) is a positive map. We run into; problems, however, if we tensor \(\Lambda\) with the identity to get a partial; transpose map.; rho = ket2dm(bell_state()); rho_out = partial_transpose(rho, [0, 1]); print(rho_out.eigenenergies()). Output:; [-0.5 0.5 0.5 0.5]. Notice that even though we started with a positive map, we got an operator out; with negative eigenvalues. Complete positivity addresses this by requiring that; a map returns positive operators for all positive operators, and does so even; under tensoring with another map. The Choi matrix is very useful here, as it; can be shown that a map is completely positive if and only if its Choi matrix; is positive [Wat13]. QuTiP implements this check with the iscp; attribute. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-states.html:30509,perform,perform,30509,docs/4.6/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html,2,['perform'],['perform']
Performance,"+= "" and ket vectors.""; raise TypeError(err). [docs] def overlap(self, other):; """"""Overlap between two state vectors or two operators. Gives the overlap (inner product) between the current bra or ket Qobj; and and another bra or ket Qobj. It gives the Hilbert-Schmidt overlap; when one of the Qobj is an operator/density matrix. Parameters; -----------; other : :class:`qutip.Qobj`; Quantum object for a state vector of type 'ket', 'bra' or density; matrix. Returns; -------; overlap : complex; Complex valued overlap. Raises; ------; TypeError; Can only calculate overlap between a bra, ket and density matrix; quantum objects. Notes; -----; Since QuTiP mainly deals with ket vectors, the most efficient inner; product call is the ket-ket version that computes the product; <self|other> with both vectors expressed as kets.; """""". if isinstance(other, Qobj):. if self.isbra:; if other.isket:; return zcsr_inner(self.data, other.data, 1); elif other.isbra:; # Since we deal mainly with ket vectors, the bra-bra combo; # is not common, and not optimized.; return zcsr_inner(self.data, other.dag().data, 1); elif other.isoper:; return (qutip.states.ket2dm(self).dag() * other).tr(); else:; err = ""Can only calculate overlap for state vector Qobjs""; raise TypeError(err). elif self.isket:; if other.isbra:; return zcsr_inner(other.data, self.data, 1); elif other.isket:; return zcsr_inner(self.data, other.data, 0); elif other.isoper:; return (qutip.states.ket2dm(self).dag() * other).tr(); else:; err = ""Can only calculate overlap for state vector Qobjs""; raise TypeError(err). elif self.isoper:; if other.isket or other.isbra:; return (self.dag() * qutip.states.ket2dm(other)).tr(); elif other.isoper:; return (self.dag() * other).tr(); else:; err = ""Can only calculate overlap for state vector Qobjs""; raise TypeError(err). raise TypeError(""Can only calculate overlap for state vector Qobjs""). [docs] def eigenstates(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenstates a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobj.html:40944,optimiz,optimized,40944,docs/4.5/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobj.html,1,['optimiz'],['optimized']
Performance,"+= "" and ket vectors.""; raise TypeError(err). [docs] def overlap(self, other):; """"""Overlap between two state vectors or two operators. Gives the overlap (inner product) between the current bra or ket Qobj; and and another bra or ket Qobj. It gives the Hilbert-Schmidt overlap; when one of the Qobj is an operator/density matrix. Parameters; -----------; other : :class:`qutip.Qobj`; Quantum object for a state vector of type 'ket', 'bra' or density; matrix. Returns; -------; overlap : complex; Complex valued overlap. Raises; ------; TypeError; Can only calculate overlap between a bra, ket and density matrix; quantum objects. Notes; -----; Since QuTiP mainly deals with ket vectors, the most efficient inner; product call is the ket-ket version that computes the product; <self|other> with both vectors expressed as kets.; """""". if isinstance(other, Qobj):. if self.isbra:; if other.isket:; return zcsr_inner(self.data, other.data, 1); elif other.isbra:; # Since we deal mainly with ket vectors, the bra-bra combo; # is not common, and not optimized.; return zcsr_inner(self.data, other.dag().data, 1); elif other.isoper:; return (qutip.states.ket2dm(self).dag() * other).tr(); else:; err = ""Can only calculate overlap for state vector Qobjs""; raise TypeError(err). elif self.isket:; if other.isbra:; return zcsr_inner(other.data, self.data, 1); elif other.isket:; return zcsr_inner(self.data, other.data, 0); elif other.isoper:; return (qutip.states.ket2dm(self).dag() * other).tr(); else:; err = ""Can only calculate overlap for state vector Qobjs""; raise TypeError(err). elif self.isoper:; if other.isket or other.isbra:; return (self.dag() * qutip.states.ket2dm(other)).tr(); elif other.isoper:; return (self.dag() * other).tr(); else:; err = ""Can only calculate overlap for state vector Qobjs""; raise TypeError(err); raise TypeError(""Can only calculate overlap for state vector Qobjs""). [docs] def eigenstates(self, sparse=False, sort='low', eigvals=0,; tol=0, maxiter=100000, phase_fix=None):; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobj.html:41820,optimiz,optimized,41820,docs/4.6/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html,2,['optimiz'],['optimized']
Performance,", fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type_up == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; ; optim.apply_method_params(method_params). if gen_stats:; # Create",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:65165,optimiz,optimizer,65165,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,2,['optimiz'],['optimizer']
Performance,", fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type_up == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; optim.apply_method_params(method_params). if gen_stats:; # Create a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:64771,optimiz,optimizer,64771,docs/4.2/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html,3,['optimiz'],['optimizer']
Performance,", j, m] = u_limits[0]; elif u[r + 1, j, m] > u_limits[1]:; u[r + 1, j, m] = u_limits[1]. u[r + 1, j, -1] = u[r + 1, j, -2]. if use_interp:; ip_funcs = [interp1d(times, u[R - 1, j, :], kind=interp_kind,; bounds_error=False, fill_value=u[R - 1, j, -1]); for j in range(J)]. H_td_func = [H0] + [[H_ops[j], lambda t, args, j=j: ip_funcs[j](t)]; for j in range(J)]; else:; H_td_func = [H0] + [[H_ops[j], u[-1, j, :]] for j in range(J)]. progress_bar.finished(). # return U_f_list[-1], H_td_func, u; return GRAPEResult(u=u, U_f=U_f_list[-1], H_t=H_td_func). def cy_grape_unitary(U, H0, H_ops, R, times, eps=None, u_start=None,; u_limits=None, interp_kind='linear', use_interp=False,; alpha=None, beta=None, phase_sensitive=True,; progress_bar=BaseProgressBar()):; """"""; Calculate control pulses for the Hamitonian operators in H_ops so that the; unitary U is realized. Experimental: Work in progress. Parameters; ----------; U : Qobj; Target unitary evolution operator. H0 : Qobj; Static Hamiltonian (that cannot be tuned by the control fields). H_ops: list of Qobj; A list of operators that can be tuned in the Hamiltonian via the; control fields. R : int; Number of GRAPE iterations. time : array / list; Array of time coordinates for control pulse evalutation. u_start : array; Optional array with initial control pulse values. Returns; -------; Instance of GRAPEResult, which contains the control pulses calculated; with GRAPE, a time-dependent Hamiltonian that is defined by the; control pulses, as well as the resulting propagator.; """""". if eps is None:; eps = 0.1 * (2 * np.pi) / (times[-1]). M = len(times); J = len(H_ops). u = np.zeros((R, J, M)). H_ops_data = [H_op.data for H_op in H_ops]. if u_limits and len(u_limits) != 2:; raise ValueError(""u_limits must be a list with two values""). if u_limits:; warnings.warn(""Causion: Using experimental feature u_limits""). if u_limits and u_start:; # make sure that no values in u0 violates the u_limits conditions; u_start = np.array(u_start); u_start[u",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:9421,tune,tuned,9421,docs/3.1.0/modules/qutip/control/grape.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html,1,['tune'],['tuned']
Performance,", notrace=False)[source]¶; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters:; blist (array_like) – List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger; tlist (array_like) – list of corresponding times t1,..,tn at which to evaluate the field; operators; tau (float) – time-delay; c1 (qutip.Qobj) – system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element); c2 (qutip.Qobj) – system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element); notrace (bool {False}) – If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns:time-propagator for computing field correlation function. Return type:qutip.Qobj. propagator(t, tau, notrace=False)[source]¶; Compute propagator for time t and time-delay tau. Parameters:; t (float) – current time; tau (float) – time-delay; notrace (bool {False}) – If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns:time-propagator for reduced system dynamics. Return type:qutip.Qobj. rhot(rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters:; rho0 (qutip.Qobj) – initial density matrix or state vector (ket); t (float) – current time; tau (float) – time-delay. Returns:density matrix at time \(t\). Return type:qutip.Qobj. class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:33801,perform,performed,33801,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['perform'],['performed']
Performance,", show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:task: a Python function. The function that is to be called for each value in task_vec. task_vec: array / list. The list or array of values for which the task function is to be; evaluated. args: list / dictionary. The optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.Client. The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view. The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False. Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False. Display a HTML-based progress bar duing the execution of the parfor; loop. Returns:result : list. The result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. parallel_map(task, values, task_args=None, task_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:198704,load,load-balanced,198704,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,3,['load'],['load-balanced']
Performance,", squeeze=False). y_max = abs(u).max(). for r in range(R):; for j in range(J):. if r == R - 1:; lw, lc, alpha = 2.0, 'k', 1.0. axes[j, 0].set_ylabel(labels[j], fontsize=18); axes[j, 0].set_xlabel(r'$t$', fontsize=18); axes[j, 0].set_xlim(0, times[-1]). else:; lw, lc, alpha = 0.5, 'b', 0.25. axes[j, 0].step(times, u[r, j, :], lw=lw, color=lc, alpha=alpha). if uniform_axes:; axes[j, 0].set_ylim(-y_max, y_max). fig.tight_layout(). return fig, axes. def _overlap(A, B):; return (A.dag() * B).tr() / A.shape[0]; # return cy_overlap(A.data, B.data). [docs]def grape_unitary(U, H0, H_ops, R, times, eps=None, u_start=None,; u_limits=None, interp_kind='linear', use_interp=False,; alpha=None, beta=None, phase_sensitive=True,; progress_bar=BaseProgressBar()):; """"""; Calculate control pulses for the Hamiltonian operators in H_ops so that the; unitary U is realized. Experimental: Work in progress. Parameters; ----------; U : Qobj; Target unitary evolution operator. H0 : Qobj; Static Hamiltonian (that cannot be tuned by the control fields). H_ops: list of Qobj; A list of operators that can be tuned in the Hamiltonian via the; control fields. R : int; Number of GRAPE iterations. time : array / list; Array of time coordinates for control pulse evalutation. u_start : array; Optional array with initial control pulse values. Returns; -------; Instance of GRAPEResult, which contains the control pulses calculated; with GRAPE, a time-dependent Hamiltonian that is defined by the; control pulses, as well as the resulting propagator.; """""". if eps is None:; eps = 0.1 * (2 * np.pi) / (times[-1]). M = len(times); J = len(H_ops). u = np.zeros((R, J, M)). if u_limits and len(u_limits) != 2:; raise ValueError(""u_limits must be a list with two values""). if u_limits:; warnings.warn(""Caution: Using experimental feature u_limits""). if u_limits and u_start:; # make sure that no values in u0 violates the u_limits conditions; u_start = np.array(u_start); u_start[u_start < u_limits[0]] = u_limits[0]; u_start",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:5993,tune,tuned,5993,docs/3.1.0/modules/qutip/control/grape.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html,1,['tune'],['tuned']
Performance,"- describes the dynamics of the (quantum) system. to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. algstringAlgorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msgboolSet true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_paramsDictionaryOptions for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_gradboolIf set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:74148,optimiz,optimize,74148,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['optimiz'],['optimize']
Performance,"----------; log_level : integer; level of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. alg : string; Algorithm to use in pulse optimisation. Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; Options that are specific to the pulse optim algorithm ``alg``. disp_conv_msg : bool; Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_params : Dictionary; Options for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_grad : bool; If set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:7502,optimiz,optimize,7502,docs/4.6/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html,2,['optimiz'],['optimize']
Performance,"-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, …) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hol",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-control.html:13524,optimiz,optimize,13524,docs/4.3/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html,2,"['optimiz', 'perform']","['optimize', 'perform']"
Performance,"-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, …) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-control.html:13522,optimiz,optimize,13522,docs/4.4/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-control.html,6,"['optimiz', 'perform']","['optimize', 'perform']"
Performance,". . Overview: module code — QuTiP 4.0 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Overview: module code. All modules for which code is available; qutip.about; qutip.bloch; qutip.bloch3d; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dump; qutip.control.dynamics; qutip.control.fidcomp; qutip.control.optimizer; qutip.control.optimresult; qutip.control.propcomp; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.control.stats; qutip.control.termcond; qutip.control.tslotcomp; qutip.correlation; qutip.distributions; qutip.entropy; qutip.eseries; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.graph; qutip.ipynbtools; qutip.mcsolve; qutip.mesolve; qutip.metrics; qutip.nonmarkov.heom; qutip.nonmarkov.memorycascade; qutip.nonmarkov.transfertensor; qutip.operators; qutip.orbital; qutip.parallel; qutip.partial_transpose; qutip.propagator; qutip.qip.algorithms.qft; qutip.qip.circuit; qutip.qip.gates; qutip.qip.models.circuitprocessor; qutip.qip.models.cqed; qutip.qip.models.spinchain; qutip.qip.qubits; qutip.qobj; qutip.random_objects; qutip.rhs_generate; qutip.sesolve; qutip.simdiag; qutip.solver; qutip.states; qutip.steadystate; qutip.stochastic; qutip.superop_reps; qutip.superoperator; qutip.tensor; qutip.three_level_atom; qutip.tomography; qutip.utilities; qutip.visualization; qutip.wigner. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/index.html:475,optimiz,optimizer,475,docs/4.0.2/modules/index.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/index.html,1,['optimiz'],['optimizer']
Performance,". . Overview: module code — QuTiP 4.1 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.1; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Overview: module code. All modules for which code is available; qutip.about; qutip.bloch; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dump; qutip.control.dynamics; qutip.control.fidcomp; qutip.control.optimizer; qutip.control.optimresult; qutip.control.propcomp; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.control.stats; qutip.control.termcond; qutip.control.tslotcomp; qutip.correlation; qutip.distributions; qutip.entropy; qutip.eseries; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.graph; qutip.interpolate; qutip.ipynbtools; qutip.mcsolve; qutip.mesolve; qutip.metrics; qutip.nonmarkov.heom; qutip.nonmarkov.memorycascade; qutip.nonmarkov.transfertensor; qutip.operators; qutip.orbital; qutip.parallel; qutip.partial_transpose; qutip.propagator; qutip.qip.algorithms.qft; qutip.qip.circuit; qutip.qip.gates; qutip.qip.models.circuitprocessor; qutip.qip.models.cqed; qutip.qip.models.spinchain; qutip.qip.qubits; qutip.qobj; qutip.random_objects; qutip.rhs_generate; qutip.sesolve; qutip.simdiag; qutip.solver; qutip.states; qutip.steadystate; qutip.stochastic; qutip.superop_reps; qutip.superoperator; qutip.tensor; qutip.three_level_atom; qutip.tomography; qutip.utilities; qutip.visualization; qutip.wigner. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/index.html:460,optimiz,optimizer,460,docs/4.1/modules/index.html,https://qutip.org,https://qutip.org/docs/4.1/modules/index.html,1,['optimiz'],['optimizer']
Performance,". . Overview: module code — QuTiP 4.2 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.2; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Overview: module code. All modules for which code is available; qutip.about; qutip.bloch; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dump; qutip.control.dynamics; qutip.control.fidcomp; qutip.control.optimizer; qutip.control.optimresult; qutip.control.propcomp; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.control.stats; qutip.control.termcond; qutip.control.tslotcomp; qutip.correlation; qutip.distributions; qutip.entropy; qutip.eseries; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.graph; qutip.interpolate; qutip.ipynbtools; qutip.mcsolve; qutip.mesolve; qutip.metrics; qutip.nonmarkov.heom; qutip.nonmarkov.memorycascade; qutip.nonmarkov.transfertensor; qutip.operators; qutip.orbital; qutip.parallel; qutip.partial_transpose; qutip.propagator; qutip.qip.algorithms.qft; qutip.qip.circuit; qutip.qip.gates; qutip.qip.models.circuitprocessor; qutip.qip.models.cqed; qutip.qip.models.spinchain; qutip.qip.qubits; qutip.qobj; qutip.random_objects; qutip.rhs_generate; qutip.sesolve; qutip.simdiag; qutip.solver; qutip.states; qutip.steadystate; qutip.stochastic; qutip.superop_reps; qutip.superoperator; qutip.tensor; qutip.three_level_atom; qutip.tomography; qutip.utilities; qutip.visualization; qutip.wigner. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/index.html:460,optimiz,optimizer,460,docs/4.2/modules/index.html,https://qutip.org,https://qutip.org/docs/4.2/modules/index.html,1,['optimiz'],['optimizer']
Performance,". . Overview: module code — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Overview: module code. All modules for which code is available; qutip.about; qutip.bloch; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dump; qutip.control.dynamics; qutip.control.fidcomp; qutip.control.optimizer; qutip.control.optimresult; qutip.control.propcomp; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.control.stats; qutip.control.termcond; qutip.control.tslotcomp; qutip.correlation; qutip.cy.br_tensor; qutip.distributions; qutip.entropy; qutip.eseries; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.graph; qutip.interpolate; qutip.ipynbtools; qutip.mcsolve; qutip.mesolve; qutip.metrics; qutip.nonmarkov.heom; qutip.nonmarkov.memorycascade; qutip.nonmarkov.transfertensor; qutip.operators; qutip.orbital; qutip.parallel; qutip.partial_transpose; qutip.piqs; qutip.propagator; qutip.qip.algorithms.qft; qutip.qip.circuit; qutip.qip.gates; qutip.qip.models.circuitprocessor; qutip.qip.models.cqed; qutip.qip.models.spinchain; qutip.qip.qubits; qutip.qobj; qutip.random_objects; qutip.rhs_generate; qutip.scattering; qutip.sesolve; qutip.simdiag; qutip.solver; qutip.states; qutip.steadystate; qutip.stochastic; qutip.superop_reps; qutip.superoperator; qutip.tensor; qutip.three_level_atom; qutip.tomography; qutip.utilities; qutip.visualization; qutip.wigner. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/index.html:460,optimiz,optimizer,460,docs/4.3/modules/index.html,https://qutip.org,https://qutip.org/docs/4.3/modules/index.html,1,['optimiz'],['optimizer']
Performance,". . Overview: module code — QuTiP 4.4 Documentation. QuTiP: Quantum Toolbox in Python. . 4.4; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Overview: module code. All modules for which code is available; qutip.about; qutip.bloch; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dump; qutip.control.dynamics; qutip.control.fidcomp; qutip.control.optimizer; qutip.control.optimresult; qutip.control.propcomp; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.control.stats; qutip.control.termcond; qutip.control.tslotcomp; qutip.correlation; qutip.cy.br_tensor; qutip.distributions; qutip.entropy; qutip.eseries; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.graph; qutip.interpolate; qutip.ipynbtools; qutip.mcsolve; qutip.mesolve; qutip.metrics; qutip.nonmarkov.heom; qutip.nonmarkov.memorycascade; qutip.nonmarkov.transfertensor; qutip.operators; qutip.orbital; qutip.parallel; qutip.partial_transpose; qutip.piqs; qutip.propagator; qutip.qip.algorithms.qft; qutip.qip.circuit; qutip.qip.gates; qutip.qip.models.circuitprocessor; qutip.qip.models.cqed; qutip.qip.models.spinchain; qutip.qip.qubits; qutip.qobj; qutip.qobjevo; qutip.random_objects; qutip.rhs_generate; qutip.scattering; qutip.sesolve; qutip.simdiag; qutip.solver; qutip.states; qutip.steadystate; qutip.stochastic; qutip.superop_reps; qutip.superoperator; qutip.tensor; qutip.three_level_atom; qutip.tomography; qutip.utilities; qutip.visualization; qutip.wigner. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/index.html:456,optimiz,optimizer,456,docs/4.4/modules/index.html,https://qutip.org,https://qutip.org/docs/4.4/modules/index.html,1,['optimiz'],['optimizer']
Performance,". . Overview: module code — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Overview: module code. All modules for which code is available; qutip.about; qutip.bloch; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dump; qutip.control.dynamics; qutip.control.fidcomp; qutip.control.optimizer; qutip.control.optimresult; qutip.control.propcomp; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.control.stats; qutip.control.termcond; qutip.control.tslotcomp; qutip.correlation; qutip.cy.br_tensor; qutip.dimensions; qutip.distributions; qutip.entropy; qutip.eseries; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.graph; qutip.interpolate; qutip.ipynbtools; qutip.lattice; qutip.mcsolve; qutip.mesolve; qutip.metrics; qutip.nonmarkov.heom; qutip.nonmarkov.memorycascade; qutip.nonmarkov.transfertensor; qutip.operators; qutip.orbital; qutip.parallel; qutip.partial_transpose; qutip.piqs; qutip.propagator; qutip.qip.algorithms.qft; qutip.qip.circuit; qutip.qip.device.modelprocessor; qutip.qip.device.optpulseprocessor; qutip.qip.device.processor; qutip.qip.device.spinchain; qutip.qip.noise; qutip.qip.operations.gates; qutip.qip.pulse; qutip.qip.qubits; qutip.qobj; qutip.qobjevo; qutip.random_objects; qutip.rhs_generate; qutip.scattering; qutip.sesolve; qutip.simdiag; qutip.solver; qutip.states; qutip.steadystate; qutip.stochastic; qutip.superop_reps; qutip.superoperator; qutip.tensor; qutip.three_level_atom; qutip.tomography; qutip.topology; qutip.utilities; qutip.visualization; qutip.wigner. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/index.html:469,optimiz,optimizer,469,docs/4.5/modules/index.html,https://qutip.org,https://qutip.org/docs/4.5/modules/index.html,1,['optimiz'],['optimizer']
Performance,". . Saving QuTiP Objects and Data Sets — QuTiP 4.0 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-saving.html:601,load,loading,601,docs/4.0.2/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-saving.html,2,['load'],['loading']
Performance,". . Saving QuTiP Objects and Data Sets — QuTiP 4.1 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.1; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/guide-saving.html:601,load,loading,601,docs/4.1/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.1/guide/guide-saving.html,2,['load'],['loading']
Performance,". . Saving QuTiP Objects and Data Sets — QuTiP 4.2 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.2; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-saving.html:601,load,loading,601,docs/4.2/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-saving.html,2,['load'],['loading']
Performance,". . Saving QuTiP Objects and Data Sets — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-saving.html:601,load,loading,601,docs/4.3/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-saving.html,2,['load'],['loading']
Performance,". . Saving QuTiP Objects and Data Sets — QuTiP 4.4 Documentation. QuTiP: Quantum Toolbox in Python. . 4.4; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a man",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-saving.html:597,load,loading,597,docs/4.4/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-saving.html,2,['load'],['loading']
Performance,". . Saving QuTiP Objects and Data Sets — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-saving.html:601,load,loading,601,docs/4.5/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-saving.html,2,['load'],['loading']
Performance,". . qutip.control.optimizer — QuTiP 4.0 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Module code »; qutip.control.optimizer. Source code for qutip.control.optimizer; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2014 and later, Alexander J G Pitchford; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:18,optimiz,optimizer,18,docs/4.0.2/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html,3,['optimiz'],['optimizer']
Performance,". . qutip.control.optimizer — QuTiP 4.1 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.1; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Module code »; qutip.control.optimizer. Source code for qutip.control.optimizer; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2014 and later, Alexander J G Pitchford; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:18,optimiz,optimizer,18,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,3,['optimiz'],['optimizer']
Performance,". . qutip.control.optimizer — QuTiP 4.2 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.2; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Module code »; qutip.control.optimizer. Source code for qutip.control.optimizer; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2014 and later, Alexander J G Pitchford; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:18,optimiz,optimizer,18,docs/4.2/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html,3,['optimiz'],['optimizer']
Performance,". . qutip.control.optimizer — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Module code »; qutip.control.optimizer. Source code for qutip.control.optimizer; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2014 and later, Alexander J G Pitchford; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:18,optimiz,optimizer,18,docs/4.3/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html,3,['optimiz'],['optimizer']
Performance,". . qutip.control.optimizer — QuTiP 4.4 Documentation. QuTiP: Quantum Toolbox in Python. . 4.4; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Module code »; qutip.control.optimizer. Source code for qutip.control.optimizer; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2014 and later, Alexander J G Pitchford; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMA",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/optimizer.html:18,optimiz,optimizer,18,docs/4.4/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/optimizer.html,3,['optimiz'],['optimizer']
Performance,". . qutip.control.optimizer — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Module code »; qutip.control.optimizer. Source code for qutip.control.optimizer; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2014 and later, Alexander J G Pitchford; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:18,optimiz,optimizer,18,docs/4.5/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html,3,['optimiz'],['optimizer']
Performance,". .. note::. It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """"""; if isinstance(c_ops, (Qobj, QobjEvo)):; c_ops = [c_ops]. if options is None:; options = Options(). if options.rhs_reuse and not isinstance(H, SolverSystem):; # TODO: deprecate when going to class based solver.; if ""mcsolve"" in solver_safe:; # print("" ""); H = solver_safe[""mcsolve""]; else:; pass; # raise Exception(""Could not find the Hamiltonian to reuse.""). if not ntraj:; ntraj = options.ntraj. if len(c_ops) == 0 and not options.rhs_reuse:; warn(""No c_ops, using sesolve""); return sesolve(H, psi0, tlist, e_ops=e_ops, args=args,; options=options, progress_bar=progress_bar,; _safe_mode=_safe_mode). try:; num_traj = int(ntraj); except TypeError:; num_traj = max(ntraj). # set the physics; if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). # load monte carlo class; mc = _MC(options). if isinstance(H, SolverSystem):; mc.ss = H; else:; mc.make_system(H, c_ops, tlist, args, options). mc.reset(tlist[0], psi0). mc.set_e_ops(e_ops). if options.seeds is not None:; mc.seed(num_traj, options.seeds). if _safe_mode:; mc.run_test(). # Run the simulation; mc.run(num_traj=num_traj, tlist=tlist,; progress_bar=progress_bar,; map_func=map_func, map_kwargs=map_kwargs). return mc.get_result(ntraj). # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """"""; def __init__(self, options=None):; if options is None:; options = Options(); self.options = options; self.ss = None; self.tlist = None; self.e_ops = None; self.ran = False; self.psi0 = None; self.seeds = []; self.t = 0.; self.num_traj = 0; self.args_col = None. self._psi_out = []; self._expect_out = [];",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/mcsolve.html:6829,load,load,6829,docs/4.6/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mcsolve.html,2,['load'],['load']
Performance,. Overview: module code — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Overview: module code. All modules for which code is available; qutip.about; qutip.bloch; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dump; qutip.control.dynamics; qutip.control.fidcomp; qutip.control.optimizer; qutip.control.optimresult; qutip.control.propcomp; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.control.stats; qutip.control.termcond; qutip.control.tslotcomp; qutip.correlation; qutip.cy.br_tensor; qutip.dimensions; qutip.distributions; qutip.entropy; qutip.eseries; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.graph; qutip.interpolate; qutip.ipynbtools; qutip.lattice; qutip.matplotlib_utilities; qutip.mcsolve; qutip.measurement; qutip.mesolve; qutip.metrics; qutip.nonmarkov.heom; qutip.nonmarkov.memorycascade; qutip.nonmarkov.transfertensor; qutip.operators; qutip.orbital; qutip.parallel; qutip.partial_transpose; qutip.piqs; qutip.propagator; qutip.qip.algorithms.qft; qutip.qip.circuit; qutip.qip.compiler.cavityqedcompiler; qutip.qip.compiler.gatecompiler; qutip.qip.compiler.instruction; qutip.qip.compiler.scheduler; qutip.qip.compiler.spinchaincompiler; qutip.qip.device.cavityqed; qutip.qip.device.modelprocessor; qutip.qip.device.optpulseprocessor; qutip.qip.device.processor; qutip.qip.device.spinchain; qutip.qip.noise; qutip.qip.operations.gates; qutip.qip.pulse; qutip.qip.qasm; qutip.qip.qubits; qutip.qobj; qutip.qobjevo; qutip.random_objects; qutip.rhs_generate; qutip.scattering; qutip.sesolve; qutip.simdiag; qutip.solver; qutip.states; qutip.steadystate; qutip.stochastic; qutip.superop_reps; qutip.superoperator; qutip.tensor; qutip.three_level_atom; qutip.tomography; qutip.topology; qutip.utilities; qutip.visualization; qutip.wigner. © Copyr,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/index.html:489,optimiz,optimizer,489,docs/4.6/modules/index.html,https://qutip.org,https://qutip.org/docs/4.6/modules/index.html,1,['optimiz'],['optimizer']
Performance,. Overview: module code — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Overview: module code. All modules for which code is available; qutip.about; qutip.bloch; qutip.bloch3d; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dump; qutip.control.dynamics; qutip.control.fidcomp; qutip.control.optimizer; qutip.control.optimresult; qutip.control.propcomp; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.control.stats; qutip.control.termcond; qutip.control.tslotcomp; qutip.correlation; qutip.cy.br_tensor; qutip.dimensions; qutip.distributions; qutip.entropy; qutip.eseries; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.graph; qutip.interpolate; qutip.ipynbtools; qutip.krylovsolve; qutip.lattice; qutip.matplotlib_utilities; qutip.mcsolve; qutip.measurement; qutip.mesolve; qutip.metrics; qutip.nonmarkov.bofin_baths; qutip.nonmarkov.bofin_solvers; qutip.nonmarkov.dlheom_solver; qutip.nonmarkov.memorycascade; qutip.nonmarkov.transfertensor; qutip.operators; qutip.orbital; qutip.parallel; qutip.partial_transpose; qutip.piqs; qutip.propagator; qutip.qip.algorithms.qft; qutip.qip.circuit; qutip.qip.compiler.cavityqedcompiler; qutip.qip.compiler.gatecompiler; qutip.qip.compiler.instruction; qutip.qip.compiler.scheduler; qutip.qip.compiler.spinchaincompiler; qutip.qip.device.cavityqed; qutip.qip.device.modelprocessor; qutip.qip.device.optpulseprocessor; qutip.qip.device.processor; qutip.qip.device.spinchain; qutip.qip.noise; qutip.qip.operations.gates; qutip.qip.pulse; qutip.qip.qasm; qutip.qip.qubits; qutip.qobj; qutip.qobjevo; qutip.random_objects; qutip.rhs_generate; qutip.scattering; qutip.sesolve; qutip.simdiag; qutip.solver; qutip.states; qutip.steadystate; qutip.stochastic; qutip.superop_reps; qutip.superoperator; qut,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/index.html:529,optimiz,optimizer,529,docs/4.7/modules/index.html,https://qutip.org,https://qutip.org/docs/4.7/modules/index.html,1,['optimiz'],['optimizer']
Performance,". Saving QuTiP Objects and Data Sets — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parame",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-saving.html:599,load,loading,599,docs/4.7/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html,2,['load'],['loading']
Performance,". This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_genboolIf True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_gradboolIf the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: boolIf True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: boolIf True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_optimization<=1, otherwise False. num_tslotsintegerNumber of timeslots (aka timeslices). num_ctrlsintegercalculate the of controls from the length of the control list. evo_timefloatTotal time for the evolution. tauarray[num_tslots] of floatDuration of each timeslot; Note that if this is set before initialize_controls is called; then num_tslots and evo_time are calculated from tau, otherwise; tau is generated from num_tslots and evo_time, that is; equal size time slices. timearray[num_tslots+1] of floatCumulative time for the evolution, that is the time at the start; of each time slice. drift_dyn_genQobj or list of QobjDrift or system dynamics generator (Hamiltonian); Matrix defining the underlying dynamics of the system; Can also be a list of Qobj (length num_tslo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:92705,cache,cached,92705,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['cache'],['cached']
Performance,". Wood, J. Biamonte, D. G. Cory, Tensor networks and graphical calculus for; open quantum systems. arXiv:1111.6950. dAless08. d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). Byrd95. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. Flo12. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. Lloyd14. Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. Doria11. Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. Caneva11. Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. Rach15. Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. DYNAMO. Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Wis09; Wiseman, H. M. & Milburn, G. J. Quantum Measurement and Control, (Cambridge University Press, 2009). Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/biblio.html:2473,optimiz,optimization,2473,docs/4.6/biblio.html,https://qutip.org,https://qutip.org/docs/4.6/biblio.html,2,['optimiz'],['optimization']
Performance,". class Result[source]¶; Class for storing simulation results from any of the dynamics solvers. Attributes:; solver : str; Which solver was used [e.g., ‘mesolve’, ‘mcsolve’, ‘brmesolve’, …]. times : list/array; Times at which simulation data was collected. expect : list/array; Expectation values (if requested) for simulation. states : array; State of the simulation (density matrix or ket) evaluated at times. num_expect : int; Number of expectation value operators in simulation. num_collapse : int; Number of collapse operators in simualation. ntraj : int/list; Number of trajectories (for stochastic solvers). A list indicates; that averaging of expectation values was done over a subset of total; number of trajectories. col_times : list; Times at which state collpase occurred. Only for Monte Carlo solver. col_which : list; Which collapse operator was responsible for each collapse in; col_times. Only for Monte Carlo solver. class Stats(section_names=None)[source]¶; Statistical information on the solver performance; Statistics can be grouped into sections.; If no section names are given in the the contructor, then all statistics; will be added to one section ‘main’. Parameters:; section_names : list; list of keys that will be used as keys for the sections; These keys will also be used as names for the sections; The text in the output can be overidden by setting the header property; of the section; If no names are given then one section called ‘main’ is created. Attributes:; sections : OrderedDict of _StatsSection; These are the sections that are created automatically on instantiation; or added using add_section. header : string; Some text that will be used as the heading in the report; By default there is None. total_time : float; Time in seconds for the solver to complete processing; Can be None, meaning that total timing percentages will be reported. Methods. add_section(name); Add another section with the given name. add_count(key, value[, section]); Add value to coun",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:36843,perform,performance,36843,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['perform'],['performance']
Performance,". n_avgfloat or arrayReturn the number of average photons in thermal equilibrium for a; an oscillator with the given frequency and temperature. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters. filenamestrName of file containing reqested data. sepstrSeperator used to store data. Returns. dataarray_likeData from selected file. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=',')[source]¶; Stores a matrix of data to a file to be read by an external program. Parameters. filenamestrName of data file to be stored, including extension. data: array_likeData to be written to file. numtypestr {‘complex, ‘real’}Type of numerical data. numformatstr {‘decimal’,’exp’}Format for written data. sepstrSingle-character field seperator. Usually a tab, space, comma,; or semicolon. qload(name)[source]¶; Loads data file from file named ‘filename.qu’ in current directory. Parameters. namestrName of data file to be loaded. Returns. qobjectinstance / array_likeObject retrieved from requested file. qsave(data, name='qutip_data')[source]¶; Saves given data to file named ‘filename.qu’ in current directory. Parameters. datainstance/array_likeInput Python object to be stored. filenamestrName of output data file. Parallelization¶; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing. parallel_map(task, values, task_args=(), task_kwargs={}, **kwargs)[source]¶; Parallel execution of a mapping of values to the function task. This; is functionally equivalent to:; result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters. taska Python functionThe function that is to be called for each value in task_vec. valuesarray / listThe list or array of values for which the task function is to be; evaluated. task_argslist / dictionaryThe optional additional argument to the task function. task_kwargslis",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:248622,load,loaded,248622,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['load'],['loaded']
Performance,". qutip.control.dump — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.dump. Source code for qutip.control.dump; # -*- coding: utf-8 -*-. """"""; Classes that enable the storing of historical objects created during the; pulse optimisation.; These are intented for debugging.; See the optimizer and dynamics objects for instrutcions on how to enable; data dumping.; """""". import os; import numpy as np; import copy; # QuTiP logging; import qutip.logging_utils; logger = qutip.logging_utils.get_logger('qutip.control.dump'); # QuTiP control modules; import qutip.control.io as qtrlio; from numpy.compat import asbytes. DUMP_DIR = ""~/.qtrl_dump"". def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Dump(object):; """"""; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes; ----------; parent : some control object (Dynamics or Optimizer); aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dir : str; directory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. level : string; level of data dumping: SUMMARY, FULL or CUSTOM; See property docstring for details; Set automatically if dump is created by the setting host dumping attrib. write_to_file : bool; When set True data and summaries (as configured) will be written; interactively to file during the processing; Set during instantiation by the host based ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/dump.html:529,optimiz,optimizer,529,docs/4.7/modules/qutip/control/dump.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/dump.html,1,['optimiz'],['optimizer']
Performance,". qutip.control.optimizer — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.optimizer. Source code for qutip.control.optimizer; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2014 and later, Alexander J G Pitchford; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISE",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:16,optimiz,optimizer,16,docs/4.6/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html,3,['optimiz'],['optimizer']
Performance,". qutip.control.optimizer — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.optimizer. Source code for qutip.control.optimizer; # -*- coding: utf-8 -*-; # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes here are expected to implement a run_optimization function; that will use some method for optimising the control pulse, as defined; by the control amplitudes. The system that the pulse acts upon are defined; by the Dynamics object that must be passed in the instantiation. The methods are typically N dimensional function optimisers that; find the minima of a fidelity error function. Note the number of variables; for the fidelity function is the number of control timeslots,; i.e. n_ctrls x Ntimeslots; The methods will call functions on the Dynamics.fid_computer object,; one or many times per interation,; to get the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:. BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm. This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS. This a version of the BFGS method where the H",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/optimizer.html:16,optimiz,optimizer,16,docs/4.7/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/optimizer.html,3,['optimiz'],['optimizer']
Performance,". qutip.entropy — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.entropy. Source code for qutip.entropy; __all__ = ['entropy_vn', 'entropy_linear', 'entropy_mutual', 'negativity',; 'concurrence', 'entropy_conditional', 'entangling_power',; 'entropy_relative']. from numpy import conj, e, inf, imag, inner, real, sort, sqrt; from numpy.lib.scimath import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/entropy.html:423,concurren,concurrence,423,docs/4.7/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html,1,['concurren'],['concurrence']
Performance,". qutip.krylovsolve — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.krylovsolve. Source code for qutip.krylovsolve; __all__ = [""krylovsolve""]; """"""; This module provides approximations of the time evolution operator; using small dimensional Krylov subspaces.; """""". from scipy.optimize import root_scalar; from math import ceil; import numpy as np; import warnings. from qutip.expect import expect; from qutip.qobj import Qobj; from qutip.solver import Result, Options; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.sparse import eigh. [docs]def krylovsolve(; H: Qobj,; psi0: Qobj,; tlist: np.array,; krylov_dim: int,; e_ops=None,; options=None,; progress_bar: bool = None,; sparse: bool = False,; ):; """"""; Time evolution of state vectors for time independent Hamiltonians.; Evolve the state vector (""psi0"") finding an approximation for the time; evolution operator of Hamiltonian (""H"") by obtaining the projection of; the time evolution operator on a set of small dimensional Krylov; subspaces (m << dim(H)). The output is either the state vector or the expectation values of; supplied operators (""e_ops"") at arbitrary points at (""tlist""). **Additional options**. Additional options to krylovsolve can be set with the following:. * ""store_states"": stores states even though expectation values are; requested via the ""e_ops"" argument. * ""store_final_state"": store final state even though expectation values are; requested via the ""e_ops"" argument. Parameters; ----------; H : :class:`qutip.Qobj`; System Hamiltonian.; psi0 : :class: `qutip.Qobj`; Initial state vector (ket).; tlist : None / *list* / *array*; List of times on which to evolve the initial state. If None, nothing; happens but the code won't break.; krylov_dim: int",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:517,optimiz,optimize,517,docs/4.7/modules/qutip/krylovsolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html,1,['optimiz'],['optimize']
Performance,". qutip.qip.compiler.scheduler — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.compiler.scheduler. Source code for qutip.qip.compiler.scheduler; from collections import deque; from copy import deepcopy; from functools import cmp_to_key; from random import shuffle. from ..circuit import QubitCircuit, Gate; from .instruction import Instruction. class InstructionsGraph():; """"""; A directed acyclic graph (DAG) representation; of the quantum instruction dependency.; An example is Fig3(b) in https://doi.org/10.1117/12.666419.; It contains methods of generating the instruction dependency graph,; a list-schedule algorithm to find the topological order; and the computation of the distance in the weighted graph; (circuit latency). It uses the `Instruction` object as a representation of node; and adds the following attributes to it:. predecessors, successors: dependency arrow of the DAG; distance_to_start, distance_to_end: longest distance to the start and end. Parameters; ----------; instructions: list; A list of instructions. Attributes; ----------; nodes: list; The input list of instruction with additional graph information.; start, end: list; List of indices of nodes connected to the start or end nodes.; """"""; def __init__(self, instructions):; instructions = deepcopy(instructions); self.nodes = []; for instruction in instructions:; if isinstance(instruction, Gate):; self.nodes.append(Instruction(instruction)); else:; self.nodes.append(instruction); for node in self.nodes:; if node.duration is None:; node.duration = 1; self.start = None; self.end = None. def generate_dependency_graph(self, commuting):; """"""; Generate the instruction dependency graph.; It modifies the class attribute `nodes`, where each element (node); is an `Instructio",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/compiler/scheduler.html:966,latency,latency,966,docs/4.7/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/compiler/scheduler.html,1,['latency'],['latency']
Performance,". system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : qutip.Qobj. system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notrace : bool {False}. If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns:: qutip.Qobj. time-propagator for computing field correlation function. propagator(t, tau, notrace=False)[source]¶; Compute propagator for time t and time-delay tau. Parameters:t : float. current time. tau : float. time-delay. notrace : bool {False}. If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; ——-; : :class:`qutip.Qobj`. time-propagator for reduced system dynamics. rhot(rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters:rho0 : qutip.Qobj. initial density matrix or state vector (ket). t : float. current time. tau : float. time-delay. Returns:: qutip.Qobj. density matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options for the Transfer Tensor Method solver.; Attributes. dynmaps; (list of qutip.Qobj) List of precomputed dynamical maps (superoperators), or a callback function that returns the superoperator at a given time. times; (array_like) List of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimes; (array_like) List of times \(t_k\) to use as learning times if argument dynmaps is a callback function. thres; (float) Threshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is be",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:31080,perform,performed,31080,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['perform'],['performed']
Performance,". use_rcmbool, optional, default = FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbmbool, optional, default = FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refineint {10}MKL ONLY. Max. number of iterative refinements to perform. scaling_vectorsbool {True, False}MKL ONLY. Scale matrix to unit norm columns and rows. weighted_matchingbool {True, False}MKL ONLY. Use weighted matching to better condition diagonal. x0ndarray, optionalITERATIVE ONLY. Initial guess for solution vector. maxiterint, optional, default=1000ITERATIVE ONLY. Maximum number of iterations to perform. tolfloat, optional, default=1e-12ITERATIVE ONLY. Tolerance used for terminating solver. mtolfloat, optional, default=NoneITERATIVE ‘power’ methods ONLY. Tolerance for lu solve method.; If None given then max(0.1*tol, 1e-15) is used. matolfloat, optional, default=1e-15ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_specstr, optional, default=’COLAMD’ITERATIVE ONLY. Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ and; ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. use_precondbool optional, default = FalseITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases. M{sparse matrix, dense matrix, LinearOperator}, optionalITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Eff",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:104383,perform,perform,104383,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['perform'],['perform']
Performance,".09555. 332. Ishibashi et al., ""Oscillation collapse in coupled quantum van der Pol oscillators"", ; Phys. Rev. E 96, 052210 (2017). 331. Elbin et al., ""Rényi Entropies from Random Quenches in Atomic Hubbard and Spin Models"", ; arXiv:1709.05060. 330. Li et al., ""Quantum microwave-optical interface with nitrogen-vacancy centers in diamond"", ; Phys. Rev. A 96, 032342 (2017). 329. Diguna et al., ""The coupling of single-photon exciton–biexciton quantum dot and cavity"", ; J. Nonlinear Optic. Phys. Mat. 1750029, (2017). 328. Lee et al., ""Effective formalism for open-quantum-system dynamics: Time-coarse-graining approach"", ; Phys. Rev. A 97, 012102 (2018). 327. de Moraes Neto et al., ""Steady many-body entanglements in dissipative systems"", ; Phys. Rev. A 96, 062313 (2017). 326. Zhang et al., ""Efficient numerical solution of excitation number conserving quantum systems"", ; AIP Advances 7, 085225 (2017). 325. Heuck et al., ""Temporally and frequency multiplexed single photon source using quantum feedback control for scalable photonic quantum technologies"", ; arXiv:1708.08875. 324. Kurian et al., ""Oxidative species-induced excitonic transport in tubulin aromatic networks: Potential implications for neurodegenerative disease"", ; J. Photochem. Photobiol. B: Biology (2017). 323. Hwang et al., ""Dissipative phase transition in the open quantum Rabi model"", ; Phys. Rev. A 97, 013825 (2018). 322. Higgins et al., ""Coherent Control of a Single Trapped Rydberg Ion"", ; Phys. Rev. Lett. 119, 220501 (2017). 321. Schlipf et al., ""A molecular quantum spin network controlled by a single qubit"", ; Sci. Adv. 3, 1701116 (2017). 320. Hardal et al., ""Quantum heat engine with coupled superconducting resonators"", ; Phys. Rev. E 96, 062120 (2017). 319. Katabarwa et al., ""Quantum Projective Simulation with Hamiltonian Evolution: A study in reinforcement learning"", ; arXiv:1708.00123. 318. Kienzler et al., ""Quantum Harmonic Oscillator State Control in a Squeezed Fock Basis"", ; Phys. Rev. Lett. 119, 0336",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:6235,scalab,scalable,6235,users.html,https://qutip.org,https://qutip.org/users.html,1,['scalab'],['scalable']
Performance,".5 * g * (x + iy), default g = sqrt(2).; method (string {'clenshaw', 'iterative', 'laguerre', 'fft'}) – Select method ‘clenshaw’ ‘iterative’, ‘laguerre’, or ‘fft’, where ‘clenshaw’; and ‘iterative’ use an iterative method to evaluate the Wigner functions for density; matrices \(|m><n|\), while ‘laguerre’ uses the Laguerre polynomials; in scipy for the same task. The ‘fft’ method evaluates the Fourier; transform of the density matrix. The ‘iterative’ method is default, and; in general recommended, but the ‘laguerre’ method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The ‘clenshaw’ method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). ‘clenshaw’ is a fast and numerically stable method.; sparse (bool {False, True}) – Tells the default solver whether or not to keep the input density; matrix in sparse format. As the dimensions of the density matrix; grow, setthing this flag can result in increased performance.; parfor (bool {False, True}) – Flag for calculating the Laguerre polynomial based Wigner function; method=’laguerre’ in parallel using the parfor function. Returns:; W (array) – Values representing the Wigner function calculated over the specified; range [xvec,yvec].; yvex (array) – FFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; The ‘fft’ method accepts only an xvec input for the x-coordinate.; The y-coordinates are calculated internally. References; Ulf Leonhardt,; Measuring the Quantum State of Light, (Cambridge University Press, 1997). Graphs and Visualization¶; Functions for visualizing results of quantum dynamics simulations,; visualizations of quantum states and processes. hinton(rho, xlabels=None, ylabels=None, title=None, ax=None, cmap=None, label_top=True)[source]¶; Draws a Hinton diagram for visualizing a density matrix or superoperator. Parameters:; rho (qobj) – Input density matrix ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:113687,perform,performance,113687,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['perform'],['performance']
Performance,".; Public plotting functions from the qutip.visualization module are now; prefixed with plot_ (e.g., plot_fock_distribution). The; plot_wigner and plot_wigner_fock_distribution now supports 3D views; in addition to contour views.; New API and new functions for working with spin operators and states,; including for example spin_Jx, spin_Jy, spin_Jz and; spin_state, spin_coherent.; The expect function now supports a list of operators, in addition to the; previously supported list of states.; Simplified creation of qubit states using ket function.; The module qutip.cyQ has been renamed to qutip.cy and the sparse; matrix-vector functions spmv and spmv1d has been combined into one; function spmv. New functions for operating directly on the underlaying; sparse CSR data have been added (e.g., spmv_csr). Performance; improvements. New and improved Cython functions for calculating expectation; values for state vectors, density matrices in matrix and vector form.; The concurrence function now supports both pure and mixed states. Added; function for calculating the entangling power of a two-qubit gate.; Added function for generating (generalized) Lindblad dissipator; superoperators.; New functions for generating Bell states, and singlet and triplet states.; QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The qutip.gui module has been renamed to qutip.ui and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes.; Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master eqautions with mean field terms. Imp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/changelog.html:4326,concurren,concurrence,4326,docs/3.0.0/changelog.html,https://qutip.org,https://qutip.org/docs/3.0.0/changelog.html,2,['concurren'],['concurrence']
Performance,".; Public plotting functions from the qutip.visualization module are now; prefixed with plot_ (e.g., plot_fock_distribution). The; plot_wigner and plot_wigner_fock_distribution now supports 3D views; in addition to contour views.; New API and new functions for working with spin operators and states,; including for example spin_Jx, spin_Jy, spin_Jz and; spin_state, spin_coherent.; The expect function now supports a list of operators, in addition to the; previously supported list of states.; Simplified creation of qubit states using ket function.; The module qutip.cyQ has been renamed to qutip.cy and the sparse; matrix-vector functions spmv and spmv1d has been combined into one; function spmv. New functions for operating directly on the underlaying; sparse CSR data have been added (e.g., spmv_csr). Performance; improvements. New and improved Cython functions for calculating expectation; values for state vectors, density matrices in matrix and vector form.; The concurrence function now supports both pure and mixed states. Added; function for calculating the entangling power of a two-qubit gate.; Added function for generating (generalized) Lindblad dissipator; superoperators.; New functions for generating Bell states, and singlet and triplet states.; QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The qutip.gui module has been renamed to qutip.ui and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes.; Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Imp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/changelog.html:6889,concurren,concurrence,6889,docs/3.1.0/changelog.html,https://qutip.org,https://qutip.org/docs/3.1.0/changelog.html,9,['concurren'],['concurrence']
Performance,".exp_freq = None. self.options = None; self.progress_bar = None; self.stats = None. self.ode = None; self.configured = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters; ----------; options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats; """""". self.H_sys = H_sys; self.coup_op = coup_op; self.coup_strength = coup_strength; self.temperature = temperature; self.N_cut = N_cut; self.N_exp = N_exp; if planck: self.planck = planck; if boltzmann: self.boltzmann = boltzmann; if isinstance(options, Options): self.options = options; if isinstance(progress_bar, BaseProgressBar):; self.progress_bar = progress_bar; elif progress_bar == True:; self.progress_bar = TextProgressBar(); elif progress_bar == False:; self.progress_bar = None; if isinstance(stats, Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. - config; - integrate; """"""; stats = Stats(['config', 'run']); stats.header = ""Hierarchy Solver Stats""; retur",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:6474,perform,performance,6474,docs/4.6/modules/qutip/nonmarkov/heom.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html,2,['perform'],['performance']
Performance,".exp_freq = None. self.options = None; self.progress_bar = None; self.stats = None. self.ode = None; self.configured = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters; ----------; options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats; """""". self.H_sys = H_sys; self.coup_op = coup_op; self.coup_strength = coup_strength; self.temperature = temperature; self.N_cut = N_cut; self.N_exp = N_exp; if planck: self.planck = planck; if boltzmann: self.boltzmann = boltzmann; if isinstance(options, Options): self.options = options; if isinstance(progress_bar, BaseProgressBar):; self.progress_bar = progress_bar; elif progress_bar == True:; self.progress_bar = TextProgressBar(); elif progress_bar == False:; self.progress_bar = None; if isinstance(stats, Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections; config; integrate; """"""; stats = Stats(['config', 'run']); stats.header = ""Hierarchy Solver Stats""; return st",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/heom.html:6442,perform,performance,6442,docs/4.1/modules/qutip/nonmarkov/heom.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/heom.html,6,['perform'],['performance']
Performance,".get('pulse_action'). optim.pulse_generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params); ; lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub; ; if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action; ; if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]; ; else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__). return optim. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:68997,optimiz,optimizer,68997,docs/4.5/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimizer']
Performance,".integrate import ode; import scipy.sparse as sp; from scipy.integrate._ode import zvode; from scipy.linalg.blas import get_blas_funcs; from qutip.qobj import Qobj; from qutip.parallel import parfor, parallel_map, serial_map; from qutip.cy.spmatfuncs import cy_ode_rhs, cy_expect_psi_csr, spmv, spmv_csr; from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup; from qutip.cy.spconvert import dense2D_to_fastcsr_cmode; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; from qutip.fastsparse import csr2fast; import qutip.settings. dznrm2 = get_blas_funcs(""znrm2"", dtype=np.float64). if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions; #; _cy_col_spmv_func = None; _cy_col_expect_func = None; _cy_col_spmv_call_func = None; _cy_col_expect_call_func = None; _cy_rhs_func = None. class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=None,; args={}, options=None, progress_bar=True,; map_func=None, map_kwargs=None,; _safe_mode=True):; """"""Monte Carlo evolution of a state vector :math:`|\psi \\rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, consider ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:3146,load,loaded,3146,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['load'],['loaded']
Performance,".j 0.1+0.j 0. +0.1j 0. +0.j ]; [0. +0.j 0. -0.1j 0.1+0.j 0. +0.j ]; [0.1+0.j 0. +0.j 0. +0.j 0.1+0.j ]]. One convenient property of the \(\chi\) matrix is that the average; gate fidelity with the identity map can be read off directly from; the \(\chi_{00}\) element:; In [126]: print(average_gate_fidelity(S)); 0.9499999999999998. In [127]: print(chi[0, 0] / 4); (0.925+0j). Here, the factor of 4 comes from the dimension of the underlying; Hilbert space \(\mathcal{H}\). As with the superoperator; and Choi representations, the \(\chi\) representation is; denoted by the superrep, such that to_super,; to_choi, to_kraus,; to_stinespring and to_chi; all convert from the \(\chi\) representation appropriately. Properties of Quantum Maps¶; In addition to converting between the different representations of quantum maps,; QuTiP also provides attributes to make it easy to check if a map is completely; positive, trace preserving and/or hermicity preserving. Each of these attributes; uses superrep to automatically perform any needed conversions.; In particular, a quantum map is said to be positive (but not necessarily completely; positive) if it maps all positive operators to positive operators. For instance, the; transpose map \(\Lambda(\rho) = \rho^{\mathrm{T}}\) is a positive map. We run into; problems, however, if we tensor \(\Lambda\) with the identity to get a partial; transpose map.; In [128]: rho = ket2dm(bell_state()). In [129]: rho_out = partial_transpose(rho, [0, 1]); .....: print(rho_out.eigenenergies()); .....: ; [-0.5 0.5 0.5 0.5]. Notice that even though we started with a positive map, we got an operator out; with negative eigenvalues. Complete positivity addresses this by requiring that; a map returns positive operators for all positive operators, and does so even; under tensoring with another map. The Choi matrix is very useful here, as it; can be shown that a map is completely positive if and only if its Choi matrix; is positive [Wat13]. QuTiP implements this check",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-states.html:31427,perform,perform,31427,docs/4.5/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-states.html,1,['perform'],['perform']
Performance,".parallel.parallel_map only iterate over the values arguments, the qutip.parallel.parfor function simultaneously iterates over all arguments:; In [20]: def sum_diff(x, y, z=0): return x + y, x - y, z. In [21]: parfor(sum_diff, [1, 2, 3], [4, 5, 6], z=5.0); Out[21]: [array([5, 7, 9]), array([-3, -3, -3]), array([5., 5., 5.])]. In [22]: parallel_map(sum_diff, [1, 2, 3], task_args=(np.array([4, 5, 6]),), task_kwargs=dict(z=5.0)); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-parfor.html:5365,perform,performance,5365,docs/4.3/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-parfor.html,2,['perform'],['performance']
Performance,".pi/2., 2*np.pi/2, 3*np.pi/2])). # define noise, loc and scale are keyword arguments for np.random.normal; gaussnoise = RandomNoise(; dt=0.01, rand_gen=np.random.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; fig1, axis1 = processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, axis2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); axis2[0].step(qobjevo.tlist, noisy_coeff). Customize the simulator¶; The number of predefined physical models and compilers are limited.; However, it is designed for easy customization and one can easily build customized model and compiling routines.; For guide and examples, please refer to the tutorial notebooks; at https://qutip.org/tutorials.html. The workflow of the simulator¶; The following plot demonstrates the workflow of the simulator. The core of the simulator is Processor,; which characterizes the quantum hardware of interest,; containing the information such as the non-controllable drift Hamiltonian and; the control Hamiltonian.; Apart from the ideal system representing the qubits, one can also define; hardware-dependent or pulse-dependent noise in Noise.; It describes how noisy terms such as imperfect control; and decoherence can be added once the ideal control pulse is defined.; When loading a quantum circuit, a GateCompiler compiles the circuit into a sequence of control pulse signals and schedule the pulse for parallel execution.; For each control Hamiltonian, a Pulse instance is created that including the ideal evolution and associated noise.; They will then be sent to the QuTiP solvers for the computation. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/qip/qip-processor.html:20295,load,loading,20295,docs/4.7/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html,1,['load'],['loading']
Performance,".ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_ode_super_func); r.set_f_params(L.data); else:; if opt.use_openmp and L.data.nnz >= qset.openmp_thresh:; r = scipy.integrate.ode(cy_ode_rhs_openmp); r.set_f_params(L.data.data, L.data.indices, L.data.indptr, ; opt.openmp_threads); else:; r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(L.data.data, L.data.indices, L.data.indptr); # r = scipy.integrate.ode(_ode_rho_test); # r.set_f_params(L.data); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master eqaution; # [no longer used, replaced by cython function]; #; def _ode_rho_func(t, rho, L):; return L * rho. def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); #; # Evaluate d E(t)/dt for E a super-operator; #. def _ode_super_func(t, y, data):; ym = vec2mat(y); return (data*ym).ravel('F'). # -----------------------------------------------------------------------------; # Master equation solver for python-function time-dependence.; #; def _mesolve_func_td(L_func, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver with time dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; rho0 = ket2dm(rho0). #; # construct liouvillian; #; new_args = None. if len(c_op_list) > 0:; L_data = liouvillian(None, c_op_list).data; else:; n, m = rho0.shape; if issuper(rho0):; L_data = sp.csr_matrix((n, m), dtype=complex); else:; L_data = sp.csr_matrix((n ** 2, m ** 2), dtype=complex). if type(args) is dict:; new_args = {}; for key in args:; if isinstance(args[key], Qobj):; if isope",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:24379,perform,performance,24379,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,3,['perform'],['performance']
Performance,"0 requires; # averaging over both t and tau; for t_idx in range(np.size(tlist)):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. for trial_idx in range(options.ntraj[0]):; if isinstance(a_op, Qobj) and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H_shifted, chi_0/chi_0.norm(), taulist, c_ops, [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H_shifted, chi/chi.norm(), taulist, c_ops, [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat[t_idx, :] += \; 1/(4*options.ntraj[0]) * (c_tau[0] - c_tau[2] -; 1j*c_tau[1] + 1j*c_tau[3]); if t_idx == 1:; options.rhs_reuse = True. return corr_mat. # pseudo-inverse solvers. def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; """"""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\\tau)B(0)\\right>`.; """""". L = H if issuper(H) else liouvillian(H, c_ops). tr_mat = tensor([qeye(n) for n in L.dims[0][0]]); N = np.prod(L.dims[0][0]). A = L.full();",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html:36586,load,loaded,36586,docs/3.1.0/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html,1,['load'],['loaded']
Performance,"0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Change Log. Change Log¶. Version 4.1.0 (in dev)¶. Improvements¶; Core libraries. erf supported function in td strings. QIP. Gate object can be used to instantiate another identical gate. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codegen further optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (Added by Denis Vasilyev); Can now define a given eigen spectrum for random Hermitian and density operators.; The Qobj expm method ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/changelog.html:1651,perform,performance,1651,docs/4.0.2/changelog.html,https://qutip.org,https://qutip.org/docs/4.0.2/changelog.html,1,['perform'],['performance']
Performance,"0.5+0j). In [13]: es3_expect.value([0.0, pi/2]); Out[13]: array([ -1.00000000e+00, -6.12323400e-17]). Note the expectation value of the qutip.eseries object, expect(rho, es3), itself is an qutip.eseries, but with amplitude coefficients that are C-numbers instead of quantum operators. To evaluate the C-number qutip.eseries at the times times we use esval(es3_expect, times), or, equivalently, es3_expect.value(times). Applications of exponential series¶; The exponential series formalism can be useful for the time-evolution of quantum systems. One approach to calculating the time evolution of a quantum system is to diagonalize its Hamiltonian (or Liouvillian, for dissipative systems) and to express the propagator (e.g., \(\exp(-iHt) \rho \exp(iHt)\)) as an exponential series.; The QuTiP function qutip.essolve.ode2es and qutip.essolve use this method to evolve quantum systems in time. The exponential series approach is particularly suitable for cases when the same system is to be evolved for many different initial states, since the diagonalization only needs to be performed once (as opposed to e.g. the ode solver that would need to be ran independently for each initial state).; As an example, consider a spin-1/2 with a Hamiltonian pointing in the \(\sigma_z\) direction, and that is subject to noise causing relaxation. For a spin originally is in the up state, we can create an qutip.eseries object describing its dynamics by using the qutip.es2ode function:; In [14]: psi0 = basis(2,1). In [15]: H = sigmaz(). In [16]: L = liouvillian(H, [sqrt(1.0) * destroy(2)]). In [17]: es = ode2es(L, psi0). The qutip.essolve.ode2es function diagonalizes the Liouvillian \(L\) and creates an exponential series with the correct eigenfrequencies and amplitudes for the initial state \(\psi_0\) (psi0).; We can examine the resulting qutip.eseries object by printing a text representation:; In [18]: es; Out[18]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[2], [2]]; Exponent #0 = (-1+0j",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-eseries.html:6526,perform,performed,6526,docs/3.1.0/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-eseries.html,1,['perform'],['performed']
Performance,"0.5+0j). In [15]: es3_expect.value([0.0, pi/2]); Out[15]: array([ -1.00000000e+00, -6.12323400e-17]). Note the expectation value of the qutip.eseries object, expect(rho, es3), itself is an qutip.eseries, but with amplitude coefficients that are C-numbers instead of quantum operators. To evaluate the C-number qutip.eseries at the times times we use esval(es3_expect, times), or, equivalently, es3_expect.value(times). Applications of exponential series¶; The exponential series formalism can be useful for the time-evolution of quantum systems. One approach to calculating the time evolution of a quantum system is to diagonalize its Hamiltonian (or Liouvillian, for dissipative systems) and to express the propagator (e.g., \(\exp(-iHt) \rho \exp(iHt)\)) as an exponential series.; The QuTiP function qutip.essolve.ode2es and qutip.essolve use this method to evolve quantum systems in time. The exponential series approach is particularly suitable for cases when the same system is to be evolved for many different initial states, since the diagonalization only needs to be performed once (as opposed to e.g. the ode solver that would need to be ran independently for each initial state).; As an example, consider a spin-1/2 with a Hamiltonian pointing in the \(\sigma_z\) direction, and that is subject to noise causing relaxation. For a spin originally is in the up state, we can create an qutip.eseries object describing its dynamics by using the qutip.es2ode function:; In [16]: psi0 = basis(2,1). In [17]: H = sigmaz(). In [18]: L = liouvillian(H, [sqrt(1.0) * destroy(2)]). In [19]: es = ode2es(L, psi0). The qutip.essolve.ode2es function diagonalizes the Liouvillian \(L\) and creates an exponential series with the correct eigenfrequencies and amplitudes for the initial state \(\psi_0\) (psi0).; We can examine the resulting qutip.eseries object by printing a text representation:; In [20]: es; Out[20]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[2], [2]]; Exponent #0 = (-1+0j",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-eseries.html:6429,perform,performed,6429,docs/3.0.0/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-eseries.html,2,['perform'],['performed']
Performance,"0]:; return 0.5 * ((1j * self).expm() + (-1j * self).expm()); else:; raise TypeError('Invalid operand for matrix square root'). [docs] def sinm(self):; """"""Sine of a quantum operator. Operator must be square. Returns; -------; oper : :class:`qutip.Qobj`; Matrix sine of operator. Raises; ------; TypeError; Quantum object is not square. Notes; -----; Uses the Q.expm() method. """"""; if self.dims[0][0] == self.dims[1][0]:; return -0.5j * ((1j * self).expm() - (-1j * self).expm()); else:; raise TypeError('Invalid operand for matrix square root'). [docs] def unit(self, inplace=False,; norm=None, sparse=False,; tol=0, maxiter=100000):; """"""Operator or state normalized to unity. Uses norm from Qobj.norm(). Parameters; ----------; inplace : bool; Do an in-place normalization; norm : str; Requested norm for states / operators.; sparse : bool; Use sparse eigensolver for trace norm. Does not affect other norms.; tol : float; Tolerance used by sparse eigensolver.; maxiter : int; Number of maximum iterations performed by sparse eigensolver. Returns; -------; oper : :class:`qutip.Qobj`; Normalized quantum object if not in-place,; else None. """"""; if inplace:; nrm = self.norm(norm=norm, sparse=sparse,; tol=tol, maxiter=maxiter). self.data /= nrm; elif not inplace:; out = self / self.norm(norm=norm, sparse=sparse,; tol=tol, maxiter=maxiter); if settings.auto_tidyup:; return out.tidyup(); else:; return out; else:; raise Exception('inplace kwarg must be bool.'). [docs] def ptrace(self, sel):; """"""Partial trace of the quantum object. Parameters; ----------; sel : int/list; An ``int`` or ``list`` of components to keep after partial trace. Returns; -------; oper : :class:`qutip.Qobj`; Quantum object representing partial trace with selected components; remaining. Notes; -----; This function is identical to the :func:`qutip.qobj.ptrace` function; that has been deprecated. """"""; q = Qobj(); q.data, q.dims, _ = _ptrace(self, sel); return q.tidyup() if settings.auto_tidyup else q. [docs] def permut",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobj.html:32416,perform,performed,32416,docs/4.4/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobj.html,1,['perform'],['performed']
Performance,"10); >>> dm_list = mesolve(H, psi0, times, c_ops, []); >>> qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program; >>> dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0; >>> a = destroy(10); >>> expect(a.dag() * a, dm_list_loaded.states) ; array([4.63317086, 3.59150315, 2.90590183, 2.41306641, 2.05120716,; 1.78312503, 1.58357995, 1.4346382 , 1.32327398, 1.23991233]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes two mandatory and three optional arguments:; >>> file_data_store(filename, data, numtype=""complex"", numformat=""decimal"", sep="","") . where filename is the name of the file, data is the data to be written to the file (must be a numpy array), numtype (optional) is a flag indicating numerical type that can take values complex or real, numformat (optional) specifies the numerical format that can take the values exp for the format 1.0e1 and decimal for the format 10.0, and sep (optional) is an arbitrary single-character field separator (usually a tab, space, comma, semicolon, etc.).; A common use for the qutip.fileio.file_data_store function is to store the expectation values of a set of operators for a sequence of times, e.g., as returned by the qutip.mesolve function, which is what the following example does; >>> a = dest",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-saving.html:4258,load,load,4258,docs/4.6/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-saving.html,2,['load'],['load']
Performance,"15):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. « Visualization of... Saving QuTiP Obj... ». Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; In [1]: def func1(x): return x, x**2, x**3. In [2]: a, b, c = parfor(func1, range(10)). In [3]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [4]: print(b); [ 0 1 4 9 16 25 36 49 64 81]. In [5]: print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; In [6]: result = parallel_map(func1, range(10)). In [7]: result_array = np.array(result). In [8]: print(result_array[:, 0]) # == a; [0 1 2 3 4 5 6 7 8 9]. In [9]: print(result_array[:, 1]) # == b; [ 0 1 4 9 16 25 36 49 64 81]. In [10]: print(result_array[:, 2]) # == c; [ 0 1 8 27 64 125 216 343 512 729]. Note that the return values are arranged differently for the qutip.parallel.parallel_map and the qutip.parallel.parfor functions, as illustrated below. In particular, the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-parfor.html:2100,perform,performed,2100,docs/3.1.0/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-parfor.html,1,['perform'],['performed']
Performance,"17). 272. Cesa et al., ""Two-qubit entangling gates between distant atomic qubits in a lattice"", ; Phys. Rev. A 95, 052330 (2017). 271. Ren et al., ""Evanescent-Vacuum-Enhanced Photon-Exciton Coupling and Fluorescence Collection"", ; Phys. Rev. Lett. 118, 073604 (2017). 270. Chu et al., ""Quantum acoustics with superconducting qubits"", ; Science 358, 199 (2017). 269. Fischer et al., ""Signatures of two-photon pulses from a quantum two-level system"", ; Nat. Phys. 13, 649 (2017). 268. Marshman et al., ""Investigating and improving student understanding of the probability distributions for measuring physical observables in quantum mechanics"", ; Eur. J. Phys. 38, 025705 (2017). 267. Borges et al., ""Influence of the asymmetric excited state decay on coherent population trapping: atom × quantum dot"", ; arXiv:1702.07692. 266. Pleinert et al., ""Hyperradiance from collective behavior of coherently driven atoms"", ; Optica 4, 779 (2017). 265. Oviedo-Casado et al., ""Magnetic field enhancement of organic photovoltaic cells performance"", ; Sci. Rep. 7, 4297 (2017). 264. Whalen et al., ""Open quantum systems with delayed coherent feedback"", ; Quantum Sci. Technol. 2, 044008 (2017). 263. Cottet et al., ""Observing a quantum Maxwell demon at work"", ; Proc. Natl. Acad. Sci. U.S.A. 114, 7561 (2017). 262. Mazloom et al., ""Adiabatic state preparation of stripe phases with strongly magnetic atoms"", ; Phys. Rev. A 96, 033602 (2017). 261. Poonia et al., ""Functional window of the avian compass"", ; Phys. Rev. E 95, 052417 (2017). 260. Su et al., ""Generating double NOON states of photons in circuit QED"", ; Phys. Rev. A 95, 022339 (2017). 259. Kiukas et al., ""Remote parameter estimation in a quantum spin chain enhanced by local control"", ; Phys. Rev. A 95, 052132 (2017). 258. Gely et al., ""Convergence of the multimode quantum Rabi model of circuit quantum electrodynamics"", ; Phys. Rev. B 95, 245115 (2017). 257. Radtke et al., ""Photonic Quantum Operations via the Quantum Carburettor Effect"", ; arXiv:17",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:14038,perform,performance,14038,users.html,https://qutip.org,https://qutip.org/users.html,1,['perform'],['performance']
Performance,"1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes containing termination conditions for the control pulse optimisation; i.e. attributes that will be checked during the optimisation, that; will determine if the algorithm has completed its task / exceeded limits; """""". [docs]class TerminationConditions(object):; """"""; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes; ----------; fid_err_targ : float; Target fidelity error. fid_goal : float; goal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_time : float; # maximum time for optimisation (seconds). min_gradient_norm : float; Minimum normalised gradient after which optimisation will terminate. max_iterations : integer; Maximum iterations of the optimisation algorithm. max_fid_func_calls : integer; Maximum number of calls to the fidelity function during; the optimisation algorithm; ; accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user; """"""; def __init__(self):; self.reset(). def reset(self):; self.fid_err_targ = 1e-5; self.fid_goal = None; self.max_wall_time = 60*60.0; self.min_gradient_norm = 1e-5; self.max_iterations = 1e10; self.max_fid_func_calls = 1e10. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/termcond.html:3456,optimiz,optimize,3456,docs/4.3/modules/qutip/control/termcond.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/termcond.html,1,['optimiz'],['optimize']
Performance,"24); Add towncrier draft build of changelog to CI tests. (#1946); Add Python 3.11 to builds. (#2041); Simplify version parsing by using packaging.version.Version. (#2043); Update builds to use cibuildwheel 2.11, and to build with manylinux2014 on Python 3.8 and 3.9, since numpy and SciPy no longer support manylinux2010 on those versions of Python. (#2047). Version 4.7.0 (April 13, 2022)¶; This release sees the addition of two new solvers – qutip.krylovsolve based on the Krylov subspace approximation and qutip.nonmarkov.heom that reimplements the BoFiN HEOM solver.; Bloch sphere rendering gained support for drawing arcs and lines on the sphere, and for setting the transparency of rendered points and vectors, Hinton plots gained support for specifying a coloring style, and matrix histograms gained better default colors and more flexible styling options.; Other significant improvements include better scaling of the Floquet solver, support for passing Path objects when saving and loading files, support for passing callable functions as e_ops to mesolve and sesolve, and faster state number enumeration and Husimi Q functions.; Import bugfixes include some bugs affecting plotting with matplotlib 3.5 and fixing support for qutrits (and other non-qubit) quantum circuits.; The many other small improvements, bug fixes, documentation enhancements, and behind the scenese development changes are included in the list below.; QuTiP 4.7.X will be the last series of releases for QuTiP 4. Patch releases will continue for the 4.7.X series but the main development effort will move to QuTiP 5.; The many, many contributors who filed issues, submitted or reviewed pull requests, and improved the documentation for this release are listed next to their contributions below. Thank you to all of you. Improvements¶. MAJOR Added krylovsolve as a new solver based on krylov subspace approximation. (#1739 by Emiliano Fortes); MAJOR Imported BoFiN HEOM (https://github.com/tehruhn/bofin/) into QuTiP an",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/changelog.html:7351,load,loading,7351,docs/4.7/changelog.html,https://qutip.org,https://qutip.org/docs/4.7/changelog.html,1,['load'],['loading']
Performance,"345018. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [9]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [10]: psi0 = rand_ket(10). In [11]: times = np.linspace(0, 10, 10). In [12]: dm_list = mesolve(H, psi0, times, c_ops, []). In [13]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [14]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [15]: a = destroy(10). In [16]: expect(a.dag() * a, dm_list_loaded.states); Out[16]: ; array([ 3.87543797, 3.11893669, 2.5717301 , 2.17012827, 1.87240607,; 1.65062668, 1.48498272, 1.36107052, 1.26828395, 1.19875921]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes two mandatory and three optional arguments:; >>> file_data_store(filename, data, numtype=""complex"", numformat=""decimal"", sep="",""). where filename is the name of the file, data is the data to be written to the file (must be a numpy array), numtype (optional) is a flag indicating numerical type that can take values complex or real, numformat (optional) specifies the numerical format that can take the v",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-saving.html:4554,load,loading,4554,docs/3.0.0/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-saving.html,1,['load'],['loading']
Performance,"3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [5]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True. In [6]: a = destroy(10). In [7]: expect(a.dag() * a, rho_ss_loaded); Out[7]: 0.9902248289345061. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [8]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]. In [9]: psi0 = rand_ket(10). In [10]: times = np.linspace(0, 10, 10). In [11]: dm_list = mesolve(H, psi0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: expect(a.dag() * a, dm_list_loaded.states); Out[15]: ; array([4.40942767, 3.44132235, 2.80622054, 2.3433275 , 2.00107858,; 1.74653819, 1.55662702, 1.41466358, 1.30841238, 1.22882551]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-saving.html:3394,load,loaded,3394,docs/4.3/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-saving.html,1,['load'],['loaded']
Performance,"3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [5]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True. In [6]: a = destroy(10). In [7]: expect(a.dag() * a, rho_ss_loaded); Out[7]: 0.9902248289345061. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [8]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]. In [9]: psi0 = rand_ket(10). In [10]: times = np.linspace(0, 10, 10). In [11]: dm_list = mesolve(H, psi0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: expect(a.dag() * a, dm_list_loaded.states); Out[15]: ; array([4.63317086, 3.59150315, 2.90590183, 2.41306641, 2.05120716,; 1.78312503, 1.58357995, 1.4346382 , 1.32327398, 1.23991233]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-saving.html:3435,load,loaded,3435,docs/4.5/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-saving.html,1,['load'],['loaded']
Performance,"3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [5]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True. In [6]: a = destroy(10). In [7]: expect(a.dag() * a, rho_ss_loaded); Out[7]: 0.9902248289345063. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [8]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]. In [9]: psi0 = rand_ket(10). In [10]: times = np.linspace(0, 10, 10). In [11]: dm_list = mesolve(H, psi0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: expect(a.dag() * a, dm_list_loaded.states); Out[15]: ; array([4.04416292, 3.22336973, 2.64206514, 2.2194952 , 1.90787059,; 1.67647333, 1.50399675, 1.37514572, 1.27874735, 1.20656019]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-saving.html:3390,load,loaded,3390,docs/4.4/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-saving.html,1,['load'],['loaded']
Performance,"3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [5]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True. In [6]: a = destroy(10). In [7]: expect(a.dag() * a, rho_ss_loaded); Out[7]: 0.9902248289345064. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [8]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]. In [9]: psi0 = rand_ket(10). In [10]: times = np.linspace(0, 10, 10). In [11]: dm_list = mesolve(H, psi0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: expect(a.dag() * a, dm_list_loaded.states); Out[15]: ; array([ 3.40657352, 2.74980446, 2.29441406, 1.96186716, 1.71601185,; 1.5332011 , 1.39683111, 1.29490432, 1.21862519, 1.16149242]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store take",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-saving.html:3394,load,loaded,3394,docs/4.2/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-saving.html,1,['load'],['loaded']
Performance,"4. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [8]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]. In [9]: psi0 = rand_ket(10). In [10]: times = np.linspace(0, 10, 10). In [11]: dm_list = mesolve(H, psi0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: expect(a.dag() * a, dm_list_loaded.states); Out[15]: ; array([ 3.40657352, 2.74980446, 2.29441406, 1.96186716, 1.71601185,; 1.5332011 , 1.39683111, 1.29490432, 1.21862519, 1.16149242]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes two mandatory and three optional arguments:; >>> file_data_store(filename, data, numtype=""complex"", numformat=""decimal"", sep="",""). where filename is the name of the file, data is the data to be written to the file (must be a numpy array), numtype (optional) is a flag indicating numerical type that can take values complex or real, numformat (optional) specifies the numerical format that can take the v",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-saving.html:3867,load,loading,3867,docs/4.2/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-saving.html,1,['load'],['loading']
Performance,"505+0.0000000000j,1.5687324121+0.0000000000j,0.1351622725+0.0000000000j,0.2018398581+0.0000000000j; 6.0606060606+0.0000000000j,1.4348632045+0.0000000000j,0.2143080535+0.0000000000j,-0.0067820038+0.0000000000j; 7.0707070707+0.0000000000j,1.3321818015+0.0000000000j,0.0950352763+0.0000000000j,-0.1630920429+0.0000000000j; 8.0808080808+0.0000000000j,1.2533244850+0.0000000000j,-0.0771210981+0.0000000000j,-0.1468923919+0.0000000000j. In this case we didn’t really need to store both the real and imaginary parts, so instead we could use the numtype=""real"" option; >>> file_data_store('expect.dat', output_data.T, numtype=""real""); >>> with open(""expect.dat"", ""r"") as f:; ... print('\n'.join(f.readlines()[:5])); # Generated by QuTiP: 100x4 real matrix in decimal format [',' separated values].; 0.0000000000,3.2109553666,0.3689771549,0.0185002867; 1.0101010101,2.6754598872,0.1298251132,-0.3303672956; 2.0202020202,2.2743186810,-0.2106241300,-0.2623894277; 3.0303030303,1.9726633457,-0.3037311621,0.0397330921. and if we prefer scientific notation we can request that using the numformat=""exp"" option; >>> file_data_store('expect.dat', output_data.T, numtype=""real"", numformat=""exp""). Loading data previously stored using qutip.fileio.file_data_store (or some other software) is a even easier. Regardless of which deliminator was used, if data was stored as complex or real numbers, if it is in decimal or exponential form, the data can be loaded using the qutip.fileio.file_data_read, which only takes the filename as mandatory argument.; input_data = file_data_read('expect.dat'); plt.plot(input_data[:,0], input_data[:,1]); # plot the data. (If a particularly obscure choice of deliminator was used it might be necessary to use the optional second argument, for example sep=""_"" if _ is the deliminator). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-saving.html:7988,load,loaded,7988,docs/4.7/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html,1,['load'],['loaded']
Performance,"61. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [8]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]. In [9]: psi0 = rand_ket(10). In [10]: times = np.linspace(0, 10, 10). In [11]: dm_list = mesolve(H, psi0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: expect(a.dag() * a, dm_list_loaded.states); Out[15]: ; array([4.40942767, 3.44132235, 2.80622054, 2.3433275 , 2.00107858,; 1.74653819, 1.55662702, 1.41466358, 1.30841238, 1.22882551]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes two mandatory and three optional arguments:; >>> file_data_store(filename, data, numtype=""complex"", numformat=""decimal"", sep="",""). where filename is the name of the file, data is the data to be written to the file (must be a numpy array), numtype (optional) is a flag indicating numerical type that can take values complex or real, numformat (optional) specifies the numerical format that can take the v",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-saving.html:3866,load,loading,3866,docs/4.3/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-saving.html,1,['load'],['loading']
Performance,"61. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [8]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]. In [9]: psi0 = rand_ket(10). In [10]: times = np.linspace(0, 10, 10). In [11]: dm_list = mesolve(H, psi0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: expect(a.dag() * a, dm_list_loaded.states); Out[15]: ; array([4.63317086, 3.59150315, 2.90590183, 2.41306641, 2.05120716,; 1.78312503, 1.58357995, 1.4346382 , 1.32327398, 1.23991233]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes two mandatory and three optional arguments:; >>> file_data_store(filename, data, numtype=""complex"", numformat=""decimal"", sep="",""). where filename is the name of the file, data is the data to be written to the file (must be a numpy array), numtype (optional) is a flag indicating numerical type that can take values complex or real, numformat (optional) specifies the numerical format that can take the v",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-saving.html:3907,load,loading,3907,docs/4.5/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-saving.html,1,['load'],['loading']
Performance,"63. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [8]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]. In [9]: psi0 = rand_ket(10). In [10]: times = np.linspace(0, 10, 10). In [11]: dm_list = mesolve(H, psi0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: expect(a.dag() * a, dm_list_loaded.states); Out[15]: ; array([4.04416292, 3.22336973, 2.64206514, 2.2194952 , 1.90787059,; 1.67647333, 1.50399675, 1.37514572, 1.27874735, 1.20656019]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes two mandatory and three optional arguments:; >>> file_data_store(filename, data, numtype=""complex"", numformat=""decimal"", sep="",""). where filename is the name of the file, data is the data to be written to the file (must be a numpy array), numtype (optional) is a flag indicating numerical type that can take values complex or real, numformat (optional) specifies the numerical format that can take the v",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-saving.html:3862,load,loading,3862,docs/4.4/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-saving.html,1,['load'],['loading']
Performance,"8632045+0.0000000000j,0.2143080535+0.0000000000j,-0.0067820038+0.0000000000j; 7.0707070707+0.0000000000j,1.3321818015+0.0000000000j,0.0950352763+0.0000000000j,-0.1630920429+0.0000000000j; 8.0808080808+0.0000000000j,1.2533244850+0.0000000000j,-0.0771210981+0.0000000000j,-0.1468923919+0.0000000000j. In this case we didn’t really need to store both the real and imaginary parts, so instead we could use the numtype=""real"" option; >>> file_data_store('expect.dat', output_data.T, numtype=""real""); >>> with open(""expect.dat"", ""r"") as f:; ... print('\n'.join(f.readlines()[:5])); # Generated by QuTiP: 100x4 real matrix in decimal format [',' separated values].; 0.0000000000,3.2109553666,0.3689771549,0.0185002867; 1.0101010101,2.6754598872,0.1298251132,-0.3303672956; 2.0202020202,2.2743186810,-0.2106241300,-0.2623894277; 3.0303030303,1.9726633457,-0.3037311621,0.0397330921. and if we prefer scientific notation we can request that using the numformat=""exp"" option; >>> file_data_store('expect.dat', output_data.T, numtype=""real"", numformat=""exp""). Loading data previously stored using qutip.fileio.file_data_store (or some other software) is a even easier. Regardless of which deliminator was used, if data was stored as complex or real numbers, if it is in decimal or exponential form, the data can be loaded using the qutip.fileio.file_data_read, which only takes the filename as mandatory argument.; input_data = file_data_read('expect.dat'); plt.plot(input_data[:,0], input_data[:,1]); # plot the data. (png, hires.png, pdf). (If a particularly obscure choice of deliminator was used it might be necessary to use the optional second argument, for example sep=""_"" if _ is the deliminator). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-saving.html:7930,load,loaded,7930,docs/4.6/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-saving.html,1,['load'],['loaded']
Performance,"89345064. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [8]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [9]: psi0 = rand_ket(10). In [10]: times = np.linspace(0, 10, 10). In [11]: dm_list = mesolve(H, psi0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: expect(a.dag() * a, dm_list_loaded.states); Out[15]: ; array([ 4.21111367, 3.243081 , 2.64337648, 2.2162089 , 1.90369673,; 1.67257851, 1.50071221, 1.37250326, 1.27667537, 1.20496022]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes two mandatory and three optional arguments:; >>> file_data_store(filename, data, numtype=""complex"", numformat=""decimal"", sep="",""). where filename is the name of the file, data is the data to be written to the file (must be a numpy array), numtype (optional) is a flag indicating numerical type that can take values complex or real, numformat (optional) specifies the numerical format that can take the v",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/guide-saving.html:3854,load,loading,3854,docs/4.1/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.1/guide/guide-saving.html,1,['load'],['loading']
Performance,"89345064. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [8]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [9]: psi0 = rand_ket(10). In [10]: times = np.linspace(0, 10, 10). In [11]: dm_list = mesolve(H, psi0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: expect(a.dag() * a, dm_list_loaded.states); Out[15]: ; array([ 5.47236604, 4.25321934, 3.40221147, 2.78459863, 2.32939541,; 1.99152365, 1.739766 , 1.55173281, 1.41108289, 1.30577149]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes two mandatory and three optional arguments:; >>> file_data_store(filename, data, numtype=""complex"", numformat=""decimal"", sep="",""). where filename is the name of the file, data is the data to be written to the file (must be a numpy array), numtype (optional) is a flag indicating numerical type that can take values complex or real, numformat (optional) specifies the numerical format that can take the v",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-saving.html:4654,load,loading,4654,docs/3.1.0/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-saving.html,1,['load'],['loading']
Performance,"9345061. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [8]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [9]: psi0 = rand_ket(10). In [10]: times = np.linspace(0, 10, 10). In [11]: dm_list = mesolve(H, psi0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: expect(a.dag() * a, dm_list_loaded.states); Out[15]: ; array([ 4.29179401, 3.37589742, 2.75659972, 2.30562634, 1.97257341,; 1.72505191, 1.54045945, 1.40251047, 1.2992826 , 1.22196967]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes two mandatory and three optional arguments:; >>> file_data_store(filename, data, numtype=""complex"", numformat=""decimal"", sep="",""). where filename is the name of the file, data is the data to be written to the file (must be a numpy array), numtype (optional) is a flag indicating numerical type that can take values complex or real, numformat (optional) specifies the numerical format that can take the v",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-saving.html:3855,load,loading,3855,docs/4.0.2/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-saving.html,1,['load'],['loading']
Performance,"9345064. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [9]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [10]: psi0 = rand_ket(10). In [11]: times = np.linspace(0, 10, 10). In [12]: dm_list = mesolve(H, psi0, times, c_ops, []). In [13]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [14]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [15]: a = destroy(10). In [16]: expect(a.dag() * a, dm_list_loaded.states); Out[16]: ; array([ 5.05864971, 3.933244 , 3.16570274, 2.60846057, 2.19781898,; 1.8930801 , 1.66604188, 1.49648702, 1.36966702, 1.27471483]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes two mandatory and three optional arguments:; >>> file_data_store(filename, data, numtype=""complex"", numformat=""decimal"", sep="",""). where filename is the name of the file, data is the data to be written to the file (must be a numpy array), numtype (optional) is a flag indicating numerical type that can take values complex or real, numformat (optional) specifies the numerical format that can take the v",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/guide-saving.html:4615,load,loading,4615,docs/3.0.1/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-saving.html,1,['load'],['loading']
Performance,": figure(); Out[8]: <Figure size 640x480 with 0 Axes>. In [9]: plot(times, np.real(corr1), times, np.real(corr2), times, np.real(corr3)); Out[9]: ; [<matplotlib.lines.Line2D at 0x1a26dd45f8>,; <matplotlib.lines.Line2D at 0x1a26dd4668>,; <matplotlib.lines.Line2D at 0x1a250d2c18>]. In [10]: legend(['0.5','1.0','2.0']); Out[10]: <matplotlib.legend.Legend at 0x1a2551cef0>. In [11]: xlabel(r'Time $t$'); Out[11]: Text(0.5,0,'Time $t$'). In [12]: ylabel(r'Correlation $\left<x(t)x(0)\right>$'); Out[12]: Text(0,0.5,'Correlation $\\left<x(t)x(0)\\right>$'). In [13]: show(). Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using the qutip.essolve.essolve solver and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; import numpy as np; import pylab as plt; from qutip import *. N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * np.pi # cavity and atom frequency; g = 0.1 * 2 * np.pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = tensor(destroy(N), qeye(2)); sm = tensor(qeye(N), destroy(2)); H = wc * a.dag() * a + wa * sm.dag() * sm + g * (a.dag() * sm + a * sm.dag()). # collapse operators; n_th = 0.25; c_ops = [np.sqrt(kappa * (1 + n_th)) * a, np.sqrt(kappa * n_th) * a.dag(), np.sqrt(gamma) * sm]. # calculate the correlation function using the mesolve solver, and then fft to; # obtain the spectrum. Here we need to make sure ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-correlation.html:5289,perform,performs,5289,docs/4.5/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-correlation.html,1,['perform'],['performs']
Performance,": float. Variance of operator ‘oper’ for given state. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:rho : qutip.qobj. A density matrix. mask : list / array. A mask that selects which subsystems should be transposed. method : str. choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr: qutip.qobj. A density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state : qobj. Ket, bra, or density matrix for a two-qubit state. Returns:concur : float. Concurrence. References. [R2]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters:rho : qobj. Density matrix of composite object. selB : int/list. Selected components for density matrix B. base : {e,2}. Base of logarithm. sparse : {False,True}. Use sparse eigensolver. Returns:ent_cond : float. Value of conditional entropy. entropy_linear(rho)[source]¶; Linear entropy of a density matrix. Parameters:rho : qobj. sensity matrix or ket/bra vector. Returns:entropy : float. Linear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)[sour",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/apidoc/functions.html:43775,concurren,concurrence,43775,docs/4.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.1/apidoc/functions.html,2,['concurren'],['concurrence']
Performance,": float. Variance of operator ‘oper’ for given state. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:rho : qutip.qobj. A density matrix. mask : list / array. A mask that selects which subsystems should be transposed. method : str. choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr: qutip.qobj. A density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state : qobj. Ket, bra, or density matrix for a two-qubit state. Returns:concur : float. Concurrence. References. [R2]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a slected density matrix component. Parameters:rho : qobj. Density matrix of composite object. selB : int/list. Selected components for density matrix B. base : {e,2}. Base of logarithm. sparse : {False,True}. Use sparse eigensolver. Returns:ent_cond : float. Value of conditional entropy. entropy_linear(rho)[source]¶; Linear entropy of a density matrix. Parameters:rho : qobj. sensity matrix or ket/bra vector. Returns:entropy : float. Linear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)[sourc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:33145,concurren,concurrence,33145,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,2,['concurren'],['concurrence']
Performance,":; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = complex(item); n += 1; m += 1. else:; data = np.zeros((M, N), dtype=""float""); m = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = float(item); n += 1; m += 1. f.close(). return data. [docs]def qsave(data, name='qutip_data'):; """"""; Saves given data to file named 'filename.qu' in current directory. Parameters; ----------; data : instance/array_like; Input Python object to be stored.; filename : str; Name of output data file. """"""; # open the file for writing; fileObject = open(name + '.qu', 'wb'); # this writes the object a to the file named 'filename.qu'; pickle.dump(data, fileObject); fileObject.close(). [docs]def qload(name):; """"""; Loads data file from file named 'filename.qu' in current directory. Parameters; ----------; name : str; Name of data file to be loaded. Returns; -------; qobject : instance / array_like; Object retrieved from requested file. """"""; fileObject = open(name + '.qu', 'rb') # open the file for reading; if sys.version_info >= (3, 0):; out = pickle.load(fileObject, encoding='latin1') # return the object from the file; else:; out = pickle.load(fileObject); if isinstance(out, Qobj): # for quantum objects; print('Loaded Qobj object:'); str1 = ""Quantum object: "" + ""dims = "" + str(out.dims) \; + "", shape = "" + str(out.shape) + "", type = "" + out.type; if out.type == 'oper' or out.type == 'super':; str1 += "", isHerm = "" + str(out.isherm) + ""\n""; else:; str1 += ""\n""; print(str1); elif isinstance(out, Result):; print('Loaded Result object:'); print(out); else:; print(""Loaded "" + str(type(out).__name__) + "" object.""); return out. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/fileio.html:7188,load,load,7188,docs/4.0.2/modules/qutip/fileio.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/fileio.html,2,['load'],['load']
Performance,":; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = complex(item); n += 1; m += 1. else:; data = np.zeros((M, N), dtype=""float""); m = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = float(item); n += 1; m += 1. f.close(). return data. [docs]def qsave(data, name='qutip_data'):; """"""; Saves given data to file named 'filename.qu' in current directory. Parameters; ----------; data : instance/array_like; Input Python object to be stored.; filename : str; Name of output data file. """"""; # open the file for writing; fileObject = open(name + '.qu', 'wb'); # this writes the object a to the file named 'filename.qu'; pickle.dump(data, fileObject); fileObject.close(). [docs]def qload(name):; """"""; Loads data file from file named 'filename.qu' in current directory. Parameters; ----------; name : str; Name of data file to be loaded. Returns; -------; qobject : instance / array_like; Object retrieved from requested file. """"""; fileObject = open(name + '.qu', 'rb') # open the file for reading; if sys.version_info >= (3, 0):; out = pickle.load(fileObject, encoding='latin1') # return the object from the file; else:; out = pickle.load(fileObject); if isinstance(out, Qobj): # for quantum objects; print('Loaded Qobj object:'); str1 = ""Quantum object: "" + ""dims = "" + str(out.dims) \; + "", shape = "" + str(out.shape) + "", type = "" + out.type; if out.type == 'oper' or out.type == 'super':; str1 += "", isHerm = "" + str(out.isherm) + ""\n""; else:; str1 += ""\n""; print(str1); elif isinstance(out, Result):; print('Loaded Result object:'); print(out); else:; print(""Loaded "" + str(type(out).__name__) + "" object.""); return out. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/fileio.html:7188,load,load,7188,docs/4.2/modules/qutip/fileio.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/fileio.html,2,['load'],['load']
Performance,":; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = complex(item); n += 1; m += 1. else:; data = np.zeros((M, N), dtype=""float""); m = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = float(item); n += 1; m += 1. f.close(). return data. [docs]def qsave(data, name='qutip_data'):; """"""; Saves given data to file named 'filename.qu' in current directory. Parameters; ----------; data : instance/array_like; Input Python object to be stored.; filename : str; Name of output data file. """"""; # open the file for writing; fileObject = open(name + '.qu', 'wb'); # this writes the object a to the file named 'filename.qu'; pickle.dump(data, fileObject); fileObject.close(). [docs]def qload(name):; """"""; Loads data file from file named 'filename.qu' in current directory. Parameters; ----------; name : str; Name of data file to be loaded. Returns; -------; qobject : instance / array_like; Object retrieved from requested file. """"""; fileObject = open(name + '.qu', 'rb') # open the file for reading; if sys.version_info >= (3, 0):; out = pickle.load(fileObject, encoding='latin1') # return the object from the file; else:; out = pickle.load(fileObject); if isinstance(out, Qobj): # for quantum objects; print('Loaded Qobj object:'); str1 = ""Quantum object: "" + ""dims = "" + str(out.dims) \; + "", shape = "" + str(out.shape) + "", type = "" + out.type; if out.type == 'oper' or out.type == 'super':; str1 += "", isHerm = "" + str(out.isherm) + ""\n""; else:; str1 += ""\n""; print(str1); elif isinstance(out, Result):; print('Loaded Result object:'); print(out); else:; print(""Loaded "" + str(type(out).__name__) + "" object.""); return out. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/fileio.html:7188,load,load,7188,docs/4.1/modules/qutip/fileio.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/fileio.html,2,['load'],['load']
Performance,":; phase_option : string. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm : complex; Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current : boolean; flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:104200,cache,cached,104200,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['cache'],['cached']
Performance,"; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes containing termination conditions for the control pulse optimisation; i.e. attributes that will be checked during the optimisation, that; will determine if the algorithm has completed its task / exceeded limits; """""". [docs]class TerminationConditions(object):; """"""; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes; ----------; fid_err_targ : float; Target fidelity error. fid_goal : float; goal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_time : float; # maximum time for optimisation (seconds). min_gradient_norm : float; Minimum normalised gradient after which optimisation will terminate. max_iterations : integer; Maximum iterations of the optimisation algorithm. max_fid_func_calls : integer; Maximum number of calls to the fidelity function during; the optimisation algorithm; ; accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user; """"""; def __init__(self):; self.reset(). def reset(self):; self.fid_err_targ = 1e-5; self.fid_goal = None; self.max_wall_time = 60*60.0; self.min_gradient_norm = 1e-5; self.max_iterations = 1e10; self.max_fid_func_calls = 1e10. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/control/termcond.html:3465,optimiz,optimize,3465,docs/4.5/modules/qutip/control/termcond.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/termcond.html,1,['optimiz'],['optimize']
Performance,"; ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; ; optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that parameters have been supp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:65623,optimiz,optimizer,65623,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,2,['optimiz'],['optimizer']
Performance,"; ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that parameters have been suppli",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:65229,optimiz,optimizer,65229,docs/4.2/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html,3,['optimiz'],['optimizer']
Performance,"; Adjoint (dagger) of quantum object. dnorm(); Diamond norm of quantum operator. dual_chan(); Dual channel of quantum object representing a CP map. eigenenergies(sparse=False, sort=’low’, eigvals=0, tol=0, maxiter=100000); Returns eigenenergies (eigenvalues) of a quantum object. eigenstates(sparse=False, sort=’low’, eigvals=0, tol=0, maxiter=100000); Returns eigenenergies and eigenstates of quantum object. expm(); Matrix exponential of quantum object. full(order=’C’); Returns dense array of quantum object data attribute. groundstate(sparse=False, tol=0, maxiter=100000); Returns eigenvalue and eigenket for the groundstate of a quantum object. matrix_element(bra, ket); Returns the matrix element of operator between bra and ket vectors. norm(norm=’tr’, sparse=False, tol=0, maxiter=100000); Returns norm of a ket or an operator. permute(order); Returns composite qobj with indices reordered. proj(); Computes the projector for a ket or bra vector. ptrace(sel); Returns quantum object for selected dimensions after performing partial trace. sinm(); Sine of quantum object. sqrtm(); Matrix square root of quantum object. tidyup(atol=1e-12); Removes small elements from quantum object. tr(); Trace of quantum object. trans(); Transpose of quantum object. transform(inpt, inverse=False); Performs a basis transformation defined by inpt matrix. trunc_neg(method=’clip’); Removes negative eigenvalues and returns a new Qobj that is a valid density operator. unit(norm=’tr’, sparse=False, tol=0, maxiter=100000); Returns normalized quantum object. check_herm()[source]¶; Check if the quantum object is hermitian. Returns:; isherm : bool; Returns the new value of isherm property. check_isunitary()[source]¶; Checks whether qobj is a unitary matrix. conj()[source]¶; Conjugate operator of quantum object. copy()[source]¶; Create identical copy. cosm()[source]¶; Cosine of a quantum operator.; Operator must be square. Returns:; oper : qobj; Matrix cosine of operator. Raises:; TypeError; Quantum objec",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:4095,perform,performing,4095,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['perform'],['performing']
Performance,"; Adjoint (dagger) of quantum object. dnorm(); Diamond norm of quantum operator. dual_chan(); Dual channel of quantum object representing a CP map. eigenenergies(sparse=False, sort=’low’, eigvals=0, tol=0, maxiter=100000); Returns eigenenergies (eigenvalues) of a quantum object. eigenstates(sparse=False, sort=’low’, eigvals=0, tol=0, maxiter=100000); Returns eigenenergies and eigenstates of quantum object. expm(); Matrix exponential of quantum object. full(order=’C’); Returns dense array of quantum object data attribute. groundstate(sparse=False, tol=0, maxiter=100000); Returns eigenvalue and eigenket for the groundstate of a quantum object. matrix_element(bra, ket); Returns the matrix element of operator between bra and ket vectors. norm(norm=’tr’, sparse=False, tol=0, maxiter=100000); Returns norm of a ket or an operator. permute(order); Returns composite qobj with indices reordered. proj(); Computes the projector for a ket or bra vector. ptrace(sel); Returns quantum object for selected dimensions after performing partial trace. sinm(); Sine of quantum object. sqrtm(); Matrix square root of quantum object. tidyup(atol=1e-12); Removes small elements from quantum object. tr(); Trace of quantum object. trans(); Transpose of quantum object. transform(inpt, inverse=False); Performs a basis transformation defined by inpt matrix. trunc_neg(method=’clip’); Removes negative eigenvalues and returns a new Qobj that is a valid density operator. unit(norm=’tr’, sparse=False, tol=0, maxiter=100000); Returns normalized quantum object. check_herm(self)[source]¶; Check if the quantum object is hermitian. Returns. ishermboolReturns the new value of isherm property. check_isunitary(self)[source]¶; Checks whether qobj is a unitary matrix. conj(self)[source]¶; Conjugate operator of quantum object. copy(self)[source]¶; Create identical copy. cosm(self)[source]¶; Cosine of a quantum operator.; Operator must be square. Returns. operqutip.QobjMatrix cosine of operator. Raises. TypeErrorQu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:3988,perform,performing,3988,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,1,['perform'],['performing']
Performance,"; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Change Log. Change Log¶. Version 4.3.0 ()¶. Improvements¶. Added fast projector method, Q.proj().; Computing matrix elements, Q.matrix_element is now ~10x faster.; Computing expectation values for ket vectors using expect is now ~10x faster.; Q.tr() is now faster for small Hilbert space dimensions. Bug Fixes¶. Fixed bug in trace-norm for non-Hermitian operators. Version 4.2.0 (July 28, 2017)¶. Improvements¶. MAJOR FEATURE: Initial implementation of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization. This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputing a list. with Python functions as time-dependence. Fixed non-int issue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse m",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/changelog.html:2167,optimiz,optimization,2167,docs/4.2/changelog.html,https://qutip.org,https://qutip.org/docs/4.2/changelog.html,1,['optimiz'],['optimization']
Performance,"; Cython version of the QobjEvo. dummy_cte : bool; is self.cte a dummy Qobj. const : bool; Indicates if quantum object is Constant. type : int; information about the type of coefficient; ""string"", ""func"", ""array"",; ""spline"", ""mixed_callable"", ""mixed_compilable"". num_obj : int; number of Qobj in the QobjEvo : len(ops) + (1 if not dummy_cte). Methods; -------; copy() :; Create copy of Qobj. arguments(new_args):; Update the args of the object. Math:; +/- QobjEvo, Qobj, scalar:; Addition is possible between QobjEvo and with Qobj or scalar; -:; Negation operator; * Qobj, scalar:; Product is possible with Qobj or scalar; / scalar:; It is possible to divide by scalar only; conj(); Return the conjugate of quantum object. dag(); Return the adjoint (dagger) of quantum object. trans(); Return the transpose of quantum object. norm(); Return self.dag() * self.; Only possible if num_obj == 1. permute(order); Returns composite qobj with indices reordered. ptrace(sel); Returns quantum object for selected dimensions after performing; partial trace. apply(f, *args, **kw_args); Apply the function f to every Qobj. f(Qobj) -> Qobj; Return a modified QobjEvo and let the original one untouched. apply_decorator(decorator, *args, str_mod=None,; inplace_np=False, **kw_args):; Apply the decorator to each function of the ops.; The *args and **kw_args are passed to the decorator.; new_coeff_function = decorator(coeff_function, *args, **kw_args); str_mod : list of 2 elements; replace the string : str_mod[0] + original_string + str_mod[1]; *exemple: str_mod = [""exp("","")""]; inplace_np:; Change the numpy array instead of applying the decorator to the; function reading the array. Some decorators create incorrect array.; Transformations f'(t) = f(g(t)) create a missmatch between the; array and the associated time list. tidyup(atol=1e-12); Removes small elements from quantum object. compress():; Merge ops which are based on the same quantum object and coeff type. compile(code=False, matched=False, dens",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobjevo.html:9809,perform,performing,9809,docs/4.4/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobjevo.html,1,['perform'],['performing']
Performance,"; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; # QuTiP Graphics; qutip_graphics=""YES""; # use auto tidyup; auto_tidyup=True; # detect hermiticity; auto_herm=True; # use auto tidyup absolute tolerance; auto_tidyup_atol=1e-12; # number of cpus; num_cpus=4; # debug; debug=False. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-settings.html:2409,load,loaded,2409,docs/4.0.2/guide/guide-settings.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-settings.html,1,['load'],['loaded']
Performance,"; Dual channel of quantum object representing a CP map.; eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000); Returns eigenenergies (eigenvalues) of a quantum object.; eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000); Returns eigenenergies and eigenstates of quantum object.; expm(); Matrix exponential of quantum object.; full(order='C'); Returns dense array of quantum object `data` attribute.; groundstate(sparse=False, tol=0, maxiter=100000); Returns eigenvalue and eigenket for the groundstate of a quantum; object.; inv(); Return a Qobj corresponding to the matrix inverse of the operator.; matrix_element(bra, ket); Returns the matrix element of operator between `bra` and `ket` vectors.; norm(norm='tr', sparse=False, tol=0, maxiter=100000); Returns norm of a ket or an operator.; permute(order); Returns composite qobj with indices reordered.; proj(); Computes the projector for a ket or bra vector.; ptrace(sel); Returns quantum object for selected dimensions after performing; partial trace.; sinm(); Sine of quantum object.; sqrtm(); Matrix square root of quantum object.; tidyup(atol=1e-12); Removes small elements from quantum object.; tr(); Trace of quantum object.; trans(); Transpose of quantum object.; transform(inpt, inverse=False); Performs a basis transformation defined by `inpt` matrix.; trunc_neg(method='clip'); Removes negative eigenvalues and returns a new Qobj that is; a valid density operator.; unit(norm='tr', sparse=False, tol=0, maxiter=100000); Returns normalized quantum object. """"""; __array_priority__ = 100 # sets Qobj priority above numpy arrays. def __init__(self, inpt=None, dims=[[], []], shape=[],; type=None, isherm=None, copy=True,; fast=False, superrep=None, isunitary=None):; """"""; Qobj constructor.; """"""; self._isherm = isherm; self._type = type; self.superrep = superrep; self._isunitary = isunitary. if fast == 'mc':; # fast Qobj construction for use in mcsolve with ket output; self._data = inpt; self.dim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobj.html:7407,perform,performing,7407,docs/4.5/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobj.html,1,['perform'],['performing']
Performance,"; Dual channel of quantum object representing a CP map.; eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000); Returns eigenenergies (eigenvalues) of a quantum object.; eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000); Returns eigenenergies and eigenstates of quantum object.; expm(); Matrix exponential of quantum object.; full(order='C'); Returns dense array of quantum object `data` attribute.; groundstate(sparse=False, tol=0, maxiter=100000); Returns eigenvalue and eigenket for the groundstate of a quantum; object.; inv(); Return a Qobj corresponding to the matrix inverse of the operator.; matrix_element(bra, ket); Returns the matrix element of operator between `bra` and `ket` vectors.; norm(norm='tr', sparse=False, tol=0, maxiter=100000); Returns norm of a ket or an operator.; permute(order); Returns composite qobj with indices reordered.; proj(); Computes the projector for a ket or bra vector.; ptrace(sel); Returns quantum object for selected dimensions after performing; partial trace.; sinm(); Sine of quantum object.; sqrtm(); Matrix square root of quantum object.; tidyup(atol=1e-12); Removes small elements from quantum object.; tr(); Trace of quantum object.; trans(); Transpose of quantum object.; transform(inpt, inverse=False); Performs a basis transformation defined by `inpt` matrix.; trunc_neg(method='clip'); Removes negative eigenvalues and returns a new Qobj that is; a valid density operator.; unit(norm='tr', sparse=False, tol=0, maxiter=100000); Returns normalized quantum object. """"""; __array_priority__ = 100 # sets Qobj priority above numpy arrays; # Disable ufuncs from acting directly on Qobj. This is necessary because we; # define __array__.; __array_ufunc__ = None. def __init__(self, inpt=None, dims=None, shape=None,; type=None, isherm=None, copy=True,; fast=False, superrep=None, isunitary=None):; """"""; Qobj constructor.; """"""; self._isherm = isherm; self._type = type; self.superrep = superrep; self._isunitary",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobj.html:7434,perform,performing,7434,docs/4.6/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html,2,['perform'],['performing']
Performance,"; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Steady State Solutions for Arbitrary Systems; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide.html:3275,load,loading,3275,docs/3.1.0/guide/guide.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide.html,2,['load'],['loading']
Performance,"; In [3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [5]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True. In [6]: a = destroy(10). In [7]: expect(a.dag() * a, rho_ss_loaded); Out[7]: 0.9902248289345061. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [8]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [9]: psi0 = rand_ket(10). In [10]: times = np.linspace(0, 10, 10). In [11]: dm_list = mesolve(H, psi0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: expect(a.dag() * a, dm_list_loaded.states); Out[15]: ; array([ 4.29179401, 3.37589742, 2.75659972, 2.30562634, 1.97257341,; 1.72505191, 1.54045945, 1.40251047, 1.2992826 , 1.22196967]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store take",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-saving.html:3382,load,loaded,3382,docs/4.0.2/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-saving.html,1,['load'],['loaded']
Performance,"; In [3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [5]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True. In [6]: a = destroy(10). In [7]: expect(a.dag() * a, rho_ss_loaded); Out[7]: 0.9902248289345064. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [8]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [9]: psi0 = rand_ket(10). In [10]: times = np.linspace(0, 10, 10). In [11]: dm_list = mesolve(H, psi0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: expect(a.dag() * a, dm_list_loaded.states); Out[15]: ; array([ 4.21111367, 3.243081 , 2.64337648, 2.2162089 , 1.90369673,; 1.67257851, 1.50071221, 1.37250326, 1.27667537, 1.20496022]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/guide-saving.html:3382,load,loaded,3382,docs/4.1/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.1/guide/guide-saving.html,1,['load'],['loaded']
Performance,"; In [3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [5]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = [10, 10], type = oper, isHerm = True. In [6]: a = destroy(10). In [7]: expect(a.dag() * a, rho_ss_loaded); Out[7]: 0.9902248289345064. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [8]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [9]: psi0 = rand_ket(10). In [10]: times = np.linspace(0, 10, 10). In [11]: dm_list = mesolve(H, psi0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: expect(a.dag() * a, dm_list_loaded.states); Out[15]: ; array([ 5.47236604, 4.25321934, 3.40221147, 2.78459863, 2.32939541,; 1.99152365, 1.739766 , 1.55173281, 1.41108289, 1.30577149]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-saving.html:4182,load,loaded,4182,docs/3.1.0/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-saving.html,1,['load'],['loaded']
Performance,"; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Parallel computation. Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; >>> def func1(x): return x, x**2, x**3. >>> a, b, c = parfor(func1, range(10)). >>> print(a); [0 1 2 3 4 5 6 7 8 9]. >>> print(b); [ 0 1 4 9 16 25 36 49 64 81]. >>> print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; >>> result = parallel_map(func1, range(10)). >>> result_array = np.array(result). >>> print(result_array[:, 0]) # == a; [0 1 2 3 4 5 6 7 8 9]. >>> print(result_array[:, 1]) # == b; [ 0 1 4 9 16 25 36 49 64 81]. >>> print(result_array[:, 2]) # == c; [ 0 1 8 27 64 125 216 343 512 729]. Note that the return values are arranged differently for the qutip.parallel.parallel_map and the qutip.parallel.parfor functions, as illustrated below. In particular, the return value of qutip.parallel.parallel_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-parfor.html:1418,perform,performed,1418,docs/4.7/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-parfor.html,1,['perform'],['performed']
Performance,"; This is usually overridden in the subclass. dump_summaryboolIf True a summary is recorded each time a new item is added to the; the dump.; Default is True. summary_sepstrdelimiter for the summary file.; default is a space. data_sepstrdelimiter for the data files (arrays saved to file).; default is a space. summary_filestrFile path for summary file.; Automatically generated. Can be set specifically. create_dump_dir()[source]¶; Checks dump directory exists, creates it if not. property level¶; The level of data dumping that will occur. SUMMARYA summary will be recorded. FULLAll possible dumping. CUSTOMSome customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped. class OptimDump(optim, level='SUMMARY')[source]¶; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes. dump_summaryboolWhen True summary items are appended to the iter_summary. iter_summarylist of optimizer.OptimIterSummarySummary at each iteration. dump_fid_errboolWhen True values are appended to the fid_err_log. fid_err_loglist of floatFidelity error at each call of the fid_err_func. dump_grad_normboolWhen True values are appended to the fid_err_log. grad_norm_loglist of floatGradient norm at each call of the grad_norm_log. dump_gradboolWhen True values are appended to the grad_log. grad_loglist of ndarrayGradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. property dump_all¶; True if everything (ignoring the summary) is to be dumped. property dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out to file(s). Parameters",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:244261,optimiz,optimizer,244261,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,1,['optimiz'],['optimizer']
Performance,"; Uses the Q.expm() method. """"""; if self.dims[0][0] == self.dims[1][0]:; return 0.5 * ((1j * self).expm() + (-1j * self).expm()); else:; raise TypeError('Invalid operand for matrix square root'); ; ; [docs] def sinm(self):; """"""Sine of a quantum operator. Operator must be square. Returns; -------; oper : qobj; Matrix sine of operator. Raises; ------; TypeError; Quantum object is not square. Notes; -----; Uses the Q.expm() method. """"""; if self.dims[0][0] == self.dims[1][0]:; return -0.5j * ((1j * self).expm() - (-1j * self).expm()); else:; raise TypeError('Invalid operand for matrix square root'); ; ; ; [docs] def unit(self, norm=None, sparse=False, tol=0, maxiter=100000):; """"""Operator or state normalized to unity. Uses norm from Qobj.norm(). Parameters; ----------; norm : str; Requested norm for states / operators.; sparse : bool; Use sparse eigensolver for trace norm. Does not affect other norms.; tol : float; Tolerance used by sparse eigensolver.; maxiter : int; Number of maximum iterations performed by sparse eigensolver. Returns; -------; oper : qobj; Normalized quantum object. """"""; out = self / self.norm(norm=norm, sparse=sparse,; tol=tol, maxiter=maxiter); if settings.auto_tidyup:; return out.tidyup(); else:; return out. [docs] def ptrace(self, sel):; """"""Partial trace of the quantum object. Parameters; ----------; sel : int/list; An ``int`` or ``list`` of components to keep after partial trace. Returns; -------; oper : qobj; Quantum object representing partial trace with selected components; remaining. Notes; -----; This function is identical to the :func:`qutip.qobj.ptrace` function; that has been deprecated. """"""; q = Qobj(); q.data, q.dims, _ = _ptrace(self, sel); return q.tidyup() if settings.auto_tidyup else q. [docs] def permute(self, order):; """"""Permutes a composite quantum object. Parameters; ----------; order : list/array; List specifying new tensor order. Returns; -------; P : qobj; Permuted quantum object. """"""; q = Qobj(); q.data, q.dims = _permute(se",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:30437,perform,performed,30437,docs/4.0.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html,1,['perform'],['performed']
Performance,"; [[ 1.]]; Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[ 2.]]; Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[ 3.]]; Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[ 4.]]]. In [15]: print(c); ['' 'a' 'aa' 'aaa' 'aaaa']. Note; New in QuTiP 3. One can also define functions with multiple input arguments and even keyword arguments:; In [16]: def sum_diff(x , y, z=0): return x + y, x - y, z. In [17]: parfor(sum_diff, [1, 2, 3], [4, 5, 6], z=5); Out[17]: [array([5, 7, 9]), array([-3, -3, -3]), array([5, 5, 5])]. Note that the keyword arguments can be anything you like, but the keyword values are not iterated over. The keyword argument num_cpus is reserved as it sets the number of CPU’s used by parfor. By default, this value is set to the total number of physical processors on your system. You can change this number to a lower value, however setting it higher than the number of CPU’s will cause a drop in performance.; Parfor is also useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-Based parfor¶. Note; New in QuTiP 3. When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parfor. The advantage of this parfor implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Parallel picloud Computations¶. Note; New in QuTiP 3. New to QuTiP version 3 is the option to run computations in parallel on the cloud computing platform provided by PiCloud. You must have their software installed on your machine, and an active account, for this function to work. Note that, at present, the picloud software is only avail",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-parfor.html:4230,perform,performance,4230,docs/3.0.0/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-parfor.html,2,['perform'],['performance']
Performance,"; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. optim_method : string; A ``scipy.optimize.minimize`` method that will be used to optimise the; pulse for minimum fidelity error Note that ``FMIN``, ``FMIN_BFGS`` &; ``FMIN_L_BFGS_B`` will all result in calling these specific; scipy.optimize methods Note the ``LBFGSB`` is equivalent to; ``FMIN_L_BFGS_B`` for backwards compatibility reasons. Supplying; ``DEF`` will given algorithm-dependent result:. - GRAPE - Default ``optim_method`` is FMIN_L_BFGS_B; - CRAB - Default ``optim_method`` is FMIN. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~qutip.control.optimizer.Optimizer` object or; the ``termination_conditions`` matching the key that attribute.; Otherwise, and in some case also, they are assumed to be; method_options for the ``scipy.optimize.minimize`` method. optim_alg : string; Deprecated. Use ``optim_method``. max_metric_corr : integer; Deprecated. Use ``method_params`` instead. accuracy_factor : float; Deprecated. Use ``method_params`` instead. phase_option : string; Determines how global phase is treated in fidelity calculations; (``fid_type='UNIT'`` only). Options:. - PSU - global phase ignored; - SU - global phase included. dyn_params : dict; Parameters for the :obj:`~qutip.control.dynamics.Dynamics` object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_params : dict; Parameters for the :obj:`~qutip.control.propcomp.PropagatorComputer`; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. fid_params : dict; Parameters for the :obj:`~qutip.control.fidcomp.FidelityComputer`; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is cr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:22341,optimiz,optimize,22341,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimize']
Performance,"; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. optim_method : string; A ``scipy.optimize.minimize`` method that will be used to optimise the; pulse for minimum fidelity error. Note that ``FMIN``, ``FMIN_BFGS`` &; ``FMIN_L_BFGS_B`` will all result in calling these specific; ``scipy.optimize methods``. Note the ``LBFGSB`` is equivalent to; ``FMIN_L_BFGS_B`` for backwards compatibility reasons. Supplying DEF; will given alg dependent result:. - GRAPE - Default ``optim_method`` is ``FMIN_L_BFGS_B``; - CRAB - Default ``optim_method`` is ``FMIN``. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~qutip.control.optimizer.Optimizer` object or; the termination_conditions matching the key that attribute.; Otherwise, and in some case also, they are assumed to be method_options; for the ``scipy.optimize.minimize`` method. optim_alg : string; Deprecated. Use ``optim_method``. max_metric_corr : integer; Deprecated. Use ``method_params`` instead. accuracy_factor : float; Deprecated. Use ``method_params`` instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe the dynamics.; Options are ``UNIT``, ``GEN_MAT``, ``SYMPL``; (see :obj:`~qutip.control.dynamics.Dynamics` classes for details). dyn_params : dict; Parameters for the :obj:`~qutip.control.dynamics.Dynamics` object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the propagators and; propagator gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT. DEF will use the default for the specific; ``dyn_type`` (see :obj:`~qutip.control.propcomp.PropagatorComputer`; classes for details). prop_params : dict; Parameters for the :obj:`~qutip.control.propcomp.Prop",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:8356,optimiz,optimize,8356,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimize']
Performance,"; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators. PulseGenThere are many subclasses of pulse generators that generate different types of pulses as the init",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-control.html:14601,load,loadparams,14601,docs/4.7/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html,1,['load'],['loadparams']
Performance,"; integer – The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:69398,optimiz,optimize,69398,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['optimiz'],['optimize']
Performance,"; new_type = 'ket'; ekets = np.empty((len(evecs),), dtype=object); ekets[:] = [Qobj(vec, dims=new_dims, type=new_type) for vec in evecs]; norms = np.array([ket.norm() for ket in ekets]); if phase_fix is None:; phase = np.array([1] * len(ekets)); else:; phase = np.array([np.abs(ket[phase_fix, 0]) / ket[phase_fix, 0]; if ket[phase_fix, 0] else 1; for ket in ekets]); return evals, ekets / norms * phase. [docs] def eigenenergies(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; sort : str; Sort eigenvalues 'low' to high, or 'high' to low.; eigvals : int; Number of requested eigenvalues. Default is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobj.html:45050,perform,performed,45050,docs/4.6/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html,2,['perform'],['performed']
Performance,"; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License.; “Distribute” means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership.; “Licensor” means the individual, individuals, entity or entities that; offer(s) the Work under the terms of this License.; “Original Author” means, in the case of a literary or artistic work, the; individual, individuals, entity or entities who created the Work or if no; individual or entity can be identified, the publisher; and in addition; (i) in the case of a performance the actors, singers, musicians, dancers,; an",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/copyright-1.html:2485,perform,performances,2485,docs/4.7/copyright-1.html,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html,2,['perform'],['performances']
Performance,"; self._summary_file_path = os.path.expanduser(value); else:; self._summary_file_path = os.path.join(self.dump_dir, value). [docs]class OptimDump(Dump):; """"""; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes; ----------; dump_summary : bool; When True summary items are appended to the iter_summary. iter_summary : list of :class:`optimizer.OptimIterSummary`; Summary at each iteration. dump_fid_err : bool; When True values are appended to the fid_err_log. fid_err_log : list of float; Fidelity error at each call of the fid_err_func. dump_grad_norm : bool; When True values are appended to the fid_err_log. grad_norm_log : list of float; Gradient norm at each call of the grad_norm_log. dump_grad : bool; When True values are appended to the grad_log. grad_log : list of ndarray; Gradients at each call of the fid_grad_func. """"""; def __init__(self, optim, level='SUMMARY'):; from qutip.control.optimizer import Optimizer; if not isinstance(optim, Optimizer):; raise TypeError(""Must instantiate with {} type"".format(; Optimizer)); self.parent = optim; self._level = level; self.reset(). def reset(self):; Dump.reset(self); self._apply_level(); self.iter_summary = []; self.fid_err_log = []; self.grad_norm_log = []; self.grad_log = []; self._fname_base = 'optimdump'; self._fid_err_file = None; self._grad_norm_file = None. def clear(self):; del self.iter_summary[:]; self.fid_err_log[:]; self.grad_norm_log[:]; self.grad_log[:]. @property; def dump_any(self):; """"""True if anything other than the summary is to be dumped""""""; if (self.dump_fid_err or self.dump_grad_norm or self.dump_grad):; return True; else:; return False. @property; def dump_all(self):; """"""True if everything (ignoring the summary) is to be dumped""""""; if (self.dump_fid_err and self.dump_grad_norm and self.dump_grad):; return True; else:; return False. def _apply_level(self, level=None):; if level is None:; level = self._level. if not _is_string(level):; raise ValueError(""Dump l",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dump.html:8029,optimiz,optimizer,8029,docs/4.1/modules/qutip/control/dump.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dump.html,7,['optimiz'],['optimizer']
Performance,"; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master eqautions with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructued.; QuTiP is now using continous integration tests (TravisCI). Version 2.2.0 (March 01, 2013):¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose function.; Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis.; The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form.; Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo.; A module of tools for using QuTiP in IPython notebooks.; Increased performance of the steady state solver.; New Wigner colormap for highlighting negative values.; More graph styles to the visualizati",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/changelog.html:6049,perform,performance,6049,docs/3.0.0/changelog.html,https://qutip.org,https://qutip.org/docs/3.0.0/changelog.html,2,['perform'],['performance']
Performance,"; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013):¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose function.; Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis.; The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form.; Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo.; A module of tools for using QuTiP in IPython notebooks.; Increased performance of the steady state solver.; New Wigner colormap for highlighting negative values.; More graph styles to the visualiza",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/changelog.html:8612,perform,performance,8612,docs/3.1.0/changelog.html,https://qutip.org,https://qutip.org/docs/3.1.0/changelog.html,7,['perform'],['performance']
Performance,"; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013)¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose function.; Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis.; The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form.; Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo.; A module of tools for using QuTiP in IPython notebooks.; Increased performance of the steady state solver.; New Wigner colormap for highlighting negative values.; More graph styles to the visualizat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:40368,perform,performance,40368,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['perform'],['performance']
Performance,"; str; Representation used if type is ‘super’. One of ‘super’; (Liouville form) or ‘choi’ (Choi matrix with tr = dimension). Methods. conj(); Conjugate of quantum object. dag(); Adjoint (dagger) of quantum object. eigenenergies(sparse=False, sort=’low’, eigvals=0, tol=0, maxiter=100000); Returns eigenenergies (eigenvalues) of a quantum object. eigenstates(sparse=False, sort=’low’, eigvals=0, tol=0, maxiter=100000); Returns eigenenergies and eigenstates of quantum object. expm(); Matrix exponential of quantum object. full(); Returns dense array of quantum object data attribute. groundstate(sparse=False,tol=0,maxiter=100000); Returns eigenvalue and eigenket for the groundstate of a quantum; object. matrix_element(bra, ket); Returns the matrix element of operator between bra and ket vectors. norm(norm=’tr’, sparse=False, tol=0, maxiter=100000); Returns norm of a ket or an operator. permute(order); Returns composite qobj with indices reordered. ptrace(sel); Returns quantum object for selected dimensions after performing; partial trace. sqrtm(); Matrix square root of quantum object. tidyup(atol=1e-12); Removes small elements from quantum object. tr(); Trace of quantum object. trans(); Transpose of quantum object. transform(inpt, inverse=False); Performs a basis transformation defined by inpt matrix. unit(norm=’tr’, sparse=False, tol=0, maxiter=100000); Returns normalized quantum object. checkherm()¶; Check if the quantum object is hermitian. Returns:isherm: bool :. Returns the new value of isherm property. conj()¶; Conjugate operator of quantum object. dag()¶; Adjoint operator of quantum object. diag()¶; Diagonal elements of quantum object. Returns:diags: array :. Returns array of real values if operators is Hermitian,; otherwise complex values are returned. eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)¶; Eigenenergies of a quantum object.; Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters:sparse : bool. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/classes.html:3596,perform,performing,3596,docs/3.0.0/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html,2,['perform'],['performing']
Performance,"; that the right version of the MinGW compiler is used if more than one; is installed (not uncommon under Windows, since many packages are; distributed and installed with their own version of all dependencies). Optional Installation Options¶. UMFPACK Linear Solver¶; As of SciPy 0.14+, the umfpack linear solver routines for solving large-scale sparse linear systems have been replaced due to licensing restrictions. The default method for all sparse linear problems is now the SuperLU library. However, scipy still includes the ability to call the umfpack library via the scikits.umfpack module. In our experience, the umfpack solver is 2-5x faster than the SuperLU routines, which is a very noticeable performance increase when used for solving steady state solutions. We have an updated scikits.umfpack module available at http://github.com/nonhermitian/umfpack that can be installed to have SciPy find and use the umfpack library. Optimized BLAS Libraries¶; QuTiP is designed to take advantage of some of the optimized BLAS libraries that are available for NumPy. At present, this includes the OPENBLAS and MKL libraries. If NumPy is built against these libraries, then QuTiP will take advantage of the performance gained by using these optimized tools. As these libraries are multi-threaded, you can change the number of threads used in these packages by adding:; >>> import os; >>> os.environ['OPENBLAS_NUM_THREADS'] = '4'; >>> os.environ['MKL_NUM_THREADS'] = '4'. at the top of your Python script files, or iPython notebooks, and then loading the QuTiP framework. If these commands are not present, then QuTiP automatically sets the number of threads to one. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; >>> import qutip.testing as qt; >>> qt",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/installation.html:10756,optimiz,optimized,10756,docs/3.0.1/installation.html,https://qutip.org,https://qutip.org/docs/3.0.1/installation.html,2,['optimiz'],['optimized']
Performance,"= 'super':; # Type is not super, i.e. dims not explicitly passed, but oper-like; # shape.; if dims is None and self.shape[0] == self.shape[1]:; sub_shape = np.sqrt(self.shape[0]); # check if root of shape is int; if (sub_shape % 1) != 0:; raise Exception('Invalid shape for a super operator.'); else:; sub_shape = int(sub_shape); self.dims = [[[sub_shape], [sub_shape]]]*2. if superrep:; self.superrep = superrep; else:; if self.type == 'super' and self.superrep is None:; self.superrep = 'super'. # While the obvious check would be != that would fail valid; # use cases such as enr_fock and other enr_ functions.; # This does leave open the possibility of data still being; # misused such as Qobj(complex[n**2][1], dims = [[n],[n]]); if (self._data.shape[0] > np.prod(np.hstack(self.dims[0])) or; self._data.shape[1] > np.prod(np.hstack(self.dims[1]))) and \; self.type != 'super':. raise ValueError(f""Qobj has smaller dims {self.dims} "" +; f""than underlying shape {self._data.shape}""). # clear type cache; self._type = None. [docs] def copy(self):; """"""Create identical copy""""""; return Qobj(inpt=self). def get_data(self):; return self._data. # Here we perfrom a check of the csr matrix type during setting of Q.data; def set_data(self, data):; if not isinstance(data, fast_csr_matrix):; raise TypeError('Qobj data must be in fast_csr format.'); else:; self._data = data; data = property(get_data, set_data). def __add__(self, other):; """"""; ADDITION with Qobj on LEFT [ ex. Qobj+4 ]; """"""; self._isunitary = None. if isinstance(other, eseries):; return other.__radd__(self). if not isinstance(other, Qobj):; if isinstance(other, (int, float, complex, np.integer, np.floating,; np.complexfloating, np.ndarray, list, tuple)) \; or sp.issparse(other):; other = Qobj(other); else:; return NotImplemented. if np.prod(other.shape) == 1 and np.prod(self.shape) != 1:; # case for scalar quantum object; dat = other.data[0, 0]; if dat == 0:; return self. out = Qobj(). if self.type in ['oper', 'super']:; out.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobj.html:12144,cache,cache,12144,docs/4.6/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html,1,['cache'],['cache']
Performance,"= LinearSpinChain(2); processor.load_circuit(qc); fig, axis = processor.plot_pulses(); fig.show(). DispersiveCavityQED; Same as above, DispersiveCavityQED is a simulator based on Cavity Quantum Electrodynamics. The workflow is similar to the one for the spin chain, except that the component systems are a multi-level cavity and a qubits system. The control Hamiltonians are the single-qubit rotation together with the qubits-cavity interaction \(a^{\dagger} \sigma^{-} + a \sigma^{+}\). The device parameters including the cavity frequency, qubits frequency, detuning and interaction strength etc. Note; The run_state method of DispersiveCavityQED; returns the full simulation result of the solver,; hence including the cavity.; To obtain the circuit result, one needs to first trace out the cavity state. OptPulseProcessor; The OptPulseProcessor uses the function in optimize_pulse_unitary in the optimal control module to find the control pulses. The Hamiltonian includes a drift part and a control part and only the control part will be optimized. The unitary evolution follows. \[U(\Delta t)=\exp(\rm{i} \cdot \Delta t [H_d + \sum_j u_j H_j] )\]; To let it find the optimal pulses, we need to give the parameters for optimize_pulse_unitary as keyword arguments to load_circuit. Usually, the minimal requirements are the evolution time evo_time and the number of time slices num_tslots for each gate. Other parameters can also be given in the keyword arguments. For available choices, see optimize_pulse_unitary. It is also possible to specify different parameters for different gates, as shown in the following example:; from qutip.qip.device import OptPulseProcessor; from qutip.operators import sigmaz, sigmax, sigmay; from qutip.tensor import tensor. # Same parameter for all the gates; qc = QubitCircuit(N=1); qc.add_gate(""SNOT"", 0). num_tslots = 10; evo_time = 10; processor = OptPulseProcessor(N=1, drift=sigmaz()); processor.add_control(sigmax()); # num_tslots and evo_time are two keywor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/qip/qip-processor.html:8164,optimiz,optimized,8164,docs/4.7/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html,1,['optimiz'],['optimized']
Performance,"= self.dims[1][0]:; return 0.5 * ((1j * self).expm() + (-1j * self).expm()); else:; raise TypeError('Invalid operand for matrix square root'). [docs] def sinm(self):; """"""Sine of a quantum operator. Operator must be square. Returns; -------; oper : qobj; Matrix sine of operator. Raises; ------; TypeError; Quantum object is not square. Notes; -----; Uses the Q.expm() method. """"""; if self.dims[0][0] == self.dims[1][0]:; return -0.5j * ((1j * self).expm() - (-1j * self).expm()); else:; raise TypeError('Invalid operand for matrix square root'). [docs] def unit(self, inplace=False,; norm=None, sparse=False,; tol=0, maxiter=100000):; """"""Operator or state normalized to unity. Uses norm from Qobj.norm(). Parameters; ----------; inplace : bool; Do an in-place normalization; norm : str; Requested norm for states / operators.; sparse : bool; Use sparse eigensolver for trace norm. Does not affect other norms.; tol : float; Tolerance used by sparse eigensolver.; maxiter : int; Number of maximum iterations performed by sparse eigensolver. Returns; -------; oper : qobj; Normalized quantum object if not in-place,; else None. """"""; if inplace:; nrm = self.norm(norm=norm, sparse=sparse,; tol=tol, maxiter=maxiter). self.data /= nrm; elif not inplace:; out = self / self.norm(norm=norm, sparse=sparse,; tol=tol, maxiter=maxiter); if settings.auto_tidyup:; return out.tidyup(); else:; return out; else:; raise Exception('inplace kwarg must be bool.'). [docs] def ptrace(self, sel):; """"""Partial trace of the quantum object. Parameters; ----------; sel : int/list; An ``int`` or ``list`` of components to keep after partial trace. Returns; -------; oper : qobj; Quantum object representing partial trace with selected components; remaining. Notes; -----; This function is identical to the :func:`qutip.qobj.ptrace` function; that has been deprecated. """"""; q = Qobj(); q.data, q.dims, _ = _ptrace(self, sel); return q.tidyup() if settings.auto_tidyup else q. [docs] def permute(self, order):; """"""Permutes a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/qobj.html:32074,perform,performed,32074,docs/4.3/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/qobj.html,1,['perform'],['performed']
Performance,"= {}; for key in params:; val = params[key]; if hasattr(self, key):; setattr(self, key, val); if hasattr(self.termination_conditions, key):; setattr(self.termination_conditions, key, val); else:; unused_params[key] = val. if len(unused_params) > 0:; if not isinstance(self.method_options, dict):; self.method_options = unused_params; else:; self.method_options.update(unused_params). def _build_bounds_list(self):; cfg = self.config; dyn = self.dynamics; n_ctrls = dyn.num_ctrls; self.bounds = []; for t in range(dyn.num_tslots):; for c in range(n_ctrls):; if isinstance(self.amp_lbound, list):; lb = self.amp_lbound[c]; else:; lb = self.amp_lbound; if isinstance(self.amp_ubound, list):; ub = self.amp_ubound[c]; else:; ub = self.amp_ubound. if not lb is None and np.isinf(lb):; lb = None; if not ub is None and np.isinf(ub):; ub = None. self.bounds.append((lb, ub)). [docs] def run_optimization(self, term_conds=None):; """"""; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below). The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient. The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:16975,optimiz,optimize,16975,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,8,['optimiz'],['optimize']
Performance,"== '':; # None given, use the default for the Dynamics; pass; elif fid_type_up == 'TDAPPROX':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type_up == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wa",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:65049,optimiz,optimizer,65049,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,5,['optimiz'],['optimizer']
Performance,">> show(). Data for expectation values extracted from the result Result object. State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation data can be stored and later retrieved. The qutip.fileio.qsave and qutip.fileio.qload functions are designed for this task. To begin, let us save the data object from the previous section into a file called “cavity+qubit-data” in the current working directory by calling:; >>> qsave(result, 'cavity+qubit-data'). All of the data results are then stored in a single file of the same name with a ”.qu” extension. Therefore, everything needed to later this data is stored in a single file. Loading the file is just as easy as saving:; >>> stored_result = qload('cavity+qubit-data'); Loaded Result object:; Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. where stored_result is the new name of the Result object. We can then extract the data and plot in the same manner as before:; expt0 = stored_result.expect[0]; expt1 = stored_result.expect[1]; times = stored_result.times; plot(times, expt0, times, expt1); show(). Data for expectation values from the stored_result object loaded from the result object stored with qutip.fileio.qsave. Also see Saving QuTiP Objects and Data Sets for more information on saving quantum objects, as well as arrays for use in other programs. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-data.html:6721,load,loaded,6721,docs/3.0.1/guide/dynamics/dynamics-data.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-data.html,1,['load'],['loaded']
Performance,">> show(). Data for expectation values extracted from the result Result object. State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation data can be stored and later retrieved. The qutip.fileio.qsave and qutip.fileio.qload functions are designed for this task. To begin, let us save the data object from the previous section into a file called “cavity+qubit-data” in the current working directory by calling:; >>> qsave(result, 'cavity+qubit-data'). All of the data results are then stored in a single file of the same name with a ”.qu” extension. Therefore, everything needed to later this data is stored in a single file. Loading the file is just as easy as saving:; >>> stored_result = qload('cavity+qubit-data'); Loaded Result object:; Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. where stored_result is the new name of the Result object. We can then extract the data and plot in the same manner as before:; expt0 = stored_result.expect[0]; expt1 = stored_result.expect[1]; times = stored_result.times; plot(times, expt0, times, expt1); show(). Data for expectation values from the stored_result object loaded from the result object stored with qutip.fileio.qsave. Also see Saving QuTiP Objects and Data Sets for more information on saving quantum objects, as well as arrays for use in other programs. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-data.html:6659,load,loaded,6659,docs/3.0.0/guide/dynamics/dynamics-data.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-data.html,1,['load'],['loaded']
Performance,"@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes containing termination conditions for the control pulse optimisation; i.e. attributes that will be checked during the optimisation, that; will determine if the algorithm has completed its task / exceeded limits; """""". [docs]class TerminationConditions(object):; """"""; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes; ----------; fid_err_targ : float; Target fidelity error. fid_goal : float; goal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_time : float; # maximum time for optimisation (seconds). min_gradient_norm : float; Minimum normalised gradient after which optimisation will terminate. max_iterations : integer; Maximum iterations of the optimisation algorithm. max_fid_func_calls : integer; Maximum number of calls to the fidelity function during; the optimisation algorithm; ; accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user; """"""; def __init__(self):; self.reset(). def reset(self):; self.fid_err_targ = 1e-5; self.fid_goal = None; self.max_wall_time = 60*60.0; self.min_gradient_norm = 1e-5; self.max_iterations = 1e10; self.max_fid_func_calls = 1e10. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/control/termcond.html:3456,optimiz,optimize,3456,docs/4.0.2/modules/qutip/control/termcond.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/termcond.html,1,['optimiz'],['optimize']
Performance,"@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes containing termination conditions for the control pulse optimisation; i.e. attributes that will be checked during the optimisation, that; will determine if the algorithm has completed its task / exceeded limits; """""". [docs]class TerminationConditions(object):; """"""; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes; ----------; fid_err_targ : float; Target fidelity error. fid_goal : float; goal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_time : float; # maximum time for optimisation (seconds). min_gradient_norm : float; Minimum normalised gradient after which optimisation will terminate. max_iterations : integer; Maximum iterations of the optimisation algorithm. max_fid_func_calls : integer; Maximum number of calls to the fidelity function during; the optimisation algorithm; ; accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user; """"""; def __init__(self):; self.reset(). def reset(self):; self.fid_err_targ = 1e-5; self.fid_goal = None; self.max_wall_time = 60*60.0; self.min_gradient_norm = 1e-5; self.max_iterations = 1e10; self.max_fid_func_calls = 1e10. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/termcond.html:3456,optimiz,optimize,3456,docs/4.2/modules/qutip/control/termcond.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/termcond.html,1,['optimiz'],['optimize']
Performance,"@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes containing termination conditions for the control pulse optimisation; i.e. attributes that will be checked during the optimisation, that; will determine if the algorithm has completed its task / exceeded limits; """""". [docs]class TerminationConditions(object):; """"""; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes; ----------; fid_err_targ : float; Target fidelity error. fid_goal : float; goal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_time : float; # maximum time for optimisation (seconds). min_gradient_norm : float; Minimum normalised gradient after which optimisation will terminate. max_iterations : integer; Maximum iterations of the optimisation algorithm. max_fid_func_calls : integer; Maximum number of calls to the fidelity function during; the optimisation algorithm; ; accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user; """"""; def __init__(self):; self.reset(). def reset(self):; self.fid_err_targ = 1e-5; self.fid_goal = None; self.max_wall_time = 60*60.0; self.min_gradient_norm = 1e-5; self.max_iterations = 1e10; self.max_fid_func_calls = 1e10. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/termcond.html:3456,optimiz,optimize,3456,docs/4.1/modules/qutip/control/termcond.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/termcond.html,1,['optimiz'],['optimize']
Performance,"ARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #; # Significant parts of this code were contributed by Denis Vasilyev.; #; ###############################################################################; """"""; This module contains functions for solving stochastic schrodinger and master; equations. The API should not be considered stable, and is subject to change; when we work more on optimizing this module for performance and features.; """""". __all__ = ['ssesolve', 'ssepdpsolve', 'smesolve', 'smepdpsolve']. import numpy as np; import scipy.sparse as sp; from scipy.linalg.blas import get_blas_funcs; try:; norm = get_blas_funcs(""znrm2"", dtype=np.float64); except:; from scipy.linalg import norm. from numpy.random import RandomState. from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.solver import Result; from qutip.expect import expect, expect_rho_vec; from qutip.superoperator import (spre, spost, mat2vec, vec2mat,; liouvillian, lindblad_dissipator); from qutip.cy.spmatfuncs import cy_expect_psi_csr, spmv, cy_expect_rho_vec; from qutip.cy.stochastic import (cy_d1_rho_photocurrent,; cy_d2_rho_photocurrent); from qutip.parallel import serial_map; from qutip.ui.progressbar import TextProgressBar; from qutip.solver import Options, _solver_safety_check; from qutip.settings import debug. if debug:; import qutip.logging_utils; im",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/stochastic.html:2347,optimiz,optimizing,2347,docs/4.1/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/stochastic.html,8,"['optimiz', 'perform']","['optimizing', 'performance']"
Performance,"ARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #; # Significant parts of this code were contributed by Denis Vasilyev.; #; ###############################################################################; """"""; This module contains functions for solving stochastic schrodinger and master; equations. The API should not be considered stable, and is subject to change; when we work more on optimizing this module for performance and features.; """""". __all__ = ['ssesolve', 'ssepdpsolve', 'smesolve', 'smepdpsolve']. import numpy as np; import scipy.sparse as sp; from scipy.linalg.blas import get_blas_funcs; try:; norm = get_blas_funcs(""znrm2"", dtype=np.float64); except:; from scipy.linalg import norm. from numpy.random import RandomState. from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.solver import Result; from qutip.expect import expect, expect_rho_vec; from qutip.superoperator import (spre, spost, mat2vec, vec2mat,; liouvillian, lindblad_dissipator); from qutip.cy.spmatfuncs import cy_expect_psi_csr, spmv, cy_expect_rho_vec; from qutip.cy.stochastic import (cy_d1_rho_photocurrent,; cy_d2_rho_photocurrent); from qutip.parallel import serial_map; from qutip.ui.progressbar import TextProgressBar; from qutip.solver import Options; from qutip.settings import debug. if debug:; import qutip.logging; import inspect; logger = qutip",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:3601,optimiz,optimizing,3601,docs/3.1.0/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html,2,"['optimiz', 'perform']","['optimizing', 'performance']"
Performance,"AW IS PROHIBITED.; BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. Definitions. “Adaptation” means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License.; “Distribute” means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership.; “Licensor” means th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/copyright-1.html:2201,perform,performance,2201,docs/4.7/copyright-1.html,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html,2,['perform'],['performance']
Performance,"Bloch3d. Configuring the Bloch sphere; Bloch Class Options; Bloch3d Class Options. Animating with the Bloch sphere; Example: Qubit Decay; Generating Images for Animation; Directly Generating an Animation. « Two-time correla... Visualization of... ». Plotting on the Bloch Sphere¶. Important; Updated in QuTiP version 3.0. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; In [3]: b=Bloch(). which will load an instance of the qutip.Bloch class, or using:; In [4]: b3d=Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; In [5]: b.show(). or. In addition to the show() command, the Bloch class has the following functions:. Name; Input Parameters (#=optional); Description. add_points(pnts,#meth); pnts list/array of (x,y,z) points,; meth=’m’ (default meth=’s’) will; plot a collection of points as; multi-colored data points.; Adds a single or set of data points; to be plotted on the sphere. add_states(state,#kind); state Qobj or list/array of Qobj’s; representing state or density matrix; of a two-level system,; kind (optional) string specifying; if state should be plotted as point; (‘point’) or vector (default).; Input multiple states as a list or array. add_vectors(vec); vec list/array of (x,y,z) points; giving direction and length of; state vectors.; adds single or multipl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-bloch.html:2527,load,load,2527,docs/3.0.0/guide/guide-bloch.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-bloch.html,2,['load'],['load']
Performance,"Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; In [2]: import numpy as np. In [3]: import matplotlib.pyplot as plt. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsulating the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this using matrix representation.; To begin, let us create a blank Qobj:; In [4]: Qobj(); Out[4]: ; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[ 0.]]. where we see the blank Qobj object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. Hi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-basics.html:1599,load,loaded,1599,docs/4.2/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-basics.html,3,['load'],['loaded']
Performance,"Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; In [2]: import numpy as np. In [3]: import matplotlib.pyplot as plt. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsulating the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this using matrix representation.; To begin, let us create a blank Qobj:; In [4]: Qobj(); Out[4]: ; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank Qobj object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. Hin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-basics.html:1599,load,loaded,1599,docs/4.3/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-basics.html,2,['load'],['loaded']
Performance,"ENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from collections import deque; from copy import deepcopy; from functools import cmp_to_key; from random import shuffle. from ..circuit import QubitCircuit, Gate; from .instruction import Instruction. class InstructionsGraph():; """"""; A directed acyclic graph (DAG) representation; of the quantum instruction dependency.; An example is Fig3(b) in https://doi.org/10.1117/12.666419.; It contains methods of generating the instruction dependency graph,; a list-schedule algorithm to find the topological order; and the computation of the distance in the weighted graph; (circuit latency). It uses the `Instruction` object as a representation of node; and adds the following attributes to it:. predecessors, successors: dependency arrow of the DAG; distance_to_start, distance_to_end: longest distance to the start and end. Parameters; ----------; instructions: list; A list of instructions. Attributes; ----------; nodes: list; The input list of instruction with additional graph information.; start, end: list; List of indices of nodes connected to the start or end nodes.; """"""; def __init__(self, instructions):; instructions = deepcopy(instructions); self.nodes = []; for instruction in instructions:; if isinstance(instruction, Gate):; self.nodes.append(Instruction(instruction)); else:; self.nodes.append(instruction); for node in self.nodes:; if node.duration is None:; node.duration = 1; self.start = None; self.end = None. def generate_dependency_graph(self, commuting):; """"""; G",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:2701,latency,latency,2701,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,1,['latency'],['latency']
Performance,"F THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Opt",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:2894,optimiz,optimize,2894,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,6,['optimiz'],['optimize']
Performance,"F THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation. References; ----------; 1. N Khaneja et. al.; Optimal con",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:2923,optimiz,optimize,2923,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimize']
Performance,"False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:; task: a Python function; The function that is to be called for each value in task_vec. values: array / list; The list or array of values for which the task function is to be; evaluated. task_args: list / dictionary; The optional additional argument to the task function. task_kwargs: list / dictionary; The optional additional keyword argument to the task function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns:; result : list; The result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:; version_table: string; Return an HTML-formatted string containing version information for; QuTiP depen",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:215311,load,load-balanced,215311,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['load'],['load-balanced']
Performance,"FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; ; optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:65471,optimiz,optimize,65471,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,2,['optimiz'],['optimize']
Performance,"FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = dr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:65077,optimiz,optimize,65077,docs/4.2/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html,3,['optimiz'],['optimize']
Performance,"GHz”, “mK”). tostringThe name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns. value_new_unitfloat / arrayThe energy in the new unit. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters. filenamestrName of file containing reqested data. sepstrSeperator used to store data. Returns. dataarray_likeData from selected file. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=', ')[source]¶; Stores a matrix of data to a file to be read by an external program. Parameters. filenamestrName of data file to be stored, including extension. data: array_likeData to be written to file. numtypestr {‘complex, ‘real’}Type of numerical data. numformatstr {‘decimal’,’exp’}Format for written data. sepstrSingle-character field seperator. Usually a tab, space, comma,; or semicolon. qload(name)[source]¶; Loads data file from file named ‘filename.qu’ in current directory. Parameters. namestrName of data file to be loaded. Returns. qobjectinstance / array_likeObject retrieved from requested file. qsave(data, name='qutip_data')[source]¶; Saves given data to file named ‘filename.qu’ in current directory. Parameters. datainstance/array_likeInput Python object to be stored. filenamestrName of output data file. Parallelization¶; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1, we recommend to use qutip.parallel_map; instead of this function. Parameters. funcfunction_typeA function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input vari",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:206763,load,loaded,206763,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['load'],['loaded']
Performance,"IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['mcsolve']. import os; import numpy as np; from numpy.random import RandomState, randint; import scipy.sparse as sp; from scipy.integrate import ode; from scipy.integrate._ode import zvode. from types import FunctionType, BuiltinFunctionType; from functools import partial; from qutip.fastsparse import csr2fast; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.parallel import parfor, parallel_map, serial_map; from qutip.cy.mcsolve import CyMcOde, CyMcOdeDiag; from qutip.cy.spconvert import dense1D_to_fastcsr_ket; from qutip.sesolve import sesolve; from qutip.solver import (Options, Result, ExpectOps,; solver_safe, SolverSystem); from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; import qutip.settings. if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions. # Todo: use real warning; def warn(text):; print(text). class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0,; args={}, options=None, progress_bar=True,; map_func=parallel_map, map_kwargs={}, _safe_mode=True):; """"""Monte Carlo evolution of a state vector :math:`|\psi \\rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, consider a Hamiltonian",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/mcsolve.html:2955,load,loaded,2955,docs/4.5/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/mcsolve.html,1,['load'],['loaded']
Performance,"IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['mcsolve']. import os; import numpy as np; from numpy.random import RandomState, randint; import scipy.sparse as sp; from scipy.integrate import ode; from scipy.integrate._ode import zvode. from types import FunctionType, BuiltinFunctionType; from functools import partial; from qutip.fastsparse import csr2fast; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.parallel import parfor, parallel_map, serial_map; from qutip.cy.mcsolve import CyMcOde, CyMcOdeDiag; from qutip.cy.spconvert import dense1D_to_fastcsr_ket; from qutip.sesolve import sesolve; from qutip.solver import (Options, Result, ExpectOps,; solver_safe, SolverSystem); from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; import qutip.settings. if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions. # Todo: use real warning; def warn(text):; print(text). class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0,; args={}, options=None, progress_bar=True,; map_func=parallel_map, map_kwargs={}, _safe_mode=True):; r""""""Monte Carlo evolution of a state vector :math:`|\psi \rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, consider a Hamiltonian",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/mcsolve.html:2975,load,loaded,2975,docs/4.6/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mcsolve.html,1,['load'],['loaded']
Performance,"IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['mcsolve']. import os; import numpy as np; from numpy.random import RandomState, randint; import scipy.sparse as sp; from scipy.integrate import ode; from scipy.integrate._ode import zvode. from types import FunctionType, BuiltinFunctionType; from functools import partial; from qutip.fastsparse import csr2fast; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.parallel import parfor, parallel_map, serial_map; from qutip.cy.mcsolve import CyMcOde, CyMcOdeDiag; from qutip.cy.spconvert import dense1D_to_fastcsr_ket; from qutip.sesolve import sesolve; from qutip.solver import (Options, Result, ExpectOps,; solver_safe, SolverSystem); from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; import qutip.settings. if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions. # Todo: use real warning; def warn(text):; print(text). class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0,; args={}, options=Options(),; progress_bar=True, map_func=parallel_map, map_kwargs={},; _safe_mode=True, _exp=False):; """"""Monte Carlo evolution of a state vector :math:`|\psi \\rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, cons",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/mcsolve.html:2942,load,loaded,2942,docs/4.4/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/mcsolve.html,1,['load'],['loaded']
Performance,"Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. « Guide Overview. Manipulating Sta... ». Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the Numpy and Matplotlib libraries with:; In [2]: import numpy as np. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt or a Python script. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsulating the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this using matrix r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-basics.html:1989,load,load,1989,docs/3.1.0/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-basics.html,1,['load'],['load']
Performance,"Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:; from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this us",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-basics.html:1236,load,load,1236,docs/4.6/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html,1,['load'],['load']
Performance,"LDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. """"""; Classes that enable the storing of historical objects created during the; pulse optimisation.; These are intented for debugging.; See the optimizer and dynamics objects for instrutcions on how to enable; data dumping.; """""". import os; import numpy as np; import copy; # QuTiP logging; import qutip.logging_utils; logger = qutip.logging_utils.get_logger(); # QuTiP control modules; import qutip.control.io as qtrlio; from numpy.compat import asbytes. DUMP_DIR = ""~/.qtrl_dump"". def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Dump(object):; """"""; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes; ----------; parent : some control object (Dynamics or Optimizer); aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dir : str; directory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dump.html:2219,optimiz,optimizer,2219,docs/4.1/modules/qutip/control/dump.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dump.html,7,['optimiz'],['optimizer']
Performance,"MRES method and optional preconditioner. LGMRES; ‘iterative-lgmres’; Solve using the LGMRES method and optional preconditioner. BICGSTAB; ‘iterative-bicgstab’; Solve using the BICGSTAB method and optional preconditioner. SVD; ‘svd’; Steady-state solution via the dense SVD of the Liouvillian. The function qutip.steadystate.steadystate can take either a Hamiltonian and a list of collapse operators as input, generating internally the corresponding Liouvillian super operator in Lindblad form, or alternatively, a Liouvillian passed by the user. When possible, we recommend passing the Hamiltonian and collapse operators to qutip.steadystate.steadystate, and letting the function automatically build the Liouvillian (in Lindblad form) for the system.; As of QuTiP 3.2, the direct and power methods can take advantage of the Intel Pardiso LU solver in the Intel Math Kernel library that comes with the Anacoda (2.5+) and Intel Python distributions. This gives a substantial increase in performance compared with the standard SuperLU method used by SciPy. To verify that QuTiP can find the necessary libraries, one can check for INTEL MKL Ext: True in the QuTiP about box (qutip.about). Using the Steadystate Solver¶; Solving for the steady state solution to the Lindblad master equation for a general system with qutip.steadystate.steadystate can be accomplished using:; >>> rho_ss = steadystate(H, c_ops). where H is a quantum object representing the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-steady.html:3540,perform,performance,3540,docs/4.2/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-steady.html,8,['perform'],['performance']
Performance,"No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params). # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params). # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn). optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params). # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc. optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.targ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:65078,optimiz,optimizer,65078,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimizer']
Performance,"Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Plotting on the Bloch Sphere. Plotting on the Bloch Sphere¶. Important; Updated in QuTiP version 3.0. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; In [1]: b = Bloch(). which will load an instance of the qutip.Bloch class, or using:; >>> b3d = Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; In [2]: b.show(). or. In addition to the show() command, the Bloch class has the following functions:. Name; Input Parameters (#=optional); Description. add_points(pnts,#meth); pnts list/array of (x,y,z) points,; meth=’m’ (default meth=’s’) will; plot a collection of points as; multi-colored data points.; Adds a single or set of data points; to be plotted on the sphere. add_states(state,#kind); state Qobj or list/array of Qobj’s; representing state or density matrix; of a two-level system,; kind (optional) string specifying; if state should be plotted as point; (‘point’) or vector (default).; Input multiple states as a list or array. add_vectors(vec); vec list/array of (x,y,z) points; giving direction and length of; state vectors.; adds single or multiple ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-bloch.html:1764,load,load,1764,docs/4.2/guide/guide-bloch.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-bloch.html,5,['load'],['load']
Performance,"Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Measurement of Quantum Objects. Measurement of Quantum Objects¶. Note; New in QuTiP 4.6. Introduction¶; Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts.; Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions measure and; measurement_statistics can be used; to handle both observable-style measurements and projective style measurements. Performing a basic measurement (Observable)¶; First we need to select some states to measure. For now, let us create an up; state and a down state:; up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis.; We choose what to measure (in this case) by selecting a measurement operator.; For example,; we could select sigmaz which measures the z-component of the; spin of a spin-1/2 particle, or sigmax which measures the; x-component:; spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. A quantum measurement tranforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator.; Which eigenvector to pr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-measurement.html:1514,perform,perform,1514,docs/4.6/guide/guide-measurement.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-measurement.html,1,['perform'],['perform']
Performance,"Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [5]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True. In [6]: a = destroy(10). In [7]: expect(a.dag() * a, rho_ss_loaded); Out[7]: 0.9902248289345061. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [8]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [9]: psi0 = rand_ket(10). In [10]: times = np.linspace(0, 10, 10). In [11]: dm_list = mesolve(H, psi0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: expect(a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-saving.html:2576,load,loaded,2576,docs/4.0.2/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-saving.html,1,['load'],['loaded']
Performance,"Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [5]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True. In [6]: a = destroy(10). In [7]: expect(a.dag() * a, rho_ss_loaded); Out[7]: 0.9902248289345064. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [8]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [9]: psi0 = rand_ket(10). In [10]: times = np.linspace(0, 10, 10). In [11]: dm_list = mesolve(H, psi0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: expect(a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/guide-saving.html:2576,load,loaded,2576,docs/4.1/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.1/guide/guide-saving.html,1,['load'],['loaded']
Performance,"Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [5]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = [10, 10], type = oper, isHerm = True. In [6]: a = destroy(10). In [7]: expect(a.dag() * a, rho_ss_loaded); Out[7]: 0.9902248289345064. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [8]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [9]: psi0 = rand_ket(10). In [10]: times = np.linspace(0, 10, 10). In [11]: dm_list = mesolve(H, psi0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: expect(a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-saving.html:3376,load,loaded,3376,docs/3.1.0/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-saving.html,1,['load'],['loaded']
Performance,"Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [2]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [3]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [4]: qsave(rho_ss, 'steadystate'). In [5]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [6]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = [10, 10], type = oper, isHerm = True. In [7]: a = destroy(10). In [8]: expect(a.dag() * a, rho_ss_loaded); Out[8]: 0.9902248289345018. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [9]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [10]: psi0 = rand_ket(10). In [11]: times = np.linspace(0, 10, 10). In [12]: dm_list = mesolve(H, psi0, times, c_ops, []). In [13]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [14]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [15]: a = destroy(10). In [16]: expect(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-saving.html:3274,load,loaded,3274,docs/3.0.0/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-saving.html,1,['load'],['loaded']
Performance,"Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [2]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [3]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [4]: qsave(rho_ss, 'steadystate'). In [5]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [6]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = [10, 10], type = oper, isHerm = True. In [7]: a = destroy(10). In [8]: expect(a.dag() * a, rho_ss_loaded); Out[8]: 0.9902248289345064. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [9]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [10]: psi0 = rand_ket(10). In [11]: times = np.linspace(0, 10, 10). In [12]: dm_list = mesolve(H, psi0, times, c_ops, []). In [13]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [14]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [15]: a = destroy(10). In [16]: expect(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/guide-saving.html:3336,load,loaded,3336,docs/3.0.1/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-saving.html,1,['load'],['loaded']
Performance,"Qobj; The evolution operator from t=0 to t=T based on the final amps. evo_full_initial : Qobj; The evolution operator from t=0 to t=T based on the initial amps. stats : Stats; Object contaning the stats for the run (if any collected). optimizer : Optimizer; Instance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; g",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:84053,perform,performance,84053,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['perform'],['performance']
Performance,"QuTiP is the original quantum framework written in Python; the most widely ; used programming language in the quantum sciences. Python's straightforward syntax allows for constructing, manipulating, and evolving quantum objects using QuTiP with just a few lines of code. Easy to learn, and 100% open-source, QuTiP is the ideal toolbox for research or the classroom. Did you know that you can determine if an operator is Hermitian without performing the conjugate transpose? QuTiP does. In fact, it is just one of many custom algorithms that QuTiP uses to maximize performance. Focusing on sparse matrices, and the means by which to efficiently manipulate these data structures, allows QuTiP to tackle even the largest quantum mechanical calculations. ; . In addition to custom algorithms, QuTiP is capable of leveraging the multiprocessing power inside every modern computer. Taking advantage of the Python multiprocessing library, OPENMP, SSE3 processor extensions, and the Intel MKL, if available, allows for faster manipulation of quantum objects, and increased performance of evolution equations, without any work at all.; . QuTiP includes a variety of builtin solvers for dynamical simulations. In addition to the standard Lindblad and Monte Carlo Solvers, QuTiP includes routines for Bloch-Redfield evolution, periodic systems using the Floquet formalism, and stochastic solvers. Add to this, steady state analysis and non-Markovian techniques, and you have a wide variety of tools from which to explore your systems behavior. A wide range of time-dependent evolution simulations can be runtime compiled into C++ behind the scenes using Cython. Thus, you get the ease of use of the Python programming language, and the performance of compiled code, all for free. What can be better than that?; . Can't express your time-dependence analytically, or need to construct a function from a data set? No problem. QuTiP allows for passing interpolating functions as time-dependent arguments to the evol",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/features.html:1355,perform,performance,1355,features.html,https://qutip.org,https://qutip.org/features.html,1,['perform'],['performance']
Performance,"QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.device.optpulseprocessor. Source code for qutip.qip.device.optpulseprocessor; from collections.abc import Iterable; import warnings; import numbers. import numpy as np. from qutip.qobj import Qobj; import qutip.control.pulseoptim as cpo; from qutip.operators import identity; from qutip.tensor import tensor; from qutip.mesolve import mesolve; from qutip.qip.circuit import QubitCircuit; from qutip.qip.device.processor import Processor; from qutip.qip.operations.gates import gate_sequence_product. __all__ = ['OptPulseProcessor']. [docs]class OptPulseProcessor(Processor):; """"""; A processor, which takes the Hamiltonian available; as dynamic generators, calls the; `qutip.control.optimize_pulse_unitary` function; to find an optimized pulse sequence for the desired quantum circuit.; The processor can simulate the evolution under the given; control pulses using :func:`qutip.mesolve`.; (For attributes documentation, please; refer to the parent class :class:`.Processor`). Parameters; ----------; N: int; The number of component systems. drift: `:class:`qutip.Qobj`; The drift Hamiltonian. The size must match the whole quantum system. t1: list or float; Characterize the decoherence of amplitude damping for; each qubit. A list of size `N` or a float for all qubits. t2: list of float; Characterize the decoherence of dephasing for; each qubit. A list of size `N` or a float for all qubits. dims: list; The dimension of each component system.; Default value is a; qubit system of ``dim=[2,2,2,...,2]``; """"""; def __init__(self, N, drift=None, t1=None, t2=None, dims=None):; super(OptPulseProcessor, self).__init__(; N, t1=t1, t2=t2, dims=dims); if drift is not None:; self.add_drift(drift, list(range(N))); self.spline_kind = ""ste",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/device/optpulseprocessor.html:1058,optimiz,optimized,1058,docs/4.7/modules/qutip/qip/device/optpulseprocessor.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/device/optpulseprocessor.html,1,['optimiz'],['optimized']
Performance,"Quantum Maps. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide.html:2678,load,loading,2678,docs/4.0.2/guide/guide.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide.html,2,['load'],['loading']
Performance,"Quantum Maps. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/guide.html:2678,load,loading,2678,docs/4.1/guide/guide.html,https://qutip.org,https://qutip.org/docs/4.1/guide/guide.html,2,['load'],['loading']
Performance,"Quantum Maps. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide.html:2678,load,loading,2678,docs/4.2/guide/guide.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide.html,2,['load'],['loading']
Performance,"Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Plotting on the Bloch Sphere. Plotting on the Bloch Sphere¶. Important; Updated in QuTiP version 3.0. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; In [1]: b = Bloch(). which will load an instance of the qutip.Bloch class, or using:; >>> b3d = Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; In [2]: b.show(). or. In addition to the show() command, the Bloch class has the following functions:; As an example, we can add a single data point:; In [3]: pnt = [1/np.sqrt(3),1/np.sqrt(3),1/np.sqrt(3)]. In [4]: b.add_points(pnt). In [5]: b.show(); <Figure size 500x500 with 1 Axes>. and then a single vector:; In [6]: vec = [0,1,0]. In [7]: b.add_vectors(vec). In [8]: b.show(); <Figure size 500x500 with 1 Axes>. and then add another vector corresponding to the \(\left|\rm up \right>\) state:; In [9]: up = basis(2,0). In [10]: b.add_states(up). In [11]: b.show(); <Figure size 500x500 with 1 Axes>. Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4). In total, the ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-bloch.html:1805,load,load,1805,docs/4.5/guide/guide-bloch.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-bloch.html,1,['load'],['load']
Performance,"SINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from collections.abc import Iterable; import warnings; import numbers. import numpy as np. from qutip.qobj import Qobj; import qutip.control.pulseoptim as cpo; from qutip.operators import identity; from qutip.tensor import tensor; from qutip.mesolve import mesolve; from qutip.qip.circuit import QubitCircuit; from qutip.qip.device.processor import Processor; from qutip.qip.operations.gates import gate_sequence_product. __all__ = ['OptPulseProcessor']. [docs]class OptPulseProcessor(Processor):; """"""; A processor, which takes the Hamiltonian available; as dynamic generators, calls the; `qutip.control.optimize_pulse_unitary` function; to find an optimized pulse sequence for the desired quantum circuit.; The processor can simulate the evolution under the given; control pulses using :func:`qutip.mesolve`.; (For attributes documentation, please; refer to the parent class :class:`.Processor`). Parameters; ----------; N: int; The number of component systems. drift: `:class:`qutip.Qobj`; The drift Hamiltonian. The size must match the whole quantum system. t1: list or float; Characterize the decoherence of amplitude damping for; each qubit. A list of size `N` or a float for all qubits. t2: list of float; Characterize the decoherence of dephasing for; each qubit. A list of size `N` or a float for all qubits. dims: list; The dimension of each component system.; Default value is a; qubit system of ``dim=[2,2,2,...,2]``; """"""; def __init__(self, N, drift=None, t1=None, t2=None, dims=None):; super(OptPulseProcessor, self).__init__(; N, t1=t1, t2=t2, dims=dims); if drift is not None:; self.add_drift(drift, list(range(N))); self.spline_kind = ""ste",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/device/optpulseprocessor.html:2793,optimiz,optimized,2793,docs/4.6/modules/qutip/qip/device/optpulseprocessor.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/optpulseprocessor.html,1,['optimiz'],['optimized']
Performance,"SINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from collections.abc import Iterable; import warnings; import numbers. import numpy as np. from qutip.qobj import Qobj; import qutip.control.pulseoptim as cpo; from qutip.operators import identity; from qutip.tensor import tensor; from qutip.mesolve import mesolve; from qutip.qip.circuit import QubitCircuit; from qutip.qip.device.processor import Processor; from qutip.qip.operations.gates import gate_sequence_product. __all__ = ['OptPulseProcessor']. [docs]class OptPulseProcessor(Processor):; """"""; A processor, which takes the Hamiltonian available; as dynamic generators, calls the; `qutip.control.optimize_pulse_unitary` function; to find an optimized pulse sequence for the desired quantum circuit.; The processor can simulate the evolution under the given; control pulses using :func:`qutip.mesolve`.; (For attributes documentation, please; refer to the parent class :class:`qutip.qip.device.Processor`). Parameters; ----------; N: int; The number of component systems. drift: `:class:`qutip.Qobj`; The drift Hamiltonian. The size must match the whole quantum system. t1: list or float; Characterize the decoherence of amplitude damping for; each qubit. A list of size `N` or a float for all qubits. t2: list of float; Characterize the decoherence of dephasing for; each qubit. A list of size `N` or a float for all qubits. dims: list; The dimension of each component system.; Default value is a; qubit system of ``dim=[2,2,2,...,2]``; """"""; def __init__(self, N, drift=None, t1=None, t2=None, dims=None):; super(OptPulseProcessor, self).__init__(; N, t1=t1, t2=t2, dims=dims); if drift is not None:; self.add_drift(drift, list(range(N))); self.sp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qip/device/optpulseprocessor.html:2773,optimiz,optimized,2773,docs/4.5/modules/qutip/qip/device/optpulseprocessor.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/device/optpulseprocessor.html,1,['optimiz'],['optimized']
Performance,"Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Plotting on the Bloch Sphere. Plotting on the Bloch Sphere¶. Introduction¶; When studying the dynamics of a two-level system, it is often convenient to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.bloch.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.bloch3d.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; b = qutip.Bloch(). which will load an instance of the qutip.bloch.Bloch class, or using; >>> b3d = qutip.Bloch3d(). that loads the qutip.bloch3d.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; b.make_sphere(). or. In addition to the show command, see the API documentation for Bloch for a full list of other available functions.; As an example, we can add a single data point:; pnt = [1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)]; b.add_points(pnt); b.render(). and then a single vector:; b.fig.clf(); vec = [0, 1, 0]; b.add_vectors(vec); b.render(). and then add another vector corresponding to the \(\left|\rm up \right>\) state:; up = qutip.basis(2, 0); b.add_states(up); b.render(). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-bloch.html:1856,load,load,1856,docs/4.7/guide/guide-bloch.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html,1,['load'],['load']
Performance,"Stats attribute). num_grad_func_calls (Stats attribute). num_iter (OptimResult attribute). (Stats attribute). num_timeslot_changes (Stats attribute). num_tslot_recompute (Stats attribute). num_tslots (Dynamics attribute). (PulseGen attribute). num_waves (PulseGenPeriodic attribute). O. ode2es() (in module qutip.essolve). offset (PulseGen attribute). omega (DynamicsSymplectic attribute). onto_evo (Dynamics attribute), [1]. onwd_evo (Dynamics attribute), [1]. oper_dtype (Dynamics attribute). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). optim_method (Optimizer attribute). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircuitProcessor method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). optimizer (OptimResult attribute). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). options (HEOMSolver attribute). (MemoryCascade attribute). (StochasticSolverOptions attribute). (TTMSolverOptions attribute). orbital() (in module qutip.orbital). order (Options attribute). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel (MemoryCascade attribute). parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). params (Dynamics attribute). (Optimizer attribute). parent (Dump attribute). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). periodic (PulseGen attribute). permute() (Qobj method), [1",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/genindex.html:18825,optimiz,optimizer,18825,docs/4.0.2/genindex.html,https://qutip.org,https://qutip.org/docs/4.0.2/genindex.html,1,['optimiz'],['optimizer']
Performance,System Dynamics — QuTiP 4.3 Documentation; An Overview of the Eseries Class — QuTiP 4.3 Documentation; Guide Overview — QuTiP 4.3 Documentation; Parallel computation — QuTiP 4.3 Documentation; Generating Random Quantum States & Operators — QuTiP 4.3 Documentation; Saving QuTiP Objects and Data Sets — QuTiP 4.3 Documentation; Modifying Internal QuTiP Settings — QuTiP 4.3 Documentation; Manipulating States and Operators — QuTiP 4.3 Documentation; guide-states-1.pdf; guide-states-1.py; Solving for Steady-State Solutions — QuTiP 4.3 Documentation; Using Tensor Products and Partial Traces — QuTiP 4.3 Documentation; Visualization of quantum states and processes — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python (4.3) — QuTiP 4.3 Documentation; Installation — QuTiP 4.3 Documentation. /modules; . /qutip; . /control; ; qutip.control.dump — QuTiP 4.3 Documentation; qutip.control.dynamics — QuTiP 4.3 Documentation; qutip.control.fidcomp — QuTiP 4.3 Documentation; qutip.control.optimizer — QuTiP 4.3 Documentation; qutip.control.optimresult — QuTiP 4.3 Documentation; qutip.control.propcomp — QuTiP 4.3 Documentation; qutip.control.pulsegen — QuTiP 4.3 Documentation; qutip.control.pulseoptim — QuTiP 4.3 Documentation; qutip.control.stats — QuTiP 4.3 Documentation; qutip.control.termcond — QuTiP 4.3 Documentation; qutip.control.tslotcomp — QuTiP 4.3 Documentation. /nonmarkov; ; qutip.nonmarkov.heom — QuTiP 4.3 Documentation; qutip.nonmarkov.memorycascade — QuTiP 4.3 Documentation; qutip.nonmarkov.transfertensor — QuTiP 4.3 Documentation. /qip; . /algorithms; ; qutip.qip.algorithms.qft — QuTiP 4.3 Documentation. /models; ; qutip.qip.models.circuitprocessor — QuTiP 4.3 Documentation; qutip.qip.models.cqed — QuTiP 4.3 Documentation; qutip.qip.models.spinchain — QuTiP 4.3 Documentation. qutip.qip.circuit — QuTiP 4.3 Documentation; qutip.qip.gates — QuTiP 4.3 Documentation; qutip.qip.qubits — QuTiP 4.3 Documentation. qutip.about — QuTiP 4.3 Documentation; qutip.bloch — QuTiP 4.,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/index-wcopy.html:29637,optimiz,optimizer,29637,index-wcopy.html,https://qutip.org,https://qutip.org/index-wcopy.html,1,['optimiz'],['optimizer']
Performance,System Dynamics — QuTiP 4.4 Documentation; An Overview of the Eseries Class — QuTiP 4.4 Documentation; Guide Overview — QuTiP 4.4 Documentation; Parallel computation — QuTiP 4.4 Documentation; Generating Random Quantum States & Operators — QuTiP 4.4 Documentation; Saving QuTiP Objects and Data Sets — QuTiP 4.4 Documentation; Modifying Internal QuTiP Settings — QuTiP 4.4 Documentation; Manipulating States and Operators — QuTiP 4.4 Documentation; guide-states-1.pdf; guide-states-1.py; Solving for Steady-State Solutions — QuTiP 4.4 Documentation; Using Tensor Products and Partial Traces — QuTiP 4.4 Documentation; Visualization of quantum states and processes — QuTiP 4.4 Documentation. QuTiP: Quantum Toolbox in Python (4.4) — QuTiP 4.4 Documentation; Installation — QuTiP 4.4 Documentation. /modules; . /qutip; . /control; ; qutip.control.dump — QuTiP 4.4 Documentation; qutip.control.dynamics — QuTiP 4.4 Documentation; qutip.control.fidcomp — QuTiP 4.4 Documentation; qutip.control.optimizer — QuTiP 4.4 Documentation; qutip.control.optimresult — QuTiP 4.4 Documentation; qutip.control.propcomp — QuTiP 4.4 Documentation; qutip.control.pulsegen — QuTiP 4.4 Documentation; qutip.control.pulseoptim — QuTiP 4.4 Documentation; qutip.control.stats — QuTiP 4.4 Documentation; qutip.control.termcond — QuTiP 4.4 Documentation; qutip.control.tslotcomp — QuTiP 4.4 Documentation. /nonmarkov; ; qutip.nonmarkov.heom — QuTiP 4.4 Documentation; qutip.nonmarkov.memorycascade — QuTiP 4.4 Documentation; qutip.nonmarkov.transfertensor — QuTiP 4.4 Documentation. /qip; . /algorithms; ; qutip.qip.algorithms.qft — QuTiP 4.4 Documentation. /models; ; qutip.qip.models.circuitprocessor — QuTiP 4.4 Documentation; qutip.qip.models.cqed — QuTiP 4.4 Documentation; qutip.qip.models.spinchain — QuTiP 4.4 Documentation. qutip.qip.circuit — QuTiP 4.4 Documentation; qutip.qip.gates — QuTiP 4.4 Documentation; qutip.qip.qubits — QuTiP 4.4 Documentation. qutip.about — QuTiP 4.4 Documentation; qutip.bloch — QuTiP 4.,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/index-wcopy.html:36144,optimiz,optimizer,36144,index-wcopy.html,https://qutip.org,https://qutip.org/index-wcopy.html,1,['optimiz'],['optimizer']
Performance,"TURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codegen further optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (Added by Denis Vasilyev); Can now define a given eigen spectrum for random Hermitian and density operators.; The Qobj expm method ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/changelog.html:4017,perform,performance,4017,docs/4.2/changelog.html,https://qutip.org,https://qutip.org/docs/4.2/changelog.html,6,['perform'],['performance']
Performance,"The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""). # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""). if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in metho",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:58550,optimiz,optimizer,58550,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimizer']
Performance,"The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); ; # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""); ; if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:58632,optimiz,optimizer,58632,docs/4.2/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html,3,['optimiz'],['optimizer']
Performance,"The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; if not isinstance(drift, Qobj):; if not isinstance(drift, (list, tuple)):; raise TypeError(""drift should be a Qobj or a list of Qobj""); else:; for d in drift:; if not isinstance(d, Qobj):; raise TypeError(""drift should be a Qobj or a list of Qobj""). if not isinstance(ctrls, (list, tuple)):; raise TypeError(""ctrls should be a list of Qobj""); else:; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""ctrls should be a list of Qobj""). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); ; # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:58728,optimiz,optimizer,58728,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,2,['optimiz'],['optimizer']
Performance,"The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(self, term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(self, term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(self, term_conds)[source]¶; Check optimiser attribute status and passed parameters before; r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:83206,optimiz,optimize,83206,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['optimiz'],['optimize']
Performance,"This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be downloaded from https://arxiv.org/abs/1211.6518 or https://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organizations:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/frontmatter.html:2251,perform,performed,2251,docs/4.7/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html,1,['perform'],['performed']
Performance,"True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operator from t=0 to t=T based on the final amps. evo_full_initial : Qobj; The evolution operator from t=0 to t=T based on the initial amps; ; stats : Stats; Object contaning the stats for the run (if any collected); ; optimizer : Optimizer; Instance of the Optimizer used to generate the result; """"""; def __init__(self):; self.reset(). def reset(self):; self.fidelity = 0.0; self.initial_fid_err = np.Inf; self.fid_err = np.Inf; self.goal_achieved = False; self.grad_norm_final = 0.0; self.grad_norm_min_reached = False; self.num_iter = 0; self.max_iter_exceeded = False; self.num_fid_func_calls = 0; self.max_fid_func_exceeded = False; self.wall_time = 0.0; self.wall_time_limit_exceeded = False; self.termination_reason = ""not started yet""; self.time = None; self.initial_amps = None; self.final_amps = None; self.evo_full_final = None; self.evo_full_initial = None; self.stats = None; self.optimizer = None. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/optimresult.html:4043,optimiz,optimizer,4043,docs/4.6/modules/qutip/control/optimresult.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimresult.html,1,['optimiz'],['optimizer']
Performance,"URE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threashold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codegen further optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (Added by Denis Vasilyev); Can now define a given eigen spectrum for random Hermitian and density operators.; The Qobj expm method ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/changelog.html:2355,perform,performance,2355,docs/4.1/changelog.html,https://qutip.org,https://qutip.org/docs/4.1/changelog.html,1,['perform'],['performance']
Performance,"Ucar, “Design, Implementation, and; Analysis of Maximum Transversal Algorithms”, ACM Trans. Math. Softw.; 38, no. 2, (2011). weighted_bipartite_matching(A, perm_type='row')[source]¶; Returns an array of row permutations that attempts to maximize; the product of the ABS values of the diagonal elements in; a nonsingular square CSC sparse matrix. Such a permutation is; always possible provided that the matrix is nonsingular.; This function looks at both the structure and ABS values of the; underlying matrix. Parameters:; A : csc_matrix; Input matrix. perm_type : str {‘row’, ‘column’}; Type of permutation to generate. Returns:; perm : array; Array of row or column permutations. Notes; This function uses a weighted maximum cardinality bipartite matching; algorithm based on breadth-first search (BFS). The columns are weighted; according to the element of max ABS value in the associated rows and; are traversed in descending order by weight. When performing the BFS; traversal, the row associated to a given column is the one with maximum; weight. Unlike other techniques[1]_, this algorithm does not guarantee the; product of the diagonal is maximized. However, this limitation is offset; by the substantially faster runtime of this method.; References; I. S. Duff and J. Koster, “The design and use of algorithms for; permuting large entries to the diagonal of sparse matrices”, SIAM J.; Matrix Anal. and Applics. 20, no. 4, 889 (1997). Utility Functions¶; This module contains utility functions that are commonly needed in other; qutip modules. n_thermal(w, w_th)[source]¶; Return the number of photons in thermal equilibrium for an harmonic; oscillator mode with frequency ‘w’, at the temperature described by; ‘w_th’ where \(\omega_{\rm th} = k_BT/\hbar\). Parameters:; w : float or array; Frequency of the oscillator. w_th : float; The temperature in units of frequency (or the same units as w). Returns:; n_avg : float or array; Return the number of average photons in thermal equilibriu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:205566,perform,performing,205566,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['perform'],['performing']
Performance,"Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Parallel computation. Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; In [1]: def func1(x): return x, x**2, x**3. In [2]: a, b, c = parfor(func1, range(10)). In [3]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [4]: print(b); [ 0 1 4 9 16 25 36 49 64 81]. In [5]: print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; In [6]: result = parallel_map(func1, range(10)). In [7]: result_array = np.array(result). In [8]: print(result_array[:, 0]) # == a; [0 1 2 3 4 5 6 7 8 9]. In [9]: print(result_array[:, 1]) # == b; [ 0 1 4 9 16 25 36 49 64 81]. In [10]: print(result_array[:, 2]) # == c; [ 0 1 8 27 64 125 216 343 512 729]. Note that the return values are arranged differently for the qut",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-parfor.html:1263,perform,performing,1263,docs/4.5/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-parfor.html,1,['perform'],['performing']
Performance,"Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. « Parallel computa... Generating Rando... ». Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steady",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-saving.html:2209,perform,performed,2209,docs/3.1.0/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-saving.html,1,['perform'],['performed']
Performance,"Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. « Running Problems... Generating Rando... ». Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [2]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [3]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steady",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-saving.html:2107,perform,performed,2107,docs/3.0.0/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-saving.html,2,['perform'],['performed']
Performance,"Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-saving.html:1450,perform,performed,1450,docs/4.5/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-saving.html,1,['perform'],['performed']
Performance,"[ 0.0+0.j 0.1+0.j 0.0+0.1j 0.0+0.j ]; [ 0.0+0.j 0.0-0.1j 0.1+0.j 0.0+0.j ]; [ 0.1+0.j 0.0+0.j 0.0+0.j 0.1+0.j ]]. One convenient property of the \(\chi\) matrix is that the average; gate fidelity with the identity map can be read off directly from; the \(\chi_{00}\) element:; In [134]: print(average_gate_fidelity(S)); 0.95. In [135]: print(chi[0, 0] / 4); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-states.html:35212,perform,perform,35212,docs/4.2/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-states.html,3,['perform'],['perform']
Performance,"[num_tslots, n_ctrls] – The amplitudes at the end of the optimisation. evo_full_final¶; Qobj – The evolution operator from t=0 to t=T based on the final amps. stats¶; Stats – Object contaning the stats for the run (if any collected). optimizer¶; Optimizer – Instance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params¶; Dictionary – The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats¶; Stats – Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer¶; TimeslotComputer (subclass instance) – Used to manage when the timeslot dynamics; generator",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:76058,perform,performance,76058,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['perform'],['performance']
Performance,"\(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Manipulating States and Operators. Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the tutorials web page. State Vectors (kets or bras)¶; Here we begin by creating a Fock qutip.states.basis vacuum state vector \(\left|0\right>\) with in a Hilbert space with 5 number states, from 0 to 4:; vac = basis(5, 0). print(vac). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator \(\left(\hat{a}\right)\) corresponding to 5 number states using the qutip.operators.destroy function:; a = destroy(5). print(a). Output:; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. 0. ]; [0. 0. 1.41421356 0. 0. ]; [0. 0. 0. 1.73205081 0. ]; [0. 0. 0. 0. 2. ]; [0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state vac,; print(a * vac). Output:; Quantum object: dims = [[5]",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-states.html:1415,perform,performing,1415,docs/4.7/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html,1,['perform'],['performing']
Performance,"]; self.h_td_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None. # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver. def _format_time(t, tt=None, ttt=None):; time_str = str(datetime.timedelta(seconds=t)); if tt is not None and ttt is not None:; sect_percent = 100*t/tt; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% section, {:03.2f}% total)"".format(; sect_percent, solve_percent); elif tt is not None:; sect_percent = 100*t/tt; time_str += "" ({:03.2f}% section)"".format(sect_percent). elif ttt is not None:; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% total)"".format(solve_percent). return time_str. [docs]class Stats:; """"""; Statistical information on the solver performance; Statistics can be grouped into sections.; If no section names are given in the the contructor, then all statistics; will be added to one section 'main'. Parameters; ----------; section_names : list; list of keys that will be used as keys for the sections; These keys will also be used as names for the sections; The text in the output can be overidden by setting the header property; of the section; If no names are given then one section called 'main' is created. Attributes; ----------; sections : OrderedDict of _StatsSection; These are the sections that are created automatically on instantiation; or added using add_section. header : string; Some text that will be used as the heading in the report; By default there is None. total_time : float; Time in seconds for the solver to complete processing; Can be None, meaning that total timing percentages will be reported; """""". def __init__(self, section_names=None):; self._def_section_name = 'main'; self.sections = OrderedDict(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/solver.html:16623,perform,performance,16623,docs/4.6/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html,2,['perform'],['performance']
Performance,"]¶; Calculates the diamond norm, or the diamond distance to another; operator. Parameters. Bqutip.Qobj or NoneIf B is not None, the diamond distance d(A, B) = dnorm(A - B) between; this operator and B is returned instead of the diamond norm. Returns. dfloatEither the diamond norm of this operator, or the diamond distance; from this operator to B. dual_chan(self)[source]¶; Dual channel of quantum object representing a completely positive; map. eigenenergies(self, sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]¶; Eigenenergies of a quantum object.; Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters. sparseboolUse sparse Eigensolver. sortstrSort eigenvalues ‘low’ to high, or ‘high’ to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). Returns. eigvalsarrayArray of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(self, sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters. sparseboolUse sparse Eigensolver. sortstrSort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). Returns. eigvalsarrayArray of eigenvalues for operator. eigvecsarrayArray of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of ei",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:6285,perform,performed,6285,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,1,['perform'],['performed']
Performance,"]¶; Calculates the diamond norm, or the diamond distance to another; operator. Parameters. Bqutip.Qobj or NoneIf B is not None, the diamond distance d(A, B) = dnorm(A - B); between this operator and B is returned instead of the diamond norm. Returns. dfloatEither the diamond norm of this operator, or the diamond distance; from this operator to B. dual_chan(self)[source]¶; Dual channel of quantum object representing a completely positive; map. eigenenergies(self, sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]¶; Eigenenergies of a quantum object.; Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters. sparseboolUse sparse Eigensolver. sortstrSort eigenvalues ‘low’ to high, or ‘high’ to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). Returns. eigvalsarrayArray of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(self, sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters. sparseboolUse sparse Eigensolver. sortstrSort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). Returns. eigvalsarrayArray of eigenvalues for operator. eigvecsarrayArray of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of ei",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:6397,perform,performed,6397,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,1,['perform'],['performed']
Performance,"^2` giving the default; value `hbar=1`. method : string {'clenshaw', 'iterative', 'laguerre', 'fft'}; Select method 'clenshaw' 'iterative', 'laguerre', or 'fft', where 'clenshaw'; and 'iterative' use an iterative method to evaluate the Wigner functions for density; matrices :math:`|m><n|`, while 'laguerre' uses the Laguerre polynomials; in scipy for the same task. The 'fft' method evaluates the Fourier; transform of the density matrix. The 'iterative' method is default, and; in general recommended, but the 'laguerre' method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The 'clenshaw' method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). 'clenshaw' is a fast and numerically stable method. sparse : bool {False, True}; Tells the default solver whether or not to keep the input density; matrix in sparse format. As the dimensions of the density matrix; grow, setthing this flag can result in increased performance. parfor : bool {False, True}; Flag for calculating the Laguerre polynomial based Wigner function; method='laguerre' in parallel using the parfor function. Returns; -------. W : array; Values representing the Wigner function calculated over the specified; range [xvec,yvec]. yvex : array; FFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; -----; The 'fft' method accepts only an xvec input for the x-coordinate.; The y-coordinates are calculated internally. References; ----------. Ulf Leonhardt,; Measuring the Quantum State of Light, (Cambridge University Press, 1997). """""". if not (psi.type == 'ket' or psi.type == 'oper' or psi.type == 'bra'):; raise TypeError('Input state is not a valid operator.'). if method == 'fft':; return _wigner_fourier(psi, xvec, g). if psi.type == 'ket' or psi.type == 'bra':; rho = ket2dm(psi); else:; rho = psi. if method == 'iterative':; return _wigner_iterative(rho, xvec, yve",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/wigner.html:8562,perform,performance,8562,docs/4.5/modules/qutip/wigner.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/wigner.html,3,['perform'],['performance']
Performance,_PSU() (FidCompUnitary method). normalize_SU() (FidCompUnitary method). num() (in module qutip.operators). num_ctrls() (Dynamics property). (DynamicsUnitary property). num_dicke_ladders() (in module qutip.piqs). num_tls() (in module qutip.piqs). O. ode2es() (in module qutip.essolve). onto_evo() (Dynamics property). onwd_evo() (Dynamics property). operator_at_cells() (Lattice1d method). operator_between_cells() (Lattice1d method). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircularSpinChain method). (LinearSpinChain method). (SpinChain method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). OptPulseProcessor (class in qutip.qip.device). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). phase() (in module qutip.operators). phase_application() (Dynamics property). phase_basis() (in module qutip.states). phasegate() (in module qutip.qip.gates). photocurrent_mesolve() (in module qutip.stochastic). photocurrent_sesolve() (in module qutip.stochastic). Pim (class in qutip.piqs). pisolve() (Dicke method). plot_berry_curvatur,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/genindex.html:16050,optimiz,optimizer,16050,docs/4.5/genindex.html,https://qutip.org,https://qutip.org/docs/4.5/genindex.html,1,['optimiz'],['optimizer']
Performance,"_callback_func,; gtol=term_conds.min_gradient_norm,; maxiter=term_conds.max_iterations,; full_output=True, disp=True). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); if warn == 1:; result.max_iter_exceeded = True; result.termination_reason = ""Iteration count limit reached""; elif warn == 2:; result.grad_norm_min_reached = True; result.termination_reason = ""Gradient normal minimum reached"". except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_lev",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:28336,optimiz,optimize,28336,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,8,['optimiz'],['optimize']
Performance,"_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:197049,optimiz,optimize,197049,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['optimiz'],['optimize']
Performance,"_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/partial_transpose.html:4691,perform,performs,4691,docs/4.4/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/partial_transpose.html,1,['perform'],['performs']
Performance,"_ind = [] # norm collapse op indices; self.n_ops_ptr = [] # norm collapse op indptrs. # holds executable strings for time-dependent collapse evaluation; self.col_expect_code = None; self.col_spmv_code = None. # hold stuff for function list based time dependence; self.h_td_inds = []; self.h_td_data = []; self.h_td_ind = []; self.h_td_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None. def _format_time(t, tt=None, ttt=None):; time_str = str(datetime.timedelta(seconds=t)); if tt is not None and ttt is not None:; sect_percent = 100*t/tt; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% section, {:03.2f}% total)"".format(; sect_percent, solve_percent); elif tt is not None:; sect_percent = 100*t/tt; time_str += "" ({:03.2f}% section)"".format(sect_percent); ; elif ttt is not None:; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% total)"".format(solve_percent); ; return time_str. [docs]class Stats(object):; """"""; Statistical information on the solver performance; Statistics can be grouped into sections.; If no section names are given in the the contructor, then all statistics; will be added to one section 'main'; ; Parameters; ----------; section_names : list; list of keys that will be used as keys for the sections; These keys will also be used as names for the sections; The text in the output can be overidden by setting the header property; of the section; If no names are given then one section called 'main' is created; ; Attributes; ----------; sections : OrderedDict of _StatsSection; These are the sections that are created automatically on instantiation; or added using add_section; ; header : string; Some text that will be used as the heading in the report; By default there is None; ; total_time : float; Time in seconds for the solver to complete processing; Can be None, meaning that total timing percentages will be reported; ; Methods; -------; add_section; Add another section; ; add_count; Add some stat that is an int",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/solver.html:13544,perform,performance,13544,docs/4.0.2/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html,2,['perform'],['performance']
Performance,_ladders() (in module qutip.piqs). num_dicke_states() (in module qutip.piqs). num_tls() (in module qutip.piqs). O. ode2es() (in module qutip.essolve). onto_evo() (Dynamics property). onwd_evo() (Dynamics property). operator_at_cells() (Lattice1d method). operator_between_cells() (Lattice1d method). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircularSpinChain method). (DispersiveCavityQED method). (LinearSpinChain method). (SpinChain method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). OptPulseProcessor (class in qutip.qip.device). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). (QobjEvo method). phase() (in module qutip.operators). phase_application() (Dynamics property). phase_basis() (in module qutip.states). phasegate() (in module qutip.qip.operations.gates). photocurrent_mesolve() (in module qutip.stochastic). photocurrent_sesolve() (in module qutip.stochastic). Pim (class in qutip.piqs). pisolve() (Dicke method). plot_berry_curvature() (in module qutip.topology). plot_dispersion() (Lattice1d method). plot_,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/genindex.html:19934,optimiz,optimizer,19934,docs/4.6/genindex.html,https://qutip.org,https://qutip.org/docs/4.6/genindex.html,2,['optimiz'],['optimizer']
Performance,"_min, u_max). if use_interp:; ip_funcs = [interp1d(times, u[R - 1, j, :], kind=interp_kind,; bounds_error=False, fill_value=u[R - 1, j, -1]); for j in range(J)]. H_td_func = [H0] + [[H_ops[j], lambda t, args, j=j: ip_funcs[j](t)]; for j in range(J)]; else:; H_td_func = [H0] + [[H_ops[j], u[-1, j, :]] for j in range(J)]. progress_bar.finished(). return GRAPEResult(u=u, U_f=Qobj(U_f_list[-1], dims=U.dims),; H_t=H_td_func). [docs]def grape_unitary_adaptive(U, H0, H_ops, R, times, eps=None, u_start=None,; u_limits=None, interp_kind='linear',; use_interp=False, alpha=None, beta=None,; phase_sensitive=False, overlap_terminate=1.0,; progress_bar=BaseProgressBar()):; """"""; Calculate control pulses for the Hamiltonian operators in H_ops so that; the unitary U is realized. Experimental: Work in progress. Parameters; ----------; U : Qobj; Target unitary evolution operator. H0 : Qobj; Static Hamiltonian (that cannot be tuned by the control fields). H_ops: list of Qobj; A list of operators that can be tuned in the Hamiltonian via the; control fields. R : int; Number of GRAPE iterations. time : array / list; Array of time coordinates for control pulse evalutation. u_start : array; Optional array with initial control pulse values. Returns; -------; Instance of GRAPEResult, which contains the control pulses calculated; with GRAPE, a time-dependent Hamiltonian that is defined by the; control pulses, as well as the resulting propagator.; """""". if eps is None:; eps = 0.1 * (2 * np.pi) / (times[-1]). eps_vec = np.array([eps / 2, eps, 2 * eps]); eps_log = np.zeros(R); overlap_log = np.zeros(R). best_k = 0; _k_overlap = np.array([0.0, 0.0, 0.0]). M = len(times); J = len(H_ops); K = len(eps_vec); Uf = [None for _ in range(K)]. u = np.zeros((R, J, M, K)). if u_limits and len(u_limits) != 2:; raise ValueError(""u_limits must be a list with two values""). if u_limits:; warnings.warn(""Causion: Using experimental feature u_limits""). if u_limits and u_start:; # make sure that no values in u0 violate",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:12759,tune,tuned,12759,docs/3.1.0/modules/qutip/control/grape.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html,1,['tune'],['tuned']
Performance,"_name, inctime=True):; """"""; Save a file with the control amplitudes in each timeslot. Parameters; ----------; file_name: string; Name of the file. inctime: bool, optional; True if the time list should be included in the first column.; """"""; self._is_pulses_valid(); coeffs = np.array(self.get_full_coeffs()); if inctime:; shp = coeffs.T.shape; data = np.empty((shp[0], shp[1] + 1), dtype=np.float64); data[:, 0] = self.get_full_tlist(); data[:, 1:] = coeffs.T; else:; data = coeffs.T. np.savetxt(file_name, data, delimiter='\t', fmt='%1.16f'). [docs] def read_coeff(self, file_name, inctime=True):; """"""; Read the control amplitudes matrix and time list; saved in the file by `save_amp`. Parameters; ----------; file_name: string; Name of the file. inctime: bool, optional; True if the time list in included in the first column. Returns; -------; tlist: array_like; The time list read from the file. coeffs: array_like; The pulse matrix read from the file.; """"""; data = np.loadtxt(file_name, delimiter='\t'); if not inctime:; self.coeffs = data.T; return self.coeffs; else:; tlist = data[:, 0]; self.set_all_tlist(tlist); self.coeffs = data[:, 1:].T; return self.get_full_tlist, self.coeffs. [docs] def get_noisy_pulses(self, device_noise=False, drift=False):; """"""; It takes the pulses defined in the `Processor` and; adds noise according to `Processor.noise`. It does not modify the; pulses saved in `Processor.pulses` but returns a new list.; The length of the new list of noisy pulses might be longer; because of drift Hamiltonian and device noise. They will be; added to the end of the pulses list. Parameters; ----------; device_noise: bool, optional; If true, include pulse independent noise such as single qubit; Relaxation. Default is False.; drift: bool, optional; If true, include drift Hamiltonians. Default is False. Returns; -------; noisy_pulses: list of :class:`.Pulse`; A list of noisy pulses.; """"""; pulses = deepcopy(self.pulses); noisy_pulses = process_noise(; pulses, self.noise, sel",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/device/processor.html:14977,load,loadtxt,14977,docs/4.6/modules/qutip/qip/device/processor.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/processor.html,2,['load'],['loadtxt']
Performance,"_ops[k], list):; if len(c_ops[k]) != 2:; raise TypeError(; ""Incorrect collapse operator specification.""); else:; if isinstance(c_ops[k][1], (FunctionType,; BuiltinFunctionType, partial)):; c_func.append(k); elif isinstance(c_ops[k][1], str):; c_str.append(k); elif isinstance(c_ops[k][1], Cubic_Spline):; c_obj.append(k); elif hasattr(c_ops[k][1], '__call__'):; c_func.append(k); elif isinstance(c_ops[k][1], np.ndarray):; c_str.append(k); elif isinstance(c_ops[k][1], tuple):; c_str.append(k); else:; raise TypeError(; ""Incorrect collapse operator specification""); else:; raise TypeError(""Incorrect collapse operator specification""). #; # if n_str == 0 and n_func == 0:; # # no time-dependence at all; #; if ((len(h_str) > 0 and len(h_func) > 0) or; (len(c_str) > 0 and len(c_func) > 0)):; raise TypeError(; ""Cannot mix string and function type time-dependence formats""). # check to see if Cython is installed and version is high enough.; if len(h_str) > 0 or len(c_str) > 0:; pass; #try:; # import Cython; #except:; # raise Exception(; # ""Unable to load Cython. Use Python function format.""); #else:; # if Cython.__version__ < '0.21':; # raise Exception(""Cython version (%s) is too old. Upgrade to"" +; # "" version 0.21+"" % Cython.__version__). # If only time-dependence is in Objects, then prefer string based format; if (len(h_func) + len(c_func) + len(h_str) + len(c_str)) == 0:; h_str += h_obj #Does nothing if not objects; c_str += c_obj; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj. #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)). elif solver == 'mc':. # H C_ops #; # -- ----- --; # NO NO 00; # NO STR 01; # NO FUNC 02; #; # STR NO 10; # STR STR 11; #; # FUNC NO 20; #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; el",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/rhs_generate.html:8818,load,load,8818,docs/4.5/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/rhs_generate.html,3,['load'],['load']
Performance,"_params); guess_pulse_action = init_pulse_params.get('pulse_action'). optim.pulse_generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params); ; lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub; ; if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action; ; if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]; ; else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__). return optim. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:69379,optimiz,optimizer,69379,docs/4.0.2/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimizer']
Performance,"_params); guess_pulse_action = init_pulse_params.get('pulse_action'). optim.pulse_generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params); ; lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub; ; if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action; ; if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]; ; else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__). return optim. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:68983,optimiz,optimizer,68983,docs/4.2/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimizer']
Performance,"_params); guess_pulse_action = init_pulse_params.get('pulse_action'). optim.pulse_generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params); ; lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub; ; if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action; ; if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]; ; else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__). return optim. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:69379,optimiz,optimizer,69379,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimizer']
Performance,"_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None; ; # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver; . def _format_time(t, tt=None, ttt=None):; time_str = str(datetime.timedelta(seconds=t)); if tt is not None and ttt is not None:; sect_percent = 100*t/tt; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% section, {:03.2f}% total)"".format(; sect_percent, solve_percent); elif tt is not None:; sect_percent = 100*t/tt; time_str += "" ({:03.2f}% section)"".format(sect_percent); ; elif ttt is not None:; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% total)"".format(solve_percent); ; return time_str. [docs]class Stats(object):; """"""; Statistical information on the solver performance; Statistics can be grouped into sections.; If no section names are given in the the contructor, then all statistics; will be added to one section 'main'; ; Parameters; ----------; section_names : list; list of keys that will be used as keys for the sections; These keys will also be used as names for the sections; The text in the output can be overidden by setting the header property; of the section; If no names are given then one section called 'main' is created; ; Attributes; ----------; sections : OrderedDict of _StatsSection; These are the sections that are created automatically on instantiation; or added using add_section; ; header : string; Some text that will be used as the heading in the report; By default there is None; ; total_time : float; Time in seconds for the solver to complete processing; Can be None, meaning that total timing percentages will be reported; ; Methods; -------; add_section; Add another section; ; add_count; Add some stat that is an int",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/solver.html:14052,perform,performance,14052,docs/4.2/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html,2,['perform'],['performance']
Performance,"_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expect = []; for num in ntraj:; expt_data = np.mean(mc.expect_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:9194,load,load,9194,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['load'],['load']
Performance,"_type == '':; # None given, use the default for the Dynamics; pass; elif fid_type == 'TDAPPROX':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type). if isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer.set_phase_option(phase_option). if isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer.scale_factor = fid_err_scale_factor. # Create the Optimiser instance; # The class of the object will determine which multivar optimisation; # algorithm is used; if optim_alg == 'BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_alg == 'LBFGSB':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_alg is None:; raise errors.UsageError(""Optimisation algorithm must be specified ""; ""via 'optim_alg' parameter""); else:; raise errors.UsageError(""No option for optim_alg: "" + optim_alg). # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc. if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that par",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:29476,optimiz,optimizer,29476,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimizer']
Performance,"_up == '':; # None given, use the default for the Dynamics; pass; elif fid_type_up == 'TDAPPROX':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type_up == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params). # Currently the only working option for tslot computer is; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params). # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn). optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params). # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:65126,optimiz,optimizer,65126,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,2,['optimiz'],['optimizer']
Performance,"_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; ; optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that parameters have been supplied to generate the; # timeslot durations; try:; evo_time / num_tslots; except:; raise errors.UsageError(; ""Either the timeslot durations should be supplied as an ""; ""array 'tau' or the number of timeslots 'num_tslots' ""; ""and the evolution time 'evo_time' must be given.""). dyn.num_tslots = num_tslots; dyn.evo_time = evo_time; else:; dyn.tau = tau. # this function is called, so that the num_ctrls attribute will be set; n_ctrls = dyn.num_ctrls. ramping_pgen = None; if ramping_pulse_type:; ramping_pgen = pulsegen.create_pulse_gen(; pulse_type=ramping_pulse_type, dyn=dyn, ; pulse_params=ramping_pulse_params",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:66287,perform,performance,66287,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,2,['perform'],['performance']
Performance,"_up == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params). # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params). # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn). optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params). # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc. optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; #",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:64770,optimiz,optimizer,64770,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimizer']
Performance,"_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes; -----; [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011).; [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011).; """""". def reset(self):; OptimizerCrab.reset(self); self.id_text = 'CRAB_FMIN'; self.xtol = 1e-4; self.ftol = 1e-4. [docs] def run_optimization(self, term_conds=None):; """"""; This function optimisation method is a wrapper to the; scipy.optimize.fmin function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:36892,optimiz,optimize,36892,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,6,['optimiz'],['optimize']
Performance,_vec() (QobjEvo method). N. n_thermal() (in module qutip.utilities). next() (HierarchyADOs method). Noise (class in qutip.qip.noise). norm() (Qobj method). normalize_gradient_PSU() (FidCompUnitary method). normalize_gradient_SU() (FidCompUnitary method). normalize_PSU() (FidCompUnitary method). normalize_SU() (FidCompUnitary method). num() (in module qutip.operators). num_ctrls() (Dynamics property). (DynamicsUnitary property). num_dicke_ladders() (in module qutip.piqs). num_dicke_states() (in module qutip.piqs). num_tls() (in module qutip.piqs). O. ode2es() (in module qutip.essolve). onto_evo() (Dynamics property). onwd_evo() (Dynamics property). operator_at_cells() (Lattice1d method). operator_between_cells() (Lattice1d method). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircularSpinChain method). (DispersiveCavityQED method). (LinearSpinChain method). (SpinChain method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). OptPulseProcessor (class in qutip.qip.device). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). ,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/genindex.html:20702,optimiz,optimizer,20702,docs/4.7/genindex.html,https://qutip.org,https://qutip.org/docs/4.7/genindex.html,1,['optimiz'],['optimizer']
Performance,"`; Object storing all results from the simulation. .. note::. It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """"""; if isinstance(c_ops, (Qobj, QobjEvo)):; c_ops = [c_ops]. if options.rhs_reuse and not isinstance(H, SolverSystem):; # TODO: deprecate when going to class based solver.; if ""mcsolve"" in solver_safe:; # print("" ""); H = solver_safe[""mcsolve""]; else:; pass; # raise Exception(""Could not find the Hamiltonian to reuse.""). if not ntraj:; ntraj = options.ntraj. if len(c_ops) == 0 and not options.rhs_reuse:; warn(""No c_ops, using sesolve""); return sesolve(H, psi0, tlist, e_ops=e_ops, args=args,; options=options, progress_bar=progress_bar,; _safe_mode=_safe_mode). try:; num_traj = int(ntraj); except:; num_traj = max(ntraj). # set the physics; if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). # load monte carlo class; mc = _MC(options, _exp). if isinstance(H, SolverSystem):; mc.ss = H; else:; mc.make_system(H, c_ops, tlist, args, options). mc.reset(tlist[0], psi0). mc.set_e_ops(e_ops). if options.seeds is not None:; mc.seed(num_traj, options.seeds). if _safe_mode:; mc.run_test(). # Run the simulation; mc.run(num_traj=num_traj, tlist=tlist,; progress_bar=progress_bar,; map_func=map_func, map_kwargs=map_kwargs). return mc.get_result(ntraj). # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """"""; def __init__(self, options=Options(), _exp=False):; self.options = options; self.ss = None; self.tlist = None; self.e_ops = None; self.ran = False; self.psi0 = None; self.seeds = []; self.t = 0.; self.num_traj = 0; self.args_col = None. self._psi_out = []; self._expect_out = []; self._collapse = []; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/mcsolve.html:6762,load,load,6762,docs/4.4/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/mcsolve.html,1,['load'],['load']
Performance,"`qutip.Qobj`, optionalOld API, same as init_state. solver: str“mesolve” or “mcsolve”. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.ResultIf analytical is False, an instance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)[source]¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)[source]¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. class OptPulseProcessor(N, drift=None, t1=None, t2=None, dims=None)[source]¶; A processor, which takes the Hamiltonian available; as dynamic generators, calls the; qutip.control.optimize_pulse_unitary function; to find an optimized pulse sequence for the desired quantum circuit.; The processor can simulate the evolution under the given; control pulses using qutip.mesolve.; (For attributes documentation, please; refer to the parent class Processor). Parameters. N: intThe number of component systems. drift: `:class:`qutip.Qobj`The drift Hamiltonian. The size must match the whole quantum system. t1: list or floatCharacterize the decoherence of amplitude damping for; each qubit. A list of size N or a float for all qubits. t2: list of floatCharacterize the decoherence of dephasing for; each qubit. A list of size N or a float for all qubits. dims: listThe dimension of each component system.; Default value is a; qubit system of dim=[2,2,2,...,2]. add_control(qobj, targets=None, cyclic_permutation=False, label=None)¶; Add a control Hamiltonian to the processor. It creates a new; Pulse; object for the device that is turned off; (tlist = None, coeff = None). To activate the pulse, one; can set its tlist and coeff. Param",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:97474,optimiz,optimized,97474,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,1,['optimiz'],['optimized']
Performance,"a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. scale_factor¶; float – The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. epsilon¶; float – control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. log_level¶; i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:98679,cache,cached,98679,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['cache'],['cached']
Performance,"a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface (as in the notebook examples) then skip to the section on ‘Using the pulseoptim functions’.; ![qtrl-code_obj_model](./images/qtrl-code_object_model.png “Qtrl code object model”). The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file.; Optimizer; This acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm.; Dynamics; This is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators.; PulseGen; There are many subclasses that of pulse generators that generate different types of pulses as the initial amplitudes for the optimisation. Often the goal cannot be achieved from all starting conditions, and then typic",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-control.html:15163,optimiz,optimize,15163,docs/4.0.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html,4,"['optimiz', 'perform']","['optimize', 'perform']"
Performance,"a, other.dag().data, 1); else:; raise TypeError(""Can only calculate overlap for state vector Qobjs""). elif self.isket:; if other.isbra:; return zcsr_inner(other.data, self.data, 1); elif other.isket:; return zcsr_inner(self.data, other.data, 0); else:; raise TypeError(""Can only calculate overlap for state vector Qobjs""). raise TypeError(""Can only calculate overlap for state vector Qobjs""). [docs] def eigenstates(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenstates and eigenenergies. Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver. sort : str; Sort eigenvalues (and vectors) 'low' to high, or 'high' to low. eigvals : int; Number of requested eigenvalues. Default is all eigenvalues. tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. eigvecs : array; Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; evals, evecs = sp_eigs(self.data, self.isherm, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol,; maxiter=maxiter); new_dims = [self.dims[0], [1] * len(self.dims[0])]; ekets = np.array([Qobj(vec, dims=new_dims) for vec in evecs],; dtype=object); norms = np.array([ket.norm() for ket in ekets]); return evals, ekets / norms. [docs] def eigenenergies(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; sort : str; Sort",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/qobj.html:39903,perform,performed,39903,docs/4.3/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/qobj.html,1,['perform'],['performed']
Performance,"ad in collecting statistics. exp_coefflist of complexCoefficients for the exponential series terms. exp_freqlist of complexFrequencies for the exponential series terms. configure(self, H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats(self)[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset(self)[source]¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:31879,perform,performance,31879,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['perform'],['performance']
Performance,"ad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operator from t=0 to t=T based on the final amps. evo_full_initial : Qobj; The evolution operator from t=0 to t=T based on the initial amps; ; stats : Stats; Object contaning the stats for the run (if any collected); ; optimizer : Optimizer; Instance of the Optimizer used to generate the result; """"""; def __init__(self):; self.reset(). def reset(self):; self.fidelity = 0.0; self.initial_fid_err = np.Inf; self.fid_err = np.Inf; self.goal_achieved = False; self.grad_norm_final = 0.0; self.grad_norm_min_reached = False; self.num_iter = 0; self.max_iter_exceeded = False; self.num_fid_func_calls = 0; self.max_fid_func_exceeded = False; self.wall_time = 0.0; self.wall_time_limit_exceeded = False; self.termination_reason = ""not started yet""; self.time = None; self.initial_amps = None; self.final_amps = None; self.evo_full_final = None; self.evo_full_initial = None; self.stats = None; self.optimizer = None. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/control/optimresult.html:4023,optimiz,optimizer,4023,docs/4.5/modules/qutip/control/optimresult.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimresult.html,2,['optimiz'],['optimizer']
Performance,"added; to any initial pulses generated. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------. Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g.; optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; """""". # check parameters; if not isinstance(drift, Qobj):; raise TypeError(""drift must be a Qobj""); else:; drift = drift.full(). if not isinstance(ctrls, (list, tuple)):; raise TypeError(""ctrls should be a list of Qobj""); else:; j = 0; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""ctrls should be a list of Qobj""); else:; ctrls[j] = ctrl.full(); j += 1. if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""); else:; initial = initial.full(). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); else:; target = target.full(). cfg = optimconfig.OptimConfig(); cfg.optim_alg = optim_alg; cfg.max_metric_corr = max_metric_corr; cfg.accuracy_factor = accuracy_factor; cfg.amp_update_mode = amp_update_mode; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.pulse_type = init_pulse_type; cfg.phase_option = phase_option; cfg.amp_lbound = amp_lbound; cfg.a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:25873,optimiz,optimizer,25873,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimizer']
Performance,"adient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:4799,optimiz,optimizer,4799,docs/4.5/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html,2,['optimiz'],['optimizer']
Performance,"adients, but this can be very expensive, and can lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [Lloyd14], the dimension of a quantum optimal control problem is a polynomial function of the dimension of the manifold of the time-polynomial reachable states, when allowing for a finite control precision and evolution time. You can think of this as the information content of the pulse (as being the only effective input) being very limited e.g. the pulse is compressible to a few bytes without loosing the target.; This is where the Chopped RAndom Basis (CRAB) algorithm [Doria11], [Caneva11] comes into play: Since the pulse complexity is usually very low, it is sufficient to transform the optimal control problem to a few parameter search by introducing a physically motivated function basis that builds up the pulse. Compared to the number of time slices needed to accurately simulate quantum dynamics (often equals basis dimension for Gradient based algorithms), this number is lower by orders of magnitude, allowing CRAB to efficiently optimize smooth pulses with realistic experimental constraints. It is important to point out, that CRAB does not make any suggestion on the basis function to be used. The basis must be chosen carefully considered, taking into account a priori knowledge of the system (such as symmetries, magnitudes of scales,...) and solution (e.g. sign, smoothness, bang-bang behavior, singularities, maximum excursion or rate of change,....). By doing so, this algorithm allows for native integration of experimental constraints such as maximum frequencies allowed, maximum amplitude, smooth ramping up and down of the pulse and many more. Moreover initial guesses, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [Rach15]",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-control.html:11337,optimiz,optimize,11337,docs/4.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-control.html,1,['optimiz'],['optimize']
Performance,"adients, but this can be very expensive, and can lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [Lloyd14], the dimension of a quantum optimal control problem is a polynomial function of the dimension of the manifold of the time-polynomial reachable states, when allowing for a finite control precision and evolution time. You can think of this as the information content of the pulse (as being the only effective input) being very limited e.g. the pulse is compressible to a few bytes without loosing the target.; This is where the Chopped RAndom Basis (CRAB) algorithm [Doria11], [Caneva11] comes into play: Since the pulse complexity is usually very low, it is sufficient to transform the optimal control problem to a few parameter search by introducing a physically motivated function basis that builds up the pulse. Compared to the number of time slices needed to accurately simulate quantum dynamics (often equals basis dimension for Gradient based algorithms), this number is lower by orders of magnitude, allowing CRAB to efficiently optimize smooth pulses with realistic experimental constraints. It is important to point out, that CRAB does not make any suggestion on the basis function to be used. The basis must be chosen carefully considered, taking into account a priori knowledge of the system (such as symmetries, magnitudes of scales,…) and solution (e.g. sign, smoothness, bang-bang behavior, singularities, maximum excursion or rate of change,….). By doing so, this algorithm allows for native integration of experimental constraints such as maximum frequencies allowed, maximum amplitude, smooth ramping up and down of the pulse and many more. Moreover initial guesses, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [Rach15] tha",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-control.html:11337,optimiz,optimize,11337,docs/4.3/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html,4,['optimiz'],['optimize']
Performance,"adystate.qu using; >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations; >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True; >>> a = destroy(10); >>> np.testing.assert_almost_equal(expect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve; >>> a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> psi0 = rand_ket(10); >>> times = np.linspace(0, 10, 10); >>> dm_list = mesolve(H, psi0, times, c_ops, []); >>> qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program; >>> dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0; >>> a = destroy(10); >>> expect(a.dag() * a, dm_list_loaded.states) ; array([4.63317086, 3.59150315, 2.90590183, 2.41306641, 2.05120716,; 1.78312503, 1.58357995, 1.4346382 , 1.32327398, 1.23991233]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes two mandatory and thre",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-saving.html:3428,load,loaded,3428,docs/4.6/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-saving.html,2,['load'],['loaded']
Performance,"al minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:; ; BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:4070,optimiz,optimize,4070,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,5,['optimiz'],['optimize']
Performance,"al minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:; ; BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; exc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:4079,optimiz,optimize,4079,docs/4.5/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html,1,['optimiz'],['optimize']
Performance,"alculus for; open quantum systems. arXiv:1111.6950. [dAless08]; d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). [Kha05]; Khaneja, T. Reiss, C. Kehlet, T. Schulte-Herbruggen, and S. J. Glaser, Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms, J. Magn. Reson. 172, 296 (2005). doi:10.1016/j.jmr.2004.11.004. [Byrd95]. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. [Flo12]. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. [Lloyd14]; Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. [Doria11]; Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. [Caneva11]; Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. [Rach15]; Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. [DYNAMO]; Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/biblio.html:3043,optimiz,optimization,3043,docs/4.3/biblio.html,https://qutip.org,https://qutip.org/docs/4.3/biblio.html,2,['optimiz'],['optimization']
Performance,"algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method. The only tested options are 'fmin'; and 'Nelder-mead'. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. Note that where there is an attribute; of the :class:`~qutip.control.optimizer.Optimizer` object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; ``scipy.optimize.minimize`` method. The commonly used parameter are:. - xtol - limit on variable change for convergence; - ftol - limit on fidelity error change for convergence. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_params : dict; Parameters for the :class:`qutip.control.dynamics.Dynamics` object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are D",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:32697,optimiz,optimize,32697,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimize']
Performance,"algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method. The only tested options are 'fmin'; and 'Nelder-mead'. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. Note that where there is an attribute; of the :obj:`~Optimizer` object or the termination_conditions matching; the key that attribute. Otherwise, and in some case also, they are; assumed to be method_options for the ``scipy.optimize.minimize``; method. The commonly used parameter are:. - xtol - limit on variable change for convergence; - ftol - limit on fidelity error change for convergence. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object. The key value pairs are assumed to; be attribute name value pairs. They applied after the object is; created. prop_type : string; Propagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT DEF will use the defau",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:33966,optimiz,optimize,33966,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimize']
Performance,"all the function ``tast`` for each value in ``task_vec`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, args)`` or ``task(value)`` if ``args=None``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. task_vec: array / list; The list or array of values for which the ``task`` function is to be; evaluated. args: list / dictionary; The optional additional argument to the ``task`` function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar duing the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of ``task(value, args)`` for each; value in ``task_vec``, that is, it should be equivalent to; ``[task(v, args) for v in task_vec]``.; """""". if show_progressbar:; progress_bar = HTMLProgressBar(); else:; progress_bar = None. return parallel_map(task, task_vec, task_args=args,; client=client, view=view, progress_bar=progress_bar,; show_scheduling=show_scheduling). [docs]def parallel_map(task, values, task_args=None, task_kwargs=None,; client=None, view=None, progress_bar=None,; show_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/ipynbtools.html:8000,load,load-balanced,8000,docs/4.2/modules/qutip/ipynbtools.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/ipynbtools.html,9,['load'],['load-balanced']
Performance,"alled for each value in task_vec. values : array / list; The list or array of values for which the task function is to be; evaluated. task_args : list / dictionary; The optional additional argument to the task function. task_kwargs : list / dictionary; The optional additional keyword argument to the task function. progress_bar : ProgressBar; Progress bar class instance for showing progress. Returns:; result : list; The result list contains the value of; task(value, *task_args, **task_kwargs) for each; value in values. IPython Notebook Tools¶; This module contains utility functions for using QuTiP with IPython notebooks. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:; task: a Python function; The function that is to be called for each value in task_vec. task_vec: array / list; The list or array of values for which the task function is to be; evaluated. args: list / dictionary; The optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:212887,load,load-balanced,212887,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['load'],['load-balanced']
Performance,"allel.parallel_map only iterate over the values arguments, the qutip.parallel.parfor function simultaneously iterates over all arguments:; In [20]: def sum_diff(x, y, z=0): return x + y, x - y, z. In [21]: parfor(sum_diff, [1, 2, 3], [4, 5, 6], z=5.0); Out[21]: [array([5, 7, 9]), array([-3, -3, -3]), array([ 5., 5., 5.])]. In [22]: parallel_map(sum_diff, [1, 2, 3], task_args=(np.array([4, 5, 6]),), task_kwargs=dict(z=5.0)); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-parfor.html:5381,perform,performance,5381,docs/4.2/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-parfor.html,3,['perform'],['performance']
Performance,"ally overridden in the subclass. dump_summaryboolIf True a summary is recorded each time a new item is added to the; the dump.; Default is True. summary_sepstrdelimiter for the summary file.; default is a space. data_sepstrdelimiter for the data files (arrays saved to file).; default is a space. summary_filestrFile path for summary file.; Automatically generated. Can be set specifically. create_dump_dir(self)[source]¶; Checks dump directory exists, creates it if not. property level¶. The level of data dumping that will occur; SUMMARY : A summary will be recorded; FULL : All possible dumping; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped. class OptimDump(optim, level='SUMMARY')[source]¶; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes. dump_summaryboolWhen True summary items are appended to the iter_summary. iter_summarylist of optimizer.OptimIterSummarySummary at each iteration. dump_fid_errboolWhen True values are appended to the fid_err_log. fid_err_loglist of floatFidelity error at each call of the fid_err_func. dump_grad_normboolWhen True values are appended to the fid_err_log. grad_norm_loglist of floatGradient norm at each call of the grad_norm_log. dump_gradboolWhen True values are appended to the grad_log. grad_loglist of ndarrayGradients at each call of the fid_grad_func. add_iter_summary(self)[source]¶; add copy of current optimizer iteration summary. property dump_all¶; True if everything (ignoring the summary) is to be dumped. property dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(self, fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(self, grad)[source]¶; add an entry to the grad log. update_grad_norm_log(self, grad_norm)[source]¶; add an entry to the grad_norm log. writeout(self, f=None)[source]¶; write all the logs and the summar",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:131154,optimiz,optimizer,131154,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['optimiz'],['optimizer']
Performance,"alue > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for a file named qutiprc in a folder called .qutip user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; [qutip]; auto_tidyup=True; auto_herm=True; auto_tidyup_atol=1e-12; num_cpus=4; debug=False. Note that the openmp_thresh value is automatically generatd by QuTiP. It is also possible to set a specific compiler for QuTiP to use when generating runtime Cython code for time-dependent problems. For example, the following section in the qutiprc file will set the compiler to be clang-3.9:; [compiler]; cc = clang-3.9; cxx = clang-3.9. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-settings.html:2485,load,loaded,2485,docs/4.3/guide/guide-settings.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-settings.html,1,['load'],['loaded']
Performance,"alues. tol : float. Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigvals : array. Array of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters:sparse : bool. Use sparse Eigensolver. sort : str. Sort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvals : int. Number of requested eigenvalues. Default is all eigenvalues. tol : float. Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigvals : array. Array of eigenvalues for operator. eigvecs : array. Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eliminate_states(states_inds, normalize=False)[source]¶; Creates a new quantum object with states in state_inds eliminated. Parameters:states_inds : list of integer. The states that should be removed. normalize : True / False. Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q : Qobj. A new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. Notes;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:6932,perform,performed,6932,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['perform'],['performed']
Performance,"ame and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. optim_method : string; A ``scipy.optimize.minimize`` method that will be used to optimise the; pulse for minimum fidelity error. Note that ``FMIN``, ``FMIN_BFGS`` &; ``FMIN_L_BFGS_B`` will all result in calling these specific; ``scipy.optimize methods``. Note the ``LBFGSB`` is equivalent to; ``FMIN_L_BFGS_B`` for backwards compatibility reasons. Supplying DEF; will given alg dependent result:. - GRAPE - Default ``optim_method`` is ``FMIN_L_BFGS_B``; - CRAB - Default ``optim_method`` is ``FMIN``. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~Optimizer` object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the ``scipy.optimize.minimize``; method. optim_alg : string; Deprecated. Use ``optim_method``. max_metric_corr : integer; Deprecated. Use ``method_params`` instead. accuracy_factor : float; Deprecated. Use ``method_params`` instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe the dynamics.; Options are ``UNIT``, ``GEN_MAT``, ``SYMPL`` (see :obj:`~Dynamics`; classes for details). dyn_params : dict; Parameters for the :obj:`~Dynamics` object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_type : string; Propagator type i.e. the method used to calculate the propagators and; propagator gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT. DEF will use the default for the specific; ``dyn_type`` (see :obj:`~PropagatorComputer` classes for details). prop_params : dict; Parameters for the :obj:`~PropagatorComputer` object. The key value; pairs are assumed to be attribute name value pairs. T",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:10050,optimiz,optimize,10050,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimize']
Performance,amics property). (DynamicsUnitary property). num_dicke_ladders() (in module qutip.piqs). num_dicke_states() (in module qutip.piqs). num_tls() (in module qutip.piqs). O. ode2es() (in module qutip.essolve). onto_evo() (Dynamics property). onwd_evo() (Dynamics property). operator_at_cells() (Lattice1d method). operator_between_cells() (Lattice1d method). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircularSpinChain method). (DispersiveCavityQED method). (LinearSpinChain method). (SpinChain method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). OptPulseProcessor (class in qutip.qip.device). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). (QobjEvo method). phase() (in module qutip.operators). phase_application() (Dynamics property). phase_basis() (in module qutip.states). phasegate() (in module qutip.qip.operations.gates). photocurrent_mesolve() (in module qutip.stochastic). photocurrent_sesolve() (in module qutip.stochastic). Pim (class in qutip.piqs). pisolve() (Dicke method). plot_berry_curvature() (in module qutip.,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/genindex.html:19880,optimiz,optimizer,19880,docs/4.6/genindex.html,https://qutip.org,https://qutip.org/docs/4.6/genindex.html,2,['optimiz'],['optimizer']
Performance,"amics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Parallel computation. Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; >>> def func1(x): return x, x**2, x**3. >>> a, b, c = parfor(func1, range(10)). >>> print(a); [0 1 2 3 4 5 6 7 8 9]. >>> print(b); [ 0 1 4 9 16 25 36 49 64 81]. >>> print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; >>> result = parallel_map(func1, range(10)). >>> result_array = np.array(result). >>> print(result_array[:, 0]) # == a; [0 1 2 3 4 5 6 7 8 9]. >>> print(result_array[:, 1]) # == b; [ 0 1 4 9 16 25 36 49 64 81]. >>> print(result_array[:, 2]) # == c; [ 0 1 8 27 64 125 216 343 512 729]. Note that the return values are arranged differently for the qutip.parallel.parallel_map and the qutip.pa",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-parfor.html:1340,perform,performing,1340,docs/4.7/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-parfor.html,1,['perform'],['performing']
Performance,"amiltonians; Floquet Formalism; Performance (QuTiP vs. qotoolbox); Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Running Problems in Parallel; QuTiP’s Built-in Parallel for-loop; IPython-Based parfor; Parallel picloud Computations. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. API documentation; Classes; Qobj; eseries; Bloch sphere; Solver Options and Results; Distribution functions; Quantum information processing. Functions; Manipulation and Creation of States and Operators; Functions acting on states and operators; Dynamics and Time-Evolution; Visualization; Quantum Information Processing; Utilitiy Functions. Change Log; Version 3.0.0 (July 17, 2014):; New Features; Improvements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/index.html:3749,load,loading,3749,docs/3.0.0/index.html,https://qutip.org,https://qutip.org/docs/3.0.0/index.html,2,['load'],['loading']
Performance,"amiltonians; Floquet Formalism; Performance (QuTiP vs. qotoolbox); Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Running Problems in Parallel; QuTiP’s Built-in Parallel for-loop; IPython-Based parfor; Parallel picloud Computations. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. API documentation; Classes; Qobj; eseries; Bloch sphere; Solver Options and Results; Distribution functions; Quantum information processing. Functions; Manipulation and Creation of States and Operators; Functions acting on states and operators; Dynamics and Time-Evolution; Visualization; Quantum Information Processing; Utilitiy Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Bug Fixes. Version 3.0.0 (July 17, 2014):; New Features; Improvements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/index.html:3890,load,loading,3890,docs/3.0.1/index.html,https://qutip.org,https://qutip.org/docs/3.0.1/index.html,2,['load'],['loading']
Performance,"amond norm, or the diamond distance to another; operator. Parameters:B : Qobj or None. If B is not None, the diamond distance d(A, B) = dnorm(A - B) between; this operator and B is returned instead of the diamond norm. Returns:d : float. Either the diamond norm of this operator, or the diamond distance; from this operator to B. dual_chan()[source]¶; Dual channel of quantum object representing a completely positive; map. eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]¶; Eigenenergies of a quantum object.; Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters:sparse : bool. Use sparse Eigensolver. sort : str. Sort eigenvalues ‘low’ to high, or ‘high’ to low. eigvals : int. Number of requested eigenvalues. Default is all eigenvalues. tol : float. Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigvals : array. Array of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters:sparse : bool. Use sparse Eigensolver. sort : str. Sort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvals : int. Number of requested eigenvalues. Default is all eigenvalues. tol : float. Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigvals : array. Array of eigenvalues for operator. eigvecs : array. Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:6128,perform,performed,6128,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['perform'],['performed']
Performance,"ams). # Currently the only working option for tslot computer is; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params). # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn). optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params). # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc. optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that parameters have been supplied to ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:65700,optimiz,optimizer,65700,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,2,['optimiz'],['optimizer']
Performance,"ance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:226422,cache,cached,226422,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['cache'],['cached']
Performance,"ance)Used to computer the fidelity error and the fidelity error; gradient. memory_optimizationintLevel of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtypetypeData type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_genboolIf True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_gradboolIf the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: boolIf True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: boolIf True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_optimization<=1, o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:91909,perform,perform,91909,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,4,['perform'],['perform']
Performance,"ance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.settings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for a file named qutiprc in a folder called .qutip user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; [qutip]; auto_tidyup=True; auto_herm=True; auto_tidyup_atol=1e-12; num_cpus=4; debug=False. Note that the openmp_thresh value is automatically generatd by QuTiP. It is also possible to set a specific compiler for QuTiP to use when generating runtime Cython code for time-dependent problems. For example, the following section in the qutiprc file will set the compiler to be clang-3.9:; [compiler]; cc = clang-3.9; cxx = clang-3.9. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-settings.html:2604,load,loaded,2604,docs/4.7/guide/guide-settings.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-settings.html,1,['load'],['loaded']
Performance,and Quantum System Dynamics — QuTiP 4.0 Documentation; An Overview of the Eseries Class — QuTiP 4.0 Documentation; Guide Overview — QuTiP 4.0 Documentation; Parallel computation — QuTiP 4.0 Documentation; Generating Random Quantum States & Operators — QuTiP 4.0 Documentation; Saving QuTiP Objects and Data Sets — QuTiP 4.0 Documentation; Modifying Internal QuTiP Settings — QuTiP 4.0 Documentation; Manipulating States and Operators — QuTiP 4.0 Documentation; Solving for Steady-State Solutions — QuTiP 4.0 Documentation; Using Tensor Products and Partial Traces — QuTiP 4.0 Documentation; Visualization of quantum states and processes — QuTiP 4.0 Documentation. /images; ; qutip_tree.pdf. QuTiP: Quantum Toolbox in Python (4.0) — QuTiP 4.0 Documentation; Installation — QuTiP 4.0 Documentation. /modules; . /qutip; . /control; ; qutip.control.dump — QuTiP 4.0 Documentation; qutip.control.dynamics — QuTiP 4.0 Documentation; qutip.control.fidcomp — QuTiP 4.0 Documentation; qutip.control.optimizer — QuTiP 4.0 Documentation; qutip.control.optimresult — QuTiP 4.0 Documentation; qutip.control.propcomp — QuTiP 4.0 Documentation; qutip.control.pulsegen — QuTiP 4.0 Documentation; qutip.control.pulseoptim — QuTiP 4.0 Documentation; qutip.control.stats — QuTiP 4.0 Documentation; qutip.control.termcond — QuTiP 4.0 Documentation; qutip.control.tslotcomp — QuTiP 4.0 Documentation. /nonmarkov; ; qutip.nonmarkov.heom — QuTiP 4.0 Documentation; qutip.nonmarkov.memorycascade — QuTiP 4.0 Documentation; qutip.nonmarkov.transfertensor — QuTiP 4.0 Documentation. /qip; . /algorithms; ; qutip.qip.algorithms.qft — QuTiP 4.0 Documentation. /models; ; qutip.qip.models.circuitprocessor — QuTiP 4.0 Documentation; qutip.qip.models.cqed — QuTiP 4.0 Documentation; qutip.qip.models.spinchain — QuTiP 4.0 Documentation. qutip.qip.circuit — QuTiP 4.0 Documentation; qutip.qip.gates — QuTiP 4.0 Documentation; qutip.qip.qubits — QuTiP 4.0 Documentation. qutip.about — QuTiP 4.0 Documentation; qutip.bloch — QuTiP 4.,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/index-wcopy.html:12885,optimiz,optimizer,12885,index-wcopy.html,https://qutip.org,https://qutip.org/index-wcopy.html,1,['optimiz'],['optimizer']
Performance,"and qutip.parallel.parfor functions behaves differently:; While qutip.parallel.parallel_map only iterate over the values arguments, the qutip.parallel.parfor function simultaneously iterates over all arguments:; In [20]: def sum_diff(x, y, z=0): return x + y, x - y, z. In [21]: parfor(sum_diff, [1, 2, 3], [4, 5, 6], z=5.0); Out[21]: [array([5, 7, 9]), array([-3, -3, -3]), array([ 5., 5., 5.])]. In [22]: parallel_map(sum_diff, [1, 2, 3], task_args=(np.array([4, 5, 6]),), task_kwargs=dict(z=5.0)); Out[22]: ; [(array([5, 6, 7]), array([-3, -4, -5]), 5.0),; (array([6, 7, 8]), array([-2, -3, -4]), 5.0),; (array([7, 8, 9]), array([-1, -2, -3]), 5.0)]. Note that the keyword arguments can be anything you like, but the keyword values are not iterated over. The keyword argument num_cpus is reserved as it sets the number of CPU’s used by parfor. By default, this value is set to the total number of physical processors on your system. You can change this number to a lower value, however setting it higher than the number of CPU’s will cause a drop in performance. In qutip.parallel.parallel_map, keyword arguments to the task function are specified using task_kwargs argument, so there is no special reserved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; In [23]: import time. In [24]: def func(x): time.sleep(1). In [25]: result = parallel_map(func, range(50), progress_bar=True); 10.0%. Run time: 2.01s. Est. time left: 00:00:00:18; 20.0%. Run time: 3.01s. Est. time left: 00:00:00:12; 30.0%. Run time: 4.02s. Est. time left: 00:00:00:09; 40.0%. Run time: 5.02s. Est. time left: 00:00:00:07; 50.0%. Run time: 7.02s. Est. time",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-parfor.html:5595,perform,performance,5595,docs/3.1.0/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-parfor.html,1,['perform'],['performance']
Performance,"andom.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; fig1, axis1 = processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, axis2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); axis2[0].step(qobjevo.tlist, noisy_coeff). (png, hires.png, pdf)¶. (png, hires.png, pdf)¶. Customize the simulator¶; The number of predefined physical models and compilers are limited.; However, it is designed for easy customization and one can easily build customized model and compiling routines.; For guide and examples, please refer to the tutorial notebooks; at http://qutip.org/tutorials.html. The workflow of the simulator¶; The following plot demonstrates the workflow of the simulator. The core of the simulator is Processor,; which characterizes the quantum hardware of interest,; containing the information such as the non-controllable drift Hamiltonian and; the control Hamiltonian.; Apart from the ideal system representing the qubits, one can also define; hardware-dependent or pulse-dependent noise in Noise.; It describes how noisy terms such as imperfect control; and decoherence can be added once the ideal control pulse is defined.; When loading a quantum circuit, a GateCompiler compiles the circuit into a sequence of control pulse signals and schedule the pulse for parallel execution.; For each control Hamiltonian, a Pulse instance is created that including the ideal evolution and associated noise.; They will then be sent to the QuTiP solvers for the computation. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/qip/qip-processor.html:20339,load,loading,20339,docs/4.6/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html,1,['load'],['loading']
Performance,"antum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator; >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-saving.html:1701,load,loading,1701,docs/4.7/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html,2,['load'],"['load', 'loading']"
Performance,"apse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : qutip.Qobj; system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notrace : bool {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns:; : :class:`qutip.Qobj`; time-propagator for computing field correlation function. propagator(t, tau, notrace=False)[source]¶; Compute propagator for time t and time-delay tau. Parameters:; t : float; current time. tau : float; time-delay. notrace : bool {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns. ——-. : :class:`qutip.Qobj`; time-propagator for reduced system dynamics. rhot(rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters:; rho0 : qutip.Qobj; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns:; : :class:`qutip.Qobj`; density matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options for the Transfer Tensor Method solver. Attributes:; dynmaps : list of qutip.Qobj; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times : array_like; List of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimes : array_like; List of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thres : float; Threshold for halting. Halts if \(||T_{n}-T",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:31869,perform,performed,31869,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['perform'],['performed']
Performance,"aram_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1]_, [2]_.; It uses the ``scipy.optimize.fmin`` function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB. References; ----------; .. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011).; .. [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011).; """""". def reset(self):; OptimizerCrab.reset(self); self.id_text = 'CRAB_FMIN'; self.xtol = 1e-4; self.ftol = 1e-4. [docs] def run_optimization(self, term_conds=None):; """"""; This function optimisation method is a wrapper to the; scipy.optimize.fmin function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:37931,optimiz,optimize,37931,docs/4.6/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html,2,['optimiz'],['optimize']
Performance,"arams : Dictionary. The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string. a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_params : dict. Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string. Deprecated. Use optim_method. max_metric_corr : integer. Deprecated. Use method_params instead. accuracy_factor : float. Deprecated. Use method_params instead. dyn_type : string. Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict. Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string. Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict. Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_type : string. Fidelity",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:164877,optimiz,optimize,164877,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['optimiz'],['optimize']
Performance,"arams : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_type : string; Fidelity",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:179674,optimiz,optimize,179674,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"are assumed to be attribute name value pairs; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimizerInstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:182124,optimiz,optimizer,182124,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,3,['optimiz'],['optimizer']
Performance,"are available, can; (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has; recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, …) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The; first is an implementation of first order GRAPE, and is not further described; here, but there are the example notebooks. The second is referred to as Qtrl; (when a distinction needs to be made) as this was its name before it was; integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the; multi-variable optimisation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-control.html:12803,optimiz,optimization,12803,docs/4.7/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html,1,['optimiz'],['optimization']
Performance,"are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_paramsdictParameters for the optim_method. Note that where there is an attribute; of the Optimizer object or the termination_conditions matching; the key that attribute. Otherwise, and in some case also, they are; assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object. The key value pairs are assumed to; be attribute name value pairs. They applied after the object is; created. prop_typestringPropagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT DEF will use the default for the specific dyn_type; (see P",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:212053,optimiz,optimize,212053,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_paramsdictParameters for the optim_method. Note that where there is an attribute; of the Optimizer object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; scipy.optimize.minimize method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_paramsdictParameters for the qutip.control.dynamics.Dynamics object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT DEF will use the default for the sp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:224140,optimiz,optimize,224140,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"array) Array of coeffcients defining cubic spline. Non-Markovian Solvers¶. class HEOMSolver[source]¶; This is superclass for all solvers that use the HEOM method for; calculating the dynamics evolution. There are many references for this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve); This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate.; There are opportunities to develop a more general spectral density code.; Attributes. H_sys; (Qobj) System Hamiltonian. coup_op; (Qobj) Operator describing the coupling between system and bath. coup_strength; (float) Coupling strength. temperature; (float) Bath temperature, in units corresponding to planck. N_cut; (int) Cutoff parameter for the bath. N_exp; (int) Number of exponential terms used to approximate the bath correlation functions. planck; (float) reduced Planck constant. boltzmann; (float) Boltzmann’s constant. options; (qutip.solver.Options) Generic solver options. If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for showing the progress of the simulation. stats; (qutip.solver.Stats) optional container for holding performance statitics If None is set, then statistics are not collected There may be an",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:23441,perform,performance,23441,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['perform'],['performance']
Performance,"array)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation value",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:8782,load,load,8782,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['load'],['load']
Performance,"array; Array of coeffcients defining cubic spline. Non-Markovian Solvers¶. class HEOMSolver[source]¶; This is superclass for all solvers that use the HEOM method for; calculating the dynamics evolution. There are many references for this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve); This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate.; There are opportunities to develop a more general spectral density code. Attributes:; H_sys : Qobj; System Hamiltonian. coup_op : Qobj; Operator describing the coupling between system and bath. coup_strength : float; Coupling strength. temperature : float; Bath temperature, in units corresponding to planck. N_cut : int; Cutoff parameter for the bath. N_exp : int; Number of exponential terms used to approximate the bath correlation; functions. planck : float; reduced Planck constant. boltzmann : float; Boltzmann’s constant. options : qutip.solver.Options; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats : qutip.solver.Stats; optional container for holding performance statitics; If None is set, then statistics are not collected; There may ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:24197,perform,performance,24197,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['perform'],['performance']
Performance,"ary will be recorded; FULL : All possible dumping; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped. class OptimDump(optim, level='SUMMARY')[source]¶; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes:; dump_summary : bool; When True summary items are appended to the iter_summary. iter_summary : list of optimizer.OptimIterSummary; Summary at each iteration. dump_fid_err : bool; When True values are appended to the fid_err_log. fid_err_log : list of float; Fidelity error at each call of the fid_err_func. dump_grad_norm : bool; When True values are appended to the fid_err_log. grad_norm_log : list of float; Gradient norm at each call of the grad_norm_log. dump_grad : bool; When True values are appended to the grad_log. grad_log : list of ndarray; Gradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. dump_all¶; True if everything (ignoring the summary) is to be dumped. dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out to file(s). Parameters:; f : filename or filehandle; If specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DynamicsDump(dynamics, level='SUMMARY')[source]¶; A container for dumps of dynamics data.; Mainly time evolution calculations. Attributes:; dump_summary : bool; If True a summary is recorded. evo_summary : list of :class:`tslotco",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:126030,optimiz,optimizer,126030,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['optimiz'],['optimizer']
Performance,"ary will be recorded; FULL : All possible dumping; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped. class OptimDump(optim, level='SUMMARY')[source]¶; A container for dumps of optimisation data generated during the pulse; optimisation.; Attributes. dump_summary; (bool) When True summary items are appended to the iter_summary. iter_summary; (list of optimizer.OptimIterSummary) Summary at each iteration. dump_fid_err; (bool) When True values are appended to the fid_err_log. fid_err_log; (list of float) Fidelity error at each call of the fid_err_func. dump_grad_norm; (bool) When True values are appended to the fid_err_log. grad_norm_log; (list of float) Gradient norm at each call of the grad_norm_log. dump_grad; (bool) When True values are appended to the grad_log. grad_log; (list of ndarray) Gradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. dump_all¶; True if everything (ignoring the summary) is to be dumped. dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out to file(s). Parameters:f : filename or filehandle. If specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DynamicsDump(dynamics, level='SUMMARY')[source]¶; A container for dumps of dynamics data.; Mainly time evolution calculations; Attributes. dump_summary; (bool) If True a summary is recorded. evo_summary; (list of :class:`tslotcomp.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:112659,optimiz,optimizer,112659,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['optimiz'],['optimizer']
Performance,"asis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; ``alg_params`` (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by ``alg_params`` (if given there). optim_method : string; Multi-variable optimisation method. The only tested options are 'fmin'; and 'Nelder-mead'. In theory any non-gradient method implemented in; ``scipy.optimize.minimize`` could be used. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~qutip.control.optimizer.Optimizer` object or; the termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; ``scipy.optimize.minimize`` method. The commonly used parameter are:. - xtol - limit on variable change for convergence; - ftol - limit on fidelity error change for convergence. phase_option : string; Determines how global phase is treated in fidelity calculations; (``fid_type='UNIT'`` only). Options:. - PSU - global phase ignored; - SU - global phase included. dyn_params : dict; Parameters for the :obj:`~qutip.control.dynamics.Dynamics` object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_params : dict; Parameters for the :obj:`~qutip.control.propcomp.PropagatorComputer`; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. fid_params : dict; Parameters for the :obj:`~qutip.control.fidcomp.FidelityComputer`; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. tslot_type : string; Method for computing t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:44062,optimiz,optimize,44062,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimize']
Performance,"at are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:186118,optimiz,optimize,186118,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['optimiz'],['optimize']
Performance,"at are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_optionstringdetermines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_paramsdictParameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_paramsdictParameters for the Fidelity",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:194566,optimiz,optimize,194566,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['optimiz'],['optimize']
Performance,"at has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate.; There are opportunities to develop a more general spectral density code. H_sys¶; Qobj – System Hamiltonian. coup_op¶; Qobj – Operator describing the coupling between system and bath. coup_strength¶; float – Coupling strength. temperature¶; float – Bath temperature, in units corresponding to planck. N_cut¶; int – Cutoff parameter for the bath. N_exp¶; int – Number of exponential terms used to approximate the bath correlation; functions. planck¶; float – reduced Planck constant. boltzmann¶; float – Boltzmann’s constant. options¶; qutip.solver.Options – Generic solver options.; If set to None the default options will be used. progress_bar¶; BaseProgressBar – Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats¶; qutip.solver.Stats – optional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coeff¶; list of complex – Coefficients for the exponential series terms. exp_freq¶; list of complex – Frequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters:; options (qutip.solver.Options) – Generic solver options.; If set to None the default options will be used; progress_bar (BaseProgressBar) – Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar; stats (qutip.solver.Stats) – Optional instance of solver.Stats, or a subclass th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:27521,perform,performance,27521,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['perform'],['performance']
Performance,"at is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. statsStatsAttributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computerTimeslotComputer (subclass instance)Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computerPropagatorComputer (subclass instance)Used to compute the propagators and their gradients. fid_computerFidelityComputer (subclass instance)Used to computer the fidelity error and the fidelity error; gradient. memory_optimizationintLevel of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:90531,perform,performance,90531,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,4,['perform'],['performance']
Performance,"at should be kept. normalize : True / False. Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q : qutip.Qobj. A new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Note; Experimental. full(squeeze=False)¶; Dense array from quantum object. Returns:data : array. Array of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000)¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters:sparse : bool. Use sparse Eigensolver. tol : float. Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigval : float. Eigenvalue for the ground state of quantum operator. eigvec : qobj. Eigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(bra, ket)¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:bra : qobj. Quantum object of type ‘bra’. ket : qobj. Quantum object of type ‘ket’. Returns:elem : complex. Complex valued matrix element. Raises:TypeError. Can only calculate matrix elements between a bra and ket; quantum object. norm(norm=None, sparse=False, tol=0, maxiter=100000)¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters:norm : str. Which norm to use for ket/bra vectors: L2 ‘l2’, max norm ‘max’,; or f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/classes.html:10392,perform,performed,10392,docs/3.1.0/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/classes.html,1,['perform'],['performed']
Performance,"at. Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer. level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. gen_stats : boolean. if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:Instance of an Optimizer, through which the. Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer. The optimisation can be run through the optimizer.run_optimization. Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details. create_pulse_gen(pulse_type='RND', dyn=None)[source]¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot. These are the other non-periodic options:; LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pul",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:147917,optimiz,optimizer,147917,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['optimiz'],['optimizer']
Performance,"ate Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Parallel computation. Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; In [1]: def func1(x): return x, x**2, x**3. In [2]: a, b, c = parfor(func1, range(10)). In [3]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [4]: print(b); [ 0 1 4 9 16 25 36 49 64 81]. In [5]: print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; In [6]: result = parallel_map(func1, range(10)). In [7]: result_array = np.array(result). In [8]: print(result_array[:, 0]) # == a; [0 1 2 3 4 5 6 7 8 9]. In [9]: print(result_array[:, 1]) # == b; [ 0 1 4 9 16 25 36 49 64 81]. In [10]: print(result_array[:, 2]) # == c; [ 0 1 8 27 64 125 216 343 512 729]. Note that the return values are arranged differently for the qutip.parallel.parallel_map and the qutip.parallel.parfor functions, as illustrated below. In particular, the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-parfor.html:1341,perform,performed,1341,docs/4.5/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-parfor.html,1,['perform'],['performed']
Performance,"ate overlap for state vector Qobjs""; raise TypeError(err). elif self.isoper:; if other.isket or other.isbra:; return (self.dag() * qutip.states.ket2dm(other)).tr(); elif other.isoper:; return (self.dag() * other).tr(); else:; err = ""Can only calculate overlap for state vector Qobjs""; raise TypeError(err); raise TypeError(""Can only calculate overlap for state vector Qobjs""). [docs] def eigenstates(self, sparse=False, sort='low', eigvals=0,; tol=0, maxiter=100000, phase_fix=None):; """"""Eigenstates and eigenenergies. Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver. sort : str; Sort eigenvalues (and vectors) 'low' to high, or 'high' to low. eigvals : int; Number of requested eigenvalues. Default is all eigenvalues. tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). phase_fix : int, None; If not None, set the phase of each kets so that ket[phase_fix,0]; is real positive. Returns; -------; eigvals : array; Array of eigenvalues for operator. eigvecs : array; Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; evals, evecs = sp_eigs(self.data, self.isherm, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol,; maxiter=maxiter); if self.type == 'super':; new_dims = [self.dims[0], [1]]; new_type = 'operator-ket'; else:; new_dims = [self.dims[0], [1] * len(self.dims[0])]; new_type = 'ket'; ekets = np.empty((len(evecs),), dtype=object); ekets[:] = [Qobj(vec, dims=new_dims, type=new_type) for vec in evecs]; norms = np.array([ket.norm() for ket in ekets]); if phase_fix is None:; phase = np.array([1] * len(ekets)); els",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobj.html:43298,perform,performed,43298,docs/4.6/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html,2,['perform'],['performed']
Performance,"ate solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. API documentation; Classes; Qobj; QobjEvo; eseries; Bloch sphere; Cubic Spline; Non-Markovian Solvers; Solver Options and Results; Permutational Invariance; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and Operators; Functions acting on states and operators; Dynamics and Time-Evolution; Visualization; Quantum Information Processing; Non-Markovian Solvers; Optimal control; Utility Functions. Change Log; Version 4.4.0 (July 03, 2019); Bug Fixes. Version 4.3.0 (July 14, 2018); Improvements; Bug Fixes. Version 4.2.0 (July 28, 2017); Improvements; Bug Fixes. Version 4.1.0 (March 10, 2017); Improvements; Bug Fixes. Version 4.0.2 (January 5, 201",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/index.html:2770,load,loading,2770,docs/4.4/index.html,https://qutip.org,https://qutip.org/docs/4.4/index.html,2,['load'],['loading']
Performance,"ate solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. API documentation; Classes; Qobj; eseries; Bloch sphere; Cubic Spline; Non-Markovian Solvers; Solver Options and Results; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and Operators; Functions acting on states and operators; Dynamics and Time-Evolution; Visualization; Quantum Information Processing; non-Markovian Solvers; Optimal control; Utilitiy Functions. Change Log; Version 4.1.0 (March 10, 2017); Improvements; Bug Fixes. Version 4.0.2 (January 5, 2017); Bug Fixes. Version 4.0.0 (December 22, 2016); Improvements; Bug Fixes. Version 3.2.0 (Never officially released); New Features; Improvements; Bug Fixes. Version 3.1.0 (January 1, 2015)",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/index.html:2675,load,loading,2675,docs/4.1/index.html,https://qutip.org,https://qutip.org/docs/4.1/index.html,2,['load'],['loading']
Performance,"ate solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. API documentation; Classes; Qobj; eseries; Bloch sphere; Cubic Spline; Non-Markovian Solvers; Solver Options and Results; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and Operators; Functions acting on states and operators; Dynamics and Time-Evolution; Visualization; Quantum Information Processing; non-Markovian Solvers; Optimal control; Utilitiy Functions. Change Log; Version 4.3.0 (); Improvements; Bug Fixes. Version 4.2.0 (July 28, 2017); Improvements; Bug Fixes. Version 4.1.0 (March 10, 2017); Improvements; Bug Fixes. Version 4.0.2 (January 5, 2017); Bug Fixes. Version 4.0.0 (December 22, 2016); Improvements; Bug Fixes. Version 3.2.0 ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/index.html:2675,load,loading,2675,docs/4.2/index.html,https://qutip.org,https://qutip.org/docs/4.2/index.html,2,['load'],['loading']
Performance,"ate solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. API documentation; Classes; Qobj; eseries; Bloch sphere; Cubic Spline; Non-Markovian Solvers; Solver Options and Results; Permutational Invariance; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and Operators; Functions acting on states and operators; Dynamics and Time-Evolution; Visualization; Quantum Information Processing; non-Markovian Solvers; Optimal control; Utility Functions. Change Log; Version 4.3.0 (July 14, 2018); Improvements; Bug Fixes. Version 4.2.0 (July 28, 2017); Improvements; Bug Fixes. Version 4.1.0 (March 10, 2017); Improvements; Bug Fixes. Version 4.0.2 (January 5, 2017); Bug Fixes. Version 4.0.0 (December 22, 2016); I",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/index.html:2701,load,loading,2701,docs/4.3/index.html,https://qutip.org,https://qutip.org/docs/4.3/index.html,2,['load'],['loading']
Performance,"ate solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. API documentation; Classes; Qobj; eseries; Bloch sphere; non-Markovian Solvers; Solver Options and Results; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and Operators; Functions acting on states and operators; Dynamics and Time-Evolution; Visualization; Quantum Information Processing; non-Markovian Solvers; Optimal control; Utilitiy Functions. Change Log; Version 4.1.0 (in dev); Improvements. Version 4.0.2 (January 5, 2017); Bug Fixes. Version 4.0.0 (December 22, 2016); Improvements; Bug Fixes. Version 3.2.0 (Never officially released); New Features; Improvements; Bug Fixes. Version 3.1.0 (January 1, 2015):; New Features; Bug Fixes. Versi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/index.html:2651,load,loading,2651,docs/4.0.2/index.html,https://qutip.org,https://qutip.org/docs/4.0.2/index.html,2,['load'],['loading']
Performance,"ate solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Introduction; Quantum Circuit; Processor for QIP simulation; Noise Simulation; Workflow of the Processor. Gallery; Quantum Information Processing. API documentation; Classes; Qobj; QobjEvo; eseries; Bloch sphere; Cubic Spline; Non-Markovian Solvers; Solver Options and Results; Permutational Invariance; One-Dimensional Lattice; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and Operators; Functions acting on states and operators; Dynamics and Time-Evolution; Lattice; Visualization; Quantum Information Processing; Non-Markovian Solvers; Optimal control; Utility Functions. Change Log; Version 4.5.0 (January 31, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/index.html:2763,load,loading,2763,docs/4.5/index.html,https://qutip.org,https://qutip.org/docs/4.5/index.html,2,['load'],['loading']
Performance,"ated CodeClimate configuration to treat our Python source files as Python 3. (#1577 by Jake Lishman); Reduced cyclomatic complexity in qutip._mkl. (#1576 by Jake Lishman); Fixed PEP8 warnings in qutip.control, qutip.mcsolve, qutip.random_objects, and qutip.stochastic. (#1575 by Jake Lishman); Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (#1563 by dependabot); Moved tests to GitHub Actions. (#1551 by Jake Lishman); The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (#1549 by Jake Lishman); The release documentation was reworked after the initial 4.6.1 to match the actual release process. (#1544 by Jake Lishman). Version 4.6.3 (February 9, 2022)¶; This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1.; The performance of the enr_destroy, state_number_enumerate and hadamard_transform functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the qutip.qip Processor.; The qutip.hardware_info module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users – it was largely unrelated to QuTiP’s core functionality and its presence was a continual source of blockers to importing qutip on new or changed platforms.; A new check on the dimensions of Qobj’s were added to prevent segmentation faults when invalid shape and dimension combinations were passed to Cython code.; In addition, there were many small bugfixes, documentation improvements, and improvements to our building and testing processes. Improvements¶. The enr_destroy function was made ~200x faster in many simple cases. (#1593 by Johannes Feist); The state_number_enumerate function was made significantly faster. (#1594 by Johannes Feist); Added the missing drift Hamiltonian to the method ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/changelog.html:14633,perform,performance,14633,docs/4.7/changelog.html,https://qutip.org,https://qutip.org/docs/4.7/changelog.html,1,['perform'],['performance']
Performance,"ath. Functions operating on Qobj class. Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:; from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this us",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-basics.html:1295,load,load,1295,docs/4.7/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-basics.html,1,['load'],['load']
Performance,"ating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. « Basic Operations... Using Tensor Pro... ». Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the tutorials web page. State Vectors (kets or bras)¶; Here we begin by creating a Fock qutip.states.basis vacuum state vector \(\left|0\right>\) with in a Hilbert space with 5 number states, from 0 to 4:; In [2]: vac = basis(5, 0). In [3]: print(vac); Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. and then create a lowering operator \(\left(\hat{a}\right)\) corresponding to 5 number states using the qutip.operators.destroy function:; In [4]: a = destroy(5). In [5]: print(a); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isherm = False; Qobj data =; [[ 0. 1. 0. 0. 0. ]; [ 0. 0. 1.41421356 0. 0. ]; [ 0. 0. 0. 1.73205081 0. ]; [ 0. 0. 0. 0. 2. ]; [ 0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state vac,; In [6]: a * vac; Out[6]: ; Q",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-states.html:1912,perform,performing,1912,docs/3.0.0/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-states.html,1,['perform'],['performing']
Performance,"ations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. « Running Problems... Generating Rando... ». Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.filei",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/guide-saving.html:1547,load,loading,1547,docs/3.0.1/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-saving.html,2,['load'],['loading']
Performance,"ator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer. level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean. if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt : Optimizer. Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:168986,optimiz,optimizer,168986,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['optimiz'],['optimizer']
Performance,"ators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However; Attributes. num_ctrls. dyn_gen. prop. prop_grad. fwd_evo. onwd_evo. onto_evo. dumping. log_level; (integer) level of messaging output from the logger. Options are attributes of qutip.logging_utils, in decreasing levels of messaging, are: DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL Anything WARN or above is effectively ‘quiet’ execution, assuming everything runs as expected. The default NOTSET implies that the level will be taken from the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value Note: attributes are created if they do not exist already, and are overwritten if they do. stats; (Stats) Attributes of which give performance stats for the optimisation set to None to reduce overhead of calculating stats. Note it is (usually) shared with the Optimizer object. tslot_computer; (TimeslotComputer (subclass instance)) Used to manage when the timeslot dynamics generators, propagators, gradients etc are updated. prop_computer; (PropagatorComputer (subclass instance)) Used to compute the propagators and their gradients. fid_computer; (FidelityComputer (subclass instance)) Used to computer the fidelity error and the fidelity error gradient. memory_optimization; (int) Level of memory optimisation. Setting to 0 (default) means that execution speed is prioritized over memory. Setting to 1 means that some memory prioritisation steps will be taken, for instance using Qobj (and hence sparse arrays) as the the internal operator data type, and not caching some operators Potentially further memory saving maybe made with memory_optimization > 1. The options are processed in _set_memory_optimizations, see this for more information. Individu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:73851,perform,performance,73851,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['perform'],['performance']
Performance,"ault = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refine : int {10}; MKL ONLY. Max. number of iterative refinements to perform. scaling_vectors : bool {True, False}; MKL ONLY. Scale matrix to unit norm columns and rows. weighted_matching : bool {True, False}; MKL ONLY. Use weighted matching to better condition diagonal. x0 : ndarray, optional; ITERATIVE ONLY. Initial guess for solution vector. maxiter : int, optional, default=1000; ITERATIVE ONLY. Maximum number of iterations to perform. tol : float, optional, default=1e-12; ITERATIVE ONLY. Tolerance used for terminating solver. mtol : float, optional, default=None; ITERATIVE ‘power’ methods ONLY. Tolerance for lu solve method.; If None given then max(0.1*tol, 1e-15) is used. matol : float, optional, default=1e-15; ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_spec : str, optional, default=’COLAMD’; ITERATIVE ONLY. Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ and; ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specifie",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:103554,perform,perform,103554,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['perform'],['perform']
Performance,"auto check. class Result[source]¶; Class for storing simulation results from any of the dynamics solvers. Attributes. solverstrWhich solver was used [e.g., ‘mesolve’, ‘mcsolve’, ‘brmesolve’, …]. timeslist/arrayTimes at which simulation data was collected. expectlist/arrayExpectation values (if requested) for simulation. statesarrayState of the simulation (density matrix or ket) evaluated at times. num_expectintNumber of expectation value operators in simulation. num_collapseintNumber of collapse operators in simualation. ntrajint/listNumber of trajectories (for stochastic solvers). A list indicates; that averaging of expectation values was done over a subset of total; number of trajectories. col_timeslistTimes at which state collpase occurred. Only for Monte Carlo solver. col_whichlistWhich collapse operator was responsible for each collapse in; col_times. Only for Monte Carlo solver. class SolverConfiguration[source]¶. class Stats(section_names=None)[source]¶; Statistical information on the solver performance; Statistics can be grouped into sections.; If no section names are given in the the contructor, then all statistics; will be added to one section ‘main’. Parameters. section_nameslistlist of keys that will be used as keys for the sections; These keys will also be used as names for the sections; The text in the output can be overidden by setting the header property; of the section; If no names are given then one section called ‘main’ is created. Attributes. sectionsOrderedDict of _StatsSectionThese are the sections that are created automatically on instantiation; or added using add_section. headerstringSome text that will be used as the heading in the report; By default there is None. total_timefloatTime in seconds for the solver to complete processing; Can be None, meaning that total timing percentages will be reported. Methods. add_section(self, name); Add another section with the given name. add_count(self, key, value[, section]); Add value to count. add_tim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:43341,perform,performance,43341,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,1,['perform'],['performance']
Performance,"auto check. class Result[source]¶; Class for storing simulation results from any of the dynamics solvers. Attributes. solverstrWhich solver was used [e.g., ‘mesolve’, ‘mcsolve’, ‘brmesolve’, …]. timeslist/arrayTimes at which simulation data was collected. expectlist/arrayExpectation values (if requested) for simulation. statesarrayState of the simulation (density matrix or ket) evaluated at times. num_expectintNumber of expectation value operators in simulation. num_collapseintNumber of collapse operators in simualation. ntrajint/listNumber of trajectories (for stochastic solvers). A list indicates; that averaging of expectation values was done over a subset of total; number of trajectories. col_timeslistTimes at which state collpase occurred. Only for Monte Carlo solver. col_whichlistWhich collapse operator was responsible for each collapse in; col_times. Only for Monte Carlo solver. class SolverConfiguration[source]¶. class Stats(section_names=None)[source]¶; Statistical information on the solver performance; Statistics can be grouped into sections.; If no section names are given in the the contructor, then all statistics; will be added to one section ‘main’. Parameters. section_nameslistlist of keys that will be used as keys for the sections; These keys will also be used as names for the sections; The text in the output can be overidden by setting the header property; of the section; If no names are given then one section called ‘main’ is created. Attributes. sectionsOrderedDict of _StatsSectionThese are the sections that are created automatically on instantiation; or added using add_section. headerstringSome text that will be used as the heading in the report; By default there is None. total_timefloatTime in seconds for the solver to complete processing; Can be None, meaning that total timing percentages will be reported. add_count(key, value, section=None)[source]¶; Add value to count. If key does not already exist in section then; it is created with this value",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:49332,perform,performance,49332,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['perform'],['performance']
Performance,"basis. Notes; This function is still in development. trunc_neg(method='clip')[source]¶; Truncates negative eigenvalues and renormalizes.; Returns a new Qobj by removing the negative eigenvalues; of this instance, then renormalizing to obtain a valid density; operator. Parameters:; method : str; Algorithm to use to remove negative eigenvalues. “clip”; simply discards negative eigenvalues, then renormalizes.; “sgs” uses the SGS algorithm (doi:10/bb76) to find the; positive operator that is nearest in the Shatten 2-norm. Returns:; oper : qobj; A valid density operator. unit(inplace=False, norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters:; inplace : bool; Do an in-place normalization. norm : str; Requested norm for states / operators. sparse : bool; Use sparse eigensolver for trace norm. Does not affect other norms. tol : float; Tolerance used by sparse eigensolver. maxiter : int; Number of maximum iterations performed by sparse eigensolver. Returns:; oper : qobj; Normalized quantum object if not in-place,; else None. eseries¶. class eseries(q=array([], dtype=object), s=array([], dtype=float64))[source]¶; Class representation of an exponential-series expansion of; time-dependent quantum objects. Attributes:; ampl : ndarray; Array of amplitudes for exponential series. rates : ndarray; Array of rates for exponential series. dims : list; Dimensions of exponential series components. shape : list; Shape corresponding to exponential series components. Methods. value(tlist); Evaluate an exponential series at the times listed in tlist. spec(wlist); Evaluate the spectrum of an exponential series at frequencies in wlist. tidyup(); Returns a tidier version of the exponential series. spec(wlist)[source]¶; Evaluate the spectrum of an exponential series at frequencies; in wlist. Parameters:; wlist : array_like; Array/list of frequenies. Returns:; val_list : ndarray; Values of exponential series at ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:16260,perform,performed,16260,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['perform'],['performed']
Performance,"be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_gen : bool; If True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_grad : bool; If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: bool; If True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: bool; If True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_optimization<=1, otherwise False. num_tslots : integer; Number of timeslots (aka timeslices). num_ctrls : integer; Number of controls.; Note this is calculated as the length of ctrl_dyn_gen when first used.; And is recalculated during initialise_controls only. evo_time : float; Total time for the evolution. tau : array[num_tslots] of float; Duration of each timeslot; Note that if this is set before initialize_controls is called; then num_tslots and evo_time are calculated from tau, otherwise; tau is generated from num_tslots and evo_time, that is; equal size time slices. time : array[num_tslots+1] of float; Cumulative time for the evolution, that is the time at the start; of each time slice. drift_dyn_gen : Qobj or list of Qobj; Drift or system dynamics generat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html:9248,cache,cached,9248,docs/4.4/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html,2,['cache'],['cached']
Performance,"be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_gen : bool; If True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_grad : bool; If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: bool; If True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: bool; If True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_optimization<=1, otherwise False. num_tslots : integer; Number of timeslots (aka timeslices). num_ctrls : integer; calculate the of controls from the length of the control list. evo_time : float; Total time for the evolution. tau : array[num_tslots] of float; Duration of each timeslot; Note that if this is set before initialize_controls is called; then num_tslots and evo_time are calculated from tau, otherwise; tau is generated from num_tslots and evo_time, that is; equal size time slices. time : array[num_tslots+1] of float; Cumulative time for the evolution, that is the time at the start; of each time slice. drift_dyn_gen : Qobj or list of Qobj; Drift or system dynamics generator (Hamiltonian); Matrix defining the underlying dynamics of the system; Can also b",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:86995,cache,cached,86995,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['cache'],['cached']
Performance,"bjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters. rhoqobjDensity matrix of composite object. selBint/listSelected components for density matrix B. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_condfloatValue of conditional entropy. entropy_linear(rho)[source]¶; Linear entropy of a density matrix. Parameters. rhoqobjsensity matrix or ket/bra vector. Returns. entropyfloatLinear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the mutual information ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:43142,concurren,concurrence,43142,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,6,['concurren'],['concurrence']
Performance,"bjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; https://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters. rhoqobjDensity matrix of composite object. selBint/listSelected components for density matrix B. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_condfloatValue of conditional entropy. entropy_linear(rho)[source]¶; Linear entropy of a density matrix. Parameters. rhoqobjsensity matrix or ket/bra vector. Returns. entropyfloatLinear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the mutual information",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:59215,concurren,concurrence,59215,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['concurren'],['concurrence']
Performance,"bles. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:. num_cpus : int; Number of CPU's to use. Default uses maximum number of CPU's.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns; -------; result : list; A ``list`` with length equal to number of input parameters; containing the output from `func`. """"""; kw = _default_kwargs(); if 'num_cpus' in kwargs.keys():; kw['num_cpus'] = kwargs['num_cpus']; del kwargs['num_cpus']; if len(kwargs) != 0:; task_func = partial(_task_wrapper_with_args, user_args=kwargs); else:; task_func = _task_wrapper. if kw['num_cpus'] > qset.num_cpus:; print(""Requested number of CPUs (%s) "" % kw['num_cpus'] +; ""is larger than physical number (%s)."" % qset.num_cpus); print(""Reduce 'num_cpus' for greater performance.""). pool = Pool(processes=kw['num_cpus']); args = [list(arg) for arg in args]; var = [[args[j][i] for j in range(len(args))]; for i in range(len(list(args[0])))]; try:; map_args = ((func, v, os.getpid()) for v in var); par_return = list(pool.map(task_func, map_args)). pool.terminate(); pool.join(). if isinstance(par_return[0], tuple):; par_return = [elem for elem in par_return]; num_elems = len(par_return[0]); dt = [type(ii) for ii in par_return[0]]; return [array([elem[ii] for elem in par_return], dtype=dt[ii]); for ii in range(num_elems)]; else:; return list(par_return). except KeyboardInterrupt:; pool.terminate(). [docs]def serial_map(task, values, task_args=tuple(), task_kwargs={}, **kwargs):; """"""; Serial mapping function with the same call signature as parallel_map, for; easy switching between serial and parallel execution. This; is functionally equivalent to:. result = [task(value, *task_args, **task_kwargs) for value in values]. This function work a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/parallel.html:5566,perform,performance,5566,docs/3.1.0/modules/qutip/parallel.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/parallel.html,1,['perform'],['performance']
Performance,"bles. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:. num_cpus : int; Number of CPU's to use. Default uses maximum number of CPU's.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns; -------; result : list; A ``list`` with length equal to number of input parameters; containing the output from `func`. """"""; kw = _default_kwargs(); if 'num_cpus' in kwargs.keys():; kw['num_cpus'] = kwargs['num_cpus']; del kwargs['num_cpus']; if len(kwargs) != 0:; task_func = partial(_task_wrapper_with_args, user_args=kwargs); else:; task_func = _task_wrapper. if kw['num_cpus'] > qset.num_cpus:; print(""Requested number of CPUs (%s) "" % kw['num_cpus'] +; ""is larger than physical number (%s)."" % qset.num_cpus); print(""Reduce 'num_cpus' for greater performance.""). pool = Pool(processes=kw['num_cpus']); args = [list(arg) for arg in args]; var = [[args[j][i] for j in range(len(args))]; for i in range(len(list(args[0])))]; try:; map_args = ((func, v, os.getpid()) for v in var); par_return = list(pool.map(task_func, map_args)). pool.terminate(); pool.join(). if isinstance(par_return[0], tuple):; par_return = [elem for elem in par_return]; num_elems = len(par_return[0]); dt = [type(ii) for ii in par_return[0]]; return [array([elem[ii] for elem in par_return], dtype=dt[ii]); for ii in range(num_elems)]; else:; return list(par_return). except KeyboardInterrupt:; pool.terminate(). [docs]def serial_map(task, values, task_args=tuple(), task_kwargs={}, **kwargs):; """"""; Serial mapping function with the same call signature as parallel_map, for; easy switching between serial and parallel execution. This; is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. This function work ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/parallel.html:4308,perform,performance,4308,docs/4.0.2/modules/qutip/parallel.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/parallel.html,1,['perform'],['performance']
Performance,"bove. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; ``alg_params`` (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by ``alg_params`` (if given there). optim_method : string; Multi-variable optimisation method. The only tested options are 'fmin'; and 'Nelder-mead'. In theory any non-gradient method implemented in; ``scipy.optimize.minimize`` could be used. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~Optimizer` object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the ``scipy.optimize.minimize``; method. The commonly used parameter are:. - xtol - limit on variable change for convergence; - ftol - limit on fidelity error change for convergence. phase_option : string; Determines how global phase is treated in fidelity calculations; (``fid_type='UNIT'`` only). Options:. - PSU - global phase ignored; - SU - global phase included. dyn_params : dict; Parameters for the :obj:`~Dynamics` object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_params : dict; Parameters for the :obj:`~PropagatorComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied aft",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:44789,optimiz,optimize,44789,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimize']
Performance,"bove. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; ``alg_params`` (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by ``alg_params`` (if given there). optim_method : string; Multi-variable optimisation method. The only tested options are 'fmin'; and 'Nelder-mead'. In theory any non-gradient method implemented in; ``scipy.optimize.minimize`` could be used. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~qutip.control.optimizer.Optimizer` object or; the termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; ``scipy.optimize.minimize`` method. The commonly used parameter are:. - xtol - limit on variable change for convergence; - ftol - limit on fidelity error change for convergence. phase_option : string; Determines how global phase is treated in fidelity calculations; (``fid_type='UNIT'`` only). Options:. - PSU - global phase ignored; - SU - global phase included. dyn_params : dict; Parameters for the :obj:`~qutip.control.dynamics.Dynamics` object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_params : dict; Parameters for the :obj:`~qutip.control.propcomp.PropagatorComputer`; object. The key valu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:43719,optimiz,optimize,43719,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimize']
Performance,"bug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.settings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for a file named qutiprc in a folder called .qutip user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; [qutip]; auto_tidyup=True; auto_herm=True; auto_tidyup_atol=1e-12; num_cpus=4; debug=False. Note that the openmp_thresh value is automatically generatd by QuTiP. It is also possible to set a specific compiler for QuTiP to use when generating runtime Cython code for time-dependent problems. For example, the following section in the qutiprc file will set the compiler to be clang-3.9:; [compiler]; cc = clang-3.9; cxx = clang-3.9. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-settings.html:2545,load,loaded,2545,docs/4.6/guide/guide-settings.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-settings.html,1,['load'],['loaded']
Performance,"by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; # QuTiP Graphics; qutip_graphics=""YES""; # use auto tidyup; auto_tidyup=True; # detect hermiticity; auto_herm=True; # use auto tidyup absolute tolerance; auto_tidyup_atol=1e-12; # number of cpus; num_cpus=4; # debug; debug=False. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-settings.html:3209,load,loaded,3209,docs/3.1.0/guide/guide-settings.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-settings.html,1,['load'],['loaded']
Performance,"by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. qutip_graphics; Use matplotlib; True / False. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; # QuTiP Graphics; qutip_graphics=""YES""; # use auto tidyup; auto_tidyup=True; # detect hermiticity; auto_herm=True; # use auto tidyup absolute tolerance; auto_tidyup_atol=1e-12; # number of cpus; num_cpus=4; # debug; debug=False. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/guide-settings.html:3169,load,loaded,3169,docs/3.0.1/guide/guide-settings.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-settings.html,1,['load'],['loaded']
Performance,"by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. qutip_graphics; Use matplotlib; True / False. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; # QuTiP Graphics; qutip_graphics=""YES""; # use auto tidyup; auto_tidyup=True; # detect hermiticity; auto_herm=True; # use auto tidyup absolute tolerance; auto_tidyup_atol=1e-12; # number of cpus; num_cpus=4; # debug; debug=False. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-settings.html:3107,load,loaded,3107,docs/3.0.0/guide/guide-settings.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-settings.html,1,['load'],['loaded']
Performance,"c Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; In [2]: import numpy as np. In [3]: import matplotlib.pyplot as plt. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsula",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-basics.html:1129,load,load,1129,docs/4.5/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-basics.html,1,['load'],['load']
Performance,"ch is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False. Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False. Display a HTML-based progress bar duing the execution of the parfor; loop. Returns:result : list. The result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. parallel_map(task, values, task_args=None, task_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:task: a Python function. The function that is to be called for each value in task_vec. values: array / list. The list or array of values for which the task function is to be; evaluated. task_args: list / dictionary. The optional additional argument to the task function. task_kwargs: list / dictionary. The optional additional keyword argument to the task function. client: IPython.parallel.Client. The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view. The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False. Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:199707,load,load-balanced,199707,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,3,['load'],['load-balanced']
Performance,"check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.iter_summary = None. self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.iteration_steps = None. def _build_method_options(self):; """"""; Creates the method_options dictionary for the scipy.optimize.minimize; function based on the attributes of this object and the; termination_conditions; It assumes that apply_method_params has already been run and; hence the method_options attribute may already contain items.; These values will NOT be overridden; """"""; tc = self.termination_conditions; if self.method_options is None:; self.method_options = {}; mo = self.method_options. if 'max_metric_corr' in mo and not 'maxcor' in mo:; mo['maxcor'] = mo['max_metric_corr']; elif hasattr(self, 'max_metric_corr') and not 'maxcor' in mo:; mo['maxcor'] = self.max_metric_corr; if 'accuracy_factor' in mo and not 'ftol' in mo:; mo['ftol'] = mo['accuracy_factor']; elif hasattr(tc, 'accuracy_factor') and not 'ftol' in mo:; mo['ftol'] = tc.accuracy_factor; if tc.max_iterations > 0 and not 'maxiter' in mo:; mo['maxiter'] = tc.max_iterations; if tc.max_fid_func_calls > 0 and not 'maxfev' in mo:; mo['maxfev'] = tc.max_fid_func_calls; if tc.min_gradient_norm > 0 and not 'gtol' in mo:; mo['gtol'] = tc.min_gr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:14410,optimiz,optimize,14410,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,8,['optimiz'],['optimize']
Performance,check_herm() (Qobj method). check_isunitary() (Qobj method). check_unitarity() (DynamicsUnitary method). CircuitProcessor (class in qutip.qip.models). CircularSpinChain (class in qutip.qip.models.spinchain). clear() (Bloch method). (FidCompUnitary method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coefficient_matrix() (Dicke method). (Pim method). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). collapse_uncoupled() (in module qutip.piqs). combine_dyn_gen() (Dynamics method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method). controlled_gate() (in module qutip.qip.gates). convert_unit() (in module qutip.utilities). copy() (Qobj method). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_3op_1t() (in module qutip.correlation). correlation_3op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). cosm() (Qobj method). covariance_matrix() (in module qutip.continuous_variables). cphase() (in module qutip.qip.gates). create() (in module qutip.operators). create_dump_dir() (Dump,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/genindex.html:2941,concurren,concurrence,2941,docs/4.3/genindex.html,https://qutip.org,https://qutip.org/docs/4.3/genindex.html,2,['concurren'],['concurrence']
Performance,"cientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.3+ is highly recommended. Numpy; 1.7+; Not tested on lower versions. Scipy; 0.13+; Lower versions have missing features. Matplotlib; 1.2.0+; Some plotting does not work on lower versions. Cython; 0.15+; Needed for compiling some time-dependent; Hamiltonians. GCC; Compiler; 4.2+; Needed for compiling Cython files. Fortran; Compiler; Fortran 90; Needed for compiling the optional Fortran-based; Monte Carlo solver. BLAS; library; 1.2+; Optional, Linux & Mac only.; Needed for installing Fortran Monte Carlo solver. Mayavi; 4.1+; Optional. Needed for using the Bloch3d class. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. LaTeX; TexLive 2009+; Optional. Needed if using LaTeX in figures. nose; 1.1.2+; Optional. For running tests. As of version 2.2, QuTiP includes an optional Fortran-based Monte Carlo solver that has a substantial performance benefit when compared with the Python-based solver. In order to install this package you must have a Fortran compiler (for example gfortran) and BLAS development libraries. At present, these packages are only tested on the Linux and OS X platforms. Platform-independent installation¶; Often the easiest way is to install QuTiP is to use the Python package manager pip.; sudo pip install qutip. However, when installing QuTiP this way the Fortran-based Monte Carlo solver is not included.; More detailed platform-dependent installation alternatives are given below. Get the source code¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/installation.html:2966,perform,performance,2966,docs/3.0.0/installation.html,https://qutip.org,https://qutip.org/docs/3.0.0/installation.html,1,['perform'],['performance']
Performance,"cify whether fidelity_prenorm are based on the current amplitude values. Set False when amplitudes change. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]¶. normalize_SU(A)[source]¶. normalize_gradient_PSU(grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. set_phase_option(phase_option=None",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:91907,cache,cached,91907,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['cache'],['cached']
Performance,"compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_gen : bool; If True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_grad : bool; If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: bool; If True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: bool; If True ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:86134,perform,performs,86134,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,3,['perform'],['performs']
Performance,"corr; (integer) The maximum number of variable metric corrections used to define the limited memory matrix. That is the number of previous gradient values that are used to approximate the Hessian see the scipy.optimize.fmin_l_bfgs_b documentation for description of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:66403,optimiz,optimize,66403,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['optimiz'],['optimize']
Performance,"ct. class Result[source]¶; Class for storing simulation results from any of the dynamics solvers. solver¶; str – Which solver was used [e.g., ‘mesolve’, ‘mcsolve’, ‘brmesolve’, ...]. times¶; list/array – Times at which simulation data was collected. expect¶; list/array – Expectation values (if requested) for simulation. states¶; array – State of the simulation (density matrix or ket) evaluated at times. num_expect¶; int – Number of expectation value operators in simulation. num_collapse¶; int – Number of collapse operators in simualation. ntraj¶; int/list – Number of trajectories (for stochastic solvers). A list indicates; that averaging of expectation values was done over a subset of total; number of trajectories. col_times¶; list – Times at which state collpase occurred. Only for Monte Carlo solver. col_which¶; list – Which collapse operator was responsible for each collapse in; col_times. Only for Monte Carlo solver. class Stats(section_names=None)[source]¶; Statistical information on the solver performance; Statistics can be grouped into sections.; If no section names are given in the the contructor, then all statistics; will be added to one section ‘main’. Parameters:section_names (list) – list of keys that will be used as keys for the sections; These keys will also be used as names for the sections; The text in the output can be overidden by setting the header property; of the section; If no names are given then one section called ‘main’ is created. sections¶; OrderedDict of _StatsSection – These are the sections that are created automatically on instantiation; or added using add_section. header¶; string – Some text that will be used as the heading in the report; By default there is None. total_time¶; float – Time in seconds for the solver to complete processing; Can be None, meaning that total timing percentages will be reported. add_section()¶; Add another section. add_count()¶; Add some stat that is an integer count. add_timing()¶; Add some timing statistic",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:39043,perform,performance,39043,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['perform'],['performance']
Performance,"ctor for a = 0.5 * g * (x + iy), default g = sqrt(2). methodstring {‘clenshaw’, ‘iterative’, ‘laguerre’, ‘fft’}Select method ‘clenshaw’ ‘iterative’, ‘laguerre’, or ‘fft’, where ‘clenshaw’; and ‘iterative’ use an iterative method to evaluate the Wigner functions for density; matrices \(|m><n|\), while ‘laguerre’ uses the Laguerre polynomials; in scipy for the same task. The ‘fft’ method evaluates the Fourier; transform of the density matrix. The ‘iterative’ method is default, and; in general recommended, but the ‘laguerre’ method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The ‘clenshaw’ method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). ‘clenshaw’ is a fast and numerically stable method. sparsebool {False, True}Tells the default solver whether or not to keep the input density; matrix in sparse format. As the dimensions of the density matrix; grow, setthing this flag can result in increased performance. parforbool {False, True}Flag for calculating the Laguerre polynomial based Wigner function; method=’laguerre’ in parallel using the parfor function. Returns. WarrayValues representing the Wigner function calculated over the specified; range [xvec,yvec]. yvexarrayFFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; The ‘fft’ method accepts only an xvec input for the x-coordinate.; The y-coordinates are calculated internally.; References; Ulf Leonhardt,; Measuring the Quantum State of Light, (Cambridge University Press, 1997). Graphs and Visualization¶; Functions for visualizing results of quantum dynamics simulations,; visualizations of quantum states and processes. hinton(rho, xlabels=None, ylabels=None, title=None, ax=None, cmap=None, label_top=True)[source]¶; Draws a Hinton diagram for visualizing a density matrix or superoperator. Parameters. rhoqobjInput density matrix or superoperator. xlabelsli",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:127232,perform,performance,127232,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['perform'],['performance']
Performance,"ctors); e0 = eigenvectors.conj().T[:, 0]. def time_evolution(t):; delta_t = t - t0; aux = np.multiply(np.exp(-1j * delta_t * eigenvalues), e0); return np.matmul(U, aux). return time_evolution. def _evolve_krylov_tlist(; H,; psi0: np.ndarray,; krylov_dim: int,; tlist: list,; t0: float,; psi_norm: float = None,; krylov_basis: np.array = None,; T_m: np.array = None,; sparse: bool = False,; ):; """"""; Computes the Krylov approximation time evolution of dimension 'krylov_dim'; for Hamiltonian 'H' and initial state 'psi0' for each time in 'tlist'.; Parameters; ------------; H: np.ndarray or csr_matrix; System Hamiltonian.; psi0: np.ndarray; Initial state vector.; krylov_basis: np.ndarray; Krylov basis projector operator.; tlist: list; List of timesteps for the time evolution.; t0: float; Initial time for the time evolution.; psi_norm: float (optional, default False); Norm-2 of psi0.; krylov_basis: np.ndarray (optional, default None); Krylov basis projector operator. If 'krylov_basis' is None, perform; a lanczos iteration.; T_m: np.ndarray (optional, default None); Tridiagonal matrix decomposition of the system given by lanczos; algorithm. If 'T_m' is None, perform a lanczos iteration.; Returns; ---------; psi_list: List[np.ndarray]; List of evolved states at times t in 'tlist'.; """""". if psi_norm is None:; psi_norm = np.linalg.norm(psi0). if psi_norm != 1:; psi = psi0 / psi_norm; else:; psi = psi0. if (krylov_basis is None) or (T_m is None):; krylov_basis, T_m = lanczos_algorithm(; H=H, psi=psi, krylov_dim=krylov_dim, sparse=sparse; ). evolve = _evolve(t0, krylov_basis, T_m); psi_list = list(map(evolve, tlist)). return psi_list. # ----------------------------------------------------------------------; # Auxiliar functions. def _check_inputs(H, psi0, krylov_dim):; """"""Check that the inputs 'H' and 'psi0' have the correct structures.""""""; if not isinstance(H, Qobj):; raise TypeError(; ""krylovsolve currently supports Hamiltonian Qobj operators only""; ). if not H.isherm:; raise Typ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:10276,perform,perform,10276,docs/4.7/modules/qutip/krylovsolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html,1,['perform'],['perform']
Performance,"cts and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. « Guide Overview. Manipulating Sta... ». Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the Numpy and Matplotlib libraries with:; In [2]: import numpy as np. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt or a Python script. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsulating the properties of a quantum operator and ket/bra vect",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-basics.html:1884,load,load,1884,docs/3.1.0/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-basics.html,1,['load'],['load']
Performance,"ctual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License.; “Distribute” means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership.; “Licensor” means the individual, individuals, entity or entities that; offer(s) the Work under the terms of this License.; “Original Author” means, in the case of a literary or artistic work, the; individual, individuals, entity or entities who created the Work or if no; individual or entity can be identified, the publisher; and in addition; (i) in the case of a performance the actors, singers, musicians, dancers,; and other persons who act, sing, deliver, declaim, play in, interpret or; otherwise perform literary or artistic works or expressions of folklore;; (ii) in the case of a phonogram the producer being the person or legal; entity who first fixes the sounds of a performance or other sounds; and,; (iii) in the case of broadcasts, the organization that transmits the; broadcast.; “Work” means the literary and/or artistic work offered under the terms of; this License including without limitation any production in the literary,; scientific and artistic domain, whatever may be the mode or form of its; expression including digital form, such as a book, pamphlet and other; writing; a lecture, address, sermon or other work of the same nature; a; dramatic or dramatico-musical work; a choreographic work or entertainment; in dumb show; a musical composition with or without words; a; cinematographic work to which are assimilated works expressed by a; process analogous to cinematography; a work of drawing, painting,; architecture, sculpture",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/copyright-1.html:3603,perform,performance,3603,docs/4.7/copyright-1.html,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html,6,['perform'],"['perform', 'performance']"
Performance,"culations were taken from DYNAMO; (see file header); Attributes. phase_option; (string) determines how global phase is treated in fidelity calculations: PSU - global phase ignored SU - global phase included. fidelity_prenorm; (complex) Last computed value of the fidelity before it is normalised It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current; (boolean) flag to specify whether fidelity_prenorm are based on the current amplitude values. Set False when amplitudes change. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:91464,cache,cached,91464,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['cache'],['cached']
Performance,"d by settting them directly (see below). oper_dtypetypeData type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_genboolIf True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_gradboolIf the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: boolIf True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: boolIf True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_optimization<=1, otherwise False. num_tslotsintegerNumber of timeslots (aka timeslices). num_ctrlsintegercalculate the of controls from the length of the control list. evo_timefloatTotal time for the evolution. tauarray[num_tslots] of floatDuration of each timeslot; Note that if this is set before initialize_controls is called; then num_tslots and evo_time are calculated from tau, otherwise; tau is generated from num_tslots and evo_time, that is; equal size time slices. timearray[num_tslots+1] of floatCumulative time for the evolution, that is the time at the start; of each time slice. drift_dyn_genQobj or list of QobjDrift or system dynamics generator (Hamiltonian); Matrix defining the underlying dynamics of the system; Can also be a list of Qobj (length num_tslo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:206403,cache,cached,206403,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['cache'],['cached']
Performance,"d to store both the real and imaginary parts, so instead we could use the numtype=”real” option:; In [26]: file_data_store('expect.dat', output_data.T, numtype=""real""). In [27]: !head -n5 expect.dat; # Generated by QuTiP: 100x4 real matrix in decimal format [',' separated values].; 0.0000000000,4.1221306284,0.8180285078,0.2587243651; 1.0101010101,3.2841512161,0.4586234246,-0.3833562278; 2.0202020202,2.7240822717,-0.0615227674,-0.4728230694; 3.0303030303,2.3115622941,-0.3603166834,-0.1677781350. and if we prefer scientific notation we can request that using the numformat=”exp” option; In [28]: file_data_store('expect.dat', output_data.T, numtype=""real"", numformat=""exp""). In [29]: !head -n 5 expect.dat; # Generated by QuTiP: 100x4 real matrix in exp format [',' separated values].; 0.0000000000e+00,4.1221306284e+00,8.1802850776e-01,2.5872436511e-01; 1.0101010101e+00,3.2841512161e+00,4.5862342455e-01,-3.8335622781e-01; 2.0202020202e+00,2.7240822717e+00,-6.1522767387e-02,-4.7282306935e-01; 3.0303030303e+00,2.3115622941e+00,-3.6031668340e-01,-1.6777813499e-01. Loading data previously stored using qutip.fileio.file_data_store (or some other software) is a even easier. Regardless of which deliminator was used, if data was stored as complex or real numbers, if it is in decimal or exponential form, the data can be loaded using the qutip.fileio.file_data_read, which only takes the filename as mandatory argument.; In [30]: input_data = file_data_read('expect.dat'). In [31]: shape(input_data); Out[31]: (100, 4). In [32]: from pylab import *. In [33]: plot(input_data[:,0], input_data[:,1]); # plot the data. (If a particularly obscure choice of deliminator was used it might be necessary to use the optional second argument, for example sep=”_” if _ is the deliminator). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/guide-saving.html:8319,load,loaded,8319,docs/4.1/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.1/guide/guide-saving.html,1,['load'],['loaded']
Performance,d). normalize_gradient_SU() (FidCompUnitary method). normalize_PSU() (FidCompUnitary method). normalize_SU() (FidCompUnitary method). num() (in module qutip.operators). num_ctrls (Dynamics attribute). (DynamicsUnitary attribute). num_dicke_ladders() (in module qutip.piqs). num_dicke_states() (in module qutip.piqs). num_tls() (in module qutip.piqs). O. ode2es() (in module qutip.essolve). onto_evo (Dynamics attribute). onwd_evo (Dynamics attribute). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircuitProcessor method). (CircularSpinChain method). (DispersivecQED method). (LinearSpinChain method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). phase() (in module qutip.operators). phase_application (Dynamics attribute). phase_basis() (in module qutip.states). phasegate() (in module qutip.qip.gates). Pim (class in qutip.piqs). pisolve() (Dicke method). plot_energy_levels() (in module qutip.visualization). plot_expectation_values() (in module qutip.visualization). plot_fock_,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/genindex.html:12019,optimiz,optimizer,12019,docs/4.3/genindex.html,https://qutip.org,https://qutip.org/docs/4.3/genindex.html,1,['optimiz'],['optimizer']
Performance,"d; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['entropy_vn', 'entropy_linear', 'entropy_mutual',; 'concurrence', 'entropy_conditional', 'entangling_power']. from numpy import e, real, sort, sqrt; from scipy import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.qip.gates import swap. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e."");",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/entropy.html:3372,concurren,concurrence,3372,docs/3.1.0/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/entropy.html,1,['concurren'],['concurrence']
Performance,dCompUnitary method). num() (in module qutip.operators). num_ctrls() (Dynamics property). (DynamicsUnitary property). num_dicke_ladders() (in module qutip.piqs). num_tls() (in module qutip.piqs). O. ode2es() (in module qutip.essolve). onto_evo() (Dynamics property). onwd_evo() (Dynamics property). operator_at_cells() (Lattice1d method). operator_between_cells() (Lattice1d method). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircularSpinChain method). (LinearSpinChain method). (SpinChain method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). OptPulseProcessor (class in qutip.qip.device). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). phase() (in module qutip.operators). phase_application() (Dynamics property). phase_basis() (in module qutip.states). phasegate() (in module qutip.qip.gates). photocurrent_mesolve() (in module qutip.stochastic). photocurrent_sesolve() (in module qutip.stochastic). Pim (class in qutip.piqs). pisolve() (Dicke method). plot_berry_curvature() (in module qutip.topology). plot_dispersion() ,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/genindex.html:16100,optimiz,optimizer,16100,docs/4.5/genindex.html,https://qutip.org,https://qutip.org/docs/4.5/genindex.html,1,['optimiz'],['optimizer']
Performance,"daptive number of time steps scaled by the number of sidebands, kmax. (#1961); Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); Change brmesolve to raise an exception when ode integration is not successful. (#1965); Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP’s helper to match. (#1970); Fix correlation for case where only the collapse operators are time dependent. (#1979); Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); Add back .qu suffix to objects saved with qsave and loaded with qload. The suffix was accidentally removed in QuTiP 4.7.0. (#2038); Add a default max_step to processors. (#2040). Documentation¶. Add towncrier for managing the changelog. (#1927); Update the version of numpy used to build documentation to 1.22.0. (#1940); Clarify returned objects from bloch_redfield_tensor(). (#1950); Update Floquet Markov solver docs. (#1958); Update the roadmap and ideas to show completed work as of August 2022. (#1967). Miscellaneous¶. Return TypeError instead of Exception for type error in sesolve argument. (#1924); Add towncrier draft build of changelog to CI tests. (#1946); Add Python 3.11 to builds. (#2041); Simplify version parsing by using packaging.version.Version. (#2043); Update builds to use cibuildwheel 2.11, and to build with manylinux2014 on Python 3.8 and 3.9, since numpy and SciPy no longer support manylinux2010 on those versions of Python. (#2047). Version 4.7.0 (April 13, 2022)¶; This release sees the addition of two new so",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/changelog.html:5808,load,loaded,5808,docs/4.7/changelog.html,https://qutip.org,https://qutip.org/docs/4.7/changelog.html,1,['load'],['loaded']
Performance,"daries for the control amplitudes Can be a scalar value applied to all controls or a list of bounds for each control. bounds; (List of floats) Bounds for the parameters. If not set before the run_optimization call then the list is built automatically based on the amp_lbound and amp_ubound attributes. Setting this attribute directly allows specific bounds to be set for individual parameters. Note: Only some methods use bounds. dynamics; (Dynamics (subclass instance)) describes the dynamics of the (quantum) system to be control optimised (see Dynamics classes for details). config; (OptimConfig instance) various configuration options (see OptimConfig for details). termination_conditions; (TerminationCondition instance) attributes determine when the optimisation will end. pulse_generator; (PulseGen (subclass instance)) (can be) used to create initial pulses not used by the class, but set by pulseoptim.create_pulse_optimizer. stats; (Stats) attributes of which give performance stats for the optimisation set to None to reduce overhead of calculating stats. Note it is (usually) shared with the Dynamics instance. dump; (dump.OptimDump) Container for data dumped during the optimisation. Can be set by specifying the dumping level or set directly. Note this is mainly intended for user and a development debugging but could be used for status information during a long optimisation. dump_to_file; (bool) If set True then data will be dumped to file during the optimisation dumping will be set to SUMMARY during init_optim if dump_to_file is True and dumping not set. Default is False. dump_dir; (string) Basically a link to dump.dump_dir. Exists so that it can be set through optim_params. If dump is None then will return None or will set dumping to SUMMARY when setting a path. iter_summary; (OptimIterSummary) Summary of the most recent iteration. Note this is only set if dummping is on. apply_method_params(params=None)[source]¶; Loops through all the method_params; (either passed here",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:59608,perform,performance,59608,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['perform'],['performance']
Performance,"delity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.minimize could be used. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object. The key value pairs are; as",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:220179,perform,performance,220179,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['perform'],['performance']
Performance,"delity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.minimize could be used. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or; the termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; scipy.optimize.minimize method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object.; The key value pairs are as",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:232292,perform,performance,232292,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['perform'],['performance']
Performance,"delity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float. Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer. Maximum number of iterations of the optimisation algorithm. max_wall_time : float. Maximum allowed elapsed time for the optimisation algorithm. alg : string. Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary. options that are specific to the algorithm see above. optim_params : Dictionary. The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string. a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params : dict. Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string. Deprecated. Use optim_method. max_metric_corr : integer. Deprecated. Use method_params instead. accuracy_factor : float. Deprecated. Use method_params instead. dyn_type : string. Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:147483,optimiz,optimize,147483,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['optimiz'],['optimize']
Performance,"delity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float. Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer. Maximum number of iterations of the optimisation algorithm. max_wall_time : float. Maximum allowed elapsed time for the optimisation algorithm. alg : string. Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary. options that are specific to the algorithm see above. optim_params : Dictionary. The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string. a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params : dict. Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string. Deprecated. Use optim_method. max_metric_corr : integer. Deprecated. Use method_params instead. accuracy_factor : float. Deprecated. Use method_params instead. phase_option : string. determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ onl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:156367,optimiz,optimize,156367,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['optimiz'],['optimize']
Performance,"delity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float. Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer. Maximum number of iterations of the optimisation algorithm. max_wall_time : float. Maximum allowed elapsed time for the optimisation algorithm. alg : string. Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary. options that are specific to the algorithm see above. optim_params : Dictionary. The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string. a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_params : dict. Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string. Deprecated. Use optim_method. max_metric_corr : integer. Deprecated. Use method_params instead. accuracy_factor : float. Deprecated. Use method_params instead. dyn_type : string. Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:164179,optimiz,optimize,164179,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['optimiz'],['optimize']
Performance,"delity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:162272,optimiz,optimize,162272,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"delity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ onl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:171160,optimiz,optimize,171160,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"delity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:178976,optimiz,optimize,178976,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"den in the subclass. dump_summaryboolIf True a summary is recorded each time a new item is added to the; the dump.; Default is True. summary_sepstrdelimiter for the summary file.; default is a space. data_sepstrdelimiter for the data files (arrays saved to file).; default is a space. summary_filestrFile path for summary file.; Automatically generated. Can be set specifically. create_dump_dir()[source]¶; Checks dump directory exists, creates it if not. property level¶; The level of data dumping that will occur. SUMMARYA summary will be recorded. FULLAll possible dumping. CUSTOMSome customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped. class OptimDump(optim, level='SUMMARY')[source]¶; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes. dump_summaryboolWhen True summary items are appended to the iter_summary. iter_summarylist of qutip.control.optimizer.OptimIterSummarySummary at each iteration. dump_fid_errboolWhen True values are appended to the fid_err_log. fid_err_loglist of floatFidelity error at each call of the fid_err_func. dump_grad_normboolWhen True values are appended to the fid_err_log. grad_norm_loglist of floatGradient norm at each call of the grad_norm_log. dump_gradboolWhen True values are appended to the grad_log. grad_loglist of ndarrayGradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. property dump_all¶; True if everything (ignoring the summary) is to be dumped. property dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out to file(s). Parameters. ffilenam",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:276726,optimiz,optimizer,276726,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,1,['optimiz'],['optimizer']
Performance,"der). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:223470,cache,cached,223470,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['cache'],['cached']
Performance,"des to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes:; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and detail",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:76506,optimiz,optimize,76506,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['optimiz'],['optimize']
Performance,"develop and promote it. The ‘Sympsi’ name; is cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages¶. qucontrol-krotov¶. code repository: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz.; Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects¶. data layer abstraction¶. tag; dl-abs. status; majority of development completed. admin lead; Eric. main dev; Jake Lishman. Development completed as a GSoC project. Fully implemented in the dev.major; branch. Currently being used by some research groups.; Abstraction of the linear algebra data from code qutip components, allowing; for alternatives, such as sparse, dense etc. Difficult to summarize. Almost; every file in qutip affected in some way. A major milestone for qutip.; Significant performance improvements throughout qutip.; Some developments tasks remain, including providing full control over how the; data-layer dispatchers choose the most appropriate output type. qutip main reorganization¶. tag; qmain-reorg. status; development [pretty much] complete. admin lead; Eric. main dev; Jake Lishman. Reorganise qutip main components to the structure described above. qutip user docs migration¶. tag; qmain-docs. status; conceptualised. admin lead; TBA; Shahnawaz?. main dev; TBA. The qutip user documentation build files are to be moved to the qutip/qutip; repo. This is more typical for an OSS package.; As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them.; The qutip-doc repo will afterwards just be used for docume",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/roadmap.html:9208,perform,performance,9208,docs/4.6/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html,1,['perform'],['performance']
Performance,"documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Plotting on the Bloch Sphere. Plotting on the Bloch Sphere¶. Introduction¶; When studying the dynamics of a two-level system, it is often convenient to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.bloch.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.bloch3d.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; b = qutip.Bloch(). which will load an instance of the qutip.bloch.Bloch class, or using; >>> b3d = qutip.Bloch3d(). that loads the qutip.bloch3d.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; b.make_sphere(). or. In addition to the show command, see the API documentation for Bloch for a full list of other available functions.; As an example, we can add a single data point:; pnt = [1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)]; b.add_points(pnt); b.render(). and then a single vector:; b.fig.clf(); vec = [0, 1, 0]; b.add_vectors(vec); b.render(). and then add another vector corresponding to the \(\left|\rm up \right>\) state:; up = qutip.basis(2, 0); b.add_states(up); b.render(). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:; b = qutip.Bloch(). pnt = [1./np.sqrt(3), 1./np.sqrt(3), 1./np.sqrt(3)]; b.add_points(p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-bloch.html:1947,load,loads,1947,docs/4.7/guide/guide-bloch.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html,1,['load'],['loads']
Performance,"dom Basis. alg_params : Dictionary; Options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. optim_method : string; A ``scipy.optimize.minimize`` method that will be used to optimise the; pulse for minimum fidelity error. Note that ``FMIN``, ``FMIN_BFGS`` &; ``FMIN_L_BFGS_B`` will all result in calling these specific; ``scipy.optimize methods``. Note the ``LBFGSB`` is equivalent to; ``FMIN_L_BFGS_B`` for backwards compatibility reasons. Supplying DEF; will given alg dependent result:. - GRAPE - Default ``optim_method`` is ``FMIN_L_BFGS_B``; - CRAB - Default ``optim_method`` is ``FMIN``. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~qutip.control.optimizer.Optimizer` object or; the termination_conditions matching the key that attribute.; Otherwise, and in some case also, they are assumed to be method_options; for the ``scipy.optimize.minimize`` method. optim_alg : string; Deprecated. Use ``optim_method``. max_metric_corr : integer; Deprecated. Use ``method_params`` instead. accuracy_factor : float; Deprecated. Use ``method_params`` instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe the dynamics.; Options are ``UNIT``, ``GEN_MAT``, ``SYMPL``; (see :obj:`~qutip.control.dynamics.Dynamics` classes for details). dyn_params : dict; Parameters for the :obj:`~qutip.control.dynamics.Dynamics` object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the propagators and; propagator gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT. DEF will use the default ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:8174,optimiz,optimizer,8174,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimizer']
Performance,"dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more informatio",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:84784,perform,performance,84784,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['perform'],['performance']
Performance,"dynamics of the (quantum) system. to be control optimised. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params¶; Dictionary – The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg¶; string – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params¶; Dictionary – options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg¶; bool – Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method¶; string – a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_params¶; Dictionary – Options for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_grad¶; bool – If set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound¶; float or list of floats – lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound¶; float or list of floats – upper boundaries for the control amplitudes; Can be a scalar value",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:60544,optimiz,optimize,60544,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['optimiz'],['optimize']
Performance,"e assumed to be attribute name value pairs.; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimizerInstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object,; e.g. optimizer.dynamics.fid_computer The optimisation can be run; through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:220143,optimiz,optimizer,220143,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['optimiz'],['optimizer']
Performance,"e attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:; opt : Optimizer; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:183858,optimiz,optimizer,183858,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['optimiz'],['optimizer']
Performance,"e dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Thus, we must yet again go dense.; return la.norm(op.full(), 2). # If we're still here, we need to actually solve the problem. # Assume square...; dim = np.prod(J.dims[0][0]). J_dat = J.data. if not sparse:; # The parameters and constraints only depend on the dimension, so; # we can cache them efficiently.; problem, Jr, Ji = dnorm_problem(dim). # Load the parameters with the Choi matrix passed in.; Jr.value = sp.csr_matrix((J_dat.data.real, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(). Ji.value = sp.csr_matrix((J_dat.data.imag, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(); else:. # The parameters do not depend solely on the dimension,; # so we can not cache them efficiently.; problem = dnorm_sparse_problem(dim, J_dat). problem.solve(solver=solver, verbose=verbose). return problem.value. def unitarity(oper):; """"""; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map's superoperator representation. Parameters; ----------; oper : Qobj; Quantum map under consideration. Returns; -------; u : float; Unitarity of ``oper``.; """"""; Eu = _super_to_superpauli(oper).full()[1:, 1:]; #return np.real(np.trace(np.dot(Eu, Eu.conj().T))) / len(Eu); return np.linalg.norm(Eu, 'fro')**2 / len(Eu). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/metrics.html:14252,cache,cache,14252,docs/4.6/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/metrics.html,1,['cache'],['cache']
Performance,"e factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; ``alg_params`` (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by ``alg_params`` (if given there). optim_method : string; Multi-variable optimisation method. The only tested options are 'fmin'; and 'Nelder-mead'. In theory any non-gradient method implemented in; ``scipy.optimize.minimize`` could be used. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~Optimizer` object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the ``scipy.optimize.minimize``; method. The commonly used parameter are:. - xtol - limit on variable change for convergence; - ftol - limit on fidelity error change for convergence. phase_option : string; Determines how global phase is treated in fidelity calculations; (``fid_type='UNIT'`` only). Options:. - PSU - global phase ignored; - SU - global phase included. dyn_params : dict; Parameters for the :obj:`~Dynamics` object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_params : dict; Parameters for the :obj:`~PropagatorComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_params : dict; Parameters for the :obj:`~FidelityComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. tslot_type : string; Method for computing the dynamics generators, propagators and evolution; in the timeslots",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:45107,optimiz,optimize,45107,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimize']
Performance,"e function that is to be called for each value in task_vec. valuesarray / listThe list or array of values for which the task function is to be; evaluated. task_argslist / dictionaryThe optional additional argument to the task function. task_kwargslist / dictionaryThe optional additional keyword argument to the task function. progress_barProgressBarProgress bar class instance for showing progress. Returns. resultlistThe result list contains the value of; task(value, *task_args, **task_kwargs) for each; value in values. IPython Notebook Tools¶; This module contains utility functions for using QuTiP with IPython notebooks. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. task_vec: array / listThe list or array of values for which the task function is to be; evaluated. args: list / dictionaryThe optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:210457,load,load-balanced,210457,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['load'],['load-balanced']
Performance,"e matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters. braqutip.QobjQuantum object of type ‘bra’ or ‘ket’. ketqutip.QobjQuantum object of type ‘ket’. Returns. elemcomplexComplex valued matrix element. Notes; It is slightly more computationally efficient to use a ket; vector for the ‘bra’ input. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters. normstrWhich norm to use for ket/bra vectors: L2 ‘l2’, max norm ‘max’,; or for operators: trace ‘tr’, Frobius ‘fro’, one ‘one’, or max; ‘max’. sparseboolUse sparse eigenvalue solver for trace norm. Other norms are not; affected by this parameter. tolfloatTolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used); for trace norm. Returns. normfloatThe requested norm of the operator or state quantum object. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. overlap(other)[source]¶; Overlap between two state vectors or two operators.; Gives the overlap (inner product) between the current bra or ket Qobj; and and another bra or ket Qobj. It gives the Hilbert-Schmidt overlap; when one of the Qobj is an operator/density matrix. Parameters. otherqutip.QobjQuantum object for a state vector of type ‘ket’, ‘bra’ or density; matrix. Returns. overlapcomplexComplex valued overlap. Raises. TypeErrorCan only calculate overlap between a bra, ket and density matrix; quantum objects. Notes; Since QuTiP mainly deals with ket vectors, the most efficient inner; product call is the ket-ket version that computes the product; <self|other> with both vectors expressed as kets. permute(order)[source]¶; Permutes a composite",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:12310,perform,performed,12310,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['perform'],['performed']
Performance,"e name value pairs.; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object,; e.g. optimizer.dynamics.fid_computer The optimisation can be run; through the optimizer.run_optimization. """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""). # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""). if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in method_params:; method_params['accuracy_factor'] = ac",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:58337,optimiz,optimizer,58337,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimizer']
Performance,"e of :class:`qutip.Qobj` that contains only the states; corresponding to indices that are **not** in `state_inds`. Notes; -----; Experimental. """"""; keep_indices = np.array([s not in states_inds; for s in range(self.shape[0])]).nonzero()[0]. return self.extract_states(keep_indices, normalize=normalize). [docs] def dnorm(self, B=None):; """"""Calculates the diamond norm, or the diamond distance to another; operator. Parameters; ----------; B : Qobj or None; If B is not None, the diamond distance d(A, B) = dnorm(A - B) between; this operator and B is returned instead of the diamond norm. Returns; -------; d : float; Either the diamond norm of this operator, or the diamond distance; from this operator to B. """"""; return mts.dnorm(self, B). @property; def ishp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = sr.to_choi(self); return J.isherm; except:; return False; else:; return False. @property; def iscp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = (; self; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.superrep in ('choi', 'chi'); else sr.to_choi(self); ); # If J isn't hermitian, then that could indicate either; # that J is not normal, or is normal, but has complex eigenvalues.; # In either case, it makes no sense to then demand that the; # eigenvalues be non-negative.; if not J.isherm:; return False; eigs = J.eigenenergies(); return all(eigs >= -settings.atol); except:; return False; else:; return False. @property; def istp(self):; import qutip.superop_reps as sr; if self.type in [""super"", ""oper""]:; try:; # Normalize to a super of type choi or chi.; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.type == ""super"" and self.super",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/qobj.html:43443,cache,cached,43443,docs/4.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html,3,['cache'],['cached']
Performance,"e pulse optimisation so far (in seconds of elapsed time). class TerminationConditions[source]¶; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used; Attributes. fid_err_targ; (float) Target fidelity error. fid_goal; (float) goal fidelity, e.g. 1 - self.fid_err_targ It its typical to set this for unitary systems. max_wall_time; (float) # maximum time for optimisation (seconds). min_gradient_norm; (float) Minimum normalised gradient after which optimisation will terminate. max_iterations; (integer) Maximum iterations of the optimisation algorithm. max_fid_func_calls; (integer) Maximum number of calls to the fidelity function during the optimisation algorithm. accuracy_factor; (float) Determines the accuracy of the result. Typical values for accuracy_factor are: 1e12 for low accuracy; 1e7 for moderate accuracy; 10.0 for extremely high accuracy scipy.optimize.fmin_l_bfgs_b factr argument. Only set for specific methods (fmin_l_bfgs_b) that uses this Otherwise the same thing is passed as method_option ftol (although the scale is different) Hence it is not defined here, but may be set by the user. class OptimResult[source]¶; Attributes give the result of the pulse optimisation attempt; Attributes. termination_reason; (string) Description of the reason for terminating the optimisation. fidelity; (float) final (normalised) fidelity that was achieved. initial_fid_err; (float) fidelity error before optimisation starting. fid_err; (float) final fidelity error that was achieved. goal_achieved; (boolean) True is the fidely error achieved was below the target. grad_norm_final; (float) Final value of the sum of the squares of the (normalised) fidelity error gradients. grad_norm_min_reached; (float) True if the optimisation terminated due to the minimum value of the gradient being reached. num_iter; (integer) Number of iterations of the optimisation",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:70484,optimiz,optimize,70484,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['optimiz'],['optimize']
Performance,"e system at time \(\tau\) into one of the renormalized states given by Eq. (3). The corresponding collapse operator \(C_{n}\) is chosen such that \(n\) is the smallest integer satisfying:. (5)\[\sum_{i=1}^{n} P_{i}(\tau) \ge r\]; where the individual \(P_{n}\) are given by Eq. (4). Note that the left hand side of Eq. (5) is, by definition, normalized to unity. IV: Using the renormalized state from step III as the new initial condition at time \(\tau\), draw a new random number, and repeat the above procedure until the final simulation time is reached. Monte Carlo in QuTiP¶; In QuTiP, Monte Carlo evolution is implemented with the qutip.mcsolve function. It takes nearly the same arguments as the qutip.mesolve; function for master-equation evolution, except that the initial state must be a ket vector, as oppose to a density matrix, and there is an optional keyword parameter ntraj that defines the number of stochastic trajectories to be simulated. By default, ntraj=500 indicating that 500 Monte Carlo trajectories will be performed.; To illustrate the use of the Monte Carlo evolution of quantum systems in QuTiP, let’s again consider the case of a two-level atom coupled to a leaky cavity. The only differences to the master-equation treatment is that in this case we invoke the qutip.mcsolve function instead of qutip.mesolve; In [1]: times = np.linspace(0.0, 10.0, 200). In [2]: psi0 = tensor(fock(2, 0), fock(10, 5)). In [3]: a = tensor(qeye(2), destroy(10)). In [4]: sm = tensor(destroy(2), qeye(10)). In [5]: H = 2 * np.pi * a.dag() * a + 2 * np.pi * sm.dag() * sm + 2 * np.pi * 0.25 * (sm * a.dag() + sm.dag() * a). In [6]: data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); 10.0%. Run time: 1.27s. Est. time left: 00:00:00:11; 20.0%. Run time: 2.44s. Est. time left: 00:00:00:09; 30.0%. Run time: 3.64s. Est. time left: 00:00:00:08; 40.0%. Run time: 4.82s. Est. time left: 00:00:00:07; 50.0%. Run time: 5.98s. Est. time left: 00:00:00:05; 60.0%. Run ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-monte.html:5486,perform,performed,5486,docs/3.1.0/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-monte.html,1,['perform'],['performed']
Performance,"e system at time \(\tau\) into one of the renormalized states given by Eq. (3). The corresponding collapse operator \(C_{n}\) is chosen such that \(n\) is the smallest integer satisfying:. (5)\[\sum_{i=1}^{n} P_{n}(\tau) \ge r\]; where the individual \(P_{n}\) are given by Eq. (4). Note that the left hand side of Eq. (5) is, by definition, normalized to unity. IV: Using the renormalized state from step III as the new initial condition at time \(\tau\), draw a new random number, and repeat the above procedure until the final simulation time is reached. Monte Carlo in QuTiP¶; In QuTiP, Monte Carlo evolution is implemented with the qutip.mcsolve function. It takes nearly the same arguments as the qutip.mesolve; function for master-equation evolution, except that the initial state must be a ket vector, as oppose to a density matrix, and there is an optional keyword parameter ntraj that defines the number of stochastic trajectories to be simulated. By default, ntraj=500 indicating that 500 Monte Carlo trajectories will be performed.; To illustrate the use of the Monte Carlo evolution of quantum systems in QuTiP, let’s again consider the case of a two-level atom coupled to a leaky cavity. The only differences to the master-equation treatment is that in this case we invoke the qutip.mcsolve function instead of qutip.mesolve:; from qutip import *; from pylab import *. times = linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 5)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); H = 2 * pi * a.dag() * a + 2 * pi * sm.dag() * sm + \; 2 * pi * 0.25 * (sm * a.dag() + sm.dag() * a); # run Monte Carlo solver; data = mcsolve(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); plot(times, data.expect[0], times, data.expect[1]); title('Monte Carlo time evolution'); xlabel('Time'); ylabel('Expectation values'); legend((""cavity photon number"", ""atom excitation probability"")); show(). The advantage of the Monte Carlo method over the master equ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html:5384,perform,performed,5384,docs/3.0.0/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html,2,['perform'],['performed']
Performance,"e vector (ket).; tlist (list / array) – list of times for \(t\).; e_ops (list of qutip.qobj / callback function) – list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values.; T (float) – The period of the time-dependence of the hamiltonian.; args (dictionary) – Dictionary with variables required to evaluate H.; Tsteps (integer) – The number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns:output – An instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Return type:qutip.solver.Result. Stochastic Schrödinger Equation and Master Equation¶; This module contains functions for solving stochastic schrodinger and master; equations. The API should not be considered stable, and is subject to change; when we work more on optimizing this module for performance and features. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters:; H (qutip.Qobj) – System Hamiltonian.; rho0 (qutip.Qobj) – Initial density matrix or state vector (ket).; times (list / array) – List of times for \(t\). Must be uniformly spaced.; c_ops (list of qutip.Qobj) – Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; sc_ops (list of qutip.Qobj) – List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; e_ops (list of qutip.Qobj / callback function single) – single operator or list of operators for which to evaluate; expectation values.; kwargs (diction",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:76075,optimiz,optimizing,76075,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,2,"['optimiz', 'perform']","['optimizing', 'performance']"
Performance,"e)) Used to compute the propagators and their gradients. fid_computer; (FidelityComputer (subclass instance)) Used to computer the fidelity error and the fidelity error gradient. memory_optimization; (int) Level of memory optimisation. Setting to 0 (default) means that execution speed is prioritized over memory. Setting to 1 means that some memory prioritisation steps will be taken, for instance using Qobj (and hence sparse arrays) as the the internal operator data type, and not caching some operators Potentially further memory saving maybe made with memory_optimization > 1. The options are processed in _set_memory_optimizations, see this for more information. Individual memory saving options can be switched by settting them directly (see below). oper_dtype; (type) Data type for internal dynamics generators, propagators and time evolution operators. This can be ndarray or Qobj, or (in theory) any other representaion that supports typical matrix methods (e.g. dot) ndarray performs best for smaller quantum systems. Qobj may perform better for larger systems, and will also perform better when (custom) fidelity measures use Qobj methods such as partial trace. See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_gen; (bool) If True then the dynamics generators will be saved with and without the propagation prefactor (if there is one) Defaults to True when memory_optimization=0, otherwise False. cache_prop_grad; (bool) If the True then the propagator gradients (for exact gradients) will be computed when the propagator are computed and cache until the are used by the fidelity computer. If False then the fidelity computer will calculate them as needed. Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: bool; If True then DynamicsUnitary will cached the adjoint of the Hamiltion eignvector matrix Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: bool; If True then Dynamic",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:75185,perform,performs,75185,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['perform'],['performs']
Performance,e). bures_angle() (in module qutip.metrics). bures_dist() (in module qutip.metrics). C. calculate() (Stats method). charge() (in module qutip.operators). check_herm() (Qobj method). check_unitarity() (DynamicsUnitary method). CircuitProcessor (class in qutip.qip.models). CircularSpinChain (class in qutip.qip.models.spinchain). clear() (Bloch method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). combine_dyn_gen() (Dynamics method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method). controlled_gate() (in module qutip.qip.gates). convert_unit() (in module qutip.utilities). copy() (Qobj method). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_3op_1t() (in module qutip.correlation). correlation_3op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). cosm() (Qobj method). covariance_matrix() (in module qutip.continuous_variables). cphase() (in module qutip.qip.gates). create() (in module qutip.operators). create_dump_dir() (Dump,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/genindex.html:2612,concurren,concurrence,2612,docs/4.1/genindex.html,https://qutip.org,https://qutip.org/docs/4.1/genindex.html,2,['concurren'],['concurrence']
Performance,"e)[source]¶; Calculates the diamond norm, or the diamond distance to another; operator. Parameters. Bqutip.Qobj or NoneIf B is not None, the diamond distance d(A, B) = dnorm(A - B); between this operator and B is returned instead of the diamond; norm. Returns. dfloatEither the diamond norm of this operator, or the diamond distance; from this operator to B. dual_chan()[source]¶; Dual channel of quantum object representing a completely positive; map. eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]¶; Eigenenergies of a quantum object.; Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters. sparseboolUse sparse Eigensolver. sortstrSort eigenvalues ‘low’ to high, or ‘high’ to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). Returns. eigvalsarrayArray of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000, phase_fix=None)[source]¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters. sparseboolUse sparse Eigensolver. sortstrSort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). phase_fixint, NoneIf not None, set the phase of each kets so that ket[phase_fix,0]; is real positive. Returns. eigvalsarrayArray of eigenvalues for operator. eigvecsarra",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:6387,perform,performed,6387,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['perform'],['performed']
Performance,"e, c2=None, notrace=False)[source]¶; Compute propagator for computing output field expectation values; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters:; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : qutip.Qobj; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : qutip.Qobj; system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notrace : bool {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns:; : :class:`qutip.Qobj`; time-propagator for computing field correlation function. propagator(t, tau, notrace=False)[source]¶; Compute propagator for time t and time-delay tau. Parameters:; t : float; current time. tau : float; time-delay. notrace : bool {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns. ——-. : :class:`qutip.Qobj`; time-propagator for reduced system dynamics. rhot(rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters:; rho0 : qutip.Qobj; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns:; : :class:`qutip.Qobj`; density matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:31357,perform,performed,31357,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['perform'],['performed']
Performance,"e, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; ; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:9322,optimiz,optimize,9322,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,6,['optimiz'],['optimize']
Performance,"e, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm; ; alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; - GRAPE - Default optim_method is FMIN_L_BFGS_B; - CRAB - Default optim_method is Nelder-Mead; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is cr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:54051,optimiz,optimize,54051,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,6,['optimiz'],['optimize']
Performance,"e-delay. c1qutip.Qobjsystem collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns. : qutip.Qobjtime-propagator for computing field correlation function. propagator(self, t, tau, notrace=False)[source]¶; Compute propagator for time t and time-delay tau. Parameters. tfloatcurrent time. taufloattime-delay. notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; ——-; : :class:`qutip.Qobj`time-propagator for reduced system dynamics. rhot(self, rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). tfloatcurrent time. taufloattime-delay. Returns. : qutip.Qobjdensity matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options for the Transfer Tensor Method solver. Attributes. dynmapslist of qutip.QobjList of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. timesarray_likeList of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimesarray_likeList of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thresfloatThreshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. optionsqutip.s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:37460,perform,performed,37460,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['perform'],['performed']
Performance,"e:; raise TypeError('Invalid operand for matrix square root'). [docs] def inv(self, sparse=False):; """"""Matrix inverse of a quantum operator. Operator must be square. Returns; -------; oper : :class:`qutip.Qobj`; Matrix inverse of operator. Raises; ------; TypeError; Quantum object is not square.; """"""; if self.shape[0] != self.shape[1]:; raise TypeError('Invalid operand for matrix inverse'); if sparse:; inv_mat = sp.linalg.inv(sp.csc_matrix(self.data)); else:; inv_mat = np.linalg.inv(self.full()); return Qobj(inv_mat, dims=self.dims[::-1]). [docs] def unit(self, inplace=False,; norm=None, sparse=False,; tol=0, maxiter=100000):; """"""Operator or state normalized to unity. Uses norm from Qobj.norm(). Parameters; ----------; inplace : bool; Do an in-place normalization; norm : str; Requested norm for states / operators.; sparse : bool; Use sparse eigensolver for trace norm. Does not affect other norms.; tol : float; Tolerance used by sparse eigensolver.; maxiter : int; Number of maximum iterations performed by sparse eigensolver. Returns; -------; oper : :class:`qutip.Qobj`; Normalized quantum object if not in-place,; else None. """"""; if inplace:; nrm = self.norm(norm=norm, sparse=sparse,; tol=tol, maxiter=maxiter). self.data /= nrm; elif not inplace:; out = self / self.norm(norm=norm, sparse=sparse,; tol=tol, maxiter=maxiter); if settings.auto_tidyup:; return out.tidyup(); else:; return out; else:; raise Exception('inplace kwarg must be bool.'). [docs] def ptrace(self, sel, sparse=None):; """"""Partial trace of the quantum object. Parameters; ----------; sel : int/list; An ``int`` or ``list`` of components to keep after partial trace. Returns; -------; oper : :class:`qutip.Qobj`; Quantum object representing partial trace with selected components; remaining. Notes; -----; This function is identical to the :func:`qutip.qobj.ptrace` function; that has been deprecated. """"""; if sparse is None:; if self.isket:; sparse = False; elif (self.data.nnz / (self.shape[0] * self.shape[1]))",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobj.html:33666,perform,performed,33666,docs/4.5/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobj.html,1,['perform'],['performed']
Performance,"e:; raise TypeError('Invalid operand for matrix square root'). [docs] def inv(self, sparse=False):; """"""Matrix inverse of a quantum operator. Operator must be square. Returns; -------; oper : :class:`qutip.Qobj`; Matrix inverse of operator. Raises; ------; TypeError; Quantum object is not square.; """"""; if self.shape[0] != self.shape[1]:; raise TypeError('Invalid operand for matrix inverse'); if sparse:; inv_mat = sp.linalg.inv(sp.csc_matrix(self.data)); else:; inv_mat = np.linalg.inv(self.full()); return Qobj(inv_mat, dims=self.dims[::-1]). [docs] def unit(self, inplace=False,; norm=None, sparse=False,; tol=0, maxiter=100000):; """"""Operator or state normalized to unity. Uses norm from Qobj.norm(). Parameters; ----------; inplace : bool; Do an in-place normalization; norm : str; Requested norm for states / operators.; sparse : bool; Use sparse eigensolver for trace norm. Does not affect other norms.; tol : float; Tolerance used by sparse eigensolver.; maxiter : int; Number of maximum iterations performed by sparse eigensolver. Returns; -------; oper : :class:`qutip.Qobj`; Normalized quantum object if not in-place,; else None. """"""; if inplace:; nrm = self.norm(norm=norm, sparse=sparse,; tol=tol, maxiter=maxiter). self.data /= nrm; elif not inplace:; out = self / self.norm(norm=norm, sparse=sparse,; tol=tol, maxiter=maxiter); if settings.auto_tidyup:; return out.tidyup(); else:; return out; else:; raise Exception('inplace kwarg must be bool.'). [docs] def ptrace(self, sel, sparse=None):; """"""Partial trace of the quantum object. Parameters; ----------; sel : int/list; An ``int`` or ``list`` of components to keep after partial trace.; The order is unimportant; no transposition will be done and the; spaces will remain in the same order in the output. Returns; -------; oper : :class:`qutip.Qobj`; Quantum object representing partial trace with selected components; remaining. Notes; -----; This function is identical to the :func:`qutip.qobj.ptrace` function; that has been depre",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobj.html:34419,perform,performed,34419,docs/4.6/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html,2,['perform'],['performed']
Performance,e_gradient_SU() (FidCompUnitary method). normalize_PSU() (FidCompUnitary method). normalize_SU() (FidCompUnitary method). num() (in module qutip.operators). num_ctrls() (Dynamics property). (DynamicsUnitary property). num_dicke_ladders() (in module qutip.piqs). num_tls() (in module qutip.piqs). O. ode2es() (in module qutip.essolve). onto_evo() (Dynamics property). onwd_evo() (Dynamics property). operator_at_cells() (Lattice1d method). operator_between_cells() (Lattice1d method). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircularSpinChain method). (LinearSpinChain method). (SpinChain method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). OptPulseProcessor (class in qutip.qip.device). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). phase() (in module qutip.operators). phase_application() (Dynamics property). phase_basis() (in module qutip.states). phasegate() (in module qutip.qip.gates). photocurrent_mesolve() (in module qutip.stochastic). photocurrent_sesolve() (in module qutip.stochastic). Pim (class in qutip.pi,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/genindex.html:16000,optimiz,optimizer,16000,docs/4.5/genindex.html,https://qutip.org,https://qutip.org/docs/4.5/genindex.html,1,['optimiz'],['optimizer']
Performance,"e_params); guess_pulse_action = init_pulse_params.get('pulse_action'). optim.pulse_generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params); ; lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub; ; if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action; ; if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]; ; else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__). return optim. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:68983,optimiz,optimizer,68983,docs/4.3/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimizer']
Performance,"e_up == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params). # Currently the only working option for tslot computer is; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params). # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn). optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params). # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc. optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; #",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:65342,optimiz,optimizer,65342,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,2,['optimiz'],['optimizer']
Performance,"easure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes:; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes:; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:107158,cache,cached,107158,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['cache'],['cached']
Performance,"ect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve; >>> a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> psi0 = rand_ket(10); >>> times = np.linspace(0, 10, 10); >>> dm_list = mesolve(H, psi0, times, c_ops, []); >>> qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program; >>> dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0; >>> a = destroy(10); >>> expect(a.dag() * a, dm_list_loaded.states) ; array([4.63317086, 3.59150315, 2.90590183, 2.41306641, 2.05120716,; 1.78312503, 1.58357995, 1.4346382 , 1.32327398, 1.23991233]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes two mandatory and three optional arguments:; >>> file_data_store(filename, data, numtype=""complex"", numformat=""decimal"", sep="","") . where filename is the name of the file, data is the data to be written to the file (must be a numpy array), numtype (optional) is a flag indicating numerical type that can take values complex or real, numformat (optional) specifies the numerical format that can take the ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-saving.html:3874,load,loading,3874,docs/4.6/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-saving.html,2,['load'],['loading']
Performance,"ects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Parallel computation. Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; In [1]: def func1(x): return x, x**2, x**3. In [2]: a, b, c = parfor(func1, range(10)). In [3]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [4]: print(b); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-parfor.html:1222,perform,performing,1222,docs/4.2/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-parfor.html,5,['perform'],['performing']
Performance,"ed eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). Returns. eigvalsarrayArray of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(self, sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters. sparseboolUse sparse Eigensolver. sortstrSort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). Returns. eigvalsarrayArray of eigenvalues for operator. eigvecsarrayArray of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eliminate_states(self, states_inds, normalize=False)[source]¶; Creates a new quantum object with states in state_inds eliminated. Parameters. states_indslist of integerThe states that should be removed. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. Notes; Expe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:7067,perform,performed,7067,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['perform'],['performed']
Performance,"ed if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method. The only tested options are 'fmin'; and 'Nelder-mead'. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. Note that where there is an attribute; of the :class:`~qutip.control.optimizer.Optimizer` object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; ``scipy.optimize.minimize`` method. The commonly used parameter are:. - xtol - limit on variable change for convergence; - ftol - limit on fidelity error change for convergence. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_params : dict; Parameters for the :class:`qutip.control.dynamics.Dynamics` object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT DEF will use the default for the specific dyn_type; (see :obj:`~qutip.control.propcomp.PropagatorComputer` classes for; d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:32854,optimiz,optimizer,32854,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimizer']
Performance,"ed into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refineint, default 10MKL ONLY. Max. number of iterative refinements to perform. scaling_vectorsboolMKL ONLY. Scale matrix to unit norm columns and rows. weighted_matchingboolMKL ONLY. Use weighted matching to better condition diagonal. x0ndarray, optionalITERATIVE ONLY. Initial guess for solution vector. maxiterint, default 1000ITERATIVE ONLY. Maximum number of iterations to perform. tolfloat, default 1e-12ITERATIVE ONLY. Tolerance used for terminating solver. mtolfloat, optionalITERATIVE ‘power’ methods ONLY. Tolerance for lu solve method. If None; given then max(0.1*tol, 1e-15) is used. matolfloat, default 1e-15ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_specstr, optionalITERATIVE ONLY. Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ (default); and ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. use_precondbool, default FalseITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers. Speeds up; convergence time by orders of magnitude in many cases. M{sparse matrix, dense matrix, LinearOperator}, optionalITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:137360,perform,perform,137360,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['perform'],['perform']
Performance,"ed to create arbitrary time-dependent Hamiltonians and collapse operators.; Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. Important; This breaks compatibility with QuTiP version 1.x. mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed.; QuTiP includes functions for creating random quantum states and operators.; The generation and manipulation of quantum objects is now more efficient.; Quantum objects have basis transformation and matrix element calculations as built-in methods.; The quantum object eigensolver can use sparse solvers.; The partial-trace (ptrace) function is up to 20x faster.; The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure.; QuTiP has built-in functions for saving quantum objects and data arrays.; The steady-state solver has been further optimized for sparse matrices, and can handle much larger system Hamiltonians.; The steady-state solver can use the iterative bi-conjugate gradient method instead of a direct solver.; There are three new entropy functions for concurrence, mutual information, and conditional entropy.; Correlation functions have been combined under a single function.; The operator norm can now be set to trace, Frobius, one, or max norm.; Global QuTiP settings can now be modified.; QuTiP includes a collection of unit tests for verifying the installation.; Demos window now lets you copy and paste code from each example. Version 1.1.4 (May 28, 2012):¶. Bug Fixes:¶. Fixed bug pointed out by Brendan Abolins.; Qobj.tr() returns zero-dim ndarray instead of float or complex.; Updated factorial import for scipy version 0.10+. Version 1.1.3 (November 21, 2011):¶. New Functions:¶. Allow custom naming of Bloch sphere. Bug Fixes:¶. Fixed text alignment issues in AboutBox.; Added fix for SciPy V>0.10 where factorial was moved to scipy.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/changelog.html:10169,optimiz,optimized,10169,docs/3.0.0/changelog.html,https://qutip.org,https://qutip.org/docs/3.0.0/changelog.html,9,['optimiz'],['optimized']
Performance,"ed to create arbitrary time-dependent Hamiltonians and collapse operators.; Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. Important; This breaks compatibility with QuTiP version 1.x. mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed.; QuTiP includes functions for creating random quantum states and operators.; The generation and manipulation of quantum objects is now more efficient.; Quantum objects have basis transformation and matrix element calculations as built-in methods.; The quantum object eigensolver can use sparse solvers.; The partial-trace (ptrace) function is up to 20x faster.; The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure.; QuTiP has built-in functions for saving quantum objects and data arrays.; The steady-state solver has been further optimized for sparse matrices, and can handle much larger system Hamiltonians.; The steady-state solver can use the iterative bi-conjugate gradient method instead of a direct solver.; There are three new entropy functions for concurrence, mutual information, and conditional entropy.; Correlation functions have been combined under a single function.; The operator norm can now be set to trace, Frobius, one, or max norm.; Global QuTiP settings can now be modified.; QuTiP includes a collection of unit tests for verifying the installation.; Demos window now lets you copy and paste code from each example. Version 1.1.4 (May 28, 2012)¶. Bug Fixes¶. Fixed bug pointed out by Brendan Abolins.; Qobj.tr() returns zero-dim ndarray instead of float or complex.; Updated factorial import for scipy version 0.10+. Version 1.1.3 (November 21, 2011)¶. New Functions¶. Allow custom naming of Bloch sphere. Bug Fixes¶. Fixed text alignment issues in AboutBox.; Added fix for SciPy V>0.10 where factorial was moved to scipy.misc ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:44485,optimiz,optimized,44485,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['optimiz'],['optimized']
Performance,"edfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide.html:2897,load,loading,2897,docs/4.7/guide/guide.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide.html,2,['load'],['loading']
Performance,"eduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations.; This is the first release to have full binary wheel releases on pip; you can now do pip install qutip on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. python -mbuild /path/to/qutip), all build dependencies will be correctly satisfied. Improvements¶. MAJOR Add saving, loading and resetting functionality to qutip.settings for easy re-configuration. (by Eric Giguère); MAJOR Add a quantum gate scheduler in qutip.qip.scheduler, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by Boxi Li); MAJOR Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by Sidhant Saraogi); MAJOR Add tools for quantum measurements and their statistics. (by Simon Cross and Sidhant Saraogi); Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint.; Improve the error message when circuit plotting fails. (by Boxi Li); Add support for parsing M1 Mac hardware information. (by Xiaoliang Wu); Add more single-qubit gates and controlled gates. (by Mateo Laguna and Martín Sande Costa); Support decomposition of X, Y and Z gates in circuits. (by Boxi Li); Refactor QubitCircuit.resolve_gate() (by Martín Sande Costa). Bug Fixes¶. Fix dims in the returns from Qobj.eigenstates on superoperators. (by Jake Lishman); Calling Numpy ufuncs on Qobj will now correctly raise a TypeError rather than returning",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:12370,perform,performance,12370,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['perform'],['performance']
Performance,"ee above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying; DEF will given algorithm-dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_paramsdictParameters for the FidelityComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. tslot_typestringMethod for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC.;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:237314,optimiz,optimize,237314,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"ee above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying; DEF will given algorithm-dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or; the termination_conditions matching the key that attribute.; Otherwise, and in some case also, they are assumed to be; method_options for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_paramsdictParameters for the PropagatorComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. fid_paramsdictParameters for the FidelityComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. tslot_typestringMethod for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC.;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:249432,optimiz,optimize,249432,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"een tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Opti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:195593,optimiz,optimize,195593,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['optimiz'],['optimize']
Performance,"een tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes:; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:75831,optimiz,optimize,75831,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['optimiz'],['optimize']
Performance,"een tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. max_metric_corr¶; integer – The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:67948,optimiz,optimize,67948,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['optimiz'],['optimize']
Performance,"een tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm; Attributes. max_metric_corr; (integer) The maximum number of variable metric corrections used to define the limited memory matrix. That is the number of previous gradient values that are used to approximate the Hessian see the scipy.optimize.fmin_l_bfgs_b documentation for description of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Opt",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:64946,optimiz,optimize,64946,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['optimiz'],['optimize']
Performance,"efloatTime spent computing the pulse optimisation so far; (in seconds of elapsed time). class TerminationConditions[source]¶; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes. fid_err_targfloatTarget fidelity error. fid_goalfloatgoal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_timefloat# maximum time for optimisation (seconds). min_gradient_normfloatMinimum normalised gradient after which optimisation will terminate. max_iterationsintegerMaximum iterations of the optimisation algorithm. max_fid_func_callsintegerMaximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factorfloatDetermines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]¶; Attributes give the result of the pulse optimisation attempt. Attributes. termination_reasonstringDescription of the reason for terminating the optimisation. fidelityfloatfinal (normalised) fidelity that was achieved. initial_fid_errfloatfidelity error before optimisation starting. fid_errfloatfinal fidelity error that was achieved. goal_achievedbooleanTrue is the fidely error achieved was below the target. grad_norm_finalfloatFinal value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reachedfloatTrue if the optimisation terminated due to the minimum value; of the gradient being reached. num_iterintegerNumber of iterations of the optimisation algorithm completed. max_iter_exc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:87239,optimiz,optimize,87239,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,4,['optimiz'],['optimize']
Performance,"elds). H_ops: list of Qobj. A list of operators that can be tuned in the Hamiltonian via the; control fields. R : int. Number of GRAPE iterations. time : array / list. Array of time coordinates for control pulse evalutation. u_start : array. Optional array with initial control pulse values. Returns:Instance of GRAPEResult, which contains the control pulses calculated. with GRAPE, a time-dependent Hamiltonian that is defined by the; control pulses, as well as the resulting propagator. grape_unitary_adaptive(U, H0, H_ops, R, times, eps=None, u_start=None, u_limits=None, interp_kind='linear', use_interp=False, alpha=None, beta=None, phase_sensitive=False, overlap_terminate=1.0, progress_bar=<qutip.ui.progressbar.BaseProgressBar object at 0x107be58d0>)[source]¶; Calculate control pulses for the Hamiltonian operators in H_ops so that; the unitary U is realized.; Experimental: Work in progress. Parameters:U : Qobj. Target unitary evolution operator. H0 : Qobj. Static Hamiltonian (that cannot be tuned by the control fields). H_ops: list of Qobj. A list of operators that can be tuned in the Hamiltonian via the; control fields. R : int. Number of GRAPE iterations. time : array / list. Array of time coordinates for control pulse evalutation. u_start : array. Optional array with initial control pulse values. Returns:Instance of GRAPEResult, which contains the control pulses calculated. with GRAPE, a time-dependent Hamiltonian that is defined by the; control pulses, as well as the resulting propagator. Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. optimize_pulse(drift, ctrls, initial, target, num_ts",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:129085,tune,tuned,129085,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['tune'],['tuned']
Performance,"elf.h_td_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None. # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver. def _format_time(t, tt=None, ttt=None):; time_str = str(datetime.timedelta(seconds=t)); if tt is not None and ttt is not None:; sect_percent = 100*t/tt; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% section, {:03.2f}% total)"".format(; sect_percent, solve_percent); elif tt is not None:; sect_percent = 100*t/tt; time_str += "" ({:03.2f}% section)"".format(sect_percent). elif ttt is not None:; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% total)"".format(solve_percent). return time_str. [docs]class Stats(object):; """"""; Statistical information on the solver performance; Statistics can be grouped into sections.; If no section names are given in the the contructor, then all statistics; will be added to one section 'main'. Parameters; ----------; section_names : list; list of keys that will be used as keys for the sections; These keys will also be used as names for the sections; The text in the output can be overidden by setting the header property; of the section; If no names are given then one section called 'main' is created. Attributes; ----------; sections : OrderedDict of _StatsSection; These are the sections that are created automatically on instantiation; or added using add_section. header : string; Some text that will be used as the heading in the report; By default there is None. total_time : float; Time in seconds for the solver to complete processing; Can be None, meaning that total timing percentages will be reported. Methods; -------; add_section; Add another section. add_count; Add some stat that is an integer count. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/solver.html:16333,perform,performance,16333,docs/4.4/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/solver.html,2,['perform'],['performance']
Performance,"em directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_gen : bool; If True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_grad : bool; If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: bool; If True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: bool; If True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_optimization<=1, otherwise False. num_tslots : integer; Number of timeslots (aka timeslices). num_ctrls : integer; Number of controls.; Note this is calculated as the length of ctrl_dyn_gen when first used.; And is recalculated during initialise_controls only. evo_time : float; Total time for the evolution. tau : array[num_tslots] of float; Duration of each timeslot; Note that if this is set before initialize_controls is called; then num_tslots and evo_time are calculated from tau, otherwise; tau is generated from num_tslots and evo_time, that is; equal size time slices. time : array[num_tslots+1] of float; Cumulative time for the evolution, that is the time at the start; of each time slice. drift_dyn_gen : Qobj or list of Qobj; Drift or system dynamics generat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:9222,cache,cached,9222,docs/4.6/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html,2,['cache'],['cached']
Performance,"em.; Qobj diag method now returns real array if all imaginary parts are zero.; Examples GUI now links to new documentation.; Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011)¶. Bug Fixes¶. Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011)¶; THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE. New Functions¶. Added linear entropy function.; Number of CPU’s can now be changed. Bug Fixes¶. Metrics no longer use dense matrices.; Fixed Bloch sphere grid issue with matplotlib 1.1.; Qobj trace operation uses only sparse matrices.; Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011)¶; THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED. New Functions¶. tidyup function to remove small elements from a Qobj.; Added concurrence function.; Added simdiag for simultaneous diagonalization of operators.; Added eigenstates method returning eigenstates and eigenvalues to Qobj class.; Added fileio for saving and loading data sets and/or Qobj’s.; Added hinton function for visualizing density matrices. Bug Fixes¶. Switched Examples to new Signals method used in PySide 1.0.6+.; Switched ProgressBar to new Signals method.; Fixed memory issue in expm functions.; Fixed memory bug in isherm.; Made all Qobj data complex by default.; Reduced ODE tolerance levels in Odeoptions.; Fixed bug in ptrace where dense matrix was used instead of sparse.; Fixed issue where PyQt4 version would not be displayed in about box.; Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011)¶. Initial release. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:46719,load,loading,46719,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,1,['load'],['loading']
Performance,"emand it. matrix_element(self, bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters. braqutip.QobjQuantum object of type ‘bra’ or ‘ket’. ketqutip.QobjQuantum object of type ‘ket’. Returns. elemcomplexComplex valued matrix element. norm(self, norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters. normstrWhich norm to use for ket/bra vectors: L2 ‘l2’, max norm ‘max’,; or for operators: trace ‘tr’, Frobius ‘fro’, one ‘one’, or max; ‘max’. sparseboolUse sparse eigenvalue solver for trace norm. Other norms are not; affected by this parameter. tolfloatTolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used); for trace norm. Returns. normfloatThe requested norm of the operator or state quantum object. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. overlap(self, other)[source]¶; Overlap between two state vectors or two operators.; Gives the overlap (inner product) between the current bra or ket Qobj; and and another bra or ket Qobj. It gives the Hilbert-Schmidt overlap; when one of the Qobj is an operator/density matrix. Parameters. otherqutip.QobjQuantum object for a state vector of type ‘ket’, ‘bra’ or density; matrix. Returns. overlapcomplexComplex valued overlap. Raises. TypeErrorCan only calculate overlap between a bra, ket and density matrix; quantum objects. Notes; Since QuTiP mainly deals with ket vectors, the most efficient inner; product call is the ket-ket version that computes the product; <self|other> with both vectors expressed as kets. permute(self, order)[source]¶; Permutes",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:11854,perform,performed,11854,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,1,['perform'],['performed']
Performance,"enerally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate. Change the VERSION file by bumping the last number up by one (double-digit numbers are fine, so 4.6.10 comes after 4.6.9), and commit the change.; Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the “Base” branch to qutip-4.6.X (or whatever version), because GitHub will default to making it against master.; It should be quite clear if you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin’s approval, merge the PR. You should now see that the qutip-4.6.X (or whatever) branch on GitHub has been updated, and now includes all the changes you have just made.; If you have made a mistake, feel free to make additonal PRs to rectify the situation.; You are now ready to actually perform the release.; Go to deploy. Build Release Distribution and Deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:10813,perform,perform,10813,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,1,['perform'],['perform']
Performance,"ense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/partial_transpose.html:4704,perform,performs,4704,docs/4.5/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/partial_transpose.html,1,['perform'],['performs']
Performance,"ensional_norm. [docs] def normalize_gradient_PSU(self, grad):; """"""; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase; """"""; fid_pn = self.get_fidelity_prenorm(); grad_normalized = np.real(grad * np.exp(-1j * np.angle(fid_pn)) /; self.dimensional_norm); return grad_normalized. [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; return np.abs(1 - self.get_fidelity()). [docs] def get_fidelity(self):; """"""; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config; """"""; if not self.fidelity_current:; self.fidelity = \; self.fid_norm_func(self.get_fidelity_prenorm()); self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_pre",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:14417,cache,cached,14417,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,8,['cache'],['cached']
Performance,"ensity matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(self, order='C', squeeze=False)[source]¶; Dense array from quantum object. Parameters. orderstr {‘C’, ‘F’}Return array in C (default) or Fortran ordering. squeezebool {False, True}Squeeze output array. Returns. dataarrayArray of complex data from quantum objects data attribute. groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters. sparseboolUse sparse Eigensolver. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). safebool (default=True)Check for degenerate ground state. Returns. eigvalfloatEigenvalue for the ground state of quantum operator. eigvecqutip.QobjEigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. inv(self, sparse=False)[source]¶; Matrix inverse of a quantum operator; Operator must be square. Returns. operqutip.QobjMatrix inverse of operator. Raises. TypeErrorQuantum object is not square. matrix_element(self, bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters. braqutip.QobjQuantum object of type ‘bra’ or ‘ket’. ketqutip.QobjQuantum object of type ‘ket’. Returns. elemcomplexComplex valued matrix element. norm(self, norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:10626,perform,performed,10626,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,1,['perform'],['performed']
Performance,"ensity matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(self, order='C', squeeze=False)[source]¶; Dense array from quantum object. Parameters. orderstr {‘C’, ‘F’}Return array in C (default) or Fortran ordering. squeezebool {False, True}Squeeze output array. Returns. dataarrayArray of complex data from quantum objects data attribute. groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters. sparseboolUse sparse Eigensolver. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). safebool (default=True)Check for degenerate ground state. Returns. eigvalfloatEigenvalue for the ground state of quantum operator. eigvecqutip.QobjEigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(self, bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters. braqutip.QobjQuantum object of type ‘bra’ or ‘ket’. ketqutip.QobjQuantum object of type ‘ket’. Returns. elemcomplexComplex valued matrix element. norm(self, norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters. normstrWhich norm to use for ket/bra vectors: L2 ‘l2’, max norm ‘max’,; or f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:10514,perform,performed,10514,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,1,['perform'],['performed']
Performance,"ent for the quantum object sandwiched between a; bra and ket vector. Parameters:bra : qobj. Quantum object of type ‘bra’. ket : qobj. Quantum object of type ‘ket’. Returns:elem : complex. Complex valued matrix element. Raises:TypeError. Can only calculate matrix elements between a bra and ket; quantum object. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters:norm : str. Which norm to use for ket/bra vectors: L2 ‘l2’, max norm ‘max’,; or for operators: trace ‘tr’, Frobius ‘fro’, one ‘one’, or max; ‘max’. sparse : bool. Use sparse eigenvalue solver for trace norm. Other norms are not; affected by this parameter. tol : float. Tolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used); for trace norm. Returns:norm : float. The requested norm of the operator or state quantum object. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. overlap(state)[source]¶; Overlap between two state vectors.; Gives the overlap (scalar product) for the quantum object and state; state vector. Parameters:state : qobj. Quantum object for a state vector of type ‘ket’ or ‘bra’. Returns:overlap : complex. Complex valued overlap. Raises:TypeError. Can only calculate overlap between a bra and ket quantum objects. permute(order)[source]¶; Permutes a composite quantum object. Parameters:order : list/array. List specifying new tensor order. Returns:P : qobj. Permuted quantum object. ptrace(sel)[source]¶; Partial trace of the quantum object. Parameters:sel : int/list. An int or list of components to keep after partial trace. Returns:oper : qobj. Quantum object representing partial trace with selected com",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:11853,perform,performed,11853,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['perform'],['performed']
Performance,"entire Hessian, which reduces the computer memory required, and; allows bounds to be set for variable values, which considering these are field; amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be; calculated exactly, rather than approximated. For simple fidelity measures such; as \(f_{PSU}\) this is possible. Firstly the propagator gradient for each; timeslot with respect to the control amplitudes is calculated. For closed; systems, with unitary dynamics, a method using the eigendecomposition is used,; which is efficient as it is also used in the propagator calculation (to; exponentiate the combined Hamiltonian). More generally (for example open; systems and symplectic dynamics) the Frechet derivative (or augmented matrix); method is used, which is described in [Flo12]. For other optimisation goals it; may not be possible to calculate analytic gradients. In these cases it is; necessary to approximate the gradients, but this can be very expensive, and can; lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [Lloyd14], the dimension of a quantum optimal control; problem is a polynomial function of the dimension of the manifold of the; time-polynomial reachable states, when allowing for a finite control precision; and evolution time. You can think of this as the information content of the; pulse (as being the only effective input) being very limited e.g. the pulse is; compressible to a few bytes without loosing the target.; This is where the Chopped RAndom Basis (CRAB) algorithm; [Doria11], [Caneva11] comes into play: Since the pulse complexity is usually; very low, it is sufficient to transform the optimal control problem to a few; parameter search by introducing a physically motivated function basis that; builds up the pulse. Compared to the number of time slices needed to accurately; simulate quantum dynamics (often equals basis dimension for Gradient based; algorithms), thi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-control.html:10150,perform,performing,10150,docs/4.7/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html,1,['perform'],['performing']
Performance,"envalues. tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns:; eigvals : array; Array of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters:; sparse : bool; Use sparse Eigensolver. sort : str; Sort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvals : int; Number of requested eigenvalues. Default is all eigenvalues. tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns:; eigvals : array; Array of eigenvalues for operator. eigvecs : array; Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eliminate_states(states_inds, normalize=False)[source]¶; Creates a new quantum object with states in state_inds eliminated. Parameters:; states_inds : list of integer; The states that should be removed. normalize : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:; q : Qobj; A new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in stat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:7203,perform,performed,7203,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['perform'],['performed']
Performance,"eory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified; ; cache_phased_dyn_gen : bool; If True then the dynamics generators will be saved with and ; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False; ; cache_prop_grad : bool; If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the ; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False; ; cache_dyn_gen_eigenvectors_adj: bool; If True then DynamicsUnitary will cached the adjoint of ; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False; ; sparse_eigen_decomp: bool; If True then DynamicsUnitary will use the sparse eigenvalue ; decomposition.; Defaults to True when memory_optimization<=1, otherwise False. num_tslots : integer; Number of timeslots (aka timeslices). num_ctrls : integer; Number of controls.; Note this is calculated as the length of ctrl_dyn_gen when first used.; And is recalculated during initialise_controls only. evo_time : float; Total time for the evolution. tau : array[num_tslots] of float; Duration of each timeslot; Note that if this is set before initialize_controls is called; then num_tslots and evo_time are calculated from tau, otherwise; tau is generated from num_tslots and evo_time, that is; equal size time slices. time : array[num_tslots+1] of float; Cumulative time for the evolution, that is the time at the start; of each time slice. drift_dyn_gen : Qobj or list of Qobj; Drift or system dynamics generator (Hamiltonian);",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html:8080,cache,cached,8080,docs/4.1/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html,4,['cache'],['cached']
Performance,"equired:. Package; Version; Details. Python; 2.7+; Version 3.4+ is highly recommended. Numpy; 1.8+; Not tested on lower versions. Scipy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. GCC; Compiler; 4.2+; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. gfortran; 4.2+; Needed for compiling the optional Fortran-based; Monte Carlo solver. BLAS; library; 1.2+; Optional, Linux & Mac only.; Needed for installing Fortran Monte Carlo solver. Mayavi; 4.1+; Needed for using the Bloch3d class. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. nose; 1.1.2+; For running the test suite. As of version 2.2, QuTiP includes an optional Fortran-based Monte Carlo solver that has some performance benefit over the Python-based solver when simulating small systems. In order to install this package you must have a Fortran compiler (for example gfortran) and BLAS development libraries. At present, these packages are tested only on the Linux and OS X platforms.; We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platforms. Platform-independent Installation¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; If you aleady have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda insta",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/installation.html:1705,perform,performance,1705,docs/4.0.2/installation.html,https://qutip.org,https://qutip.org/docs/4.0.2/installation.html,1,['perform'],['performance']
Performance,"er function; Husimi Q-function. Visualizing operators; Quantum process tomography; Implementation in QuTiP. Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Visualization of quantum states and processes. Visualization of quantum states and processes¶; Visualization is often an important complement to a simulation of a quantum; mechanical system. The first method of visualization that come to mind might be; to plot the expectation values of a few selected operators. But on top of that,; it can often be instructive to visualize for example the state vectors or; density matices that describe the state of the system, or how the state is; transformed as a function of time (see process tomography below). In this; section we demonstrate how QuTiP and matplotlib can be used to perform a few; types of visualizations that often can provide additional understanding of; quantum system. Fock-basis probability distribution¶; In quantum mechanics probability distributions plays an important role, and as; in statistics, the expectation values computed from a probability distribution; does not reveal the full story. For example, consider an quantum harmonic; oscillator mode with Hamiltonian \(H = \hbar\omega a^\dagger a\), which is; in a state described by its density matrix \(\rho\), and which on average; is occupied by two photons, \(\mathrm{Tr}[\rho a^\dagger a] = 2\). Given; this information we cannot say whether the oscillator is in a Fock state,; a thermal state, a coherent state, etc. By visualizing the photon distribution; in the Fock state basis important clues about the underlying state can be; obtained.; One convenient way to visualize a probability distribution is to use histograms.; Consider the following histogram visualization of the number-basis probability; distribut",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-visualization.html:1600,perform,perform,1600,docs/4.2/guide/guide-visualization.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-visualization.html,5,['perform'],['perform']
Performance,"er number yields a more accurate approximate inverse at the expense of fill-in and increased runtime. diag_pivot_thresh; None; Sets the threshold between \([0,1]\) for which diagonal elements are considered acceptable pivot points when using a preconditioner. ILU_MILU; ‘smilu_2’; Selects the incomplete LU decomposition method algorithm used. Further information can be found in the qutip.steadystate.steadystate docstrings. Example: Harmonic Oscillator in Thermal Bath¶; A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the \(\left|10\right>\) number state, and weakly coupled to a thermal environment characterized by an average particle expectation value of \(\left<n\right>=2\). We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perform only a few Monte Carlo trajectories so we can distinguish this evolution from the master-equation solution.; In [1]: N = 20 # number of basis states to consider. In [2]: a = destroy(N). In [3]: H = a.dag() * a. In [4]: psi0 = basis(N, 10) # initial state. In [5]: kappa = 0.1 # coupling to oscillator. In [6]: c_op_list = []. In [7]: n_th_a = 2 # temperature with average of 2 excitations. In [8]: rate = kappa * (1 + n_th_a). In [9]: c_op_list.append(sqrt(rate) * a) # decay operators. In [10]: rate = kappa * n_th_a. In [11]: c_op_list.append(sqrt(rate) * a.dag()) # excitation operators. In [12]: final_state = steadystate(H, c_op_list). In [13]: fexpt = expect(a.dag() * a, final_state). In [14]: tlist = linspace(0, 50, 100). In [15]: mcdata = mcsolve(H, psi0, tlist, c_op_list, [a.dag() * a], ntraj=100); 10.0%. Run time: 0.41s. Est. time left: 00:00:00:03; 20.0%. Run time: 0.82s. Est. time left: 00:00:00:03; 30.0%. Run time: 1.17s. Est. time left: 00:00:00:02; 40.0%. Run time: 1.61s. Est. time left: 00:00:00:02; 50.0%. Run time: ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-steady.html:10821,perform,perform,10821,docs/3.1.0/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-steady.html,1,['perform'],['perform']
Performance,"er number yields a more accurate approximate inverse at the expense of fill-in and increased runtime. diag_pivot_thresh; None; Sets the threshold between \([0,1]\) for which diagonal elements are considered acceptable pivot points when using a preconditioner. ILU_MILU; ‘smilu_2’; Selects the incomplete LU decomposition method algorithm used. Further information can be found in the qutip.steadystate.steadystate docstrings. Example: Harmonic Oscillator in Thermal Bath¶; A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the \(\left|10\right>\) number state, and weakly coupled to a thermal environment characterized by an average particle expectation value of \(\left<n\right>=2\). We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perform only a few Monte Carlo trajectories so we can distinguish this evolution from the master-equation solution.; from qutip import *; from pylab import *; from scipy import *. # Define paramters; N = 20 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 10) # initial state; kappa = 0.1 # coupling to oscillator. # collapse operators; c_op_list = []; n_th_a = 2 # temperature with average of 2 excitations; rate = kappa * (1 + n_th_a); if rate > 0.0:; c_op_list.append(sqrt(rate) * a) # decay operators; rate = kappa * n_th_a; if rate > 0.0:; c_op_list.append(sqrt(rate) * a.dag()) # excitation operators. # find steady-state solution; final_state = steadystate(H, c_op_list); # find expectation value for particle number in steady state; fexpt = expect(a.dag() * a, final_state). tlist = linspace(0, 50, 100); # monte-carlo; mcdata = mcsolve(H, psi0, tlist, c_op_list, [a.dag() * a], ntraj=100); # master eq.; medata = mesolve(H, psi0, tlist, c_op_list, [a.dag() * a]). plot(tlist, mcdata.expect[0], tlist, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-steady.html:10354,perform,perform,10354,docs/3.0.0/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-steady.html,2,['perform'],['perform']
Performance,"er number yields a more accurate approximate inverse at the expense of fill-in and increased runtime. diag_pivot_thresh; None; Sets the threshold between \([0,1]\) for which diagonal elements are considered acceptable pivot points when using a preconditioner. ILU_MILU; ‘smilu_2’; Selects the incomplete LU decomposition method algorithm used. Further information can be found in the qutip.steadystate.steadystate docstrings. Example: Harmonic Oscillator in Thermal Bath¶; A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the \(\left|10\right>\) number state, and weakly coupled to a thermal environment characterized by an average particle expectation value of \(\left<n\right>=2\). We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perform only a few Monte Carlo trajectories so we can distinguish this evolution from the master-equation solution.; import numpy as np; import matplotlib.pyplot as plt. import qutip. # Define paramters; N = 20 # number of basis states to consider; a = qutip.destroy(N); H = a.dag() * a; psi0 = qutip.basis(N, 10) # initial state; kappa = 0.1 # coupling to oscillator. # collapse operators; c_op_list = []; n_th_a = 2 # temperature with average of 2 excitations; rate = kappa * (1 + n_th_a); if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a) # decay operators; rate = kappa * n_th_a; if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a.dag()) # excitation operators. # find steady-state solution; final_state = qutip.steadystate(H, c_op_list); # find expectation value for particle number in steady state; fexpt = qutip.expect(a.dag() * a, final_state). tlist = np.linspace(0, 50, 100); # monte-carlo; mcdata = qutip.mcsolve(H, psi0, tlist, c_op_list, [a.dag() * a], ntraj=100); # master eq.; medata = qutip.mesolve(H, psi0, tlist, c_op_list, [a.d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-steady.html:10086,perform,perform,10086,docs/4.6/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-steady.html,2,['perform'],['perform']
Performance,"er number yields a more accurate approximate inverse at the expense of fill-in and increased runtime. diag_pivot_thresh; None; Sets the threshold between \([0,1]\) for which diagonal elements are considered acceptable pivot points when using a preconditioner. ILU_MILU; ‘smilu_2’; Selects the incomplete LU decomposition method algorithm used. Further information can be found in the qutip.steadystate.steadystate docstrings. Example: Harmonic Oscillator in Thermal Bath¶; A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the \(\left|10\right>\) number state, and weakly coupled to a thermal environment characterized by an average particle expectation value of \(\left<n\right>=2\). We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perform only a few Monte Carlo trajectories so we can distinguish this evolution from the master-equation solution.; import numpy as np; import pylab as plt; from qutip import *; # Define paramters; N = 20 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 10) # initial state; kappa = 0.1 # coupling to oscillator. # collapse operators; c_op_list = []; n_th_a = 2 # temperature with average of 2 excitations; rate = kappa * (1 + n_th_a); if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a) # decay operators; rate = kappa * n_th_a; if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a.dag()) # excitation operators. # find steady-state solution; final_state = steadystate(H, c_op_list); # find expectation value for particle number in steady state; fexpt = expect(a.dag() * a, final_state). tlist = np.linspace(0, 50, 100); # monte-carlo; mcdata = mcsolve(H, psi0, tlist, c_op_list, [a.dag() * a], ntraj=100); # master eq.; medata = mesolve(H, psi0, tlist, c_op_list, [a.dag() * a]). plt.plot(tlist, mcdata.expect",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-steady.html:10060,perform,perform,10060,docs/4.2/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-steady.html,6,['perform'],['perform']
Performance,"er optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (Added by Denis Vasilyev); Can now define a given eigen spectrum for random Hermitian and density operators.; The Qobj expm method now uses the equivilent SciPy routine, and performs a much faster exp operation if the matrix is diagonal.; One can now build zero operators using the qzero function. Control modules. MAJOR FEATURE: CRAB algorithm added; This is an alternative to the GRAPE algorithm, which allows for analytical control functions, which means that experimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements¶; Core libraries. Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (Added by Kevin Fischer); The code for the inverse-power method for the steady state solver has been simplified.; Bloch-Redfield tensor creation is now up to an order of magnitude faster. (Added by Johannes Feist); Q.transform now works properly for arrays directly from sp_eigs (or eig).; Q.groundstate now checks for degeneracy.; Added sinm and cosm methods to the Qobj class.; Added charge and tunneling operators.; Time-dependent Cython code is n",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/changelog.html:2717,perform,performs,2717,docs/4.0.2/changelog.html,https://qutip.org,https://qutip.org/docs/4.0.2/changelog.html,8,['perform'],['performs']
Performance,"er' systems. use_rcm : bool, default False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbm : bool, default False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refine : int, default 10; MKL ONLY. Max. number of iterative refinements to perform. scaling_vectors : bool; MKL ONLY. Scale matrix to unit norm columns and rows. weighted_matching : bool; MKL ONLY. Use weighted matching to better condition diagonal. x0 : ndarray, optional; ITERATIVE ONLY. Initial guess for solution vector. maxiter : int, default 1000; ITERATIVE ONLY. Maximum number of iterations to perform. tol : float, default 1e-12; ITERATIVE ONLY. Tolerance used for terminating solver. mtol : float, optional; ITERATIVE 'power' methods ONLY. Tolerance for lu solve method. If None; given then ``max(0.1*tol, 1e-15)`` is used. matol : float, default 1e-15; ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_spec : str, optional; ITERATIVE ONLY. Column ordering used internally by superLU for the; 'direct' LU decomposition method. Options include 'COLAMD' (default); and 'NATURAL'. If using RCM then this is set to 'NATURAL' automatically; unless explicitly specified. use_precond : bool, default False; ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the 'iterative' GMRES and BICG solvers. Speeds up; convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional; ITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective precondition",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/steadystate.html:7793,perform,perform,7793,docs/4.6/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html,2,['perform'],['perform']
Performance,"er.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_e",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:15182,cache,cached,15182,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,8,['cache'],['cached']
Performance,"ere the qutip.parallel.parallel_map and qutip.parallel.parfor functions behaves differently:; While qutip.parallel.parallel_map only iterate over the values arguments, the qutip.parallel.parfor function simultaneously iterates over all arguments:; >>> def sum_diff(x, y, z=0): return x + y, x - y, z. >>> parfor(sum_diff, [1, 2, 3], [4, 5, 6], z=5.0); [array([5, 7, 9]), array([-3, -3, -3]), array([5., 5., 5.])]. >>> parallel_map(sum_diff, [1, 2, 3], task_args=(np.array([4, 5, 6]),), task_kwargs=dict(z=5.0)); [(array([5, 6, 7]), array([-3, -4, -5]), 5.0),; (array([6, 7, 8]), array([-2, -3, -4]), 5.0),; (array([7, 8, 9]), array([-1, -2, -3]), 5.0)]. Note that the keyword arguments can be anything you like, but the keyword values are not iterated over. The keyword argument num_cpus is reserved as it sets the number of CPU’s used by parfor. By default, this value is set to the total number of physical processors on your system. You can change this number to a lower value, however setting it higher than the number of CPU’s will cause a drop in performance. In qutip.parallel.parallel_map, keyword arguments to the task function are specified using task_kwargs argument, so there is no special reserved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; >>> import time. >>> def func(x): time.sleep(1). >>> result = parallel_map(func, range(50), progress_bar=True). 10.0%. Run time: 3.10s. Est. time left: 00:00:00:27; 20.0%. Run time: 5.11s. Est. time left: 00:00:00:20; 30.0%. Run time: 8.11s. Est. time left: 00:00:00:18; 40.0%. Run time: 10.15s. Est. time left: 00:00:00:15; 50.0%. Run time: 13.15s. Est. time left: 00:00:",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-parfor.html:4623,perform,performance,4623,docs/4.6/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-parfor.html,2,['perform'],['performance']
Performance,"eroperators can be represented; using the isomorphism; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\) [Hav03], [Wat13].; To represent superoperators acting on \(\mathcal{L}(\mathcal{H}_1 \otimes \mathcal{H}_2)\) thus takes some tensor rearrangement to get the desired ordering; \(\mathcal{H}_1 \otimes \mathcal{H}_2 \otimes \mathcal{H}_1 \otimes \mathcal{H}_2\).; In particular, this means that qutip.tensor does not act as; one might expect on the results of qutip.superop_reps.to_super:; >>> A = qeye([2]). >>> B = qeye([3]). >>> to_super(tensor(A, B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. >>> tensor(to_super(A), to_super(B)).dims; [[[2], [2], [3], [3]], [[2], [2], [3], [3]]]. In the former case, the result correctly has four copies; of the compound index with dims [2, 3]. In the latter; case, however, each of the Hilbert space indices is listed; independently and in the wrong order.; The qutip.tensor.super_tensor function performs the needed; rearrangement, providing the most direct analog to qutip.tensor on; the underlying Hilbert space. In particular, for any two type=""oper""; Qobjs A and B, to_super(tensor(A, B)) == super_tensor(to_super(A), to_super(B)) and; operator_to_vector(tensor(A, B)) == super_tensor(operator_to_vector(A), operator_to_vector(B)). Returning to the previous example:; >>> super_tensor(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. The qutip.tensor.composite function automatically switches between; qutip.tensor and qutip.tensor.super_tensor based on the type; of its arguments, such that composite(A, B) returns an appropriate Qobj to; represent the composition of two systems.; >>> composite(A, B).dims; [[2, 3], [2, 3]]. >>> composite(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. QuTiP also allows more general tensor manipulations that are; useful for converting between superoperator representations [WBC11].; In particular, the tensor_contract function allows for; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-tensor.html:11577,perform,performs,11577,docs/4.7/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-tensor.html,1,['perform'],['performs']
Performance,"erridden in the subclass. dump_summary¶; bool – If True a summary is recorded each time a new item is added to the; the dump.; Default is True. summary_sep¶; str – delimiter for the summary file.; default is a space. data_sep¶; str – delimiter for the data files (arrays saved to file).; default is a space. summary_file¶; str – File path for summary file.; Automatically generated. Can be set specifically. create_dump_dir()[source]¶; Checks dump directory exists, creates it if not. level¶. The level of data dumping that will occur. SUMMARY : A summary will be recorded; FULL : All possible dumping; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped. class OptimDump(optim, level='SUMMARY')[source]¶; A container for dumps of optimisation data generated during the pulse; optimisation. dump_summary¶; bool – When True summary items are appended to the iter_summary. iter_summary¶; list of optimizer.OptimIterSummary – Summary at each iteration. dump_fid_err¶; bool – When True values are appended to the fid_err_log. fid_err_log¶; list of float – Fidelity error at each call of the fid_err_func. dump_grad_norm¶; bool – When True values are appended to the fid_err_log. grad_norm_log¶; list of float – Gradient norm at each call of the grad_norm_log. dump_grad¶; bool – When True values are appended to the grad_log. grad_log¶; list of ndarray – Gradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. dump_all¶; True if everything (ignoring the summary) is to be dumped. dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:116629,optimiz,optimizer,116629,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['optimiz'],['optimizer']
Performance,"erride these. coeff_scalingfloatLinear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method; Options a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:186417,optimiz,optimize,186417,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['optimiz'],['optimize']
Performance,"erride these. coeff_scalingfloatLinear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_optionstringdetermines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_paramsdictParameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_paramsdictParameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. tslot_typestringMethod for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:194865,optimiz,optimize,194865,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['optimiz'],['optimize']
Performance,"error target. Pulse optimisation will; terminate when the fidelity error falls below this value; mim_grad (float) – Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima; max_iter (integer) – Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg (string) – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; optim_method (string) – a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; optim_alg (string) – Deprecated. Use optim_method.; max_metric_corr (integer) – Deprecated. Use method_params instead; accuracy_factor (float) – Deprecated. Use method_params instead; dyn_type (string) – Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:149244,optimiz,optimize,149244,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"error target. Pulse optimisation will; terminate when the fidelity error falls below this value; mim_grad (float) – Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima; max_iter (integer) – Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg (string) – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; optim_method (string) – a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; optim_alg (string) – Deprecated. Use optim_method.; max_metric_corr (integer) – Deprecated. Use method_params instead; accuracy_factor (float) – Deprecated. Use method_params instead; phase_option (string) – determines how global phase is treated in fidelity; calculations (fid_type=’UN",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:158076,optimiz,optimize,158076,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"error target. Pulse optimisation will; terminate when the fidelity error falls below this value; mim_grad (float) – Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima; max_iter (integer) – Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg (string) – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; optim_method (string) – a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; optim_alg (string) – Deprecated. Use optim_method.; max_metric_corr (integer) – Deprecated. Use method_params instead; accuracy_factor (float) – Deprecated. Use method_params instead; dyn_type (string) – Dynamics type, i.e. the type of matrix used to describe; the dynamics. Opti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:165835,optimiz,optimize,165835,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"es already exist,; and we would like to add a backend that implements the necessary operations; using TensorFlow 1. Why a TensorFlow backend?¶; TensorFlow supports distributing matrix operations across multiple GPUs and; multiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them.; There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver 2. Challenges¶; TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results.; The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes¶. Add a qutip.core.data.tensorflow data type.; Implement specialisations for some important operations (e.g. add,; mul, matmul, eigen, etc).; Write a small benchmark to show how Qobj operations scale on the new; backend in comparison to the existing backends. Run the benchmark both; with and without using a GPU.; Implement enough for a solver to run on top of the new TensorFlow data; backend and benchmark that (stretch goal). Skills¶. Git, Python and familiarity with the Python scientific computing stack; Familiarity with TensorFlow (beneficial, but not required); Familiarity with Cython (beneficial, but not required). Difficulty¶. Medium. Mentors¶. Simon Cross (hodgestar@gmail.com); Jake Lishman (jake@binhbar.com); Alex Pitchford (alex.pitchford@gmail.com). References¶. 1; https://www.tensorflow.org/. 2; https://github.com/tehruhn/bofin. 3; https://github.com",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html:2415,perform,performance,2415,docs/4.7/development/ideas/tensorflow-data-backend.html,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html,1,['perform'],['performance']
Performance,"es already exist,; and we would like to add a backend that implements the necessary operations; using TensorFlow 1. Why a TensorFlow backend?¶; TensorFlow supports distributing matrix operations across multiple GPUs and; multiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them.; There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver 2. Challenges¶; TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results.; The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes¶. Add a qutip.core.data.tensorflow data type.; Implement specialisations for some important operations (e.g. add,; mul, matmul, eigen, etc).; Write a small benchmark to show how Qobj operations scale on the new; backend in comparison to the existing backends. Run the benchmark both; with and without using a GPU.; Implement enough for a solver to run on top of the new TensorFlow data; backend and benchmark that (stretch goal). Skills¶. Git, Python and familiarity with the Python scientific computing stack; Familiarity with TensorFlow (beneficial, but not required); Familiarity with Cython (beneficial, but not required). Difficulty¶. Medium. Mentors¶. Simon Cross (hodgestar@gmail.com); Jake Lishman (jake@binhbar.com); Alex Pitchford (alex.pitchford@gmail.com). References¶. 1; https://www.tensorflow.org/. 2; https://github.com/tehruhn/bofin. Next ; Previous. © Co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/ideas/tensorflow-data-backend.html:2329,perform,performance,2329,docs/4.6/development/ideas/tensorflow-data-backend.html,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/tensorflow-data-backend.html,1,['perform'],['performance']
Performance,"es are currently required:. Package; Version; Details. Python; 2.7+; Version 3.3+ is highly recommended. Numpy; 1.7+; Not tested on lower versions. Scipy; 0.13+; Lower versions have missing features. Matplotlib; 1.2.0+; Some plotting does not work on lower versions. Cython; 0.15+; Needed for compiling some time-dependent; Hamiltonians. GCC; Compiler; 4.2+; Needed for compiling Cython files. Fortran; Compiler; Fortran 90; Needed for compiling the optional Fortran-based; Monte Carlo solver. BLAS; library; 1.2+; Optional, Linux & Mac only.; Needed for installing Fortran Monte Carlo solver. Mayavi; 4.1+; Optional. Needed for using the Bloch3d class. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. LaTeX; TexLive 2009+; Optional. Needed if using LaTeX in figures. nose; 1.1.2+; Optional. For running tests. scikits.umfpack; 5.2.0+; Optional. Faster (~2-5x) steady state calculations. As of version 2.2, QuTiP includes an optional Fortran-based Monte Carlo solver that has a substantial performance benefit when compared with the Python-based solver. In order to install this package you must have a Fortran compiler (for example gfortran) and BLAS development libraries. At present, these packages are only tested on the Linux and OS X platforms. Platform-independent installation¶; Often the easiest way is to install QuTiP is to use the Python package manager pip.; sudo pip install qutip. However, when installing QuTiP this way the Fortran-based Monte Carlo solver is not included.; More detailed platform-dependent installation alternatives are given below. Get the source code¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/installation.html:3185,perform,performance,3185,docs/3.0.1/installation.html,https://qutip.org,https://qutip.org/docs/3.0.1/installation.html,1,['perform'],['performance']
Performance,"es as argument, and returns a list of corresponding propagators. Bug Fixes¶. mesolver now correctly uses the user defined rhs_filename in Odeoptions().; rhs_generate() now handles user defined filenames properly.; Density matrix returned by propagator_steadystate is now Hermitian.; eseries_value returns real list if all imag parts are zero.; mcsolver now gives correct results for strong damping rates.; Odeoptions now prints mc_avg correctly.; Do not check for PyObj in mcsolve when gui=False.; Eseries now correctly handles purely complex rates.; thermal_dm() function now uses truncated operator method.; Cython based time-dependence now Python 3 compatible.; Removed call to NSAutoPool on mac systems.; Progress bar now displays the correct number of CPU’s used.; Qobj.diag() returns reals if operator is Hermitian.; Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012)¶; The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features¶. QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations.; The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators.; It is possible to automatically compile time-dependent problems into c-code using Cython (if installed).; Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators.; Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. Important; This breaks compatibility with QuTiP version 1.x. mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed.; QuTiP includes functions for creating random quantum states and operators.; The generation and manipulation of quantum obje",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:42996,perform,performance,42996,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['perform'],['performance']
Performance,"es for which the task function is to be; evaluated. task_argslist / dictionaryThe optional additional argument to the task function. task_kwargslist / dictionaryThe optional additional keyword argument to the task function. progress_barProgressBarProgress bar class instance for showing progress. Returns. resultlistThe result list contains the value of; task(value, *task_args, **task_kwargs) for each; value in values. Semidefinite Programming¶; This module implements internal-use functions for semidefinite programming. IPython Notebook Tools¶; This module contains utility functions for using QuTiP with IPython notebooks. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. task_vec: array / listThe list or array of values for which the task function is to be; evaluated. args: list / dictionaryThe optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:235664,load,load-balanced,235664,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,1,['load'],['load-balanced']
Performance,"es. dumping. log_level; (integer) level of messaging output from the logger. Options are attributes of qutip.logging_utils, in decreasing levels of messaging, are: DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL Anything WARN or above is effectively ‘quiet’ execution, assuming everything runs as expected. The default NOTSET implies that the level will be taken from the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value Note: attributes are created if they do not exist already, and are overwritten if they do. alg; (string) Algorithm to use in pulse optimisation. Options are: ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering ‘CRAB’ - Chopped RAndom Basis. alg_params; (Dictionary) options that are specific to the pulse optim algorithm that is GRAPE or CRAB. disp_conv_msg; (bool) Set true to display a convergence message (for scipy.optimize.minimize methods anyway). optim_method; (string) a scipy.optimize.minimize method that will be used to optimise the pulse for minimum fidelity error. method_params; (Dictionary) Options for the optim_method. Note that where there is an equivalent attribute of this instance or the termination_conditions (for example maxiter) it will override an value in these options. approx_grad; (bool) If set True then the method will approximate the gradient itself (if it has requirement and facility for this) This will mean that the fid_err_grad_wrapper will not get called Note it should be left False when using the Dynamics to calculate approximate gradients Note it is set True automatically when the alg is CRAB. amp_lbound; (float or list of floats) lower boundaries for the control amplitudes Can be a scalar value applied to all controls or a list of bounds for each control. amp_ubound; (float or list of floats) upper boundaries for the control amplitudes Can be a scalar value applied to all controls or a list of bounds for each control. bounds; (List of flo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:57766,optimiz,optimize,57766,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['optimiz'],['optimize']
Performance,"eturn _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html:2909,perform,performs,2909,docs/4.7/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html,1,['perform'],['performs']
Performance,"eturn time_evolution. def _evolve_krylov_tlist(; H,; psi0: np.ndarray,; krylov_dim: int,; tlist: list,; t0: float,; psi_norm: float = None,; krylov_basis: np.array = None,; T_m: np.array = None,; sparse: bool = False,; ):; """"""; Computes the Krylov approximation time evolution of dimension 'krylov_dim'; for Hamiltonian 'H' and initial state 'psi0' for each time in 'tlist'.; Parameters; ------------; H: np.ndarray or csr_matrix; System Hamiltonian.; psi0: np.ndarray; Initial state vector.; krylov_basis: np.ndarray; Krylov basis projector operator.; tlist: list; List of timesteps for the time evolution.; t0: float; Initial time for the time evolution.; psi_norm: float (optional, default False); Norm-2 of psi0.; krylov_basis: np.ndarray (optional, default None); Krylov basis projector operator. If 'krylov_basis' is None, perform; a lanczos iteration.; T_m: np.ndarray (optional, default None); Tridiagonal matrix decomposition of the system given by lanczos; algorithm. If 'T_m' is None, perform a lanczos iteration.; Returns; ---------; psi_list: List[np.ndarray]; List of evolved states at times t in 'tlist'.; """""". if psi_norm is None:; psi_norm = np.linalg.norm(psi0). if psi_norm != 1:; psi = psi0 / psi_norm; else:; psi = psi0. if (krylov_basis is None) or (T_m is None):; krylov_basis, T_m = lanczos_algorithm(; H=H, psi=psi, krylov_dim=krylov_dim, sparse=sparse; ). evolve = _evolve(t0, krylov_basis, T_m); psi_list = list(map(evolve, tlist)). return psi_list. # ----------------------------------------------------------------------; # Auxiliar functions. def _check_inputs(H, psi0, krylov_dim):; """"""Check that the inputs 'H' and 'psi0' have the correct structures.""""""; if not isinstance(H, Qobj):; raise TypeError(; ""krylovsolve currently supports Hamiltonian Qobj operators only""; ). if not H.isherm:; raise TypeError(""Hamiltonian 'H' must be hermician.""). if not isinstance(psi0, Qobj):; raise TypeError(""'psi0' must be a Qobj.""). if not psi0.isket:; raise TypeError(""Initial state",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:10443,perform,perform,10443,docs/4.7/modules/qutip/krylovsolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html,1,['perform'],['perform']
Performance,"expect = []; self.num_expect = 0; self.num_collapse = 0; self.ntraj = None; self.seeds = None; self.col_times = None; self.col_which = None. def __str__(self):; s = ""Result object ""; if self.solver:; s += ""with "" + self.solver + "" data.\n""; else:; s += ""missing solver information.\n""; s += ""-"" * (len(s) - 1) + ""\n""; if self.states is not None and len(self.states) > 0:; s += ""states = True\n""; elif self.expect is not None and len(self.expect) > 0:; s += ""expect = True\nnum_expect = "" + str(self.num_expect) + "", ""; else:; s += ""states = True, expect = True\n"" + \; ""num_expect = "" + str(self.num_expect) + "", ""; s += ""num_collapse = "" + str(self.num_collapse); if self.solver == 'mcsolve':; s += "", ntraj = "" + str(self.ntraj); return s. def __repr__(self):; return self.__str__(). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). # %%%%%%%%%%% remove ?; [docs]class SolverConfiguration():; def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):; # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. self.soft_reset(). def soft_reset(self):; # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltoni",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/solver.html:13116,load,loading,13116,docs/4.5/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/solver.html,3,['load'],['loading']
Performance,"expect = []; self.num_expect = 0; self.num_collapse = 0; self.ntraj = None; self.seeds = None; self.col_times = None; self.col_which = None. def __str__(self):; s = ""Result object ""; if self.solver:; s += ""with "" + self.solver + "" data.\n""; else:; s += ""missing solver information.\n""; s += ""-"" * (len(s) - 1) + ""\n""; if self.states is not None and len(self.states) > 0:; s += ""states = True\n""; elif self.expect is not None and len(self.expect) > 0:; s += ""expect = True\nnum_expect = "" + str(self.num_expect) + "", ""; else:; s += ""states = True, expect = True\n"" + \; ""num_expect = "" + str(self.num_expect) + "", ""; s += ""num_collapse = "" + str(self.num_collapse); if self.solver == 'mcsolve':; s += "", ntraj = "" + str(self.ntraj); return s. def __repr__(self):; return self.__str__(). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). # %%%%%%%%%%% remove ?; class SolverConfiguration():; def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):. # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. self.soft_reset(). def soft_reset(self):. # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian ope",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/solver.html:13081,load,loading,13081,docs/4.4/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/solver.html,1,['load'],['loading']
Performance,"expect = []; self.num_expect = 0; self.num_collapse = 0; self.ntraj = None; self.seeds = None; self.col_times = None; self.col_which = None. def __str__(self):; s = ""Result object ""; if self.solver:; s += ""with "" + self.solver + "" data.\n""; else:; s += ""missing solver information.\n""; s += ""-"" * (len(s) - 1) + ""\n""; if self.states is not None and len(self.states) > 0:; s += ""states = True\n""; elif self.expect is not None and len(self.expect) > 0:; s += ""expect = True\nnum_expect = "" + str(self.num_expect) + "", ""; else:; s += ""states = True, expect = True\n"" + \; ""num_expect = "" + str(self.num_expect) + "", ""; s += ""num_collapse = "" + str(self.num_collapse); if self.solver == 'mcsolve':; s += "", ntraj = "" + str(self.ntraj); return s. def __repr__(self):; return self.__str__(). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). class SolverConfiguration():. def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):. # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/solver.html:11278,load,loading,11278,docs/3.1.0/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/solver.html,3,['load'],['loading']
Performance,"expect = []; self.num_expect = 0; self.num_collapse = 0; self.ntraj = None; self.seeds = None; self.col_times = None; self.col_which = None. def __str__(self):; s = ""Result object ""; if self.solver:; s += ""with "" + self.solver + "" data.\n""; else:; s += ""missing solver information.\n""; s += ""-"" * (len(s) - 1) + ""\n""; if self.states is not None and len(self.states) > 0:; s += ""states = True\n""; elif self.expect is not None and len(self.expect) > 0:; s += ""expect = True\nnum_expect = "" + str(self.num_expect) + "", ""; else:; s += ""states = True, expect = True\n"" + \; ""num_expect = "" + str(self.num_expect) + "", ""; s += ""num_collapse = "" + str(self.num_collapse); if self.solver == 'mcsolve':; s += "", ntraj = "" + str(self.ntraj); return s. def __repr__(self):; return self.__str__(). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). class SolverConfiguration():. def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):. # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem; ; self.soft_reset(). def soft_reset(self):. # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/solver.html:10813,load,loading,10813,docs/4.2/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html,2,['load'],['loading']
Performance,"f the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached. max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operator from t=0 to t=T based on the final amps. evo_full_initial : Qobj; The evolution operator from t=0 to t=T based on the initial amps. stats : Stats; Object contaning the stats for the run (if any collected). optimizer : Optimizer; Instance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEB",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:83267,optimiz,optimizer,83267,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['optimiz'],['optimizer']
Performance,"f.approx_grad,; callback=self.iter_step_callback_func,; bounds=self.bounds, m=m, factr=factr,; pgtol=term_conds.min_gradient_norm,; disp=self.msg_level,; maxfun=term_conds.max_fid_func_calls,; maxiter=term_conds.max_iterations). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); warn = res_dict['warnflag']; if warn == 0:; result.grad_norm_min_reached = True; result.termination_reason = ""function converged""; elif warn == 1:; result.max_iter_exceeded = True; result.termination_reason = (""Iteration or fidelity ""; ""function call limit reached""); elif warn == 2:; result.termination_reason = res_dict['task']. result.num_iter = res_dict['nit']; except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerCrab(Optimizer):; """"""; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients. AJGP ToDo: Add citation here; """""". def reset(self):; Optimizer.reset(self); self.id_text = 'CRAB'; self.num_optim_vars = 0. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; Optimizer.init_optim(self, term_conds); dyn = self.dynamics. self.num_optim_vars = 0; pulse_gen_valid = True; # check the pulse generators match the ctrls; # (in terms of number); # and count the number of parameters; if self.pulse_generator is None:; pulse_gen_valid = False; err_msg = ""pulse_generator attribute is None""; elif not isinstance(self.pulse_generator, collections.Iterable):; pulse_gen_valid = False; er",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:32838,optimiz,optimize,32838,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,4,['optimiz'],['optimize']
Performance,"f.approx_grad,; callback=self.iter_step_callback_func,; bounds=self.bounds, m=m, factr=factr,; pgtol=term_conds.min_gradient_norm,; disp=self.msg_level,; maxfun=term_conds.max_fid_func_calls,; maxiter=term_conds.max_iterations). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); warn = res_dict['warnflag']; if warn == 0:; result.grad_norm_min_reached = True; result.termination_reason = ""function converged""; elif warn == 1:; result.max_iter_exceeded = True; result.termination_reason = (""Iteration or fidelity ""; ""function call limit reached""); elif warn == 2:; result.termination_reason = res_dict['task']. result.num_iter = res_dict['nit']; except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerCrab(Optimizer):; """"""; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients. AJGP ToDo: Add citation here; """""". def reset(self):; Optimizer.reset(self); self.id_text = 'CRAB'; self.num_optim_vars = 0. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; Optimizer.init_optim(self, term_conds); dyn = self.dynamics. self.num_optim_vars = 0; pulse_gen_valid = True; # check the pulse generators match the ctrls; # (in terms of number); # and count the number of parameters; if self.pulse_generator is None:; pulse_gen_valid = False; err_msg = ""pulse_generator attribute is None""; elif not isinstance(self.pulse_generator, collections.abc.Iterable):; pulse_gen_valid = False",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/optimizer.html:32898,optimiz,optimize,32898,docs/4.4/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/optimizer.html,4,['optimiz'],['optimize']
Performance,"f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = complex(item); n += 1; m += 1. else:; data = np.zeros((M, N), dtype=""float""); m = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = float(item); n += 1; m += 1. f.close(). return data. [docs]def qsave(data, name='qutip_data'):; """"""; Saves given data to file named 'filename.qu' in current directory. Parameters; ----------; data : instance/array_like; Input Python object to be stored.; filename : str; Name of output data file. """"""; # open the file for writing; fileObject = open(name + '.qu', 'wb'); # this writes the object a to the file named 'filename.qu'; pickle.dump(data, fileObject); fileObject.close(). [docs]def qload(name):; """"""; Loads data file from file named 'filename.qu' in current directory. Parameters; ----------; name : str; Name of data file to be loaded. Returns; -------; qobject : instance / array_like; Object retrieved from requested file. """"""; fileObject = open(name + '.qu', 'rb') # open the file for reading; if sys.version_info >= (3, 0):; out = pickle.load(fileObject, encoding='latin1') # return the object from the file; else:; out = pickle.load(fileObject); if isinstance(out, Qobj): # for quantum objects; print('Loaded Qobj object:'); str1 = ""Quantum object: "" + ""dims = "" + str(out.dims) \; + "", shape = "" + str(out.shape) + "", type = "" + out.type; if out.type == 'oper' or out.type == 'super':; str1 += "", isHerm = "" + str(out.isherm) + ""\n""; else:; str1 += ""\n""; print(str1); elif isinstance(out, Result):; print('Loaded Result object:'); print(out); else:; print(""Loaded "" + str(type(out).__name__) + "" object.""); return out. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/fileio.html:7188,load,load,7188,docs/4.3/modules/qutip/fileio.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/fileio.html,2,['load'],['load']
Performance,"falls below this value, the optimisation; terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation. Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; Options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. optim_method : string; A ``scipy.optimize.minimize`` method that will be used to optimise the; pulse for minimum fidelity error. Note that ``FMIN``, ``FMIN_BFGS`` &; ``FMIN_L_BFGS_B`` will all result in calling these specific; ``scipy.optimize methods``. Note the ``LBFGSB`` is equivalent to; ``FMIN_L_BFGS_B`` for backwards compatibility reasons. Supplying DEF; will given alg dependent result:. - GRAPE - Default ``optim_method`` is ``FMIN_L_BFGS_B``; - CRAB - Default ``optim_method`` is ``FMIN``. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~Optimizer` object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the ``scipy.optimize.minimize``; method. optim_alg : string; Deprecated. Use ``optim_method``. max_metric_corr : integer; Deprecated. Use ``method_params`` instead. accuracy_factor : float; Deprecated. Use ``method_params`` instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe the dynamics.; Options are ``UNIT``, ``GEN_MAT``, ``SYMPL`` (see :obj:`~Dynamics`; classes for details). dyn_params : dict; Parameters for the :obj:`~Dynamics` objec",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:9501,optimiz,optimize,9501,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimize']
Performance,"falls below this value, the optimisation; terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation. Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; Options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. optim_method : string; A ``scipy.optimize.minimize`` method that will be used to optimise the; pulse for minimum fidelity error. Note that ``FMIN``, ``FMIN_BFGS`` &; ``FMIN_L_BFGS_B`` will all result in calling these specific; ``scipy.optimize methods``. Note the ``LBFGSB`` is equivalent to; ``FMIN_L_BFGS_B`` for backwards compatibility reasons. Supplying DEF; will given alg dependent result:. - GRAPE - Default ``optim_method`` is ``FMIN_L_BFGS_B``; - CRAB - Default ``optim_method`` is ``FMIN``. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~qutip.control.optimizer.Optimizer` object or; the termination_conditions matching the key that attribute.; Otherwise, and in some case also, they are assumed to be method_options; for the ``scipy.optimize.minimize`` method. optim_alg : string; Deprecated. Use ``optim_method``. max_metric_corr : integer; Deprecated. Use ``method_params`` instead. accuracy_factor : float; Deprecated. Use ``method_params`` instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe the dynamics.; Options are ``UNIT``, ``GEN_MAT``, ``SYMPL``; (see :obj:`~qutip.control.dynamics.Dynamics` classes for details). dyn_params : ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:7782,optimiz,optimize,7782,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimize']
Performance,"fault is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class:`qutip.Qobj`; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Ground state may be degenerate. ""; ""Use Q.eigenstates()""); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : :class:`qutip.Qobj`; Transpose of input operator. """"""; out = Q",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobj.html:43007,perform,performed,43007,docs/4.4/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobj.html,2,['perform'],['performed']
Performance,"fault is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class:`qutip.Qobj`; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; tol = 1e-15 if tol == 0 else tol; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Ground state may be degenerate. ""; ""Use Q.eigenstates()""); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : :class:`qutip.Qobj`; Transpose of input operator. """""";",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobj.html:45841,perform,performed,45841,docs/4.6/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html,2,['perform'],['performed']
Performance,"fault is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Ground state may be degenerate. ""; ""Use Q.eigenstates()""); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : qobj; Transpose of input operator. """"""; out = Qobj(); out.data = zcsr_transpo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/qobj.html:39808,perform,performed,39808,docs/4.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html,3,['perform'],['performed']
Performance,"fault is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print('WARNING: Ground state may be degenerate. Use Q.eigenstates()'); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : qobj; Transpose of input operator. """"""; out = Qobj(); out.data = zcsr_transpose(s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:39602,perform,performed,39602,docs/4.0.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html,1,['perform'],['performed']
Performance,"floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. boundsList of floatsBounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamicsDynamics (subclass instance)describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). configOptimConfig instancevarious configuration options; (see OptimConfig for details). termination_conditionsTerminationCondition instanceattributes determine when the optimisation will end. pulse_generatorPulseGen (subclass instance)(can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. statsStatsattributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dumpdump.OptimDumpContainer for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumpingstringThe level of data dumping that will occur during the optimisation - NONE : No processing data dumped (Default) - SUMMARY : A summary at each iteration will be recorded - FULL : All logs will be generated and dumped - CUSTOM : Some customised level of dumping When first set to CUSTOM this is equivalent to SUMMARY. dump_to_fileboolIf set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dirstringBasically a link to dump.dump_dir. Exists so that it can be set throu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:76023,perform,performance,76023,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['perform'],['performance']
Performance,"floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. boundsList of floatsBounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamicsDynamics (subclass instance)describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). configOptimConfig instancevarious configuration options; (see OptimConfig for details). termination_conditionsTerminationCondition instanceattributes determine when the optimisation will end. pulse_generatorPulseGen (subclass instance)(can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. statsStatsattributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dumpdump.OptimDumpContainer for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumpingstringThe level of data dumping that will occur during the optimisation. dump_to_fileboolIf set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dirstringBasically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summaryOptimIterSummarySummary of the most recent iteration.; Note this is only set if dummping is on. apply_method_params(params=Non",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:190174,perform,performance,190174,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,1,['perform'],['performance']
Performance,"floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. boundsList of floatsBounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamicsDynamics (subclass instance)describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). configOptimConfig instancevarious configuration options; (see OptimConfig for details). termination_conditionsTerminationCondition instanceattributes determine when the optimisation will end. pulse_generatorPulseGen (subclass instance)(can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. statsStatsattributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dumpqutip.control.dump.OptimDumpContainer for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumpingstringThe level of data dumping that will occur during the optimisation. dump_to_fileboolIf set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dirstringBasically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summaryOptimIterSummarySummary of the most recent iteration.; Note this is only set if dummping is on. apply_method_par",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:222597,perform,performance,222597,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,1,['perform'],['performance']
Performance,"for each value in ``values`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, *args, **kwargs)``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. values: array / list; The list or array of values for which the ``task`` function is to be; evaluated. task_args: list / dictionary; The optional additional argument to the ``task`` function. task_kwargs: list / dictionary; The optional additional keyword argument to the ``task`` function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs);",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/ipynbtools.html:10062,load,load-balanced,10062,docs/4.2/modules/qutip/ipynbtools.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/ipynbtools.html,9,['load'],['load-balanced']
Performance,"fset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------. Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g.; optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; """""". # check parameters; if not isinstance(drift, Qobj):; raise TypeError(""drift must be a Qobj""); else:; drift = drift.full(). if not isinstance(ctrls, (list, tuple)):; raise TypeError(""ctrls should be a list of Qobj""); else:; j = 0; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""ctrls should be a list of Qobj""); else:; ctrls[j] = ctrl.full(); j += 1. if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""); else:; initial = initial.full(). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); else:; target = target.full(). cfg = optimconfig.OptimConfig(); cfg.optim_alg = optim_alg; cfg.max_metric_corr = max_metric_corr; cfg.accuracy_factor = accuracy_factor; cfg.amp_update_mode = amp_update_mode; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.pulse_type = init_pulse_type; cfg.phase_option = p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:25800,optimiz,optimizer,25800,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimizer']
Performance,"g This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be downloaded from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organizations:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/frontmatter.html:1996,perform,performed,1996,docs/4.6/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html,1,['perform'],['performed']
Performance,"g. status; development [pretty much] complete. admin lead; Eric. main dev; Jake Lishman. Reorganise qutip main components to the structure described above. qutip user docs migration¶. tag; qmain-docs. status; conceptualised. admin lead; TBA; Shahnawaz?. main dev; TBA. The qutip user documentation build files are to be moved to the qutip/qutip; repo. This is more typical for an OSS package.; As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them.; The qutip-doc repo will afterwards just be used for documents, such as this one,; pertaining to the QuTiP project. Solver data layer integration¶. tag; solve-dl. status; development ongoing. admin lead; Eric. main dev; Eric. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying QobjEvo; (the time-dependent quantum object) that he developed. QobjEvo will exploit; the data layer, and the solvers in turn exploit QobjEvo. QIP migration¶. tag; qip-mig. status; development [pretty much] complete. admin lead; Boxi. main dev; Sidhant Saraogi. A separate package for qutip-qip was created during Sidhant’s GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. HEOM revamp¶. tag; heom-revamp. status; development [pretty much] complete. admin lead; Neill. main dev; Tarun Raheja. An overhaul of the HEOM solver. C++ components used to speed up construction of; the hierarchy. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/roadmap.html:10454,perform,performance,10454,docs/4.6/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html,1,['perform'],['performance']
Performance,"g; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Plotting on the Bloch Sphere. Plotting on the Bloch Sphere¶. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; b = qutip.Bloch(). which will load an instance of the qutip.Bloch class, or using; >>> b3d = qutip.Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; b.make_sphere(). (png, hires.png, pdf). or. In addition to the show command, see the API documentation for Bloch for a full list of other available functions.; As an example, we can add a single data point:; pnt = [1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)]; b.add_points(pnt); b.render(). (png, hires.png, pdf). and then a single vector:; b.fig.clf(); vec = [0, 1, 0]; b.add_vectors(vec); b.render(). (png, hires.png, pdf). and then add another vector corresponding to the \(\left|\rm up \right>\) state:; up = qutip.basis(2, 0); b.add_states(up); b.render(). (png, hires.png, pdf). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:; b ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-bloch.html:1866,load,loads,1866,docs/4.6/guide/guide-bloch.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html,1,['load'],['loads']
Performance,"g=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:task: a Python function. The function that is to be called for each value in task_vec. values: array / list. The list or array of values for which the task function is to be; evaluated. task_args: list / dictionary. The optional additional argument to the task function. task_kwargs: list / dictionary. The optional additional keyword argument to the task function. client: IPython.parallel.Client. The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view. The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False. Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False. Display a HTML-based progress bar during the execution of the parfor; loop. Returns:result : list. The result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:version_table: string. Return an HTML-formatted string containing version information for; QuTiP dependenc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:200439,load,load-balanced,200439,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,3,['load'],['load-balanced']
Performance,"g=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:; task (a Python function) – The function that is to be called for each value in task_vec.; task_vec (array / list) – The list or array of values for which the task function is to be; evaluated.; args (list / dictionary) – The optional additional argument to the task function. For example; a dictionary with parameter values.; client (IPython.parallel.Client) – The IPython.parallel Client instance that will be used in the; parfor execution.; view (a IPython.parallel.Client view) – The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view().; show_scheduling (bool {False, True}, default False) – Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster.; show_progressbar (bool {False, True}, default False) – Display a HTML-based progress bar duing the execution of the parfor; loop. Returns:result – The result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. Return type:list. parallel_map(task, values, task_args=None, task_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:200565,load,load-balanced,200565,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['load'],['load-balanced']
Performance,"garithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.isoper and rho.dims != [[2, 2], [2, 2]]:; raise Exception(""Density matrix must be tensor product of two qubits.""). if rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). [docs]de",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/entropy.html:4829,concurren,concurrence,4829,docs/3.1.0/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/entropy.html,2,['concurren'],['concurrence']
Performance,"garithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.isoper and rho.dims != [[2, 2], [2, 2]]:; raise Exception(""Density matrix must be tensor product of two qubits.""). if rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). def nega",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/entropy.html:3641,concurren,concurrence,3641,docs/4.2/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/entropy.html,14,['concurren'],['concurrence']
Performance,"garithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] https://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.isoper and rho.dims != [[2, 2], [2, 2]]:; raise Exception(""Density matrix must be tensor product of two qubits.""). if rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). def neg",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/entropy.html:1958,concurren,concurrence,1958,docs/4.7/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html,2,['concurren'],['concurrence']
Performance,"gator(blist, tlist, tau, c1=None, c2=None, notrace=False)[source]¶; Compute propagator for computing output field expectation values; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters. blistarray_likeList of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlistarray_likelist of corresponding times t1,..,tn at which to evaluate the field; operators. taufloattime-delay. c1qutip.Qobjsystem collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns. : qutip.Qobjtime-propagator for computing field correlation function. propagator(t, tau, notrace=False)[source]¶; Compute propagator for time t and time-delay tau. Parameters. tfloatcurrent time. taufloattime-delay. notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; ——-; : :class:`qutip.Qobj`time-propagator for reduced system dynamics. rhot(rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). tfloatcurrent time. taufloattime-delay. Returns. : qutip.Qobjdensity matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options for the Tra",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:43953,perform,performed,43953,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['perform'],['performed']
Performance,"gen.apply_params(init_pulse_params); guess_pulse_action = init_pulse_params.get('pulse_action'). optim.pulse_generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params). lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub. if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action. if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]. else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__); return optim. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:68576,optimiz,optimizer,68576,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimizer']
Performance,"genenergies(); eig_distances = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A). if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (∞-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Thus, we must yet again go dense.; return la.norm(op.data.todense(), 2). # If we're still here, we need to actually solve the problem. # Assume square...; dim = np.prod(J.dims[0][0]). # The constraints only depend on the dimension, so; # we can cache them efficiently.; problem, Jr, Ji, X, rho0, rho1 = dnorm_problem(dim). # Load the parameters with the Choi matrix passed in.; J_dat = J.data. Jr.value = sp.csr_matrix((J_dat.data.real, J_dat.indices, J_dat.indptr),; shape=J_dat.shape). Ji.value = sp.csr_matrix((J_dat.data.imag, J_dat.indices, J_dat.indptr),; shape=J_dat.shape); # Finally, set up and run the problem.; problem.solve(solver=solver, verbose=verbose). return problem.value. def unitarity(oper):; """"""; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map's superoperator representation. Parameters; ----------; oper : Qobj; Quantum map under consideration. Returns; -------; u : float; Unitarity of ``oper``.; """"""; Eu = _super_to_superpauli(oper).full()[1:, 1:]; #return np.real(np.trace(np.dot(Eu, Eu.conj().T))) / len(Eu); return np.linalg.norm(Eu, 'fro')**2 / len(Eu). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/metrics.html:13514,cache,cache,13514,docs/4.4/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/metrics.html,1,['cache'],['cache']
Performance,"generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params). lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub. if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action. if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]. else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__); return optim. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:69437,optimiz,optimizer,69437,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,1,['optimiz'],['optimizer']
Performance,"gmax(),ohmic_spectrum]], e_ops=e_ops). where the resulting output is an instance of the class qutip.solver.Result. Time-dependent Bloch-Redfield Dynamics¶. Note; New in QuTiP 4.2. Warning; It takes ~3-5 seconds (~30 if using Visual Studio) to compile a time-dependent Bloch-Redfield problem. Therefore,; if you are doing repeated simulations by varying parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; In [18]: ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). In [19]: output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python fu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html:14774,scalab,scalability,14774,docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,4,['scalab'],['scalability']
Performance,"grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operator from t=0 to t=T based on the final amps. evo_full_initial : Qobj; The evolution operator from t=0 to t=T based on the initial amps; ; stats : Stats; Object contaning the stats for the run (if any collected); ; optimizer : Optimizer; Instance of the Optimizer used to generate the result; """"""; def __init__(self):; self.reset(). def reset(self):; self.fidelity = 0.0; self.initial_fid_err = np.Inf; self.fid_err = np.Inf; self.goal_achieved = False; self.grad_norm_final = 0.0; self.grad_norm_min_reached = False; self.num_iter = 0; self.max_iter_exceeded = False; self.num_fid_func_calls = 0; self.max_fid_func_exceeded = False; self.wall_time = 0.0; self.wall_time_limit_exceeded = False; self.termination_reason = ""not started yet""; self.time = None; self.initial_amps = None; self.final_amps = None; self.evo_full_final = None; self.evo_full_initial = None; self.stats = None; self.optimizer = None. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/optimresult.html:4010,optimiz,optimizer,4010,docs/4.4/modules/qutip/control/optimresult.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/optimresult.html,2,['optimiz'],['optimizer']
Performance,"h; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype¶; type – Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_gen¶; bool – If True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_grad¶; bool – If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj¶; bool – If True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp¶; bool – If True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_optimization<=1, otherwise False. num_tslots¶; integer – Number of timeslots (aka timeslices). num_ctrls¶; integer – Number of controls.; Note this is calculated as the length of ctrl_dyn_gen when first used.; And is recalculated during initialise_controls only. evo_time¶; float – Total time for the evolution. tau¶; array[num_tslots] of float – Duration of each timeslot; Note that if this is set before initialize_controls is called; then n",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:78743,cache,cache,78743,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['cache'],['cache']
Performance,"hat contains only the states; corresponding to indices that are **not** in `state_inds`. Notes; -----; Experimental. """"""; keep_indices = np.array([s not in states_inds; for s in range(self.shape[0])]).nonzero()[0]. return self.extract_states(keep_indices, normalize=normalize). [docs] def dnorm(self, B=None):; """"""Calculates the diamond norm, or the diamond distance to another; operator. Parameters; ----------; B : :class:`qutip.Qobj` or None; If B is not None, the diamond distance d(A, B) = dnorm(A - B); between this operator and B is returned instead of the diamond; norm. Returns; -------; d : float; Either the diamond norm of this operator, or the diamond distance; from this operator to B. """"""; return mts.dnorm(self, B). @property; def ishp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = sr.to_choi(self); return J.isherm; except TypeError:; return False; else:; return False. @property; def iscp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = (; self; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.superrep in ('choi', 'chi'); else sr.to_choi(self); ); # If J isn't hermitian, then that could indicate either; # that J is not normal, or is normal,; # but has complex eigenvalues.; # In either case, it makes no sense to then demand that the; # eigenvalues be non-negative.; if not J.isherm:; return False; eigs = J.eigenenergies(); return all(eigs >= -settings.atol); except TypeError:; return False; else:; return False. @property; def istp(self):; import qutip.superop_reps as sr; if self.type in [""super"", ""oper""]:; try:; # Normalize to a super of type choi or chi.; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.type == ""super"" a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobj.html:49570,cache,cached,49570,docs/4.6/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html,2,['cache'],['cached']
Performance,"hat is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes; -----; [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011).; [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011).; """""". def reset(self):; OptimizerCrab.reset(self); self.id_text = 'CRAB_FMIN'; self.xtol = 1e-4; self.ftol = 1e-4. [docs] def run_optimization(self, term_conds=None):; """"""; This function optimisation method is a wrapper to the; scipy.optimize.fmin function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Spec",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:36266,optimiz,optimize,36266,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,6,['optimiz'],['optimize']
Performance,"hat the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (∞-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Thus, we must yet again go dense.; return la.norm(op.full(), 2). # If we're still here, we need to actually solve the problem. # Assume square...; dim = np.prod(J.dims[0][0]). J_dat = J.data. if not sparse:; # The parameters and constraints only depend on the dimension, so; # we can cache them efficiently.; problem, Jr, Ji = dnorm_problem(dim). # Load the parameters with the Choi matrix passed in.; Jr.value = sp.csr_matrix((J_dat.data.real, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(). Ji.value = sp.csr_matrix((J_dat.data.imag, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(); else:. # The parameters do not depend solely on the dimension,; # so we can not cache them efficiently.; problem = dnorm_sparse_problem(dim, J_dat). problem.solve(solver=solver, verbose=verbose). return problem.value. [docs]def unitarity(oper):; """"""; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map's superoperator representation. Parameters; ----------; oper : Qobj; Quantum map under consideration. Returns; -------; u : float; Unitarity of ``oper``.; """"""; Eu = _super_to_superpauli(oper).full()[1:, 1:]; #return np.real(np.trace(np.dot(Eu, Eu.conj().T))) / len(Eu); return np.linalg.norm(Eu, 'fro')**2 / len(Eu). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/metrics.html:12576,cache,cache,12576,docs/4.7/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/metrics.html,1,['cache'],['cache']
Performance,"hbar via hbar=2/g^2 giving the default; value hbar=1. methodstring {‘clenshaw’, ‘iterative’, ‘laguerre’, ‘fft’}Select method ‘clenshaw’ ‘iterative’, ‘laguerre’, or ‘fft’, where ‘clenshaw’; and ‘iterative’ use an iterative method to evaluate the Wigner functions for density; matrices \(|m><n|\), while ‘laguerre’ uses the Laguerre polynomials; in scipy for the same task. The ‘fft’ method evaluates the Fourier; transform of the density matrix. The ‘iterative’ method is default, and; in general recommended, but the ‘laguerre’ method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The ‘clenshaw’ method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). ‘clenshaw’ is a fast and numerically stable method. sparsebool {False, True}Tells the default solver whether or not to keep the input density; matrix in sparse format. As the dimensions of the density matrix; grow, setthing this flag can result in increased performance. parforbool {False, True}Flag for calculating the Laguerre polynomial based Wigner function; method=’laguerre’ in parallel using the parfor function. Returns. WarrayValues representing the Wigner function calculated over the specified; range [xvec,yvec]. yvexarrayFFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; The ‘fft’ method accepts only an xvec input for the x-coordinate.; The y-coordinates are calculated internally.; References; Ulf Leonhardt,; Measuring the Quantum State of Light, (Cambridge University Press, 1997). Graphs and Visualization¶; Functions for visualizing results of quantum dynamics simulations,; visualizations of quantum states and processes. hinton(rho, xlabels=None, ylabels=None, title=None, ax=None, cmap=None, label_top=True)[source]¶; Draws a Hinton diagram for visualizing a density matrix or superoperator. Parameters. rhoqobjInput density matrix or superoperator. xlabelsli",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:150297,perform,performance,150297,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,2,['perform'],['performance']
Performance,"hbar via hbar=2/g^2 giving the default; value hbar=1. methodstring {‘clenshaw’, ‘iterative’, ‘laguerre’, ‘fft’}Select method ‘clenshaw’ ‘iterative’, ‘laguerre’, or ‘fft’, where ‘clenshaw’; and ‘iterative’ use an iterative method to evaluate the Wigner functions for density; matrices \(|m><n|\), while ‘laguerre’ uses the Laguerre polynomials; in scipy for the same task. The ‘fft’ method evaluates the Fourier; transform of the density matrix. The ‘iterative’ method is default, and; in general recommended, but the ‘laguerre’ method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The ‘clenshaw’ method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). ‘clenshaw’ is a fast and numerically stable method. sparsebool {False, True}Tells the default solver whether or not to keep the input density; matrix in sparse format. As the dimensions of the density matrix; grow, setthing this flag can result in increased performance. parforbool {False, True}Flag for calculating the Laguerre polynomial based Wigner function; method=’laguerre’ in parallel using the parfor function. Returns. WarrayValues representing the Wigner function calculated over the specified; range [xvec,yvec]. yvexarrayFFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; The ‘fft’ method accepts only an xvec input for the x-coordinate.; The y-coordinates are calculated internally.; References; Ulf Leonhardt,; Measuring the Quantum State of Light, (Cambridge University Press, 1997). Graphs and Visualization¶; Functions for visualizing results of quantum dynamics simulations,; visualizations of quantum states and processes. hinton(rho, xlabels=None, ylabels=None, title=None, ax=None, cmap=None, label_top=True, color_style='scaled')[source]¶; Draws a Hinton diagram for visualizing a density matrix or superoperator. Parameters. rhoqobjInput density matrix or su",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:173911,perform,performance,173911,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['perform'],['performance']
Performance,"he algorithm see above. optim_params : Dictionary. The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float. Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer. Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_method : string. Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict. Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_type : string. Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict. Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string. Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the spe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:173137,optimiz,optimize,173137,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['optimiz'],['optimize']
Performance,"he algorithm see above. optim_params : Dictionary. The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float. Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer. Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_method : string. Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict. Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string. determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params : dict. Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict. Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict. Pa",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:181768,optimiz,optimize,181768,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['optimiz'],['optimize']
Performance,"he algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the spe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:187938,optimiz,optimize,187938,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"he algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict; Pa",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:196573,optimiz,optimize,196573,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"he argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(self, term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(self, *args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(self, term_conds=None)[source]¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason fo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:80188,optimiz,optimize,80188,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['optimiz'],['optimize']
Performance,"hen amplitudes change. clear(self)[source]¶; clear any temporarily held status data. compute_fid_grad(self)[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed(self)[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err(self)[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient(self)[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity(self)[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm(self)[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp(self)[source]¶; Check configuration and initialise the normalisation. init_normalization(self)[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(self, A)[source]¶. normalize_SU(self, A)[source]¶. normalize_gradient_PSU(self, grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(self, grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:110371,cache,cached,110371,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['cache'],['cached']
Performance,"hill and J. McKee, “Reducing the Bandwidth of Sparse Symmetric; Matrices”, ACM ‘69 Proceedings of the 1969 24th national conference,; (1969). weighted_bipartite_matching(A, perm_type='row')[source]¶; Returns an array of row permutations that attempts to maximize the product; of the ABS values of the diagonal elements in a nonsingular square CSC; sparse matrix. Such a permutation is always possible provided that the; matrix is nonsingular.; This function looks at both the structure and ABS values of the underlying; matrix. Parameters. Acsc_matrixInput matrix. perm_typestr {‘row’, ‘column’}Type of permutation to generate. Returns. permarrayArray of row or column permutations. Notes; This function uses a weighted maximum cardinality bipartite matching; algorithm based on breadth-first search (BFS). The columns are weighted; according to the element of max ABS value in the associated rows and are; traversed in descending order by weight. When performing the BFS; traversal, the row associated to a given column is the one with maximum; weight. Unlike other techniques[1]_, this algorithm does not guarantee the; product of the diagonal is maximized. However, this limitation is offset; by the substantially faster runtime of this method.; References; I. S. Duff and J. Koster, “The design and use of algorithms for permuting; large entries to the diagonal of sparse matrices”, SIAM J. Matrix Anal.; and Applics. 20, no. 4, 889 (1997). Utility Functions¶; This module contains utility functions that are commonly needed in other; qutip modules. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters. j1floatTotal angular momentum 1. j2floatTotal angular momentum 2. j3floatTotal angular momentum 3. m1floatz-component of angular momentum 1. m2floatz-component of angular momentum 2. m3floatz-component of angular momentum 3. Returns. cg_coefffloatRequested Clebsch-Gordan coefficient. convert_unit(v",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:245868,perform,performing,245868,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['perform'],['performing']
Performance,"his section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file.; Optimizer; This acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm.; Dynamics; This is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators.; PulseGen; There are many subclasses of pulse generators that generate different types of pulses as the initial amplitudes for the optimisation. Often the goal cannot be achieved from all starting conditions, and then typically ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-control.html:14878,optimiz,optimize,14878,docs/4.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-control.html,4,"['optimiz', 'perform']","['optimize', 'perform']"
Performance,"his trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, …) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The; first is an implementation of first order GRAPE, and is not further described; here, but there are the example notebooks. The second is referred to as Qtrl; (when a distinction needs to be made) as this was its name before it was; integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the; multi-variable optimisation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to h",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-control.html:13377,optimiz,optimize,13377,docs/4.7/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html,2,"['optimiz', 'perform']","['optimize', 'perform']"
Performance,"hm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error. Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods. Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying DEF; will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or; the termination_conditions matching the key that attribute.; Otherwise, and in some case also, they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the propagators and; propagator gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT. DEF will use the default for the specific; dyn_type (see PropagatorComputer; classes for details). prop_paramsdictParameters for the PropagatorComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. fid_typestringFidelity error (and fidelity error gradie",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:240735,optimiz,optimize,240735,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['optimiz'],['optimize']
Performance,"hon engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar duing the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of ``task(value, args)`` for each; value in ``task_vec``, that is, it should be equivalent to; ``[task(v, args) for v in task_vec]``.; """""". if show_progressbar:; progress_bar = HTMLProgressBar(); else:; progress_bar = None. return parallel_map(task, task_vec, task_args=args,; client=client, view=view, progress_bar=progress_bar,; show_scheduling=show_scheduling). [docs]def parallel_map(task, values, task_args=None, task_kwargs=None,; client=None, view=None, progress_bar=None,; show_scheduling=False, **kwargs):; """"""; Call the function ``task`` for each value in ``values`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, *args, **kwargs)``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. values: array / list; The list or array of values for which the ``task`` function is to be; evaluated. task_args: list / dictionary; The optional additional argument to the ``task`` function. task_kwargs: list / dictionary; The optional additional keyword argument to the ``task`` function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/ipynbtools.html:9297,load,load-balanced,9297,docs/4.2/modules/qutip/ipynbtools.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/ipynbtools.html,9,['load'],['load-balanced']
Performance,"i0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: expect(a.dag() * a, dm_list_loaded.states); Out[15]: ; array([ 3.40657352, 2.74980446, 2.29441406, 1.96186716, 1.71601185,; 1.5332011 , 1.39683111, 1.29490432, 1.21862519, 1.16149242]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes two mandatory and three optional arguments:; >>> file_data_store(filename, data, numtype=""complex"", numformat=""decimal"", sep="",""). where filename is the name of the file, data is the data to be written to the file (must be a numpy array), numtype (optional) is a flag indicating numerical type that can take values complex or real, numformat (optional) specifies the numerical format that can take the values exp for the format 1.0e1 and decimal for the format 10.0, and sep (optional) is an arbitrary single-character field separator (usually a tab, space, comma, semicolon, etc.).; A common use for the qutip.fileio.file_data_store function is to store the expectation values of a set of operators for a sequence of times, e.g., as returned by the qutip.mesolve function, which is what the following example does:; In [16]: a =",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-saving.html:4251,load,load,4251,docs/4.2/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-saving.html,1,['load'],['load']
Performance,"i0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: expect(a.dag() * a, dm_list_loaded.states); Out[15]: ; array([ 4.29179401, 3.37589742, 2.75659972, 2.30562634, 1.97257341,; 1.72505191, 1.54045945, 1.40251047, 1.2992826 , 1.22196967]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes two mandatory and three optional arguments:; >>> file_data_store(filename, data, numtype=""complex"", numformat=""decimal"", sep="",""). where filename is the name of the file, data is the data to be written to the file (must be a numpy array), numtype (optional) is a flag indicating numerical type that can take values complex or real, numformat (optional) specifies the numerical format that can take the values exp for the format 1.0e1 and decimal for the format 10.0, and sep (optional) is an arbitrary single-character field separator (usually a tab, space, comma, semicolon, etc.).; A common use for the qutip.fileio.file_data_store function is to store the expectation values of a set of operators for a sequence of times, e.g., as returned by the qutip.mesolve function, which is what the following example does:; In [16]: a =",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-saving.html:4239,load,load,4239,docs/4.0.2/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-saving.html,1,['load'],['load']
Performance,"i0, times, c_ops, []). In [13]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [14]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [15]: a = destroy(10). In [16]: expect(a.dag() * a, dm_list_loaded.states); Out[16]: ; array([ 3.87543797, 3.11893669, 2.5717301 , 2.17012827, 1.87240607,; 1.65062668, 1.48498272, 1.36107052, 1.26828395, 1.19875921]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes two mandatory and three optional arguments:; >>> file_data_store(filename, data, numtype=""complex"", numformat=""decimal"", sep="",""). where filename is the name of the file, data is the data to be written to the file (must be a numpy array), numtype (optional) is a flag indicating numerical type that can take values complex or real, numformat (optional) specifies the numerical format that can take the values exp for the format 1.0e1 and decimal for the format 10.0, and sep (optional) is an arbitrary single-character field separator (usually a tab, space, comma, semicolon, etc.).; A common use for the qutip.fileio.file_data_store function is to store the expectation values of a set of operators for a sequence of times, e.g., as returned by the qutip.mesolve function, which is what the following example does:; In [17]: a =",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-saving.html:4938,load,load,4938,docs/3.0.0/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-saving.html,1,['load'],['load']
Performance,"iP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator; >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steady",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-saving.html:1527,perform,performed,1527,docs/4.7/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html,1,['perform'],['performed']
Performance,"ial state vector (ket). tlist : list / array. list of times for \(t\). e_ops : list of qutip.qobj / callback function. list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. Dictionary with variables required to evaluate H. Tsteps : integer. The number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns:output : qutip.solver.Result. An instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶; This module contains experimental functions for solving stochastic schrodinger; and master equations. The API should not be considered stable, and is subject; to change when we work more on optimizing this module for performance and; features.; Todo:. parallelize. smesolve(H, rho0, times, c_ops, sc_ops, e_ops, **kwargs)¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters:H : qutip.Qobj. System Hamiltonian. rho0 : qutip.Qobj. Initial density matrix or state vector (ket). times : list / array. List of times for \(t\). Must be uniformly spaced. c_ops : list of qutip.Qobj. Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_ops : list of qutip.Qobj. List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_ops : list of qutip.Qobj / callback function single. single operator or list of operators for which to evaluate; expectation values. kwargs : dictionary. Optional keyword arg",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:54662,optimiz,optimizing,54662,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,4,"['optimiz', 'perform']","['optimizing', 'performance']"
Performance,"iamond norm, or the diamond distance to another; operator. Parameters:; B : Qobj or None; If B is not None, the diamond distance d(A, B) = dnorm(A - B) between; this operator and B is returned instead of the diamond norm. Returns:; d : float; Either the diamond norm of this operator, or the diamond distance; from this operator to B. dual_chan()[source]¶; Dual channel of quantum object representing a completely positive; map. eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]¶; Eigenenergies of a quantum object.; Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters:; sparse : bool; Use sparse Eigensolver. sort : str; Sort eigenvalues ‘low’ to high, or ‘high’ to low. eigvals : int; Number of requested eigenvalues. Default is all eigenvalues. tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns:; eigvals : array; Array of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters:; sparse : bool; Use sparse Eigensolver. sort : str; Sort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvals : int; Number of requested eigenvalues. Default is all eigenvalues. tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns:; eigvals : array; Array of eigenvalues for operator. eigvecs : array; Array of quantum operators representing the oprator eigenkets.; Order o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:6395,perform,performed,6395,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['perform'],['performed']
Performance,"ib.figure.Figure at 0x10b2196d0>. In [9]: plot(times, np.real(corr1), times, np.real(corr2), times, np.real(corr3)); Out[9]: ; [<matplotlib.lines.Line2D at 0x10b4a3490>,; <matplotlib.lines.Line2D at 0x10b4a33d0>,; <matplotlib.lines.Line2D at 0x10b4fddd0>]. In [10]: legend(['0.5','1.0','2.0']); Out[10]: <matplotlib.legend.Legend at 0x10df0d310>. In [11]: xlabel(r'Time $t$'); Out[11]: <matplotlib.text.Text at 0x10d29b1d0>. In [12]: ylabel(r'Correlation $\left<x(t)x(0)\right>$'); Out[12]: <matplotlib.text.Text at 0x10d263f90>. In [13]: show(). Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[\begin{split}S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\end{split}\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using the qutip.essolve.essolve solver and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; import numpy as np; from qutip import *; import pylab as plt. N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * np.pi # cavity and atom frequency; g = 0.1 * 2 * np.pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = tensor(destroy(N), qeye(2)); sm = tensor(qeye(N), destroy(2)); H = wc * a.dag() * a + wa * sm.dag() * sm + g * (a.dag() * sm + a * sm.dag()). # collapse operators; n_th = 0.25; c_ops = [np.sqrt(kappa * (1 + n_th)) * a, np.sqrt(kappa * n_th) * a.dag(), np.sqrt(gamma) * sm]. # calculate the correlation function using the mesolve solver, and then fft to; # obtain the spectrum. Here we need to make sure ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-correlation.html:6092,perform,performs,6092,docs/3.1.0/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-correlation.html,1,['perform'],['performs']
