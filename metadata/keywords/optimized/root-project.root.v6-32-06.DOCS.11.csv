quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Integrability,"essing. ### Implicit Multi-Threading; When `ROOT::EnableImplicitMT()` is used, RNTuple uses ROOT's task arena to compress and decompress pages.; That requires writes to be buffered and reads uses the cluster pool resp.; The RNTuple data source for RDataFrame lets RDataFrame full control of the thread pool.; That means that RDataFrame uses a separate data source for every thread, each of the data sources runs in sequential mode. ### Concurrent Readers; Multiple readers can read the same RNTuple concurrently as long as access to every individual reader is sequential. ### Parallel REntry Preparation; Multiple `REntry` object can be concurrently prepared by multiple threads.; I.e., construction and binding of the objects can happen in parallel.; The actual reading and writing of entries (`RNTupleReader::LoadEntry()`, `RNTupleWriter::Fill()`) needs to be protected by a mutex.; This is considered ""mild scalability parallelization"" in RNTuple. ### RNTupleParallelWriter; The parallel writer offers the most scalable parallel writing interface.; Multiple _fill contexts_ can concurrently serialize and compress data.; Every fill context prepares a set of entire clusters in the final on-disk layout.; When a fill context flushes data,; a brief serialization point handles the RNTuple meta-data updates and the reservation of disk space to write into. Low precision float types; --------------------------; RNTuple supports encoding floating point types with a lower precision when writing them to disk. This encoding is specified by the; user per field and it is independent on the in-memory type used for that field (meaning both a `RField<double>` or `RField<float>` can; be mapped to e.g. a low-precision 16 bit float). RNTuple supports the following encodings (all mutually exclusive):. - **Real16**/**SplitReal16**: IEEE-754 half precision float. Set by calling `RField::SetHalfPrecision()`;; - **Real32Trunc**: floating point with less than 32 bits of precision (truncated mantissa).; Set",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:25510,interface,interface,25510,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['interface'],['interface']
Integrability,"essions; Yes. 95; NAD; Elaborated type specifiers referencing names declared in friend decls; Clang 3.3. 96; C++11; Syntactic disambiguation using the template keyword; No. 97; NAD; Use of bool constants in integral constant expressions; Yes. 98; TC1; Branching into try block; Yes. 99; NAD; Partial ordering, references and cv-qualifiers; Superseded by 214. 100; TC1; Clarify why string literals are not allowed as template arguments; Yes. 101; TC1; Redeclaration of extern ""C"" names via using-declarations; Clang 3.5. 102; NAD; Operator lookup rules do not work well with parts of the library; Yes. 103; TC1; Is it extended-namespace-definition or extension-namespace-definition ?; N/A. 104; NAD; Destroying the exception temp when no handler is found; N/A (Library DR). 105; TC1; Meaning of ""template function""; N/A. 106; CD1; Creating references to references during template deduction/instantiation; Superseded by 540. 107; NAD; Linkage of operator functions; Yes. 108; TC1; Are classes nested in templates dependent?; Clang 2.9. 109; NAD; Allowing ::template in using-declarations; Yes. 110; CD6; Can template functions and classes be declared in the same scope?; Unknown. 111; NAD; Copy constructors and cv-qualifiers; Duplicate of 535. 112; CD1; Array types and cv-qualifiers; Yes. 113; CD1; Visibility of called function; Yes. 114; NAD; Virtual overriding by template member function specializations; Yes. 115; CD1; Address of template-id; Clang 3.0. 116; TC1; Equivalent and functionally-equivalent function templates; Yes. 117; NAD; Timing of destruction of temporaries; N/A. 118; CD1; Calls via pointers to virtual member functions; Yes. 119; CD1; Object lifetime and aggregate initialization; N/A. 120; TC1; Nonexistent non-terminal qualified-name; N/A. 121; TC1; Dependent type names with non-dependent nested-name-specifiers; Yes. 122; CD1; template-ids as unqualified-ids; Yes. 123; TC1; Bad cross-reference; N/A. 124; CD1; Lifetime of temporaries in default initialization of class ar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:7960,depend,dependent,7960,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['depend'],['dependent']
Integrability,"est(id x) {; return;; [x retain]; // warn; }. alpha.fuchsia; ^^^^^^^^^^^^^. .. _alpha-fuchsia-lock:. alpha.fuchsia.Lock; """"""""""""""""""""""""""""""""""""; Similarly to :ref:`alpha.unix.PthreadLock <alpha-unix-PthreadLock>`, checks for; the locking/unlocking of fuchsia mutexes. .. code-block:: cpp. spin_lock_t mtx1;. void bad1(void); {; spin_lock(&mtx1);; spin_lock(&mtx1);	// warn: This lock has already been acquired; }. alpha.llvm; ^^^^^^^^^^. .. _alpha-llvm-Conventions:. alpha.llvm.Conventions; """""""""""""""""""""""""""""""""""""""""""". Check code for LLVM codebase conventions:. * A StringRef should not be bound to a temporary std::string whose lifetime is shorter than the StringRef's.; * Clang AST nodes should not have fields that can allocate memory. alpha.osx; ^^^^^^^^^. .. _alpha-osx-cocoa-DirectIvarAssignment:. alpha.osx.cocoa.DirectIvarAssignment (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for direct assignments to instance variables. .. code-block:: objc. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) foo;; @end. @implementation MyClass; - (void) foo {; _A = 0; // warn; }; @end. .. _alpha-osx-cocoa-DirectIvarAssignmentForAnnotatedFunctions:. alpha.osx.cocoa.DirectIvarAssignmentForAnnotatedFunctions (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for direct assignments to instance variables in; the methods annotated with ``objc_no_direct_instance_variable_assignment``. .. code-block:: objc. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) fAnnotated __attribute__((; annotate(""objc_no_direct_instance_variable_assignment"")));; - (void) fNotAnnotated;; @end. @implementation MyClass; - (void) fAnnotated {; _A = 0; // warn; }; - (void) fNotAnnotated {; _A = 0; // no warn; }; @end. .. _alpha-osx-cocoa-InstanceVariableInvalidation:. alpha.osx.cocoa.InstanceVariableInvalidation (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that the invalidatable instance variables are; invalidated in the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:57269,interface,interface,57269,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['interface'],['interface']
Integrability,"et address is passed in X15.; ""``cc <n>``"" - Numbered convention; Any calling convention may be specified by number, allowing; target-specific calling conventions to be used. Target specific; calling conventions start at 64. More calling conventions can be added/defined on an as-needed basis, to; support Pascal conventions or any other well-known target-independent; convention. .. _visibilitystyles:. Visibility Styles; -----------------. All Global Variables and Functions have one of the following visibility; styles:. ""``default``"" - Default style; On targets that use the ELF object file format, default visibility; means that the declaration is visible to other modules and, in; shared libraries, means that the declared entity may be overridden.; On Darwin, default visibility means that the declaration is visible; to other modules. On XCOFF, default visibility means no explicit; visibility bit will be set and whether the symbol is visible; (i.e ""exported"") to other modules depends primarily on export lists; provided to the linker. Default visibility corresponds to ""external; linkage"" in the language.; ""``hidden``"" - Hidden style; Two declarations of an object with hidden visibility refer to the; same object if they are in the same shared object. Usually, hidden; visibility indicates that the symbol will not be placed into the; dynamic symbol table, so no other module (executable or shared; library) can reference it directly.; ""``protected``"" - Protected style; On ELF, protected visibility indicates that the symbol will be; placed in the dynamic symbol table, but that references within the; defining module will bind to the local symbol. That is, the symbol; cannot be overridden by another module. A symbol with ``internal`` or ``private`` linkage must have ``default``; visibility. .. _dllstorageclass:. DLL Storage Classes; -------------------. All Global Variables, Functions and Aliases can have one of the following; DLL storage class:. ``dllimport``; ""``dllimport``"" ca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:23543,depend,depends,23543,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['depends']
Integrability,"et(CONFIG_COMMAND ${LLVM_CONFIG}; ""--assertion-mode""; ""--bindir""; ""--libdir""; ""--includedir""; ""--prefix""; ""--cmakedir""; ""--build-mode""; ""--version""); execute_process(; COMMAND ${CONFIG_COMMAND}; RESULT_VARIABLE HAD_ERROR; OUTPUT_VARIABLE CONFIG_OUTPUT; ); if(NOT HAD_ERROR); string(REGEX REPLACE; ""[ \t]*[\r\n]+[ \t]*"" "";""; CONFIG_OUTPUT ${CONFIG_OUTPUT}); else(); string(REPLACE "";"" "" "" CONFIG_COMMAND_STR ""${CONFIG_COMMAND}""); message(STATUS ""${CONFIG_COMMAND_STR}""); message(FATAL_ERROR ""llvm-config failed with status ${HAD_ERROR}""); endif(); else(); message(FATAL_ERROR ""llvm-config not found -- ${LLVM_CONFIG}""); endif(). list(GET CONFIG_OUTPUT 0 ENABLE_ASSERTIONS); list(GET CONFIG_OUTPUT 1 TOOLS_BINARY_DIR); list(GET CONFIG_OUTPUT 2 LIBRARY_DIR); list(GET CONFIG_OUTPUT 3 INCLUDE_DIR); list(GET CONFIG_OUTPUT 4 LLVM_OBJ_ROOT); list(GET CONFIG_OUTPUT 5 LLVM_CONFIG_CMAKE_PATH); list(GET CONFIG_OUTPUT 6 LLVM_BUILD_MODE); list(GET CONFIG_OUTPUT 7 LLVM_VERSION). message(STATUS ""External llvm built in ${LLVM_BUILD_MODE} mode.""). if(NOT MSVC_IDE); set(LLVM_ENABLE_ASSERTIONS ${ENABLE_ASSERTIONS}; CACHE BOOL ""Enable assertions""); # Assertions should follow llvm-config's.; mark_as_advanced(LLVM_ENABLE_ASSERTIONS); endif(). set(LLVM_TOOLS_BINARY_DIR ${TOOLS_BINARY_DIR} CACHE PATH ""Path to llvm/bin""); set(LLVM_LIBRARY_DIR ${LIBRARY_DIR} CACHE PATH ""Path to llvm/lib""); set(LLVM_MAIN_INCLUDE_DIR ${INCLUDE_DIR} CACHE PATH ""Path to llvm/include""); set(LLVM_BINARY_DIR ${LLVM_OBJ_ROOT} CACHE PATH ""Path to LLVM build tree""). set(LLVM_DIR ""${LLVM_BINARY_DIR}""). # Normalize LLVM_CMAKE_PATH. --cmakedir might contain backslashes.; # CMake assumes slashes as PATH.; file(TO_CMAKE_PATH ${LLVM_CONFIG_CMAKE_PATH} LLVM_CMAKE_PATH). find_program(LLVM_TABLEGEN_EXE ""llvm-tblgen"" ${LLVM_TOOLS_BINARY_DIR}; NO_DEFAULT_PATH). set(LLVMCONFIG_FILE ""${LLVM_CMAKE_PATH}/LLVMConfig.cmake""); if(EXISTS ${LLVMCONFIG_FILE}); list(APPEND CMAKE_MODULE_PATH ""${LLVM_CMAKE_PATH}""); include(${LLVMCONFIG_FILE}); else(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt:13679,message,message,13679,interpreter/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt,1,['message'],['message']
Integrability,"et(stldicts; vector; list; forward_list; deque; map map2 unordered_map; multimap multimap2 unordered_multimap; set unordered_set; multiset unordered_multiset; complex); if(NOT WIN32); list(APPEND stldicts valarray); endif(); foreach(dict ${stldicts}); string(REPLACE ""2"" """" header ${dict}); string(REPLACE ""complex"" ""root_std_complex.h"" header ${header}); string(REPLACE ""multi"" """" header ${header}); ROOT_STANDARD_LIBRARY_PACKAGE(${dict}Dict; NO_SOURCES NO_INSTALL_HEADERS NO_CXXMODULE; STAGE1; NODEPHEADERS ${header}; LINKDEF src/${dict}Linkdef.h; DICTIONARY_OPTIONS --noIncludePaths; DEPENDENCIES Core); target_include_directories(${dict}Dict PRIVATE ${CMAKE_SOURCE_DIR}/interpreter/cling/include/cling/cint); endforeach(). set(CLANG_RESOURCE_DIR_STEM); if (builtin_clang); set(CLANG_RESOURCE_DIR_STEM ${CMAKE_BINARY_DIR}/interpreter/llvm-project/llvm/${CMAKE_CFG_INTDIR}/lib/clang); set(CLANG_RESOURCE_DIR_VERSION ${LLVM_VERSION_MAJOR}); else (); set(CLANG_RESOURCE_DIR_STEM ${LLVM_LIBRARY_DIR}/clang); # A user can define a clang version to use, otherwise find it (but will error if more than one version is present); if (NOT DEFINED CLANG_RESOURCE_DIR_VERSION); if (NOT EXISTS ${CLANG_RESOURCE_DIR_STEM}); message(FATAL_ERROR ""${CLANG_RESOURCE_DIR_STEM} does not exist. Please install clang.""); endif(); # There is no reasonable way to get the version of clang under which is its resource directory.; # For example, lib/clang/5.0.0/include. Deduce it.; file(GLOB CHILDREN RELATIVE ${CLANG_RESOURCE_DIR_STEM} ${CLANG_RESOURCE_DIR_STEM}/*); list(LENGTH CHILDREN CHILDREN_LENGTH); if (${CHILDREN_LENGTH} GREATER 1); message(FATAL_ERROR ""Found more than one version of clang. CLANG_RESOURCE_DIR_VERSION contains: '${CHILDREN}'."" ); endif(). list(GET CHILDREN 0 CLANG_RESOURCE_DIR_VERSION); endif(); endif(). set(CLANG_RESOURCE_DIR ${CLANG_RESOURCE_DIR_STEM}/${CLANG_RESOURCE_DIR_VERSION}/include). #---Deal with clang resource here----------------------------------------------; install(DIRECTORY ${",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/CMakeLists.txt:2957,message,message,2957,core/clingutils/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/CMakeLists.txt,1,['message'],['message']
Integrability,"et, Extend)>;; }. defm : ro_signed_pats<""B"", Rm, Base, Offset, Extend,; !foreach(decls.pattern, address,; !subst(SHIFT, imm_eq0, decls.pattern)),; i8>;. See the :doc:`TableGen Programmer's Reference <./ProgRef>` for an in-depth; description of TableGen. .. _backend:; .. _backends:. TableGen backends; =================. TableGen files have no real meaning without a backend. The default operation; when running ``*-tblgen`` is to print the information in a textual format, but; that's only useful for debugging the TableGen files themselves. The power; in TableGen is, however, to interpret the source files into an internal; representation that can be generated into anything you want. Current usage of TableGen is to create huge include files with tables that you; can either include directly (if the output is in the language you're coding),; or be used in pre-processing via macros surrounding the include of the file. Direct output can be used if the backend already prints a table in C format; or if the output is just a list of strings (for error and warning messages).; Pre-processed output should be used if the same information needs to be used; in different contexts (like Instruction names), so your backend should print; a meta-information list that can be shaped into different compile-time formats. See :doc:`TableGen BackEnds <./BackEnds>` for a list of available; backends, and see the :doc:`TableGen Backend Developer's Guide <./BackGuide>`; for information on how to write and debug a new backend. Tools and Resources; ===================. In addition to this documentation, a list of tools and resources for TableGen; can be found in TableGen's; `README <https://github.com/llvm/llvm-project/blob/main/llvm/utils/TableGen/README.md>`_. TableGen Deficiencies; =====================. Despite being very generic, TableGen has some deficiencies that have been; pointed out numerous times. The common theme is that, while TableGen allows; you to build domain specific languages, the f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/index.rst:11281,message,messages,11281,interpreter/llvm-project/llvm/docs/TableGen/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/index.rst,1,['message'],['messages']
Integrability,"et`** are specified by; `SetFlags(Int_t flags)` and `ClearFlags(Int_t flags)` methods. The; status flags are: `kWidgetWantFocus`, `kWidgetHasFocus`, and; `kWidgetIsEnabled`. The method `Associate(const TGWindow* w)` - sets the; window which handles the widget events.; `SetCommand(const char* command)` - sets the command to be executed. The; command string can be gathering via `GetCommand()` method. For example,; the third parameter in **`TGTextButton`** constructor can be omitted and; set later in your program, i.e. instead of:. ``` {.cpp}; TGTextButton *exit = new TGTextButton(hframe,""&Exit"",; ""gApplication->Terminate()"");; ```. You will have the following the two lines:. ``` {.cpp}; TGTextButton *exit = new TGTextButton(hframe,""&Exit"");; exit->SetCommand(""gApplication->Terminate()"");; ```. The method `IsEnabled()` - returns `kTRUE` if the widget has flag; `kWidgetIsEnabled` and it accepts user events. This method is very; important for creating a good user interface because it allows you to; disable or enable a widget depending on the situation of your; application. As a standard all disabled widgets are displayed ""grayed; out"". `HasFocus()` - returns `kTRUE` if the widget has the input focus; (i.e. flag `kWidgetHasFocus` is set). Remember that only one item in a; complex widget as a dialog can have the value of `HasFocus()` sets as; true. `WantFocus()` - returns `kTRUE` if the flag `kWidgetWantFocus` is; set. ### TGWindow. **`TGWindow`** is a ROOT GUI window base class. It inherits from; **`TGObject`** and **`TGFrame`** derives from it. The application does; not use it directly. It creates and registers a new window within the; system. This window has common characteristics: existing parent,; location, size in height and width (it has a default minimum size 1, 1; under which it cannot shrink), border with particular view, state,; specific attributes. If there are no specified arguments their values; will be taken from the parent. It receives events from the windo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:23126,interface,interface,23126,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,2,"['depend', 'interface']","['depending', 'interface']"
Integrability,"eter of a function or an ObjC method declaration or a; block. Does not match the 'this' parameter of a method. Given; class X { void f(int x, int y, int z) {} };; cxxMethodDecl(hasAnyParameter(hasName(""y""))); matches f(int x, int y, int z) {}; with hasAnyParameter(...); matching int y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end. the matcher objcMethodDecl(hasAnyParameter(hasName(""y""))); matches the declaration of method f with hasParameter; matching y. For blocks, given; b = ^(int y) { printf(""%d"", y) };. the matcher blockDecl(hasAnyParameter(hasName(""y""))); matches the declaration of the block b with hasParameter; matching y. Matcher<ObjCMethodDecl>hasParameterunsigned N, Matcher<ParmVarDecl> InnerMatcher; Matches the n'th parameter of a function or an ObjC method; declaration or a block. Given; class X { void f(int x) {} };; cxxMethodDecl(hasParameter(0, hasType(varDecl()))); matches f(int x) {}; with hasParameter(...); matching int x. For ObjectiveC, given; @interface I - (void) f:(int) y; @end. the matcher objcMethodDecl(hasParameter(0, hasName(""y""))); matches the declaration of method f with hasParameter; matching y. Matcher<ObjCPropertyDecl>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:223227,interface,interface,223227,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['interface'],['interface']
Integrability,eter pack end?; Not resolved. 2106; CD4; Unclear restrictions on use of function-type template arguments; Unknown. 2107; CD4; Lifetime of temporaries for default arguments in array copying; Unknown. 2108; drafting; Conversions to non-class prvalues in reference initialization; Not resolved. 2109; CD4; Value dependence underspecified; Unknown. 2110; drafting; Overload resolution for base class conversion and reference/non-reference; Not resolved. 2111; NAD; Array temporaries in reference binding; Unknown. 2112; CD5; new auto{x}; Unknown. 2113; CD4; Incompete specification of types for declarators; Unknown. 2114; CD3; Missing description of incompatibility from aggregate NSDMIs; Unknown. 2115; drafting; Order of implicit destruction vs release of automatic storage; Not resolved. 2116; C++17; Direct or copy initialization for omitted aggregate initializers; Unknown. 2117; drafting; Explicit specializations and constexpr function templates; Not resolved. 2118; open; Stateful metaprogramming via friend injection; Not resolved. 2119; NAD; Disambiguation of multi-level covariant return type; Unknown. 2120; CD4; Array as first non-static data member in standard-layout class; Clang 7. 2121; CD6; More flexible lambda syntax; Unknown. 2122; CD4; Glvalues of void type; Unknown. 2123; open; Omitted constant initialization of local static variables; Not resolved. 2124; CD4; Signature of constructor template; Unknown. 2125; NAD; Copy elision and comma operator; Unknown. 2126; C++20; Lifetime-extended temporaries in constant expressions; Clang 12. 2127; drafting; Partial specialization and nullptr; Not resolved. 2128; drafting; Imprecise rule for reference member initializer; Not resolved. 2129; CD4; Non-object prvalues and constant expressions; Unknown. 2130; CD4; Over-aligned types in new-expressions; Unknown. 2131; drafting; Ambiguity with opaque-enum-declaration; Not resolved. 2132; NAD; Deprecated default generated copy constructors; Unknown. 2133; CD5; Converting std::nullptr_,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:144268,inject,injection,144268,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['inject'],['injection']
Integrability,"eterSettings` to define the properties of the fit parameters (initial; 	values, bounds, etc..), `ROOT::Fit::FitResult` for storing the result of the fit.; * Data classes containing the data sets used in the fitting. These classes are the`ROOT::Fit::BinData`for describing bin data sets,; 	 thus data points containing both coordinates and a corresponding value/weight; 	 with optionally an error on the value or the coordinate and the `ROOT::Fit::UnBinData` for un-binned data sets,; 	 which consists only of a vector of coordinate values. The coordinate values can be; 	 one-dimensional (i.e. one entry per event) or multi-dimensional (N entries per event).; * Function classes defining the type of fit (the objective function used for fitting):; 	- `ROOT::Fit::Chi2FCN` for chi2 (least-square fits),; 	- `ROOT::Fit::PoissonLikelihoodFCN` for binned likelihood fits of histograms,; 	- `ROOT::Fit::LogLikelihoodFCN` for generic un-binned likelihood fits.; 	These classes are templated on the type of function interface they implement (see later). User convenient typedefs are also provided.; 	They derive from the common generic interface multi-dimensional for function evaluation, `ROOT::Math::IBaseFunctionMultiDim`. In addition the fitter classes make uses of the generic interfaces for parametric function evaluations, `ROOT::Math::IParametricFunctionMultiDim`; to define the fit model function and use the `ROOT::Math::Minimizer` interface to perform the minimization of the objective function.; More information about the function interface and the multi-dimensional minimization in ROOT is given in the Mathematical Library chapter. Here we present a detailed description of the `ROOT::Fit` classes and how to use them.; Using these classes instead of the interface provided directly in the ROOT data objects, like `TH1::Fit` allow are more fine control; to configure and customise the fits. For example, using these classes a combined fit of several histograms can be performed. To understand",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:27695,interface,interface,27695,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['interface'],['interface']
Integrability,"eterized ranges but are not involved in the; parameterization of others (e.g. x and y in the example above). Running integrals and Cumulative distribution functions. It is now possible to create running integrals from any RooAbsReal function and; to create cumulative distribution functions from any RooAbsPdf using the following; methods:. // Create int[xlo,x] f(x') dx' from f(x); RooAbsReal* runInt = func.createRunningIntegral(x) ;. // Create int[xlo,x] f(x') dx' from p.d.f f(x) normalized over x; RooAbsReal* cdf = pdf.createCdf(x) ;. // Create int[xlo,x] f(x',y) dx' from p.d.f f(x,y) normalized over (x,y); RooAbsReal* cdf = pdf.createCdf(x,y) ;. ; As with the similarly styled function createIntegral running integrals and c.d.f. can be created; over any number of observables, e.g createCdf(RooArgSet(x,y,z)) will create a three-dimensional; cumulative distribution function. C.d.f and running integrals that are calculated from p.d.fs that have; support for analytical integration are constructed from an appropriately reconnected RooRealIntegral.; If numeric integration is required, the c.d.f or running integral is calculated by a dedicated class; RooRunningIntegral that precalculates results for all observable values, which is more efficient; in most use cases. Cumulative distributions functions that are calculated numerically are handled slightly differently; that standard running integrals: their values is constructed to converge to exactly zero at the lower bound; and exactly 1 at the upper bound so that algorithms that make use of that property of c.d.f can do so reliably. Constraints management. New tools have been added to simplify studies with fits involving (external) constraints on parameters.; The general philosophy is that constraints on parameters can be represented as probability density functions; and can thus be modeled by RooAbsPdf classes (e.g. a RooGaussian for a simple Gaussian constraint on a parameter).; There are two modes of operation: you can add",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html:5958,integrat,integration,5958,roofit/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html,2,['integrat'],['integration']
Integrability,"ethod 2. Another method allows to create the evolution of a given radioactive; material/mixture at a given moment in time:. ~~~{.cpp}; TGeoMaterial::DecayMaterial(Double_t time, Double_t precision=0.001); ~~~. The method will create the mixture that result from the decay of a; initial material/mixture at time, while all resulting elements having a; fractional weight less than precision are excluded. A demo macro for radioactive material features is; `$ROOTSYS/tutorials/geom/RadioNuclides.C` It demonstrates also the decay; of a mixture made of radionuclides. \image html geometry004.png width=600px. \anchor GM00c; ### Tracking Media. The class TGeoMedium describes tracking media properties. This has; a pointer to a material and the additional data members representing the; properties related to tracking. ~~~{.cpp}; TGeoMedium(const char *name,Int_t numed,TGeoMaterial *mat,; Double_t *params=0);; ~~~. - `name:` name assigned to the medium; - `mat:` pointer to a material; - `params:` array of additional parameters. Another constructor allows effectively defining tracking parameters in; GEANT3 style:. ~~~{.cpp}; TGeoMedium(const char *name,Int_t numed,Int_t imat,Int_t ifield,; Double_t fieldm,Double_t tmaxfd,Double_t stemax,; Double_t deemax,Double_t epsil,Double_t stmin);; ~~~. This constructor is reserved for creating tracking media from the VMC; interface [...]:. - `numed:` user-defined medium index; - `imat:` unique ID of the material; - `others:` see G3 documentation. Looking at our simple world example, one can see that for creating; volumes one needs to create tracking media before. The way to proceed; for those not interested in performing tracking with external MC's is to; define and use only one `dummy tracking medium` as in the example (or a; `NULL` pointer). \anchor GM00d; ### User Interface for Handling Materials and Media. The TGeoManager class contains the API for accessing and handling; defined materials:. ~~~{.cpp}; TGeoManager::GetMaterial(name);; ~~~. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/materials.md:9897,interface,interface,9897,geom/geom/doc/materials.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/materials.md,1,['interface'],['interface']
Integrability,"ethods follow such a convention very reliably, at least for; system libraries on macOS, and functions always pass objects at +0. The; C-based APIs for Core Foundation objects, on the other hand, have much more; varied transfer semantics. The use of ``__attribute__((NSObject))`` typedefs is not recommended. If it's; absolutely necessary to use this attribute, be very explicit about using the; typedef, and do not assume that it will be preserved by language features like; ``__typeof`` and C++ template argument substitution. .. admonition:: Rationale. Any compiler operation which incidentally strips type ""sugar"" from a type; will yield a type without the attribute, which may result in unexpected; behavior. .. _arc.objects.retains:. Retain count semantics; ----------------------. A retainable object pointer is either a :arc-term:`null pointer` or a pointer; to a valid object. Furthermore, if it has block pointer type and is not; ``null`` then it must actually be a pointer to a block object, and if it has; ``Class`` type (possibly protocol-qualified) then it must actually be a pointer; to a class object. Otherwise ARC does not enforce the Objective-C type system; as long as the implementing methods follow the signature of the static type.; It is undefined behavior if ARC is exposed to an invalid pointer. For ARC's purposes, a valid object is one with ""well-behaved"" retaining; operations. Specifically, the object must be laid out such that the; Objective-C message send machinery can successfully send it the following; messages:. * ``retain``, taking no arguments and returning a pointer to the object.; * ``release``, taking no arguments and returning ``void``.; * ``autorelease``, taking no arguments and returning a pointer to the object. The behavior of these methods is constrained in the following ways. The term; :arc-term:`high-level semantics` is an intentionally vague term; the intent is; that programmers must implement these methods in a way such that the compiler,; m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:12664,protocol,protocol-qualified,12664,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['protocol'],['protocol-qualified']
Integrability,"etry need to be saved as a `C` macro or a; `.root` file.; - *Shapes.* The category provides buttons for creation of all; supported shapes. The new shape name is chosen by the interface, but; can be changed from the shape editor GUI. Existing shapes can be; browsed and edited from the same category.; - *Volumes.* The category allows the creation of a new volume having a; given name, shape and medium. For creating a volume assembly only; the name is relevant. Existing volumes can be browsed or edited from; this category.; - *Materials.* Allows creation of new materials/mixtures or editing; existing ones.; - *Media.* The same for creation/editing of tracking media (materials; having a set of properties related to tracking); - *Matrices.* Allows creation of translations, rotations or combined; transformations. Existing matrices can also be browser/edited. \anchor GP08c; ### Editing Existing Objects. For editing an existing object from one of the categories described; above, the interface imposes first a selection among all objects of the; corresponding type stored in the geometry. This can be done by clicking; the button next to the blue label *Select \<object\>*. The dialog; interfaces are generally different for different types of objects. The; volume selection dialog offers the possibility to select either a volume; already connected to the geometry hierarchy or non-connected ones.; Selection for shapes and matrices is split into categories represented; by top-level list tree items for: boxes, tubes, translations, rotations,; etc. \image html geometry020.png ""Selection dialogs for different TGeo objects"". Once a selection is made and the dialog is closed, the selected item; name will appear in the corresponding label and the button Edit will; start the object editor in a transient frame. Closing these transient; frames will not delete, but just hide existing opened editors for later; reuse. Their lifetime is determined by the canvas to which the manager; editor is att",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:129265,interface,interface,129265,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['interface'],['interface']
Integrability,"etting next clang stage to: ${NEXT_CLANG_STAGE}""). set(STAMP_DIR ${CMAKE_CURRENT_BINARY_DIR}/${NEXT_CLANG_STAGE}-stamps/); set(BINARY_DIR ${CMAKE_CURRENT_BINARY_DIR}/${NEXT_CLANG_STAGE}-bins/). if(BOOTSTRAP_LLVM_ENABLE_LLD); # adding lld to clang-bootstrap-deps without having it enabled in; # LLVM_ENABLE_PROJECTS just generates a cryptic error message.; if (NOT ""lld"" IN_LIST LLVM_ENABLE_PROJECTS); message(FATAL_ERROR ""LLD is enabled in the bootstrap build, but lld is not in LLVM_ENABLE_PROJECTS""); endif(); add_dependencies(clang-bootstrap-deps lld); endif(). if (WIN32); # Build llvm-rc and llvm-mt which are needed by the Windows build.; add_dependencies(clang-bootstrap-deps llvm-rc); if(LLVM_ENABLE_LIBXML2); add_dependencies(clang-bootstrap-deps llvm-mt); endif(); endif(). # If the next stage is LTO we need to depend on LTO and possibly lld or LLVMgold; if(BOOTSTRAP_LLVM_ENABLE_LTO OR LLVM_ENABLE_LTO AND NOT LLVM_BUILD_INSTRUMENTED); if(APPLE); add_dependencies(clang-bootstrap-deps LTO); # on Darwin we need to set DARWIN_LTO_LIBRARY so that -flto will work; # using the just-built compiler, and we need to override DYLD_LIBRARY_PATH; # so that the host object file tools will use the just-built libLTO.; # However if System Integrity Protection is enabled the DYLD variables; # will be scrubbed from the environment of any base system commands. This; # includes /bin/sh, which ninja uses when executing build commands. To; # work around the envar being filtered away we pass it in as a CMake; # variable, and have LLVM's CMake append the envar to the archiver calls.; set(LTO_LIBRARY -DDARWIN_LTO_LIBRARY=${LLVM_SHLIB_OUTPUT_INTDIR}/libLTO.dylib; -DDYLD_LIBRARY_PATH=${LLVM_LIBRARY_OUTPUT_INTDIR}); elseif(MSVC); add_dependencies(clang-bootstrap-deps llvm-lib); set(${CLANG_STAGE}_AR -DCMAKE_AR=${LLVM_RUNTIME_OUTPUT_INTDIR}/llvm-lib); elseif(NOT WIN32); add_dependencies(clang-bootstrap-deps llvm-ar llvm-ranlib); if(NOT BOOTSTRAP_LLVM_ENABLE_LLD AND LLVM_BINUTILS_INCDIR); add_depend",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:21475,depend,depend,21475,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,1,['depend'],['depend']
Integrability,"eturn error;; }; }; if (FoundDeclsList is empty) {; Import dependent declarations and types of ToDecl;; ToDecl = create a new AST node in ""to"" Ctx;; Mark FromD as imported;; }; return ToDecl;; }. Two AST nodes are *structurally equivalent* if they are. - builtin types and refer to the same type, e.g. ``int`` and ``int`` are structurally equivalent,; - function types and all their parameters have structurally equivalent types,; - record types and all their fields in order of their definition have the same identifier names and structurally equivalent types,; - variable or function declarations and they have the same identifier name and their types are structurally equivalent. We could extend the definition of structural equivalency to templates similarly. If A and B are AST nodes and *A depends on B*, then we say that A is a **dependant** of B and B is a **dependency** of A.; The words ""dependant"" and ""dependency"" are nouns in British English.; Unfortunately, in American English, the adjective ""dependent"" is used for both meanings.; In this document, with the ""dependent"" adjective we always address the dependencies, the B node in the example. API; ---. Let's create a tool which uses the ASTImporter class!; First, we build two ASTs from virtual files; the content of the virtual files are synthesized from string literals:. .. code-block:: cpp. std::unique_ptr<ASTUnit> ToUnit = buildASTFromCode(; """", ""to.cc""); // empty file; std::unique_ptr<ASTUnit> FromUnit = buildASTFromCode(; R""(; class MyClass {; int m1;; int m2;; };; )"",; ""from.cc"");. The first AST corresponds to the destination (""to"") context - which is empty - and the second for the source (""from"") context.; Next, we define a matcher to match ``MyClass`` in the ""from"" context:. .. code-block:: cpp. auto Matcher = cxxRecordDecl(hasName(""MyClass""));; auto *From = getFirstDecl<CXXRecordDecl>(Matcher, FromUnit);. Now we create the Importer and do the import:. .. code-block:: cpp. ASTImporter Importer(ToUnit->getASTCon",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:4454,depend,dependent,4454,interpreter/llvm-project/clang/docs/LibASTImporter.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst,1,['depend'],['dependent']
Integrability,"eturn types: they always return null. With these basic helper functions, we can implement the first piece of; our grammar: numeric literals. Basic Expression Parsing; ========================. We start with numeric literals, because they are the simplest to; process. For each production in our grammar, we'll define a function; which parses that production. For numeric literals, we have:. .. code-block:: c++. /// numberexpr ::= number; static std::unique_ptr<ExprAST> ParseNumberExpr() {; auto Result = std::make_unique<NumberExprAST>(NumVal);; getNextToken(); // consume the number; return std::move(Result);; }. This routine is very simple: it expects to be called when the current; token is a ``tok_number`` token. It takes the current number value,; creates a ``NumberExprAST`` node, advances the lexer to the next token,; and finally returns. There are some interesting aspects to this. The most important one is; that this routine eats all of the tokens that correspond to the; production and returns the lexer buffer with the next token (which is; not part of the grammar production) ready to go. This is a fairly; standard way to go for recursive descent parsers. For a better example,; the parenthesis operator is defined like this:. .. code-block:: c++. /// parenexpr ::= '(' expression ')'; static std::unique_ptr<ExprAST> ParseParenExpr() {; getNextToken(); // eat (.; auto V = ParseExpression();; if (!V); return nullptr;. if (CurTok != ')'); return LogError(""expected ')'"");; getNextToken(); // eat ).; return V;; }. This function illustrates a number of interesting things about the; parser:. 1) It shows how we use the LogError routines. When called, this function; expects that the current token is a '(' token, but after parsing the; subexpression, it is possible that there is no ')' waiting. For example,; if the user types in ""(4 x"" instead of ""(4)"", the parser should emit an; error. Because errors can occur, the parser needs a way to indicate that; they happened: in our pa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:7857,rout,routine,7857,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['rout'],['routine']
Integrability,"ety`` implicitly adds the redundant bounds; checks that the optimizer can remove:. .. code-block:: c. void fill_array_with_indices(int *__counted_by(count) p, size_t count) {; for (size_t i = 0; i < count; ++i) {; // implicit bounds checks:; // if (p + i < p || p + i + 1 > p + count) trap();; p[i] = i;; }; }. ``ConstraintElimination`` collects the following facts and determines if the; bounds checks can be safely removed:. * Inside the for-loop, ``0 <= i < count``, hence ``1 <= i + 1 <= count``.; * Pointer arithmetic ``p + count`` in the if-condition doesn’t wrap.; * ``-fbounds-safety`` treats pointer arithmetic overflow as deterministically; two’s complement computation, not an undefined behavior. Therefore,; getelementptr does not typically have inbounds keyword. However, the compiler; does emit inbounds for ``p + count`` in this case because; ``__counted_by(count)`` has the invariant that p has at least as many as; elements as count. Using this information, ``ConstraintElimination`` is able; to determine ``p + count`` doesn’t wrap.; * Accordingly, ``p + i`` and ``p + i + 1`` also don’t wrap.; * Therefore, ``p <= p + i`` and ``p + i + 1 <= p + count``.; * The if-condition simplifies to false and becomes dead code that the subsequent; optimization passes can remove. ``OptRemarks`` can be utilized to provide insights into performance tuning. It; has the capability to report on checks that it cannot eliminate, possibly with; reasons, allowing programmers to adjust their code to unlock further; optimizations. Debugging; =========. Internal bounds annotations; ---------------------------. Internal bounds annotations change a pointer into a wide pointer. The debugger; needs to understand that wide pointers are essentially pointers with a struct; layout. To handle this, a wide pointer is described as a record type in the; debug info. The type name has a special name prefix (e.g.,; ``__bounds_safety$bidi_indexable``) which can be recognized by a debug info; consumer to pr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:7712,wrap,wrap,7712,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,1,['wrap'],['wrap']
Integrability,"eve the geometry in a ready state, ignoring what the state; variables that can be always re-initialized. When the code is generated; for a given **`TGeoVolume`** in the geometry, just the branch starting; with that volume will be saved in the file. Executing the generated code; will create a geometry that has `MyVolume` as top volume. In this case,; only the materials/media/matrices used effectively in the `MyVolume`; branch are exported to file. Volumes can be made persistent in the same way the full geometry is.; Exporting is straightforward (module1, 2 are pointers to; **`TGeoVolume`** objects):. ``` {.cpp}; module1->Export(""file.root"");; // by default file is overwritten; module2->Export(""file.root"","""",""update"");; // to the same file; ```. Importing will append the volume to the current TGeoManager or will; create one:. ``` {.cpp}; TGeoManager *geom = new TGeoManager(""myGeom"", """");; TGeoVolume *top = geom->MakeBox(...);; geom->SetTopVolume(top);; //name of volume or key (depending on export usage); TGeoVolume *module1 = TGeoVolume::Import(""file.root"", ""MOD1"");; TGeoVolume *module2 = TGeoVolume::Import(""file.root"", ""MOD2"");; top->AddNode(module1, 1, new TGeoTranslation(0,0,100));; top->AddNode(module2, 1, new TGeoTranslation(0,0,-100));; // One should close oneself the geometry; geom->CloseGeometry();; ```. ### GDML. Few lines above word GDML was used. GDML stands for **G**eometry; **D**escription **M**arkup **L**anguage. It is an application-independent; geometry description format based on XML. It is mainly used for geometry; interchange between ROOT and Geant4 framework. More details about this; project can be found http://gdml.web.cern.ch. This feature; (importing/exporting from/to gdml file format) is disabled by default in; ROOT installation. To enable this feature add `--enable-gdml` option to; `./configure` script call. ## Navigation Algorithms. This section will describe the main methods and algorithms used for; implementing the navigation features withi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:153643,depend,depending,153643,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['depend'],['depending']
Integrability,"event error dterr and all its parameters, convoluted with a triple; gaussian resolution model and multiplied with a Gaussian p.d.f. in the; energy substituted mass. (In plain RooFit this would have required at; least 23 lines of code). A series of three new tutorial macros has been added to illustrate the; various features of the object factory. rf511_wsfactory_basic.C - Basic factory concepts; rf512_wsfactory_oper.C - Using operator p.d.f.s in the factory; rf513_wsfactory_tools.C - Advanced example using interfaced high level tools. A formal transaction model is used to commit composite objects into; the workspace. If an error is detected in the expression, no objects; will be committed to the workspace, thus leaving no 'partial builds'. Compact demo of several new major features. The macro below demonstrates in a couple of lines a number of major new features in RooFit 3.00: Use of. workspace factory to quickly create and store (compiled) models; workspace CINT interface to easily access contents in a typesafe way; new adaptive ND numeric integration technique to normalize arbitrary p.d.f. in fast; and reliable way; new adaptive TFoam sampling technique to efficiently generate toy MC data from strongly; peaked datasets; parallel processing in likelihood construction and use of profile likelihood operator; to represent profile likelihoods as regular RooFit functions. void demo(); {; // Construct compiled 2-D model that requires numeric integration for normalization; RooWorkspace w(""w"",1) ;; w.factory(""CEXPR::model('1/((x-a)*(x-a)+0.001)+1/((y-b)*(y-b)+0.001)',x[-1,1],y[-1,1],a[-5,5],b[-5,5])"") ;. // Generate data from model (using TFoam adaptive sampling algorithm); RooDataSet* d = w::model.generate(RooArgSet(w::x,w::y),1000) ;; w::model.fitTo(*d) ;. // Make 2D plot on (x,y); TH2* hh = w::model.createHistogram(""x,y"",40,40) ;; hh->SetLineColor(kBlue) ;. // Make Projection on x (integrate over y); RooPlot* framex = w::x.frame(Title(""Data and p.d.f. projected on X"")) ;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:22011,interface,interface,22011,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,4,"['integrat', 'interface']","['integration', 'interface']"
Integrability,"ever need to be converted; to a ``std::error_code`` you can use the ``inconvertibleErrorCode()`` function:. .. code-block:: c++. createStringError(inconvertibleErrorCode(), ""Bad executable"");. This should be done only after careful consideration. If any attempt is made to; convert this error to a ``std::error_code`` it will trigger immediate program; termination. Unless you are certain that your errors will not need; interoperability you should look for an existing ``std::error_code`` that you; can convert to, and even (as painful as it is) consider introducing a new one as; a stopgap measure. ``createStringError`` can take ``printf`` style format specifiers to provide a; formatted message:. .. code-block:: c++. createStringError(errc::executable_format_error,; ""Bad executable: %s"", FileName);. Interoperability with std::error_code and ErrorOr; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Many existing LLVM APIs use ``std::error_code`` and its partner ``ErrorOr<T>``; (which plays the same role as ``Expected<T>``, but wraps a ``std::error_code``; rather than an ``Error``). The infectious nature of error types means that an; attempt to change one of these functions to return ``Error`` or ``Expected<T>``; instead often results in an avalanche of changes to callers, callers of callers,; and so on. (The first such attempt, returning an ``Error`` from; MachOObjectFile's constructor, was abandoned after the diff reached 3000 lines,; impacted half a dozen libraries, and was still growing). To solve this problem, the ``Error``/``std::error_code`` interoperability requirement was; introduced. Two pairs of functions allow any ``Error`` value to be converted to a; ``std::error_code``, any ``Expected<T>`` to be converted to an ``ErrorOr<T>``, and vice; versa:. .. code-block:: c++. std::error_code errorToErrorCode(Error Err);; Error errorCodeToError(std::error_code EC);. template <typename T> ErrorOr<T> expectedToErrorOr(Expected<T> TOrErr);; template <typename T> Expected<T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:28428,wrap,wraps,28428,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['wrap'],['wraps']
Integrability,"ever, under certain circumstances, ARC is permitted to re-order and; eliminate operations in a manner which may alter the overall; computation history beyond what is permitted by the general ""as if""; rule of C/C++ and the :ref:`restrictions <arc.objects.retains>` on; the implementation of ``retain`` and ``release``. .. admonition:: Rationale. Specifically, ARC is sometimes permitted to optimize ``release``; operations in ways which might cause an object to be deallocated; before it would otherwise be. Without this, it would be almost; impossible to eliminate any ``retain``/``release`` pairs. For; example, consider the following code:. .. code-block:: objc. id x = _ivar;; [x foo];. If we were not permitted in any event to shorten the lifetime of the; object in ``x``, then we would not be able to eliminate this retain; and release unless we could prove that the message send could not; modify ``_ivar`` (or deallocate ``self``). Since message sends are; opaque to the optimizer, this is not possible, and so ARC's hands; would be almost completely tied. ARC makes no guarantees about the execution of a computation history; which contains undefined behavior. In particular, ARC makes no; guarantees in the presence of race conditions. ARC may assume that any retainable object pointers it receives or; generates are instantaneously valid from that point until a point; which, by the concurrency model of the host language, happens-after; the generation of the pointer and happens-before a release of that; object (possibly via an aliasing pointer or indirectly due to; destruction of a different object). .. admonition:: Rationale. There is very little point in trying to guarantee correctness in the; presence of race conditions. ARC does not have a stack-scanning; garbage collector, and guaranteeing the atomicity of every load and; store operation would be prohibitive and preclude a vast amount of; optimization. ARC may assume that non-ARC code engages in sensible balancing; behavior ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:77198,message,message,77198,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['message'],['message']
Integrability,"evision"" as a whole used for the; commit message). If you suggest changes in a code review, but don't wish the suggestion to be; interpreted this strongly, please state so explicitly. Aim to Make Efficient Use of Everyone's Time; --------------------------------------------. Aim to limit the number of iterations in the review process. For example, when; suggesting a change, if you want the author to make a similar set of changes at; other places in the code, please explain the requested set of changes so that; the author can make all of the changes at once. If a patch will require; multiple steps prior to approval (e.g., splitting, refactoring, posting data; from specific performance tests), please explain as many of these up front as; possible. This allows the patch author and reviewers to make the most efficient; use of their time. LGTM - How a Patch Is Accepted; ------------------------------. A patch is approved to be committed when a reviewer accepts it, and this is; almost always associated with a message containing the text ""LGTM"" (which; stands for Looks Good To Me). Only approval from a single reviewer is required. When providing an unqualified LGTM (approval to commit), it is the; responsibility of the reviewer to have reviewed all of the discussion and; feedback from all reviewers ensuring that all feedback has been addressed and; that all other reviewers will almost surely be satisfied with the patch being; approved. If unsure, the reviewer should provide a qualified approval, (e.g.,; ""LGTM, but please wait for @someone, @someone_else""). You may also do this if; you are fairly certain that a particular community member will wish to review,; even if that person hasn't done so yet. Note that, if a reviewer has requested a particular community member to review,; and after a week that community member has yet to respond, feel free to ping; the patch (which literally means submitting a comment on the patch with the; word, ""Ping.""), or alternatively, ask the o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst:6575,message,message,6575,interpreter/llvm-project/llvm/docs/CodeReview.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst,1,['message'],['message']
Integrability,"ework may be compared to living in the; country. In order to have transportation and water, you will have to; build a road and dig a well. To have services like telephone and; electricity you will need to route the wires to your home. In; addition, you cannot build some things yourself. For example, you; cannot build a commercial airport on your patch of land. From a global; perspective, it would make no sense for everyone to build their; own airport. You see you will be very busy building the infrastructure; (or framework) before you can use the phone to communicate with your; collaborators and have a drink of water at the same time. In software; engineering, it is much the same way. In a framework, the basic; utilities and services, such as I/O and graphics, are provided. In; addition, ROOT being a HEP analysis framework, it provides a large; selection of HEP specific utilities such as histograms and fitting.; The drawback of a framework is that you are constrained to it, as you; are constraint to use the routing algorithm provided by your telephone; service. You also have to learn the framework interfaces, which in; this analogy is the same as learning how to use a telephone. If you are interested in doing physics, a good HEP framework will save; you much work. Next is a list of the more commonly used components of; ROOT: Command Line Interpreter, Histograms and Fitting, Writing a; Graphical User Interface, 2D Graphics, Input/Output , Collection; Classes, Script Processor. There are also less commonly used components, as: 3D Graphics,; Parallel Processing (PROOF), Run Time Type Identification (RTTI),; Socket and Network Communication, Threads. #### Advantages of Frameworks. The benefits of frameworks can be summarized as follows:. - Less code to write - the programmer should be able to use and; reuse the majority of the existing code. Basic functionality, such; as fitting and histogramming are implemented and ready to use and; customize. - More reliable and robust",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:6436,rout,routing,6436,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['rout'],['routing']
Integrability,"example of classes with template arguments. First, we; define a class similar to the ``FPFormat`` class above. It takes a template; argument and uses it to initialize a field named ``Value``. Then we define; four records that inherit the ``Value`` field with its four different; integer values. .. code-block:: text. class ModRefVal <bits<2> val> {; bits<2> Value = val;; }. def None : ModRefVal<0>;; def Mod : ModRefVal<1>;; def Ref : ModRefVal<2>;; def ModRef : ModRefVal<3>;. This is somewhat contrived, but let's say we would like to examine the two; bits of the ``Value`` field independently. We can define a class that; accepts a ``ModRefVal`` record as a template argument and splits up its; value into two fields, one bit each. Then we can define records that inherit from; ``ModRefBits`` and so acquire two fields from it, one for each bit in the; ``ModRefVal`` record passed as the template argument. .. code-block:: text. class ModRefBits <ModRefVal mrv> {; // Break the value up into its bits, which can provide a nice; // interface to the ModRefVal values.; bit isMod = mrv.Value{0};; bit isRef = mrv.Value{1};; }. // Example uses.; def foo : ModRefBits<Mod>;; def bar : ModRefBits<Ref>;; def snork : ModRefBits<ModRef>;. This illustrates how one class can be defined to reorganize the; fields in another class, thus hiding the internal representation of that; other class. Running ``llvm-tblgen`` on the example prints the following definitions:. .. code-block:: text. def bar { // Value; bit isMod = 0;; bit isRef = 1;; }; def foo { // Value; bit isMod = 1;; bit isRef = 0;; }; def snork { // Value; bit isMod = 1;; bit isRef = 1;; }. ``let`` --- override fields in classes or records; -------------------------------------------------. A ``let`` statement collects a set of field values (sometimes called; *bindings*) and applies them to all the classes and records defined by; statements within the scope of the ``let``. .. productionlist::; Let: ""let"" `LetList` ""in"" ""{"" `Statement`*",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:32060,interface,interface,32060,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['interface'],['interface']
Integrability,"exp(-(x^2)-(y^2))"",-3,3,-3,3);; // two contours less than the number of colors in palette; f2->SetContour(colNum-2);; f2->Draw(""cont"");; }; ```. Since ROOT 6.26, you can also define a palette based on an ASCII text; file, using `TColor::CreateColorTableFromFile(""filename.txt"")` or; `gStyle->SetPalette(""filename.txt"")`. The input file contains one color; per line in ""r g b"" float format. This function is useful to profit from; a full set of colour-vision deficiency friendly and perceptually uniform; colour maps that are available to; [download](https://doi.org/10.5281/zenodo.4491293). ## The Graphics Editor. A new graphics editor took place in ROOT v4.0. The editor can be; activated by selecting the Editor menu entry in the canvas View menu or; one of the context menu entries for setting line, fill, marker or text; attributes. The following object editors are available for the current; ROOT version. ### TAxisEditor. ![](pictures/030000D5.png). This user interface gives the possibility for changing the following; axis attributes:. - color of the selected axis, the axis' title and labels;. - the length of thick parameters and the possibility to set them on; both axis sides (if `+-` is selected);. - to set logarithmic or linear scale along the selected axis with a; choice for optimized or more logarithmic labels;. - primary, secondary and tertiary axis divisions can be set via the; three number fields;. - the axis title can be added or edited and the title's color,; position, offset, size and font can be set interactively;. - the color, size, and offset of axis labels can be set similarly. In; addition, there is a check box for no exponent choice, and another; one for setting the same decimal part for all labels. ### TPadEditor. ![](pictures/030000D6.png). - It provides the following user interface:. - Fixed aspect ratio - can be set for pad resizing. - Edit - sets pad or canvas as editable. - Cross-hair - sets a cross hair on the pad. - TickX - set ticks along the X ax",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:84411,interface,interface,84411,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['interface'],['interface']
Integrability,"expect`` intrinsics, i.e., through use of; ``__builtin_expect(...)``, they are trying to communicate how their code is; expected to behave at runtime to the optimizer. These annotations, however, can; be incorrect for a variety of reasons: changes to the code base invalidate them; silently, the developer mis-annotated them (e.g., using ``LIKELY`` instead of; ``UNLIKELY``), or perhaps they assumed something incorrectly when they wrote; the annotation. Regardless of why, it is useful to detect these situations so; that the optimizer can make more useful decisions about the code. MisExpect; diagnostics are intended to help developers identify and address these; situations, by comparing the use of the ``llvm.expect`` intrinsic to the ground; truth provided by a profiling input. The MisExpect checks in the LLVM backend follow a simple procedure: if there is; a mismatch between the branch weights collected during profiling and those; supplied by an ``llvm.expect`` intrinsic, then it will emit a diagnostic; message to the user. The most natural place to perform the verification is just prior to when; branch weights are assigned to the target instruction in the form of; branch weight metadata. There are 3 key places in the LLVM backend where branch weights are; created and assigned based on profiling information or the use of the; ``llvm.expect`` intrinsic, and our implementation focuses on these; places to perform the verification. We calculate the threshold for emitting MisExpect related diagnostics; based on the values the compiler assigns to ``llvm.expect`` intrinsics,; which can be set through the ``-likely-branch-weight`` and; ``-unlikely-branch-weight`` LLVM options. During verification, if the; profile weights mismatch the calculated threshold, then we will emit a; remark or warning detailing a potential performance regression. The; diagnostic also reports the percentage of the time the annotation was; correct during profiling to help developers reason about how to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MisExpect.rst:1139,message,message,1139,interpreter/llvm-project/llvm/docs/MisExpect.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MisExpect.rst,1,['message'],['message']
Integrability,explicit specialization; Not resolved. 1994; dup; Confusing wording regarding multiple template<> prefixes; Duplicate of 529. 1995; CD4; exception-specifications and non-type template parameters; Unknown. 1996; drafting; Reference list-initialization ignores conversion functions; Not resolved. 1997; drafting; Placement new and previous initialization; Not resolved. 1998; NAD; Additional sources of xvalue expressions; Unknown. 1999; CD4; Representation of source characters as universal-character-names; Unknown. 2000; CD4; header-name outside #include directive; Unknown. 2001; CD4; non-directive is underspecified; Unknown. 2002; open; White space within preprocessing directives; Not resolved. 2003; drafting; Zero-argument macros incorrectly specified; Not resolved. 2004; CD4; Unions with mutable members in constant expressions; Unknown. 2005; NAD; Incorrect constexpr reference initialization requirements; Unknown. 2006; CD4; Cv-qualified void types; Unknown. 2007; CD6; Argument-dependent lookup for operator=; Clang 3.4. 2008; CD4; Default template-arguments underspecified; Unknown. 2009; CD6; Unclear specification of class scope; N/A. 2010; CD4; exception-specifications and conversion operators; Unknown. 2011; C++17; Unclear effect of reference capture of reference; Unknown. 2012; CD4; Lifetime of references; Unknown. 2013; drafting; Pointer subtraction in large array; Not resolved. 2014; NAD; Unneeded deallocation signatures; Unknown. 2015; CD4; odr-use of deleted virtual functions; Unknown. 2016; CD4; Confusing wording in description of conversion function; Unknown. 2017; CD4; Flowing off end is not equivalent to no-expression return; Unknown. 2018; dup; Qualification conversion vs reference binding; Unknown. 2019; CD4; Member references omitted from description of storage duration; Unknown. 2020; CD5; Inadequate description of odr-use of implicitly-invoked functions; Unknown. 2021; dup; Function template redeclaration via alias template; Unknown. 2022; CD4; Copy eli,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:136448,depend,dependent,136448,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['depend'],['dependent']
Integrability,"explicitly written in; code (as opposed to implicitly added by the compiler). Given; struct Foo {; Foo() { }; Foo(int) : foo_(""A"") { }; string foo_;; };; cxxConstructorDecl(hasAnyConstructorInitializer(isWritten())); will match Foo(int), but not Foo(). Matcher<CXXDeductionGuideDecl>isExplicit; Matches constructor, conversion function, and deduction guide declarations; that have an explicit specifier if this explicit specifier is resolved to; true. Given; template<bool b>; struct S {; S(int); // #1; explicit S(double); // #2; operator int(); // #3; explicit operator bool(); // #4; explicit(false) S(bool) // # 7; explicit(true) S(char) // # 8; explicit(b) S(S) // # 9; };; S(int) -> S<true> // #5; explicit S(double) -> S<false> // #6; cxxConstructorDecl(isExplicit()) will match #2 and #8, but not #1, #7 or #9.; cxxConversionDecl(isExplicit()) will match #4, but not #3.; cxxDeductionGuideDecl(isExplicit()) will match #6, but not #5. Matcher<CXXDependentScopeMemberExpr>hasMemberNamestd::string N; Matches template-dependent, but known, member names. In template declarations, dependent members are not resolved and so can; not be matched to particular named declarations. This matcher allows to match on the known name of members. Given; template <typename T>; struct S {; void mem();; };; template <typename T>; void x() {; S<T> s;; s.mem();; }; cxxDependentScopeMemberExpr(hasMemberName(""mem"")) matches `s.mem()`. Matcher<CXXDependentScopeMemberExpr>isArrow; Matches member expressions that are called with '->' as opposed; to '.'. Member calls on the implicit this pointer match as called with '->'. Given; class Y {; void x() { this->x(); x(); Y y; y.x(); a; this->b; Y::b; }; template <class T> void f() { this->f<T>(); f<T>(); }; int a;; static int b;; };; template <class T>; class Z {; void x() { this->m; }; };; memberExpr(isArrow()); matches this->x, x, y.x, a, this->b; cxxDependentScopeMemberExpr(isArrow()); matches this->m; unresolvedMemberExpr(isArrow()); matches this->f<T>, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:64623,depend,dependent,64623,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['depend'],['dependent']
Integrability,"expression; <LangRef.html#diexpression>`_. An `llvm.dbg.value` intrinsic describes the *value* of a source variable; directly, not its address. Note that the value operand of this intrinsic may; be indirect (i.e, a pointer to the source variable), provided that interpreting; the complex expression derives the direct value. ``llvm.dbg.assign``; ^^^^^^^^^^^^^^^^^^^; .. toctree::; :hidden:. AssignmentTracking. .. code-block:: llvm. void @llvm.dbg.assign(Value *Value,; DIExpression *ValueExpression,; DILocalVariable *Variable,; DIAssignID *ID,; Value *Address,; DIExpression *AddressExpression). This intrinsic marks the position in IR where a source assignment occurred. It; encodes the value of the variable. It references the store, if any, that; performs the assignment, and the destination address. The first three arguments are the same as for an ``llvm.dbg.value``. The fourth; argument is a ``DIAssignID`` used to reference a store. The fifth is the; destination of the store (wrapped as metadata), and the sixth is a `complex; expression <LangRef.html#diexpression>`_ that modifies it. The formal LLVM-IR signature is:. .. code-block:: llvm. void @llvm.dbg.assign(metadata, metadata, metadata, metadata, metadata, metadata). See :doc:`AssignmentTracking` for more info. Object lifetimes and scoping; ============================. In many languages, the local variables in functions can have their lifetimes or; scopes limited to a subset of a function. In the C family of languages, for; example, variables are only live (readable and writable) within the source; block that they are defined in. In functional languages, values are only; readable after they have been defined. Though this is a very obvious concept,; it is non-trivial to model in LLVM, because it has no notion of scoping in this; sense, and does not want to be tied to a language's scoping rules. In order to handle this, the LLVM debug format uses the metadata attached to; llvm instructions to encode line number and sc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:11551,wrap,wrapped,11551,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['wrap'],['wrapped']
Integrability,expressions; Yes. 1815; CD4; Lifetime extension in aggregate initialization; No. 1816; CD4; Unclear specification of bit-field values; Unknown. 1817; drafting; Linkage specifications and nested scopes; Not resolved. 1818; CD6; Visibility and inherited language linkage; Unknown. 1819; CD4; Acceptable scopes for definition of partial specialization; Unknown. 1820; CD6; Qualified typedef names; Unknown. 1821; CD6; Qualified redeclarations in a class member-specification; Clang 2.9. 1822; CD6; Lookup of parameter names in lambda-expressions; Yes. 1823; CD4; String literal uniqueness in inline functions; Unknown. 1824; CD4; Completeness of return type vs point of instantiation; Unknown. 1825; C++17; Partial ordering between variadic and non-variadic function templates; Unknown. 1826; NAD; const floating-point in constant expressions; Unknown. 1827; drafting; Reference binding with ambiguous conversions; Not resolved. 1828; CD6; nested-name-specifier ambiguity; Unknown. 1829; CD6; Dependent unnamed types; Unknown. 1830; CD4; Repeated specifiers; Unknown. 1831; NAD; Explicitly vs implicitly deleted move constructors; Unknown. 1832; CD4; Casting to incomplete enumeration; Unknown. 1833; NAD; friend declarations naming implicitly-declared member functions; Unknown. 1834; CD4; Constant initialization binding a reference to an xvalue; Unknown. 1835; CD6; Dependent member lookup before <; Unknown. 1836; CD5; Use of class type being defined in trailing-return-type; Unknown. 1837; CD6; Use of this in friend and local class declarations; Clang 3.3. 1838; CD4; Definition via unqualified-id and using-declaration; Unknown. 1839; CD6; Lookup of block-scope extern declarations; Unknown. 1840; drafting; Non-deleted explicit specialization of deleted function template; Not resolved. 1841; CD6; < following template injected-class-name; Unknown. 1842; open; Unevaluated operands and “carries a dependency”; Not resolved. 1843; CD4; Bit-field in conditional operator with throw operand; Unknown,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:124200,Depend,Dependent,124200,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Depend'],['Dependent']
Integrability,"extSize` error: show code and values.; - Very long text string generated a wrong SVG file.; - Fix the option `SAME` works for `TGraph2D`.; - Implement the title for the palette of a `TH3`.; - Fix typo in `TLegend::PaintPrimitives()` and improve the exclusion graphs legend.; - `SetParameters(…)` or `SetParameter(…)` on a TF1 reset the properties of the axis that have been previously defined.; This was due to the `Update()` that was done after the parameters definition.; - Update fonts' documentation (CMS request).; - Delaunay triangles were computed by the package `triangle.c` included in the ROOT code.; This package had several problems:; - It was not maintained anymore.; - Its license was not compatible with LGPL.; It is now replaced by the CDT package which is properly maintained and has a license (MLP) compatible with LGPL. ## 3D Graphics Libraries. ### REve; * Introduce lightweight visualization of instanced shapes on the level of 100.000 instances. This is integrated in digit visualization of the type REveBoxSet. List of typed instances are boxes, hexagons, and cones. The digit sets support different types of transformation: positioning, rotation, and scaling in different combinations. With the digit set a palette GUI interface has also been added to enable setting digits threshold and value to color mapping. <figure>; <img src=""reve-boxset-cones.png"" >; <figcaption>REveBoxSet screenshot with cone shape type. The set is using value to color map with overflow and underflow mark. The single REveBoxet object has a secondary selection enabled, where one can set a custom tooltip on mouse hover of an individual instance.</figcaption>; </figure>. * Update version of RenderCore to fix tone mapping of transparent objects. ## PROOF Libraries. By default, PROOF is not configured and built any more. It will be deprecated in the future given that its functionality is now provided by the superior RDataFrame and its distributed version, [DistRDF](https://root.cern/doc/master/",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:18165,integrat,integrated,18165,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['integrat'],['integrated']
Integrability,"extra_sources`` will be; evaluated as empty before add_executable is given its arguments. Lists; -----. In CMake lists are semi-colon delimited strings, and it is strongly advised that; you avoid using semi-colons in lists; it doesn't go smoothly. A few examples of; defining lists:. .. code-block:: cmake. # Creates a list with members a, b, c, and d; set(my_list a b c d); set(my_list ""a;b;c;d""). # Creates a string ""a b c d""; set(my_string ""a b c d""). Lists of Lists; --------------. One of the more complicated patterns in CMake is lists of lists. Because a list; cannot contain an element with a semi-colon to construct a list of lists you; make a list of variable names that refer to other lists. For example:. .. code-block:: cmake. set(list_of_lists a b c); set(a 1 2 3); set(b 4 5 6); set(c 7 8 9). With this layout you can iterate through the list of lists printing each value; with the following code:. .. code-block:: cmake. foreach(list_name IN LISTS list_of_lists); foreach(value IN LISTS ${list_name}); message(${value}); endforeach(); endforeach(). You'll notice that the inner foreach loop's list is doubly dereferenced. This is; because the first dereference turns ``list_name`` into the name of the sub-list; (a, b, or c in the example), then the second dereference is to get the value of; the list. This pattern is used throughout CMake, the most common example is the compiler; flags options, which CMake refers to using the following variable expansions:; CMAKE_${LANGUAGE}_FLAGS and CMAKE_${LANGUAGE}_FLAGS_${CMAKE_BUILD_TYPE}. Other Types; -----------. Variables that are cached or specified on the command line can have types; associated with them. The variable's type is used by CMake's UI tool to display; the right input field. A variable's type generally doesn't impact evaluation,; however CMake does have special handling for some variables such as PATH.; You can read more about the special handling in `CMake's set documentation; <https://cmake.org/cmake/help/v3.5/co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst:5153,message,message,5153,interpreter/llvm-project/llvm/docs/CMakePrimer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst,1,['message'],['message']
Integrability,"eychainAttributeList *attrList = 0;; UInt32 *length = 0;; void *outData = 0;. OSStatus st =; SecKeychainItemCopyAttributesAndData(itemRef, info,; itemClass, &attrList,; length, &outData);. SecKeychainItemFreeContent(attrList, outData);; // warn: deallocator doesn't match the allocator; }. osx.cocoa.AtSync; (ObjC); Check for nil pointers used as mutexes for @synchronized. void test(id x) {; if (!x); @synchronized(x) {} // warn: nil value used as mutex; }. void test() {; id y;; @synchronized(y) {} // warn: uninitialized value used as mutex; }. osx.cocoa.ClassRelease; (ObjC); Check for sending retain, release, or ; autorelease directly to a class. @interface MyClass : NSObject; @end. void test(void) {; [MyClass release]; // warn; }. osx.cocoa.Dealloc; (ObjC); Warn about Objective-C classes that lack a correct implementation; of -dealloc. @interface MyObject : NSObject {; id _myproperty;; }; @end. @implementation MyObject // warn: lacks 'dealloc'; @end. @interface MyObject : NSObject {}; @property(assign) id myproperty;; @end. @implementation MyObject // warn: does not send 'dealloc' to super; - (void)dealloc {; self.myproperty = 0;; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(retain) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var was retained but wasn't released; - (void)dealloc {; [super dealloc];; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(assign) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var wasn't retained but was released; - (void)dealloc {; [_myproperty release];; [super dealloc];; }; @end. osx.cocoa.IncompatibleMethodTypes; (ObjC); Check for an incompatible type signature when overriding an Objective-C method. @interface MyClass1 : NSObject; - (int)foo;; @end. @implementation MyClass1; - (int)foo { return 1; }; @end. @interface MyClass2 : MyClass1; - (float)foo;; @end. @implementation MyClass2; - (fl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:15284,interface,interface,15284,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,2,['interface'],['interface']
Integrability,"f ``true``, horizontally align operands of binary and ternary; expressions. Possible values:. * ``OAS_DontAlign`` (in configuration: ``DontAlign``); Do not align operands of binary and ternary expressions.; The wrapped lines are indented ``ContinuationIndentWidth`` spaces from; the start of the line. * ``OAS_Align`` (in configuration: ``Align``); Horizontally align operands of binary and ternary expressions. Specifically, this aligns operands of a single expression that needs; to be split over multiple lines, e.g.:. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb +; ccccccccccccccc;. When ``BreakBeforeBinaryOperators`` is set, the wrapped operator is; aligned with the operand on the first line. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb; + ccccccccccccccc;. * ``OAS_AlignAfterOperator`` (in configuration: ``AlignAfterOperator``); Horizontally align operands of binary and ternary expressions. This is similar to ``AO_Align``, except when; ``BreakBeforeBinaryOperators`` is set, the operator is un-indented so; that the wrapped operand is aligned with the operand on the first line. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb; + ccccccccccccccc;. .. _AlignTrailingComments:. **AlignTrailingComments** (``TrailingCommentsAlignmentStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <AlignTrailingComments>`; Control of trailing comments. The alignment stops at closing braces after a line break, and only; followed by other closing braces, a (``do-``) ``while``, a lambda call, or; a semicolon. .. note::. As of clang-format 16 this option is not a bool but can be set; to the options. Conventional bool options still can be parsed as before. .. code-block:: yaml. # Example of usage:; AlignTrailingComments:; Kind: Always; OverEmptyLines: 2. Nested configuration flags:. Alignment options. * ``TrailingCommentsAlignmentKinds Kind``; Specifies the way to align trailing comments. Possible values:. * ``TCAS_Leave`` (in configuration: ``Leave``); Leave trailing comments as they are. .. c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:22463,wrap,wrapped,22463,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['wrap'],['wrapped']
Integrability,"f all CPUs which are missing atomic; compare-and-swap support are uniprocessor (no SMP). This is almost always the; case. The only common architecture without that property is SPARC -- SPARCV8 SMP; systems were common, yet it doesn't support any sort of compare-and-swap; operation. Some targets (like RISCV) support a ``+forced-atomics`` target feature, which; enables the use of lock-free atomics even if LLVM is not aware of any specific; OS support for them. In this case, the user is responsible for ensuring that; necessary ``__sync_*`` implementations are available. Code using; ``+forced-atomics`` is ABI-incompatible with code not using the feature, if; atomic variables cross the ABI boundary. In either of these cases, the Target in LLVM can claim support for atomics of an; appropriate size, and then implement some subset of the operations via libcalls; to a ``__sync_*`` function. Such functions *must* not use locks in their; implementation, because unlike the ``__atomic_*`` routines used by; AtomicExpandPass, these may be mixed-and-matched with native instructions by the; target lowering. Further, these routines do not need to be shared, as they are stateless. So,; there is no issue with having multiple copies included in one binary. Thus,; typically these routines are implemented by the statically-linked compiler; runtime support library. LLVM will emit a call to an appropriate ``__sync_*`` routine if the target; ISelLowering code has set the corresponding ``ATOMIC_CMPXCHG``, ``ATOMIC_SWAP``,; or ``ATOMIC_LOAD_*`` operation to ""Expand"", and if it has opted-into the; availability of those library functions via a call to ``initSyncLibcalls()``. The full set of functions that may be called by LLVM is (for ``N`` being 1, 2,; 4, 8, or 16)::. iN __sync_val_compare_and_swap_N(iN *ptr, iN expected, iN desired); iN __sync_lock_test_and_set_N(iN *ptr, iN val); iN __sync_fetch_and_add_N(iN *ptr, iN val); iN __sync_fetch_and_sub_N(iN *ptr, iN val); iN __sync_fetch_and_and_N(i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst:28457,rout,routines,28457,interpreter/llvm-project/llvm/docs/Atomics.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst,1,['rout'],['routines']
Integrability,"f bytes it read. This; implies that some bytes within the value may be ``undef`` **without**; the entire value being ``undef``. Note that this only defines the; semantics of the operation; it doesn't mean that targets will emit more; than one instruction to read the series of bytes. Note that in cases where none of the atomic intrinsics are used, this; model places only one restriction on IR transformations on top of what; is required for single-threaded execution: introducing a store to a byte; which might not otherwise be stored is not allowed in general.; (Specifically, in the case where another thread might write to and read; from an address, introducing a store can change a load that may see; exactly one write into a load that may see multiple writes.). .. _ordering:. Atomic Memory Ordering Constraints; ----------------------------------. Atomic instructions (:ref:`cmpxchg <i_cmpxchg>`,; :ref:`atomicrmw <i_atomicrmw>`, :ref:`fence <i_fence>`,; :ref:`atomic load <i_load>`, and :ref:`atomic store <i_store>`) take; ordering parameters that determine which other atomic instructions on; the same address they *synchronize with*. These semantics implement; the Java or C++ memory models; if these descriptions aren't precise; enough, check those specs (see spec references in the; :doc:`atomics guide <Atomics>`). :ref:`fence <i_fence>` instructions; treat these orderings somewhat differently since they don't take an; address. See that instruction's documentation for details. For a simpler introduction to the ordering constraints, see the; :doc:`Atomics`. ``unordered``; The set of values that can be read is governed by the happens-before; partial order. A value cannot be read unless some operation wrote; it. This is intended to provide a guarantee strong enough to model; Java's non-volatile shared variables. This ordering cannot be; specified for read-modify-write operations; it is not strong enough; to make them atomic in any interesting way.; ``monotonic``; In addition ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:152551,synchroniz,synchronize,152551,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['synchroniz'],['synchronize']
Integrability,"f bytes needed to hold all bits of the type. For; example, storing an ``i24`` writes at most three bytes. When writing a; value of a type like ``i20`` with a size that is not an integral number; of bytes, it is unspecified what happens to the extra bits that do not; belong to the type, but they will typically be overwritten.; If ``<value>`` is of aggregate type, padding is filled with; :ref:`undef <undefvalues>`.; If ``<pointer>`` is not a well-defined value, the behavior is undefined. Example:; """""""""""""""". .. code-block:: llvm. %ptr = alloca i32 ; yields ptr; store i32 3, ptr %ptr ; yields void; %val = load i32, ptr %ptr ; yields i32:val = i32 3. .. _i_fence:. '``fence``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. fence [syncscope(""<target-scope>"")] <ordering> ; yields void. Overview:; """""""""""""""""". The '``fence``' instruction is used to introduce happens-before edges; between operations. Arguments:; """""""""""""""""""". '``fence``' instructions take an :ref:`ordering <ordering>` argument which; defines what *synchronizes-with* edges they add. They can only be given; ``acquire``, ``release``, ``acq_rel``, and ``seq_cst`` orderings. Semantics:; """""""""""""""""""". A fence A which has (at least) ``release`` ordering semantics; *synchronizes with* a fence B with (at least) ``acquire`` ordering; semantics if and only if there exist atomic operations X and Y, both; operating on some atomic object M, such that A is sequenced before X, X; modifies M (either directly or through some side effect of a sequence; headed by X), Y is sequenced before B, and Y observes M. This provides a; *happens-before* dependency between A and B. Rather than an explicit; ``fence``, one (but not both) of the atomic operations X or Y might; provide a ``release`` or ``acquire`` (resp.) ordering constraint and; still *synchronize-with* the explicit ``fence`` and establish the; *happens-before* edge. A ``fence`` which has ``seq_cst`` ordering, in addition to having both; ``acquire`` and ``release`` seman",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:423788,synchroniz,synchronizes-with,423788,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['synchroniz'],['synchronizes-with']
Integrability,"f datasets that; will speedup certain data intensive operations. RooStats; New Tutorials. Several new tutorials were added for RooStats. rs101_limitexample.C Demonstrates use of Frequentist,; Bayesian, and Likelihood intervals for a simple number counting experiment; with uncertainty on signal and background rates.; rs301_splot.C Demonstrates use of RooStats sPlot; implementation; rs401c_FeldmanCousins.C Demonstrates use of; FeldmanCousins interval calculator with a Poisson problem, reproduces; results from table IV and V of the original; paper�Phys.Rev.D57:3873-3889,1998.; rs401d_FeldmanCousins.C Demonstrates use of; FeldmanCousins interval calculator with the neutrino oscillation toy; example described in the original paper�Phys.Rev.D57:3873-3889,1998.; Reproduces figure 12.; rs_bernsteinCorrection.C Demonstrates use of; BernsteinCorrection class, which corrects a nominal PDF with a polynomial; to agree with observed or simulated data. TestStatistic interface and implementations; We added a new interface class called TestStatistic. It defines the; method Evaluate(data, parameterPoint), which returns a double. �This; class can be used in�conjunction�with the ToyMCSampler class to generate; sampling distributions for a user-defined test statistic. �; The following concrete implementations of the TestStatistic interface; are currently available. ProfileLikelihoodTestStatReturns the log of profile; likelihood ratio. �Generally a powerful test statistic. ; NumEventsTestStatReturns the number of events in the; dataset. �Useful for number counting experiments.; DebuggingTestStat Simply returns a uniform random number; between 0,1. �Useful for debugging. SamplingDistribution and the�TestStatSampler interface and; implementations; We introduced a ``result'' or data model class called; SamplingDistribution, which holds the sampling distribution of an; arbitrary real valued test statistic. �The class also can return the; inverse of the cumulative distribution function (with ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:25811,interface,interface,25811,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,4,['interface'],['interface']
Integrability,"f dependencies. A; translation unit will then include the precompiled header that starts the chain; (i.e., nothing depends on it). This linearity of dependencies is important for; the semantic model of chained precompiled headers, because the most-recent; precompiled header can provide information that overrides the information; provided by the precompiled headers it depends on, just like a header file; ``B.h`` that includes another header ``A.h`` can modify the state produced by; parsing ``A.h``, e.g., by ``#undef``'ing a macro defined in ``A.h``. There are several ways in which chained precompiled headers generalize the AST; file model:. Numbering of IDs; Many different kinds of entities --- identifiers, declarations, types, etc.; --- have ID numbers that start at 1 or some other predefined constant and; grow upward. Each precompiled header records the maximum ID number it has; assigned in each category. Then, when a new precompiled header is generated; that depends on (chains to) another precompiled header, it will start; counting at the next available ID number. This way, one can determine, given; an ID number, which AST file actually contains the entity. Name lookup; When writing a chained precompiled header, Clang attempts to write only; information that has changed from the precompiled header on which it is; based. This changes the lookup algorithm for the various tables, such as the; :ref:`identifier table <pchinternals-ident-table>`: the search starts at the; most-recent precompiled header. If no entry is found, lookup then proceeds; to the identifier table in the precompiled header it depends on, and so one.; Once a lookup succeeds, that result is considered definitive, overriding any; results from earlier precompiled headers. Update records; There are various ways in which a later precompiled header can modify the; entities described in an earlier precompiled header. For example, later; precompiled headers can add entries into the various name-lookup table",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:25789,depend,depends,25789,interpreter/llvm-project/clang/docs/PCHInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst,1,['depend'],['depends']
Integrability,f function parameters; Unknown. 1149; C++11; Trivial non-public copy operators in subobjects; Unknown. 1150; NAD; Inheriting constructors have not been implemented; Unknown. 1151; C++11; Overload resolution with initializer-list and non-list constructors; Unknown. 1152; C++11; Rules for determining existence of implicit conversion sequence; Unknown. 1153; C++11; Type matching in address of overloaded function; Unknown. 1154; C++11; Address of thread_local variable as non-type template argument; Unknown. 1155; C++11; Internal-linkage non-type template arguments; Unknown. 1156; C++11; Partial ordering in a non-call context; Unknown. 1157; open; Partial ordering of function templates is still underspecified; Not resolved. 1158; C++11; Recursive instantiation via alias template; Unknown. 1159; C++11; Class and enumeration definitions in template aliases; Unknown. 1160; C++11; Definitions of template members and the current instantiation; Unknown. 1161; C++11; Dependent nested-name-specifier in a pointer-to-member declarator; Unknown. 1162; NAD; Dependent elaborated-type-specifiers in non-deduced contexts; Unknown. 1163; NAD; extern template prevents inlining functions not marked inline; Unknown. 1164; C++11; Partial ordering of f(T&) and f(T&&); Unknown. 1165; C++11; Exceptions when destroying array elements; Unknown. 1166; C++11; exception-declarations that do not declare objects; Unknown. 1167; C++11; function-try-blocks for destructors; Unknown. 1168; C++11; Additional reasons to call std::terminate; Unknown. 1169; C++11; Missing feature macro for strict pointer safety; Unknown. 1170; C++11; Access checking during template argument deduction; Unknown. 1171; C++11; Partial stack unwinding with noexcept violation; Unknown. 1172; drafting; “instantiation-dependent” constructs; Not resolved. 1173; C++11; Unclear specification of effects of signal handling; Unknown. 1174; C++11; When is a pure virtual function “used?”; Unknown. 1175; C++11; Disambiguating user-defined lite,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:77197,Depend,Dependent,77197,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Depend'],['Dependent']
Integrability,"f it appeared at the location of the; declaration whose type is being modified. Macros are not available and; nullability must be applied explicitly (even in an ``NS_ASSUME_NONNULL_BEGIN``; section). ::. - Selector: ""subviews""; MethodKind: Instance; ResultType: ""NSArray * _Nonnull"". :SwiftImportAsAccessors:. Used for properties. If true, the property will be exposed in Swift as its; accessor methods, rather than as a computed property using ``var``. ::. - Name: currentContext; PropertyKind: Class; SwiftImportAsAccessors: true. :NSErrorDomain:. Used for ``NSError`` code enums. The value is the name of the associated; domain ``NSString`` constant; an empty string (``""""``) means the enum is a; normal enum rather than an error code. ::. - Name: MKErrorCode; NSErrorDomain: MKErrorDomain. :SwiftWrapper:. Controls ``NS_STRING_ENUM`` and ``NS_EXTENSIBLE_STRING_ENUM``. There are three; options:. - ""struct"" (extensible); - ""enum""; - ""none"". Note that even an ""enum"" wrapper is still presented as a struct in Swift;; it's just a ""more enum-like"" struct. ::. - Name: AVMediaType; SwiftWrapper: none. :EnumKind:. Has the same effect as ``NS_ENUM`` and ``NS_OPTIONS``. There are four options:. - ""NSEnum"" / ""CFEnum""; - ""NSClosedEnum"" / ""CFClosedEnum""; - ""NSOptions"" / ""CFOptions""; - ""none"". ::. - Name: GKPhotoSize; EnumKind: none. :Parameters:. Used for methods and functions. Parameters are identified by a 0-based; 'Position' and support the 'Nullability', 'NoEscape', and 'Type' keys. .. note::. Using 'Parameters' within a parameter entry to describe the parameters of a; block is not implemented. Use 'Type' on the entire parameter instead. ::. - Selector: ""isEqual:""; MethodKind: Instance; Parameters:; - Position: 0; Nullability: O. :NoEscape:. Used only for block parameters. Equivalent to ``NS_NOESCAPE``. ::. - Name: dispatch_sync; Parameters:; - Position: 0; NoEscape: true. :SwiftBridge:. Used for Objective-C class types bridged to Swift value types. An empty; string ("""") means a type ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/APINotes.rst:8202,wrap,wrapper,8202,interpreter/llvm-project/clang/docs/APINotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/APINotes.rst,1,['wrap'],['wrapper']
Integrability,"f it is not 'real'. II. Usage of clang driver:. * Basic Command-Line Options:; - Help: clang --help; - Standard GCC options accepted: -E, -I*, -i*, -pedantic, -std=c90, etc.; - To make diagnostics more gcc-like: -fno-caret-diagnostics -fno-show-column; - Enable metric printing: -stats. * -fsyntax-only is currently the default mode. * -E mode works the same way as GCC. * -Eonly mode does all preprocessing, but does not print the output,; useful for timing the preprocessor.; ; * -fsyntax-only is currently partially implemented, lacking some; semantic analysis (some errors and warnings are not produced). * -parse-noop parses code without building an AST. This is useful; for timing the cost of the parser without including AST building; time.; ; * -parse-ast builds ASTs, but doesn't print them. This is most; useful for timing AST building vs -parse-noop.; ; * -parse-ast-print pretty prints most expression and statements nodes. * -parse-ast-check checks that diagnostic messages that are expected; are reported and that those which are reported are expected. * -dump-cfg builds ASTs and then CFGs. CFGs are then pretty-printed. * -view-cfg builds ASTs and then CFGs. CFGs are then visualized by; invoking Graphviz. For more information on getting Graphviz to work with clang/LLVM,; see: https://llvm.org/docs/ProgrammersManual.html#ViewGraph. III. Current advantages over GCC:. * Column numbers are fully tracked (no 256 col limit, no GCC-style pruning).; * All diagnostics have column numbers, includes 'caret diagnostics', and they; highlight regions of interesting code (e.g. the LHS and RHS of a binop).; * Full diagnostic customization by client (can format diagnostics however they; like, e.g. in an IDE or refactoring tool) through DiagnosticClient interface.; * Built as a framework, can be reused by multiple tools.; * All languages supported linked into same library (no cc1,cc1obj, ...).; * mmap's code in read-only, does not dirty the pages like GCC (mem footprint).; * LLVM Licens",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2007-OriginalClangReadme.txt:5216,message,messages,5216,interpreter/llvm-project/llvm/docs/HistoricalNotes/2007-OriginalClangReadme.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2007-OriginalClangReadme.txt,1,['message'],['messages']
Integrability,"f modules is transparent, other than the requirement that they; need to be co-located with the compiled dictionary shared library. Optionally, the dictionary generation process also produces a mapping file,; which lists the libraries needed to load C++ classes on request (for details,; see the section on the class loader below). Structurally, you could have a single dictionary for a project as a whole,; but more likely a large project will have a pre-existing functional; decomposition that can be followed, with a dictionary per functional unit. Generation; ^^^^^^^^^^. There are two interfaces onto the same underlying dictionary generator:; ``rootcling`` and ``genreflex``.; The reason for having two is historic and they are not complete duplicates,; so one or the other may suit your preference better.; It is foreseen that both will be replaced once C++ modules become more; mainstream, as that will allow simplification and improved robustness. rootcling; """""""""""""""""". The first interface is called ``rootcling``::. $ rootcling; Usage: rootcling [-v][-v0-4] [-f] [out.cxx] [opts] file1.h[+][-][!] file2.h[+][-][!] ...[Linkdef.h]; For more extensive help type: /usr/local/lib/python2.7/dist-packages/cppyy_backend/bin/rootcling -h. Rather than providing command line options, the main steering of; ``rootcling`` behavior is done through; `#pragmas in a Linkdef.h <https://root.cern.ch/root/html/guides/users-guide/AddingaClass.html#the-linkdef.h-file>`_; file, with most pragmas dedicated to selecting/excluding (parts of) classes; and functions.; Additionally, the Linkdef.h file may contain preprocessor macros. The output consists of a dictionary file (to be compiled into a shared; library), a C++ module, and an optional mapping file, as described above. genreflex; """""""""""""""""". The second interface is called ``genreflex``::. $ genreflex; Generates dictionary sources and related ROOT pcm starting from an header.; Usage: genreflex headerfile.h [opts] [preproc. opts]; ... ``genreflex`` ha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst:3832,interface,interface,3832,bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,1,['interface'],['interface']
Integrability,f non-type typename-specifier; Unknown. 1975; CD4; Permissible declarations for exception-specifications; Unknown. 1976; NAD; Ambiguity of namespace-aliases; Unknown. 1977; drafting; Contradictory results of failed destructor lookup; Not resolved. 1978; CD4; Redundant description of explicit constructor use; Unknown. 1979; drafting; Alias template specialization in template member definition; Not resolved. 1980; drafting; Equivalent but not functionally-equivalent redeclarations; Not resolved. 1981; CD4; Implicit contextual conversions and explicit; Unknown. 1982; NAD; Deduction extending parameter pack; Unknown. 1983; CD5; Inappropriate use of virt-specifier; Unknown. 1984; NAD; Lossless narrowing conversions; Unknown. 1985; NAD; Unknown bound array member with brace-or-equal-initializer; Unknown. 1986; drafting; odr-use and delayed initialization; Not resolved. 1987; NAD; constexpr static data members across translation units; Unknown. 1988; CD4; Ambiguity between dependent and non-dependent bases in implicit member access; Unknown. 1989; drafting; Insufficient restrictions on parameters of postfix operators; Not resolved. 1990; CD4; Ambiguity due to optional decl-specifier-seq; Unknown. 1991; CD4; Inheriting constructors vs default arguments; Clang 3.9. 1992; CD4; new (std::nothrow) int[N] can throw; Unknown. 1993; drafting; Use of template<> defining member of explicit specialization; Not resolved. 1994; dup; Confusing wording regarding multiple template<> prefixes; Duplicate of 529. 1995; CD4; exception-specifications and non-type template parameters; Unknown. 1996; drafting; Reference list-initialization ignores conversion functions; Not resolved. 1997; drafting; Placement new and previous initialization; Not resolved. 1998; NAD; Additional sources of xvalue expressions; Unknown. 1999; CD4; Representation of source characters as universal-character-names; Unknown. 2000; CD4; header-name outside #include directive; Unknown. 2001; CD4; non-directive is underspeci,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:135051,depend,dependent,135051,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,4,['depend'],['dependent']
Integrability,"f revolution about Z axis (inner and outer surfaces). The; class describing hyperboloids is **`TGeoHype`** has 5 input parameters:. ``` {.cpp}; TGeoHype(Double_t rin,Double_t stin,Double_t rout,; Double_t stout,Double_t dz);; ```. ![TGeoHype Class](pictures/080001C1.png). The hyperbolic surface equation is taken in the form:. ``` {.cpp}; r2 - z2tan2() = r2min; ```. - `r,z:` cylindrical coordinates for a point on the surface; - `:` stereo angle between the hyperbola asymptotic lines and Z axis; - `r2min:` minimum distance between hyperbola and Z axis (at `z=0`). The input parameters represent:. - `rin, stin:` minimum radius and tangent of stereo angle for inner; surface; - `rout, stout:` minimum radius and tangent of stereo angle for outer; surface; - `dz:` half length in Z (bounding planes positions at `+/-dz`). The following conditions are mandatory in order to avoid intersections; between the inner and outer hyperbolic surfaces in the range `+/-dz`:. - `rin<rout`; - `rout>0`; - `rin2 + dz2*stin2 > rout2 + dz2*stout2`. Particular cases:. - `rin=0, stin0:` the inner surface is conical; - `stin=0 / stout=0:` cylindrical surface(s). #### Cones - TGeoCone Class. The cones are defined by 5 parameters:. ``` {.cpp}; TGeoCone(Double_t dz,Double_t rmin1,Double_t rmax1,; Double_t rmin2,Double_t rmax2);; ```. - `rmin1:` internal radius at Z is `-dz`; - `rmax1:` external radius at Z is `-dz`; - `rmin2:` internal radius at Z is `+dz`; - `rmax2:` external radius at Z is `+dz`; - `dz:` half length in Z (a cone ranges from `-dz` to +`dz`). A cone has Z-axis as its symmetry axis. ![TGeoCone Class](pictures/060001C2.png). #### Cone Segments - TGeoConeSeg Class. A cone segment is a cone having a range in `phi.` The cone segment class; derives from **`TGeoCone`**, having two extra parameters: `phi1` and; `phi2`. ``` {.cpp}; TGeoConeSeg(Double_t dz,Double_t rmin1,Double_t rmax1,; Double_t rmin2,Double_t rmax2,Double_t phi1,Double_t phi2);; ```. Parameters` phi1` and `phi2` have the same",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:34784,rout,rout,34784,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,2,['rout'],['rout']
Integrability,"f simulateneous p.d.f.s; rf16_normandint.C - Normalization, integration and cumulative distribution functions (1d); rf16_normandint2d.C - Normalization, integration and cumulative distribution functions (1d); ; Update of class documentation; ; The documentation in the code itself that is extracted by THtml to construct; the online class documentation has been updated for all classes. Now all classes; have (again) a short class description, as well as a (short) description of each member function; and most data members. An update to the users manual is foreseen shortly after the 5.20; release. RooWorkspace. A new feature has been added that allows to persist source code of RooFit classes that; are not in ROOT distribution inside a RooWorkspace to facilitate sharing; of custom code with others. To import code of custom classes call. RooWorkspace::importClassCode(). after importing the objects themselves into the workspace. For all classes; that are compiled with ACliC RooWorkspace can automatically find the source; code using the ROOT TClass interface. For custom classes that are compiled; externally and loaded into ROOT as shared library it might be necessary to; provide the location of the source files manually using the static RooWorkspace; member functions addClassDeclImportDir() and addClassImplImportDir().; ; When a TFile with a RooWorkspace containing source code is opened in a ROOT; session that does not have the class code already loaded for the classes; contained in the workspace, the code in the workspace is written to file,; compiled and loaded into the ROOT session on the fly. The code repository of RooWorkspace is designed to handle classes that; have either their own implementation and header file, or are part of a group; of classes that share a common header and implementation file. More complicated; structuring of source code into files is not supported. ; ; Also new accessors have been added for discrete-valued functions catfunc(); and stored categor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html:2149,interface,interface,2149,roofit/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html,2,['interface'],['interface']
Integrability,"f the base expression is more; complex, then the cost can rise quickly. I've seen loops where the end; expression was actually something like: ""``SomeMap[X]->end()``"" and map lookups; really aren't cheap. By writing it in the second form consistently, you; eliminate the issue entirely and don't even have to think about it. The second (even bigger) issue is that writing the loop in the first form hints; to the reader that the loop is mutating the container (a fact that a comment; would handily confirm!). If you write the loop in the second form, it is; immediately obvious without even looking at the body of the loop that the; container isn't being modified, which makes it easier to read the code and; understand what it does. While the second form of the loop is a few extra keystrokes, we do strongly; prefer it. ``#include <iostream>`` is Forbidden; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The use of ``#include <iostream>`` in library files is hereby **forbidden**,; because many common implementations transparently inject a `static constructor`_; into every translation unit that includes it. Note that using the other stream headers (``<sstream>`` for example) is not; problematic in this regard --- just ``<iostream>``. However, ``raw_ostream``; provides various APIs that are better performing for almost every use than; ``std::ostream`` style APIs. .. note::. New code should always use `raw_ostream`_ for writing, or the; ``llvm::MemoryBuffer`` API for reading files. .. _raw_ostream:. Use ``raw_ostream``; ^^^^^^^^^^^^^^^^^^^. LLVM includes a lightweight, simple, and efficient stream implementation in; ``llvm/Support/raw_ostream.h``, which provides all of the common features of; ``std::ostream``. All new code should use ``raw_ostream`` instead of; ``ostream``. Unlike ``std::ostream``, ``raw_ostream`` is not a template and can be forward; declared as ``class raw_ostream``. Public headers should generally not include; the ``raw_ostream`` header, but use forward declarations an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:55163,inject,inject,55163,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['inject'],['inject']
Integrability,"f the normal distribution](pictures/03000128.png). ## Numerical Algorithms. ROOT provides C++ classes implementing numerical algorithms to solve a wide set of problem, like:. * Evaluation of function derivatives.; * Evaluation of integrals.; * Finding the roots of a function; * Finding the minimum/maximum of a function. In order to use these algorithm the user needs to provide a function.; ROOT provides a common way of specifying them via some interfaces. ## ROOT::Math Function interfaces. To get a consistency in the mathematical methods within ROOT, there exists a set of interfaces to define the basic behaviour of a mathematical function.; In order to use the classes presented in this chapter, the mathematical functions defined by the user must inherit from any of the classes seen in the figure:. ![ROOT::Math Function interface structure](pictures/function-hierarchy.png). ### One-dimensional Function Interfaces. These interfaces are used for numerical algorithms operating only on one-dimensional functions and cannot be applied to multi-dimensional functions.; For this case the users needs to define a function object which evaluates in one dimension, and the object will have to derivate from the following:. * `ROOT::Math::IBaseFunctionOneDim`: This class is the most basic function. Provides a method to evaluate the function given a value (simple double) by implementing; `double operator() (const double )`. The user class defined only needs to reimplement the pure abstract method `double DoEval(double x)`,; that will do the work of evaluating the function at point x. Example on how to create a class that represents a mathematical function. The user only has to override two methods from `IBaseFunctionOneDim`:. ```{.cpp}; #include ""Math/IFunction.h"". class MyFunction: public ROOT::Math::IBaseFunctionOneDim; {; double DoEval(double x) const; {; return x*x;; }. ROOT::Math::IBaseFunctionOneDim* Clone() const; {; return new MyFunction();; }; };; ```. * `ROOT::Math::IGradien",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:35203,interface,interfaces,35203,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['interface'],['interfaces']
Integrability,"f the objects content is changing in the application, one could enable monitoring flag in the browser - then objects view will be regularly updated. ## Accessing file system. THttpServer provides partial access to the files from file system.; First of all, JSROOT scripts and files can be accessed via ""jsrootsys/"" path like ""http://localhost:8080/jsrootsys/modules/core.mjs"".; Files from ROOT install directory can be get via ""rootsys/"" path like ""http://localhost:8080/rootsys/icons/about.xpm"".; Also files from current directory where ROOT is running can be accessed via ""currentdir/"" path like ""http://localhost:8080/currentdir/file.txt"". If necessary, one can add custom path as well, using [THttpServer::AddLocation](https://root.cern/doc/master/classTHttpServer.html#a5322c3bbfddb8eb6849297d83ccaf87f) method:. ```cpp; serv->AddLocation(""mydir/"", ""/home/user/specials"");; ```. Then files from that directory could be addressed via URL like ""http://localhost:8080/mydir/myfile.root"". ## Command interface. THttpServer class provide simple interface to invoke command from web browser.; One just register command like:. ```cpp; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"");; ```. Element with name `DoSomething` will appear in the web browser and can be clicked.; It will result in `gROOT->ProcessLineSync(""SomeFunction()"")` call. One could configure argument(s) for the command.; For that one should use `%arg1`, `%arg2` and so on identifiers. Like:. ```cpp; serv->RegisterCommand(""/DoSomething"", ""SomeFunction(%arg1%,%arg2%)"");; ```. User will be requested to enter arguments values, when command element clicked in the browser.; Example of the command which executes arbitrary string in application via ProcessLine looks like:. ```cpp; serv->RegisterCommand(""/Process"", ""%arg1%"");; ```. When registering command, one could specify icon name which will be displayed with the command. ```cpp; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"", ""rootsys/icons/ed_execute.png"");; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:4897,interface,interface,4897,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['interface'],['interface']
Integrability,"f they did not. The ``doInitialization(Region *, RGPassManager &)`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doInitialization(Region *, RGPassManager &RGM);. The ``doInitialization`` method is designed to do simple initialization type of; stuff that does not depend on the functions being processed. The; ``doInitialization`` method call is not scheduled to overlap with any other; pass executions (thus it should be very fast). ``RPPassManager`` interface; should be used to access ``Function`` or ``Module`` level analysis information. .. _writing-an-llvm-pass-runOnRegion:. The ``runOnRegion`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool runOnRegion(Region *, RGPassManager &RGM) = 0;. The ``runOnRegion`` method must be implemented by your subclass to do the; transformation or analysis work of your pass. As usual, a true value should be; returned if the region is modified. ``RGPassManager`` interface should be used to; update region tree. The ``doFinalization()`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doFinalization();. The ``doFinalization`` method is an infrequently used method that is called; when the pass framework has finished calling :ref:`runOnRegion; <writing-an-llvm-pass-runOnRegion>` for every region in the program being; compiled. The ``MachineFunctionPass`` class; ---------------------------------. A ``MachineFunctionPass`` is a part of the LLVM code generator that executes on; the machine-dependent representation of each LLVM function in the program. Code generator passes are registered and initialized specially by; ``TargetMachine::addPassesToEmitFile`` and similar routines, so they cannot; generally be run from the :program:`opt` or :program:`bugpoint` commands. A ``MachineFunctionPass`` is also a ``FunctionPass``, so all the restrictions; that apply to a ``FunctionPass`` also apply to it. ``MachineFunctionPass``\ es; also have addition",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:24266,interface,interface,24266,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['interface'],['interface']
Integrability,"f when to use LibClang:. * Xcode; * Clang Python Bindings. Use LibClang when you...:. * want to interface with clang from other languages than C++; * need a stable interface that takes care to be backwards compatible; * want powerful high-level abstractions, like iterating through an AST with a; cursor, and don't want to learn all the nitty gritty details of Clang's AST. Do not use LibClang when you...:. * want full control over the Clang AST. Clang Plugins; -------------. :doc:`Clang Plugins <ClangPlugins>` allow you to run additional actions on the; AST as part of a compilation. Plugins are dynamic libraries that are loaded at; runtime by the compiler, and they're easy to integrate into your build; environment. Canonical examples of when to use Clang Plugins:. * special lint-style warnings or errors for your project; * creating additional build artifacts from a single compile step. Use Clang Plugins when you...:. * need your tool to rerun if any of the dependencies change; * want your tool to make or break a build; * need full control over the Clang AST. Do not use Clang Plugins when you...:. * want to run tools outside of your build environment; * want full control on how Clang is set up, including mapping of in-memory; virtual files; * need to run over a specific subset of files in your project which is not; necessarily related to any changes which would trigger rebuilds. LibTooling; ----------. :doc:`LibTooling <LibTooling>` is a C++ interface aimed at writing standalone; tools, as well as integrating into services that run clang tools. Canonical; examples of when to use LibTooling:. * a simple syntax checker; * refactoring tools. Use LibTooling when you...:. * want to run tools over a single file, or a specific subset of files,; independently of the build system; * want full control over the Clang AST; * want to share code with Clang Plugins. Do not use LibTooling when you...:. * want to run as part of the build triggered by dependency changes; * want a stable",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst:1647,depend,dependencies,1647,interpreter/llvm-project/clang/docs/Tooling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst,1,['depend'],['dependencies']
Integrability,"f which do not have any Python equivalent; (e.g. ``unsigned short*``).; Furthermore, such codes tend to be ambiguous: the information from header; file is not sufficient to determine the full purpose.; For example, an ``int*`` type may refer to the address of a single ``int``; (an out-parameter, say) or it may refer to an array of ``int``, the ownership; of which is not clear either.; cppyy provides a few low-level helpers and integration with the Python; `ctypes module`_ to cover these cases. Use of these low-level helpers will obviously lead to very ""C-like"" code and; it is recommended to :doc:`pythonize <pythonizations>` the code, perhaps; using the Cling JIT and embedded C++. Note: the low-level module is not loaded by default (since its use is, or; should be, uncommon).; It needs to be imported explicitly:. .. code-block:: python. >>> import cppyy.ll; >>>. `LowLevelView`; --------------. Python has an elaborate array interface (buffer) specification, but no; standard library array type that completely implements it; instead, the; canonical Python array type is the NumPy one.; cppyy introduces the basic ``LowLevelView`` array class to avoid having a; direct dependency on NumPy and to guarantee zero copy.; The ``LowLevelView`` type gives access to array details such as the size,; type, etc. and allows reading/writing of array elements, both for interactive; use and through the buffer interface to allow NumPy to interface with them.; For more complex operations, it's recommended to copy from the; ``LowLevelView`` inta a NumPy array, or to create a NumPy view (see below,; under :ref:`NumPy Casts <npcasts>`). `C/C++ casts`; -------------. C++ instances are auto-casted to the most derived available type, so do not; require explicit casts even when a function returns a pointer to a base; class or interface.; However, when given only a ``void*`` or ``intptr_t`` type on return, a cast; is required to turn it into something usable. * **bind_object**: This is the preferred",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst:1102,interface,interface,1102,bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,1,['interface'],['interface']
Integrability,"f()"". You can also use the CRTP; base ManglingParser to perform some simple analysis on the mangled; name, or (in LLVM) use the opaque ItaniumPartialDemangler to query the; demangled AST. Why are there multiple copies of the this library in the source tree?; ---------------------------------------------------------------------. The canonical sources are in libcxxabi/src/demangle and some of the; files are copied to llvm/include/llvm/Demangle. The simple reason for; this comes from before the monorepo, and both [sub]projects need to; demangle symbols, but neither can depend on each other. * libcxxabi needs the demangler to implement __cxa_demangle, which is; part of the itanium ABI spec. * LLVM needs a copy for a bunch of places, and cannot rely on the; system's __cxa_demangle because it a) might not be available (i.e.,; on Windows), and b) may not be up-to-date on the latest language; features. The copy of the demangler in LLVM has some extra stuff that aren't; needed in libcxxabi (ie, the MSVC demangler, ItaniumPartialDemangler),; which depend on the shared generic components. Despite these; differences, we want to keep the ""core"" generic demangling library; identical between both copies to simplify development and testing. If you're working on the generic library, then do the work first in; libcxxabi, then run libcxxabi/src/demangle/cp-to-llvm.sh. This; script takes as an optional argument the path to llvm, and copies the; changes you made to libcxxabi over. Note that this script just; blindly overwrites all changes to the generic library in llvm, so be; careful. Because the core demangler needs to work in libcxxabi, everything; needs to be declared in an anonymous namespace (see; DEMANGLE_NAMESPACE_BEGIN), and you can't introduce any code that; depends on the libcxx dylib. FIXME: Now that LLVM is a monorepo, it should be possible to; de-duplicate this code, and have both LLVM and libcxxabi depend on a; shared demangler library. Testing; -------. The tests are spli",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/README.txt:1314,depend,depend,1314,interpreter/llvm-project/llvm/include/llvm/Demangle/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/README.txt,1,['depend'],['depend']
Integrability,"f-enter`. ### Install the experiment's configuration files system-wide. A system administrator might find convenient to install the experiment; environment scripts system-wide. Configuration scripts for LHC experiments are shipped with the VAF; client and can be found in; `/dest/dir/client/config-samples/<experiment_name>`. To make them used; by default by the VAF client, place them in the `/dest/dir/etc`; directory like this:. ``` {.bash}; rsync -a /dest/dir/client/config-samples/<experiment_name>/ /dest/dir/etc/; ```. Remember that the trailing slash in the source directory name has a; meaning in `rsync` and must not be omitted. > Remember that system-wide configuration files will always have; > precedence over user's configuration files, so *don't place there; > files that are supposed to be provided by the user!*. Entering the Virtual Analysis Facility environment; --------------------------------------------------. The Virtual Analysis Facility client is a wrapper around commands sent; to the remote host by means of PROOF on Demand's `pod-remote`. The VAF; client takes care of setting up passwordless SSH from your client node; to the VAF master. ### Getting the credentials. > You can skip this paragraph if the remote server wasn't configured for; > HTTPS+SSH authentication. In our example we will assume that the remote server's name is; `cloud-gw-213.to.infn.it`: substitute it with your remote endpoint. First, check that you have your Grid certificate and private key; installed both in your browser and in the home directory of your; client. Point your browser to `https://cloud-gw-213.to.infn.it/auth/`: you'll; probably be asked for a certificate to choose for authentication. Pick; one and you'll be presented with the following web page:. ![Web authentication with sshcertauth](img/sshcertauth-web.png). The webpage clearly explains you what to do next. ### Customizing user's configuration. Before entering the VAF environment, you should customize the user's; confi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:8250,wrap,wrapper,8250,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,1,['wrap'],['wrapper']
Integrability,"f:`SmallPtrSet <dss_smallptrset>`. The magic of this class is that it handles small sets extremely efficiently, but; gracefully handles extremely large sets without loss of efficiency. .. _dss_smallptrset:. llvm/ADT/SmallPtrSet.h; ^^^^^^^^^^^^^^^^^^^^^^. ``SmallPtrSet`` has all the advantages of ``SmallSet`` (and a ``SmallSet`` of; pointers is transparently implemented with a ``SmallPtrSet``). If more than N; insertions are performed, a single quadratically probed hash table is allocated; and grows as needed, providing extremely efficient access (constant time; insertion/deleting/queries with low constant factors) and is very stingy with; malloc traffic. Note that, unlike :ref:`std::set <dss_set>`, the iterators of ``SmallPtrSet``; are invalidated whenever an insertion occurs. Also, the values visited by the; iterators are not visited in sorted order. .. _dss_stringset:. llvm/ADT/StringSet.h; ^^^^^^^^^^^^^^^^^^^^. ``StringSet`` is a thin wrapper around :ref:`StringMap\<char\> <dss_stringmap>`,; and it allows efficient storage and retrieval of unique strings. Functionally analogous to ``SmallSet<StringRef>``, ``StringSet`` also supports; iteration. (The iterator dereferences to a ``StringMapEntry<char>``, so you; need to call ``i->getKey()`` to access the item of the StringSet.) On the; other hand, ``StringSet`` doesn't support range-insertion and; copy-construction, which :ref:`SmallSet <dss_smallset>` and :ref:`SmallPtrSet; <dss_smallptrset>` do support. .. _dss_denseset:. llvm/ADT/DenseSet.h; ^^^^^^^^^^^^^^^^^^^. DenseSet is a simple quadratically probed hash table. It excels at supporting; small values: it uses a single allocation to hold all of the pairs that are; currently inserted in the set. DenseSet is a great way to unique small values; that are not simple pointers (use :ref:`SmallPtrSet <dss_smallptrset>` for; pointers). Note that DenseSet has the same requirements for the value type that; :ref:`DenseMap <dss_densemap>` has. .. _dss_sparseset:. llvm/ADT/Spa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:79435,wrap,wrapper,79435,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['wrap'],['wrapper']
Integrability,"fButton->SetStyle(""modern"");. TRootBrowser. Use the ProcessedConfigure signal to be notified when an embedded frame change its layout, to properly call Layout() on its parent frame, to automatically display the change (for example, showing the EventStatusBar of a TCanvas embedded in a TBrowser was only appearing after manually resizing the window). TGFileBrowser. Fixed memory leak when browsing TList inside a file: don't read the list content each time one click on the list; A protection for empty directories (e.g. not containing any key) as been added. Solves the bug #94028, TBrowser crash trying to browse sub-root-directories in memory. TGFSComboBox. Fix a problem when the current directory is similar to $ROOTSYS, for example with $ROOTSYS being /home/user/root and $PWD being /home/user/rootdev, only ""dev"" was displayed, stripping off $ROOTSYS; Properly handle backslashes as directory separators on Windows. TGFileDialog. Change the file name only if the selected entry is not a directory (as reported on the forum). TGMsgBox. Implemented ""Enter"" and ""Escape"" key handling in TGMsgBox (used as Ok and Cancel buttons, if they are there). TGTextEntry. Several issues with text selection and combination of cursor position and text alignment in text entries have been solved. TRootCanvas. A check has been added for the case where the canvas is embedded (e.g. in the browser), then the layout of the main frame has to be re-applied when showing/hiding the editor; Stay in the current (working) directory when using ""File -> Save as..."" from a canvas or from a text editor (as the file dialog changes the current directory). TFitParametersDialog. Implemented keyboard navigation (tab and shift+tab) between the different number entry fields of the dialog. TFitEditor. Layout improvements and removed useless text in message box. TTreeViewer. Fixed a problem with array names (e.g. fVertex[]) as reported on the forum). TGWin32. Fixed several resource leaks (including GDI & USER objects). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v534/index.html:2153,message,message,2153,gui/doc/v534/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v534/index.html,2,['message'],['message']
Integrability,"fallback-style FALLBACK_STYLE] [-binary BINARY]. This script reads input from a unified diff and reformats all the changed; lines. This is useful to reformat all the lines touched by a specific patch.; Example usage for git/svn users:. git diff -U0 --no-color --relative HEAD^ | clang-format-diff.py -p1 -i; svn diff --diff-cmd=diff -x-U0 | clang-format-diff.py -i. It should be noted that the filename contained in the diff is used unmodified; to determine the source file to update. Users calling this script directly; should be careful to ensure that the path in the diff is correct relative to the; current working directory. optional arguments:; -h, --help show this help message and exit; -i apply edits to files instead of displaying a diff; -p NUM strip the smallest prefix containing P slashes; -regex PATTERN custom pattern selecting file paths to reformat (case sensitive, overrides -iregex); -iregex PATTERN custom pattern selecting file paths to reformat (case insensitive, overridden by -regex); -sort-includes let clang-format sort include blocks; -v, --verbose be more verbose, ineffective without -i; -style STYLE formatting style to apply (LLVM, GNU, Google, Chromium, Microsoft, Mozilla, WebKit); -fallback-style FALLBACK_STYLE; The name of the predefined style used as a fallback in case clang-format is invoked with-style=file, but can not; find the .clang-formatfile to use.; -binary BINARY location of binary to use for clang-format. To reformat all the lines in the latest Mercurial/:program:`hg` commit, do:. .. code-block:: console. hg diff -U0 --color=never | clang-format-diff.py -i -p1. The option `-U0` will create a diff without context lines (the script would format; those as well). These commands use the file paths shown in the diff output; so they will only work from the root of the repository. Current State of Clang Format for LLVM; ======================================. The following table :doc:`ClangFormattedStatus` shows the current status of clang-formatt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst:13116,message,message,13116,interpreter/llvm-project/clang/docs/ClangFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst,1,['message'],['message']
Integrability,"fast-math options. The; pragma can take two values: ``on`` and ``off``. .. code-block:: c++. float f(float x, float y); {; // Enable floating point reciprocal approximation; #pragma clang fp reciprocal(on); return x / y;; }. ``#pragma clang fp contract`` specifies whether the compiler should; contract a multiply and an addition (or subtraction) into a fused FMA; operation when supported by the target. The pragma can take three values: ``on``, ``fast`` and ``off``. The ``on``; option is identical to using ``#pragma STDC FP_CONTRACT(ON)`` and it allows; fusion as specified the language standard. The ``fast`` option allows fusion; in cases when the language standard does not make this possible (e.g. across; statements in C). .. code-block:: c++. for(...) {; #pragma clang fp contract(fast); a = b[i] * c[i];; d[i] += a;; }. The pragma can also be used with ``off`` which turns FP contraction off for a; section of the code. This can be useful when fast contraction is otherwise; enabled for the translation unit with the ``-ffp-contract=fast-honor-pragmas`` flag.; Note that ``-ffp-contract=fast`` will override pragmas to fuse multiply and; addition across statements regardless of any controlling pragmas. ``#pragma clang fp exceptions`` specifies floating point exception behavior. It; may take one of the values: ``ignore``, ``maytrap`` or ``strict``. Meaning of; these values is same as for `constrained floating point intrinsics <http://llvm.org/docs/LangRef.html#constrained-floating-point-intrinsics>`_. .. code-block:: c++. {; // Preserve floating point exceptions; #pragma clang fp exceptions(strict); z = x + y;; if (fetestexcept(FE_OVERFLOW)); ...; }. A ``#pragma clang fp`` pragma may contain any number of options:. .. code-block:: c++. void func(float *dest, float a, float b) {; #pragma clang fp exceptions(maytrap) contract(fast) reassociate(on); ...; }. ``#pragma clang fp eval_method`` allows floating-point behavior to be specified; for a section of the source code. This p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:172032,contract,contraction,172032,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,2,['contract'],"['contract', 'contraction']"
Integrability,"fault --gcc-install-dir= or --gcc-triple=. --gcc-toolchain= is discouraged. ""; ""See https://github.com/llvm/llvm-project/pull/77537 for detail.""); endif(). set(ENABLE_LINKER_BUILD_ID OFF CACHE BOOL ""pass --build-id to ld""). set(ENABLE_X86_RELAX_RELOCATIONS ON CACHE BOOL; ""enable x86 relax relocations by default""). set(PPC_LINUX_DEFAULT_IEEELONGDOUBLE OFF CACHE BOOL; ""Enable IEEE binary128 as default long double format on PowerPC Linux.""). set(CLANG_SPAWN_CC1 OFF CACHE BOOL; ""Whether clang should use a new process for the CC1 invocation""). option(CLANG_DEFAULT_PIE_ON_LINUX ""Default to -fPIE and -pie on linux-gnu"" ON). set(CLANG_DEFAULT_LINKER """" CACHE STRING; ""Default linker to use (linker name or absolute path, empty for platform default)""). set(CLANG_DEFAULT_CXX_STDLIB """" CACHE STRING; ""Default C++ stdlib to use (\""libstdc++\"" or \""libc++\"", empty for platform default""); if (NOT(CLANG_DEFAULT_CXX_STDLIB STREQUAL """" OR; CLANG_DEFAULT_CXX_STDLIB STREQUAL ""libstdc++"" OR; CLANG_DEFAULT_CXX_STDLIB STREQUAL ""libc++"")); message(WARNING ""Resetting default C++ stdlib to use platform default""); set(CLANG_DEFAULT_CXX_STDLIB """" CACHE STRING; ""Default C++ stdlib to use (\""libstdc++\"" or \""libc++\"", empty for platform default"" FORCE); endif(). set(CLANG_DEFAULT_RTLIB """" CACHE STRING; ""Default runtime library to use (\""libgcc\"" or \""compiler-rt\"", empty for platform default)""); if (NOT(CLANG_DEFAULT_RTLIB STREQUAL """" OR; CLANG_DEFAULT_RTLIB STREQUAL ""libgcc"" OR; CLANG_DEFAULT_RTLIB STREQUAL ""compiler-rt"")); message(WARNING ""Resetting default rtlib to use platform default""); set(CLANG_DEFAULT_RTLIB """" CACHE STRING; ""Default runtime library to use (\""libgcc\"" or \""compiler-rt\"", empty for platform default)"" FORCE); endif(). set(CLANG_DEFAULT_UNWINDLIB """" CACHE STRING; ""Default unwind library to use (\""none\"" \""libgcc\"" or \""libunwind\"", empty to match runtime library.)""); if (CLANG_DEFAULT_UNWINDLIB STREQUAL """"); if (CLANG_DEFAULT_RTLIB STREQUAL ""libgcc""); set (CLANG_DEFAULT_UNWINDL",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:8074,message,message,8074,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,1,['message'],['message']
Integrability,"fault, assumes at; least 1cy between the dispatch event and the issue event. When the performance is limited by data dependencies and/or long latency; instructions, the number of cycles spent while in the *ready* state is expected; to be very small when compared with the total number of cycles spent in the; scheduler's queue. The difference between the two counters is a good indicator; of how large of an impact data dependencies had on the execution of the; instructions. When performance is mostly limited by the lack of hardware; resources, the delta between the two counters is small. However, the number of; cycles spent in the queue tends to be larger (i.e., more than 1-3cy),; especially when compared to other low latency instructions. Bottleneck Analysis; ^^^^^^^^^^^^^^^^^^^; The ``-bottleneck-analysis`` command line option enables the analysis of; performance bottlenecks. This analysis is potentially expensive. It attempts to correlate increases in; backend pressure (caused by pipeline resource pressure and data dependencies) to; dynamic dispatch stalls. Below is an example of ``-bottleneck-analysis`` output generated by; :program:`llvm-mca` for 500 iterations of the dot-product example on btver2. .. code-block:: none. Cycles with backend pressure increase [ 48.07% ]; Throughput Bottlenecks:; Resource Pressure [ 47.77% ]; - JFPA [ 47.77% ]; - JFPU0 [ 47.77% ]; Data Dependencies: [ 0.30% ]; - Register Dependencies [ 0.30% ]; - Memory Dependencies [ 0.00% ]. Critical sequence based on the simulation:. Instruction Dependency Information; +----< 2. vhaddps %xmm3, %xmm3, %xmm4; |; | < loop carried >; |; | 0. vmulps %xmm0, %xmm1, %xmm2; +----> 1. vhaddps %xmm2, %xmm2, %xmm3 ## RESOURCE interference: JFPA [ probability: 74% ]; +----> 2. vhaddps %xmm3, %xmm3, %xmm4 ## REGISTER dependency: %xmm3; |; | < loop carried >; |; +----> 1. vhaddps %xmm2, %xmm2, %xmm3 ## RESOURCE interference: JFPA [ probability: 74% ]. According to the analysis, throughput is limited by resource ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst:26774,depend,dependencies,26774,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,1,['depend'],['dependencies']
Integrability,"ferent SIMDs. The exception is when in tgsplit execution mode; when the wavefronts may be executed by different SIMDs in different CUs.; * Each CU has a single LDS memory shared by the wavefronts of the work-groups; executing on it. The exception is when in tgsplit execution mode when no LDS; is allocated as wavefronts of the same work-group can be in different CUs.; * All LDS operations of a CU are performed as wavefront wide operations in a; global order and involve no caching. Completion is reported to a wavefront in; execution order.; * The LDS memory has multiple request queues shared by the SIMDs of a; CU. Therefore, the LDS operations performed by different wavefronts of a; work-group can be reordered relative to each other, which can result in; reordering the visibility of vector memory operations with respect to LDS; operations of other wavefronts in the same work-group. A ``s_waitcnt; lgkmcnt(0)`` is required to ensure synchronization between LDS operations and; vector memory operations between wavefronts of a work-group, but not between; operations performed by the same wavefront.; * The vector memory operations are performed as wavefront wide operations and; completion is reported to a wavefront in execution order. The exception is; that ``flat_load/store/atomic`` instructions can report out of vector memory; order if they access LDS memory, and out of LDS operation order if they access; global memory.; * The vector memory operations access a single vector L1 cache shared by all; SIMDs a CU. Therefore:. * No special action is required for coherence between the lanes of a single; wavefront. * No special action is required for coherence between wavefronts in the same; work-group since they execute on the same CU. The exception is when in; tgsplit execution mode as wavefronts of the same work-group can be in; different CUs and so a ``buffer_inv sc0`` is required which will invalidate; the L1 cache. * A ``buffer_inv sc0`` is required to invalidate the L1 cac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:285499,synchroniz,synchronization,285499,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['synchroniz'],['synchronization']
Integrability,"ferent SIMDs. The exception is when in tgsplit execution mode; when the wavefronts may be executed by different SIMDs in different CUs.; * Each CU has a single LDS memory shared by the wavefronts of the work-groups; executing on it. The exception is when in tgsplit execution mode when no LDS; is allocated as wavefronts of the same work-group can be in different CUs.; * All LDS operations of a CU are performed as wavefront wide operations in a; global order and involve no caching. Completion is reported to a wavefront in; execution order.; * The LDS memory has multiple request queues shared by the SIMDs of a; CU. Therefore, the LDS operations performed by different wavefronts of a; work-group can be reordered relative to each other, which can result in; reordering the visibility of vector memory operations with respect to LDS; operations of other wavefronts in the same work-group. A ``s_waitcnt; lgkmcnt(0)`` is required to ensure synchronization between LDS operations and; vector memory operations between wavefronts of a work-group, but not between; operations performed by the same wavefront.; * The vector memory operations are performed as wavefront wide operations and; completion is reported to a wavefront in execution order. The exception is; that ``flat_load/store/atomic`` instructions can report out of vector memory; order if they access LDS memory, and out of LDS operation order if they access; global memory.; * The vector memory operations access a single vector L1 cache shared by all; SIMDs a CU. Therefore:. * No special action is required for coherence between the lanes of a single; wavefront. * No special action is required for coherence between wavefronts in the same; work-group since they execute on the same CU. The exception is when in; tgsplit execution mode as wavefronts of the same work-group can be in; different CUs and so a ``buffer_wbinvl1_vol`` is required as described in; the following item. * A ``buffer_wbinvl1_vol`` is required for coherence be",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:235351,synchroniz,synchronization,235351,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['synchroniz'],['synchronization']
Integrability,"ferent methods, using in some case the derivatives. #### `ROOT::Math::BrentMinimizer1D`. This class implements the Brent method to minimize one-dimensional function.; An interval containing the function minimum must be provided.; Here is an example where we define the function to minimize as a *lambda* function; (requires C++11). The function to minimize must be given to the class implementing the algorithm as a; `ROOT::Math::IBaseFunctionOneDim` object. ```{.cpp}; ROOT::Math::Functor1D func( [](double x){ return 1 + -4*x + 1*x*x; } );. ROOT::Math::BrentMinimizer1D bm;; bm.SetFunction(func, -10,10);; bm.Minimize(10,0,0);; cout << ""Minimum: f("" << bm.XMinimum() << "") = "" <<bm.FValMinimum() << endl;; ```. Note that when setting the function to minimize, one needs to provide the interval range to find the minimum.; In the `Minimize` call, the maximum number of function calls, the relative and absolute tolerance must be provided. #### `ROOT::Math::GSLMInimizer1D`. This class wraps two different methods from the GSL.; The algorithms which can be chosen at construction time are *GOLDENSECTION*, which is the simplest method; but the slowest and *BRENT* (the default one) which combines the golden section with a parabolic interpolation.; The algorithm can be chosen as a different enumeration in the constructor:; * `ROOT::Math::Minim1D::kBRENT` for the Brent algorithm (default); * `ROOT::Math::Minim1D::kGOLDENSECTION` for the golden section algorithm. ```{.cpp}; // this makes class with the default Brent algorithm; ROOT::Math::GSLMinimizer1D minBrent;; // this make the class with the Golden Section algorithm; ROOT::Math::GSLMinimizer1D minGold(ROOT::Math::Minim1D::kGOLDENSECTION);; ```. The interface to set the function and to minimize is the same as in the case of the `BrentMinimizer1D`. #### Using the TF1 class. It is possible to perform the one-dimensional minimization/maximization of a function by using directly the function class in ROOT, `TF1` of the *Hist* library.; The",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:64978,wrap,wraps,64978,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['wrap'],['wraps']
Integrability,"fers to standard C++ modules; feature if it is not decorated by ``Clang``. Clang Modules; ~~~~~~~~~~~~~. In this document, the term ``Clang Modules``/``Clang modules`` refer to Clang; c++ modules extension. These are also known as ``Clang header modules``,; ``Clang module map modules`` or ``Clang c++ modules``. Module and module unit; ~~~~~~~~~~~~~~~~~~~~~~. A module consists of one or more module units. A module unit is a special; translation unit. Every module unit must have a module declaration. The syntax; of the module declaration is:. .. code-block:: c++. [export] module module_name[:partition_name];. Terms enclosed in ``[]`` are optional. The syntax of ``module_name`` and ``partition_name``; in regex form corresponds to ``[a-zA-Z_][a-zA-Z_0-9\.]*``. In particular, a literal dot ``.``; in the name has no semantic meaning (e.g. implying a hierarchy). In this document, module units are classified into:. * Primary module interface unit. * Module implementation unit. * Module interface partition unit. * Internal module partition unit. A primary module interface unit is a module unit whose module declaration is; ``export module module_name;``. The ``module_name`` here denotes the name of the; module. A module should have one and only one primary module interface unit. A module implementation unit is a module unit whose module declaration is; ``module module_name;``. A module could have multiple module implementation; units with the same declaration. A module interface partition unit is a module unit whose module declaration is; ``export module module_name:partition_name;``. The ``partition_name`` should be; unique within any given module. An internal module partition unit is a module unit whose module declaration; is ``module module_name:partition_name;``. The ``partition_name`` should be; unique within any given module. In this document, we use the following umbrella terms:. * A ``module interface unit`` refers to either a ``primary module interface unit``; or a ``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:2652,interface,interface,2652,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['interface'],['interface']
Integrability,"fferent ways; <DiagnosticConsumer>` depending on how the ``DiagnosticConsumer`` interface is; implemented. A representative example of a diagnostic is:. .. code-block:: text. t.c:38:15: error: invalid operands to binary expression ('int *' and '_Complex float'); P = (P-42) + Gamma*4;; ~~~~~~ ^ ~~~~~~~. In this example, you can see the English translation, the severity (error), you; can see the source location (the caret (""``^``"") and file/line/column info),; the source ranges ""``~~~~``"", arguments to the diagnostic (""``int*``"" and; ""``_Complex float``""). You'll have to believe me that there is a unique ID; backing the diagnostic :). Getting all of this to happen has several steps and involves many moving; pieces, this section describes them and talks about best practices when adding; a new diagnostic. The ``Diagnostic*Kinds.td`` files; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Diagnostics are created by adding an entry to one of the; ``clang/Basic/Diagnostic*Kinds.td`` files, depending on what library will be; using it. From this file, :program:`tblgen` generates the unique ID of the; diagnostic, the severity of the diagnostic and the English translation + format; string. There is little sanity with the naming of the unique ID's right now. Some; start with ``err_``, ``warn_``, ``ext_`` to encode the severity into the name.; Since the enum is referenced in the C++ code that produces the diagnostic, it; is somewhat useful for it to be reasonably short. The severity of the diagnostic comes from the set {``NOTE``, ``REMARK``,; ``WARNING``,; ``EXTENSION``, ``EXTWARN``, ``ERROR``}. The ``ERROR`` severity is used for; diagnostics indicating the program is never acceptable under any circumstances.; When an error is emitted, the AST for the input code may not be fully built.; The ``EXTENSION`` and ``EXTWARN`` severities are used for extensions to the; language that Clang accepts. This means that Clang fully understands and can; represent them in the AST, but we produce diagnostics ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:3499,depend,depending,3499,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['depend'],['depending']
Integrability,"fffull);; case 4:; return (x << 32) | ((y >> 24) & 0xffffffffull);; default:; return (x << 40) | ((y >> 16) & 0xffffffffffull);; }; }. //===---------------------------------------------------------------------===//. This (and similar related idioms):. unsigned int foo(unsigned char i) {; return i | (i<<8) | (i<<16) | (i<<24);; } . compiles into:. define i32 @foo(i8 zeroext %i) nounwind readnone ssp noredzone {; entry:; %conv = zext i8 %i to i32; %shl = shl i32 %conv, 8; %shl5 = shl i32 %conv, 16; %shl9 = shl i32 %conv, 24; %or = or i32 %shl9, %conv; %or6 = or i32 %or, %shl5; %or10 = or i32 %or6, %shl; ret i32 %or10; }. it would be better as:. unsigned int bar(unsigned char i) {; unsigned int j=i | (i << 8); ; return j | (j<<16);; }. aka:. define i32 @bar(i8 zeroext %i) nounwind readnone ssp noredzone {; entry:; %conv = zext i8 %i to i32; %shl = shl i32 %conv, 8; %or = or i32 %shl, %conv; %shl5 = shl i32 %or, 16; %or6 = or i32 %shl5, %or; ret i32 %or6; }. or even i*0x01010101, depending on the speed of the multiplier. The best way to; handle this is to canonicalize it to a multiply in IR and have codegen handle; lowering multiplies to shifts on cpus where shifts are faster. //===---------------------------------------------------------------------===//. We do a number of simplifications in simplify libcalls to strength reduce; standard library functions, but we don't currently merge them together. For; example, it is useful to merge memcpy(a,b,strlen(b)) -> strcpy. This can only; be done safely if ""b"" isn't modified between the strlen and memcpy of course. //===---------------------------------------------------------------------===//. We compile this program: (from GCC PR11680); http://gcc.gnu.org/bugzilla/attachment.cgi?id=4487. Into code that runs the same speed in fast/slow modes, but both modes run 2x; slower than when compile with GCC (either 4.0 or 4.2):. $ llvm-g++ perf.cpp -O3 -fno-exceptions; $ time ./a.out fast; 1.821u 0.003s 0:01.82 100.0%	0+0k 0+0io 0pf+",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:18161,depend,depending,18161,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,2,['depend'],['depending']
Integrability,"fficient to determine the full purpose.; For example, an ``int*`` type may refer to the address of a single ``int``; (an out-parameter, say) or it may refer to an array of ``int``, the ownership; of which is not clear either.; cppyy provides a few low-level helpers and integration with the Python; `ctypes module`_ to cover these cases. Use of these low-level helpers will obviously lead to very ""C-like"" code and; it is recommended to :doc:`pythonize <pythonizations>` the code, perhaps; using the Cling JIT and embedded C++. Note: the low-level module is not loaded by default (since its use is, or; should be, uncommon).; It needs to be imported explicitly:. .. code-block:: python. >>> import cppyy.ll; >>>. `LowLevelView`; --------------. Python has an elaborate array interface (buffer) specification, but no; standard library array type that completely implements it; instead, the; canonical Python array type is the NumPy one.; cppyy introduces the basic ``LowLevelView`` array class to avoid having a; direct dependency on NumPy and to guarantee zero copy.; The ``LowLevelView`` type gives access to array details such as the size,; type, etc. and allows reading/writing of array elements, both for interactive; use and through the buffer interface to allow NumPy to interface with them.; For more complex operations, it's recommended to copy from the; ``LowLevelView`` inta a NumPy array, or to create a NumPy view (see below,; under :ref:`NumPy Casts <npcasts>`). `C/C++ casts`; -------------. C++ instances are auto-casted to the most derived available type, so do not; require explicit casts even when a function returns a pointer to a base; class or interface.; However, when given only a ``void*`` or ``intptr_t`` type on return, a cast; is required to turn it into something usable. * **bind_object**: This is the preferred method to proxy a C++ address,; and lives in ``cppyy``, not ``cppyy.ll``, as it is not a low-level C++; cast, but a ``cppyy`` API that is also used internally.;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst:1346,depend,dependency,1346,bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,1,['depend'],['dependency']
Integrability,"ficate and private key; installed both in your browser and in the home directory of your; client. Point your browser to `https://cloud-gw-213.to.infn.it/auth/`: you'll; probably be asked for a certificate to choose for authentication. Pick; one and you'll be presented with the following web page:. ![Web authentication with sshcertauth](img/sshcertauth-web.png). The webpage clearly explains you what to do next. ### Customizing user's configuration. Before entering the VAF environment, you should customize the user's; configuration. How to do so depends on your experiment, but usually you; should essentially specify the version of the experiment's software you; need. For instance, in the CMS use case, only one file is needed:; `~/.vaf/common.before`, which contains something like:. ``` {.bash}; # Version of CMSSW (as reported by ""scram list""); export VafCmsswVersion='CMSSW_5_3_9_sherpa2beta2'; ```. ### Entering the VAF environment. Open a terminal on your client machine (can be either your local; computer or a remote user interface) and type:. vaf-enter <username>@cloud-gw-213.to.infn.it. You'll substitute `<username>` with the username that either your system; administrator or the web authentication (if you used it) provided you. You'll be presented with a neat shell which looks like the following:. Entering VAF environment: dberzano@cloud-gw-213.to.infn.it; Remember: you are still in a shell on your local computer!; pod://dberzano@cloud-gw-213.to.infn.it [~] >. This shell runs on your local computer and it has the environment; properly set up. PoD and PROOF workflow; ----------------------. > The following operations are valid inside the `vaf-enter` environment. ### Start your PoD server. With PROOF on Demand, each user has the control of its own personal; PROOF cluster. The first thing to do is to start the PoD server and the; PROOF master like this:. vafctl --start. A successful output will be similar to:. ** Starting remote PoD server on dberzano@cloud-gw-213.to.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:9784,interface,interface,9784,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,1,['interface'],['interface']
Integrability,"fication defines; the concept of ``TU-local`` and ``exposure`` in; `basic.link/p14 <https://eel.is/c++draft/basic.link#14>`_,; `basic.link/p15 <https://eel.is/c++draft/basic.link#15>`_,; `basic.link/p16 <https://eel.is/c++draft/basic.link#16>`_,; `basic.link/p17 <https://eel.is/c++draft/basic.link#17>`_ and; `basic.link/p18 <https://eel.is/c++draft/basic.link#18>`_. However, the compiler doesn't support these 2 ideas formally.; This results in unclear and confusing diagnostic messages.; And it is worse that the compiler may import TU-local entities to other units without any; diagnostics. This is tracked in https://github.com/llvm/llvm-project/issues/78173. Header Units; ============. How to build projects using header unit; ---------------------------------------. .. warning::. The user interfaces of header units is highly experimental. There are still; many unanswered question about how tools should interact with header units.; The user interfaces described here may change after we have progress on how; tools should support for header units. Quick Start; ~~~~~~~~~~~. For the following example,. .. code-block:: c++. import <iostream>;; int main() {; std::cout << ""Hello World.\n"";; }. we could compile it as. .. code-block:: console. $ clang++ -std=c++20 -xc++-system-header --precompile iostream -o iostream.pcm; $ clang++ -std=c++20 -fmodule-file=iostream.pcm main.cpp. How to produce BMIs; ~~~~~~~~~~~~~~~~~~~. Similar to named modules, we could use ``--precompile`` to produce the BMI.; But we need to specify that the input file is a header by ``-xc++-system-header`` or ``-xc++-user-header``. Also we could use `-fmodule-header={user,system}` option to produce the BMI for header units; which has suffix like `.h` or `.hh`.; The value of `-fmodule-header` means the user search path or the system search path.; The default value for `-fmodule-header` is `user`.; For example,. .. code-block:: c++. // foo.h; #include <iostream>; void Hello() {; std::cout << ""Hello World.\n"";;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:27305,interface,interfaces,27305,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['interface'],['interfaces']
Integrability,"fication of a given; state will provide the following information: the deepest physical node; containing the position vector, the distance to the closest boundary; along the direction vector, the next physical node after propagating the; current point with this distance and the safety distance to the nearest; boundary. This information allows the propagation of particles inside a; detector geometry by taking into account both geometrical and physical; constraints. We will hereby describe the user interface of `TGeo` to access; tracking functionality. This allows either developing a tracker for; simple navigation within a given geometry, either interfacing to an; external tracking engine such as GEANT. Note that the abstract interface; for external trackers can be found in `$ROOTSYS/vmc` folder and it can; be used to run GEANT3, GEANT4 and FLUKA-based simulations (\*) by using; directly a geometry described with %ROOT. The interface methods related to tracking are incorporated into; TGeoManager class and implemented in the navigator class; TGeoNavigator. In order to be able to start tracking, one has to; define the initial state providing the starting point \f$\vec{r_0}\f$; and direction \f$\vec{n_0}\f$ .; There are several ways of doing that. \anchor GP02a; ### TGeoNavigator Class. One geometry may have several independent navigators to query to; localize points or compute distances. The geometry manager holds a list; of active navigators accessible via:. ~~~{.cpp}; TObjArray *navigators = gGeoManager->GetListOfNavigators();; ~~~. Upon closing the geometry a default navigator is provided as first one; in this list, but one may add its own via:. ~~~{.cpp}; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; ~~~. A navigator ho",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:62540,interface,interface,62540,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['interface'],['interface']
Integrability,"fication-based vs. subset-based, etc. Traditionally,; alias analyses respond to a query with a `Must, May, or No`_ alias response,; indicating that two pointers always point to the same object, might point to the; same object, or are known to never point to the same object. The LLVM `AliasAnalysis; <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__ class is the; primary interface used by clients and implementations of alias analyses in the; LLVM system. This class is the common interface between clients of alias; analysis information and the implementations providing it, and is designed to; support a wide range of implementations and clients (but currently all clients; are assumed to be flow-insensitive). In addition to simple alias analysis; information, this class exposes Mod/Ref information from those implementations; which can provide it, allowing for powerful analyses and transformations to work; well together. This document contains information necessary to successfully implement this; interface, use it, and to test both sides. It also explains some of the finer; points about what exactly results mean. ``AliasAnalysis`` Class Overview; ================================. The `AliasAnalysis <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__; class defines the interface that the various alias analysis implementations; should support. This class exports two important enums: ``AliasResult`` and; ``ModRefResult`` which represent the result of an alias query or a mod/ref; query, respectively. The ``AliasAnalysis`` interface exposes information about memory, represented in; several different ways. In particular, memory objects are represented as a; starting address and size, and function calls are represented as the actual; ``call`` or ``invoke`` instructions that performs the call. The; ``AliasAnalysis`` interface also exposes some helper methods which allow you to; get mod/ref information for arbitrary instructions. All ``AliasAnalysis`` interfa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:1568,interface,interface,1568,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['interface'],['interface']
Integrability,"fig/AsmPrinters.def.in; ${LLVM_INCLUDE_DIR}/llvm/Config/AsmPrinters.def; ); configure_file(; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/AsmParsers.def.in; ${LLVM_INCLUDE_DIR}/llvm/Config/AsmParsers.def; ); configure_file(; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/Disassemblers.def.in; ${LLVM_INCLUDE_DIR}/llvm/Config/Disassemblers.def; ); configure_file(; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/Targets.def.in; ${LLVM_INCLUDE_DIR}/llvm/Config/Targets.def; ); configure_file(; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/TargetMCAs.def.in; ${LLVM_INCLUDE_DIR}/llvm/Config/TargetMCAs.def; ); configure_file(; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/TargetExegesis.def.in; ${LLVM_INCLUDE_DIR}/llvm/Config/TargetExegesis.def; ). # They are not referenced. See set_output_directory().; set( CMAKE_RUNTIME_OUTPUT_DIRECTORY ${LLVM_TOOLS_BINARY_DIR} ); set( CMAKE_LIBRARY_OUTPUT_DIRECTORY ${LLVM_LIBRARY_DIR} ); set( CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${LLVM_LIBRARY_DIR} ). # For up-to-date instructions for installing the TFLite dependency, refer to; # the bot setup script: https://github.com/google/ml-compiler-opt/blob/main/buildbot/buildbot_init.sh; set(LLVM_HAVE_TFLITE """" CACHE BOOL ""Use tflite""); if (LLVM_HAVE_TFLITE); find_package(tensorflow-lite REQUIRED); endif(). # For up-to-date instructions for installing the Tensorflow dependency, refer to; # the bot setup script: https://github.com/google/ml-compiler-opt/blob/main/buildbot/buildbot_init.sh; # Specifically, assuming python3 is installed:; # python3 -m pip install --upgrade pip && python3 -m pip install --user tf_nightly==2.3.0.dev20200528; # Then set TENSORFLOW_AOT_PATH to the package install - usually it's ~/.local/lib/python3.7/site-packages/tensorflow; #; set(TENSORFLOW_AOT_PATH """" CACHE PATH ""Path to TensorFlow pip install dir""). if (NOT TENSORFLOW_AOT_PATH STREQUAL """"); set(LLVM_HAVE_TF_AOT ""ON"" CACHE BOOL ""Tensorflow AOT available""); set(TENSORFLOW_AOT_COMPILER; ""${TENSORFLOW_AOT_PATH}/../../../../bin/saved_model_cli""; CACHE PATH ""Path to the Te",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:42670,depend,dependency,42670,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['depend'],['dependency']
Integrability,"file for the **master** and the **slave**. Since; most of the configuration variables are the same (like the *HTCondor; shared secret*) you can create one, clone it and change only what's; needed to change. Deploy it on the cloud; ----------------------. Provided you have access to a certain cloud API, you'll need to; instantiate a certain number of CernVM batch images with proper; contextualization: one for the master, as many as you want as slaves. CernVM supports contextualization through the ""user data"" field; supported by all cloud infrastructures. Each cloud infrastructure has a different method of setting the ""user; data"". The following description will focus on:. - [OpenNebula](http://opennebula.org/). - OpenStack (such as the [CERN Agile; infrastructure](https://openstack.cern.ch/)). - [Amazon EC2](http://aws.amazon.com/ec2/)-compatible interfaces via; the open [Eucalyptus](http://www.eucalyptus.com/); [Euca2ools](http://www.eucalyptus.com/eucalyptus-cloud/tools): many popular; clouds support such interface and tools. ### Download the CernVM Online contextualizations. Go to the CernVM Online Dashboard page where you have previously; customized the contexts for your master and your slaves. Click on the rightmost button on the line of the desired context and; select **Get rendered context** from the dropdown: save the output to a; text file (such as `my_vaf_context.txt`, the name we will use in the; examples that follow). This file will be subsequently passed as the so; called ""user-data"" file to the cloud API. > Repeat the operation for both the master context and the slave; > context. ### OpenStack API: nova. Example of a CernVM instantiation using `nova`:. ``` {.bash}; nova boot \; --flavor m1.xlarge \; --image cernvm-batch-node-2.6.0-4-1-x86_64 \; --key-name my_default_keyparir \; --user-data my_vaf_context.txt \; Name-Of-My-New-VM; ```. The `--user-data` option requires the context file we've just; downloaded. ### EC2 API: euca-tools. Example of a CernVM ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DeployVirtualAnalysisFacility.md:4347,interface,interface,4347,proof/doc/confman/DeployVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DeployVirtualAnalysisFacility.md,1,['interface'],['interface']
Integrability,"file has a; `Streamer `that decomposes it and ""streams"" its members into a buffer. The methods of the class are not written to the file, it contains only; the persistent data members. To decompose the parent classes, the; `Streamer `calls the `Streamer `of the parent classes. It moves up the; inheritance tree until it reaches an ancestor without a parent. To; serialize the object data members it calls their `Streamer`. They in; turn move up their own inheritance tree and so forth. The simple data; members are written to the buffer directly. Eventually the buffer; contains all simple data members of all the classes that make up this; particular object. Data members that are references (as; `MyClass &fObj;`) are never saved, it is always the responsibility of; the object's constructor to set them properly. ### Automatically Generated Streamers. A `Streamer `usually calls other `Streamers`: the `Streamer `of its; parents and data members. This architecture depends on all classes; having `Streamers`, because eventually they will be called. To ensure; that a class has a `Streamer`, `rootcling` automatically creates one in; the `ClassDef` macro that is defined in `$ROOTSYS/include/Rtypes.h`.; `ClassDef` defines several methods for any class, and one of them is the; `Streamer`. The automatically generated `Streamer `is complete and can; be used as long as no customization is needed. The `Event` class is defined in `$ROOTSYS/test/Event.h`. Looking at the; class definition, we find that it inherits from **`TObject`**. It is a; simple example of a class with diverse data members. ``` {.cpp}; class Event : public TObject {; private:; TDirectory *fTransient; //! current directory; Float_t fPt; //! transient value; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; EventHeader fEvtHdr; //|| don't split; TClonesArray *fTracks; //->; TH1F *fH; //->; Int_t fMeasures[10];; Float_t fMatrix[4][4];; Float_t *fClosestDistance; //[fNvert",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:43674,depend,depends,43674,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['depend'],['depends']
Integrability,"fill, marker or text; attributes. The following object editors are available for the current; ROOT version. ### TAxisEditor. ![](pictures/030000D5.png). This user interface gives the possibility for changing the following; axis attributes:. - color of the selected axis, the axis' title and labels;. - the length of thick parameters and the possibility to set them on; both axis sides (if `+-` is selected);. - to set logarithmic or linear scale along the selected axis with a; choice for optimized or more logarithmic labels;. - primary, secondary and tertiary axis divisions can be set via the; three number fields;. - the axis title can be added or edited and the title's color,; position, offset, size and font can be set interactively;. - the color, size, and offset of axis labels can be set similarly. In; addition, there is a check box for no exponent choice, and another; one for setting the same decimal part for all labels. ### TPadEditor. ![](pictures/030000D6.png). - It provides the following user interface:. - Fixed aspect ratio - can be set for pad resizing. - Edit - sets pad or canvas as editable. - Cross-hair - sets a cross hair on the pad. - TickX - set ticks along the X axis. - TickY - set ticks along the Y axis. - GridX - set a grid along the X axis. - GridY - set a grid along the Y axis. - The pad or canvas border size can be set if a sunken or a raised; border mode is. - selected; no border mode can be set too. ## Copy and Paste. You can make a copy of a canvas using `TCanvas::DrawClonePad`. This; method is unique to **`TCanvas`**. It clones the entire canvas to the; active pad. There is a more general method `TObject::DrawClone`, which; all objects descendent of **`TObject`**, specifically all graphic; objects inherit. Below are two examples, one to show the use of; `DrawClonePad` and the other to show the use of `DrawClone`. ### Using the GUI. In this example we will copy an entire canvas to a new one with; `DrawClonePad`. Run the script `draw2dopt.C`. ``` ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:85260,interface,interface,85260,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['interface'],['interface']
Integrability,"final stage, ROOT might be able to integrate the Name.pcm with the; shared library itself.; * Improved correctness in number of cases -- in a few cases ROOT is more; correct. In particular, when resolving global variables and function; declarations which are not part of the ROOT PCH.; * Enhanced symbol resolution mechanisms, bloom filters -- standard ROOT relies; on information in ROOTMAP files to react when the llvm JIT issues an; unresolved symbol callback. C++ Modules-aware ROOT relies on a behavior much; closer to the standard linker behavior. In particular, we start searching on; the LD_LIBRARY_PATH descending to the system libraries. The algorithm is very; efficient because it uses bloom filters[[5]]. This in turn allows ROOT symbol; to be extended to system libraries. ### Module Registration Approaches. The C++ modules system supports /*preloading*/ of all modules at startup time.; The current implementation of loading of C++ modules in clang has an overhead; and is between 40-60 MB depending on the ROOT configuration while there might; be 2x slowdown depending on the workflow. These issues are very likely to be; addressed by the LLVM community in midterm. Preloading of all C++ modules is semantically the closest to C++ behavior.; However, in order to achieve performance ROOT loads them on demand using; a global module index file. It has sufficient information to map a looked up; identifier to the module which contains the corresponding definition. Switching; back to preloading of all C++ modules is done by setting the `ROOT_USE_GMI`; environment variable to false.; ; ### Supported Platforms. We support all platforms with glibc++ versions: 5.2 onward. We support OSX from XCode 10 onward. ## Changes required by the users; * Self-contained header files -- every header file should be able to compile; on its own. For instance, `cat header.h header.h | gcc -fsyntax-only -xc++ -`.; This command concatenates `header.h` twice before compiling it to make sure; it has p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:13918,depend,depending,13918,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,2,['depend'],['depending']
Integrability,"fine A \; int aaaa; \; int b; \; int dddddddddd;. false:. * ``ENAS_Right`` (in configuration: ``Right``); Align escaped newlines in the right-most column. .. code-block:: c++. #define A \; int aaaa; \; int b; \; int dddddddddd;. .. _AlignOperands:. **AlignOperands** (``OperandAlignmentStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AlignOperands>`; If ``true``, horizontally align operands of binary and ternary; expressions. Possible values:. * ``OAS_DontAlign`` (in configuration: ``DontAlign``); Do not align operands of binary and ternary expressions.; The wrapped lines are indented ``ContinuationIndentWidth`` spaces from; the start of the line. * ``OAS_Align`` (in configuration: ``Align``); Horizontally align operands of binary and ternary expressions. Specifically, this aligns operands of a single expression that needs; to be split over multiple lines, e.g.:. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb +; ccccccccccccccc;. When ``BreakBeforeBinaryOperators`` is set, the wrapped operator is; aligned with the operand on the first line. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb; + ccccccccccccccc;. * ``OAS_AlignAfterOperator`` (in configuration: ``AlignAfterOperator``); Horizontally align operands of binary and ternary expressions. This is similar to ``AO_Align``, except when; ``BreakBeforeBinaryOperators`` is set, the operator is un-indented so; that the wrapped operand is aligned with the operand on the first line. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb; + ccccccccccccccc;. .. _AlignTrailingComments:. **AlignTrailingComments** (``TrailingCommentsAlignmentStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <AlignTrailingComments>`; Control of trailing comments. The alignment stops at closing braces after a line break, and only; followed by other closing braces, a (``do-``) ``while``, a lambda call, or; a semicolon. .. note::. As of clang-format 16 this option is not a bool but can be set; to the options. Conventional bool options still can be parsed ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:22068,wrap,wrapped,22068,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['wrap'],['wrapped']
Integrability,"fio:` as part of the protocol string),; the plugin class of which an object will be created; (e.g. **`TRFIOFile`**), the library to be loaded (in short; `libRFIO.so` to RFIO), and the constructor to be called (e.g.; ""`TRFIOFile()`""). This can be specified in the `.rootrc` which already; contains many plugin definitions, or by calls to; `gROOT->GetPluginManager()->AddHandler()`. #### Library AutoLoading. When using a class in Cling, e.g. in an interpreted source file, ROOT; will automatically load the library that defines this class. On; start-up, ROOT parses all files ending on `.rootmap` rootmap that are; in one of the `$LD_LIBRARY_PATH` (or `$DYLD_LIBRARY_PATH` for `MacOS`,; or `$PATH` for `Windows`). They contain class names and the library; names that the class depends on. After reading them, ROOT knows which; classes are available, and which libraries to load for them. When `TSystem::Load(""ALib"")` is called, ROOT uses this information to; determine which libraries `libALib.so` depends on. It will load these; libraries first. Otherwise, loading the requested library could cause; a system (dynamic loader) error due to unresolved symbols. ### \$ROOTSYS/tutorials. tutorials The tutorials directory contains many example example; scripts. They assume some basic knowledge of ROOT, and for the new; user we recommend reading the chapters: ""Histograms"" and; ""Input/Output"" before trying the examples. The more experienced user; can jump to chapter ""The Tutorials and Tests"" to find more explicit; and specific information about how to build and run the examples. The `$ROOTSYS/tutorials/` directory include the following; sub-directories:. `fft`: Fast Fourier Transform with the fftw package `fit`: Several; examples illustrating minimization/fitting `foam`: Random generator in; multidimensional space `geom`: Examples of use of the geometry package; (**`TGeo`** classes) `gl`: Visualisation with OpenGL `graphics`: Basic; graphics `graphs`: Use of **`TGraph`**, **`TGraphErrors`**, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:20343,depend,depends,20343,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['depend'],['depends']
Integrability,"fixes have been applied to different problems discovered mainly by a test program from Alfio Lazzaro. In detail:; . Fix a bug in MnMinos which was setting wrong initial values when the parameters were limited.; This was resulting in a much larger number of function calls used inside MnMinos. ; Improve MnHesse by returning in the final state the improved gradient step values used in HessianGradientCalculator. With this change same results are obtained from using Hesse in Minuit2 or TMinuit. In addition, the interface of MnHesse (MnHesse::operator() ) has been improved to use it from the FunctionMinimum object (similar to MnMinos) in order to be called after the minimization (Migrad). The API with a MnUserParameterState should not be used after minimization, because in that case the latest state information resulting from the minimum (gradient values and step sizes) is lost. Add support in MnMigrad and MnMinimize for user provided analytical gradient of the FCN function. One needs to pass an instance of a function implementing the ROOT::Minuit2::FcnGradientBase interface. Use now std::string for storing parameter names. This removes the un-necessary limitation on the length of parameter name (10 characters) existing before. The method Name() of MinuitParameter (and of MnUserParameterState and MnUserParameters) still returns a const char * (for backward compatibility). A new method, GetName() has been added to return a std::string. The Minuit2Minimizer class has been improved by having an option to always run Hesse if it was not done before during the minimization. Method to retrieve the correlation coefficients have been also added. More detailed description of the current Minuit2 release can be found at this location. Unuran. A new version, 1.2.4, has been added to fix mainly some problems found in gcc 4.3. For the detailed changes of this new UNU.RAN version see the file $ROOTSYS/math/unuran/src/unuran-1.2.4-root/NEWS. Last modified: Tue Jun 24 17:22:42 CEST 2008 . ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:13880,interface,interface,13880,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,2,['interface'],['interface']
Integrability,"fly describe the; modern dialect. Objective-C defines a new type kind, collectively called the :arc-term:`object; pointer types`. This kind has two notable builtin members, ``id`` and; ``Class``; ``id`` is the final supertype of all object pointers. The validity; of conversions between object pointer types is not checked at runtime. Users; may define :arc-term:`classes`; each class is a type, and the pointer to that; type is an object pointer type. A class may have a superclass; its pointer; type is a subtype of its superclass's pointer type. A class has a set of; :arc-term:`ivars`, fields which appear on all instances of that class. For; every class *T* there's an associated metaclass; it has no fields, its; superclass is the metaclass of *T*'s superclass, and its metaclass is a global; class. Every class has a global object whose class is the class's metaclass;; metaclasses have no associated type, so pointers to this object have type; ``Class``. A class declaration (``@interface``) declares a set of :arc-term:`methods`. A; method has a return type, a list of argument types, and a :arc-term:`selector`:; a name like ``foo:bar:baz:``, where the number of colons corresponds to the; number of formal arguments. A method may be an instance method, in which case; it can be invoked on objects of the class, or a class method, in which case it; can be invoked on objects of the metaclass. A method may be invoked by; providing an object (called the :arc-term:`receiver`) and a list of formal; arguments interspersed with the selector, like so:. .. code-block:: objc. [receiver foo: fooArg bar: barArg baz: bazArg]. This looks in the dynamic class of the receiver for a method with this name,; then in that class's superclass, etc., until it finds something it can execute.; The receiver ""expression"" may also be the name of a class, in which case the; actual receiver is the class object for that class, or (within method; definitions) it may be ``super``, in which case the lookup algo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:4412,interface,interface,4412,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['interface'],['interface']
Integrability,"folders can be added and removed to/from a folder. ## Why Use Folders?. One reason to use folders is to reduce class dependencies and improve; modularity. Each set of data has a producer class and one or many; consumer classes. When using folders, the producer class places a; pointer to the data into a folder, and the consumer class retrieves a; reference to the folder. The consumer can access the objects in a folder by specifying the path; name of the folder. Here is an example of a folder's path name:. `//root/Event/Hits/TCP`. One does not have to specify the full path name. If the partial path; name is unique, it will find it; otherwise it will return the first; occurrence of the path. The first diagram shows a system without folders. The objects have; pointers to each other to access each other's data. Pointers are an; efficient way to share data between classes. However, a direct pointer; creates a direct coupling between classes. This design can become a very; tangled web of dependencies in a system with a large number of classes. ![](pictures/020000E2.jpg). In the second diagram, a reference to the data is in the folder and the; consumers refer to the folder rather than each other to access the data.; The naming and search service provided by the ROOT folders hierarchy; provides an alternative. It loosely couples the classes and greatly; enhances I/O operations. In this way, folders separate the data from the; algorithms and greatly improve the modularity of an application by; minimizing the class dependencies. ![](pictures/020000E3.jpg). In addition, the folder hierarchy creates a picture of the data; organization. This is useful when discussing data design issues or when; learning the data organization. The example below illustrates this; point. ## How to Use Folders. Using folders means to build a hierarchy of folders, posting the; reference to the data in the folder by the producer, and creating a; reference to the folder by the user. ### Creating a Folder",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md:1418,depend,dependencies,1418,documentation/users-guide/FoldersTasks.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md,1,['depend'],['dependencies']
Integrability,"following:. * An :ref:`integer_number<amdgpu_synid_integer_number>` or an :ref:`absolute_expression<amdgpu_synid_absolute_expression>`. The value must be in the range from 0 to 0xFFFF.; * A combination of *instid0*, *instskip*, *instid1* values which are described below. ======================== =========================== ===============; Syntax Description Default Value; ======================== =========================== ===============; instid0(<*ID name*>) A symbolic *ID0* value. instid0(NO_DEP); instskip(<*SKIP name*>) A symbolic *SKIP* value. instskip(SAME); instid1(<*ID name*>) A symbolic *ID1* value. instid1(NO_DEP); ======================== =========================== ===============. These values may be specified in any order.; When more than one value is specified, the values must be separated from each other by a '|'. Valid *ID names* are defined below. =================== ===================================================================; Name Description; =================== ===================================================================; NO_DEP No dependency on any prior instruction. This is the default value.; VALU_DEP_1 Dependency on a previous VALU instruction, 1 opcode back.; VALU_DEP_2 Dependency on a previous VALU instruction, 2 opcodes back.; VALU_DEP_3 Dependency on a previous VALU instruction, 3 opcodes back.; VALU_DEP_4 Dependency on a previous VALU instruction, 4 opcodes back.; TRANS32_DEP_1 Dependency on a previous TRANS32 instruction, 1 opcode back.; TRANS32_DEP_2 Dependency on a previous TRANS32 instruction, 2 opcodes back.; TRANS32_DEP_3 Dependency on a previous TRANS32 instruction, 3 opcodes back.; FMA_ACCUM_CYCLE_1 Single cycle penalty for FMA accumulation.; SALU_CYCLE_1 1 cycle penalty for a prior SALU instruction.; SALU_CYCLE_2 2 cycle penalty for a prior SALU instruction.; SALU_CYCLE_3 3 cycle penalty for a prior SALU instruction.; =================== ===================================================================. Legal ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_delay.rst:2062,depend,dependency,2062,interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_delay.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_delay.rst,1,['depend'],['dependency']
Integrability,"for (i = fFirstEntry; i < fLastEntry; i++) {; sprintf(tmp, ""Entry %i"", i+1);; fListBox->AddEntry(tmp, i);; }; fListBox->Resize(150, 80);; parent->AddFrame(fListBox,new TGLayoutHints(kLHintsTop|kLHintsLeft,; 5, 5, 5, 5));; ```. We create the list box widget passing the parent window pointer and; giving an ID number. Next we add entries with specified string and ID to; the list box. Before adding the list box to its parent widget, it should; be resized via `Resize(width, height)` method. The list box width and; height are in pixels. The default entry layout hints are; `kLHintsExpandX | kLHintsTop`. If you want to add entries using; different ones, call the method:. ``` {.cpp}; TGListBox::AddEntry(TGLBEntry *lbe, TGLayoutHints *lhints);; ```. It adds the specified **`TGLBEntry`** and **`TGLayoutHints`** to the; list box. There are several methods providing a flexible entry; manipulation: you can insert, add or remove list box items dynamically.; The list box entry IDs are used in these methods and also in event; processing routines. In our example the integer variables `fFirstEntry`; and `fLastEntry` contain the information about the first and last entry; IDs. You can add or remove a list box entry using them in the following; way:. ``` {.cpp}; // adding an entry; fLastEntry++;; sprintf(tmp, ""Entry %i"", fLastEntry);; fListBox->AddEntry(tmp, fLastEntry);; fListBox->MapSubwindows();; fListBox->Layout();; . . .; // removing an entry; if (fFirstEntry < fLastEntry) {; fListBox->RemoveEntry(fFirstEntry);; fListBox->Layout();; fFirstEntry++;; }; ```. A single-selection list box is used for selecting only one item in a; list. A multiple-selection list box permits selection of more than one item.; The selected choices should be visible - you have several choices to do; this:. - to mark selected choices with a check mark or highlight them. - to provide a summary list box to the right of the list box,; containing the selected choices. - to provide a display-only text control indi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:81304,rout,routines,81304,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['rout'],['routines']
Integrability,"for Computing Limits and Confidence Levels. **`TFeldmanCousins`** class calculates the `CL` upper/lower limit for a; Poisson process using the Feldman-Cousins method (as described in PRD; V57 \#7, p3873-3889). No treatment is provided in this method for the; uncertainties in the signal or the background. **`TRolke`** computes confidence intervals for the rate of a Poisson; process in the presence of background and efficiency, using the profile; likelihood technique for treating the uncertainties in the efficiency; and background estimate. The signal is always assumed to be Poisson;; background may be Poisson, Gaussian, or user-supplied; efficiency may be; Binomial, Gaussian, or user-supplied. See publication at Nucl. Instrum.; Meth. A551:493-503,2005. **`TLimit`** class computes 95% C.L. limits using the Likelihood ratio; semi-Bayesian method ( <CLs> method; see e.g. T. Junk, NIM A434, p.; 435-443, 1999). It takes signal background and data histograms wrapped; in a `TLimitDataSource` as input, and runs a set of Monte Carlo; experiments in order to compute the limits. If needed, inputs are; fluctuated according to systematic. ### Specialized Classes for Fitting. **`TFractionFitter`** fits Monte Carlo (MC) fractions to data histogram; (a la HMCMLL, R. Barlow and C. Beeston, Comp. Phys. Comm. 77 (1993); 219-228). It takes into account both data and Monte Carlo statistical; uncertainties through a likelihood fit using Poisson statistics.; However, the template (MC) predictions are also varied within; statistics, leading to additional contributions to the overall; likelihood. This leads to many more fit parameters (one per bin per; template), but the minimization with respect to these additional; parameters is done analytically rather than introducing them as formal; fit parameters. Some special care needs to be taken in the case of bins; with zero content. **`TMultiDimFit`** implements multi-dimensional function; parametrization for multi-dimensional data by fitting them",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:117797,wrap,wrapped,117797,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['wrap'],['wrapped']
Integrability,"for June 27, 2011. Bindings - packages related to the interplay with other programming languages (Python, Ruby); Cint - the C++ interpreter; Core - the basic ROOT functionality; Geometry - building, representing and drawing geometrical objects; 2D Graphics - ROOT's two dimensional graphics interface; 3D Graphics - ROOT's three dimensional graphics interface; Graphical User Interface - from basic GUI elements to ROOT's own, complete dialogs; Histograming - counting values, spectra, and drawing them; HTML - the documentation generator; Input/Ouput - storing and reading data; Mathemathics - everything one can use to calculate: minimizers, matrixes, FFT, and much more; Miscellaneous - things that didn't make it into the other groups: table ; Monte Carlo - monte carlo and physics simulation interfaces; Networking - network-related parts, e.g. protocols and authentication interfaces; PROOF - parallel ROOT facility; RooFit - a fitting library; RooStats - a collection of statistical tools ; SQL - database interfaces; TMVA - multivariate analysis tools; Trees - ROOT's unique container class and related utilities; Tutorials - ROOT's Tutorials. Binaries for all supported platforms are available at:. https://root.cern/releases/release-52800/. For more information, see:. http://root.cern.ch; The following people have contributed to this new version:; Bertrand Bellenot, CERN/SFT,; Dario Berzano, INFN and University of Torino, ALICE, Proof,; Rene Brun, CERN/SFT,; Philippe Canal, FNAL,; Olivier Couet, CERN/SFT,; Kyle Cranmer, NYU, RooStats,; Gerri Ganis, CERN/SFT,; Andrei Gheata, CERN/Alice,; Wim Lavrijsen, LBNL, PyRoot,; Sergei Linev, GSI,; Lorenzo Moneta, CERN/SFT,; Axel Naumann, CERN/SFT,; Eddy Offermann, Renaissance, ; Bartolomeu Rabacal, CERN/ADL, Math, ; Fons Rademakers, CERN/SFT,; Paul Russo, FNAL, ; Joerg Stelzer, DESY/Atlas, TMVA, ; Alja Tadel, UCSD/CMS, Eve, ; Matevz Tadel, UCSD/CMS, Eve, ; Eckhard von Toerne, University Bonn, ATLAS, TMVA, ; Wouter Verkerke, NIKHEF/Atlas,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/doc/v530/index.html:1295,protocol,protocols,1295,doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/doc/v530/index.html,6,"['interface', 'protocol']","['interfaces', 'protocols']"
Integrability,"for ``llvm-tblgen`` commands in the output. Instruction Relation Mapping; ----------------------------. This TableGen feature is used to relate instructions with each other. It is; particularly useful when you have multiple instruction formats and need to; switch between them after instruction selection. This entire feature is driven; by relation models which can be defined in ``XXXInstrInfo.td`` files; according to the target-specific instruction set. Relation models are defined; using ``InstrMapping`` class as a base. TableGen parses all the models; and generates instruction relation maps using the specified information.; Relation maps are emitted as tables in the ``XXXGenInstrInfo.inc`` file; along with the functions to query them. For the detailed information on how to; use this feature, please refer to :doc:`HowToUseInstrMappings`. Implement a subclass of ``TargetInstrInfo``; -------------------------------------------. The final step is to hand code portions of ``XXXInstrInfo``, which implements; the interface described in ``TargetInstrInfo.h`` (see :ref:`TargetInstrInfo`).; These functions return ``0`` or a Boolean or they assert, unless overridden.; Here's a list of functions that are overridden for the SPARC implementation in; ``SparcInstrInfo.cpp``:. * ``isLoadFromStackSlot`` --- If the specified machine instruction is a direct; load from a stack slot, return the register number of the destination and the; ``FrameIndex`` of the stack slot. * ``isStoreToStackSlot`` --- If the specified machine instruction is a direct; store to a stack slot, return the register number of the destination and the; ``FrameIndex`` of the stack slot. * ``copyPhysReg`` --- Copy values between a pair of physical registers. * ``storeRegToStackSlot`` --- Store a register value to a stack slot. * ``loadRegFromStackSlot`` --- Load a register value from a stack slot. * ``storeRegToAddr`` --- Store a register value to memory. * ``loadRegFromAddr`` --- Load a register value from memory. * ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:45764,interface,interface,45764,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['interface'],['interface']
Integrability,"for constructor failure; Not resolved. 2624; C++23; Array delete expression with no array cookie; Unknown. 2625; C++23; Deletion of pointer to out-of-lifetime object; Unknown. 2626; C++23; Rephrase ones' complement using base-2 representation; Unknown. 2627; C++23; Bit-fields and narrowing conversions; Unknown. 2628; DR; Implicit deduction guides should propagate constraints; No. 2629; C++23; Variables of floating-point type as switch conditions; Unknown. 2630; C++23; Syntactic specification of class completeness; Unknown. 2631; C++23; Immediate function evaluations in default arguments; Clang 16. 2632; review; 'user-declared' is not defined; Not resolved. 2633; open; typeid of constexpr-unknown dynamic type; Not resolved. 2634; tentatively ready; Avoid circularity in specification of scope for friend class declarations; Unknown. 2635; C++23; Constrained structured bindings; Clang 16. 2636; C++23; Update Annex E based on Unicode 15.0 UAX #31; N/A. 2637; tentatively ready; Injected-class-name as a simple-template-id; Unknown. 2638; tentatively ready; Improve the example for initializing by initializer list; Unknown. 2639; C++23; new-lines after phase 1; Unknown. 2640; C++23; Allow more characters in an n-char sequence; Clang 16. 2641; C++23; Redundant specification of value category of literals; Unknown. 2642; C++23; Inconsistent use of T and C; N/A. 2643; C++23; Completing a pointer to array of unknown bound; Unknown. 2644; C++23; Incorrect comment in example; Clang 8. 2645; C++23; Unused term ""default argument promotions""; Unknown. 2646; C++23; Defaulted special member functions; Unknown. 2647; C++23; Fix for ""needed for constant evaluation""; Unknown. 2648; C++23; Correspondence of surrogate call function and conversion function; Unknown. 2649; C++23; Incorrect note about implicit conversion sequence; Unknown. 2650; C++23; Incorrect example for ill-formed non-type template arguments; Clang 17. 2651; C++23; Conversion function templates and ""noexcept""; Unknown. 2652;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:181772,Inject,Injected-class-name,181772,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Inject'],['Injected-class-name']
Integrability,"for details:. #. `Maintenance of metadata`_. .. _Reporting:. Reporting bugs; ==============. See :doc:`HowToSubmitABug` on further details on how to submit good bug reports. You can apply `labels <https://docs.github.com/en/issues/using-labels-and-milestones-to-track-work/managing-labels>`_; to the bug to provide extra information to make the bug easier to discover, such; as a label for the part of the project the bug pertains to. .. _Triaging:. Triaging bugs; =============. Open bugs that have not been marked with the ``confirmed`` label are bugs that; still need to be triaged. When triage is complete, the ``confirmed`` label; should be added along with any other labels that help to classify the report,; unless the issue is being :ref:`closed<Closing>`. The goal of triaging a bug is to make sure a newly reported bug ends up in a; good, actionable state. Try to answer the following questions while triaging:. * Is the reported behavior actually wrong?. * E.g. does a miscompile example depend on undefined behavior?. * Can you reproduce the bug from the details in the report?. * If not, is there a reasonable explanation why it cannot be reproduced?. * Is it related to an already reported bug?. * Are the following fields filled in correctly?. * Title; * Description; * Labels. * When able to do so, please add the appropriate labels to classify the bug,; such as the tool (``clang``, ``clang-format``, ``clang-tidy``, etc) or; component (``backend:<name>``, ``compiler-rt:<name>``, ``clang:<name>``, etc). * If the issue is with a particular revision of the C or C++ standard, please; add the appropriate language standard label (``c++20``, ``c99``, etc). * Please don't use both a general and a specific label. For example, bugs; labeled ``c++17`` shouldn't also have ``c++``, and bugs labeled; ``clang:codegen`` shouldn't also have ``clang``. * Add the ``good first issue`` label if you think this would be a good bug to; be fixed by someone new to LLVM. This label feeds into `the l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BugLifeCycle.rst:2049,depend,depend,2049,interpreter/llvm-project/llvm/docs/BugLifeCycle.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BugLifeCycle.rst,1,['depend'],['depend']
Integrability,"for the different interpolation types, but there is a simple script to modify it. . results/example_combined_GaussExample_model.root . Near term goals for HistFactory. Utilities for dealing with Monte Carlo statistical uncertainty in the template histograms; Support for N-D histograms; A new style of histogram variations without a constraint term attached (for shapes determined from control samples); XML steering for interpolation types. RooStats; General Improvements. This release brings several speed improvements to the RooStats tools and improved stability and performance with PROOF. This comes mainly through changes to the ToyMCSampler. In addition the HypoTestInverter tool has been rewritten, leading to some changes in the HypoTestResult. Finally, a new hypothesis test new called FrequentistCalculator was written, which plays the same role as the HybridCalculator but eliminates nuisance parameters in a frequentist way. ToyMCSampler. The primary interface for this class is to return a SamplingDistribution of a given TestStatistic.; The ToyMCSampler had a number of internal changes for improved performance with PROOF. These should be transparent. In addition, a new method was added RooAbsData* GenerateToyData(RooArgSet& paramPoint) that gives public access to the generation of toy data with all the same options for the treatment of nuisance parameters, binned or unbinned data, treatment of the global observables, importance sampling, etc. This is new method particularly useful for producing the expected limit bands where one needs to generate background-only pseudo-experiments in the same way that was used for the primary limit calculation. HypoTestResult. In the process of writing the new HypoTestInverter the conventions for p-values, CLb, CLs+b, and CLs were revisited. The situation is complicated by the fact that when performing a hypothesis test for discovery the null is background-only, but when performing an inverted hypothesis test the null is a signal+back",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v530/index.html:1880,interface,interface,1880,roofit/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v530/index.html,2,['interface'],['interface']
Integrability,"for weakly-linked C functions, ``+class`` for Objective-C classes,; and ``-respondsToSelector:`` or ``+instancesRespondToSelector:`` for; Objective-C methods. If such a check was missed, the program would compile; fine, run fine on newer systems, but crash on older systems. As of LLVM 5.0, ``-Wunguarded-availability`` uses the `availability attributes; <https://clang.llvm.org/docs/AttributeReference.html#availability>`_ together; with the new ``@available()`` keyword to assist with this issue.; When a method that's introduced in the OS newer than the target OS is called, a; -Wunguarded-availability warning is emitted if that call is not guarded:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; // If fancyNewMethod was added in e.g. macOS 10.12, but the code is; // built with -mmacosx-version-min=10.11, then this unconditional call; // will emit a -Wunguarded-availability warning:; [var fancyNewMethod];; }. To fix the warning and to avoid the crash on macOS 10.11, wrap it in; ``if(@available())``:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; if (@available(macOS 10.12, *)) {; [var fancyNewMethod];; } else {; // Put fallback behavior for old macOS versions (and for non-mac; // platforms) here.; }; }. The ``*`` is required and means that platforms not explicitly listed will take; the true branch, and the compiler will emit ``-Wunguarded-availability``; warnings for unlisted platforms based on those platform's deployment target.; More than one platform can be listed in ``@available()``:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; if (@available(macOS 10.12, iOS 10, *)) {; [var fancyNewMethod];; }; }. If the caller of ``my_fun()`` already checks that ``my_fun()`` is only called; on 10.12, then add an `availability attribute; <https://clang.llvm.org/docs/AttributeReference.html#availability>`_ to it,; which will also suppress the warning and require that calls to my_fun() are; checked:. .. code-block:: objc. API_AVAILABLE(macos(10.12)) void m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:81912,wrap,wrap,81912,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['wrap'],['wrap']
Integrability,"formation, the compiler inserts bounds checks on every; pointer dereference, ensuring that the program does not access memory outside; the specified bounds. The compiler requires programmers to provide enough bounds; information so that the accesses can be checked at either run time or compile; time — and it rejects code if it cannot. The most important contribution of ``-fbounds-safety`` is how it reduces the; programmer's annotation burden by reconciling bounds annotations at ABI; boundaries with the use of implicit wide pointers (a.k.a. ""fat"" pointers) that; carry bounds information on local variables without the need for annotations. We; designed this model so that it preserves ABI compatibility with C while; minimizing adoption effort. The ``-fbounds-safety`` extension has been adopted on millions of lines of; production C code and proven to work in a consumer operating system setting. The; extension was designed to enable incremental adoption — a key requirement in; real-world settings where modifying an entire project and its dependencies all; at once is often not possible. It also addresses multiple of other practical; challenges that have made existing approaches to safer C dialects difficult to; adopt, offering these properties that make it widely adoptable in practice:. * It is designed to preserve the Application Binary Interface (ABI).; * It interoperates well with plain C code.; * It can be adopted partially and incrementally while still providing safety; benefits.; * It is a conforming extension to C.; * Consequently, source code that adopts the extension can continue to be; compiled by toolchains that do not support the extension (CAVEAT: this still; requires inclusion of a header file macro-defining bounds annotations to; empty).; * It has a relatively low adoption cost. This document discusses the key designs of ``-fbounds-safety``. The document is; subject to be actively updated with a more detailed specification. The; implementation plan can be f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:1880,depend,dependencies,1880,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['depend'],['dependencies']
Integrability,"forward. One additional option is ``std::vector<bool>``: we discourage its use for two; reasons 1) the implementation in many common compilers (e.g. commonly; available versions of GCC) is extremely inefficient and 2) the C++ standards; committee is likely to deprecate this container and/or change it significantly; somehow. In any case, please don't use it. .. _dss_bitvector:. BitVector; ^^^^^^^^^. The BitVector container provides a dynamic size set of bits for manipulation.; It supports individual bit setting/testing, as well as set operations. The set; operations take time O(size of bitvector), but operations are performed one word; at a time, instead of one bit at a time. This makes the BitVector very fast for; set operations compared to other containers. Use the BitVector when you expect; the number of set bits to be high (i.e. a dense set). .. _dss_smallbitvector:. SmallBitVector; ^^^^^^^^^^^^^^. The SmallBitVector container provides the same interface as BitVector, but it is; optimized for the case where only a small number of bits, less than 25 or so,; are needed. It also transparently supports larger bit counts, but slightly less; efficiently than a plain BitVector, so SmallBitVector should only be used when; larger counts are rare. At this time, SmallBitVector does not support set operations (and, or, xor), and; its operator[] does not provide an assignable lvalue. .. _dss_sparsebitvector:. SparseBitVector; ^^^^^^^^^^^^^^^. The SparseBitVector container is much like BitVector, with one major difference:; Only the bits that are set, are stored. This makes the SparseBitVector much; more space efficient than BitVector when the set is sparse, as well as making; set operations O(number of set bits) instead of O(size of universe). The; downside to the SparseBitVector is that setting and testing of random bits is; O(N), and on large SparseBitVectors, this can be slower than BitVector. In our; implementation, setting or testing bits in sorted order (either forwards ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:97489,interface,interface,97489,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['interface'],['interface']
Integrability,"four operands of the `X86 addressing mode`_, which are; currently matched with custom C++ code). In addition, we'll extend fragments; so that a fragment can match multiple different patterns. * We don't automatically infer flags like ``isStore``/``isLoad`` yet. * We don't automatically generate the set of supported registers and operations; for the `Legalizer`_ yet. * We don't have a way of tying in custom legalized nodes yet. Despite these limitations, the instruction selector generator is still quite; useful for most of the binary and logical operations in typical instruction; sets. If you run into any problems or can't figure out how to do something,; please let Chris know!. .. _Scheduling and Formation:; .. _SelectionDAG Scheduling and Formation:. SelectionDAG Scheduling and Formation Phase; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The scheduling phase takes the DAG of target instructions from the selection; phase and assigns an order. The scheduler can pick an order depending on; various constraints of the machines (i.e. order for minimal register pressure or; try to cover instruction latencies). Once an order is established, the DAG is; converted to a list of :raw-html:`<tt>` `MachineInstr`_\s :raw-html:`</tt>` and; the SelectionDAG is destroyed. Note that this phase is logically separate from the instruction selection phase,; but is tied to it closely in the code because it operates on SelectionDAGs. Future directions for the SelectionDAG; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. #. Optional function-at-a-time selection. #. Auto-generate entire selector from ``.td`` file. .. _SSA-based Machine Code Optimizations:. SSA-based Machine Code Optimizations; ------------------------------------. To Be Written. Live Intervals; --------------. Live Intervals are the ranges (intervals) where a variable is *live*. They are; used by some `register allocator`_ passes to determine if two or more virtual; registers which require the same physical register are live at the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:53689,depend,depending,53689,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['depend'],['depending']
Integrability,"fp-math. Enable setting the FP exceptions build attribute not to use exceptions. .. option:: --enable-unsafe-fp-math. Enable optimizations that make unsafe assumptions about IEEE math (e.g. that; addition is associative) or may not work for all input ranges. These; optimizations allow the code generator to make use of some instructions which; would otherwise not be usable (such as ``fsin`` on X86). .. option:: --stats. Print statistics recorded by code-generation passes. .. option:: --time-passes. Record the amount of time needed for each pass and print a report to standard; error. .. option:: --load=<dso_path>. Dynamically load ``dso_path`` (a path to a dynamically shared object) that; implements an LLVM target. This will permit the target name to be used with; the :option:`-march` option so that code can be generated for that target. .. option:: -meabi=[default|gnu|4|5]. Specify which EABI version should conform to. Valid EABI versions are *gnu*,; *4* and *5*. Default value (*default*) depends on the triple. .. option:: -stack-size-section. Emit the .stack_sizes section which contains stack size metadata. The section; contains an array of pairs of function symbol values (pointer size) and stack; sizes (unsigned LEB128). The stack size values only include the space allocated; in the function prologue. Functions with dynamic stack allocations are not; included. .. option:: -remarks-section. Emit the __remarks (MachO) section which contains metadata about remark; diagnostics. Tuning/Configuration Options; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. option:: --print-after-isel. Print generated machine code after instruction selection (useful for debugging). .. option:: --regalloc=<allocator>. Specify the register allocator to use.; Valid register allocators are:. *basic*. Basic register allocator. *fast*. Fast register allocator. It is the default for unoptimized code. *greedy*. Greedy register allocator. It is the default for optimized code. *pbqp*. Register allocator based on '",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llc.rst:4718,depend,depends,4718,interpreter/llvm-project/llvm/docs/CommandGuide/llc.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llc.rst,1,['depend'],['depends']
Integrability,"frame - after the |; | | arrangement of all frames the available ""free"" height |; | | space is shared between the frames having this hint |; +------------------+---------------------------------------------------------+; | `kLHintsNormal` | = `kLHintsLeft | kLHintsTop` - default hints |; +------------------+---------------------------------------------------------+. Layout policy:. Child frames never modify their container frame. The container frame can; (or cannot) adapt its size in the layout process. It can show all or a; part of its frames. Every **`TGFrame`** object has a default minimum; size (1, 1) assured by **`TGWindow`**. ## Event Processing: Signals and Slots. Event handling covers the interaction between different objects and; between the user and the objects in an application. There are two; general ways for the user to interact with an application: the keyboard; and the mouse. The Graphical User Interface is as a bridge between the; user and the program - it provides methods to detect the user actions; and instruments that do something as a reaction of these actions. The; user communicates with an application through the window system. The; window system reports interaction events to the application. The; application in turn forwards them to the currently active window. The; objects/widgets receive the events and react to them according to the; application functionality. ![](pictures/0200020B.jpg). The signals/slot communication mechanism is an advanced object; communication concept; it largely replaces the concept of callback; functions to handle actions in GUI's. Signals and slots are just like; any object-oriented methods implemented in C++. The objects are the; instances of classes that don't know anything about each other. They; interact and allow method calls of other object's methods. The idea is; simple: any object can send out (emit) a signal in certain situations; saying that something happened. This is all it does to communicate and; it does",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:40191,bridg,bridge,40191,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['bridg'],['bridge']
Integrability,"from `TLine`. The; constructors of lines and arrows always contain the coordinates of the; endpoints. Arrows also foresee parameters to [specify; their](https://root.cern.ch/doc/master/classTArrow.html) shapes. Do not; underestimate the role of lines and arrows in your plots. Since each; plot should contain a message, it is convenient to stress it with; additional graphics primitives. ### Text. Also text plays a fundamental role in making the plots self-explanatory.; A possibility to add text in your plot is provided by the `TLatex`; class. The objects of this class are constructed with the coordinates of; the bottom-left corner of the text and a string which contains the text; itself. The real twist is that ordinary; [Latex mathematical symbols](https://root.cern.ch/doc/master/classTLatex.html#L5); are automatically interpreted, you just need to replace the ""\\"" by a ""\#"". If; [""\\"" is used as control character](https://root.cern.ch/doc/master/classTLatex.html#L14); , then the; [TMathText interface](https://root.cern.ch/doc/master/classTMathText.html); is invoked. It provides the plain TeX syntax and allow to access character's; set like Russian and Japanese. ## Interpretation and Compilation. As you observed, up to now we heavily exploited the capabilities of ROOT; for interpreting our code, more than compiling and then executing. This; is sufficient for a wide range of applications, but you might have; already asked yourself ""how can this code be compiled ?"". There are two; answers. ### Compile a Macro with ACLiC. ACLiC will create for you a compiled dynamic library for your macro,; without any effort from your side, except the insertion of the; appropriate header files in lines *5--11*. In this example, they are; already included. To generate an object library from the macro code, from inside the; interpreter type (please note the ""+""):. ``` {.cpp}; root [1] .L macro1.C+; ```. Once this operation is accomplished, the macro symbols will be available; in memory an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:8783,interface,interface,8783,documentation/primer/your_first_ROOT_macro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md,1,['interface'],['interface']
Integrability,"from the function gradient interface (ROOT::Math::IGradFunction and ROOT::Math::IMultiGradFunction). They define only the parameter gradient which is needed for fitting and not the coordinate gradient. A derived class, like ROOT::Math::Polynomial, implementing both functionality (coordinate and parameter gradient) inherits then from both interfaces.; . More detailed description of the current MathCore release can be found at this location. MathMore; This new release contains:. Modify and rename the class ROOT::Math::RootFinder to ROOT::Math::GSLRootFinder to distinguish from the main interface class which has been put in the Mathcore library and it can create the GSLRootFinder using the plug-in manager. Furthermore, the class ROOT::Math::GSLRootFinder is not anymore a template class on the algorithm. They type of root-finder algorithm can now be selected via an enumeration; Fixed a bug in the ROOT::Math::GSLNLSMultiFi class.; Changes also in the class for the new enumeration names (all names start with k, like kADAPTIVE for the integration types).; . More detailed description of the current MathMore release can be found at this location. GenVector; The new physics vector classes have been moved out from the MathCore library in a new library, libGenVector. The library contains as well the CINT dictionary including main instantiations for the template classes. For this release the instantiation of some extra methods, in particular of the class ROOT::Math::TRansform3D have been added in the dictionary library.; Due to a CINT limitation, the dictionary for explicit template constructors of the Rotation classes, taking as input any other type; of rotation are missing. Therefore code like the following one will now work in CINT (or Python):. ROOT::Math::Rotation3D r;; ROOT::Math::EulerAngles eulerRot(r);. A possible solution is to use the operator=:. ROOT::Math::EulerAngles eulerRot; eulerRot = r;. In addition the setter methods for the 2D,3D and 4D vector classes have bee",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:10880,integrat,integration,10880,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,2,['integrat'],['integration']
Integrability,"frounding-math"", ""{dynamic, tonearest, downward, upward, towardzero}""; ""ffp-contract"", ""{on, off, fast, fast-honor-pragmas}""; ""fdenormal-fp-math"", ""{IEEE, PreserveSign, PositiveZero}""; ""fdenormal-fp-math-fp32"", ""{IEEE, PreserveSign, PositiveZero}""; ""fmath-errno"", ""{on, off}""; ""fhonor-nans"", ""{on, off}""; ""fhonor-infinities"", ""{on, off}""; ""fsigned-zeros"", ""{on, off}""; ""freciprocal-math"", ""{on, off}""; ""allow_approximate_fns"", ""{on, off}""; ""fassociative-math"", ""{on, off}"". This table describes the option settings that correspond to the three; floating point semantic models: precise (the default), strict, and fast. .. csv-table:: Floating Point Models; :header: ""Mode"", ""Precise"", ""Strict"", ""Fast""; :widths: 25, 15, 15, 15. ""except_behavior"", ""ignore"", ""strict"", ""ignore""; ""fenv_access"", ""off"", ""on"", ""off""; ""rounding_mode"", ""tonearest"", ""dynamic"", ""tonearest""; ""contract"", ""on"", ""off"", ""fast""; ""denormal_fp_math"", ""IEEE"", ""IEEE"", ""IEEE""; ""denormal_fp32_math"", ""IEEE"",""IEEE"", ""IEEE""; ""support_math_errno"", ""on"", ""on"", ""off""; ""no_honor_nans"", ""off"", ""off"", ""on""; ""no_honor_infinities"", ""off"", ""off"", ""on""; ""no_signed_zeros"", ""off"", ""off"", ""on""; ""allow_reciprocal"", ""off"", ""off"", ""on""; ""allow_approximate_fns"", ""off"", ""off"", ""on""; ""allow_reassociation"", ""off"", ""off"", ""on"". .. option:: -ffast-math. Enable fast-math mode. This option lets the; compiler make aggressive, potentially-lossy assumptions about; floating-point math. These include:. * Floating-point math obeys regular algebraic rules for real numbers (e.g.; ``+`` and ``*`` are associative, ``x/y == x * (1/y)``, and; ``(a + b) * c == a * c + b * c``),; * Operands to floating-point operations are not equal to ``NaN`` and; ``Inf``, and; * ``+0`` and ``-0`` are interchangeable. ``-ffast-math`` also defines the ``__FAST_MATH__`` preprocessor; macro. Some math libraries recognize this macro and change their behavior.; With the exception of ``-ffp-contract=fast``, using any of the options; below to disable any of the individual optimi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:51362,contract,contract,51362,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['contract'],['contract']
Integrability,"full documentation on the CMake if command go; `here <https://cmake.org/cmake/help/v3.4/command/if.html>`_. That resource is; far more complete. In general CMake if blocks work the way you'd expect:. .. code-block:: cmake. if(<condition>); message(""do stuff""); elseif(<condition>); message(""do other stuff""); else(); message(""do other other stuff""); endif(). The single most important thing to know about CMake's if blocks coming from a C; background is that they do not have their own scope. Variables set inside; conditional blocks persist after the ``endif()``. Loops; -----. The most common form of the CMake ``foreach`` block is:. .. code-block:: cmake. foreach(var ...); message(""do stuff""); endforeach(). The variable argument portion of the ``foreach`` block can contain dereferenced; lists, values to iterate, or a mix of both:. .. code-block:: cmake. foreach(var foo bar baz); message(${var}); endforeach(); # prints:; # foo; # bar; # baz. set(my_list 1 2 3); foreach(var ${my_list}); message(${var}); endforeach(); # prints:; # 1; # 2; # 3. foreach(var ${my_list} out_of_bounds); message(${var}); endforeach(); # prints:; # 1; # 2; # 3; # out_of_bounds. There is also a more modern CMake foreach syntax. The code below is equivalent; to the code above:. .. code-block:: cmake. foreach(var IN ITEMS foo bar baz); message(${var}); endforeach(); # prints:; # foo; # bar; # baz. set(my_list 1 2 3); foreach(var IN LISTS my_list); message(${var}); endforeach(); # prints:; # 1; # 2; # 3. foreach(var IN LISTS my_list ITEMS out_of_bounds); message(${var}); endforeach(); # prints:; # 1; # 2; # 3; # out_of_bounds. Similar to the conditional statements, these generally behave how you would; expect, and they do not have their own scope. CMake also supports ``while`` loops, although they are not widely used in LLVM. Modules, Functions and Macros; =============================. Modules; -------. Modules are CMake's vehicle for enabling code reuse. CMake modules are just; CMake script files. T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst:8626,message,message,8626,interpreter/llvm-project/llvm/docs/CMakePrimer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst,1,['message'],['message']
Integrability,"function also needs to be added when; `analyticalIntegral()` is found in your class. Depending on the code, you can; call one or more integral functions using the `code` parameter. Our RooFoo; example above only contains one integral function (`integralFoo()`). Similar to `doFoo()`, comment out `integralFoo()' in the original file and; move it to 'MathFuncs.h'. As with `doFoo()`. add the relevant inputs (a,b) as parameters, instead of; just class members. ``` {.cpp}; ///// The MathFuncs.h file; int integralFoo(int a, int b) { return /* whatever */;}; ```. > Directory path: [hist/hist/src/MathFuncs.h](https://github.com/root-project/root/blob/master/hist/hist/src/MathFuncs.h). Next, in the original RooFoo class, update all references to the; `integralFoo()` function with its new fully qualified path (; `EvaluateFunc::integralFoo`) and include the input parameters as well (; `EvaluateFunc::integralFoo(a, b)`). ``` {.cpp}; double analyticalIntegral(Int_t code, const char* rangeName) override {; // Select the right paths for integration using codes or whatever.; return EvaluateFunc::integralFoo(a, b);; }; ```. Next, in the `RooAbsReal::buildCallToAnalyticIntegral()` function, simply; return the output using the `buildCall()` function. ``` {.cpp}; std::string; buildCallToAnalyticIntegral(Int_t code, const char *rangeName, RooFit::Detail::RooFit::Detail::CodeSquashContext &ctx) const override {; return ctx.buildCall(""EvaluateFunc::integralFoo"", a, b);; }; ```. \note The implementation of the `RooAbsReal::buildCallToAnalyticIntegral()`; function is quite similar to the `translate()` function, except that in; `translate()`, you have to add to the result (using `addResult()`), while for; `buildCallToAnalyticIntegral()`, you only have to return the string (using; `buildCall()`). **Consolidated Code changes in RooFoo example**. Final RooFoo code:. ``` {.cpp}; class RooFoo : public RooAbsReal {; int a;; int b;; // int doFoo() { return a* b + a + b; }; // int integralFoo() { retu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:23579,integrat,integration,23579,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['integrat'],['integration']
Integrability,"function with; both ``cf_audited_transfer`` and ``cf_unknown_transfer``. A pragma is provided to facilitate the mass annotation of interfaces:. .. code-block:: objc. #pragma clang arc_cf_code_audited begin; ...; #pragma clang arc_cf_code_audited end. All C functions declared within the extent of this pragma are treated as if; annotated with the ``cf_audited_transfer`` attribute unless they otherwise have; the ``cf_unknown_transfer`` attribute. The pragma is accepted in all language; modes. A program is ill-formed if it attempts to change files, whether by; including a file or ending the current file, within the extent of this pragma. It is possible to test for all the features in this section with; ``__has_feature(arc_cf_code_audited)``. .. admonition:: Rationale. A significant inconvenience in ARC programming is the necessity of; interacting with APIs based around C retainable pointers. These features are; designed to make it relatively easy for API authors to quickly review and; annotate their interfaces, in turn improving the fidelity of tools such as; the static analyzer and ARC. The single-file restriction on the pragma is; designed to eliminate the risk of accidentally annotating some other header's; interfaces. .. _arc.runtime:. Runtime support; ===============. This section describes the interaction between the ARC runtime and the code; generated by the ARC compiler. This is not part of the ARC language; specification; instead, it is effectively a language-specific ABI supplement,; akin to the ""Itanium"" generic ABI for C++. Ownership qualification does not alter the storage requirements for objects,; except that it is undefined behavior if a ``__weak`` object is inadequately; aligned for an object of type ``id``. The other qualifiers may be used on; explicitly under-aligned memory. The runtime tracks ``__weak`` objects which holds non-null values. It is; undefined behavior to direct modify a ``__weak`` object which is being tracked; by the runtime except thr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:104974,interface,interfaces,104974,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['interface'],['interfaces']
Integrability,"functionality has been added inheriting from RooAbsReal.; These are RooAbsCachedReal,RooAbsSelfCachedReal and RooCachedReal. A newly; added class RooHistFunc presents these shapes and is capable of handling negative entries. New PDF error handling structure. New infrastructure has been put into place to propagate and process p.d.f evaluation errors during fitting.; Previously evaluation errors were marked with a zero p.d.f value and propagated as a special condition; in RooAddPdf, RooProdPdf etc to result in a zero top-level p.d.f value that was caught by the RooFit minuit; interface as a special condition. Summary information on the value of the parameters and the observables; was printed for the first 10 occurrences of such conditions. . Now, each p.d.f component that generates an error; in its evaluation logs the error into a separate facility during fitting and the RooFit minuit interface; polls this error logging facility for problems. This allows much more detailed and accurate warning messages; during the minimization phase. The level of verbosity of this new error facility can be controlled with; a new . PrintEvalErrors(Int_t code). argument to fitTo(). . With code of -1, no errors are printed at all.; With a; code of zero, one line is printed for each p.d.f component with problems summarizing the number of times; problems occurred during the likelihood evaluation. . [#0] WARNING:Minization -- RooFitGlue: Minimized function has error status. ; Returning maximum FCN so far (-1e+30) to force MIGRAD to back out of this region. Error log follows; Parameter values: m=-7.397; RooGaussian::gx[ x=x mean=m sigma=sx ] has 3 errors. A code greater than zero will generate even more detail and; print the details of each evaluation error as provided by the p.d.f (zero value, not-a-number, normalization zero etc..); and show the observable values at which this error occurred. At most N detailed messages per p.d.f component; are shown where N is the integral value of the 'co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html:15762,message,messages,15762,roofit/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html,2,['message'],['messages']
Integrability,"fuzzer is good for stressing the surface layers of a; program, and is good at testing things like lexers, parsers, or binary; protocols. Some of the in-tree fuzzers that use this type of mutator are `clang-fuzzer`_,; `clang-format-fuzzer`_, `llvm-as-fuzzer`_, `llvm-dwarfdump-fuzzer`_,; `llvm-mc-assemble-fuzzer`_, and `llvm-mc-disassemble-fuzzer`_. .. _fuzzing-llvm-protobuf:. Structured Fuzzing using ``libprotobuf-mutator``; ------------------------------------------------. We can use libprotobuf-mutator_ in order to perform structured fuzzing and; stress deeper layers of programs. This works by defining a protobuf class that; translates arbitrary data into structurally interesting input. Specifically, we; use this to work with a subset of the C++ language and perform mutations that; produce valid C++ programs in order to exercise parts of clang that are more; interesting than parser error handling. To build this kind of fuzzer you need `protobuf`_ and its dependencies; installed, and you need to specify some extra flags when configuring the build; with :doc:`CMake <CMake>`. For example, `clang-proto-fuzzer`_ can be enabled by; adding ``-DCLANG_ENABLE_PROTO_FUZZER=ON`` to the flags described in; :ref:`building-fuzzers`. The only in-tree fuzzer that uses ``libprotobuf-mutator`` today is; `clang-proto-fuzzer`_. .. _libprotobuf-mutator: https://github.com/google/libprotobuf-mutator; .. _protobuf: https://github.com/google/protobuf. .. _fuzzing-llvm-ir:. Structured Fuzzing of LLVM IR; -----------------------------. We also use a more direct form of structured fuzzing for fuzzers that take; :doc:`LLVM IR <LangRef>` as input. This is achieved through the ``FuzzMutate``; library, which was `discussed at EuroLLVM 2017`_. The ``FuzzMutate`` library is used to structurally fuzz backends in; `llvm-isel-fuzzer`_. .. _discussed at EuroLLVM 2017: https://www.youtube.com/watch?v=UBbQ_s6hNgg. Building and Running; ====================. .. _building-fuzzers:. Configuring LLVM to Build",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FuzzingLLVM.rst:6950,depend,dependencies,6950,interpreter/llvm-project/llvm/docs/FuzzingLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FuzzingLLVM.rst,1,['depend'],['dependencies']
Integrability,"g builtin type which represents it. This mapping helps; to import execution results from the interpreter in a compiled program and vice; versa. The ``Value.h`` header file can be included at runtime and this is why it; has a very low token count and was developed with strict constraints in mind. This also enables the user to receive the computed 'type' back in their code; and then transform the type into something else (e.g., re-cast a double into; a float). Normally, the compiler can handle these conversions transparently,; but in interpreter mode, the compiler cannot see all the 'from' and 'to' types,; so it cannot implicitly do the conversions. So this logic enables providing; these conversions on request. On-request conversions can help improve the user experience, by allowing; conversion to a desired 'to' type, when the 'from' type is unknown or unclear. Significance of this Feature; ----------------------------. The 'Value' object enables wrapping a memory region that comes from the; JIT, and bringing it back to the compiled code (and vice versa).; This is a very useful functionality when:. - connecting an interpreter to the compiled code, or; - connecting an interpreter in another language. For example, this feature helps transport values across boundaries. A notable; example is the cppyy project code makes use of this feature to enable running C++; within Python. It enables transporting values/information between C++; and Python. Note: `cppyy <https://github.com/wlav/cppyy/>`_ is an automatic, run-time,; Python-to-C++ bindings generator, for calling C++ from Python and Python from C++.; It uses LLVM along with a C++ interpreter (e.g., Cling) to enable features like; run-time instantiation of C++ templates, cross-inheritance, callbacks,; auto-casting, transparent use of smart pointers, etc. In a nutshell, this feature enables a new way of developing code, paving the; way for language interoperability and easier interactive programming. Implementation Details;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:10376,wrap,wrapping,10376,interpreter/llvm-project/clang/docs/ClangRepl.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst,1,['wrap'],['wrapping']
Integrability,"g dictionary in Osx 12.7, Xcode 14.2; * [[#14594](https://github.com/root-project/root/issues/14594)] - Provide `file.root` request in THttpServer; * [[#14593](https://github.com/root-project/root/issues/14593)] - Build fails with CLING_DEBUG=1 set; * [[#14586](https://github.com/root-project/root/issues/14586)] - [ROOT-6317] using namespace statement does not provoke autoload; * [[#14576](https://github.com/root-project/root/issues/14576)] - [ROOT-7155] Angular units used in HTML doc of TGLViewer::SetPerspectiveCamera are wrong; * [[#14575](https://github.com/root-project/root/issues/14575)] - [ROOT-10196] boundary check in TH1::AddBinContent is missing; * [[#14569](https://github.com/root-project/root/issues/14569)] - [ROOT-8348] Segmentation Fault in TMVA::DecisionTreeNode::Print; * [[#14562](https://github.com/root-project/root/issues/14562)] - [ROOT-5009] TClass::SetDeclFile: second parameter wrong type; * [[#14553](https://github.com/root-project/root/issues/14553)] - [ROOT-10909] Add TMVA python dependencies to the requirements.txt; * [[#14547](https://github.com/root-project/root/issues/14547)] - [ROOT-9200] With Cocoa backend sometimes need two ProcessEvents to show Canvas; * [[#14528](https://github.com/root-project/root/issues/14528)] - Bug in TFoam::GetIntNorm; * [[#14510](https://github.com/root-project/root/issues/14510)] - Large computation graphs cause serious memory and runtime overhead; * [[#14509](https://github.com/root-project/root/issues/14509)] - ROOT segfaults on riscv64; * [[#14508](https://github.com/root-project/root/issues/14508)] - Using LZMA compression with RNTupleWriter leads to memory corruption; * [[#14499](https://github.com/root-project/root/issues/14499)] - It is not possible to set the Title of the palette for a 3D axis; * [[#14462](https://github.com/root-project/root/issues/14462)] - Parser for I/O customization rule is too strict.; * [[#14458](https://github.com/root-project/root/issues/14458)] - Crash when doing Weighted Like",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:30986,depend,dependencies,30986,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['depend'],['dependencies']
Integrability,"g info,; after each of these steps. Alternatively, ``-debug-only=isel-dump`` shows only; the DAG dumps, but the results can be filtered by function names using; ``-filter-print-funcs=<function names>``. One great way to visualize what is going on here is to take advantage of a few; LLC command line options. The following options pop up a window displaying the; SelectionDAG at specific times (if you only get errors printed to the console; while using this, you probably `need to configure your; system <ProgrammersManual.html#viewing-graphs-while-debugging-code>`_ to add support for it). * ``-view-dag-combine1-dags`` displays the DAG after being built, before the; first optimization pass. * ``-view-legalize-dags`` displays the DAG before Legalization. * ``-view-dag-combine2-dags`` displays the DAG before the second optimization; pass. * ``-view-isel-dags`` displays the DAG before the Select phase. * ``-view-sched-dags`` displays the DAG before Scheduling. The ``-view-sunit-dags`` displays the Scheduler's dependency graph. This graph; is based on the final SelectionDAG, with nodes that must be scheduled together; bundled into a single scheduling-unit node, and with immediate operands and; other nodes that aren't relevant for scheduling omitted. The option ``-filter-view-dags`` allows to select the name of the basic block; that you are interested to visualize and filters all the previous; ``view-*-dags`` options. .. _Build initial DAG:. Initial SelectionDAG Construction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The initial SelectionDAG is na\ :raw-html:`&iuml;`\ vely peephole expanded from; the LLVM input by the ``SelectionDAGBuilder`` class. The intent of this pass; is to expose as much low-level, target-specific details to the SelectionDAG as; possible. This pass is mostly hard-coded (e.g. an LLVM ``add`` turns into an; ``SDNode add`` while a ``getelementptr`` is expanded into the obvious; arithmetic). This pass requires target-specific hooks to lower calls, returns,; vararg",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:39704,depend,dependency,39704,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['depend'],['dependency']
Integrability,"g is best in working with C++. Clang has support of C, objC, objC++ and we are looking forward to having more use-cases and extend our tool in that direction.; Cling has internal commands, which can change its behavior at runtime. Those commands usually start with dot (.):; .I <path> - Adds an include path;; .x <filename> - #include-s the filename; and calls function called filename(); ; .L <libname> - Loads libname or #include-s the libname if libname is file;; .@ - Cancels the multiline input;; .printAST - (DEBUG ONLY) Turns on the printing of the compiler's abstract syntax tree (AST);; .dynamicExtensions - Turns on cling's dynamic extensions. This in turn enables the dynamic lookup and the late resolving of the identifier. With that option cling tries to heal the compile-time failed lookups at runtime;. Details; Command line. The interactive prompt supports an emacs-like command line editor, just like bash terminal, which makes it easy to integrate and use. Cling uses TextInput and doesn't depend on ncurses.; . Autocompletion should be coming soon!; ; #Include Declarations. Cling allows #include-s to be not only before the declarations. The includes could be mixed with other declarations. For example:; [cling]$ #include ""math.h""; [cling]$ sin(1); (double const) 8.414710e-01; [cling]$ #include ""stdio.h""; [cling]$ printf(""%f\n"", sin(1));; 0.841471. More statements could be combined using semicolon (;). This doesn't stay when the command is #include; The following example is invalid:[cling]$ #include ""math.h""; sin(1). The same rules are applicable for the other preprocessor directives (commands starting with # - such as #define); ; Variable Declarations. Cling allows statements to be entered onto the global scope. In order to be compiled and executed by the compiler these statements need to be wrapped into functions, which body contains the statement and afterwards to run the function. The semantics of the statements that declare variables is that variables should b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html:2913,depend,depend,2913,interpreter/cling/www/old/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html,2,['depend'],['depend']
Integrability,"g of expensive components cached by operator p.d.f.s ; RooMCStudy - Add Silence() argument to constructor to request minimal verbosity during running; RooMinuit - Improve contour() method to return RooPlots rather than drawing TGraphs straight on a canvas; RooWorkspace - Add private expensive object cache to workspace; RooBinningCategory - New real-to-category function that maps values of input RooRealVar to categories with labels that correspond to bins of input RooRealVar. See rf405_realtocatfuncs.C for details . RooStats; This is a new package introduced in this version for statistical tools built on top of RooFit. It is a joint effort between the LHC experiments and the ROOT team (see the RooStats Wiki page).; ; This version contains the interfaces for performing the statistical calculations and dealing with the obtained results and concrete classes implementing the statistical methods.; ; All the classes and functions in RooStats are provided in the namespace RooStats.; ; RooStats interfaces. ConfInterval: interface for describing a confidence interval. ; IntervalCalculator: interface for a statistical tool producing confidence intervals (class ConfInterval).; HypoTestResult: interface for representing results of a hypothesis test; HypoTestCalculator: interface for a statistical tool performing an hypothesis test. ; CombinedCalculator: interface for a statistical tool which can produce both hypothesis test results and confidence intervals. ; RooStats concrete classes. The concrete classes describing statistical tools implementing the above interfaces are:; ; ProfileLikelihoodCalculator: it is an implementation of a CombinedCalculator using the profile likelihood ratio as a test statistics. After configuring the calculator, one only needs to ask GetHypoTest() (which will return a HypoTestResult pointer) or GetInterval() (which will return an ConfInterval pointer).; LikelihoodInterval: concrete implementation of a ConfInterval interface. It implements connected N",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html:9815,interface,interfaces,9815,roofit/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html,2,['interface'],['interfaces']
Integrability,"g part; needing manual intervention.; This is broadly true, but realize that that 5% contains the most difficult; cases and is where 20-30% of the effort would have gone in case the bindings; were done fully manually.; It is therefore important to consider what manual tools an automatic binder; offers and to make sure they fit your work style and needs, because you are; going to spend a significant amount of time with them. `LLVM dependency`; -----------------. cppyy depends on `LLVM`_, through Cling.; LLVM is properly internalized, so that it doesn't conflict with other uses;; and in particular it is fine to mix `Numba`_ and cppyy code.; It does mean a download cost of about 20MB for the binary wheel (exact size; differs per platform) on installation, and additional `primarily initial`; memory overheads at run-time.; Whether this is onerous depends strongly not only on the application, but; also on the rest of the software stack. The initial cost of loading cppyy, and thus starting the Cling interpreter,; is about 45MB (platform dependent).; Initial uses of standard (e.g. STL) C++ results in deserialization of the; precompiled header at another eventual total cost of about 25MB (again,; platform dependent).; The actual bindings of course also carry overheads.; As a rule of thumb, you should budget for ~100MB all-in for the overhead; caused by the bindings. Other binders do not have this initial memory overhead, but do of course; occur an overhead per module, class, function, etc.; At scale, however, cppyy has some advantages: all binding is lazy (including; the option of automatic loading), standard classes are never duplicated, and; there is no additional ""per-module"" overhead.; Thus, eventually (depending on the number of classes bound, across how many; modules, what use fraction, etc.), this initial cost is recouped when; compared to other binders.; As a rule of thumb, if about 10% of classes are used, it takes several; hundreds of bound classes before the cppyy-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst:8452,depend,dependent,8452,bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,1,['depend'],['dependent']
Integrability,"g review).; * You will see a ""Stack"" tab in the ""Revision Contents"" section of the review; in the web interface, showing the parent review.; * Repeat these steps until you've uploaded or updated all the patches in; your series. When you push the patches, please remove the ""Depends on"" lines from the; commit messages, since they add noise and duplicate git's implicit ordering. One frequently used workflow for creating a series of patches using patch summaries; is based on git's rebasing. These steps assume that you have a series of commits that; you have not posted for review, but can be adapted to update existing reviews. * git interactive rebase back to the first commit you want to upload for review::. git rebase -i HEAD~<number of commits you have written>. * Mark all commits for editing by changing ""pick"" to ""edit"" in the instructions; git shows.; * Start the rebase (usually by writing and closing the instructions).; * For the first commit:. - Upload the current commit for a review (with ``arc diff`` or the web; interface). - Continue to the next commit with ``git rebase --continue``. * For the rest:. - Add the ""Depends on..."" line using ``git commit --amend``. - Upload for review. - Continue the rebase. * Once the rebase is complete, you've created your patch series. .. _finding-potential-reviewers:. Finding potential reviewers; ---------------------------. Here are a couple of ways to pick the initial reviewer(s):. * Use ``git blame`` and the commit log to find names of people who have; recently modified the same area of code that you are modifying.; * Look in CODE_OWNERS.TXT to see who might be responsible for that area.; * If you've discussed the change on a dev list, the people who participated; might be appropriate reviewers. Even if you think the code owner is the busiest person in the world, it's still; okay to put them as a reviewer. Being the code owner means they have accepted; responsibility for making sure the review happens. Reviewing code with Phab",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:8268,interface,interface,8268,interpreter/llvm-project/llvm/docs/Phabricator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst,1,['interface'],['interface']
Integrability,"g the user to reuse the; macro for many different data sets. Here is an example of an input file.; The nice graphic result shown is produced by the macro below, which; reads two such input files and uses different options to display the; data points. ```; # Measurement of Friday 26 March; # Experiment 2 Physics Lab. 1 6 5; 2 12 5; 3 14 4.7; 4 20 4.5; 5 22 4.2; 6 24 5.1; 7 35 2.9; 8 45 4.1; 9 44 4.8; 10 53 5.43; ```; \newpage; ![](figures/graph_with_expectation.png). ``` {.cpp}; @ROOT_INCLUDE_FILE macros/macro2.C; ```. In addition to the inspection of the plot, you can check the actual; contents of the graph with the `TGraph::Print()` method at any time,; obtaining a printout of the coordinates of data points on screen. The; macro also shows us how to print a coloured band around a graph instead; of error bars, quite useful for example to represent the errors of a; theoretical prediction. ## Polar Graphs ##. With ROOT you can profit from rather advanced plotting routines, like; the ones implemented in the `TPolarGraph`, a class to draw graphs in; polar coordinates. You can see the example macro in the following and the; resulting Figure is [4.2](#f42):. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro3.C; ```. A new element was added on line 4, the size of the canvas: it is; sometimes optically better to show plots in specific canvas sizes. [f42]: figures/polar_graph.png ""f42""; <a name=""f42""></a>. ![The graph of a fan obtained with ROOT.\label{f42}][f42]. ## 2D Graphs ##. Under specific circumstances, it might be useful to plot some quantities; versus two variables, therefore creating a bi-dimensional graph. Of; course ROOT can help you in this task, with the `TGraph2DErrors` class.; The following macro produces a bi-dimensional graph representing a; hypothetical measurement, fits a bi-dimensional function to it and draws; it together with its x and y projections. Some points of the code will; be explained in detail. This time, the graph is populated with dat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/graphs.md:1755,rout,routines,1755,documentation/primer/graphs.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/graphs.md,1,['rout'],['routines']
Integrability,"g() method. The context value is just a void*. All your traits which use the context; and operate on your native data types, need to agree what the context value; actually is. It could be a pointer to an object or struct which your various; traits use to shared context sensitive information. Output; ======. The llvm::yaml::Output class is used to generate a YAML document from your; in-memory data structures, using traits defined on your data types.; To instantiate an Output object you need an llvm::raw_ostream, an optional; context pointer and an optional wrapping column:. .. code-block:: c++. class Output : public IO {; public:; Output(llvm::raw_ostream &, void *context = NULL, int WrapColumn = 70);. Once you have an Output object, you can use the C++ stream operator on it; to write your native data as YAML. One thing to recall is that a YAML file; can contain multiple ""documents"". If the top level data structure you are; streaming as YAML is a mapping, scalar, or sequence, then Output assumes you; are generating one document and wraps the mapping output; with ""``---``"" and trailing ""``...``"". The WrapColumn parameter will cause the flow mappings and sequences to; line-wrap when they go over the supplied column. Pass 0 to completely; suppress the wrapping. .. code-block:: c++. using llvm::yaml::Output;. void dumpMyMapDoc(const MyMapType &info) {; Output yout(llvm::outs());; yout << info;; }. The above could produce output like:. .. code-block:: yaml. ---; name: Tom; hat-size: 7; ... On the other hand, if the top level data structure you are streaming as YAML; has a DocumentListTraits specialization, then Output walks through each element; of your DocumentList and generates a ""---"" before the start of each element; and ends with a ""..."". .. code-block:: c++. using llvm::yaml::Output;. void dumpMyMapDoc(const MyDocListType &docList) {; Output yout(llvm::outs());; yout << docList;; }. The above could produce output like:. .. code-block:: yaml. ---; name: Tom; hat-size",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst:29708,wrap,wraps,29708,interpreter/llvm-project/llvm/docs/YamlIO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst,1,['wrap'],['wraps']
Integrability,"g): Determines whether a; reference of type ``T`` bound to an expression of type ``U`` would bind to a; materialized temporary object. If ``T`` is not a reference type the result; is false. Note this trait will also return false when the initialization of; ``T`` from ``U`` is ill-formed.; Deprecated, use ``__reference_constructs_from_temporary``.; * ``__reference_constructs_from_temporary(T, U)`` (C++); Returns true if a reference ``T`` can be constructed from a temporary of type; a non-cv-qualified ``U``.; * ``__underlying_type`` (C++, GNU, Microsoft). In addition, the following expression traits are supported:. * ``__is_lvalue_expr(e)`` (Embarcadero):; Returns true if ``e`` is an lvalue expression.; Deprecated, use ``__is_lvalue_reference(decltype((e)))`` instead.; * ``__is_rvalue_expr(e)`` (Embarcadero):; Returns true if ``e`` is a prvalue expression.; Deprecated, use ``!__is_reference(decltype((e)))`` instead. There are multiple ways to detect support for a type trait ``__X`` in the; compiler, depending on the oldest version of Clang you wish to support. * From Clang 10 onwards, ``__has_builtin(__X)`` can be used.; * From Clang 6 onwards, ``!__is_identifier(__X)`` can be used.; * From Clang 3 onwards, ``__has_feature(X)`` can be used, but only supports; the following traits:. * ``__has_nothrow_assign``; * ``__has_nothrow_copy``; * ``__has_nothrow_constructor``; * ``__has_trivial_assign``; * ``__has_trivial_copy``; * ``__has_trivial_constructor``; * ``__has_trivial_destructor``; * ``__has_virtual_destructor``; * ``__is_abstract``; * ``__is_base_of``; * ``__is_class``; * ``__is_constructible``; * ``__is_convertible_to``; * ``__is_empty``; * ``__is_enum``; * ``__is_final``; * ``__is_literal``; * ``__is_standard_layout``; * ``__is_pod``; * ``__is_polymorphic``; * ``__is_sealed``; * ``__is_trivial``; * ``__is_trivially_assignable``; * ``__is_trivially_constructible``; * ``__is_trivially_copyable``; * ``__is_union``; * ``__underlying_type``. A simplistic usage example ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:65380,depend,depending,65380,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['depend'],['depending']
Integrability,"g. .. _attrgrp:. Attribute Groups; ----------------. Attribute groups are groups of attributes that are referenced by objects within; the IR. They are important for keeping ``.ll`` files readable, because a lot of; functions will use the same set of attributes. In the degenerative case of a; ``.ll`` file that corresponds to a single ``.c`` file, the single attribute; group will capture the important command line flags used to build that file. An attribute group is a module-level object. To use an attribute group, an; object references the attribute group's ID (e.g. ``#37``). An object may refer; to more than one attribute group. In that situation, the attributes from the; different groups are merged. Here is an example of attribute groups for a function that should always be; inlined, has a stack alignment of 4, and which shouldn't use SSE instructions:. .. code-block:: llvm. ; Target-independent attributes:; attributes #0 = { alwaysinline alignstack=4 }. ; Target-dependent attributes:; attributes #1 = { ""no-sse"" }. ; Function @f has attributes: alwaysinline, alignstack=4, and ""no-sse"".; define void @f() #0 #1 { ... }. .. _fnattrs:. Function Attributes; -------------------. Function attributes are set to communicate additional information about; a function. Function attributes are considered to be part of the; function, not of the function type, so functions with different function; attributes can have the same function type. Function attributes are simple keywords that follow the type specified.; If multiple attributes are needed, they are space separated. For; example:. .. code-block:: llvm. define void @f() noinline { ... }; define void @f() alwaysinline { ... }; define void @f() alwaysinline optsize { ... }; define void @f() optsize { ... }. ``alignstack(<n>)``; This attribute indicates that, when emitting the prologue and; epilogue, the backend should forcibly align the stack pointer.; Specify the desired alignment, which must be a power of two, in; parentheses",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:76647,depend,dependent,76647,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['dependent']
Integrability,"g. ``vectorize(enable)``). If the transformation is; disabled (e.g. ``vectorize(disable)``), that takes precedence over; transformations option pragmas implying that transformation. Vectorization, Interleaving, and Predication; --------------------------------------------. A vectorized loop performs multiple iterations of the original loop; in parallel using vector instructions. The instruction set of the target; processor determines which vector instructions are available and their vector; widths. This restricts the types of loops that can be vectorized. The vectorizer; automatically determines if the loop is safe and profitable to vectorize. A; vector instruction cost model is used to select the vector width. Interleaving multiple loop iterations allows modern processors to further; improve instruction-level parallelism (ILP) using advanced hardware features,; such as multiple execution units and out-of-order execution. The vectorizer uses; a cost model that depends on the register pressure and generated code size to; select the interleaving count. Vectorization is enabled by ``vectorize(enable)`` and interleaving is enabled; by ``interleave(enable)``. This is useful when compiling with ``-Os`` to; manually enable vectorization or interleaving. .. code-block:: c++. #pragma clang loop vectorize(enable); #pragma clang loop interleave(enable); for(...) {; ...; }. The vector width is specified by; ``vectorize_width(_value_[, fixed|scalable])``, where _value_ is a positive; integer and the type of vectorization can be specified with an optional; second parameter. The default for the second parameter is 'fixed' and; refers to fixed width vectorization, whereas 'scalable' indicates the; compiler should use scalable vectors instead. Another use of vectorize_width; is ``vectorize_width(fixed|scalable)`` where the user can hint at the type; of vectorization to use without specifying the exact width. In both variants; of the pragma the vectorizer may decide to fall back on fi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:163967,depend,depends,163967,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['depend'],['depends']
Integrability,"g/Tooling/Transformer/RangeSelector.h>`_. Stencils; ^^^^^^^^. Transformer offers a large and growing collection of combinators for; constructing output. Above, we demonstrated ``cat``, the core function for; constructing stencils. It takes a series of arguments, of three possible kinds:. #. Raw text, to be copied directly to the output.; #. Selector: specified with a ``RangeSelector``, indicates a range of source text; to copy to the output.; #. Builder: an operation that constructs a code snippet from its arguments. For; example, the ``access`` function we saw above. Data of these different types are all represented (generically) by a ``Stencil``.; ``cat`` takes text and ``RangeSelector``\ s directly as arguments, rather than; requiring that they be constructed with a builder; other builders are; constructed explicitly. In general, ``Stencil``\ s produce text from a match result. So, they are not; limited to generating source code, but can also be used to generate diagnostic; messages that reference (named) elements of the matched code, like we saw in the; example of rewriting method calls. Further details of the ``Stencil`` type are documented in the header file; `clang/Tooling/Transformer/Stencil.h <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Tooling/Transformer/Stencil.h>`_. Edits; ^^^^^. Transformer supports additional forms of edits. First, in a ``changeTo``, we can; specify the particular portion of code to be replaced, using the same; ``RangeSelector`` we saw earlier. For example, we could change the function name; in a function declaration with:. .. code-block:: c++. makeRule(functionDecl(hasName(""bad"")).bind(f),; 	 changeTo(name(f), cat(""good"")),; 	 cat(""bad is now good""));. We also provide simpler editing primitives for insertion and deletion:; ``insertBefore``, ``insertAfter`` and ``remove``. These can all be found in the header; file; `clang/Tooling/Transformer/RewriteRule.h <https://github.com/llvm/llvm-project/blob/main/clang/inc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:12020,message,messages,12020,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,1,['message'],['messages']
Integrability,"g; ``clang++`` simply. The users may want the scanner to get the transitional dependency information for headers.; Otherwise, the users have to scan twice for the project, once for headers and once for modules.; To address the requirement, clang-scan-deps will recognize the specified preprocessor options; in the given command line and generate the corresponding dependency information. For example,. .. code-block:: console. $ clang-scan-deps -format=p1689 -- ../bin/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o -MD -MT impl_part.ddi -MF impl_part.dep; $ cat impl_part.dep. We will get:. .. code-block:: text. impl_part.ddi: \; /usr/include/bits/wchar.h /usr/include/bits/types/wint_t.h \; /usr/include/bits/types/mbstate_t.h \; /usr/include/bits/types/__mbstate_t.h /usr/include/bits/types/__FILE.h \; /usr/include/bits/types/FILE.h /usr/include/bits/types/locale_t.h \; /usr/include/bits/types/__locale_t.h \; ... When clang-scan-deps detects ``-MF`` option, clang-scan-deps will try to write the; dependency information for headers to the file specified by ``-MF``. Possible Issues: Failed to find system headers; ----------------------------------------------. In case the users encounter errors like ``fatal error: 'stddef.h' file not found``,; probably the specified ``<path-to-compiler-executable>/clang++`` refers to a symlink; instead a real binary. There are 4 potential solutions to the problem:. * (1) End users can resolve the issue by pointing the specified compiler executable to; the real binary instead of the symlink.; * (2) End users can invoke ``<path-to-compiler-executable>/clang++ -print-resource-dir``; to get the corresponding resource directory for your compiler and add that directory; to the include search paths manually in the build scripts.; * (3) Build systems that use a compilation database as the input for clang-scan-deps; scanner, the build system can add the flag ``--resource-dir-recipe invoke-compiler`` to; the clang-scan-deps scanner to calculate the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:37946,depend,dependency,37946,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['depend'],['dependency']
Integrability,"gRef, ..., StringRef; Matches when at least one of the supplied string equals to the; Selector.getAsString(). matcher = objCMessageExpr(hasSelector(""methodA:"", ""methodB:""));; matches both of the expressions below:; [myObj methodA:argA];; [myObj methodB:argB];. Matcher<ObjCMessageExpr>hasKeywordSelector; Matches when the selector is a keyword selector. objCMessageExpr(hasKeywordSelector()) matches the generated setFrame; message expression in. UIWebView *webView = ...;; CGRect bodyFrame = webView.frame;; bodyFrame.size.height = self.bodyContentHeight;; webView.frame = bodyFrame;; // ^---- matches here. Matcher<ObjCMessageExpr>hasNullSelector; Matches when the selector is the empty selector. Matches only when the selector of the objCMessageExpr is NULL. This may; represent an error condition in the tree!. Matcher<ObjCMessageExpr>hasSelectorstd::string BaseName; Matches when BaseName == Selector.getAsString(). matcher = objCMessageExpr(hasSelector(""loadHTMLString:baseURL:""));; matches the outer message expr in the code below, but NOT the message; invocation for self.bodyView.; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMessageExpr>hasUnarySelector; Matches when the selector is a Unary Selector. matcher = objCMessageExpr(matchesSelector(hasUnarySelector());; matches self.bodyView in the code below, but NOT the outer message; invocation of ""loadHTMLString:baseURL:"".; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMessageExpr>isClassMessage; Returns true when the Objective-C message is sent to a class. Example; matcher = objcMessageExpr(isClassMessage()); matches; [NSString stringWithFormat:@""format""];; but not; NSString *x = @""hello"";; [x containsString:@""h""];. Matcher<ObjCMessageExpr>isInstanceMessage; Returns true when the Objective-C message is sent to an instance. Example; matcher = objcMessageExpr(isInstanceMessage()); matches; NSString *x = @""hello"";; [x containsString:@""h""];; but not; [NSString stringWithFormat:@""format""];. Matc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:106782,message,message,106782,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,4,['message'],['message']
Integrability,"gSerialization; clangTooling; ). With that done, Ninja will be able to compile our tool. Let's give it; something to compile! Put the following into; ``clang-tools-extra/loop-convert/LoopConvert.cpp``. A detailed explanation of; why the different parts are needed can be found in the `LibTooling; documentation <LibTooling.html>`_. .. code-block:: c++. // Declares clang::SyntaxOnlyAction.; #include ""clang/Frontend/FrontendActions.h""; #include ""clang/Tooling/CommonOptionsParser.h""; #include ""clang/Tooling/Tooling.h""; // Declares llvm::cl::extrahelp.; #include ""llvm/Support/CommandLine.h"". using namespace clang::tooling;; using namespace llvm;. // Apply a custom category to all command-line options so that they are the; // only ones displayed.; static llvm::cl::OptionCategory MyToolCategory(""my-tool options"");. // CommonOptionsParser declares HelpMessage with a description of the common; // command-line options related to the compilation database and input files.; // It's nice to have this help message in all tools.; static cl::extrahelp CommonHelp(CommonOptionsParser::HelpMessage);. // A help message for this specific tool can be added afterwards.; static cl::extrahelp MoreHelp(""\nMore help text...\n"");. int main(int argc, const char **argv) {; auto ExpectedParser = CommonOptionsParser::create(argc, argv, MyToolCategory);; if (!ExpectedParser) {; // Fail gracefully for unsupported options.; llvm::errs() << ExpectedParser.takeError();; return 1;; }; CommonOptionsParser& OptionsParser = ExpectedParser.get();; ClangTool Tool(OptionsParser.getCompilations(),; OptionsParser.getSourcePathList());; return Tool.run(newFrontendActionFactory<clang::SyntaxOnlyAction>().get());; }. And that's it! You can compile our new tool by running ninja from the; ``build`` directory. .. code-block:: console. cd ~/clang-llvm/build; ninja. You should now be able to run the syntax checker, which is located in; ``~/clang-llvm/build/bin``, on any source file. Try it!. .. code-block:: console. echo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:4337,message,message,4337,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,1,['message'],['message']
Integrability,"ge variants; set_property(TARGET rfield_variant APPEND_STRING PROPERTY LINK_FLAGS "" -STACK:8000000""); endif(); ROOT_ADD_GTEST(rfield_vector rfield_vector.cxx LIBRARIES ROOTNTuple CustomStruct). ROOT_ADD_GTEST(ntuple_minifile ntuple_minifile.cxx LIBRARIES ROOTNTuple Physics Tree CustomStruct); ROOT_ADD_GTEST(ntuple_show ntuple_show.cxx LIBRARIES ROOTNTuple CustomStruct); ROOT_ADD_GTEST(ntuple_storage ntuple_storage.cxx LIBRARIES ROOTNTuple MathCore CustomStruct); ROOT_ADD_GTEST(ntuple_extended ntuple_extended.cxx LIBRARIES ROOTNTuple MathCore CustomStruct). ROOT_ADD_GTEST(ntuple_parallel_writer ntuple_parallel_writer.cxx LIBRARIES ROOTNTuple). ROOT_ADD_GTEST(ntuple_limits ntuple_limits.cxx LIBRARIES ROOTNTuple). ROOT_ADD_GTEST(rfield_streamer rfield_streamer.cxx StreamerField.cxx StreamerFieldXML.cxx LIBRARIES ROOTNTuple); ROOT_GENERATE_DICTIONARY(StreamerFieldDict ${CMAKE_CURRENT_SOURCE_DIR}/StreamerField.hxx; MODULE rfield_streamer LINKDEF StreamerFieldLinkDef.h OPTIONS -inlineInputHeader; DEPENDENCIES RIO). if(MSVC); set(genreflex ${CMAKE_BINARY_DIR}/bin/genreflex.exe); set(command ${CMAKE_COMMAND} -E env ""ROOTIGNOREPREFIX=1"" ${genreflex}); else(); set(genreflex ${CMAKE_BINARY_DIR}/bin/genreflex); set(command ${CMAKE_COMMAND} -E env ""LD_LIBRARY_PATH=${CMAKE_BINARY_DIR}/lib:$ENV{LD_LIBRARY_PATH}""; ""ROOTIGNOREPREFIX=1"" ${genreflex}); endif(). configure_file(StreamerFieldXML.h . COPYONLY); configure_file(StreamerFieldSelection.xml . COPYONLY); add_custom_command(OUTPUT StreamerFieldXMLDict.cxx StreamerFieldXMLDict_rdict.pcm; COMMAND ${command} StreamerFieldXML.h -o StreamerFieldXMLDict.cxx -s StreamerFieldSelection.xml; DEPENDS rootcling StreamerFieldXML.h StreamerFieldSelection.xml); add_library(StreamerFieldXMLDict OBJECT StreamerFieldXMLDict.cxx); set_target_properties(StreamerFieldXMLDict PROPERTIES POSITION_INDEPENDENT_CODE TRUE); target_sources(rfield_streamer PRIVATE $<TARGET_OBJECTS:StreamerFieldXMLDict>); target_compile_options(StreamerFieldXMLDict PRIVATE $",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/CMakeLists.txt:4870,DEPEND,DEPENDENCIES,4870,tree/ntuple/v7/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/CMakeLists.txt,1,['DEPEND'],['DEPENDENCIES']
Integrability,"geName, double* clippedValPtr)](https://root.cern.ch/doc/v626/classRooAbsRealLValue.html#afc2a8818f433a9a4ec0c437cbdad4e8a): `epsRel = 0, epsAbs = 1e-6`; * [RooAbsRealLValue::inRange(std::span<const double> values, std::string const& rangeName, std::vector<bool>& out)](https://root.cern.ch/doc/v626/classRooAbsRealLValue.html#af9217abd0afe34364562ad0c194f5d2c): `epsRel = 0, epsAbs = 1e-6`. With this release, the default absolute and relative epsilon is zero to avoid confusion.; You can change them with `RooNumber::setRangeEpsRel(epsRel)` and `RooNumber::setRangeEpsAbs(epsAbs)`. ## TMVA. ### SOFIE : Code generation for fast inference of Deep Learning models. A large number of new features have been added in the TMVA SOFIE library. The list of all operators supported in the `RModel` class is the one provided below for the ONNX parser. The interface of `RModel::Generate` has been changed to; ```; RModel::Generate(Options options = Options::kDefault, int batchsize = 1)`; ```; where `Options` is a new enumeration having 3 different values:; - `kDefault = 0x0` : default case, a session class is generated and the weights are stored in a separate `.dat` file (in text format).; - `kNoSession = 0x1` : no session class is generated and the internal intermediate tensors are declared in the global namespace `TMVA_SOFIE_$ModelName`.; - `kNoWeightFile = 0x2` the weight values are not written in a separate `.dat` file, but they are included in the generated header file. In addition, the `RModel::Generate` function takes as an additional optional argument the batch size (default is = 1) and the inference code can then be generated for the desired batch size. #### SOFIE ONNX Parser. The ONNX parser supports now several new ONNX operators. The list of the current supported ONNX operator is the following:; - Gemm; - Conv (in 1D,2D and 3D); - RNN, GRU, LSTM; - Relu, Selu, Sigmoid, Softmax, Tanh, LeakyRelu; - BatchNormalization; - MaxPool, AveragePool, GlobalAverage; - ConvTranspose; - Gat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:26508,interface,interface,26508,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['interface'],['interface']
Integrability,"geName: ""sub1_.t0p"", scope: !4, file: !4, type: !5, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !7, retainedNodes: !24, targetFuncName: ""sub1_""). The targetFuncName field is the name of the function that the trampoline; calls. This descriptor results in the following DWARF tag:. .. code-block:: text. DW_TAG_subprogram; ...; DW_AT_linkage_name	(""sub1_.t0p""); DW_AT_name	(""sub1_.t0p""); DW_AT_trampoline	(""sub1_""). Debugging information format; ============================. Debugging Information Extension for Objective C Properties; ----------------------------------------------------------. Introduction; ^^^^^^^^^^^^. Objective C provides a simpler way to declare and define accessor methods using; declared properties. The language provides features to declare a property and; to let compiler synthesize accessor methods. The debugger lets developer inspect Objective C interfaces and their instance; variables and class variables. However, the debugger does not know anything; about the properties defined in Objective C interfaces. The debugger consumes; information generated by compiler in DWARF format. The format does not support; encoding of Objective C properties. This proposal describes DWARF extensions to; encode Objective C properties, which the debugger can use to let developers; inspect Objective C properties. Proposal; ^^^^^^^^. Objective C properties exist separately from class members. A property can be; defined only by ""setter"" and ""getter"" selectors, and be calculated anew on each; access. Or a property can just be a direct access to some declared ivar.; Finally it can have an ivar ""automatically synthesized"" for it by the compiler,; in which case the property can be referred to in user code directly using the; standard C dereference syntax as well as through the property ""dot"" syntax, but; there is no entry in the ``@interface`` declaration corresponding to this ivar. To facilitate debugging, these properties we will add a new DWARF TAG into the; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:49658,interface,interfaces,49658,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['interface'],['interfaces']
Integrability,"ged from the shape editor GUI. Existing shapes can be; browsed and edited from the same category.; - *Volumes.* The category allows the creation of a new volume having a; given name, shape and medium. For creating a volume assembly only; the name is relevant. Existing volumes can be browsed or edited from; this category.; - *Materials.* Allows creation of new materials/mixtures or editing; existing ones.; - *Media.* The same for creation/editing of tracking media (materials; having a set of properties related to tracking); - *Matrices.* Allows creation of translations, rotations or combined; transformations. Existing matrices can also be browser/edited. ### Editing Existing Objects. For editing an existing object from one of the categories described; above, the interface imposes first a selection among all objects of the; corresponding type stored in the geometry. This can be done by clicking; the button next to the blue label *Select \<object\>*. The dialog; interfaces are generally different for different types of objects. The; volume selection dialog offers the possibility to select either a volume; already connected to the geometry hierarchy or non-connected ones.; Selection for shapes and matrices is split into categories represented; by top-level list tree items for: boxes, tubes, translations, rotations,; etc. ![Selection dialogs for different TGeo objects](pictures/030001EF.png). Once a selection is made and the dialog is closed, the selected item; name will appear in the corresponding label and the button Edit will; start the object editor in a transient frame. Closing these transient; frames will not delete, but just hide existing opened editors for later; reuse. Their lifetime is determined by the canvas to which the manager; editor is attached to, since these will be destroyed together. ![Editors for shapes, materials, media, matrices](pictures/020001F0.jpg); ![Editors for shapes, materials, media, matrices](pictures/020001F1.jpg); ![Editors for shapes, m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:169245,interface,interfaces,169245,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['interface'],['interfaces']
Integrability,"ger 4 bytes. - **`UInt_t `**Unsigned integer 4 bytes. - **`Long64_t`** Portable signed long integer 8 bytes. - **`ULong64_t`** Portable unsigned long integer 8 bytes. - **`Float_t`** Float 4 bytes. - **`Double_t`** Float 8 bytes. - **`Double32_t`** Double 8 bytes in memory, written as a Float 4; bytes. - **`Bool_t`** Boolean (0=false, 1=true). If you do not want to save a variable on disk, you can use `int` or; `Int_t`, the result will be the same and the interpreter or the; compiler will treat them in exactly the same way. ### TObject. In ROOT, almost all classes inherit from a common base class called; **`TObject`**. This kind of architecture is also used in the Java; language. The **`TObject`** class provides default behavior and; protocol for all objects in the ROOT system. The main advantage of; this approach is that it enforces the common behavior of the derived; classes and consequently it ensures the consistency of the whole; system. See ""The Role of TObject"". **`TObject`** provides protocol, i.e. (abstract) member functions,; for:. - Object I/O (`Read()`, `Write())`. - Error handling (`Warning()`, `Error()`, `SysError()`, `Fatal())`. - Sorting (`IsSortable()`, `Compare()`, `IsEqual()`, `Hash())`. - Inspection (`Dump()`, `Inspect()`). - Printing (`Print())`. - Drawing (`Draw()`, `Paint()`, `ExecuteEvent())`. - Bit handling (`SetBit()`, `TestBit()`). - Memory allocation (operator` new and delete`, `IsOnHeap())`. - Access to meta information (`IsA()`, `InheritsFrom())`. - Object browsing (`Browse()`, `IsFolder())`. ## Global Variables. ROOT has a set of global variables that apply to the session. For; example,; ***`gDirectory`*** always holds the current directory, and; ***`gStyle`*** holds the current style. All global variables begin with ""*g*"" followed by a capital letter. ### gROOT. The single instance of **`TROOT`** is accessible via the global; ***`gROOT`*** and holds information relative to the current session.; By using the ***`gROOT`*** pointer, you g",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:31604,protocol,protocol,31604,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['protocol'],['protocol']
Integrability,"gh)``, 201910, 1; ``__has_cpp_attribute(warn_unused_result)``, 201907, 0; ``__has_cpp_attribute(clang::warn_unused_result)``, 201907, 1; ``__has_cpp_attribute(gnu::warn_unused_result)``, 201907, 1; ``__has_c_attribute(warn_unused_result)``, 202003, 0; ``__has_c_attribute(gnu::warn_unused_result)``, 202003, 1. - Fixed a bug in finding matching `operator!=` while adding reversed `operator==` as; outlined in ""The Equality Operator You Are Looking For"" (`P2468 <http://wg21.link/p2468r2>`_).; Fixes (`#68901 <https://github.com/llvm/llvm-project/issues/68901>`_). C++ Specific Potentially Breaking Changes; -----------------------------------------; - The name mangling rules for function templates has been changed to take into; account the possibility that functions could be overloaded on their template; parameter lists or requires-clauses. This causes mangled names to change for; function templates in the following cases:. - When a template parameter in a function template depends on a previous; template parameter, such as ``template<typename T, T V> void f()``.; - When the function has any constraints, whether from constrained template; parameters or requires-clauses.; - When the template parameter list includes a deduced type -- either; ``auto``, ``decltype(auto)``, or a deduced class template specialization; type.; - When a template template parameter is given a template template argument; that has a different template parameter list. This fixes a number of issues where valid programs would be rejected due to; mangling collisions, or would in some cases be silently miscompiled. Clang; will use the old manglings if ``-fclang-abi-compat=17`` or lower is; specified.; (`#48216 <https://github.com/llvm/llvm-project/issues/48216>`_),; (`#49884 <https://github.com/llvm/llvm-project/issues/49884>`_), and; (`#61273 <https://github.com/llvm/llvm-project/issues/61273>`_). - The `ClassScopeFunctionSpecializationDecl` AST node has been removed.; Dependent class scope explicit functi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:4459,depend,depends,4459,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['depend'],['depends']
Integrability,"gisters and register classes info. .. option:: -register-info-debug. Make -gen-register-info dump register information for debugging. .. option:: -gen-searchable-tables. Generate generic searchable tables. See :doc:`TableGen BackEnds <../TableGen/BackEnds>`; for a detailed description. .. option:: -gen-subtarget. Generate subtarget enumerations. .. option:: -gen-x86-EVEX2VEX-tables. Generate X86 EVEX to VEX compress tables. .. option:: -gen-x86-fold-tables. Generate X86 fold tables. .. option:: -long-string-literals. When emitting large string tables, prefer string literals over; comma-separated char literals. This can be a readability and; compile-time performance win, but upsets some compilers. .. option:: -print-enums. Print enumeration values for a class. .. option:: -class=classname. Make -print-enums print the enumeration list for the specified class. .. option:: -print-sets. Print expanded sets for testing DAG exprs. mlir-tblgen Options; ~~~~~~~~~~~~~~~~~~~. .. option:: -gen-avail-interface-decls. Generate availability interface declarations. .. option:: -gen-avail-interface-defs. Generate op interface definitions. .. option:: -gen-dialect-doc. Generate dialect documentation. .. option:: -dialect. The dialect to generate. .. option:: -gen-directive-decl. Generate declarations for directives (OpenMP, etc.). .. option:: -gen-enum-decls. Generate enum utility declarations. .. option:: -gen-enum-defs. Generate enum utility definitions. .. option:: -gen-enum-from-llvmir-conversions. Generate conversions of EnumAttrs from LLVM IR. .. option:: -gen-enum-to-llvmir-conversions. Generate conversions of EnumAttrs to LLVM IR. .. option:: -gen-llvmir-conversions. Generate LLVM IR conversions. .. option:: -gen-llvmir-intrinsics. Generate LLVM IR intrinsics. .. option:: -llvmir-intrinsics-filter. Only keep the intrinsics with the specified substring in their record name. .. option:: -dialect-opclass-base. The base class for the ops in the dialect we are to emit. .. option:: ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/tblgen.rst:12897,interface,interface-decls,12897,interpreter/llvm-project/llvm/docs/CommandGuide/tblgen.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/tblgen.rst,1,['interface'],['interface-decls']
Integrability,"given in the printout of the errors, then at; least M believes the errors are accurate, although there is always a; small chance that M has been fooled. Some visible signs that M may have; been fooled are:. - Warning messages produced during the minimization or error analysis. - Failure to find new minimum. - Value of $\mbox{EDM}$ too big. For a ""normal"" minimization,; after $\mbox{MIGRAD}$, the value of $\mbox{EDM}$ is usually; more than three orders of magnitude smaller than $\mbox{up}$,; unless a looser tolerance has been specified. - Correlation coefficients exactly equal to zero, unless some; parameters are known to be uncorrelated with the others. - Correlation coefficients very close to one (greater than 0.99).\; This indicates both an exceptionally difficult problem, and one; which has been badly parametrized so that individual errors are not; very meaningful because they are so highly correlated. - Parameter at limit. This condition, signalled by a M warning; message, may make both the function minimum and parameter errors; unreliable. See section [answer:right-errors], *Getting the right; parameter errors with limits*. The best way to be absolutely sure of the errors, is to use; ""independent"" calculations and compare them, or compare the calculated; errors with a picture of the function if possible. For example, if there; is only one free parameter, $\mbox{SCAN}$ allows the user to verify; approximately the function curvature. Similarly, if there are only two; free parameters, use $\mbox{CONTOURS}$. To verify a full error; matrix, compare the results of $\mbox{MIGRAD}$ with those; (calculated afterward) by $\mbox{HESSE}$, which uses a different; method. And of course the most reliable and most expensive technique,; which must be used if asymmetric errors are required, is; $\mbox{MINOS}$. ## Convergence in $\mbox{MIGRAD}$, and positive–definiteness ##. $\mbox{MIGRAD}$ uses its current estimate of the covariance matrix; of the function to determine the curre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:70128,message,message,70128,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['message'],['message']
Integrability,"gle; conversion function to an integral or Objective-C pointer type, in which; case that conversion is applied and analysis continues as appropriate.; Otherwise, the expression is ill-formed. An Objective-C object subscript expression is always an l-value. If the; expression appears on the left-hand side of a simple assignment operator; (=), the element is written as described below. If the expression; appears on the left-hand side of a compound assignment operator (e.g.; +=), the program is ill-formed, because the result of reading an element; is always an Objective-C object pointer and no binary operators are; legal on such pointers. If the expression appears in any other position,; the element is read as described below. It is an error to take the; address of a subscript expression, or (in C++) to bind a reference to; it. Programs can use object subscripting with Objective-C object pointers of; type ``id``. Normal dynamic message send rules apply; the compiler must; see *some* declaration of the subscripting methods, and will pick the; declaration seen first. Caveats; =======. Objects created using the literal or boxed expression syntax are not; guaranteed to be uniqued by the runtime, but nor are they guaranteed to; be newly-allocated. As such, the result of performing direct comparisons; against the location of an object literal (using ``==``, ``!=``, ``<``,; ``<=``, ``>``, or ``>=``) is not well-defined. This is usually a simple; mistake in code that intended to call the ``isEqual:`` method (or the; ``compare:`` method). This caveat applies to compile-time string literals as well.; Historically, string literals (using the ``@""...""`` syntax) have been; uniqued across translation units during linking. This is an; implementation detail of the compiler and should not be relied upon. If; you are using such code, please use global string constants instead; (``NSString * const MyConst = @""...""``) or use ``isEqual:``. Grammar Additions; =================. To support th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:16922,message,message,16922,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,1,['message'],['message']
Integrability,"global offset for the Y; dimension is passed in the; kernarg. ""HiddenGlobalOffsetZ""; The OpenCL grid dispatch; global offset for the Z; dimension is passed in the; kernarg. ""HiddenNone""; An argument that is not used; by the kernel. Space needs to; be left for it, but it does; not need to be set up. ""HiddenPrintfBuffer""; A global address space pointer; to the runtime printf buffer; is passed in kernarg. Mutually; exclusive with; ""HiddenHostcallBuffer"". ""HiddenHostcallBuffer""; A global address space pointer; to the runtime hostcall buffer; is passed in kernarg. Mutually; exclusive with; ""HiddenPrintfBuffer"". ""HiddenDefaultQueue""; A global address space pointer; to the OpenCL device enqueue; queue that should be used by; the kernel by default is; passed in the kernarg. ""HiddenCompletionAction""; A global address space pointer; to help link enqueued kernels into; the ancestor tree for determining; when the parent kernel has finished. ""HiddenMultiGridSyncArg""; A global address space pointer for; multi-grid synchronization is; passed in the kernarg. ""ValueType"" string Unused and deprecated. This should no longer; be emitted, but is accepted for compatibility. ""PointeeAlign"" integer Alignment in bytes of pointee; type for pointer type kernel; argument. Must be a power; of 2. Only present if; ""ValueKind"" is; ""DynamicSharedPointer"".; ""AddrSpaceQual"" string Kernel argument address space; qualifier. Only present if; ""ValueKind"" is ""GlobalBuffer"" or; ""DynamicSharedPointer"". Values; are:. - ""Private""; - ""Global""; - ""Constant""; - ""Local""; - ""Generic""; - ""Region"". .. TODO::. Is GlobalBuffer only Global; or Constant? Is; DynamicSharedPointer always; Local? Can HCC allow Generic?; How can Private or Region; ever happen?. ""AccQual"" string Kernel argument access; qualifier. Only present if; ""ValueKind"" is ""Image"" or; ""Pipe"". Values; are:. - ""ReadOnly""; - ""WriteOnly""; - ""ReadWrite"". .. TODO::. Does this apply to; GlobalBuffer?. ""ActualAccQual"" string The actual memory accesses; performe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:125392,synchroniz,synchronization,125392,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['synchroniz'],['synchronization']
Integrability,"gnatureArgument foo) {; return;; }));. .. _Language:. **Language** (``LanguageKind``) :versionbadge:`clang-format 3.5` :ref:`¶ <Language>`; Language, this format style is targeted at. Possible values:. * ``LK_None`` (in configuration: ``None``); Do not use. * ``LK_Cpp`` (in configuration: ``Cpp``); Should be used for C, C++. * ``LK_CSharp`` (in configuration: ``CSharp``); Should be used for C#. * ``LK_Java`` (in configuration: ``Java``); Should be used for Java. * ``LK_JavaScript`` (in configuration: ``JavaScript``); Should be used for JavaScript. * ``LK_Json`` (in configuration: ``Json``); Should be used for JSON. * ``LK_ObjC`` (in configuration: ``ObjC``); Should be used for Objective-C, Objective-C++. * ``LK_Proto`` (in configuration: ``Proto``); Should be used for Protocol Buffers; (https://developers.google.com/protocol-buffers/). * ``LK_TableGen`` (in configuration: ``TableGen``); Should be used for TableGen code. * ``LK_TextProto`` (in configuration: ``TextProto``); Should be used for Protocol Buffer messages in text format; (https://developers.google.com/protocol-buffers/). * ``LK_Verilog`` (in configuration: ``Verilog``); Should be used for Verilog and SystemVerilog.; https://standards.ieee.org/ieee/1800/6700/; https://sci-hub.st/10.1109/IEEESTD.2018.8299595. .. _LineEnding:. **LineEnding** (``LineEndingStyle``) :versionbadge:`clang-format 16` :ref:`¶ <LineEnding>`; Line ending style (``\n`` or ``\r\n``) to use. Possible values:. * ``LE_LF`` (in configuration: ``LF``); Use ``\n``. * ``LE_CRLF`` (in configuration: ``CRLF``); Use ``\r\n``. * ``LE_DeriveLF`` (in configuration: ``DeriveLF``); Use ``\n`` unless the input has more lines ending in ``\r\n``. * ``LE_DeriveCRLF`` (in configuration: ``DeriveCRLF``); Use ``\r\n`` unless the input has more lines ending in ``\n``. .. _MacroBlockBegin:. **MacroBlockBegin** (``String``) :versionbadge:`clang-format 3.7` :ref:`¶ <MacroBlockBegin>`; A regular expression matching macros that start a block. .. code-block:: c++. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:84075,message,messages,84075,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['message'],['messages']
Integrability,"gner_9j(int ja, int jb, int jc, int jd, int je, int jf, int jg, int jh, int ji);; . New statistical function: non-central chisquare probability; density function; ; double noncentral_chisquared_pdf(double x, double r, double lambda);; ; It is implemented using Bessel functions or hypergeometric function; ; New classes VavilovAccurate and VavilovFast,; derived from the abstract base class Vavilov,; provide pdf, cdf and quantile functions for the Vavilov distribution,; based on the algorithms of CERNLIB (G116 and G115, respectively).; The classes VavilovAccuratePdf,; VavilovAccurateCdf and VavilovAccurateQuantile; implement the IParametricFunctionOneDim interface; for easier use in fit problems. . Unuran. Use new version 1.7.2 ; Add new class TUnuranSampler implementing the; ROOT::Math::DistSampler interface for one dimensional; continuous and discrete distributions and for mult-dimensional ones; . Foam. Add new class TFoamSampler implementing the; ROOT::Math::DistSampler interface for generating random; numbers according to any one or multi-dim distributions using Foam.; ; All the TFoam options can be controlled via the; ROOT::Math::DistSamplerOptions class, which can be passed; as input to the virtual ROOT::Math::DistSampler::Init(..); function.; . GenVector. Add some missing copy constructor and assignment operators to; fix compilation issue observed with LLVM (Clang). Minuit. Fix a bug when using at the same time TMinuit or TFitter with; the new TMinuitMinimizer class. See bug 72909.; . Minuit2. Fix the returned error from the Minimizer class for fixed and; constant parameters. Now is set explicitly to zero.; ; Fix a problem in re-defining fixed parameters as variable; ones. Before it was not possible to release them.; ; Fix a problem in the number of function calls when running MnHesse; after minimizing. Now the number is incremented instead of being; reset.; . Genetic. Add a new Minimizer implementation based on the genetic; algorithm used in TMVA (plugin name """,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v528/index.html:9260,interface,interface,9260,math/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v528/index.html,2,['interface'],['interface']
Integrability,"gnostic required”; Unknown. 1463; drafting; extern ""C"" alias templates; Not resolved. 1464; CD3; Negative array bound in a new-expression; Unknown. 1465; CD4; noexcept and std::bad_array_new_length; Unknown. 1466; C++14; Visible sequences of side effects are redundant; Unknown. 1467; CD4; List-initialization of aggregate from same-type object; Clang 3.7 (C++11 onwards). 1468; CD5; typeid, overload resolution, and implicit lambda capture; Unknown. 1469; CD5; Omitted bound in array new-expression; Unknown. 1470; NAD; Thread migration; Unknown. 1471; CD3; Nested type of non-dependent base; Unknown. 1472; CD3; odr-use of reference variables; Unknown. 1473; CD3; Syntax of literal-operator-id; Unknown. 1474; NAD; User-defined literals and <inttypes.h> format macros; Unknown. 1475; CD3; Errors in [[carries_dependency]] example; Unknown. 1476; CD3; Definition of user-defined type; Unknown. 1477; CD3; Definition of a friend outside its namespace; Unknown. 1478; CD6; template keyword for dependent template template arguments; Unknown. 1479; CD3; Literal operators and default arguments; Clang 3.1. 1480; CD3; Constant initialization via non-constant temporary; Unknown. 1481; CD3; Increment/decrement operators with reference parameters; Unknown. 1482; CD3; Point of declaration of enumeration; Clang 3.0. 1483; NAD; Non-dependent static_assert-declarations; Unknown. 1484; CD4; Unused local classes of function templates; Unknown. 1485; drafting; Out-of-class definition of member unscoped opaque enumeration; Not resolved. 1486; drafting; Base-derived conversion in member pointer deduction; Not resolved. 1487; CD3; When are inheriting constructors declared?; Unknown. 1488; drafting; abstract-pack-declarators in type-ids; Not resolved. 1489; CD3; Is value-initialization of an array constant initialization?; Unknown. 1490; CD4; List-initialization from a string literal; Clang 3.7 (C++11 onwards). 1491; CD3; Move construction and rvalue reference members; Unknown. 1492; CD4; Exception s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:99270,depend,dependent,99270,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['depend'],['dependent']
Integrability,"go too overboard on this recommendation, however. You; **must** include all of the header files that you are using --- you can include; them either directly or indirectly through another header file. To make sure; that you don't accidentally forget to include a header file in your module; header, make sure to include your module header **first** in the implementation; file (as mentioned above). This way there won't be any hidden dependencies that; you'll find out about later. Keep ""Internal"" Headers Private; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Many modules have a complex implementation that causes them to use more than one; implementation (``.cpp``) file. It is often tempting to put the internal; communication interface (helper classes, extra functions, etc) in the public; module header file. Don't do this!. If you really need to do something like this, put a private header file in the; same directory as the source files, and include it locally. This ensures that; your private interface remains private and undisturbed by outsiders. .. note::. It's okay to put extra implementation methods in a public class itself. Just; make them private (or protected) and all is well. Use Namespace Qualifiers to Implement Previously Declared Functions; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When providing an out of line implementation of a function in a source file, do; not open namespace blocks in the source file. Instead, use namespace qualifiers; to help ensure that your definition matches an existing declaration. Do this:. .. code-block:: c++. // Foo.h; namespace llvm {; int foo(const char *s);; }. // Foo.cpp; #include ""Foo.h""; using namespace llvm;; int llvm::foo(const char *s) {; // ...; }. Doing this helps to avoid bugs where the definition does not match the; declaration from the header. For example, the following C++ code defines a new; overload of ``llvm::foo`` instead of providing a definition for the existing; function declared in the header:. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:33554,interface,interface,33554,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['interface'],['interface']
Integrability,"gonal pivoting method decomposes a real symmetric matrix `A`.; - TDecompChol: The Cholesky decomposition class, which decomposes a symmetric, positive definite matrix `A = U^T * U` where `U` is a upper triangular matrix.; - TDecompQRH: QR decomposition class.; - TDecompSVD: Single value decomposition class.; - TDecompSparse: Sparse symmetric decomposition class. ### Matrix Eigen analysis. With the `TMatrixDEigen` and `TMatrixDSymEigen` classes, you can compute eigenvalues and; eigenvectors for general dense and symmetric real matrices. ## Additional Notes. The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in %ROOT, they of course; can be stored in a %ROOT database. ### How to efficiently use this package. #### 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:. ~~~ {.cpp}; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; ~~~. runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. #### 2. Use ""two-address instructions"". ~~~ {.cpp};",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/doc/index.md:14698,integrat,integrated,14698,math/matrix/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/doc/index.md,1,['integrat'],['integrated']
Integrability,"gram to adjust; the scale of the function. In case of extended p.d.f.s, the adjustment is made with the expected; number of events, rather than the observed number of events. Tutorial macro rf602_chi2fit.C has been updated to use this new interface. Chi-squared fits to X-Y datasets now possible; In addition to the ability to perform chi-squared fits to histograms it is now also possible; to perform chi-squared fits to unbinned datasets containing a series of X and Y values; with associated errors on Y and optionally on X. These 'X-Y' chi-squared fits are interfaced through newly added method; RooAbsReal::chi2FitTo(const RooDataSet&,...). By default the event weight is; interpreted as the 'Y' value, but an YVar() argument can designate any other; dataset column as Y value. If X errors are defined, one can choose to integrate the fitted; function over the range of the X errors, rather than taking the central value by adding; an Integrate(true) argument to chi2FitTo(); Two new arguments, StoreError(const RooArgSet&) and StoreAsymError(const RooArgSet&); have been added to the RooDataSet constructor to simplify the process of storing the errors; of X and Y variables along with their values in a dataset. The newly added tutorial macro rf609_xychi2fit.C illustrates the use of all this; new functionality. Uniform interface for creation of (profile likelihoods) and chi-squared from p.d.f.s; It is now recommended to use the method RooAbsPdf::createNLL(RooAbsData&,...) to; create a likelihood from a p.d.f and a dataset rather than constructing a RooNLLVar; object directly. This is because part of the likelihood construction functionality such a using; multiple Range()s, or the inclusion for constraint terms are only available through; createNLL(). To promote the consistency of this interface, a similar method RooAbsReal::createChi2(); has been added to construct chi-squared functions of a dataset and a function or p.d.f. Along the same lines, it is recommended to use RooAbsRe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:8729,integrat,integrate,8729,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,3,"['Integrat', 'integrat']","['Integrate', 'integrate']"
Integrability,"grator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; ```. The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <= max ( epsAbs, epsRel * Integral); $$; Where *absErr* is an estimate of the absolute error (it can be retrieved with `GSLIntegrator::Error()`) and *Integral* is the estimate of the function integral; (it can be obtained with `GSLIntegrator::Result()`). The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the `GSL` users documentation.; * `ROOT::Math::Integration::kNONADAPTIVE` : based on `gsl_integration_qng`. It is a non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson abscissae; to sample the integrand at a maximum of 87 points. It is provided for fast integration of smooth functions.; * `ROOT::Math::Integration::kADAPTIVE`: based on `gsl_integration_qag`. It is an adaptiva Gauss-Kronrod integration algorithm, the integration region is divided into subintervals, and on each; iteration the subinterval with the largest estimated error is bisected. It is possible to specify the integration rule as an extra enumeration parameter. The possible rules are; * `Integration::kGAUSS15` : 15 points Gauss-Konrod rule (value = 1); * `Integration::kGAUSS21` : 21 points Gauss-Konrod rule (value = 2); * `Integration::kGAUSS31` : 31 points Gauss-Konrod rule (value = 3); * `Integration::kGAUSS41` : 41 points Gauss-Konrod rule (value = 4); * `Integration::kGAUSS51` : 51 points Gauss-Konrod rule (value = 5); * `Integration::kGAUSS61` : 61 points Gauss-Konrod rule (value = 6); 	 The higher-order rules give better accuracy for smooth functions, while lower-order rules save time when the function contains local difficulties, such as discontinuities. If no integ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:56438,integrat,integration,56438,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['integrat'],['integration']
Integrability,"gs: [--target=thumbv7m-none-eabi]. Design principles; =================. Stable interface; ----------------. ``multilib.yaml`` and ``-print-multi-flags-experimental`` are new; interfaces to Clang. In order for them to be usable over time and across LLVM; versions their interfaces should be stable.; The new multilib system will be considered experimental in LLVM 17, but in; LLVM 18 it will be stable. In particular this is important to which multilib; selection flags Clang generates from command line options. Once a flag is; generated by a released version of Clang it may be used in ``multilib.yaml``; files that exist independently of the LLVM release cycle, and therefore; ceasing to generate the flag would be a breaking change and should be; avoided. However, an exception is the normalization of ``-march``.; ``-march`` for Arm architectures contains a list of enabled and disabled; extensions and this list is likely to grow. Therefore ``-march`` flags are; unstable. Incomplete interface; --------------------. The new multilib system does multilib selection based on only a limited set of; command line options, and limits which flags can be used for multilib; selection. This is in order to avoid committing to too large an interface.; Later LLVM versions can add support for multilib selection from more command; line options as needed. Extensible; ----------. It is likely that the configuration format will need to evolve in future to; adapt to new requirements.; Using a format like YAML that supports key-value pairs helps here as it's; trivial to add new keys alongside existing ones. Backwards compatibility; -----------------------. New versions of Clang should be able to use configuration written for earlier; Clang versions.; To avoid behaving in a way that may be subtly incorrect, Clang should be able; to detect if the configuration is too new and emit an error. Forwards compatibility; ----------------------. As an author of a multilib configuration, it should be possib",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:10186,interface,interface,10186,interpreter/llvm-project/clang/docs/Multilib.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst,1,['interface'],['interface']
Integrability,"gumentWithParam(; declRefExpr(to(varDecl(hasName(""y"")))),; parmVarDecl(hasType(isInteger())); )); matches f(y);; with declRefExpr(...); matching int y; and parmVarDecl(...); matching int i. Matcher<CXXConstructExpr>forEachArgumentWithParamTypeMatcher<Expr> ArgMatcher, Matcher<QualType> ParamMatcher; Matches all arguments and their respective types for a CallExpr or; CXXConstructExpr. It is very similar to forEachArgumentWithParam but; it works on calls through function pointers as well. The difference is, that function pointers do not provide access to a; ParmVarDecl, but only the QualType for each argument. Given; void f(int i);; int y;; f(y);; void (*f_ptr)(int) = f;; f_ptr(y);; callExpr(; forEachArgumentWithParamType(; declRefExpr(to(varDecl(hasName(""y"")))),; qualType(isInteger()).bind(""type); )); matches f(y) and f_ptr(y); with declRefExpr(...); matching int y; and qualType(...); matching int. Matcher<CXXConstructExpr>hasAnyArgumentMatcher<Expr> InnerMatcher; Matches any argument of a call expression or a constructor call; expression, or an ObjC-message-send expression. Given; void x(int, int, int) { int y; x(1, y, 42); }; callExpr(hasAnyArgument(declRefExpr())); matches x(1, y, 42); with hasAnyArgument(...); matching y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end; void foo(I *i) { [i f:12]; }; objcMessageExpr(hasAnyArgument(integerLiteral(equals(12)))); matches [i f:12]. Matcher<CXXConstructExpr>hasArgumentunsigned N, Matcher<Expr> InnerMatcher; Matches the n'th argument of a call expression or a constructor; call expression. Example matches y in x(y); (matcher = callExpr(hasArgument(0, declRefExpr()))); void x(int) { int y; x(y); }. Matcher<CXXConstructExpr>hasDeclarationMatcher<Decl> InnerMatcher; Matches a node if the declaration associated with that node; matches the given matcher. The associated declaration is:; - for type nodes, the declaration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the de",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:148420,message,message-send,148420,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['message'],['message-send']
Integrability,"h 8.5.2 of the book,; *F. James, Statistical Methods in Experimental Physics, 2nd Edition*. ### Fit Statistics. You can change the statistics box to display the fit parameters with the; `TStyle::SetOptFit(mode)` method. This parameter has four digits:; `mode = pcev` (`default = 0111`). - `p` = 1 print probability; - `c` = 1 print Chi-square/number of degrees of freedom; - `e` = 1 print errors (if `e=1`, `v` must be 1); - `v` = 1 print name/values of parameters. For example, to print the fit probability, parameter names/values, and; errors, use:. ``` {.cpp}; gStyle->SetOptFit(1011);; ```. ## The Fit Panel. ![The Fit Panel](pictures/03000061.png). To display the Fit Panel right click on a histogram to pop up the; context menu, and then select the menu entry Fit Panel. The new Fit Panel GUI is available in ROOT v5.14. Its goal is to; replace the old Fit Panel and to provide more user friendly way for; performing, exploring and comparing fits. By design, this user interface is planned to contain two tabs:; ""General"" and ""Minimization"". Currently, the ""General"" tab provides; user interface elements for setting the fit function, fit method and; different fit, draw, print options.; The ""Minimization tab"" provides the option to set the Minimizer to use in the fit and; its specific options. The new fit panel is a modeless dialog, i.e. when opened, it does not; prevent users from interacting with other windows. Its first prototype; is a singleton application. When the Fit Panel is activated, users can; select an object for fitting in the usual way, i.e. by left-mouse; click on it. If the selected object is suitable for fitting, the fit; panel is connected with this object and users can perform fits by; setting different parameters and options. ### Function Choice and Settings. *‘Predefined' combo box* - contains a list of predefined functions in; ROOT. You have a choice of several polynomials, a Gaussian, a Landau,; and an Exponential function. The default one is Gaussian. *‘",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:20341,interface,interface,20341,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['interface'],['interface']
Integrability,"h a DataError(RooAbsData::Poisson) argument these; approximate Poisson error bars are shown. Miscellaneous improvements other. The RooFit messagee service class RooMsgService has been augmented with a stack that; can store its configurate state information. A call to saveState() will save the; present configuration, which can be restored through a subsequent call to restoreState().; In addition to the method RooAbsArg::printCompactTree() which is mostly intende for; debugging, a new method RooAbsArg::printComponentTree() has been added that prints; the tree structure of a pdf in a more user-friendly content oriented way. The printing ; of the leaf nodes (the variables) is omitted in this method to keep the output compact. RooStats. This release contains significant bug fixes and it is strongly; recommended to update to this version if using older ones. . Major Changes in LimitCalculator and HypoTestCalculator classes: usage of ModelConfig class. The RooStats calculator interfaces have been changed to use the ModelConfig class.; All the setter methods with the parameter lists, pdf instances and name have been removed from the interfaces.; The SetWorkspace(RooWorkspace & ) has also been removed, while a SetModel(const ModelConfig &); function is introduced. Users are supposed to pass all the model information using the; ModelConfig class rather than via the; RooWorkspace or specifying directly the pdf and parameter; objects in the constructors. ; Setter methods using pdf instances and parameter lists are maintained in the derived classes, like the ProfileLikelihoodCalculator or the HybridCalculator, but those passing a string for the name of the pdf have been removed. ; All the calculator classes do not keep anymore a pointer to the workspace, but they contain pointers to the pdf, the data and the parameters required to run the calculator. These pointers are managed outside by the users or by the RooWorkspace. They can be passed either directly to the classes, for exam",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html:11534,interface,interfaces,11534,roofit/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html,2,['interface'],['interfaces']
Integrability,"h a hash (``#``) is a comment.; * A non-comment line is a single pattern.; * The slash (``/``) is used as the directory separator.; * A pattern is relative to the directory of the ``.clang-format-ignore`` file; (or the root directory if the pattern starts with a slash). Patterns; containing drive names (e.g. ``C:``) are not supported.; * Patterns follow the rules specified in `POSIX 2.13.1, 2.13.2, and Rule 1 of; 2.13.3 <https://pubs.opengroup.org/onlinepubs/9699919799/utilities/; V3_chap02.html#tag_18_13>`_.; * A pattern is negated if it starts with a bang (``!``). To match all files in a directory, use e.g. ``foo/bar/*``. To match all files in; the directory of the ``.clang-format-ignore`` file, use ``*``.; Multiple ``.clang-format-ignore`` files are supported similar to the; ``.clang-format`` files, with a lower directory level file voiding the higher; level ones. Vim Integration; ===============. There is an integration for :program:`vim` which lets you run the; :program:`clang-format` standalone tool on your current buffer, optionally; selecting regions to reformat. The integration has the form of a `python`-file; which can be found under `clang/tools/clang-format/clang-format.py`. This can be integrated by adding the following to your `.vimrc`:. .. code-block:: vim. if has('python'); map <C-K> :pyf <path-to-this-file>/clang-format.py<cr>; imap <C-K> <c-o>:pyf <path-to-this-file>/clang-format.py<cr>; elseif has('python3'); map <C-K> :py3f <path-to-this-file>/clang-format.py<cr>; imap <C-K> <c-o>:py3f <path-to-this-file>/clang-format.py<cr>; endif. The first line enables :program:`clang-format` for NORMAL and VISUAL mode, the; second line adds support for INSERT mode. Change ""C-K"" to another binding if; you need :program:`clang-format` on a different key (C-K stands for Ctrl+k). With this integration you can press the bound key and clang-format will; format the current line in NORMAL and INSERT mode or the selected region in; VISUAL mode. The line or region is e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst:6360,integrat,integration,6360,interpreter/llvm-project/clang/docs/ClangFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst,1,['integrat'],['integration']
Integrability,"h allow for representing large collections.; RNTuple can still use 32bit offset columns, e.g.; ```; RNTupleWriteOptions options;; options.SetHasSmallClusters(true);; auto writer = RNTupleWriter::Recreate(std::move(model), ""myNTuple"", ""out.ntuple"");; ```. - Support for projected fields, i.e. exposing other fields' data as a different (compatible) C++ type.; Users should provide a mapping function that maps each projected subfield in the tree to theunderlying real field, e.g.; ```; auto model = RNTupleModel::Create();; auto fvec = model->MakeField<std::vector<float>>(""vec"");. auto aliasVec = RFieldBase::Create(""aliasVec"", ""std::vector<float>"").Unwrap();; model->AddProjectedField(std::move(aliasVec), [](const std::string &fieldName) {; if (fieldName == ""aliasVec"") return ""vec"";; else return ""vec._0"";; });; ```; Projected fields are stored as part of the metadata. - Improvements on the internal `RField` value API. The `RFieldValue` class has been deprecated in favor of `RField::Value` and the related interfaces have changed accordingly (see [#13219](https://github.com/root-project/root/pull/13219) and [#13264](https://github.com/root-project/root/pull/13264)).; If you were not using `RField::(Read|Append)` directly, this change should not impact you. - The new `RNTupleImporter` class provides automatic conversion of TTree to RNTuple.; Note that not all of the C++ types supported in TTree are currently supported in RNTuple. - Many bug fixes and performance improvements. Please, report any issues regarding the abovementioned features should you encounter them.; RNTuple is still experimental and is scheduled to become production grade by end of 2024.; Thus, we appreciate feedback and suggestions for improvement. ## Histogram Libraries. ## Math Libraries. ### Minuit2 is now the default minimizer. Many ROOT-based frameworks and users employ Minuit2 as the minimizer of choice for a long time already.; Therefore, Minuit2 is now the default minimizer used by ROOT.; This affects",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md:9244,interface,interfaces,9244,README/ReleaseNotes/v630/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md,1,['interface'],['interfaces']
Integrability,"h as TH1::Fit.; ; The fit data are decoupled from the fitter class and described by the dedicated fit data classes like the ROOT::Fit::BinData for bin data containing coordinate values of any dimensions, bin content values and optionally errors in coordinate and bin content, and ROOT::Fit::UnBinData classes for any dimension un-bin data.; The fitter class, ROOT::Fit::Fitter, provides the functionality for fitting those data with any model function implementing the parametric function interface, ROOT::Math::IParamMultiFunction. Fit methods such as least square, bin and un-bin likelihood are supported. The fit solution is then found by using the ROOT::Math::Minimizer interface class and the results are stored in the ROOT::Fit::FitResult class. Fit parameter can be configured individually using the ROOT::Fit::FitParameterSettings class.; ; Various implementation of the minimizer interface can be used automatically using the ROOT plug-in manager mechanism, including the linear fitter for a fast and direct solution, in case of a linear least square model, or by using Minuit, Minuit2 or GSL minimization methods provided by the MathMore library. Functions for filling the new ROOT::Fit::BinData classes with all the histogram and graph types have been added in the histogram library (libHist) and graph library:; ; ROOT::Fit::FillData( BinData & , const TH1 *, TF1 * ) for histograms (in libHist); ROOT::Fit::FillData( BinData & , const TGraph2D *, TF1 * ) for 2D graphs (in libHist); ROOT::Fit::FillData( BinData & , const TGraph *, TF1 * ) for all 1D graphs (in libGraf); ROOT::Fit::FillData( BinData & , const TMultiGraph *, TF1 * ) for multi-graphs (in libGraf); . MathCore Numerical Algorithms. Classes implementing numerical methods which can be used by all the other ROOT library have been added in MathCore. These originate mainly from methods present previously in the implementation of the TF1 class. Now they can be used also outside this class. In addition, in order to have a c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:5170,interface,interface,5170,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,2,['interface'],['interface']
Integrability,"h integer overflow errors. Signed integer overflow is; undefined in C. With this flag, extra code is generated to detect this and; abort when it happens. .. option:: -fvisibility. This flag sets the default visibility level. .. option:: -fcommon, -fno-common. This flag specifies that variables without initializers get common linkage.; It can be disabled with :option:`-fno-common`. .. option:: -ftls-model=<model>. Set the default thread-local storage (TLS) model to use for thread-local; variables. Valid values are: ""global-dynamic"", ""local-dynamic"",; ""initial-exec"" and ""local-exec"". The default is ""global-dynamic"". The default; model can be overridden with the tls_model attribute. The compiler will try; to choose a more efficient model if possible. .. option:: -flto, -flto=full, -flto=thin, -emit-llvm. Generate output files in LLVM formats, suitable for link time optimization.; When used with :option:`-S` this generates LLVM intermediate language; assembly files, otherwise this generates LLVM bitcode format object files; (which may be passed to the linker depending on the stage selection options). The default for :option:`-flto` is ""full"", in which the; LLVM bitcode is suitable for monolithic Link Time Optimization (LTO), where; the linker merges all such modules into a single combined module for; optimization. With ""thin"", :doc:`ThinLTO <../ThinLTO>`; compilation is invoked instead. .. note::. On Darwin, when using :option:`-flto` along with :option:`-g` and; compiling and linking in separate steps, you also need to pass; ``-Wl,-object_path_lto,<lto-filename>.o`` at the linking step to instruct the; ld64 linker not to delete the temporary object file generated during Link; Time Optimization (this flag is automatically passed to the linker by Clang; if compilation and linking are done in a single step). This allows debugging; the executable as well as generating the ``.dSYM`` bundle using :manpage:`dsymutil(1)`. Driver Options; ~~~~~~~~~~~~~~. .. option:: -###. Print ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:15285,depend,depending,15285,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,1,['depend'],['depending']
Integrability,"h is supported; for compatibility with SP3 assembler:. =============================== =========================================================; Syntax Description; =============================== =========================================================; dim:SQ_RSRC_IMG_1D One-dimensional image.; dim:SQ_RSRC_IMG_2D Two-dimensional image.; dim:SQ_RSRC_IMG_3D Three-dimensional image.; dim:SQ_RSRC_IMG_CUBE Cubemap array.; dim:SQ_RSRC_IMG_1D_ARRAY One-dimensional image array.; dim:SQ_RSRC_IMG_2D_ARRAY Two-dimensional image array.; dim:SQ_RSRC_IMG_2D_MSAA Two-dimensional multi-sample auto-aliasing image.; dim:SQ_RSRC_IMG_2D_MSAA_ARRAY Two-dimensional multi-sample auto-aliasing image array.; =============================== =========================================================. dlc; ~~~. See a description :ref:`here<amdgpu_synid_dlc>`. Miscellaneous Modifiers; -----------------------. .. _amdgpu_synid_dlc:. dlc; ~~~. Controls device level cache policy for memory operations. Used for synchronization.; When specified, forces operation to bypass device level cache, making the operation device; level coherent. By default, instructions use device level cache. ======================================== ================================================; Syntax Description; ======================================== ================================================; dlc Bypass device level cache.; ======================================== ================================================. .. _amdgpu_synid_glc:. glc; ~~~. For atomic opcodes, this modifier indicates that the instruction returns the value from memory; before the operation. For other opcodes, it is used together with :ref:`slc<amdgpu_synid_slc>`; to specify cache policy. The default value is off (0). ======================================== ================================================; Syntax Description; ======================================== ================================================; glc Set glc bit to 1.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUModifierSyntax.rst:17102,synchroniz,synchronization,17102,interpreter/llvm-project/llvm/docs/AMDGPUModifierSyntax.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUModifierSyntax.rst,1,['synchroniz'],['synchronization']
Integrability,"h the; .inc extension. Use sparingly, and prefer self-contained headers when possible. In general, a header should be implemented by one or more ``.cpp`` files. Each; of these ``.cpp`` files should include the header that defines their interface; first. This ensures that all of the dependences of the header have been; properly added to the header itself, and are not implicit. System headers; should be included after user headers for a translation unit. Library Layering; ^^^^^^^^^^^^^^^^. A directory of header files (for example ``include/llvm/Foo``) defines a; library (``Foo``). One library (both; its headers and implementation) should only use things from the libraries; listed in its dependencies. Some of this constraint can be enforced by classic Unix linkers (Mac & Windows; linkers, as well as lld, do not enforce this constraint). A Unix linker; searches left to right through the libraries specified on its command line and; never revisits a library. In this way, no circular dependencies between; libraries can exist. This doesn't fully enforce all inter-library dependencies, and importantly; doesn't enforce header file circular dependencies created by inline functions.; A good way to answer the ""is this layered correctly"" would be to consider; whether a Unix linker would succeed at linking the program if all inline; functions were defined out-of-line. (& for all valid orderings of dependencies; - since linking resolution is linear, it's possible that some implicit; dependencies can sneak through: A depends on B and C, so valid orderings are; ""C B A"" or ""B C A"", in both cases the explicit dependencies come before their; use. But in the first case, B could still link successfully if it implicitly; depended on C, or the opposite in the second case). .. _minimal list of #includes:. ``#include`` as Little as Possible; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``#include`` hurts compile time performance. Don't do it unless you have to,; especially in header files. But wait! S",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:30972,depend,dependencies,30972,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['depend'],['dependencies']
Integrability,"h) is no longer necessary; when using ExpandCreateFast. New Thread Pool class. A first version of TThreadPool class has been introduced.; This class implements a Thread Pool pattern.; So far it supports only one type of queue - FIFO. Thread library. Reduces risk of internal dead lock by using a private internal lock to protect the internals of TThread, rather than using TThread::Lock. New header TThreadSlots.h to centralize and formalize the use of the TThread local memory slots amongst the ROOT packages. Global Variables. The global values gPad, gVirtualX, gInterpreter, gDirectory and gFile; are now all accessed via a static function of their respective class. The; access is made transparent via a CPP macro.; The access is now also made transparent from the CINT and python prompt.; gPad, gVirtualX and gInterpreter are now accessible even when their value; is zero and they now properly support tab completion.; See the important note in the I/O section on gDirectory and gFile which; are now thread local. Meta. The new interface TDictionary::GetDictionary(const char*) offers a; single entry point to query the type based on its name, conveniently combining; TDataType and TClass queries. It does name normalization (removing std etc). Add the ability to explicitly forbid (or allow) the splitting of a class; (TClass::SetSplit) so that user can inforce the use of a custom streamer in all possible split cases. Resolve several issues with the creation of StreamerInfo for abstract classes. When looking for the value corresponding to an enum type, skip global that are not enums. (This improves the speed of TFile::Open by 60%). TStyle. The Modern style has now a transparent background for the histogram title. Misc. In the root executable, auto-detect command line arguments that are local root files even if their name does not end with "".root"". If home directory is not correctly set in pw file or user is not known, use the HOME shell variable to find the desired home directory. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v532/index.html:3410,interface,interface,3410,core/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v532/index.html,2,['interface'],['interface']
Integrability,h/tan.h; libclc/generic/include/clc/math/tanh.h; libclc/generic/include/clc/math/tanpi.h; libclc/generic/include/clc/math/tgamma.h; libclc/generic/include/clc/math/trunc.h; libclc/generic/include/clc/relational/bitselect.h; libclc/generic/include/clc/relational/isfinite.h; libclc/generic/include/clc/relational/isgreater.h; libclc/generic/include/clc/relational/isgreaterequal.h; libclc/generic/include/clc/relational/isless.h; libclc/generic/include/clc/relational/islessequal.h; libclc/generic/include/clc/relational/islessgreater.h; libclc/generic/include/clc/relational/isnormal.h; libclc/generic/include/clc/relational/isnotequal.h; libclc/generic/include/clc/relational/isordered.h; libclc/generic/include/clc/relational/isunordered.h; libclc/generic/include/clc/relational/signbit.h; libclc/generic/include/clc/shared/clamp.h; libclc/generic/include/clc/shared/max.h; libclc/generic/include/clc/shared/min.h; libclc/generic/include/clc/synchronization/barrier.h; libclc/generic/include/clc/synchronization/cl_mem_fence_flags.h; libclc/generic/include/clc/workitem/get_global_id.h; libclc/generic/include/clc/workitem/get_global_offset.h; libclc/generic/include/clc/workitem/get_global_size.h; libclc/generic/include/clc/workitem/get_group_id.h; libclc/generic/include/clc/workitem/get_local_id.h; libclc/generic/include/clc/workitem/get_local_size.h; libclc/generic/include/clc/workitem/get_num_groups.h; libclc/generic/include/clc/workitem/get_work_dim.h; libclc/generic/include/integer/popcount.h; libclc/generic/include/math/clc_exp10.h; libclc/generic/include/math/clc_fma.h; libclc/generic/include/math/clc_fmod.h; libclc/generic/include/math/clc_hypot.h; libclc/generic/include/math/clc_ldexp.h; libclc/generic/include/math/clc_nextafter.h; libclc/generic/include/math/clc_pow.h; libclc/generic/include/math/clc_pown.h; libclc/generic/include/math/clc_powr.h; libclc/generic/include/math/clc_remainder.h; libclc/generic/include/math/clc_remquo.h; libclc/generic/include/math/clc_rootn.h;,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:158264,synchroniz,synchronization,158264,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['synchroniz'],['synchronization']
Integrability,hMulticlass DEPENDS ${PyMVA-Torch-Multiclass-depends}). # Test RModelParser_PyTorch. ROOT_ADD_GTEST(TestRModelParserPyTorch TestRModelParserPyTorch.C; LIBRARIES; ROOTTMVASofie; TMVA; Python3::NumPy; Python3::Python; INCLUDE_DIRS; SYSTEM; ${CMAKE_CURRENT_BINARY_DIR}; ); target_link_libraries(TestRModelParserPyTorch ${BLAS_LINKER_FLAGS} ${BLAS_LIBRARIES}). endif(PY_TORCH_FOUND). if((PY_KERAS_FOUND AND PY_THEANO_FOUND) OR (PY_KERAS_FOUND AND PY_TENSORFLOW_FOUND)); configure_file(generateKerasModels.py generateKerasModels.py COPYONLY); configure_file(scale_by_2_op.hxx scale_by_2_op.hxx COPYONLY). if (PY_TORCH_FOUND); set(PyMVA-Keras-Classification-depends PyMVA-Torch-Classification); set(PyMVA-Keras-Regression-depends PyMVA-Torch-Regression); set(PyMVA-Keras-Multiclass-depends PyMVA-Torch-Multiclass); endif(). # Test PyKeras: Binary classification; ROOT_EXECUTABLE(testPyKerasClassification testPyKerasClassification.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-Keras-Classification COMMAND testPyKerasClassification DEPENDS ${PyMVA-Keras-Classification-depends}). # Test PyKeras: Regression; if (NOT ROOT_ARCHITECTURE MATCHES macosx); #veto also keras tutorial on macos due to issue in disabling eager execution on macos; ROOT_EXECUTABLE(testPyKerasRegression testPyKerasRegression.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-Keras-Regression COMMAND testPyKerasRegression DEPENDS ${PyMVA-Keras-Regression-depends}); endif(). # Test PyKeras: Multi-class classification; ROOT_EXECUTABLE(testPyKerasMulticlass testPyKerasMulticlass.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-Keras-Multiclass COMMAND testPyKerasMulticlass DEPENDS ${PyMVA-Keras-Multiclass-depends}). ROOT_ADD_GTEST(TestRModelParserKeras TestRModelParserKeras.C; LIBRARIES; ROOTTMVASofie; PyMVA; Python3::NumPy; Python3::Python; INCLUDE_DIRS; SYSTEM; ${CMAKE_CURRENT_BINARY_DIR}; ); target_link_libraries(TestRModelParserKeras ${BLAS_LINKER_FLAGS} ${BLAS_LIBRARIES}). endif((PY_KERAS_FOUND AND PY_THEANO_FOUND) OR (P,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/test/CMakeLists.txt:4492,depend,depends,4492,tmva/pymva/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/test/CMakeLists.txt,3,"['DEPEND', 'depend']","['DEPENDS', 'depends']"
Integrability,"handling, thread local; variables, and language runtime registration. Supporting these features enables; ORC to execute code generated from source languages which rely on these features; (e.g. C++ requires object format support for static initializers to support; static constructors, eh-frame registration for exceptions, and TLV support for; thread locals; Swift and Objective-C require language runtime registration for; many features). For some object format features support is provided entirely; within JITLink, and for others it is provided in cooperation with the; (prototype) ORC runtime. JITLink aims to support the following features, some of which are still under; development:. 1. Cross-process and cross-architecture linking of single relocatable objects; into a target *executor* process. 2. Support for all object format features. 3. Open linker data structures (``LinkGraph``) and pass system. JITLink and ObjectLinkingLayer; ==============================. ``ObjectLinkingLayer`` is ORCs wrapper for JITLink. It is an ORC layer that; allows objects to be added to a ``JITDylib``, or emitted from some higher level; program representation. When an object is emitted, ``ObjectLinkingLayer`` uses; JITLink to construct a ``LinkGraph`` (see :ref:`constructing_linkgraphs`) and; calls JITLink's ``link`` function to link the graph into the executor process. The ``ObjectLinkingLayer`` class provides a plugin API,; ``ObjectLinkingLayer::Plugin``, which users can subclass in order to inspect and; modify ``LinkGraph`` instances at link time, and react to important JIT events; (such as an object being emitted into target memory). This enables many features; and optimizations that were not possible under MCJIT or RuntimeDyld. ObjectLinkingLayer Plugins; --------------------------. The ``ObjectLinkingLayer::Plugin`` class provides the following methods:. * ``modifyPassConfig`` is called each time a LinkGraph is about to be linked. It; can be overridden to install JITLink *Passes* t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:1894,wrap,wrapper,1894,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['wrap'],['wrapper']
Integrability,"hape; alpha=0.5; RooPlot* frame = x.frame() ;; rlm.plotOn(frame) ;. In short the algorithm works as follows: for both f1(x) and f2(x), the cumulative distribution; functions F1(x) and F2(x) are calculated. One finds takes a value 'y' of both c.d.fs and ; determines the corresponding x values x1,x2 at which F1(x1)=F2(x2)=y. The value of the interpolated ; p.d.f fbar(x) is then calculated as fbar(alpha*x1+(1-alpha)*x2) = f1(x1)*f2(x2) / ( alpha*f2(x2) + ; (1-alpha)*f1(x1) ). Given that it is not easily possible to calculate the value of RooLinearMorph; at a given value of x, the value for all values of x are calculated in one by (through a scan over y); and stored in a cache. NB: The range of the interpolation parameter does not need to be [0,1], it can; be anything. New workspace tool RooSimWSTool. A new tool to clone and customize p.d.f.s into a RooSimultaneous p.d.f has been added. This new; tool succeeds the original RooSimPdfBuilder tool which had a similar functionality but; has a much cleaner interface, partly thanks to its use of the RooWorkspace class for both input; of prototype p.d.fs and output of built p.d.f.s. The simplest use case to to take a workspace p.d.f as prototype and 'split' a parameter of that p.d.f ; into two specialized parameters depending on a category in the dataset. ; For example, given a Gaussian p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'.; Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. . SplitParam(""m"",""c,d"")",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html:11642,interface,interface,11642,roofit/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html,2,['interface'],['interface']
Integrability,"hared objects which provide the actual computation functions. set(shared_object_sources src/RooBatchCompute.cxx src/ComputeFunctions.cxx). # Generic implementation for CPUs that don't support vector instruction sets.; ROOT_LINKER_LIBRARY(RooBatchCompute_GENERIC ${shared_object_sources} TYPE SHARED DEPENDENCIES RooBatchCompute); target_compile_options(RooBatchCompute_GENERIC PRIVATE ${common-flags} -DRF_ARCH=GENERIC). # Windows platform and ICC compiler need special code and testing, thus the feature has not been implemented yet for these.; if (ROOT_PLATFORM MATCHES ""linux|macosx"" AND CMAKE_SYSTEM_PROCESSOR MATCHES x86_64 AND CMAKE_CXX_COMPILER_ID MATCHES ""GNU|Clang""). target_compile_options(RooBatchCompute PRIVATE -DR__RF_ARCHITECTURE_SPECIFIC_LIBS). ROOT_LINKER_LIBRARY(RooBatchCompute_SSE4.1 ${shared_object_sources} TYPE SHARED DEPENDENCIES RooBatchCompute); ROOT_LINKER_LIBRARY(RooBatchCompute_AVX ${shared_object_sources} TYPE SHARED DEPENDENCIES RooBatchCompute); ROOT_LINKER_LIBRARY(RooBatchCompute_AVX2 ${shared_object_sources} TYPE SHARED DEPENDENCIES RooBatchCompute); ROOT_LINKER_LIBRARY(RooBatchCompute_AVX512 ${shared_object_sources} TYPE SHARED DEPENDENCIES RooBatchCompute). # Flags -fno-signaling-nans, -fno-trapping-math and -O3 are necessary to enable autovectorization (especially for GCC).; set(common-flags $<$<CXX_COMPILER_ID:GNU>:-fno-signaling-nans>); list(APPEND common-flags $<$<OR:$<CONFIG:Release>,$<CONFIG:RelWithDebInfo>>: -fno-trapping-math -O3>). target_compile_options(RooBatchCompute_SSE4.1 PRIVATE ${common-flags} -msse4 -DRF_ARCH=SSE4); target_compile_options(RooBatchCompute_AVX PRIVATE ${common-flags} -mavx -DRF_ARCH=AVX); target_compile_options(RooBatchCompute_AVX2 PRIVATE ${common-flags} -mavx2 -DRF_ARCH=AVX2); target_compile_options(RooBatchCompute_AVX512 PRIVATE ${common-flags} -march=skylake-avx512 -DRF_ARCH=AVX512). endif() # vector versions of library. if (cuda); set(shared_object_sources_cu src/RooBatchCompute.cu src/ComputeFunctions.cu s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/CMakeLists.txt:1417,DEPEND,DEPENDENCIES,1417,roofit/batchcompute/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/CMakeLists.txt,4,['DEPEND'],['DEPENDENCIES']
Integrability,"hase.; A standalone version of VMC is being developed at [https://github.com/vmc-project/vmc](https://github.com/vmc-project/vmc); to replace the deprecated version in ROOT. ### Removed packages. Support for the following optional components of ROOT has been removed:. * afdsmgrd (Dataset manager for PROOF-based analysis facilities); * bonjour (Avahi/Bonjour/Zeroconf); * castor (CERN Advanced STORage manager); * geocad (OpenCascade); * globus (Globus authentication); * hdfs (Hadoop Distributed File System); * krb5 (Kerberos 5 authentication); * ldap (OpenLDAP authentication); * memstat (legacy memory statistics utility); * qt, qtgsi, qtroot (Qt4-based GUI components); * rfio (Remote File IO for CASTOR); * table (libTable contrib library). In addition, the following deprecated parts of ROOT components have been; removed:. * PROOF's PQ2 module; * `THttpServer::ExecuteHttp()` and `THttpServer::SubmitHttp` from `THttpServer`. ### Other changes. The deprecation of the GraphViz integration has been reverted since the code is; still in use. The ODBC interface, deprecated in ROOT 6.16, is no longer deprecated in ROOT 6.18.; It is the main option to support databases on Windows, so the decision to deprecate; it was reverted. The `xft` option has been merged into `x11` and is no longer used (its value is; now ignored by ROOT). ## Preprocessor deprecation macros; ### Deprecated Classes; * `R__SUGGEST_ALTERNATIVE(""Suggestion text"")` macro allows to suggest alternatives to classes. It must be used after the class definition and before the final semicolon:; ```{.cpp}; class DoNotUseClass {; } R__SUGGEST_ALTERNATIVE(""Use ... instead."");; ```; It is activated by the preprocessor defines `R__SUGGEST_NEW_INTERFACE`. The former is useful when deprecation warnings should be activated/deactivated at global level, for example for an entire project. This could be done by defining `R__SUGGEST_NEW_INTERFACE` in the build system. ; If the warning needs to be confined within single translation ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md:2555,integrat,integration,2555,README/ReleaseNotes/v618/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md,1,['integrat'],['integration']
Integrability,"hat accesses private); provided the other operation's sync scope is:. - ``system``, ``agent`` or ``workgroup`` and; executed by a thread in the same work-group.; - ``wavefront`` and executed by a thread in the; same wavefront. ``wavefront`` Synchronizes with, and participates in modification; and seq_cst total orderings with, other operations; (except image operations) for all address spaces; (except private, or generic that accesses private); provided the other operation's sync scope is:. - ``system``, ``agent``, ``workgroup`` or; ``wavefront`` and executed by a thread in the; same wavefront. ``singlethread`` Only synchronizes with and participates in; modification and seq_cst total orderings with,; other operations (except image operations) running; in the same thread for all address spaces (for; example, in signal handlers). ``one-as`` Same as ``system`` but only synchronizes with other; operations within the same address space. ``agent-one-as`` Same as ``agent`` but only synchronizes with other; operations within the same address space. ``workgroup-one-as`` Same as ``workgroup`` but only synchronizes with; other operations within the same address space. ``wavefront-one-as`` Same as ``wavefront`` but only synchronizes with; other operations within the same address space. ``singlethread-one-as`` Same as ``singlethread`` but only synchronizes with; other operations within the same address space.; ======================= ===================================================. LLVM IR Intrinsics; ------------------. The AMDGPU backend implements the following LLVM IR intrinsics. *This section is WIP.*. .. table:: AMDGPU LLVM IR Intrinsics; :name: amdgpu-llvm-ir-intrinsics-table. ============================================== ==========================================================; LLVM Intrinsic Description; ============================================== ==========================================================; llvm.amdgcn.sqrt Provides direct access to v_sqrt_f64, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:34848,synchroniz,synchronizes,34848,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['synchroniz'],['synchronizes']
Integrability,"hat an operation is not accepted according to a corresponding; specification. ============================== ======= ======= ============= ======= =====; Operator OpenCL AltiVec GCC NEON SVE; ============================== ======= ======= ============= ======= =====; [] yes yes yes yes yes; unary operators +, -- yes yes yes yes yes; ++, -- -- yes yes yes no no; +,--,*,/,% yes yes yes yes yes; bitwise operators &,|,^,~ yes yes yes yes yes; >>,<< yes yes yes yes yes; !, &&, || yes -- yes yes yes; ==, !=, >, <, >=, <= yes yes yes yes yes; = yes yes yes yes yes; ?: [#]_ yes -- yes yes yes; sizeof yes yes yes yes yes [#]_; C-style cast yes yes yes no no; reinterpret_cast yes no yes no no; static_cast yes no yes no no; const_cast no no no no no; address &v[i] no no no [#]_ no no; ============================== ======= ======= ============= ======= =====. See also :ref:`langext-__builtin_shufflevector`, :ref:`langext-__builtin_convertvector`. .. [#] ternary operator(?:) has different behaviors depending on condition; operand's vector type. If the condition is a GNU vector (i.e. __vector_size__),; a NEON vector or an SVE vector, it's only available in C++ and uses normal bool; conversions (that is, != 0).; If it's an extension (OpenCL) vector, it's only available in C and OpenCL C.; And it selects base on signedness of the condition operands (OpenCL v1.1 s6.3.9).; .. [#] sizeof can only be used on vector length specific SVE types.; .. [#] Clang does not allow the address of an element to be taken while GCC; allows this. This is intentional for vectors with a boolean element type and; not implemented otherwise. Vector Builtins; ---------------. **Note: The implementation of vector builtins is work-in-progress and incomplete.**. In addition to the operators mentioned above, Clang provides a set of builtins; to perform additional operations on certain scalar and vector types. Let ``T`` be one of the following types:. * an integer type (as in C23 6.2.5p22), but excluding enumer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:20085,depend,depending,20085,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['depend'],['depending']
Integrability,"hat constant folding in various; ways turns into a tree walk that needs to handle the various cases. However, there are places in both C and C++ that require constants to be; folded. For example, the C standard defines what an ""integer constant; expression"" (i-c-e) is with very precise and specific requirements. The; language then requires i-c-e's in a lot of places (for example, the size of a; bitfield, the value for a case statement, etc). For these, we have to be able; to constant fold the constants, to do semantic checks (e.g., verify bitfield; size is non-negative and that case statements aren't duplicated). We aim for; Clang to be very pedantic about this, diagnosing cases when the code does not; use an i-c-e where one is required, but accepting the code unless running with; ``-pedantic-errors``. Things get a little bit more tricky when it comes to compatibility with; real-world source code. Specifically, GCC has historically accepted a huge; superset of expressions as i-c-e's, and a lot of real world code depends on; this unfortunate accident of history (including, e.g., the glibc system; headers). GCC accepts anything its ""fold"" optimizer is capable of reducing to; an integer constant, which means that the definition of what it accepts changes; as its optimizer does. One example is that GCC accepts things like ""``case; X-X:``"" even when ``X`` is a variable, because it can fold this to 0. Another issue are how constants interact with the extensions we support, such; as ``__builtin_constant_p``, ``__builtin_inf``, ``__extension__`` and many; others. C99 obviously does not specify the semantics of any of these; extensions, and the definition of i-c-e does not include them. However, these; extensions are often used in real code, and we have to have a way to reason; about them. Finally, this is not just a problem for semantic analysis. The code generator; and other clients have to be able to fold constants (e.g., to initialize global; variables) and have to handle",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:119607,depend,depends,119607,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['depend'],['depends']
Integrability,"hat having a; ptrtoint or inttoptr cast (which is common for such use cases) breaks the; rules used for inferring base pointers for arbitrary references when; lowering out of the abstract model to the explicit physical model. Note; that a frontend which lowers directly to the physical model doesn't have; any problems here. Objects on the Stack; ^^^^^^^^^^^^^^^^^^^^. As noted above, the explicit lowering supports objects allocated on the; stack provided the collector can find a heap map given the stack address. The missing pieces are a) integration with rewriting (RS4GC) from the; abstract machine model and b) support for optionally decomposing on stack; objects so as not to require heap maps for them. The later is required; for ease of integration with some collectors. Lowering Quality and Representation Overhead; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The current statepoint lowering is known to be somewhat poor. In the very; long term, we'd like to integrate statepoints with the register allocator;; in the near term this is unlikely to happen. We've found the quality of; lowering to be relatively unimportant as hot-statepoints are almost always; inliner bugs. Concerns have been raised that the statepoint representation results in a; large amount of IR being produced for some examples and that this; contributes to higher than expected memory usage and compile times. There's; no immediate plans to make changes due to this, but alternate models may be; explored in the future. Relocations Along Exceptional Edges; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Relocations along exceptional paths are currently broken in ToT. In; particular, there is current no way to represent a rethrow on a path which; also has relocations. See `this llvm-dev discussion; <https://groups.google.com/forum/#!topic/llvm-dev/AE417XjgxvI>`_ for more; detail. Bugs and Enhancements; =====================. Currently known bugs and enhancements under consideration can be; tracked by performing a `bu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:35453,integrat,integrate,35453,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['integrat'],['integrate']
Integrability,"hat initializes/serializes the option class (in our case; ``CodeGenOptions``) stored within ``CompilerInvocation``. This can be done; automatically by using the marshalling annotations on the option definition:. .. code-block:: diff. // Options.td. def fpass_plugin_EQ : Joined<[""-""], ""fpass-plugin="">,; Group<f_Group>, Flags<[CC1Option]>,; HelpText<""Load pass plugin from a dynamic shared object file."">,; + MarshallingInfoStringVector<CodeGenOpts<""PassPlugins"">>;. Inner workings of the system are introduced in the :ref:`marshalling; infrastructure <OptionMarshalling>` section and the available annotations are; listed :ref:`here <OptionMarshallingAnnotations>`. In case the marshalling infrastructure does not support the desired semantics,; consider simplifying it to fit the existing model. This makes the command line; more uniform and reduces the amount of custom, manually written code. Remember; that the ``-cc1`` command line interface is intended only for Clang developers,; meaning it does not need to mirror the driver interface, maintain backward; compatibility or be compatible with GCC. If the option semantics cannot be encoded via marshalling annotations, you can; resort to parsing/serializing the command line arguments manually:. .. code-block:: diff. // CompilerInvocation.cpp. static bool ParseCodeGenArgs(CodeGenOptions &Opts, ArgList &Args /*...*/) {; // ... + Opts.PassPlugins = Args.getAllArgValues(OPT_fpass_plugin_EQ);; }. static void GenerateCodeGenArgs(const CodeGenOptions &Opts,; SmallVectorImpl<const char *> &Args,; CompilerInvocation::StringAllocator SA /*...*/) {; // ... + for (const std::string &PassPlugin : Opts.PassPlugins); + GenerateArg(Args, OPT_fpass_plugin_EQ, PassPlugin, SA);; }. Finally, you can specify the argument on the command line:; ``clang -fpass-plugin=a -fpass-plugin=b`` and use the new member variable as; desired. .. code-block:: diff. void EmitAssemblyHelper::EmitAssemblyWithNewPassManager(/*...*/) {; // ...; + for (auto &PluginFN : ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:32748,interface,interface,32748,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,2,['interface'],['interface']
Integrability,"hat it is functional makes it ""too easy"" to generate LLVM IR for it. In; particular, a functional language makes it very easy to build LLVM IR; directly in `SSA; form <http://en.wikipedia.org/wiki/Static_single_assignment_form>`_.; Since LLVM requires that the input code be in SSA form, this is a very; nice property and it is often unclear to newcomers how to generate code; for an imperative language with mutable variables. The short (and happy) summary of this chapter is that there is no need; for your front-end to build SSA form: LLVM provides highly tuned and; well tested support for this, though the way it works is a bit; unexpected for some. Why is this a hard problem?; ===========================. To understand why mutable variables cause complexities in SSA; construction, consider this extremely simple C example:. .. code-block:: c. int G, H;; int test(_Bool Condition) {; int X;; if (Condition); X = G;; else; X = H;; return X;; }. In this case, we have the variable ""X"", whose value depends on the path; executed in the program. Because there are two different possible values; for X before the return instruction, a PHI node is inserted to merge the; two values. The LLVM IR that we want for this example looks like this:. .. code-block:: llvm. @G = weak global i32 0 ; type of @G is i32*; @H = weak global i32 0 ; type of @H is i32*. define i32 @test(i1 %Condition) {; entry:; br i1 %Condition, label %cond_true, label %cond_false. cond_true:; %X.0 = load i32, i32* @G; br label %cond_next. cond_false:; %X.1 = load i32, i32* @H; br label %cond_next. cond_next:; %X.2 = phi i32 [ %X.1, %cond_false ], [ %X.0, %cond_true ]; ret i32 %X.2; }. In this example, the loads from the G and H global variables are; explicit in the LLVM IR, and they live in the then/else branches of the; if statement (cond\_true/cond\_false). In order to merge the incoming; values, the X.2 phi node in the cond\_next block selects the right value; to use based on where control flow is coming from: if",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:1751,depend,depends,1751,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['depend'],['depends']
Integrability,"hat still applies one can also edit drawn geometry objects. For this,; the menu entry View/Editor of the canvas containing for instance a drawn; volume must be activated. For starting the volume editor one can click; on a volume. The GUI of the **`TGeoManager`** class can be started by; clicking on the top-right `40x40` pixels corner of the pad with a drawn; geometry. This is the main entry point for editing the geometry or creating new; objects. Once the interface is created (using one of the methods; described above), several categories can be accessed via a shutter GUI; widget:. - *General.* This allows changing the name/title of the geometry,; setting the top volume, closing the geometry and saving the geometry; in a file. The file name is formed by `geometry_name.C` or `.root`; depending if the geometry need to be saved as a `C` macro or a; `.root` file.; - *Shapes.* The category provides buttons for creation of all; supported shapes. The new shape name is chosen by the interface, but; can be changed from the shape editor GUI. Existing shapes can be; browsed and edited from the same category.; - *Volumes.* The category allows the creation of a new volume having a; given name, shape and medium. For creating a volume assembly only; the name is relevant. Existing volumes can be browsed or edited from; this category.; - *Materials.* Allows creation of new materials/mixtures or editing; existing ones.; - *Media.* The same for creation/editing of tracking media (materials; having a set of properties related to tracking); - *Matrices.* Allows creation of translations, rotations or combined; transformations. Existing matrices can also be browser/edited. ### Editing Existing Objects. For editing an existing object from one of the categories described; above, the interface imposes first a selection among all objects of the; corresponding type stored in the geometry. This can be done by clicking; the button next to the blue label *Select \<object\>*. The dialog; interface",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:168244,interface,interface,168244,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['interface'],['interface']
Integrability,"hat you want is to have a native compiler to the; platform itself, but not others. So there's rarely a point in compiling; all back-ends. For that reason, you should also set the; ``TARGETS_TO_BUILD`` to only build the back-end you're targeting to. You must set the ``CMAKE_INSTALL_PREFIX``, otherwise a ``ninja install``; will copy ARM binaries to your root filesystem, which is not what you; want. Hacks; -----. There are some bugs in current LLVM, which require some fiddling before; running CMake:. #. If you're using Clang as the cross-compiler, there is a problem in; the LLVM ARM back-end that is producing absolute relocations on; position-independent code (``R_ARM_THM_MOVW_ABS_NC``), so for now, you; should disable PIC:. .. code-block:: bash. -DLLVM_ENABLE_PIC=False. This is not a problem, since Clang/LLVM libraries are statically; linked anyway, it shouldn't affect much. #. The ARM libraries won't be installed in your system.; But the CMake prepare step, which checks for; dependencies, will check the *host* libraries, not the *target*; ones. Below there's a list of some dependencies, but your project could; have more, or this document could be outdated. You'll see the errors; while linking as an indication of that. Debian based distros have a way to add ``multiarch``, which adds; a new architecture and allows you to install packages for those; systems. See https://wiki.debian.org/Multiarch/HOWTO for more info. But not all distros will have that, and possibly not an easy way to; install them in any anyway, so you'll have to build/download; them separately. A quick way of getting the libraries is to download them from; a distribution repository, like Debian (http://packages.debian.org/jessie/),; and download the missing libraries. Note that the ``libXXX``; will have the shared objects (``.so``) and the ``libXXX-dev`` will; give you the headers and the static (``.a``) library. Just in; case, download both. The ones you need for ARM are: ``libtinfo``, ``zlib1g``,; ``l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileLLVM.rst:4773,depend,dependencies,4773,interpreter/llvm-project/llvm/docs/HowToCrossCompileLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileLLVM.rst,1,['depend'],['dependencies']
Integrability,"hat's been `git add`ed:; git clang-format. To also format everything touched in the most recent commit:; git clang-format HEAD~1. If you're on a branch off main, to format everything touched on your branch:; git clang-format main. If two commits are given (requires --diff), run clang-format on all lines in the; second <commit> that differ from the first <commit>. The following git-config settings set the default of the corresponding option:; clangFormat.binary; clangFormat.commit; clangFormat.extensions; clangFormat.style. positional arguments:; <commit> revision from which to compute the diff; <file>... if specified, only consider differences in these files. optional arguments:; -h, --help show this help message and exit; --binary BINARY path to clang-format; --commit COMMIT default commit to use if none is specified; --diff print a diff instead of applying the changes; --diffstat print a diffstat instead of applying the changes; --extensions EXTENSIONS; comma-separated list of file extensions to format, excluding the period and case-insensitive; -f, --force allow changes to unstaged files; -p, --patch select hunks interactively; -q, --quiet print less information; --staged, --cached format lines in the stage instead of the working dir; --style STYLE passed to clang-format; -v, --verbose print extra information. Script for patch reformatting; =============================. The python script `clang/tools/clang-format/clang-format-diff.py` parses the; output of a unified diff and reformats all contained lines with; :program:`clang-format`. .. code-block:: console. usage: clang-format-diff.py [-h] [-i] [-p NUM] [-regex PATTERN] [-iregex PATTERN] [-sort-includes] [-v] [-style STYLE]; [-fallback-style FALLBACK_STYLE] [-binary BINARY]. This script reads input from a unified diff and reformats all the changed; lines. This is useful to reformat all the lines touched by a specific patch.; Example usage for git/svn users:. git diff -U0 --no-color --relative HEAD^ | clang-form",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst:11442,message,message,11442,interpreter/llvm-project/clang/docs/ClangFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst,1,['message'],['message']
Integrability,"haviour in wildcard import; * [[#7644](https://github.com/root-project/root/issues/7644)] - Provide in the cmake configuration the C++ standard which was used to compile ROOT; * [[#7627](https://github.com/root-project/root/issues/7627)] - Fix TMVA group links; * [[#7159](https://github.com/root-project/root/issues/7159)] - TNetXNGFile::Open fails with double slash (//) in path; * [[#7128](https://github.com/root-project/root/issues/7128)] - Cannot build ROOT if another ROOT at /usr/local; * [[#6900](https://github.com/root-project/root/issues/6900)] - mathmore: invalid roots for a quartic polynomial; * [[#6811](https://github.com/root-project/root/issues/6811)] - Bug displaying several 3D objects such as TGraph2D on the same canvas ; * [[#6755](https://github.com/root-project/root/issues/6755)] - Greek letter epsilon not rendered correctly using TLatex with OpenGL.CanvasPreferGL option, segmentation fault.; * [[#6753](https://github.com/root-project/root/issues/6753)] - CMake dependency on Python: use targets; * [[#6616](https://github.com/root-project/root/issues/6616)] - hadd writes files with unspecified compression algorithm; * [[#6438](https://github.com/root-project/root/issues/6438)] - hadd --help prints wrong usage info; * [[#6384](https://github.com/root-project/root/issues/6384)] - cxx-standard should not be in CMAKE_CXX_FLAGS; * [[ROOT-3358](https://its.cern.ch/jira/browse/ROOT-3358)] - SetRootSys() improperly sets $ROOTSYS; * [[ROOT-6424](https://its.cern.ch/jira/browse/ROOT-6424)] - Bogus template names suggested by autocompletion; * [[ROOT-6581](https://its.cern.ch/jira/browse/ROOT-6581)] - .x stress.cxx(1) broken; * [[ROOT-6713](https://its.cern.ch/jira/browse/ROOT-6713)] - Root attempts to stream null pointers to abstract classes; * [[ROOT-6867](https://its.cern.ch/jira/browse/ROOT-6867)] - forward declaration 'payload' inadvertently (?) unloaded; * [[ROOT-7280](https://its.cern.ch/jira/browse/ROOT-7280)] - Memory leaks due to erroneous use of Expand",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:49800,depend,dependency,49800,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['depend'],['dependency']
Integrability,"he ""Undo"" does not allow restoring an; intermediate state of the parameters that was applied - it will always; restore the parameters at the moment the shape was edited. All material properties changes are undoable. The mixture editor; currently allows adding elements one by one in the mixture composition.; This can be done either by element weight fraction or by number of; atoms. Once an element was added using one method the other method is not; selectable anymore. Summing component fractions up to 1 in the final; mixture is the user responsibility. Adding materials as components of a; mixture is not supported in this version. The elements that were added to the mixture appear in the bottom of the; mixture editor. The operations performed on mixture are not undoable. \anchor GP08d; ### Creation of New Objects. As described above, all geometry object creators are accessible within; the geometry manager editor frame. Generally, if the new object that; needs to be created does not depend on other objects, it will be built; with a set of default parameters. This is the case for all shapes; (except composite shapes) and matrices. For all the other objects the; interface forces the selection of components before creating the object. \anchor GP08e; ### Editing Volumes. Volumes are hierarchical components in the geometry, therefore their; editor is more complex. It provides the following functionalities:. - *General*. This category allows changing the name of the volume and; selecting other shape or medium among existing ones. - *Daughters*. The category allows removing existing daughter nodes or; adding new ones. The button ""Position"" allows editing the; positioning matrix of a given node. \image html geometry022.jpg width=600px; \image html geometry023.jpg ""Setting volume properties and modifying volume hierarchy"" width=600px. - *Visualization*. This category allows changing the visibility of the; edited volume or for its daughters, as well as other visualization; settin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:131914,depend,depend,131914,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['depend'],['depend']
Integrability,"he `ClassDef` support, `ClassDefInline(ClassName, Version)` now provides it without the need for a dictionary source: all members injected by this `ClassDef` flavor are generated by the interpreter. ### `TObjString` to `TString`. `TObjString::GetString()` now returns a `const TString&` to the `TString` inside the `TObjString`, instead of copying it.; This is to prevent very common misunderstanding of the interface. In several cases, the misunderstanding of the interface caused invalid memory accesses to the already destructed; temporary `TString` returned by `GetString()`, e.g. `objStr->GetString().Data()`. This will be fixed automatically by the; new return type. In rare cases, the caller expected `GetString()` to return a (non-const) reference to the embedded `TString`, e.g.; `objString->GetString().ReplaceAll(""a"", ""b""); // WRONG!` This will now fail to compile, instead of not doing what the author of the; code expected. Please fix that code by using the `TObjString::String()` interface, which returns a non-const `TString&`:; `objString->String().ReplaceAll(""a"", ""b"");`. In extremely rare cases, this change breaks a valid use where the temporary `TString` was modified and then captured in a new `TString`; object before the destruction of the temporary: `TString str = objStr->GetString().ReplaceAll(""a"", ""b"");`. In these rare cases,; please use the new function `CopyString()` which clearly indicates that it involves a temporary. ## Histogram Libraries. - New class `THnChain` was added to provide a `TChain`-like experience when; working with `THnBase`'ed histograms (currently `THn` and `THnSparse`) from; many files, see [here](https://sft.its.cern.ch/jira/browse/ROOT-4515). This; allows to e.g., interactively adjust axis parameters before performing; projections from high-dimensional histograms,. ```{.cpp}; // Create a chain of histograms called `h`.; THnChain chain(""h"");. // Add files containing histograms `h` to `chain`.; chain->AddFile(""file1.root"");. chain->GetXaxi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md:3754,interface,interface,3754,README/ReleaseNotes/v610/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md,1,['interface'],['interface']
Integrability,"he ``@path/to/file.rsp`` syntax. Arguments read from a file must; be one per line and are treated as if they were in the same place as the; original file referencing argument on the command line. A response file can; reference other response files. Users interested in the :program:`lit` architecture or designing a; :program:`lit` testing implementation should see :ref:`lit-infrastructure`. GENERAL OPTIONS; ---------------. .. option:: -h, --help. Show the :program:`lit` help message. .. option:: -j N, --workers=N. Run ``N`` tests in parallel. By default, this is automatically chosen to; match the number of detected available CPUs. .. option:: --config-prefix=NAME. Search for :file:`{NAME}.cfg` and :file:`{NAME}.site.cfg` when searching for; test suites, instead of :file:`lit.cfg` and :file:`lit.site.cfg`. .. option:: -D NAME[=VALUE], --param NAME[=VALUE]. Add a user defined parameter ``NAME`` with the given ``VALUE`` (or the empty; string if not given). The meaning and use of these parameters is test suite; dependent. .. _output-options:. OUTPUT OPTIONS; --------------. .. option:: -q, --quiet. Suppress any output except for test failures. .. option:: -s, --succinct. Show less output, for example don't show information on tests that pass.; Also show a progress bar, unless ``--no-progress-bar`` is specified. .. option:: -v, --verbose. Show more information on test failures, for example the entire test output; instead of just the test result. Each command is printed before it is executed. This can be valuable for; debugging test failures, as the last printed command is the one that failed.; Moreover, :program:`lit` inserts ``'RUN: at line N'`` before each; command pipeline in the output to help you locate the source line of; the failed command. .. option:: -vv, --echo-all-commands. Deprecated alias for -v. .. option:: -a, --show-all. Enable -v, but for all tests not just failed tests. .. option:: --no-progress-bar. Do not use curses based progress bar. .. option:: --s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:2950,depend,dependent,2950,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['depend'],['dependent']
Integrability,"he ``TargetFrameLowering`` class; ---------------------------------. The ``TargetFrameLowering`` class is used to provide information about the stack; frame layout of the target. It holds the direction of stack growth, the known; stack alignment on entry to each function, and the offset to the local area.; The offset to the local area is the offset from the stack pointer on function; entry to the first location where function data (local variables, spill; locations) can be stored. The ``TargetSubtarget`` class; -----------------------------. The ``TargetSubtarget`` class is used to provide information about the specific; chip set being targeted. A sub-target informs code generation of which; instructions are supported, instruction latencies and instruction execution; itinerary; i.e., which processing units are used, in what order, and for how; long. The ``TargetJITInfo`` class; ---------------------------. The ``TargetJITInfo`` class exposes an abstract interface used by the; Just-In-Time code generator to perform target-specific activities, such as; emitting stubs. If a ``TargetMachine`` supports JIT code generation, it should; provide one of these objects through the ``getJITInfo`` method. .. _code being generated:; .. _machine code representation:. Machine code description classes; ================================. At the high-level, LLVM code is translated to a machine specific representation; formed out of :raw-html:`<tt>` `MachineFunction`_ :raw-html:`</tt>`,; :raw-html:`<tt>` `MachineBasicBlock`_ :raw-html:`</tt>`, and :raw-html:`<tt>`; `MachineInstr`_ :raw-html:`</tt>` instances (defined in; ``include/llvm/CodeGen``). This representation is completely target agnostic,; representing instructions in their most abstract form: an opcode and a series of; operands. This representation is designed to support both an SSA representation; for machine code, as well as a register allocated, non-SSA form. .. _MachineInstr:. The ``MachineInstr`` class; --------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:14892,interface,interface,14892,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['interface'],['interface']
Integrability,"he build process needs them.; You may also need to install ``wheel`` first if you have an older version of; ``pip`` and/or do not use virtualenv (which installs wheel by default).; Example::. $ python -m pip install wheel --user; $ PATH=$HOME/.local/bin:$PATH python -m pip install cppyy --user. Wheels on PyPI; --------------. Wheels for the backend (``cppyy-cling``) are available on PyPI for GNU/Linux,; MacOS-X, and MS Windows (both 32b and 64b).; The Linux wheels are built for manylinux2014, but with the dual ABI enabled.; The wheels for MS Windows were build with MSVC Community Edition 2017. There are no wheels for the ``CPyCppyy`` and ``cppyy`` packages, to allow; the C++ standard chosen to match the local compiler. pip with conda; --------------. Although installing ``cppyy`` through `conda-forge`_ is recommended, it is; possible to build/install with ``pip`` under Anaconda/miniconda. Typical Python extensions only expose a C interface for use through the; Python C-API, requiring only calling conventions (and the Python C-API; version, of course) to match to be binary compatible.; Here, cppyy differs because it exposes C++ APIs: it thus requires a C++; run-time that is ABI compatible with the C++ compiler that was used during; build-time. A set of modern compilers is available through conda-forge, but are only; intended for use with ``conda-build``.; In particular, the corresponding run-time is installed (for use through rpath; when building), but not set up.; That is, the conda compilers are added to ``PATH`` but not their libraries; to ``LD_LIBRARY_PATH`` (Mac, Linux; ``PATH`` for both on MS Windows).; Thus, you get the conda compilers and your system libraries mixed in the same; build environment, unless you set ``LD_LIBRARY_PATH`` (``PATH`` on Windows); explicitly, e.g. by adding ``$CONDA_PREFIX/lib``.; Note that the conda documentation recommends against this.; Furthermore, the compilers from conda-forge are not vanilla distributions:; header files have been",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/installation.rst:3295,interface,interface,3295,bindings/pyroot/cppyy/cppyy/doc/source/installation.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/installation.rst,1,['interface'],['interface']
Integrability,"he burden to add; things to the LLVM monorepo needs to be very high - code that is added to this; repository is checked out by everyone in the community. As such, we hold; components to a high bar similar to ""official targets"", they:. * Must be generally aligned with the mission of the LLVM project to advance; compilers, languages, tools, runtimes, etc.; * Must conform to all of the policies laid out in this developer policy; document, including license, patent, coding standards, and code of conduct.; * Must have an active community that maintains the code, including established; code owners.; * Should have reasonable documentation about how it works, including a high; quality README file.; * Should have CI to catch breakage within the project itself or due to; underlying LLVM dependencies.; * Should have code free of issues the community finds contentious, or be on a; clear path to resolving them.; * Must be proposed through the LLVM RFC process, and have its addition approved; by the LLVM community - this ultimately mediates the resolution of the; ""should"" concerns above. If you have a project that you think would make sense to add to the LLVM; monorepo, please start an RFC topic on the `LLVM Discourse forums`_ to kick off; the discussion. This process can take some time and iteration - please don’t; be discouraged or intimidated by that!. If you have an earlier stage project that you think is aligned with LLVM, please; see the ""Incubating New Projects"" section. Incubating New Projects; -----------------------. The burden to add a new project to the LLVM monorepo is intentionally very high,; but that can have a chilling effect on new and innovative projects. To help; foster these sorts of projects, LLVM supports an ""incubator"" process that is; much easier to get started with. It provides space for potentially valuable,; new top-level and sub-projects to reach a critical mass before they have enough; code to prove their utility and grow a community. This also allows",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:46596,mediat,mediates,46596,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['mediat'],['mediates']
Integrability,"he case where; the tree is in the top level directory. The file should not contain; sub-directories. Before switching to a new file, the tree header is; written to the current file, then the current file is closed. To process; the multiple files created by `ChangeFile()`, one must use a; **`TChain`**. The new file name has a suffix ""`_N`"" where `N` is equal to; `fFileNumber+1`. By default a Root session starts with `fFileNumber=0`.; One can set `fFileNumber` to a different value via; `TTree::SetFileNumber()`. In case a file named ""`_N`"" already exists,; the function will try a file named ""`__N`"", then ""`___N`"", etc. The; maximum tree size can be set via the static function; `TTree::SetMaxTreeSize()`. The default value of `fgMaxTreeSize` is 100; GB. If the current file contains other objects (like **`TH1`** and; **`TTree`**), these objects are automatically moved to the new file. ### User Info Attached to a TTree Object. The function `TTree::GetUserInfo()` allows adding any object defined by; a user to the tree that is not depending on the entry number. For; example:. ``` {.cpp}; tree->GetUserInfo()->Add(myruninfo);; ```. ### Indexing a Tree. Use `TTree::BuildIndex()`, to build an index table using expressions; depending on the value in the leaves. ``` {.cpp}; tree->BuildIndex(majorname, minorname);; ```. The index is built in the following way:. - a pass on all entries is made like in `TTree::Draw()`; - `var1 = majorname`; - `var2 = minorname`; - `sel = ` $2^{31} \times majorname + minorname$; - for each entry in the tree the sel expression is evaluated and the; results array is sorted into `fIndexValues`. Once the index is computed, using the; `TTree::GetEntryWithIndex(majornumber, minornumber)` one entry can be; retrieved. Example:. ``` {.cpp}; // to create an index using leaves Run and Event; tree.BuildIndex(""Run"",""Event"");; // to read entry corresponding to Run=1234 and Event=56789; tree.GetEntryWithIndex(1234,56789);; ```. Note that `majorname` and `minorname` m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:16252,depend,depending,16252,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['depend'],['depending']
Integrability,"he column limit. A column limit of ``0`` means that there is no column limit. In this case,; clang-format will respect the input's line breaking decisions within; statements unless they contradict other rules. .. _CommentPragmas:. **CommentPragmas** (``String``) :versionbadge:`clang-format 3.7` :ref:`¶ <CommentPragmas>`; A regular expression that describes comments with special meaning,; which should not be split into lines or otherwise changed. .. code-block:: c++. // CommentPragmas: '^ FOOBAR pragma:'; // Will leave the following line unaffected; #include <vector> // FOOBAR pragma: keep. .. _CompactNamespaces:. **CompactNamespaces** (``Boolean``) :versionbadge:`clang-format 5` :ref:`¶ <CompactNamespaces>`; If ``true``, consecutive namespace declarations will be on the same; line. If ``false``, each namespace is declared on a new line. .. code-block:: c++. true:; namespace Foo { namespace Bar {; }}. false:; namespace Foo {; namespace Bar {; }; }. If it does not fit on a single line, the overflowing namespaces get; wrapped:. .. code-block:: c++. namespace Foo { namespace Bar {; namespace Extra {; }}}. .. _ConstructorInitializerAllOnOneLineOrOnePerLine:. **ConstructorInitializerAllOnOneLineOrOnePerLine** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <ConstructorInitializerAllOnOneLineOrOnePerLine>`; This option is **deprecated**. See ``CurrentLine`` of; ``PackConstructorInitializers``. .. _ConstructorInitializerIndentWidth:. **ConstructorInitializerIndentWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <ConstructorInitializerIndentWidth>`; The number of characters to use for indentation of constructor; initializer lists as well as inheritance lists. .. _ContinuationIndentWidth:. **ContinuationIndentWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <ContinuationIndentWidth>`; Indent width for line continuations. .. code-block:: c++. ContinuationIndentWidth: 2. int i = // VeryVeryVeryVeryVeryLongComment; longFunction( // Again a lon",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:57854,wrap,wrapped,57854,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['wrap'],['wrapped']
Integrability,"he corresponding function call. Given Mod/Ref information; ``MRI`` for a memory location ``Loc``, ``MRI`` can be refined with a statement; like ``MRI &= AA.getModRefInfoMask(Loc);``. Another useful idiom is; ``isModSet(AA.getModRefInfoMask(Loc))``; this checks to see if the given; location can be modified at all. For convenience, there is also a method; ``pointsToConstantMemory(Loc)``; this is synonymous with; ``isNoModRef(AA.getModRefInfoMask(Loc))``. .. _never access memory or only read memory:. The ``doesNotAccessMemory`` and ``onlyReadsMemory`` methods; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. These methods are used to provide very simple mod/ref information for function; calls. The ``doesNotAccessMemory`` method returns true for a function if the; analysis can prove that the function never reads or writes to memory, or if the; function only reads from constant memory. Functions with this property are; side-effect free and only depend on their input arguments, allowing them to be; eliminated if they form common subexpressions or be hoisted out of loops. Many; common functions behave this way (e.g., ``sin`` and ``cos``) but many others do; not (e.g., ``acos``, which modifies the ``errno`` variable). The ``onlyReadsMemory`` method returns true for a function if analysis can prove; that (at most) the function only reads from non-volatile memory. Functions with; this property are side-effect free, only depending on their input arguments and; the state of memory when they are called. This property allows calls to these; functions to be eliminated and moved around, as long as there is no store; instruction that changes the contents of memory. Note that all functions that; satisfy the ``doesNotAccessMemory`` method also satisfy ``onlyReadsMemory``. Writing a new ``AliasAnalysis`` Implementation; ==============================================. Writing a new alias analysis implementation for LLVM is quite straight-forward.; There are already several ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:8661,depend,depend,8661,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['depend'],['depend']
Integrability,"he corresponding; :ref:`llvm.stacksave <int_stacksave>` intrinsic executed. This is; useful for implementing language features like scoped automatic; variable sized arrays in C99. The address space should typically be; the :ref:`alloca address space <alloca_addrspace>`. Semantics:; """""""""""""""""""". See the description for :ref:`llvm.stacksave <int_stacksave>`. .. _int_get_dynamic_area_offset:. '``llvm.get.dynamic.area.offset``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.get.dynamic.area.offset.i32(); declare i64 @llvm.get.dynamic.area.offset.i64(). Overview:; """""""""""""""""". The '``llvm.get.dynamic.area.offset.*``' intrinsic family is used to; get the offset from native stack pointer to the address of the most; recent dynamic alloca on the caller's stack. These intrinsics are; intended for use in combination with; :ref:`llvm.stacksave <int_stacksave>` to get a; pointer to the most recent dynamic alloca. This is useful, for example,; for AddressSanitizer's stack unpoisoning routines. Semantics:; """""""""""""""""""". These intrinsics return a non-negative integer value that can be used to; get the address of the most recent dynamic alloca, allocated by :ref:`alloca <i_alloca>`; on the caller's stack. In particular, for targets where stack grows downwards,; adding this offset to the native stack pointer would get the address of the most; recent dynamic alloca. For targets where stack grows upwards, the situation is a bit more; complicated, because subtracting this value from stack pointer would get the address; one past the end of the most recent dynamic alloca. Although for most targets `llvm.get.dynamic.area.offset <int_get_dynamic_area_offset>`; returns just a zero, for others, such as PowerPC and PowerPC64, it returns a; compile-time-known constant value. The return value type of :ref:`llvm.get.dynamic.area.offset <int_get_dynamic_area_offset>`; must match the target's default address space's (address space 0) pointer type. '``llvm",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:521898,rout,routines,521898,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['rout'],['routines']
Integrability,"he currently used compiler runtime library; (""libgcc.a"" or ""libclang_rt.builtins.*.a""). .. option:: -print-prog-name=<name>. Print the full program path of name. .. option:: -print-search-dirs. Print the paths used for finding libraries and programs. .. option:: -save-temps. Save intermediate compilation results. .. option:: -save-stats, -save-stats=cwd, -save-stats=obj. Save internal code generation (LLVM) statistics to a file in the current; directory (:option:`-save-stats`/""-save-stats=cwd"") or the directory; of the output file (""-save-state=obj""). You can also use environment variables to control the statistics reporting.; Setting ``CC_PRINT_INTERNAL_STAT`` to ``1`` enables the feature, the report; goes to stdout in JSON format. Setting ``CC_PRINT_INTERNAL_STAT_FILE`` to a file path makes it report; statistics to the given file in the JSON format. Note that ``-save-stats`` take precedence over ``CC_PRINT_INTERNAL_STAT``; and ``CC_PRINT_INTERNAL_STAT_FILE``. .. option:: -integrated-as, -no-integrated-as. Used to enable and disable, respectively, the use of the integrated; assembler. Whether the integrated assembler is on by default is target; dependent. .. option:: -time. Time individual commands. .. option:: -ftime-report. Print timing summary of each stage of compilation. .. option:: -v. Show commands to run and use verbose output. Diagnostics Options; ~~~~~~~~~~~~~~~~~~~. .. option:: -fshow-column, -fshow-source-location, -fcaret-diagnostics, -fdiagnostics-fixit-info, -fdiagnostics-parseable-fixits, -fdiagnostics-print-source-range-info, -fprint-source-range-info, -fdiagnostics-show-option, -fmessage-length. These options control how Clang prints out information about diagnostics; (errors and warnings). Please see the Clang User's Manual for more information. Preprocessor Options; ~~~~~~~~~~~~~~~~~~~~. .. option:: -D<macroname>=<value>. Adds an implicit #define into the predefines buffer which is read before the; source file is preprocessed. .. option:: -U<mac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:18072,integrat,integrated-as,18072,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,2,['integrat'],['integrated-as']
Integrability,"he custom Streamer,; when storing the object in a TTree and in a collection object, use:. ``` {.cpp}; TClass::GetClass(classname)->SetCanSplit(true);; ```. ### I/O Schema Checksum. The algorithm used to calculate a single number giving an indication on whether; the schema layout has changed (i.e. if two StreamerInfo are equivalent) have; been update to. - Use the normalized name for the types (i.e. two different spelling of the same; name will lead to the same checksum); - Take into account the base classes' checksum in the derived class checksum;; this is necessary to properly support base classes during memberwise streaming. The algorithm that checks whether two StreamerInfo are equal even-though their; checksum is different has been significantly enhanced in particular to also; check the base classes. ### TFileMerger. - Added possibility to merge only a list of objects/folders from the; input files, specified by name, \; or to skip them from merging. This is fully integrated with the new; PartialMerge(flags) schema. \; Usage: \; The names of the objects to be merged or skipped have to be; specified using the interface:. ``` {.cpp}; TFileMerger::AddObjectNames(const char *names); ```. This method can be called several times to add object names. Several; names can be added with one call separated by single blancs (no; blanc at the end). Directory names are accepted, applying the; merging selection to all content. Two new options are being; supported for partial merging:. ``` {.cpp}; TFileMerger::PartialMerge(flags | kOnlyListed); ```. This will merge only the objects in the files having the names in; the specified list. If a folder is specified, it whole content will; be merged. ``` {.cpp}; TFileMerger::PartialMerge(flags | kSkipListed); ```. This will skip merging for the specified objects. If a folder is; specified, its whole content will be skipped. Important note:; The kOnlyListed and kSkipListed flags have to be bitwise OR-ed; on top of the merging defaults: kA",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v600/index.md:1474,integrat,integrated,1474,io/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v600/index.md,1,['integrat'],['integrated']
Integrability,"he dtor for the contained object; 3. The contained object itself. Note that it is necessary to maintain #1 & #2 in the exception object itself; because objects without virtual function tables may be thrown (as in this ; example). Assuming this, TryHandler would look something like this:. TryHandler: ; Exception *E = getThreadLocalException();; switch (E->RTTIType) {; case IntRTTIInfo:; ...int Stuff... // The action to perform from the catch block; break;; case DoubleRTTIInfo:; ...double Stuff... // The action to perform from the catch block; goto TryCleanup // This catch block rethrows the exception; break; // Redundant, eliminated by the optimizer; default:; goto TryCleanup // Exception not caught, rethrow; }. // Exception was consumed; if (E->dtor); E->dtor(E->object) // Invoke the dtor on the object if it exists; goto EndTry // Continue mainline code... And that is all there is to it. The throw(E) function would then be implemented like this (which may be ; inlined into the caller through standard optimization):. function throw(Exception *E) {; // Get the start of the stack trace...; %frame %f = call getStackCurrentFrame(). // Get the label information that corresponds to it; label * %L = call getFrameLabel(%f); while (%L == 0 && !isFirstFrame(%f)) {; // Loop until a cleanup handler is found; %f = call getNextFrame(%f); %L = call getFrameLabel(%f); }. if (%L != 0) {; call setThreadLocalException(E) // Allow handlers access to this...; call doNonLocalBranch(%L); }; // No handler found!; call BlowUp() // Ends up calling the terminate() method in use; }. That's a brief rundown of how C++ exception handling could be implemented in; llvm. Java would be very similar, except it only uses destructors to unlock; synchronized blocks, not to destroy data. Also, it uses two stack walks: a; nondestructive walk that builds a stack trace, then a destructive walk that; unwinds the stack as shown here. . It would be trivial to get exception interoperability between C++ and Java. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-05-18-ExceptionHandling.txt:7227,synchroniz,synchronized,7227,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-05-18-ExceptionHandling.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-05-18-ExceptionHandling.txt,2,"['interoperab', 'synchroniz']","['interoperability', 'synchronized']"
Integrability,"he event vector itself (`Event` column) as well as the `float` columns `Event.pt` and `Event.eta`. ### RClusterPool; The RClusterPool is an internal class owned be a page source.; The cluster pool maintains an I/O thread that asynchronously prefetches the next few clusters.; Through `RPageSource::SetEntryRange()`, the cluster pool is instructed to not read beyond the given limit.; This is used in the RNTuple data source when multiple threads work on different clusters of the same file. ### RMiniFile; The RMiniFile is an internal class used to read and write RNTuple data in a ROOT file.; It provides a minimal subset of the `TFile` functionality.; Its purpose is to reduce the coupling between RNTuple and the ROOT I/O library. For writing data, the RMiniFile can either use a proper `TFile` (descendant) or a C file stream (only for new ROOT files with a single RNTuple).; For reading, the `RMiniFile` always uses an `RRawFile`. ### RRawFile; The RRawFile internal abstract class provides an interface to read byte ranges from a file, including vector reads.; Concrete implementations exist for local files, XRootD and HTTP (the latter two through the ROOT plugin mechanism).; The local file implementation on Linux uses uring for vector reads, if available.; `RRawFileTFile` wraps an existing `TFile` and provides access to the full set of implementations, e.g. `TMemFile`. Tooling; -------. ### RNTupleMerger; The `RNTupleMerger` is an internal class and part of the core RNTuple library.; It concatenates RNTuple data from several sources into a combined sink.; It implements ""fast merging"", i.e. copy-based merging that does not decompress and recompress pages.; The RNTupler merger is used by the `TFileMerger` and thus provides RNTuple merge support in `hadd` and `TBufferMerger`. ### RNTupleImporter; The RNTupleImporter creates RNTuple data sets from ROOT trees.; It is part of the `ROOTNTupleUtil` library. ### RNTupleInspector; The RNTupleInspector provides insights of an RNTuple, e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:15977,interface,interface,15977,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['interface'],['interface']
Integrability,"he existing SVN repository that; the sub-projects move synchronously, and a single revision number (or commit; hash) identifies the state of the development across all projects. .. _build_single_project:. Building a single sub-project; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Even though there is a single source tree, you are not required to build; all sub-projects together. It is trivial to configure builds for a single; sub-project. For example::. mkdir build && cd build; # Configure only LLVM (default); cmake path/to/monorepo; # Configure LLVM and lld; cmake path/to/monorepo -DLLVM_ENABLE_PROJECTS=lld; # Configure LLVM and clang; cmake path/to/monorepo -DLLVM_ENABLE_PROJECTS=clang. .. _git-svn-mirror:. Outstanding Questions; ---------------------. Read-only sub-project mirrors; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. With the Monorepo, it is undecided whether the existing single-subproject; mirrors (e.g. https://git.llvm.org/git/compiler-rt.git) will continue to; be maintained. Read/write SVN bridge; ^^^^^^^^^^^^^^^^^^^^^. GitHub supports a read/write SVN bridge for its repositories. However,; there have been issues with this bridge working correctly in the past,; so it's not clear if this is something that will be supported going forward. Monorepo Drawbacks; ------------------. * Using the monolithic repository may add overhead for those contributing to a; standalone sub-project, particularly on runtimes like libcxx and compiler-rt; that don't rely on LLVM; currently, a fresh clone of libcxx is only 15MB (vs.; 1GB for the monorepo), and the commit rate of LLVM may cause more frequent; `git push` collisions when upstreaming. Affected contributors may be able to; use the SVN bridge or the single-subproject Git mirrors. However, it's; undecided if these projects will continue to be maintained.; * Using the monolithic repository may add overhead for those *integrating* a; standalone sub-project, even if they aren't contributing to it, due to the; same disk space concern as the point ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:10773,bridg,bridge,10773,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['bridg'],['bridge']
Integrability,"he following code in your command prompt:. $ git clone https://github.com/civetweb/civetweb.git; or simply grab a copy of the source code as a ZIP or TGZ file. Quick start documentation; --------------------------. - [docs/Installing.md](https://github.com/civetweb/civetweb/blob/master/docs/Installing.md) - Install Guide (for end users using pre-built binaries); - [docs/UserManual.md](https://github.com/civetweb/civetweb/blob/master/docs/UserManual.md) - End User Guide; - [docs/Building.md](https://github.com/civetweb/civetweb/blob/master/docs/Building.md) - Building the Server (quick start guide); - [docs/Embedding.md](https://github.com/civetweb/civetweb/blob/master/docs/Embedding.md) - Embedding (how to add HTTP support to an existing application); - [docs/OpenSSL.md](https://github.com/civetweb/civetweb/blob/master/docs/OpenSSL.md) - Adding HTTPS (SSL/TLS) support using OpenSSL.; - [API documentation](https://github.com/civetweb/civetweb/tree/master/docs/api) - Additional documentation on the civetweb application programming interface ([civetweb.h](https://github.com/civetweb/civetweb/blob/master/include/civetweb.h)).; - [RELEASE_NOTES.md](https://github.com/civetweb/civetweb/blob/master/RELEASE_NOTES.md) - Release Notes; - [SECURITY.md](https://github.com/civetweb/civetweb/blob/master/SECURITY.md) - Security Policy; - [LICENSE.md](https://github.com/civetweb/civetweb/blob/master/LICENSE.md) - Copyright License. Overview; --------. CivetWeb keeps the balance between functionality and; simplicity by a carefully selected list of features:. - Liberal, commercial-friendly, permissive,; [MIT license](http://en.wikipedia.org/wiki/MIT_License); - Free from copy-left licenses, like GPL, because you should innovate without; restrictions.; - Forked from [Mongoose](https://code.google.com/p/mongoose/) in 2013, before; it changed the licence from MIT to commercial + GPL. A lot of enhancements; have been added since that time, see; [RELEASE_NOTES.md](https://github.com/civet",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md:4753,interface,interface,4753,net/http/civetweb/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md,1,['interface'],['interface']
Integrability,"he following where ``EltTy`` is the; element type of ``MTy``, ``col`` is the number of columns, ``row`` is the; number of rows in ``MTy`` and ``inner`` is the number of columns of ``M1``:. .. code-block:: c++. MTy Res;; for (int C = 0; C < col; ++C) {; for (int R = 0; R < row; ++R) {; EltTy Elt = 0;; for (int K = 0; K < inner; ++K) {; Elt += M1[R][K] * M2[K][C];; }; Res[R][C] = Elt;; }. All operations on matrix types match the behavior of the element type with; respect to signed overflows. With respect to floating-point contraction, rounding and environment rules,; operations on matrix types match the behavior of the elementwise operations; in the corresponding expansions provided above. Operations on floating-point matrices have the same rounding and floating-point; environment behavior as ordinary floating-point operations in the expression's; context. For the purposes of floating-point contraction, all calculations done; as part of a matrix operation are considered intermediate operations, and their; results need not be rounded to the format of the element type until the final; result in the containing expression. This is subject to the normal restrictions; on contraction, such as ``#pragma STDC FP_CONTRACT``. For the ``+=``, ``-=`` and ``*=`` operators the semantics match their expanded; variants. Matrix Type Builtin Operations; ------------------------------. Each matrix type supports a collection of builtin expressions that look like; function calls but do not form an overload set. Here they are described as; function declarations with rules for how to construct the argument list types; and return type and the library description elements from; [library.description.structure.specifications]/3 in the C++ standard. Definitions:. * *M*, *M1*, *M2*, *M3* - Matrix types; * *T* - Element type; * *row*, *col* - Row and column arguments respectively. ``M2 __builtin_matrix_transpose(M1 matrix)``. **Remarks**: The return type is a cv-unqualified matrix type that has the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst:7767,contract,contraction,7767,interpreter/llvm-project/clang/docs/MatrixTypes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst,1,['contract'],['contraction']
Integrability,"he function ""approxfun"" returns a function performing (linear or constant); //interpolation of the given data.; //For a given set of x values, this function will return the corresponding interpolated values.; r<<""f <- approxfun(x, y)"";. r<<""curve(f(x), 0, 11, col = 'green2')"";; r<<""points(x, y)"";. //using approxfun with const method; r<<""fc <- approxfun(x, y, method = 'const')"";; r<<""curve(fc(x), 0, 10, col = 'darkblue', add = TRUE)"";; // different interpolation on left and right side :; r<<""plot(approxfun(x, y, rule = 2:1), 0, 11,col = 'tomato', add = TRUE, lty = 3, lwd = 2)"";; }; ~~~; The image shows the interpolated function plotted within R:; \image html R_image3.png. ## Integration (Passing vectorized function to R); Numerical integration using R passing the function from ROOT. ~~~{.cxx}; #include<TMath.h>; #include<TRInterface.h>; #include<Math/Integrator.h>; #include<TF1.h>. //To integrate using R the function must be vectorized; //The idea is just to receive a vector like an argument,to evaluate; //every element saving the result in another vector; //and return the resultant vector.; std::vector<Double_t> BreitWignerVectorized(std::vector<Double_t> xx); {; std::vector<Double_t> result(xx.size());; for(Int_t i=0;i<xx.size();i++); {; result[i]=TMath::BreitWigner(xx[i]);; }; return result;; }. double BreitWignerWrap( double x){; return TMath::BreitWigner(x);; }. void Integration(); {. ROOT::R::TRInterface &r=ROOT::R::TRInterface::Instance();. r[""BreitWigner""]=BreitWignerVectorized;. Double_t value=r.Eval(""integrate(BreitWigner, lower = -2, upper = 2)$value"");. std::cout.precision(18);; std::cout<<""Integral of the BreitWigner Function in the interval [-2, 2] R = ""<<value<<std::endl;. ROOT::Math::WrappedFunction<> wf(BreitWignerWrap);; ROOT::Math::Integrator i(wf);; value=i.Integral(-2,2);; std::cout<<""Integral of the BreitWigner Function in the interval [-2, 2] MathMore = ""<<value<<std::endl;. TF1 f1(""BreitWigner"",""BreitWignerWrap(x)"");; value=f1.Integral(-2,2);;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/r/doc/users-guide/ROOTR_Users_Guide.md:22412,integrat,integrate,22412,bindings/r/doc/users-guide/ROOTR_Users_Guide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/r/doc/users-guide/ROOTR_Users_Guide.md,1,['integrat'],['integrate']
Integrability,"he local parameter variable, transferring; ownership of that copy to the callee is generally better for ARC; optimization, since otherwise there will be releases in the caller; that are much harder to pair with transfers in the callee. Breaking compatibility with existing Objective-C++ structures was; considered an acceptable cost, as most Objective-C++ code does not have; binary-compatibility requirements. Any existing code which cannot accept; this compatibility break, which is necessarily Objective-C++, should; force the use of the standard C++ ABI by declaring an empty (but; non-defaulted) destructor. .. _arc.ownership.inference:. Ownership inference; -------------------. .. _arc.ownership.inference.variables:. Objects; ^^^^^^^. If an object is declared with retainable object owner type, but without an; explicit ownership qualifier, its type is implicitly adjusted to have; ``__strong`` qualification. As a special case, if the object's base type is ``Class`` (possibly; protocol-qualified), the type is adjusted to have ``__unsafe_unretained``; qualification instead. .. _arc.ownership.inference.indirect_parameters:. Indirect parameters; ^^^^^^^^^^^^^^^^^^^. If a function or method parameter has type ``T*``, where ``T`` is an; ownership-unqualified retainable object pointer type, then:. * if ``T`` is ``const``-qualified or ``Class``, then it is implicitly; qualified with ``__unsafe_unretained``;; * otherwise, it is implicitly qualified with ``__autoreleasing``. .. admonition:: Rationale. ``__autoreleasing`` exists mostly for this case, the Cocoa convention for; out-parameters. Since a pointer to ``const`` is obviously not an; out-parameter, we instead use a type more useful for passing arrays. If the; user instead intends to pass in a *mutable* array, inferring; ``__autoreleasing`` is the wrong thing to do; this directs some of the; caution in the following rules about writeback. Such a type written anywhere else would be ill-formed by the general rule; requiring own",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:65054,protocol,protocol-qualified,65054,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['protocol'],['protocol-qualified']
Integrability,"he master to enable the parallel startup of workers using threads; set next to ""`yes`"" (default is ""`no`""):. ``` {.cpp}; Proof.ParallelStartup: no; ```. ``` {.cpp}; Proof.StatsHist: no; Proof.StatsTrace: no; Proof.SlaveStatsTrace: no; ```. ``` {.cpp}; Proof.CondorHome: /opt/condor; Proof.CondorConfig: /opt/condor/etc/condor_config; ```. ``` {.cpp}; PEAC.GmUrl: http://somewhere:8080/clarens/; PEAC.LmUrl: http://elsewhere:8080/clarens/; ```. #### Server Authentication in TServerSocket. General setting: file with server access rules. ``` {.cpp}; SrvAuth.DaemonRc: /etc/root/system.daemonrc; ```. Check of host equivalence via `/etc/hosts`.`equiv` or `$HOME/.rhosts`. ``` {.cpp}; SrvAuth.CheckHostsEquivalence: 1; ```. Force file opening via **`TNetFile`** (**`TNetXNGFile`**) if a hostname is; specified in the Url. By default, for local files `TFile::Open()`; invokes directly **`TFile.`**. ``` {.cpp}; TFile.ForceRemote: yes; ```. Special cases for the **`TUrl`** parser, where the special cases are; parsed in a protocol + file part, like rfio:host:/path/file.root,; castor:/path/file.root or /alien/path/file.root. In case the file; namespace descriptor ends with - the namespace is not a part of the; filename. Extend in private .rootrc with a +Url.Special line. ``` {.cpp}; Url.Special: file: rfio: hpss: castor: dcache:; +Url.Special: /alien/- /castor/; ```. #### PROOF XRD Client Variables. Debug level (if \<=0 : none, 1 : low, 2 : medium, 3 : high). ``` {.cpp}; XProof.Debug: 0; ```. Socket read timeout [in secs: default 10 secs]. ``` {.cpp}; XProof.ReadTimeout: 10; ```. `XNet.PrintTAG` - Print a particular string the developers can choose to; quickly recognize the version at run time [default - 0]. Example of custom setting for the Rint application (root.exe). This; overrides the default specified above for a generic application. Color 5; is yellow. ``` {.cpp}; Rint.Canvas.HighLightColor: 5; ```. ## Documentation to Download. - The latest ROOT Users Guide. - <https://root.cern.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:14680,protocol,protocol,14680,documentation/users-guide/InstallandBuild.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md,1,['protocol'],['protocol']
Integrability,"he new flag `RSnapshotOption::fOverwriteIfExists` to `true` to force the deletion of the TTree that is; already present and the writing of a new TTree with the same name. See; [ROOT-10573](https://sft.its.cern.ch/jira/browse/ROOT-10573) for more details.; - RDataFrame changed its error handling strategy in case of unreadable input files. Instead of simply logging an error; and skipping the file, it now throws an exception if any of the input files is unreadable (this could also happen in; the middle of an event loop). See [ROOT-10549](https://sft.its.cern.ch/jira/browse/ROOT-10549) for more details.; - New analysis examples based on the recent ATLAS Open Data release ([`Higgs to two photons`](https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html), [`W boson analysis`](https://root.cern/doc/master/df105__WBosonAnalysis_8py.html), [`Higgs to four leptons`](https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html)); - An exception is now thrown in case the size of ROOT's thread-pool changes between RDataFrame construction time and the time the event loop begins.; - Just-in-time compilation of large portions of the computation graph has been optimized, and it is now much faster. Please report any regressions you might encounter on [our issue tracker](https://sft.its.cern.ch/jira/projects/ROOT).; - `MakeRootDataFrame` is now a safe way to construct RDFs. It used to return RDFs with more limited functionality. ## PyROOT. - Introduce the `ROOT.Numba.Declare` decorator which provides a simple way to call Python callables from C++. The Python callables are; just-in-time compiled with [numba](http://numba.pydata.org/), which ensures a runtime performance similar to a C++ implementation.; The feature is targeted to improve the performance of Python based analyses, e.g., allows seamless integration into `RDataFrame` workflows.; See the tutorial [`pyroot004_NumbaDeclare.py`](https://root.cern/doc/master/pyroot004__NumbaDeclare_8py.html) for further information.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md:11267,integrat,integration,11267,README/ReleaseNotes/v622/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md,1,['integrat'],['integration']
Integrability,"he non-vectorizable part (which otherwise would make the entire; loop non-vectorizable). Conceptually, it transforms a loop such as. .. code-block:: c. for (int i = 1; i < n; i+=1) { // original loop; A[i] = i;; B[i] = 2 + B[i];; C[i] = 3 + C[i - 1];; }. into the following code:. .. code-block:: c. if (rtc) {; for (int i = 1; i < n; i+=1) // coincident loop; A[i] = i;; for (int i = 1; i < n; i+=1) // coincident loop; B[i] = 2 + B[i];; for (int i = 1; i < n; i+=1) // sequential loop; C[i] = 3 + C[i - 1];; } else {; for (int i = 1; i < n; i+=1) { // fallback loop; A[i] = i;; B[i] = 2 + B[i];; C[i] = 3 + C[i - 1];; }; }. where ``rtc`` is a generated runtime check. ``llvm.loop.distribute.followup_coincident`` sets the loop attributes of; all loops without loop-carried dependencies (i.e. vectorizable loops).; There might be more than one such loops. If not defined, the loops will; inherit the original loop's attributes. ``llvm.loop.distribute.followup_sequential`` sets the loop attributes of the; loop with potentially unsafe dependencies. There should be at most one; such loop. If not defined, the loop will inherit the original loop's; attributes. ``llvm.loop.distribute.followup_fallback`` defines the loop attributes; for the fallback loop, which is a copy of the original loop for when; loop versioning is required. If undefined, the fallback loop inherits; all attributes from the original loop. Attributes defined in ``llvm.loop.distribute.followup_all`` are added to; all of the aforementioned output loops. It is recommended to add ``llvm.loop.disable_nonforced`` to; ``llvm.loop.distribute.followup_fallback``. This avoids that the; fallback version (which is likely never executed) is further optimized; which would increase the code size. Versioning LICM; ---------------. The pass hoists code out of loops that are only loop-invariant when; dynamic conditions apply. For instance, it transforms the loop. .. code-block:: c. for (int i = 0; i < n; i+=1) // original loop; A[i] =",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst:12019,depend,dependencies,12019,interpreter/llvm-project/llvm/docs/TransformMetadata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst,1,['depend'],['dependencies']
Integrability,"he other hand, in ``void foo(int; **)``, the parameter type is a pointer to ``int *__single`` (i.e., ``void; foo(int *__single *__single)``) (or a pointer to ``int *__unsafe_indexable`` if; it's from a system header). The compiler reports an error for casts between; pointers whose elements have incompatible pointer attributes. This way,; ``-fbounds-safety`` prevents pointers that are implicitly ``__bidi_indexable``; from silently escaping thereby breaking the ABI. .. code-block:: c. void foo(int **);. void bar(void) {; int *local = 0;; // error: passing 'int *__bidi_indexable*__bidi_indexable' to parameter of; // incompatible nested pointer type 'int *__single*__single'; foo(&local);; }. A local variable may still be exposed to the ABI if ``typeof()`` takes the type; of local variable to define an interface as shown in the following example. .. code-block:: C. // bar.c; void bar(int *) { ... }. // foo.c; void foo(void) {; int *p; // implicitly `int *__bidi_indexable p`; extern void bar(typeof(p)); // creates an interface of type; // `void bar(int *__bidi_indexable)`; }. Doing this may break the ABI if the parameter is not ``__bidi_indexable`` at the; definition of function ``bar()`` which is likely the case because parameters are; ``__single`` by default without an explicit annotation. In order to avoid an implicitly wide pointer from silently breaking the ABI, the; compiler reports a warning when ``typeof()`` is used on an implicit wide pointer; at any ABI visible context (e.g., function prototype, struct definition, etc.). .. _Default pointer types in typeof:. Default pointer types in ``typeof()``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When ``typeof()`` takes an expression, it respects the bounds annotation on; the expression type, including the bounds annotation is implcit. For example,; the global variable ``g`` in the following code is implicitly ``__single`` so; ``typeof(g)`` gets ``char *__single``. The similar is true for the parameter; ``p``, so ``typeof(p)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:24841,interface,interface,24841,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['interface'],['interface']
Integrability,"he section on; :ref:`modules <pchinternals-modules>`. Clang's AST files are designed with a compact on-disk representation, which; minimizes both creation time and the time required to initially load the AST; file. The AST file itself contains a serialized representation of Clang's; abstract syntax trees and supporting data structures, stored using the same; compressed bitstream as `LLVM's bitcode file format; <https://llvm.org/docs/BitCodeFormat.html>`_. Clang's AST files are loaded ""lazily"" from disk. When an AST file is initially; loaded, Clang reads only a small amount of data from the AST file to establish; where certain important data structures are stored. The amount of data read in; this initial load is independent of the size of the AST file, such that a; larger AST file does not lead to longer AST load times. The actual header data; in the AST file --- macros, functions, variables, types, etc. --- is loaded; only when it is referenced from the user's code, at which point only that; entity (and those entities it depends on) are deserialized from the AST file.; With this approach, the cost of using an AST file for a translation unit is; proportional to the amount of code actually used from the AST file, rather than; being proportional to the size of the AST file itself. When given the `-print-stats` option, Clang produces statistics; describing how much of the AST file was actually loaded from disk. For a; simple ""Hello, World!"" program that includes the Apple ``Cocoa.h`` header; (which is built as a precompiled header), this option illustrates how little of; the actual precompiled header is required:. .. code-block:: none. *** AST File Statistics:; 895/39981 source location entries read (2.238563%); 19/15315 types read (0.124061%); 20/82685 declarations read (0.024188%); 154/58070 identifiers read (0.265197%); 0/7260 selectors read (0.000000%); 0/30842 statements read (0.000000%); 4/8400 macros read (0.047619%); 1/4995 lexical declcontexts read (0.020020%);",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:3966,depend,depends,3966,interpreter/llvm-project/clang/docs/PCHInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst,1,['depend'],['depends']
Integrability,"he sequence of '1' and '0' bits in the mask. E.g., if the mask vector is '10010001', ""expandload"" reads 3 values from memory addresses ptr, ptr+1, ptr+2 and places them in lanes 0, 3 and 7 accordingly. The masked-off lanes are filled by elements from the corresponding lanes of the '``passthru``' operand. Arguments:; """""""""""""""""""". The first operand is the base pointer for the load. It has the same underlying type as the element of the returned vector. The second operand, mask, is a vector of boolean values with the same number of elements as the return type. The third is a pass-through value that is used to fill the masked-off lanes of the result. The return type and the type of the '``passthru``' operand have the same vector type. Semantics:; """""""""""""""""""". The '``llvm.masked.expandload``' intrinsic is designed for reading multiple scalar values from adjacent memory addresses into possibly non-adjacent vector lanes. It is useful for targets that support vector expanding loads and allows vectorizing loop with cross-iteration dependency like in the following example:. .. code-block:: c. // In this loop we load from B and spread the elements into array A.; double *A, B; int *C;; for (int i = 0; i < size; ++i) {; if (C[i] != 0); A[i] = B[j++];; }. .. code-block:: llvm. ; Load several elements from array B and expand them in a vector.; ; The number of loaded elements is equal to the number of '1' elements in the Mask.; %Tmp = call <8 x double> @llvm.masked.expandload.v8f64(ptr %Bptr, <8 x i1> %Mask, <8 x double> poison); ; Store the result in A; call void @llvm.masked.store.v8f64.p0(<8 x double> %Tmp, ptr %Aptr, i32 8, <8 x i1> %Mask). ; %Bptr should be increased on each iteration according to the number of '1' elements in the Mask.; %MaskI = bitcast <8 x i1> %Mask to i8; %MaskIPopcnt = call i8 @llvm.ctpop.i8(i8 %MaskI); %MaskI64 = zext i8 %MaskIPopcnt to i64; %BNextInd = add i64 %BInd, %MaskI64. Other targets may support this intrinsic differently, for example, by lowering it",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:857017,depend,dependency,857017,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['dependency']
Integrability,"he similar is true for the parameter; ``p``, so ``typeof(p)`` returns ``void *__single``. The local variable ``l`` is; implicitly ``__bidi_indexable``, so ``typeof(l)`` becomes; ``int *__bidi_indexable``. .. code-block:: C. char *g; // typeof(g) == char *__single. void foo(void *p) {; // typeof(p) == void *__single. int *l; // typeof(l) == int *__bidi_indexable; }. When the type of expression has an ""external"" bounds annotation, e.g.,; ``__sized_by``, ``__counted_by``, etc., the compiler may report an error on; ``typeof`` if the annotation creates a dependency with another declaration or; variable. For example, the compiler reports an error on ``typeof(p1)`` shown in; the following code because allowing it can potentially create another type; dependent on the parameter ``size`` in a different context (Please note that an; external bounds annotation on a parameter may only refer to another parameter of; the same function). On the other hand, ``typeof(p2)`` works resulting in ``int; *__counted_by(10)``, since it doesn't depend on any other declaration. .. TODO: add a section describing constraints on external bounds annotations. .. code-block:: C. void foo(int *__counted_by(size) p1, size_t size) {; // typeof(p1) == int *__counted_by(size); // -> a compiler error as it tries to create another type; // dependent on `size`. int *__counted_by(10) p2; // typeof(p2) == int *__counted_by(10); // -> no error. }. When ``typeof()`` takes a type name, the compiler doesn't apply an implicit; bounds annotation on the named pointer types. For example, ``typeof(int*)``; returns ``int *`` without any bounds annotation. A bounds annotation may be; added after the fact depending on the context. In the following example,; ``typeof(int *)`` returns ``int *`` so it's equivalent as the local variable is; declared as ``int *l``, so it eventually becomes implicitly; ``__bidi_indexable``. .. code-block:: c. void foo(void) {; typeof(int *) l; // `int *__bidi_indexable` (same as `int *l`); }. T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:26790,depend,depend,26790,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['depend'],['depend']
Integrability,"he specification of non-deduced contexts; Yes. 527; CD2; Problems with linkage of types; N/A. 528; NAD; Why are incomplete class types not allowed with typeid?; Unknown. 529; drafting; Use of template<> with “explicitly-specialized” class templates; Not resolved. 530; CD1; Nontype template arguments in constant expressions; Yes. 531; C++11; Defining members of explicit specializations; Partial. 532; C++11; Member/nonmember operator template partial ordering; Clang 3.5. 533; NAD; Special treatment for C-style header names; N/A. 534; CD1; template-names and operator-function-ids; Clang 2.9. 535; CD3; Copy construction without a copy constructor; Yes. 536; CD6; Problems in the description of id-expressions; N/A. 537; CD1; Definition of “signature”; N/A. 538; CD1; Definition and usage; of structure, POD-struct, POD-union,; and POD class; N/A. 539; CD3; Constraints on type-specifier-seq; Yes. 540; CD1; Propagation of cv-qualifiers in reference-to-reference collapse; Yes. 541; CD2; Dependent function types; Yes. 542; CD2; Value initialization of arrays of POD-structs; Yes. 543; CD1; Value initialization and default constructors; Clang 3.0. 544; NAD; Base class lookup in explicit specialization; Yes. 545; open; User-defined conversions and built-in operator overload resolution; Not resolved. 546; C++11; Explicit instantiation of class template members; Yes. 547; C++11; Partial specialization on member function types; Clang 3.2. 548; dup; qualified-ids in declarations; Duplicate of 482. 549; drafting; Non-deducible parameters in partial specializations; Not resolved. 550; dup; Pointer to array of unknown bound in parameter declarations; Unknown. 551; CD1; When is inline permitted in an explicit instantiation?; Yes (C++11 onwards). 552; NAD; Use of typename in the type in a non-type parameter-declaration; Yes. 553; NAD; Problems with friend allocation and deallocation functions; Unknown. 554; CD6; Definition of “declarative region” and “scope”; N/A. 555; CD5; Pseudo-destructo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:37069,Depend,Dependent,37069,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Depend'],['Dependent']
Integrability,"he specified flags will generate four intermediate bytecode files:. #. a.out.0.0.preopt.bc (Before any link-time optimizations (LTO) are applied); #. a.out.0.2.internalize.bc (After initial optimizations are applied); #. a.out.0.4.opt.bc (After an extensive set of optimizations); #. a.out.0.5.precodegen.bc (After LTO but before translating into machine code). Execute one of the following commands to identify the source of the problem:. #. ``opt ""-passes=lto<O3>"" a.out.0.2.internalize.bc``; #. ``llc a.out.0.5.precodegen.bc``. If one of these do crash, you should be able to reduce; this with :program:`llvm-reduce`; command line (use the bc file corresponding to the command above that failed):. .. code-block:: bash. llvm-reduce --test reduce.sh a.out.0.2.internalize.bc. Example of reduce.sh script. .. code-block:: bash. $ cat reduce.sh; #!/bin/bash -e. path/to/not --crash path/to/opt ""-passes=lto<O3>"" $1 -o temp.bc 2> err.log; grep -q ""It->second == &Insn"" err.log. Here we have grepped the failed assert message. Please run this, then file a bug with the instructions and reduced .bc file; that llvm-reduce emits. .. _miscompiling:. Miscompilations; ===============. If clang successfully produces an executable, but that executable doesn't run; right, this is either a bug in the code or a bug in the compiler. The first; thing to check is to make sure it is not using undefined behavior (e.g.; reading a variable before it is defined). In particular, check to see if the; program is clean under various `sanitizers; <https://github.com/google/sanitizers>`_ (e.g. ``clang; -fsanitize=undefined,address``) and `valgrind <http://valgrind.org/>`_. Many; ""LLVM bugs"" that we have chased down ended up being bugs in the program being; compiled, not LLVM. Once you determine that the program itself is not buggy, you should choose; which code generator you wish to compile the program with (e.g. LLC or the JIT); and optionally a series of LLVM passes to run. For example:. .. code-block:: bas",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSubmitABug.rst:7814,message,message,7814,interpreter/llvm-project/llvm/docs/HowToSubmitABug.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSubmitABug.rst,1,['message'],['message']
Integrability,"he text representation (IFS) of a shared object produced; by the :program:`llvm-ifs`:. ::. --- !ifs-v1; IFSVersion: 3.0; SoName: libtest.so /* Optional */; Target: x86_64-unknown-linux-gnu /* Optional, format 1, same format as llvm target triple */; Target: { Arch: x86_64, Endianness: little, Bitwidth: 64 } /* Optional, format 2 */; NeededLibs:; - libc.so.6; Symbols:; - { Name: sym0, Type: Notype }; - { Name: sym1, Type: Object, Size: 0 }; - { Name: sym2, Type: Func, Weak: false }; - { Name: sym3, Type: TLS }; - { Name: sym4, Type: Unknown, Warning: foo }; ... * ``IFSVersion``: Version of the IFS file for reader compatibility. * ``SoName`` (optional): Name of the shared object file that is being stubbed. * ``Target`` (optional): The architecture, endianness and bitwise information of; this shared object. It can be either in explicit format or in implicit LLVM; triple format. It can be optional and can be overridden from command line; options. * ``NeededLibs``: The list of the external shared objects that this library depends on. * ``Symbols``: A collection of all data needed to link objects for each symbol, sorted by name in ascending order. + ``Name``: Symbol name. + ``Type``: Whether the symbol is an object, function, no-type, thread local storage, or unknown. Symbol types not explicitly supported are mapped as unknown to improve signal-to-noise ratio. + ``Size``: The size of the symbol in question, doesn't apply to functions, and is optional for NoType symbols. + ``Undefined``: Whether or not the symbol is defined in this shared object file. + ``Weak``: Whether or not the symbol should be treated as weak. + ``Warning`` (optional): Warning text to output when this symbol is linked against. This YAML based text format contains everything that is needed to generate a; linkable ELF shared object as well as an Apple TAPI format file. The ordering; of symbols is sorted, so these files can be easily compared using diff tools.; If the content of the file changes, it indi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-ifs.rst:1695,depend,depends,1695,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-ifs.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-ifs.rst,1,['depend'],['depends']
Integrability,"he version info is provided by the ``LLVM_REVISION`` macro in; ``llvm/include/llvm/Support/VCSRevision.h``. Developers using git who don't; need revision info can disable this option to avoid re-linking most binaries; after a branch switch. Defaults to ON. **LLVM_FORCE_VC_REVISION**:STRING; Force a specific Git revision id rather than calling to git to determine it.; This is useful in environments where git is not available or non-functional; but the VC revision is available through other means. **LLVM_FORCE_VC_REPOSITORY**:STRING; Set the git repository to include in version info rather than calling git to; determine it. **LLVM_BUILD_32_BITS**:BOOL; Build 32-bit executables and libraries on 64-bit systems. This option is; available only on some 64-bit Unix systems. Defaults to OFF. **LLVM_BUILD_BENCHMARKS**:BOOL; Adds benchmarks to the list of default targets. Defaults to OFF. **LLVM_BUILD_DOCS**:BOOL; Adds all *enabled* documentation targets (i.e. Doxgyen and Sphinx targets) as; dependencies of the default build targets. This results in all of the (enabled); documentation targets being as part of a normal build. If the ``install``; target is run then this also enables all built documentation targets to be; installed. Defaults to OFF. To enable a particular documentation target, see; see LLVM_ENABLE_SPHINX and LLVM_ENABLE_DOXYGEN. **LLVM_BUILD_EXAMPLES**:BOOL; Build LLVM examples. Defaults to OFF. Targets for building each example are; generated in any case. See documentation for *LLVM_BUILD_TOOLS* above for more; details. **LLVM_BUILD_INSTRUMENTED_COVERAGE**:BOOL; If enabled, `source-based code coverage; <https://clang.llvm.org/docs/SourceBasedCodeCoverage.html>`_ instrumentation; is enabled while building llvm. If CMake can locate the code coverage; scripts and the llvm-cov and llvm-profdata tools that pair to your compiler,; the build will also generate the `generate-coverage-report` target to generate; the code coverage report for LLVM, and the `clear-profile-da",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:14123,depend,dependencies,14123,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['depend'],['dependencies']
Integrability,"he; MnUserParameterState. ### Access values, errors, covariance ###. The result can be accessed via methods like; MnUserParameterState::value(unsigned int n) and; MnUserParameterState::error(unsigned int n), where $n$ is the index of; the parameter in the list of parameters defined by the user. ### Printout of the result ###. The FunctionMinimum can be printed on the output simply via std::cout.; It will print both the internal and external state, that is parameters,; errors and the covariance matrix (if available). It also tells the user; if M did converge or not by issuing an appropriate message. If a; covariance matrix is available, the global correlation coefficients are; printed as well. ### Global correlation coefficients ###. The global correlation coefficient for parameter $n$ is a number between; zero and one which gives the correlation between parameter $n$ and that; linear combination of all other parameters which is most strongly; correlated with $n$. # M application programming interface (API) #. [api:api]. ## FunctionMinimum ##. [api:fm] The FunctionMinimum is the output of the minimizers and; contains the minimization result. The state at the minimum is available; both in internal and external representations. For the external; representations the return methods. - FunctionMinimum::userState(),. - FunctionMinimum::userParameters() and. - FunctionMinimum::userCovariance(). are provided. These can be used as new input to a new minimization after; some manipulation. The parameters and/or the FunctionMinimum can be; printed using std::cout. ### isValid() ###. In general, if the method bool FunctionMinimum::isValid() returns; ""true"", the minimizer did find a minimum without running into troubles.; However, in some cases it may happen that a minimum cannot be found,; then the return value will be ""false"". Reasons for the minimization to; fail are. - the number of allowed function calls has been exhausted. - the minimizer could not improve the values of the p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:37035,interface,interface,37035,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['interface'],['interface']
Integrability,"he; point of evaluation of the return statement, before leaving all local scopes. When receiving a return result from such a function or method, ARC releases the; value at the end of the full-expression it is contained within, subject to the; usual optimizations for local values. .. admonition:: Rationale. This formalizes direct transfers of ownership from a callee to a caller. The; most common scenario this models is the retained return from ``init``,; ``alloc``, ``new``, and ``copy`` methods, but there are other cases in the; frameworks. After optimization there are typically no extra retains and; releases required. Methods in the ``alloc``, ``copy``, ``init``, ``mutableCopy``, and ``new``; :ref:`families <arc.method-families>` are implicitly marked; ``__attribute__((ns_returns_retained))``. This may be suppressed by explicitly; marking the method ``__attribute__((ns_returns_not_retained))``. It is undefined behavior if the method to which an Objective-C message send; statically resolves has different retain semantics on its result from the; method it dynamically resolves to. It is undefined behavior if a block or; function call is made through a static type with different retain semantics on; its result from the implementation of the called block or function. .. admonition:: Rationale. Mismatches with returned results will cause over-retains or over-releases,; depending on the direction. Again, the rule about function calls is really; just an application of the existing C/C++ rule about calling functions; through an incompatible function type. .. _arc.objects.operands.unretained-returns:. Unretained return values; ^^^^^^^^^^^^^^^^^^^^^^^^. A method or function which returns a retainable object type but does not return; a retained value must ensure that the object is still valid across the return; boundary. When returning from such a function or method, ARC retains the value at the; point of evaluation of the return statement, then leaves all local scopes, and; the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:20639,message,message,20639,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['message'],['message']
Integrability,"heir inclusion through; ``lib/Support`` interfaces. High Level Interface; --------------------. The entry points specified in the interface of ``lib/Support`` must be aimed at; completing some reasonably high level task needed by LLVM. We do not want to; simply wrap each operating system call. It would be preferable to wrap several; operating system calls that are always used in conjunction with one another by; LLVM. For example, consider what is needed to execute a program, wait for it to; complete, and return its result code. On Unix, this involves the following; operating system calls: ``getenv``, ``fork``, ``execve``, and ``wait``. The; correct thing for ``lib/Support`` to provide is a function, say; ``ExecuteProgramAndWait``, that implements the functionality completely. what; we don't want is wrappers for the operating system calls involved. There must **not** be a one-to-one relationship between operating system; calls and the Support library's interface. Any such interface function will be; suspicious. No Unused Functionality; -----------------------. There must be no functionality specified in the interface of ``lib/Support``; that isn't actually used by LLVM. We're not writing a general purpose operating; system wrapper here, just enough to satisfy LLVM's needs. And, LLVM doesn't; need much. This design goal aims to keep the ``lib/Support`` interface small and; understandable which should foster its actual use and adoption. No Duplicate Implementations; ----------------------------. The implementation of a function for a given platform must be written exactly; once. This implies that it must be possible to apply a function's; implementation to multiple operating systems if those operating systems can; share the same implementation. This rule applies to the set of operating; systems supported for a given class of operating system (e.g. Unix, Win32). No Virtual Methods; ------------------. The Support Library interfaces can be called quite frequently by LLVM.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:4830,interface,interface,4830,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['interface'],['interface']
Integrability,"hen the check fails, calling an assertion handler. For example, consider the following code; fragment:. void foo(int *p) {; assert(p != NULL);; }. When this code is preprocessed on Mac OS X it expands to the following:. void foo(int *p) {; (__builtin_expect(!(p != NULL), 0) ? __assert_rtn(__func__, ""t.c"", 4, ""p != NULL"") : (void)0);; }. In this example, the assertion handler is __assert_rtn. When called,; most assertion handlers typically print an error and terminate the program. The; analyzer can exploit such semantics by ending the analysis of a path once it; hits a call to an assertion handler.; The trick, however, is that the analyzer needs to know that a called function; is an assertion handler; otherwise the analyzer might assume the function call; returns and it will continue analyzing the path where the assertion condition; failed. This can lead to false positives, as the assertion condition usually; implies a safety condition (e.g., a pointer is not null) prior to performing; some action that depends on that condition (e.g., dereferencing a pointer).; The analyzer knows about several well-known assertion handlers, but can; automatically infer if a function should be treated as an assertion handler if; it is annotated with the 'noreturn' attribute or the (Clang-specific); 'analyzer_noreturn' attribute. Note that, currently, clang does not support; these attributes on Objective-C methods and C++ methods.; Attribute 'noreturn'; The 'noreturn' attribute is a GCC-attribute that can be placed on the; declarations of functions. It means exactly what its name implies: a function; with a 'noreturn' attribute should never return.; Specific details of the syntax of using the 'noreturn' attribute can be found; in GCC's; documentation.; Not only does the analyzer exploit this information when pruning false paths,; but the compiler also takes it seriously and will generate different code (and; possibly better optimized) under the assumption that the function does not; re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:21423,depend,depends,21423,interpreter/llvm-project/clang/www/analyzer/annotations.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html,2,['depend'],['depends']
Integrability,"her; does the same job as `scan-build` does. So, you can expect the same output; from this line as simple `scan-build` would do:. $ intercept-build <your build command> && analyze-build. The major difference is how and when the analyzer is run. The `scan-build`; tool has three distinct model to run the analyzer:. 1. Use compiler wrappers to make actions.; The compiler wrappers does run the real compiler and the analyzer.; This is the default behaviour, can be enforced with `--override-compiler`; flag. 2. Use special library to intercept compiler calls during the build process.; The analyzer run against each modules after the build finished.; Use `--intercept-first` flag to get this model. 3. Use compiler wrappers to intercept compiler calls during the build process.; The analyzer run against each modules after the build finished.; Use `--intercept-first` and `--override-compiler` flags together to get; this model. The 1. and 3. are using compiler wrappers, which works only if the build; process respects the `CC` and `CXX` environment variables. (Some build; process can override these variable as command line parameter only. This case; you need to pass the compiler wrappers manually. eg.: `intercept-build; --override-compiler make CC=intercept-cc CXX=intercept-c++ all` where the; original build command would have been `make all` only.). The 1. runs the analyzer right after the real compilation. So, if the build; process removes removes intermediate modules (generated sources) the analyzer; output still kept. The 2. and 3. generate the compilation database first, and filters out those; modules which are not exists. So, it's suitable for incremental analysis during; the development. The 2. mode is available only on FreeBSD and Linux. Where library preload; is available from the dynamic loader. Not supported on OS X (unless System; Integrity Protection feature is turned off). `intercept-build` command uses only the 2. and 3. mode to generate the; compilation database. `a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/README.md:2933,wrap,wrappers,2933,interpreter/llvm-project/clang/tools/scan-build-py/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/README.md,1,['wrap'],['wrappers']
Integrability,"here a variable takes a particular value. Similarly, Assignment Tracking; marks out the position of assignments with a new intrinsic called; `llvm.dbg.assign`. In order to know where in IR it is appropriate to use a memory location for a; variable, each assignment marker must in some way refer to the store, if any; (or multiple!), that performs the assignment. That way, the position of the; store and marker can be considered together when making that choice. Another; important benefit of referring to the store is that we can then build a two-way; mapping of stores<->markers that can be used to find markers that need to be; updated when stores are modified. An `llvm.dbg.assign` marker that is not linked to any instruction signals that; the store that performed the assignment has been optimised out, and therefore; the memory location will not be valid for at least some part of the program. Here's the `llvm.dbg.assign` signature. Each parameter is wrapped in; `MetadataAsValue`, and `Value *` type parameters are first wrapped in; `ValueAsMetadata`:. ```; void @llvm.dbg.assign(Value *Value,; DIExpression *ValueExpression,; DILocalVariable *Variable,; DIAssignID *ID,; Value *Address,; DIExpression *AddressExpression); ```. The first three parameters look and behave like an `llvm.dbg.value`. `ID` is a; reference to a store (see next section). `Address` is the destination address; of the store and it is modified by `AddressExpression`. An empty/undef/poison; address means the address component has been killed (the memory address is no; longer a valid location). LLVM currently encodes variable fragment information; in `DIExpression`s, so as an implementation quirk the `FragmentInfo` for; `Variable` is contained within `ValueExpression` only. The formal LLVM-IR signature is:; ```; void @llvm.dbg.assign(metadata, metadata, metadata, metadata, metadata, metadata); ```. ### Instruction link: `DIAssignID`. `DIAssignID` metadata is the mechanism that is currently used to encode the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md:2787,wrap,wrapped,2787,interpreter/llvm-project/llvm/docs/AssignmentTracking.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md,2,['wrap'],['wrapped']
Integrability,"here are different ways that the wavefront scratch base address is determined; by a wavefront (see :ref:`amdgpu-amdhsa-initial-kernel-execution-state`). This; memory can be accessed in an interleaved manner using buffer instruction with; the scratch buffer descriptor and per wavefront scratch offset, by the scratch; instructions, or by flat instructions. If each lane of a wavefront accesses the; same private address, the interleaving results in adjacent dwords being accessed; and hence requires fewer cache lines to be fetched. Multi-dword access is not; supported except by flat and scratch instructions in GFX9-GFX11. The generic address space uses the hardware flat address support available in; GFX7-GFX11. This uses two fixed ranges of virtual addresses (the private and; local apertures), that are outside the range of addressible global memory, to; map from a flat address to a private or local address. FLAT instructions can take a flat address and access global, private (scratch); and group (LDS) memory depending on if the address is within one of the; aperture ranges. Flat access to scratch requires hardware aperture setup and; setup in the kernel prologue (see; :ref:`amdgpu-amdhsa-kernel-prolog-flat-scratch`). Flat access to LDS requires; hardware aperture setup and M0 (GFX7-GFX8) register setup (see; :ref:`amdgpu-amdhsa-kernel-prolog-m0`). To convert between a segment address and a flat address the base address of the; apertures address can be used. For GFX7-GFX8 these are available in the; :ref:`amdgpu-amdhsa-hsa-aql-queue` the address of which can be obtained with; Queue Ptr SGPR (see :ref:`amdgpu-amdhsa-initial-kernel-execution-state`). For; GFX9-GFX11 the aperture base addresses are directly available as inline constant; registers ``SRC_SHARED_BASE/LIMIT`` and ``SRC_PRIVATE_BASE/LIMIT``. In 64 bit; address mode the aperture sizes are 2^32 bytes and the base is aligned to 2^32; which makes it easier to convert from flat to segment or segment to flat. Image and",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:155749,depend,depending,155749,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['depend'],['depending']
Integrability,"hes int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<CXXUnresolvedConstructExpr>hasAnyArgumentMatcher<Expr> InnerMatcher; Matches any argument of a call expression or a constructor call; expression, or an ObjC-message-send expression. Given; void x(int, int, int) { int y; x(1, y, 42); }; callExpr(hasAnyArgument(declRefExpr())); matches x(1, y, 42); with hasAnyArgument(...); matching y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end; void foo(I *i) { [i f:12]; }; objcMessageExpr(hasAnyArgument(integerLiteral(equals(12)))); matches [i f:12]. Matcher<CXXUnresolvedConstructExpr>hasArgumentunsigned N, Matcher<Expr> InnerMatcher; Matches the n'th argument of a call expression or a constructor; call expression. Example matches y in x(y); (matcher = callExpr(hasArgument(0, declRefExpr()))); void x(int) { int y; x(y); }. Matcher<CXXUnresolvedConstructExpr>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUn",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:170823,interface,interface,170823,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['interface'],['interface']
Integrability,"hidden_global_offset_z""; The OpenCL grid dispatch; global offset for the Z; dimension is passed in the; kernarg. ""hidden_none""; An argument that is not used; by the kernel. Space needs to; be left for it, but it does; not need to be set up. ""hidden_printf_buffer""; A global address space pointer; to the runtime printf buffer; is passed in kernarg. Mutually; exclusive with; ""hidden_hostcall_buffer""; before Code Object V5. ""hidden_hostcall_buffer""; A global address space pointer; to the runtime hostcall buffer; is passed in kernarg. Mutually; exclusive with; ""hidden_printf_buffer""; before Code Object V5. ""hidden_default_queue""; A global address space pointer; to the OpenCL device enqueue; queue that should be used by; the kernel by default is; passed in the kernarg. ""hidden_completion_action""; A global address space pointer; to help link enqueued kernels into; the ancestor tree for determining; when the parent kernel has finished. ""hidden_multigrid_sync_arg""; A global address space pointer for; multi-grid synchronization is; passed in the kernarg. "".value_type"" string Unused and deprecated. This should no longer; be emitted, but is accepted for compatibility. "".pointee_align"" integer Alignment in bytes of pointee; type for pointer type kernel; argument. Must be a power; of 2. Only present if; "".value_kind"" is; ""dynamic_shared_pointer"".; "".address_space"" string Kernel argument address space; qualifier. Only present if; "".value_kind"" is ""global_buffer"" or; ""dynamic_shared_pointer"". Values; are:. - ""private""; - ""global""; - ""constant""; - ""local""; - ""generic""; - ""region"". .. TODO::. Is ""global_buffer"" only ""global""; or ""constant""? Is; ""dynamic_shared_pointer"" always; ""local""? Can HCC allow ""generic""?; How can ""private"" or ""region""; ever happen?. "".access"" string Kernel argument access; qualifier. Only present if; "".value_kind"" is ""image"" or; ""pipe"". Values; are:. - ""read_only""; - ""write_only""; - ""read_write"". .. TODO::. Does this apply to; ""global_buffer""?. "".actual_access"" ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:138771,synchroniz,synchronization,138771,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['synchroniz'],['synchronization']
Integrability,"his allows dynamic types of nodes. But the YAML I/O model uses; static typing, so there are limits to how you can use tags with the YAML I/O; model. Recently, we added support to YAML I/O for checking/setting the optional; tag on a map. Using this functionality it is even possible to support different; mappings, as long as they are convertible. To check a tag, inside your mapping() method you can use io.mapTag() to specify; what the tag should be. This will also add that tag when writing yaml. Validation; ----------. Sometimes in a YAML map, each key/value pair is valid, but the combination is; not. This is similar to something having no syntax errors, but still having; semantic errors. To support semantic level checking, YAML I/O allows; an optional ``validate()`` method in a MappingTraits template specialization. When parsing YAML, the ``validate()`` method is call *after* all key/values in; the map have been processed. Any error message returned by the ``validate()``; method during input will be printed just a like a syntax error would be printed.; When writing YAML, the ``validate()`` method is called *before* the YAML; key/values are written. Any error during output will trigger an ``assert()``; because it is a programming error to have invalid struct values. .. code-block:: c++. using llvm::yaml::MappingTraits;; using llvm::yaml::IO;. struct Stuff {; ...; };. template <>; struct MappingTraits<Stuff> {; static void mapping(IO &io, Stuff &stuff) {; ...; }; static std::string validate(IO &io, Stuff &stuff) {; // Look at all fields in 'stuff' and if there; // are any bad values return a string describing; // the error. Otherwise return an empty string.; return std::string{};; }; };. Flow Mapping; ------------; A YAML ""flow mapping"" is a mapping that uses the inline notation; (e.g { x: 1, y: 0 } ) when written to YAML. To specify that a type should be; written in YAML using flow mapping, your MappingTraits specialization should; add ""static const bool flow = true;"".",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst:23463,message,message,23463,interpreter/llvm-project/llvm/docs/YamlIO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst,1,['message'],['message']
Integrability,"his new version provides all the functionality present in the old; FORTRAN version, with almost equivalent numerical accuracy and; computational performances.; Furthermore, it contains some fixes and small improvements and this new functionality:; * The possibility to set single side parameter limits; * the FUMILI algorithm (see the next paragraph ""FUMILI Minimization Package""),; which is an optimized method for least square and log; likelihood minimizations. Minuit2 has been originally developed by M.; Winkler and F. James in the SEAL project. More information can be found; on the [MINUIT Web Site](MINUIT Web Site) and in particular at the; following documentation page at; <http://www.cern.ch/minuit/doc/doc.html>. A detailed User Guide for Minuit2 exists, describing the API of the internal classes.; ROOT uses `Minuit2` for fitting via the `Minuit2Minimizer` class which implements; the `ROOT::Math::Minimizer` interface. `Minuit2` is also distributed as an independent package of ROOT and can be built; without any other dependency on the ROOT libraries. Examples on how to use the `Minuit2` and `Fumili2` plug-ins are provided; in the tutorials' directory `$ROOTSYS/tutorials/fit`:; `minuit2FitBench.C`, `minuit2FitBench2D.C` and `minuit2GausFit.C`.; More information on the classes and functions present in `Minuit2` is; available at; [online reference documentation](online reference documentation). Useful information on MINUIT and minimization in general is provided in the; following documents:. F. James, *Minuit Tutorial on Function Minimization* (; <http://seal.cern.ch/documents/minuit/mntutorial.pdf>); F. James, *The; Interpretation of Errors in Minuit* (; <http://seal.cern.ch/documents/minuit/mnerror.pdf>);. ## FUMILI Minimization Package. FUMILI is used to minimize Chi-square function or to search maximum of; likelihood function. Experimentally measured values $F_{i}$ are fitted; with theoretical; functions $f_{i}(\vec{x_{i}},\vec{\theta})$, where $\vec{x_{i}}$ are; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:65921,depend,dependency,65921,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['depend'],['dependency']
Integrability,"his set of function analyses. The ``doInitialization(Loop *, LPPassManager &)`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doInitialization(Loop *, LPPassManager &LPM);. The ``doInitialization`` method is designed to do simple initialization type of; stuff that does not depend on the functions being processed. The; ``doInitialization`` method call is not scheduled to overlap with any other; pass executions (thus it should be very fast). ``LPPassManager`` interface; should be used to access ``Function`` or ``Module`` level analysis information. .. _writing-an-llvm-pass-runOnLoop:. The ``runOnLoop`` method; ^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool runOnLoop(Loop *, LPPassManager &LPM) = 0;. The ``runOnLoop`` method must be implemented by your subclass to do the; transformation or analysis work of your pass. As usual, a ``true`` value; should be returned if the function is modified. ``LPPassManager`` interface; should be used to update loop nest. The ``doFinalization()`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doFinalization();. The ``doFinalization`` method is an infrequently used method that is called; when the pass framework has finished calling :ref:`runOnLoop; <writing-an-llvm-pass-runOnLoop>` for every loop in the program being compiled. .. _writing-an-llvm-pass-RegionPass:. The ``RegionPass`` class; ------------------------. ``RegionPass`` is similar to :ref:`LoopPass <writing-an-llvm-pass-LoopPass>`,; but executes on each single entry single exit region in the function.; ``RegionPass`` processes regions in nested order such that the outer most; region is processed last. ``RegionPass`` subclasses are allowed to update the region tree by using the; ``RGPassManager`` interface. You may override three virtual methods of; ``RegionPass`` to implement your own region pass. All these methods should; return ``true`` if they modified the program, or ``false`` if ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:22268,interface,interface,22268,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['interface'],['interface']
Integrability,"his version the ""*Undo*"" does not allow restoring an; intermediate state of the parameters that was applied - it will always; restore the parameters at the moment the shape was edited. All material properties changes are undoable. The mixture editor; currently allows adding elements one by one in the mixture composition.; This can be done either by element weight fraction or by number of; atoms. Once an element was added using one method the other method is not; selectable anymore. Summing component fractions up to 1 in the final; mixture is the user responsibility. Adding materials as components of a; mixture is not supported in this version. The elements that were added to the mixture appear in the bottom of the; mixture editor. The operations performed on mixture are not undoable. ### Creation of New Objects. As described above, all geometry object creators are accessible within; the geometry manager editor frame. Generally, if the new object that; needs to be created does not depend on other objects, it will be built; with a set of default parameters. This is the case for all shapes; (except composite shapes) and matrices. For all the other objects the; interface forces the selection of components before creating the object. ### Editing Volumes. Volumes are hierarchical components in the geometry, therefore their; editor is more complex. It provides the following functionalities:. - *General*. This category allows changing the name of the volume and; selecting other shape or medium among existing ones. - *Daughters*. The category allows removing existing daughter nodes or; adding new ones. The button ""*Position*"" allows editing the; positioning matrix of a given node. ![Setting volume properties and modifying volume hierarchy](pictures/020001F5.jpg); ![Setting volume properties and modifying volume hierarchy](pictures/020001F6.jpg). - *Visualization*. This category allows changing the visibility of the; edited volume or for its daughters, as well as other visuali",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:171961,depend,depend,171961,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['depend'],['depend']
Integrability,"histogram. Therefore, the original `HistoToWorkspaceFactory` is now removed to avoid; confusion and maintainance burden. #### Removing constant parameter flag from RooStats:HistFactory::NormFactor. As printed out by the HistFactory in a warning message for a long time already,; setting the `Const` attribute to the `<NormFactor>` tag is deprecated and it; will be ignored. Instead, add `<ParamSetting Const=""True""> myparam </ParamSetting>` to your top-level XML's `<Measurement>` entry. This deprecation implied that the constant parameter flag in the; `RooStats:HistFactory::NormFactor` class had no effect as well. To avoid; ambiguity in the future, the possibility to set and retrieve this flag with; `NormFactor::SetConst()` and `NormFactor::GetConst()` was removed, as well as the; `Sample::AddNormFactor(std::string Name, double Val, double Low, double High, bool Const)`; overload. Also, the aforementioned deprecation warning is not printed anymore. ### Removal of `RooAbsMinimizerFcn` and `RooMinimizerFcn` from the public interface. The `RooAbsMinimizerFcn` class and its implementation `RooMinimizerFcn` were removed from the public interface.; These classes are implementation details of the RooMinimizer and should not be used in your code.; In the unlikely case that this causes any problem for you, please open a GitHub issue requesting to extend the RooMinimizer by the needed functionality. ### Vectorize `RooAbsBinning` interface for bin index lookups. The `RooAbsBinning` interface for bin index lookups was changed to enable vectorized implementations.; Instead of having the override `RooAbsBinning::binNumber()`, the binning implementations now have to override the `RooAbsBinning::binNumbers()` function to evaluate the bin indices of multiple values in one function call. ### Disable relative and absolute epsilon in `RooAbsRealLValue::inRange()`. So far, the `RooAbsRealLValue::inRange()` function used the following; undocumented convention to check whether a value `x` is i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:24203,interface,interface,24203,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['interface'],['interface']
Integrability,"hm. The class inherits from a virtual interface, which is also implemented by the MathMore root finder methods. The user can instantiate, via the common ROOT::Math::RootFinder class, all the various root finder algorithms. The BrentRootFinder class is used by TF1::GetX . ; A similar class, BrentMinimizer1D, provides the possibility to find the minimum of one-dimensional functions using the Brent algorithm. This class is used by TF1::GetMinimum or TF1::GetMaximum; Use ROOT convention for all enumeration names defining the type of numerical algorithms (start with k, like kADAPTIVE for the integration type). This affects both MathCore and MathMore.; . In addition we use now the ROOT convention for all enumeration names defining the type of numerical algorithms. The names start with k, like kADAPTIVE for the integration type. This change affects both MathCore and MathMore and it breaks backward compatibility. MathCore Function interfaces; Mathcore provides as well interfaces for the evaluation of mathematical and parametric functions to be used in the numerical methods. This release contains the following changes:. The ROOT::Math::IParamFunction, ROOT::Math::IParamMultiFunction interfaces (used mainly for fitting) require now a pointer to the parameters (type const double *), when evaluating the function. The derived classes must implement now the const; method DoEvalPar (and not DoEval as before). In addition the method; operator()(const double * x, const double * p) is now const. This change makes the caching of parameter not hidden and the interface is now; thread-safe. ; A similar change in the ROOT::Math::IParamGradFunction, ROOT::Math::IParamMultiGradFunction interfaces, where the parameter values are now required for calculating the partial derivatives with respect to the parameters.; This changes the signature of the pure abstract method, DoParameterDerivative(const double *x, const double * p, , which takes also a pointer (type const double *) to the parameters",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:8720,interface,interfaces,8720,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,4,['interface'],['interfaces']
Integrability,"ho are unfamiliar with either are; encouraged to start with the recommended references in `Related Reading`_. Example: style-checking names; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Assume you have a style-guide rule which forbids functions from being named; ""MkX"" and you want to write a check that catches any violations of this rule. We; can express this a Transformer rewrite rule:. .. code-block:: c++. makeRule(functionDecl(hasName(""MkX"").bind(""fun""),; 	 noopEdit(node(""fun"")),; 	 cat(""The name ``MkX`` is not allowed for functions; please rename""));. ``makeRule`` is our go-to function for generating rewrite rules. It takes three; arguments: the pattern, the edit, and (optionally) an explanatory note. In our; example, the pattern (``functionDecl(...)``) identifies the declaration of the; function ``MkX``. Since we're just diagnosing the problem, but not suggesting a; fix, our edit is an no-op. But, it contains an *anchor* for the diagnostic; message: ``node(""fun"")`` says to associate the message with the source range of; the AST node bound to ""fun""; in this case, the ill-named function declaration.; Finally, we use ``cat`` to build a message that explains the change. Regarding the; name ``cat`` -- we'll discuss it in more detail below, but suffice it to say that; it can also take multiple arguments and concatenate their results. Note that the result of ``makeRule`` is a value of type; ``clang::transformer::RewriteRule``, but most users don't need to care about the; details of this type. Example: renaming a function; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Now, let's extend this example to a *transformation*; specifically, the second; example above:. .. code-block:: c++. makeRule(declRefExpr(to(functionDecl(hasName(""MkX"")))),; 	 changeTo(cat(""MakeX"")),; 	 cat(""MkX has been renamed MakeX""));. In this example, the pattern (``declRefExpr(...)``) identifies any *reference* to; the function ``MkX``, rather than the declaration itself, as in our previous; example. Our edit (``changeTo(...)``) ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:3804,message,message,3804,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,2,['message'],['message']
Integrability,"hod; that still applies one can also edit drawn geometry objects. For this,; the menu entry View/Editor of the canvas containing for instance a drawn; volume must be activated. For starting the volume editor one can click; on a volume. The GUI of the TGeoManager class can be started by; clicking on the top-right `40x40` pixels corner of the pad with a drawn; geometry. This is the main entry point for editing the geometry or creating new; objects. Once the interface is created (using one of the methods; described above), several categories can be accessed via a shutter GUI; widget:. - *General.* This allows changing the name/title of the geometry,; setting the top volume, closing the geometry and saving the geometry; in a file. The file name is formed by `geometry_name.C` or `.root`; depending if the geometry need to be saved as a `C` macro or a; `.root` file.; - *Shapes.* The category provides buttons for creation of all; supported shapes. The new shape name is chosen by the interface, but; can be changed from the shape editor GUI. Existing shapes can be; browsed and edited from the same category.; - *Volumes.* The category allows the creation of a new volume having a; given name, shape and medium. For creating a volume assembly only; the name is relevant. Existing volumes can be browsed or edited from; this category.; - *Materials.* Allows creation of new materials/mixtures or editing; existing ones.; - *Media.* The same for creation/editing of tracking media (materials; having a set of properties related to tracking); - *Matrices.* Allows creation of translations, rotations or combined; transformations. Existing matrices can also be browser/edited. \anchor GP08c; ### Editing Existing Objects. For editing an existing object from one of the categories described; above, the interface imposes first a selection among all objects of the; corresponding type stored in the geometry. This can be done by clicking; the button next to the blue label *Select \<object\>*. The di",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:128451,interface,interface,128451,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['interface'],['interface']
Integrability,"hods. This release contains the following changes:. The ROOT::Math::IParamFunction, ROOT::Math::IParamMultiFunction interfaces (used mainly for fitting) require now a pointer to the parameters (type const double *), when evaluating the function. The derived classes must implement now the const; method DoEvalPar (and not DoEval as before). In addition the method; operator()(const double * x, const double * p) is now const. This change makes the caching of parameter not hidden and the interface is now; thread-safe. ; A similar change in the ROOT::Math::IParamGradFunction, ROOT::Math::IParamMultiGradFunction interfaces, where the parameter values are now required for calculating the partial derivatives with respect to the parameters.; This changes the signature of the pure abstract method, DoParameterDerivative(const double *x, const double * p, , which takes also a pointer (type const double *) to the parameters.; In addition, these classes do not inherit anymore from the function gradient interface (ROOT::Math::IGradFunction and ROOT::Math::IMultiGradFunction). They define only the parameter gradient which is needed for fitting and not the coordinate gradient. A derived class, like ROOT::Math::Polynomial, implementing both functionality (coordinate and parameter gradient) inherits then from both interfaces.; . More detailed description of the current MathCore release can be found at this location. MathMore; This new release contains:. Modify and rename the class ROOT::Math::RootFinder to ROOT::Math::GSLRootFinder to distinguish from the main interface class which has been put in the Mathcore library and it can create the GSLRootFinder using the plug-in manager. Furthermore, the class ROOT::Math::GSLRootFinder is not anymore a template class on the algorithm. They type of root-finder algorithm can now be selected via an enumeration; Fixed a bug in the ROOT::Math::GSLNLSMultiFi class.; Changes also in the class for the new enumeration names (all names start with k, lik",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:9863,interface,interface,9863,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,2,['interface'],['interface']
Integrability,"hon-related cmake variables; are now just the ones automatically produced by cmake (see https://cmake.org/cmake/help/latest/module/FindPython.html). ### More usage of the public cppyy API. Many implementation details of the ROOT pythonizations were moved from C++ functions to pure Python bindings using the; public cppyy API. This helps in the integration with the tool but also improves code efficiency and memory usage. ## Class Reference Guide. - Define missing doxygen groups.; - Fix a few typos in the `THStack` documentation.; - Small fixes in the `THistPainter` documentation.; - Improve the `TColor` documentation: use modern C++ in the examples.; - Make sure the python examples do not generate wrong namespaces in the documentation.; - The dataframe tutorials json spec files were not displayed properly. Moreover there was; no direct correspondence between the code source and the json file. Those files do not; have any doc in them. With a direct link to the GitHub source file the dependency between source; code and json is now more obvious.; - Document how to remove shadow of `TPave`, as it was not evident (only explanations were hidden here and there in the forum).; - Improve the `SetFillColorAlpha` documentation.; - Simplify some graphics examples: arrow.C, crown.C, diamond.C and ellipse.C.; - Fix a typo in the documentation of `TGraph::SetHighlight` in `TGraph.cxx`.; - Change the marker style in the tutorial `df014_CSVDataSource`.; - Remove useless settings in the tutorial `scatter.C`.; - Fix the tutorial `h1analysisTreeReader.C`.; - Fix doxygen formatting in `TGNumberEntry.cxx`.; - Avoid the CDT documentation to appear in the reference guide.; - Remove last references to the old ROOT `drupal` website. ## Build, Configuration and Testing Infrastructure. Release v6.32.00 is the first one integrated and tested entirely through the new GitHub based build system. ## Bugs and Issues fixed in this release. More than 200 items were addressed for this release. The full li",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:23844,depend,dependency,23844,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['depend'],['dependency']
Integrability,"honor-infinities``. * ``-fno-honor-nans``. * ``-fapprox-func``. * ``-fno-math-errno``. * ``-ffinite-math-only``. * ``-fassociative-math``. * ``-freciprocal-math``. * ``-fno-signed-zeros``. * ``-fno-trapping-math``. * ``-fno-rounding-math``. * ``-ffp-contract=fast``. Note: ``-ffast-math`` causes ``crtfastmath.o`` to be linked with code. See; :ref:`crtfastmath.o` for more details. .. option:: -fno-fast-math. Disable fast-math mode. This options disables unsafe floating-point; optimizations by preventing the compiler from making any transformations that; could affect the results. This option implies:. * ``-fhonor-infinities``. * ``-fhonor-nans``. * ``-fno-approx-func``. * ``-fno-finite-math-only``. * ``-fno-associative-math``. * ``-fno-reciprocal-math``. * ``-fsigned-zeros``. * ``-ffp-contract=on``. Also, this option resets following options to their target-dependent defaults. * ``-f[no-]math-errno``; * ``-fdenormal-fp-math=<value>``. There is ambiguity about how ``-ffp-contract``, ``-ffast-math``,; and ``-fno-fast-math`` behave when combined. To keep the value of; ``-ffp-contract`` consistent, we define this set of rules:. * ``-ffast-math`` sets ``ffp-contract`` to ``fast``. * ``-fno-fast-math`` sets ``-ffp-contract`` to ``on`` (``fast`` for CUDA and; HIP). * If ``-ffast-math`` and ``-ffp-contract`` are both seen, but; ``-ffast-math`` is not followed by ``-fno-fast-math``, ``ffp-contract``; will be given the value of whichever option was last seen. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has been seen at least; once, the ``ffp-contract`` will get the value of the last seen value of; ``-ffp-contract``. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has not been seen, the; ``-ffp-contract`` setting is determined by the default value of; ``-ffp-contract``. Note: ``-fno-fast-math`` implies ``-fdenormal-fp-math=ieee``.; ``-fno-fast-math`` causes ``crtfastmath.o`` to not be linked with code. .. option:: -fdenormal-fp-math=<value>. Select which denormal n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:53636,contract,contract,53636,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['contract'],['contract']
Integrability,"hough it has some holes (it allows ""``123KKK``"" for example),; it is good enough for this example. Note that we use the option itself to print; out the error message (the ``error`` method always returns true) in order to get; a nice error message (shown below). Now that we have our parser class, we can; use it like this:. .. code-block:: c++. static cl::opt<unsigned, false, FileSizeParser>; MFS(""max-file-size"", cl::desc(""Maximum file size to accept""),; cl::value_desc(""size""));. Which adds this to the output of our program:. ::. OPTIONS:; -help - display available options (-help-hidden for more); ...; -max-file-size=<size> - Maximum file size to accept. And we can test that our parse works correctly now (the test program just prints; out the max-file-size argument value):. ::. $ ./test; MFS: 0; $ ./test -max-file-size=123MB; MFS: 128974848; $ ./test -max-file-size=3G; MFS: 3221225472; $ ./test -max-file-size=dog; -max-file-size option: 'dog' value invalid for file size argument!. It looks like it works. The error message that we get is nice and helpful, and; we seem to accept reasonable file sizes. This wraps up the ""custom parser""; tutorial. Exploiting external storage; ---------------------------. Several of the LLVM libraries define static ``cl::opt`` instances that will; automatically be included in any program that links with that library. This is; a feature. However, sometimes it is necessary to know the value of the command; line option outside of the library. In these cases the library does or should; provide an external storage location that is accessible to users of the; library. Examples of this include the ``llvm::DebugFlag`` exported by the; ``lib/Support/Debug.cpp`` file and the ``llvm::TimePassesIsEnabled`` flag; exported by the ``lib/IR/PassManager.cpp`` file. .. todo::. TODO: complete this section. .. _dynamically loaded options:. Dynamically adding command line options; ---------------------------------------. .. todo::. TODO: fill in this section; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:66302,message,message,66302,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,2,"['message', 'wrap']","['message', 'wraps']"
Integrability,"hould be declared this way:; BreakBeforeBraces: Custom; BraceWrapping:; AfterClass: true. * ``bool AfterCaseLabel`` Wrap case labels. .. code-block:: c++. false: true:; switch (foo) { vs. switch (foo) {; case 1: { case 1:; bar(); {; break; bar();; } break;; default: { }; plop(); default:; } {; } plop();; }; }. * ``bool AfterClass`` Wrap class definitions. .. code-block:: c++. true:; class foo; {};. false:; class foo {};. * ``BraceWrappingAfterControlStatementStyle AfterControlStatement``; Wrap control statements (``if``/``for``/``while``/``switch``/..). Possible values:. * ``BWACS_Never`` (in configuration: ``Never``); Never wrap braces after a control statement. .. code-block:: c++. if (foo()) {; } else {; }; for (int i = 0; i < 10; ++i) {; }. * ``BWACS_MultiLine`` (in configuration: ``MultiLine``); Only wrap braces after a multi-line control statement. .. code-block:: c++. if (foo && bar &&; baz); {; quux();; }; while (foo || bar) {; }. * ``BWACS_Always`` (in configuration: ``Always``); Always wrap braces after a control statement. .. code-block:: c++. if (foo()); {; } else; {}; for (int i = 0; i < 10; ++i); {}. * ``bool AfterEnum`` Wrap enum definitions. .. code-block:: c++. true:; enum X : int; {; B; };. false:; enum X : int { B };. * ``bool AfterFunction`` Wrap function definitions. .. code-block:: c++. true:; void foo(); {; bar();; bar2();; }. false:; void foo() {; bar();; bar2();; }. * ``bool AfterNamespace`` Wrap namespace definitions. .. code-block:: c++. true:; namespace; {; int foo();; int bar();; }. false:; namespace {; int foo();; int bar();; }. * ``bool AfterObjCDeclaration`` Wrap ObjC definitions (interfaces, implementations...). .. note::. @autoreleasepool and @synchronized blocks are wrapped; according to ``AfterControlStatement`` flag. * ``bool AfterStruct`` Wrap struct definitions. .. code-block:: c++. true:; struct foo; {; int x;; };. false:; struct foo {; int x;; };. * ``bool AfterUnion`` Wrap union definitions. .. code-block:: c++. true:; union ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:39859,wrap,wrap,39859,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['wrap'],['wrap']
Integrability,"hould be:; #. A proposal for removal / deactivation should be made to the Discourse forums ; (under the appropriate category), with a clear; statement of the maintenance costs imposed and the alternatives, if; applicable.; #. There must be enough consensus on the list that removal is warranted, and no; pending proposals to fix the situation from a sub-community.; #. An announcement for removal must be made on the same lists, with ample time; for downstream users to take action on their local infrastructure. The time; will depend on what is being removed. #. If a script or documents are to be removed, they can always be pulled; from previous revision, and can be removed within days.; #. if a whole target is removed, we need to first announce publicly, and; potentially mark as deprecated in one release, only to remove on the; next release.; #. Everything else will fall in between those two extremes.; #. The removal is made by either the proposer or the sub-community that used to; maintain it, with replacements and arrangements made atomically on the same; commit. If a proposal for removal is delayed by the promise a sub-community will take; care of the code affected, the sub-community will have a time to fix all the; issues (depending on each case, as above), and if those are not fixed in time, a; subsequent request for removal should be made and the community may elect to; eject the component without further attempts to fix. Reinstatement; -------------. If a component is removed from LLVM, it may, at a later date, request inclusion; of a modified version, with evidence that all of the issues were fixed and that; there is a clear sub-community that will maintain it. By consequence, the pressure on such sub-community will be higher to keep; overall maintenance costs to a minimum and will need to show steps to mitigate; all of the issues that were listed as reasons for its original removal. Failing on those again, will lead to become a candidate for removal yet again. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst:10650,depend,depending,10650,interpreter/llvm-project/llvm/docs/SupportPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst,1,['depend'],['depending']
Integrability,"hould have its ``__creates__`` flag set through its; :doc:`pythonization <pythonizations>`.; Well-written APIs will have clear clues in their naming convention about the; ownership rules.; For example, functions called ``New...``, ``Clone...``, etc. can be expected; to return freshly allocated objects.; A basic name-matching in the pythonization then makes it simple to mark all; these functions as creators. The return values are :ref:`auto-casted <sec-auto-casting-label>`. `\*args and \*\*kwds`; ---------------------. C++ default arguments work as expected.; Keywords, however, are a Python language feature that does not exist in C++.; Many C++ function declarations do have formal arguments, but these are not; part of the C++ interface (the argument names are repeated in the definition,; making the names in the declaration irrelevant: they do not even need to be; provided).; Thus, although ``cppyy`` will map keyword argument names to formal argument; names from the C++ declaration, use of this feature is not recommended unless; you have a guarantee that the names in C++ the interface are maintained.; Example:. .. code-block:: python. >>> from cppyy.gbl import Concrete; >>> c = Concrete() # uses default argument; >>> c.m_int; 42; >>> c = Concrete(13) # uses provided argument; >>> c.m_int; 13; >>> args = (27,); >>> c = Concrete(*args) # argument pack; >>> c.m_int; 27; >>> c = Concrete(n=17); >>> c.m_int; 17; >>> kwds = {'n' : 18}; >>> c = Concrete(**kwds); >>> c.m_int; 18; >>>. `Callbacks`; -----------. Python callables (functions/lambdas/instances) can be passed to C++ through; function pointers and/or ``std::function``.; This involves creation of a temporary wrapper, which has the same life time as; the Python callable it wraps, so the callable needs to be kept alive on the; Python side if the C++ side stores the callback.; Example:. .. code-block:: python. >>> from cppyy.gbl import call_int_int; >>> print(call_int_int.__doc__); int ::call_int_int(int(*)(int,int) f, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/functions.rst:13734,interface,interface,13734,bindings/pyroot/cppyy/cppyy/doc/source/functions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/functions.rst,1,['interface'],['interface']
Integrability,"hould; use the constructor:. ~~~{.cpp}; TGeoMaterial(const char *name, TGeoElement *elem, Double_t density); ~~~. To create a radioactive mixture, one can use radionuclides as well as; stable elements:. ~~~{.cpp}; TGeoMixture(const char *name, Int_t nelements, Double_t density);; TGeoMixture::AddElement(TGeoElement *elem,; Double_t weight_fraction);; ~~~. Once defined, one can retrieve the time evolution for the radioactive; materials/mixtures by using one of the next two methods:. #### Method 1. ~~~{.cpp}; TGeoMaterial::FillMaterialEvolution(TObjArray *population, Double_t precision=0.001); ~~~. To use this method, one has to provide an empty TObjArray object; that will be filled with all elements coming from the decay chain of the; initial radionuclides contained by the material/mixture. The precision; represent the cumulative branching ratio for which decay products are; still considered. \image html geometry003.png width=600px. The population list may contain stable elements as well as; radionuclides, depending on the initial elements. To test if an element; is a radionuclide:. ~~~{.cpp}; Bool_t TGeoElement::IsRadioNuclide() const; ~~~. All radionuclides in the output population list have attached objects; that represent the time evolution of their fraction of nuclei with; respect to the top radionuclide in the decay chain. These objects; (Bateman solutions) can be retrieved and drawn:. ~~~{.cpp}; TGeoBatemanSol *TGeoElementRN::Ratio();; void TGeoBatemanSol::Draw();; ~~~. #### Method 2. Another method allows to create the evolution of a given radioactive; material/mixture at a given moment in time:. ~~~{.cpp}; TGeoMaterial::DecayMaterial(Double_t time, Double_t precision=0.001); ~~~. The method will create the mixture that result from the decay of a; initial material/mixture at time, while all resulting elements having a; fractional weight less than precision are excluded. A demo macro for radioactive material features is; `$ROOTSYS/tutorials/geom/RadioNuclides.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/materials.md:8045,depend,depending,8045,geom/geom/doc/materials.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/materials.md,1,['depend'],['depending']
Integrability,"hread local. This fixes [ROOT-7791].; * Fix some bugs in TF1NormSum (to fit normalized sum of functions) and in TF1Convolution; * Add a new histogram fitting option, `WIDTH` to fit directly density. The bin content in this case is scaled by the histogram bin width. ### TFormula. * Fix several bugs in the new TFormula class.; * Add as new pre-defined functions: `crystalball`, `breitwigner` and `cheb0,cheb1,...cheb10` for the Chebyshev polynomials. . ## Math Libraries. ### Random numbers. * Move from MathMore to MathCore the class `ROOT::Math::Random`. Make it a new interface class for random number generation. Add interfaces for standard; ROOT random engines, GSL random engines and random engines provided by the C++ standard library (`std::random`).; * Add a new randomengine, `MIXMAX` based on matrix-recursive random number generator from Kostas and George Savvidy. See this [paper](http://dx.doi.org/10.1016/j.cpc.2015.06.003). ## R Interface. Apply several improvements in the interface to R, allowing to use R functions within ROOT.; See more at the [ROOT-R User Guide](http://oproject.org/tiki-index.php?page=ROOT%20R%20Users%20Guide). . ## TMVA. Add new TMVA plug-in based on R and Python (using Scikit-Learn) ; * See the [RMVA Web page](http://oproject.org/tiki-index.php?page=RMVA) for a detailed description of the new TMVA method based on R; * See the [PyMVA Web page](http://oproject.org/tiki-index.php?page=PyMVA) for detailed description of the machine learning methods added in TMVA and based on the Python Scikit-Learn package. ## RooFit Libraries; . ## 2D Graphics Libraries. ### THistPainter. Improve the algorithm to compute the lower limit of an axis in log scale when its; real lower limit is 0. The problem was reported in ROOT-7414. Using the `COL` option with histograms having some negative bins; the empty bins; (containing 0) are drawn. In some cases one wants to not draw empty bins; (containing 0) of histograms having a negative minimum. The option `1`, used wit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:13897,interface,interface,13897,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['interface'],['interface']
Integrability,"https://cmake.org/cmake/help/v3.4/module/CMakeParseArguments.html>`_. .. note::; As of CMake 3.5 the cmake_parse_arguments command has become a native command; and the CMakeParseArguments module is empty and only left around for; compatibility. Functions Vs Macros; -------------------. Functions and Macros look very similar in how they are used, but there is one; fundamental difference between the two. Functions have their own scope, and; macros don't. This means variables set in macros will bleed out into the calling; scope. That makes macros suitable for defining very small bits of functionality; only. The other difference between CMake functions and macros is how arguments are; passed. Arguments to macros are not set as variables, instead dereferences to; the parameters are resolved across the macro before executing it. This can; result in some unexpected behavior if using unreferenced variables. For example:. .. code-block:: cmake. macro(print_list my_list); foreach(var IN LISTS my_list); message(""${var}""); endforeach(); endmacro(). set(my_list a b c d); set(my_list_of_numbers 1 2 3 4); print_list(my_list_of_numbers); # prints:; # a; # b; # c; # d. Generally speaking this issue is uncommon because it requires using; non-dereferenced variables with names that overlap in the parent scope, but it; is important to be aware of because it can lead to subtle bugs. LLVM Project Wrappers; =====================. LLVM projects provide lots of wrappers around critical CMake built-in commands.; We use these wrappers to provide consistent behaviors across LLVM components; and to reduce code duplication. We generally (but not always) follow the convention that commands prefaced with; ``llvm_`` are intended to be used only as building blocks for other commands.; Wrapper commands that are intended for direct use are generally named following; with the project in the middle of the command name (i.e. ``add_llvm_executable``; is the wrapper for ``add_executable``). The LLVM ``add_*`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst:12709,message,message,12709,interpreter/llvm-project/llvm/docs/CMakePrimer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst,1,['message'],['message']
Integrability,"hub.com/root-project/root/issues/14385)] - Strange behavior with TF1 and SetParameters; * [[#14381](https://github.com/root-project/root/issues/14381)] - Legend entry for exclusion graph; * [[#14376](https://github.com/root-project/root/issues/14376)] - build failure with `mysql 8.3`; * [[#14372](https://github.com/root-project/root/issues/14372)] - File with mtime equal to 0 are ignored by Cling.; * [[#14333](https://github.com/root-project/root/issues/14333)] - ""Empty plot"" for df014_CSVDataSource.C ; * [[#14331](https://github.com/root-project/root/issues/14331)] - Unexpected behaviour when using the Project3D function to make a TH2 from a TH3; * [[#14329](https://github.com/root-project/root/issues/14329)] - [RF] RDataFrameToRooFit - Clarification on returned object; * [[#14324](https://github.com/root-project/root/issues/14324)] - Compatibility Issue with thisroot.sh and zsh ; * [[#14320](https://github.com/root-project/root/issues/14320)] - [RF] Wrong analytic integrals when using Gaussians with sigma depending on the observable; * [[#14303](https://github.com/root-project/root/issues/14303)] - Test failure with `nbconvert-7.14`; * [[#14302](https://github.com/root-project/root/issues/14302)] - The command ""root --notebook"" is not allowed on Windows 11; * [[#14277](https://github.com/root-project/root/issues/14277)] - Cling triggers a huge number of `openat` calls when loading libraries; * [[#14263](https://github.com/root-project/root/issues/14263)] - [tmva] When using DNN_USE_CBLAS, CMakeLists should link publicly to gsl instead of privately; * [[#14256](https://github.com/root-project/root/issues/14256)] - TAxis::GetTicks and TAxis::SetTicks are inconsistent. Significantly so.; * [[#14244](https://github.com/root-project/root/issues/14244)] - String comparison operators defined in TString.h should be defined as constexpr; * [[#14229](https://github.com/root-project/root/issues/14229)] - [6.30] root-config --git-revision broken; * [[#14225](https://github.com",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:33265,depend,depending,33265,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['depend'],['depending']
Integrability,"hub.com/vmc-project/vmc](https://github.com/vmc-project/vmc); to replace the deprecated version in ROOT. ### Removed packages. Support for the following optional components of ROOT has been removed:. * afdsmgrd (Dataset manager for PROOF-based analysis facilities); * bonjour (Avahi/Bonjour/Zeroconf); * castor (CERN Advanced STORage manager); * geocad (OpenCascade); * globus (Globus authentication); * hdfs (Hadoop Distributed File System); * krb5 (Kerberos 5 authentication); * ldap (OpenLDAP authentication); * memstat (legacy memory statistics utility); * qt, qtgsi, qtroot (Qt4-based GUI components); * rfio (Remote File IO for CASTOR); * table (libTable contrib library). In addition, the following deprecated parts of ROOT components have been; removed:. * PROOF's PQ2 module; * `THttpServer::ExecuteHttp()` and `THttpServer::SubmitHttp` from `THttpServer`. ### Other changes. The deprecation of the GraphViz integration has been reverted since the code is; still in use. The ODBC interface, deprecated in ROOT 6.16, is no longer deprecated in ROOT 6.18.; It is the main option to support databases on Windows, so the decision to deprecate; it was reverted. The `xft` option has been merged into `x11` and is no longer used (its value is; now ignored by ROOT). ## Preprocessor deprecation macros; ### Deprecated Classes; * `R__SUGGEST_ALTERNATIVE(""Suggestion text"")` macro allows to suggest alternatives to classes. It must be used after the class definition and before the final semicolon:; ```{.cpp}; class DoNotUseClass {; } R__SUGGEST_ALTERNATIVE(""Use ... instead."");; ```; It is activated by the preprocessor defines `R__SUGGEST_NEW_INTERFACE`. The former is useful when deprecation warnings should be activated/deactivated at global level, for example for an entire project. This could be done by defining `R__SUGGEST_NEW_INTERFACE` in the build system. ; If the warning needs to be confined within single translation units, irrespective of the definition of `R__SUGGEST_NEW_INTERFACE`,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md:2627,interface,interface,2627,README/ReleaseNotes/v618/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md,1,['interface'],['interface']
Integrability,"iable. See the discussion above ‘Getting the right parameter; errors with limits'. The best way to be absolutely sure of the errors is to use; ''independent'' calculations and compare them, or compare the; calculated errors with a picture of the function. Theoretically, the; covariance matrix for a ''physical'' function must be; positive-definite at the minimum, although it may not be so for all; points far away from the minimum, even for a well-determined physical; problem. Therefore, if `MIGRAD` reports that it has found a; non-positive-definite covariance matrix, this may be a sign of one or; more of the following:. #### A Non-physical Region. On its way to the minimum, `MIGRAD` may have traversed a region that; has unphysical behavior, which is of course not a serious problem as; long as it recovers and leaves such a region. #### An Underdetermined Problem. If the matrix is not positive-definite even at the minimum, this may; mean that the solution is not well defined, for example that there are; more unknowns than there are data points, or that the parameterization; of the fit contains a linear dependence. If this is the case, then; `Minuit` (or any other program) cannot solve your problem uniquely.; The error matrix will necessarily be largely meaningless, so the user; must remove the under determinedness by reformulating the; parameterization. `Minuit` cannot do this itself. #### Numerical Inaccuracies. It is possible that the apparent lack of positive-definiteness is due; to excessive round off errors in numerical calculations (in the user; function), or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or; if the parameters are badly scaled (not all of the same order of; magnitude), and correlations are large. In any case, whether the; non-positive-definiteness is real or only numerical is largely; irrelevant, since in both cases the error matrix will be unreliable; and the minimum sus",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:63248,depend,dependence,63248,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['depend'],['dependence']
Integrability,"iagnostics. For example:. .. code-block:: C++. unknownFunction().size() // .size() is a CXXDependentScopeMemberExpr; std::string(42).size() // .size() is a resolved MemberExpr. Whether or not the ``RecoveryExpr`` has a dependent type, it is always; considered value-dependent, because its value isn't well-defined until the error; is resolved. Among other things, this means that clang doesn't emit more errors; where a RecoveryExpr is used as a constant (e.g. array size), but also won't try; to evaluate it. ContainsErrors bit; ^^^^^^^^^^^^^^^^^^. Beyond the template dependence bits, we add a new “ContainsErrors” bit to; express “Does this expression or anything within it contain errors” semantic,; this bit is always set for RecoveryExpr, and propagated to other related nodes.; This provides a fast way to query whether any (recursive) child of an expression; had an error, which is often used to improve diagnostics. .. code-block:: C++. // C++; void recoveryExpr(int abc) {; unknownFunction(); // type-dependent, value-dependent, contains-errors. std::string(42).size(); // value-dependent, contains-errors,; // not type-dependent, as we know the type is std::string; }. .. code-block:: C. // C; void recoveryExpr(int abc) {; unknownVar + abc; // type-dependent, value-dependent, contains-errors; }. The ASTImporter; ---------------. The ``ASTImporter`` class imports nodes of an ``ASTContext`` into another; ``ASTContext``. Please refer to the document :doc:`ASTImporter: Merging Clang; ASTs <LibASTImporter>` for an introduction. And please read through the; high-level `description of the import algorithm; <LibASTImporter.html#algorithm-of-the-import>`_, this is essential for; understanding further implementation details of the importer. .. _templated:. Abstract Syntax Graph; ^^^^^^^^^^^^^^^^^^^^^. Despite the name, the Clang AST is not a tree. It is a directed graph with; cycles. One example of a cycle is the connection between a; ``ClassTemplateDecl`` and its ""templated"" ``CXXRe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:89598,depend,dependent,89598,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,2,['depend'],['dependent']
Integrability,"iasing and qualification conversions; Yes. 159; TC1; Namespace qualification in declarators; Clang 3.5. 160; CD1; Missing std:: qualification; N/A. 161; TC1; Access to protected nested type; Clang 3.1. 162; CD1; (&C::f)() with nonstatic members; No. 163; TC1; Description of subaggregate initializer; N/A. 164; TC1; Overlap between Koenig and normal lookup; Yes. 165; NAD; Definitions of friends and block-scope externs; No. 166; TC1; Friend declarations of template-ids; Clang 2.9. 167; NAD; Deprecating static functions; Superseded by 1012. 168; NAD; C linkage for static member functions; No. 169; NAD; template-ids in using-declarations; Yes. 170; DRWP; Pointer-to-member conversions; Unknown. 171; TC1; Global namespace scope; Clang 3.4. 172; CD1; Unsigned int as underlying type of enum; Yes. 173; TC1; Constraints on execution character set; Yes. 174; NAD; Undeprecating global static; Superseded by 1012. 175; CD1; Class name injection and base name access; Clang 2.8. 176; TC1; Name injection and templates; Clang 3.1. 177; CD1; Lvalues vs rvalues in copy-initialization; Yes. 178; TC1; More on value-initialization; Yes. 179; TC1; Function pointers and subtraction; Yes. 180; CD1; typename and elaborated types; Clang 2.8. 181; TC1; Errors in template template-parameter example; Yes. 182; NAD; Access checking on explicit specializations; Clang 14. 183; TC1; typename in explicit specializations; Superseded by 382. 184; CD1; Default arguments in template template-parameters; Yes. 185; TC1; ""Named"" temporaries and copy elision; Unknown. 186; open; Name hiding and template template-parameters; Not resolved. 187; TC1; Scope of template parameter names; Superseded by 481. 188; TC1; Comma operator and rvalue conversion; Yes. 189; drafting; Definition of operator and punctuator; Not resolved. 190; TC1; Layout-compatible POD-struct types; Unknown. 191; CD6; Name lookup does not handle complex nesting; Yes. 192; NAD; Name lookup in parameters; Unknown. 193; TC1; Order of destruction of ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:11784,inject,injection,11784,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['inject'],['injection']
Integrability,"ible in the output of the; program, since the order in which outputs appear in the buffer is changed.; However, this does not break the overall contract that ``@reserveSpaceInBuffer``; has with its caller -- which makes sense: the order of outputs is; non-deterministic anyway because of the atomic operation that is involved. If the function is inlined, the use of the anchor intrinsic similarly indicates; that certain transforms which are usually forbidden by the presence of; convergent operations are in fact allowed, as long as they don't break up the; region of code that is controlled by the anchor. .. _convergence_high-level_break:. Extended Cycles: Divergent Exit from a Loop; -------------------------------------------. High-level languages typically provide a ``break`` statement that transfers; control out of a loop statement. In most cases, the loop is structured and hence; there is no ambiguity about convergence inside the loop. But an ambiguity arises; when a ``break`` is control dependent on a divergent condition inside the loop.; Consider the following example:. .. code-block:: c++. void example() {; // A; ...; for (...) {; // B; if (condition) { // divergent condition; // C; convergent_op();; break;; }; // D; ...; }; // E; }. In this program, the call to convergent_op() is lexically ""inside"" the ``for``; loop. But when translated to LLVM IR, the basic block B is an exiting block; ending in a divergent branch, and the basic block C is an exit of the loop.; Thus, the call to convergent_op() is outside the loop. This causes a mismatch; between the programmer's expectation and the compiled program. The call should; be executed convergently on every iteration of the loop, by threads that; together take the branch to exit the loop. But when compiled, all threads that; take the divergent exit on different iterations first converge at the beginning; of basic block C and then together execute the call to convergent_op(). In this case, :ref:`llvm.experimental.converg",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:15900,depend,dependent,15900,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['depend'],['dependent']
Integrability,"ibrary and other code. This change also affects the `RooNumber::isInfinite()` function. ### Remove `add(row, weight, weightError)` from RooAbsData interface. It was not good to have this signature in RooAbsData, because the; implementations in the two derived classes RooDataHist and RooDataSet were; inconsistent. The RooDataSet indeed took the weight error as the third argument, but; the RooDataHist version instead took the sum of weights squared, which; is equivalent to the squared weight error. Therefore, the virtual `RooAbsData::add(row, weight, weightError)` function was removed. ### Removal of `RooMomentMorphND` class. The `RooMomentMorphND` and `RooMomentMorphFuncND` were almost exactly the same,; only that one inherited from `RooAbsPdf` and the other from `RooAbsReal`. Thanks to the `RooWrapperPdf`, this code duplication in the RooFit implementation can now be avoided.; Instead of using the removed `RooMomentMorphND` (which is the pdf), you now need to use the `RooMomentMorphFuncND`,; change its behavior to exactly match the formter `RooMomentMorphND`, and then wrap it into a pdf object:. ```C++; RooMomentMorphFuncND func{<constructor args you previously passed to RooMomentMorphFunc>};. func.setPdfMode(); // change behavior to be exactly like the former RooMomentMorphND. // Pass the selfNormalized=true` flag to the wrapper because the; RooMomentMorphFuncND already normalizes itself in pdf mode.; RooWrapperPdf pdf{""pdf_name"", ""pdf_name"", func, /*selfNormalized=*/true};; ```. ### Removal of several internal classes from the public RooFit interface. Several RooFit classes of which the headers are publicly exposed in the interface were only meant as implementation details of other RooFit classes.; Some of these classes are now removed from the public interface:. 1. `RooGenProdProj`, which was an implementation detail of the `RooProdPdf`; 2. `RooScaledFunc`, which was an implementation detail of the plotting in RooFit; In the supposedly very rare case where you us",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md:14260,wrap,wrap,14260,README/ReleaseNotes/v630/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md,1,['wrap'],['wrap']
Integrability,"ibutors see $ROOTSYS/README/CREDITS. set(CFITSIO_VERSION 4.4.0). set(CFITSIO_PREFIX ${CMAKE_BINARY_DIR}/CFITSIO-prefix); set(CFITSIO_LIBRARIES ${CFITSIO_PREFIX}/lib/${CMAKE_STATIC_LIBRARY_PREFIX}cfitsio${CMAKE_STATIC_LIBRARY_SUFFIX}). if(NOT WIN32); set(CFITSIO_C_FLAGS -fPIC); endif(). if(WIN32 AND NOT CMAKE_GENERATOR MATCHES Ninja); if(winrtdebug); set(CFITSIO_BUILD_COMMAND_FLAGS ""--config Debug""); else(); set(CFITSIO_BUILD_COMMAND_FLAGS ""--config Release""); endif(); endif(). ExternalProject_Add(; BUILTIN_CFITSIO; PREFIX ${CFITSIO_PREFIX}; URL https://heasarc.gsfc.nasa.gov/FTP/software/fitsio/c/cfitsio-${CFITSIO_VERSION}.tar.gz; URL_HASH SHA256=95900cf95ae760839e7cb9678a7b2fad0858d6ac12234f934bd1cb6bfc246ba9; CMAKE_ARGS -G ${CMAKE_GENERATOR}; -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}; -DCMAKE_C_FLAGS=${CFITSIO_C_FLAGS}; -DCMAKE_INSTALL_PREFIX=<INSTALL_DIR>; -DCMAKE_INSTALL_LIBDIR=<INSTALL_DIR>/lib; -DBUILD_SHARED_LIBS=OFF; -DUSE_CURL=OFF; -DZLIB_FOUND=TRUE; -DZLIB_INCLUDE_DIR=${ZLIB_INCLUDE_DIRS}; -DZLIB_LIBRARIES=$<TARGET_FILE:ZLIB::ZLIB>; # Skip the find_package(ZLIB REQUIRED), because we feed CFITSIO our own ZLIB flags.; PATCH_COMMAND git apply --ignore-space-change --ignore-whitespace; ${CMAKE_CURRENT_SOURCE_DIR}/cfitsio-no-find-zlib.diff; ${CMAKE_CURRENT_SOURCE_DIR}/no-fortran-wrapper.diff; BUILD_COMMAND ${CMAKE_COMMAND} --build . ${CFITSIO_BUILD_COMMAND_FLAGS}; INSTALL_COMMAND ${CMAKE_COMMAND} --build . ${CFITSIO_BUILD_COMMAND_FLAGS} --target install; LOG_DOWNLOAD 1 LOG_CONFIGURE 1 LOG_BUILD 1 LOG_INSTALL 1 LOG_OUTPUT_ON_FAILURE 1; BUILD_BYPRODUCTS ${CFITSIO_LIBRARIES}; TIMEOUT 600; ). add_dependencies(BUILTIN_CFITSIO ZLIB::ZLIB). add_dependencies(CFITSIO::CFITSIO BUILTIN_CFITSIO); set(CFITSIO_INCLUDE_DIRS ${CFITSIO_PREFIX}/include); file(MAKE_DIRECTORY ${CFITSIO_INCLUDE_DIRS}); set_target_properties(CFITSIO::CFITSIO PROPERTIES; IMPORTED_LOCATION ${CFITSIO_LIBRARIES}; INTERFACE_INCLUDE_DIRECTORIES ${CFITSIO_INCLUDE_DIRS}; INTERFACE_LINK_LIBRARIES ZLIB::ZLIB; ); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/cfitsio/CMakeLists.txt:1459,wrap,wrapper,1459,builtins/cfitsio/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/cfitsio/CMakeLists.txt,1,['wrap'],['wrapper']
Integrability,"ic Libraries; =========================. All libraries that you compile as part of your build will be; cross-compiled to your target, and your build system will probably; find them in the right place. But all dependencies that are; normally checked against (like ``libxml`` or ``libz`` etc) will match; against the host platform, not the target. So, if the build system is not aware that you want to cross-compile; your code, it will get every dependency wrong, and your compilation; will fail during build time, not configure time. Also, finding the libraries for your target are not as easy; as for your host machine. There aren't many cross-libraries available; as packages to most OS's, so you'll have to either cross-compile them; from source, or download the package for your target platform,; extract the libraries and headers, put them in specific directories; and add ``-I`` and ``-L`` pointing to them. Also, some libraries have different dependencies on different targets,; so configuration tools to find dependencies in the host can get the; list wrong for the target platform. This means that the configuration; of your build can get things wrong when setting their own library; paths, and you'll have to augment it via additional flags (configure,; Make, CMake, etc). Multilibs; ---------. When you want to cross-compile to more than one configuration, for; example hard-float-ARM and soft-float-ARM, you'll have to have multiple; copies of your libraries and (possibly) headers. Some Linux distributions have support for Multilib, which handle that; for you in an easier way, but if you're not careful and, for instance,; forget to specify ``-ccc-gcc-name armv7l-linux-gnueabihf-gcc`` (which; uses hard-float), Clang will pick the ``armv7l-linux-gnueabi-ld``; (which uses soft-float) and linker errors will happen. The same is true if you're compiling for different environments, like; ``gnueabi`` and ``androideabi``, and might even link and run, but produce; run-time errors, which ar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:8498,depend,dependencies,8498,interpreter/llvm-project/clang/docs/CrossCompilation.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst,2,['depend'],['dependencies']
Integrability,"ical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Derivation. There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library.; * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function.; * GSLDerivator of *MathMore* based on GSL. ## Numerical Minimization. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used for one dimensional minimization, while; the right one is used for multidimensional minimization. In the case of multidimensional minimization we have also the classes `TMinuitMinimizer` implemented using `TMinuit`, `TFumiliMinimizer`; implemented using `TFumili` for least square or likelihood minimizations.; We encourage the use of the GSL algorithms for one dimensional minimization and `Minuit2` (or the old version`Minuit`) for multi dimensional minimization. ![Numerical Minimization classes](pictures/Minimization.png). ### One-Dimensional Minimization. These algorithms are for finding the minimum of a one-dimensional minimization function.; The function to minimize must be given to the class implementing the algorithm as a; `ROOT::Math::IBaseFunctionOneDim` object.; The algorithms supported are only bracketing algorithm which do not use derivatives information. Two classes exist. One in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:62836,integrat,integration,62836,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['integrat'],['integration']
Integrability,"icate the needed directory). Note that your python interpreter (whether CPython or ``pypy-c``) may not have; been linked by the C++ compiler.; This can lead to problems during loading of C++ libraries and program shutdown.; In that case, re-linking is highly recommended. Very old versions of PyPy (5.6.0 and earlier) have a built-in ``cppyy`` based; on `Reflex`_, which is less feature-rich and no longer supported.; However, both the :doc:`distribution utilities <utilities>` and user-facing; Python codes are very backwards compatible, making migration straightforward. Precompiled header; ------------------. For performance reasons (reduced memory and CPU usage), a precompiled header; (PCH) of the system and compiler header files will be installed or, failing; that, generated on startup.; Obviously, this PCH is not portable and should not be part of any wheel. Some compiler features, such as AVX, OpenMP, fast math, etc. need to be; active during compilation of the PCH, as they depend both on compiler flags; and system headers (for intrinsics, or API calls).; You can control compiler flags through the ``EXTRA_CLING_ARGS`` envar and thus; what is active in the PCH.; In principle, you can also change the C++ language standard by setting the; appropriate flag on ``EXTRA_CLING_ARGS`` and rebuilding the PCH.; However, if done at this stage, that disables some automatic conversion for; C++ types that were introduced after C++11 (such as ``string_view`` and; ``optional``). If you want multiple PCHs living side-by-side, you can generate them; yourself (note that the given path must be absolute)::. >>> import cppyy_backend.loader as l; >>> l.set_cling_compile_options(True) # adds defaults to EXTRA_CLING_ARGS; >>> install_path = '/full/path/to/target/location/for/PCH'; >>> l.ensure_precompiled_header(install_path). You can then select the appropriate PCH with the ``CLING_STANDARD_PCH`` envar::. $ export CLING_STANDARD_PCH=/full/path/to/target/location/for/PCH/allDict.cxx.pch. Or ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/installation.rst:7892,depend,depend,7892,bindings/pyroot/cppyy/cppyy/doc/source/installation.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/installation.rst,1,['depend'],['depend']
Integrability,"ication does not alter the storage requirements for objects,; except that it is undefined behavior if a ``__weak`` object is inadequately; aligned for an object of type ``id``. The other qualifiers may be used on; explicitly under-aligned memory. The runtime tracks ``__weak`` objects which holds non-null values. It is; undefined behavior to direct modify a ``__weak`` object which is being tracked; by the runtime except through an; :ref:`objc_storeWeak <arc.runtime.objc_storeWeak>`,; :ref:`objc_destroyWeak <arc.runtime.objc_destroyWeak>`, or; :ref:`objc_moveWeak <arc.runtime.objc_moveWeak>` call. The runtime must provide a number of new entrypoints which the compiler may; emit, which are described in the remainder of this section. .. admonition:: Rationale. Several of these functions are semantically equivalent to a message send; we; emit calls to C functions instead because:. * the machine code to do so is significantly smaller,; * it is much easier to recognize the C functions in the ARC optimizer, and; * a sufficient sophisticated runtime may be able to avoid the message send in; common cases. Several other of these functions are ""fused"" operations which can be; described entirely in terms of other operations. We use the fused operations; primarily as a code-size optimization, although in some cases there is also a; real potential for avoiding redundant operations in the runtime. .. _arc.runtime.objc_autorelease:. ``id objc_autorelease(id value);``; ----------------------------------. *Precondition:* ``value`` is null or a pointer to a valid object. If ``value`` is null, this call has no effect. Otherwise, it adds the object; to the innermost autorelease pool exactly as if the object had been sent the; ``autorelease`` message. Always returns ``value``. .. _arc.runtime.objc_autoreleasePoolPop:. ``void objc_autoreleasePoolPop(void *pool);``; ---------------------------------------------. *Precondition:* ``pool`` is the result of a previous call to; :ref:`objc_autore",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:106619,message,message,106619,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['message'],['message']
Integrability,"ice`, `legalized`, `regBankSelected`, `selected`.; The whole `frameInfo` section is often unnecessary if there is no special; frame usage in the function. `tracksRegLiveness` on the other hand is often; necessary for some passes that care about block livein lists. - The (global) `liveins:` list is typically only interesting for early; instruction selection passes and can be removed when testing later passes.; The per-block `liveins:` on the other hand are necessary if; `tracksRegLiveness` is true. - Branch probability data in block `successors:` lists can be dropped if the; test doesn't depend on it. Example:; `successors: %bb.1(0x40000000), %bb.2(0x40000000)` can be replaced with; `successors: %bb.1, %bb.2`. - MIR code contains a whole IR module. This is necessary because there are; no equivalents in MIR for global variables, references to external functions,; function attributes, metadata, debug info. Instead some MIR data references; the IR constructs. You can often remove them if the test doesn't depend on; them. - Alias Analysis is performed on IR values. These are referenced by memory; operands in MIR. Example: `:: (load 8 from %ir.foobar, !alias.scope !9)`.; If the test doesn't depend on (good) alias analysis the references can be; dropped: `:: (load 8)`. - MIR blocks can reference IR blocks for debug printing, profile information; or debug locations. Example: `bb.42.myblock` in MIR references the IR block; `myblock`. It is usually possible to drop the `.myblock` reference and simply; use `bb.42`. - If there are no memory operands or blocks referencing the IR then the; IR function can be replaced by a parameterless dummy function like; `define @func() { ret void }`. - It is possible to drop the whole IR section of the MIR file if it only; contains dummy functions (see above). The .mir loader will create the; IR functions automatically in this case. .. _limitations:. Limitations; -----------. Currently the MIR format has several limitations in terms of which st",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst:4384,depend,depend,4384,interpreter/llvm-project/llvm/docs/MIRLangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst,1,['depend'],['depend']
Integrability,"ich don't depend on template parameters; must be complete when a template is defined if they affect the; program's behavior. However, the standard also says that compilers; are free to not enforce this rule. Most compilers enforce it to some; extent; for example, it would be an error in GCC to; write opts.ForceReads in the code above. In Clang, we feel; that enforcing the rule consistently lets us provide a better; experience, but unfortunately it also means we reject some code that; other compilers accept. We've explained the rule here in very imprecise terms; see; [temp.res]p8 for details. Templates with no valid instantiations. The following code contains a typo: the programmer; meant init() but wrote innit() instead. template <class T> class Processor {; ...; void init();; ...; };; ...; template <class T> void process() {; Processor<T> processor;; processor.innit(); // <-- should be 'init()'; ...; }. Unfortunately, we can't flag this mistake as soon as we see it: inside; a template, we're not allowed to make assumptions about ""dependent; types"" like Processor<T>. Suppose that later on in; this file the programmer adds an explicit specialization; of Processor, like so:. template <> class Processor<char*> {; void innit();; };. Now the program will work — as long as the programmer only ever; instantiates process() with T = char*! This is why; it's hard, and sometimes impossible, to diagnose mistakes in a; template definition before it's instantiated. The standard says that a template with no valid instantiations is; ill-formed. Clang tries to do as much checking as possible at; definition-time instead of instantiation-time: not only does this; produce clearer diagnostics, but it also substantially improves; compile times when using pre-compiled headers. The downside to this; philosophy is that Clang sometimes fails to process files because they; contain broken templates that are no longer used. The solution is; simple: since the code is unused, just remove it. Defa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:18995,depend,dependent,18995,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,2,['depend'],['dependent']
Integrability,"ich they must check. During import of a specific declaration, it may happen that some AST nodes had; already been created before we recognize an error. In this case, we signal back; the error to the caller, but the ""to"" context remains polluted with those nodes; which had been created. Ideally, those nodes should not had been created, but; that time we did not know about the error, the error happened later. Since the; AST is immutable (most of the cases we can't remove existing nodes) we choose; to mark these nodes as erroneous. We cache the errors associated with declarations in the ""from"" context in; ``ASTImporter::ImportDeclErrors`` and the ones which are associated with the; ""to"" context in ``ASTImporterSharedState::ImportErrors``. Note that, there may; be several ASTImporter objects which import into the same ""to"" context but from; different ""from"" contexts; in this case, they have to share the associated; errors of the ""to"" context. When an error happens, that propagates through the call stack, through all the; dependant nodes. However, in case of dependency cycles, this is not enough,; because we strive to mark the erroneous nodes so clients can act upon. In those; cases, we have to keep track of the errors for those nodes which are; intermediate nodes of a cycle. An **import path** is the list of the AST nodes which we visit during an Import; call. If node ``A`` depends on node ``B`` then the path contains an ``A->B``; edge. From the call stack of the import functions, we can read the very same; path. Now imagine the following AST, where the ``->`` represents dependency in terms; of the import (all nodes are declarations). .. code-block:: text. A->B->C->D; `->E. We would like to import A.; The import behaves like a DFS, so we will visit the nodes in this order: ABCDE.; During the visitation we will have the following import paths:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE; AB; A. If during the visit of E there is an error then we set an error for ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:101875,depend,dependant,101875,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['depend'],['dependant']
Integrability,"icit iterator-based loop, pay close attention to whether; ``end()`` is re-evaluated on each loop iteration. One common mistake is to; write a loop in this style:. .. code-block:: c++. BasicBlock *BB = ...; for (auto I = BB->begin(); I != BB->end(); ++I); ... use I ... The problem with this construct is that it evaluates ""``BB->end()``"" every time; through the loop. Instead of writing the loop like this, we strongly prefer; loops to be written so that they evaluate it once before the loop starts. A; convenient way to do this is like so:. .. code-block:: c++. BasicBlock *BB = ...; for (auto I = BB->begin(), E = BB->end(); I != E; ++I); ... use I ... The observant may quickly point out that these two loops may have different; semantics: if the container (a basic block in this case) is being mutated, then; ""``BB->end()``"" may change its value every time through the loop and the second; loop may not in fact be correct. If you actually do depend on this behavior,; please write the loop in the first form and add a comment indicating that you; did it intentionally. Why do we prefer the second form (when correct)? Writing the loop in the first; form has two problems. First it may be less efficient than evaluating it at the; start of the loop. In this case, the cost is probably minor --- a few extra; loads every time through the loop. However, if the base expression is more; complex, then the cost can rise quickly. I've seen loops where the end; expression was actually something like: ""``SomeMap[X]->end()``"" and map lookups; really aren't cheap. By writing it in the second form consistently, you; eliminate the issue entirely and don't even have to think about it. The second (even bigger) issue is that writing the loop in the first form hints; to the reader that the loop is mutating the container (a fact that a comment; would handily confirm!). If you write the loop in the second form, it is; immediately obvious without even looking at the body of the loop that the; container ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:53727,depend,depend,53727,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['depend'],['depend']
Integrability,"ics:; """""""""""""""""""". The '``bitcast``' instruction converts ``value`` to type ``ty2``. It; is always a *no-op cast* because no bits change with this; conversion. The conversion is done as if the ``value`` had been stored; to memory and read back as type ``ty2``. Pointer (or vector of; pointers) types may only be converted to other pointer (or vector of; pointers) types with the same address space through this instruction.; To convert pointers to other types, use the :ref:`inttoptr <i_inttoptr>`; or :ref:`ptrtoint <i_ptrtoint>` instructions first. There is a caveat for bitcasts involving vector types in relation to; endianness. For example ``bitcast <2 x i8> <value> to i16`` puts element zero; of the vector in the least significant bits of the i16 for little-endian while; element zero ends up in the most significant bits for big-endian. Example:; """""""""""""""". .. code-block:: text. %X = bitcast i8 255 to i8 ; yields i8 :-1; %Y = bitcast i32* %x to i16* ; yields i16*:%x; %Z = bitcast <2 x i32> %V to i64; ; yields i64: %V (depends on endianness); %Z = bitcast <2 x i32*> %V to <2 x i64*> ; yields <2 x i64*>. .. _i_addrspacecast:. '``addrspacecast .. to``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = addrspacecast <pty> <ptrval> to <pty2> ; yields pty2. Overview:; """""""""""""""""". The '``addrspacecast``' instruction converts ``ptrval`` from ``pty`` in; address space ``n`` to type ``pty2`` in address space ``m``. Arguments:; """""""""""""""""""". The '``addrspacecast``' instruction takes a pointer or vector of pointer value; to cast and a pointer type to cast it to, which must have a different; address space. Semantics:; """""""""""""""""""". The '``addrspacecast``' instruction converts the pointer value; ``ptrval`` to type ``pty2``. It can be a *no-op cast* or a complex; value modification, depending on the target and the address space; pair. Pointer conversions within the same address space must be; performed with the ``bitcast`` instruction. Note that if the add",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:457505,depend,depends,457505,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['depends']
Integrability,"ict how you use it.; In particular, it is possible to use the clang preprocessor and parser to build; an extremely quick and light-weight on-the-fly code generator (similar to TCC); that does not build an AST at all. As an intermediate step, clang supports; using the current AST generation and semantic analysis code and having a code; generation client free the AST for each function after code generation. Finally,; clang provides support for building and retaining fully-fledged ASTs, and even; supports writing them out to disk.; Designing the libraries with clean and simple APIs allows these high-level; policy decisions to be determined in the client, instead of forcing ""one true; way"" in the implementation of any of these libraries. Getting this right is; hard, and we don't always get it right the first time, but we fix any problems; when we realize we made a mistake. Integration with IDEs. We believe that Integrated Development Environments (IDE's) are a great way; to pull together various pieces of the development puzzle, and aim to make clang; work well in such an environment. The chief advantage of an IDE is that they; typically have visibility across your entire project and are long-lived; processes, whereas stand-alone compiler tools are typically invoked on each; individual file in the project, and thus have limited scope.; There are many implications of this difference, but a significant one has to; do with efficiency and caching: sharing an address space across different files; in a project, means that you can use intelligent caching and other techniques to; dramatically reduce analysis/compilation time.; A further difference between IDEs and batch compiler is that they often; impose very different requirements on the front-end: they depend on high; performance in order to provide a ""snappy"" experience, and thus really want; techniques like ""incremental compilation"", ""fuzzy parsing"", etc. Finally, IDEs; often have very different requirements than code gener",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:9157,Integrat,Integrated,9157,interpreter/llvm-project/clang/www/features.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html,1,['Integrat'],['Integrated']
Integrability,"icularly important when; using clang as a compiler, since the clang compiler does not support; anywhere near all the options that gcc does, and we want to make sure; users know which ones are being used. To support this, the driver maintains a bit associated with each; argument of whether it has been used (at all) during the compilation.; This bit usually doesn't need to be set by hand, as the key ArgList; accessors will set it automatically. When a compilation is successful (there are no errors), the driver; checks the bit and emits an ""unused argument"" warning for any arguments; which were never accessed. This is conservative (the argument may not; have been used to do what the user wanted) but still catches the most; obvious cases. Relation to GCC Driver Concepts; -------------------------------. For those familiar with the gcc driver, this section provides a brief; overview of how things from the gcc driver map to the clang driver. - **Driver Driver**. The driver driver is fully integrated into the clang driver. The; driver simply constructs additional Actions to bind the architecture; during the *Pipeline* phase. The tool chain specific argument; translation is responsible for handling ``-Xarch_``. The one caveat is that this approach requires ``-Xarch_`` not be used; to alter the compilation itself (for example, one cannot provide; ``-S`` as an ``-Xarch_`` argument). The driver attempts to reject; such invocations, and overall there isn't a good reason to abuse; ``-Xarch_`` to that end in practice. The upside is that the clang driver is more efficient and does little; extra work to support universal builds. It also provides better error; reporting and UI consistency. - **Specs**. The clang driver has no direct correspondent for ""specs"". The; majority of the functionality that is embedded in specs is in the; Tool specific argument translation routines. The parts of specs which; control the compilation pipeline are generally part of the *Pipeline*; stage. - **Too",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:15293,integrat,integrated,15293,interpreter/llvm-project/clang/docs/DriverInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst,1,['integrat'],['integrated']
Integrability,"id (*foo)(void);; foo(); // warn: function pointer is uninitialized; }. // C; void test() {; void (*foo)(void);; foo = 0;; foo(); // warn: function pointer is null; }. // C++; class C {; public:; void f();; };. void test() {; C *pc;; pc->f(); // warn: object pointer is uninitialized; }. // C++; class C {; public:; void f();; };. void test() {; C *pc = 0;; pc->f(); // warn: object pointer is null; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; long double ld1 = [obj1 longDoubleM];; // warn: receiver is uninitialized; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; id i = obj1.x; // warn: uninitialized object pointer; }. // Objective-C; @interface Subscriptable : NSObject; - (id)objectAtIndexedSubscript:(unsigned int)index;; @end. @interface MyClass : Subscriptable; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; id i = obj1[0]; // warn: uninitialized object pointer; }. core.DivideZero; (C, C++, ObjC); Check for division by zero.co. void test(int z) {; if (z == 0); int x = 1 / z; // warn; }. void test() {; int x = 1;; int y = x % 0; // warn; }. core.NonNullParamChecker; (C, C++, ObjC); Check for null pointers passed as arguments to a function whose arguments are; marked with the nonnull attribute. int f(int *p) __attribute__((nonnull));. void test(int *p) {; if (!p); f(p); // warn; }. core.NullDereference; (C, C++, ObjC); Check for dereferences of null pointers. // C; void test(int *p) {; if (p); return;. int x = p[0]; // warn; }. // C; void test(int *p) {; if (!p); *p = 0; // warn; }. // C++; class C {; public:; int x;; };. void test() {; C *pc = 0;; int k = pc->x; // warn; }. // Objective-C; @interface MyClass {; @public; int x;; }; @end. void test() {; MyClass *obj = 0;; obj->x = 1; // warn; }. core.StackAdd",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:2569,interface,interface,2569,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,2,['interface'],['interface']
Integrability,"idatable instance variables are; invalidated in the methods annotated with objc_instance_variable_invalidator. .. code-block:: objc. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interface SubclassInvalidationImpObj : InvalidationImpObj {; InvalidationImpObj *var;; }; - (void)invalidate;; @end. @implementation SubclassInvalidationImpObj; - (void) invalidate {}; @end; // warn: var needs to be invalidated or set to nil. .. _alpha-osx-cocoa-MissingInvalidationMethod:. alpha.osx.cocoa.MissingInvalidationMethod (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that the invalidation methods are present in classes that contain invalidatable instance variables. .. code-block:: objc. @protocol Invalidation <NSObject>; - (void)invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface NeedInvalidation : NSObject <Invalidation>; @end. @interface MissingInvalidationMethodDecl : NSObject {; NeedInvalidation *Var; // warn; }; @end. @implementation MissingInvalidationMethodDecl; @end. .. _alpha-osx-cocoa-localizability-PluralMisuseChecker:. alpha.osx.cocoa.localizability.PluralMisuseChecker (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns against using one vs. many plural pattern in code when generating localized strings. .. code-block:: objc. NSString *reminderText =; NSLocalizedString(@""None"", @""Indicates no reminders"");; if (reminderCount == 1) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; NSLocalizedString(@""1 Reminder"", @""Indicates single reminder"");; } else if (reminderCount >= 2) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; [NSString stringWithFormat:; NSLocalizedString(@""%@ Reminders"", @""Indicates multiple rem",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:59229,interface,interface,59229,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['interface'],['interface']
Integrability,"ide from all but 'admin' account:. ```cpp; serv->Restrict(""/Folder"", ""visible=admin"");; ```. Hidden folders or objects can not be accessed via http protocol. By default server runs in readonly mode and do not allow methods execution via 'exe.json' or 'exe.bin' requests. To allow such action, one could either grant generic access for all or one could allow to execute only special method:. ```cpp; serv->Restrict(""/Folder/histo1"", ""allow=all"");; serv->Restrict(""/Folder/histo1"", ""allow_method=GetTitle"");; ```. One could provide several options for the same item, separating them with '&' sign:. ```cpp; serv->Restrict(""/Folder/histo1"", ""allow_method=GetTitle&hide=guest"");; ```. Complete list of supported options could be found in [TRootSniffer:Restrict()](https://root.cern/doc/master/classTRootSniffer.html#a8af1f11cbfb9c895f968ec0594794120) method documentation. ## Using FastCGI interface. [FastCGI](http://en.wikipedia.org/wiki/FastCGI) is a protocol for interfacing interactive programs with a web server like `Apache`, `lighttpd`, `Microsoft ISS` and many others. When starting THttpServer, one could specify:. ```cpp; serv = new THttpServer(""fastcgi:9000"");; ```. In fact, the FastCGI interface can run in parallel to http server. One can just call:. ```cpp; serv = new THttpServer(""http:8080"");; serv->CreateEngine(""fastcgi:9000"");; ```. One could specify a debug parameter to be able to adjust the FastCGI configuration on the web server:. ```cpp; serv->CreateEngine(""fastcgi:9000?debug=1"");; ```. By default 10 threads are used to process FastCGI requests. This number can be changed with ""thrds"" url parameter:. ```cpp; serv->CreateEngine(""fastcgi:9000?thrds=20"");; ```. If `thrds=0` parameter specified, the only thread will be use to received and process all requests. All user access will be ruled by the main web server. Authorized account names could be used to configure access restriction in THttpServer. ### Configure fastcgi with Apache2. Since Apache version 2.4 FastCGI is d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:10052,protocol,protocol,10052,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['protocol'],['protocol']
Integrability,"ide.; set(LIT_ARGS_DEFAULT ""-sv""); if (MSVC OR XCODE); set(LIT_ARGS_DEFAULT ""${LIT_ARGS_DEFAULT} --no-progress-bar""); endif(); set(LLVM_LIT_ARGS ""${LIT_ARGS_DEFAULT}"" CACHE STRING ""Default options for lit""). get_errc_messages(LLVM_LIT_ERRC_MESSAGES). # On Win32 hosts, provide an option to specify the path to the GnuWin32 tools.; if( WIN32 AND NOT CYGWIN ); set(LLVM_LIT_TOOLS_DIR """" CACHE PATH ""Path to GnuWin32 tools""); endif(); else(); set(LLVM_INCLUDE_TESTS OFF); endif(). umbrella_lit_testsuite_begin(check-all); endif() # LLVM_INCLUDE_TESTS; endif() # standalone. # Make sure that our source directory is on the current cmake module path so that; # we can include cmake files from this directory.; list(INSERT CMAKE_MODULE_PATH 0; ""${CMAKE_CURRENT_SOURCE_DIR}/cmake/modules""; ""${LLVM_COMMON_CMAKE_UTILS}/Modules""; ). # This allows disabling clang's XML dependency even if LLVM finds libxml2.; # By default, clang depends on libxml2 if LLVM does.; option(CLANG_ENABLE_LIBXML2 ""Whether libclang may depend on libxml2""; ${LLVM_ENABLE_LIBXML2}). if(CLANG_ENABLE_LIBXML2); # Don't look for libxml if we're using MSan, since uninstrumented third party; # code may call MSan interceptors like strlen, leading to false positives.; if(NOT LLVM_USE_SANITIZER MATCHES ""Memory.*""); set (LIBXML2_FOUND 0); find_package(LibXml2 2.5.3 QUIET); if (LIBXML2_FOUND); set(CLANG_HAVE_LIBXML 1); endif(); endif(); endif(). include(CheckIncludeFile); check_include_file(sys/resource.h CLANG_HAVE_RLIMITS). # This check requires _GNU_SOURCE on linux; check_include_file(dlfcn.h CLANG_HAVE_DLFCN_H); if( CLANG_HAVE_DLFCN_H ); include(CheckLibraryExists); include(CheckSymbolExists); check_library_exists(dl dlopen """" HAVE_LIBDL); if( HAVE_LIBDL ); list(APPEND CMAKE_REQUIRED_LIBRARIES dl); endif(); list(APPEND CMAKE_REQUIRED_DEFINITIONS -D_GNU_SOURCE); check_symbol_exists(dladdr dlfcn.h CLANG_HAVE_DLADDR); list(REMOVE_ITEM CMAKE_REQUIRED_DEFINITIONS -D_GNU_SOURCE); if( HAVE_LIBDL ); list(REMOVE_ITEM CMAKE_REQUIRED",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:5406,depend,depend,5406,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,1,['depend'],['depend']
Integrability,"ided by your telephone; service. You also have to learn the framework interfaces, which in; this analogy is the same as learning how to use a telephone. If you are interested in doing physics, a good HEP framework will save; you much work. Next is a list of the more commonly used components of; ROOT: Command Line Interpreter, Histograms and Fitting, Writing a; Graphical User Interface, 2D Graphics, Input/Output , Collection; Classes, Script Processor. There are also less commonly used components, as: 3D Graphics,; Parallel Processing (PROOF), Run Time Type Identification (RTTI),; Socket and Network Communication, Threads. #### Advantages of Frameworks. The benefits of frameworks can be summarized as follows:. - Less code to write - the programmer should be able to use and; reuse the majority of the existing code. Basic functionality, such; as fitting and histogramming are implemented and ready to use and; customize. - More reliable and robust code - the code inherited from a; framework has already been tested and integrated with the rest of; the framework. - More consistent and modular code - the code reuse provides; consistency and common capabilities between programs, no matter; who writes them. Frameworks make it easier to break programs into; smaller pieces. - More focus on areas of expertise - users can concentrate on their; particular problem domain. They do not have to be experts at; writing user interfaces, graphics, or networking to use the; frameworks that provide those services. ### Why Object-Oriented?. Object-Oriented Programming offers considerable benefits compared to; Procedure-Oriented Programming:. - Encapsulation enforces data abstraction and increases opportunity; for reuse. - Sub classing and inheritance make it possible to extend and modify; objects. - Class hierarchies and containment containment hierarchies provide; a flexible mechanism for modeling real-world objects and the; relationships among them. - Complexity is reduced because there is ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:7487,integrat,integrated,7487,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['integrat'],['integrated']
Integrability,"idered value-dependent, because its value isn't well-defined until the error; is resolved. Among other things, this means that clang doesn't emit more errors; where a RecoveryExpr is used as a constant (e.g. array size), but also won't try; to evaluate it. ContainsErrors bit; ^^^^^^^^^^^^^^^^^^. Beyond the template dependence bits, we add a new “ContainsErrors” bit to; express “Does this expression or anything within it contain errors” semantic,; this bit is always set for RecoveryExpr, and propagated to other related nodes.; This provides a fast way to query whether any (recursive) child of an expression; had an error, which is often used to improve diagnostics. .. code-block:: C++. // C++; void recoveryExpr(int abc) {; unknownFunction(); // type-dependent, value-dependent, contains-errors. std::string(42).size(); // value-dependent, contains-errors,; // not type-dependent, as we know the type is std::string; }. .. code-block:: C. // C; void recoveryExpr(int abc) {; unknownVar + abc; // type-dependent, value-dependent, contains-errors; }. The ASTImporter; ---------------. The ``ASTImporter`` class imports nodes of an ``ASTContext`` into another; ``ASTContext``. Please refer to the document :doc:`ASTImporter: Merging Clang; ASTs <LibASTImporter>` for an introduction. And please read through the; high-level `description of the import algorithm; <LibASTImporter.html#algorithm-of-the-import>`_, this is essential for; understanding further implementation details of the importer. .. _templated:. Abstract Syntax Graph; ^^^^^^^^^^^^^^^^^^^^^. Despite the name, the Clang AST is not a tree. It is a directed graph with; cycles. One example of a cycle is the connection between a; ``ClassTemplateDecl`` and its ""templated"" ``CXXRecordDecl``. The *templated*; ``CXXRecordDecl`` represents all the fields and methods inside the class; template, while the ``ClassTemplateDecl`` holds the information which is; related to being a template, i.e. template arguments, etc. We can get the; *",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:89848,depend,dependent,89848,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,2,['depend'],['dependent']
Integrability,"idget's layout and add it to the parent list of children. - Set main window attributes. - Map all sub windows. - Initialize the layout algorithm via `Resize(GetDefaultSize())`; method. - Map the main frame. - Execution of the even-processing loop. ### A Standalone Version. As usual a standalone program in C++ has to contain a main() function -; the starting point for the application execution. In this case it is; better to separate the program code creating a program header file; example2a.h with the `MyMainFrame` class declaration and; `example2a.cxx `- with the class methods implementation. To run our; simple example as a standalone application we need to create in addition; an object of class **`TApplication`**. It will make a correct; initialization of the dictionaries if it is not yet done. It will be; responsible for holding everything together and to handle all events in; the application. Its environment provides an interface to the ROOT; graphics system and by calling the `Run()` method the event loop starts; and the application program is waiting for the user action. The; application exits only if the top level window is not closed. Two header; files are used in addition: `TApplication.h` - for the class; **`TApplication`** and `TGClient.h` that is used to make initial; connection to the graphics system. The class **`TApplication`** must be; instantiated only once in any given application. The original list of; argument options can be retrieved via the `Argc()` and `Argv()` methods. Note: to have signals/slots working we need to create a dictionary for; the class `MyMainFrame`, i.e. we create the file `ex2aLinkDef.h`; containing the line:. ``` {.cpp}; #pragma link C++ class MyMainFrame;; ```. We compile the example:. ``` {.cpp}; rootcling -f ex2aDict.cxx -c example2a.h ex2aLinkDef.h; g++ -o example2a example2a.cxx ex2aDict.cxx `root-config --cflags --glibs`; ```. `example2a.h`. ``` {.cpp}; #include <TQObject.h>; #include <RQ_OBJECT.h>. class TGWindow;; clas",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:16066,interface,interface,16066,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['interface'],['interface']
Integrability,"ieces of code generation algorithms. All of the target description classes (except the :raw-html:`<tt>` `DataLayout`_; :raw-html:`</tt>` class) are designed to be subclassed by the concrete target; implementation, and have virtual methods implemented. To get to these; implementations, the :raw-html:`<tt>` `TargetMachine`_ :raw-html:`</tt>` class; provides accessors that should be implemented by the target. .. _TargetMachine:. The ``TargetMachine`` class; ---------------------------. The ``TargetMachine`` class provides virtual methods that are used to access the; target-specific implementations of the various target description classes via; the ``get*Info`` methods (``getInstrInfo``, ``getRegisterInfo``,; ``getFrameInfo``, etc.). This class is designed to be specialized by a concrete; target implementation (e.g., ``X86TargetMachine``) which implements the various; virtual methods. The only required target description class is the; :raw-html:`<tt>` `DataLayout`_ :raw-html:`</tt>` class, but if the code; generator components are to be used, the other interfaces should be implemented; as well. .. _DataLayout:. The ``DataLayout`` class; ------------------------. The ``DataLayout`` class is the only required target description class, and it; is the only class that is not extensible (you cannot derive a new class from; it). ``DataLayout`` specifies information about how the target lays out memory; for structures, the alignment requirements for various data types, the size of; pointers in the target, and whether the target is little-endian or; big-endian. .. _TargetLowering:. The ``TargetLowering`` class; ----------------------------. The ``TargetLowering`` class is used by SelectionDAG based instruction selectors; primarily to describe how LLVM code should be lowered to SelectionDAG; operations. Among other things, this class indicates:. * an initial register class to use for various ``ValueType``\s,. * which operations are natively supported by the target machine,. * the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:10900,interface,interfaces,10900,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['interface'],['interfaces']
Integrability,"iew comments. Consider using the; `built-in support for fixups <https://git-scm.com/docs/git-commit#Documentation/git-commit.txt---fixupamendrewordltcommitgt>`_; in git. If you do this, you must squash and merge before landing the PR and; you must use the pull request title and description as the commit message.; You can do this manually with an interactive git rebase or with GitHub's; built-in tool. See the section about landing your fix below. When pushing to your branch, make sure you push to the correct fork. Check your; remotes with:. ::. git remote -v. And make sure you push to the remote that's pointing to your fork. Rebasing Pull Requests and Force Pushes; ---------------------------------------; In general, you should avoid rebasing a Pull Request and force pushing to the; branch that's the root of the Pull Request during the review. This action will; make the context of the old changes and comments harder to find and read. Sometimes, a rebase might be needed to update your branch with a fix for a test; or in some dependent code. After your PR is reviewed and accepted, you want to rebase your branch to ensure; you won't encounter merge conflicts when landing the PR. Landing your change; -------------------; When your PR has been accepted you can use the web interface to land your change.; If you have created multiple commits to address feedback at this point you need; to consolidate those commits into one commit. There are two different ways to; do this:. `Interactive rebase <https://git-scm.com/docs/git-rebase#_interactive_mode>`_; with fixup's. This is the recommended method since you can control the final; commit message and inspect that the final commit looks as you expect. When; your local state is correct, remember to force-push to your branch and press; the merge button afterwards. Use the button `Squash and merge` in GitHub's web interface, if you do this; remember to review the commit message when prompted. Afterwards you can select the option `Del",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst:4605,depend,dependent,4605,interpreter/llvm-project/llvm/docs/GitHub.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst,1,['depend'],['dependent']
Integrability,"iewer, then this is returned - hence once a viewer is created; it can be obtained elsewhere by:. ``` {.cpp}; TVirtualViewer3D * v = gPad->GetViewer3D();; ```. #### Opening / Closing Scenes. Objects must be added to viewer between `BeginScene()` and `EndScene()`; calls e.g. ``` {.cpp}; viewer->BeginScene();; // Add objects; viewer ->EndScene();; ```. These calls enable the viewer to suspend redraws, and perform internal; caching/setup. If the object you attach to the pad derives from; **`TAtt3D`**, then the pad will take responsibility for calling; `BeginScene()` and `EndScene()` for you. You can always test if the; scene is already open for object addition with:. ``` {.cpp}; viewer->BuildingScene();; ```. ![Overview of 3D viewer architecture](pictures/030000DF.png). Note: the x3d viewer does not support rebuilding of scenes - objects; added after the first Open/Close Scene pair will be ignored. #### Describing Objects - Filling TBuffer3D. The viewers behind the **`TVirtualViewer3D`** interface differ greatly; in their capabilities e.g. - Some support native shape (e.g. spheres/tubes in OpenGL) and can; draw these based on an abstract description. Others always require a; tessellation description based on **`TBuffer3D`**'s `kRaw` /; `kRawSizes` points/lines/segments sections. - Some need the 3D object positions in the master (world) frame,; others can cope with local frames and a translation matrix to place; the object. - Some require bounding boxes for objects - others do not. Similarly some viewer clients are only capable of providing positions in; master frame, cannot provide bounding boxes etc. Additionally we do not; want to incur the cost of expensive tessellation operations if the; viewer does not require them. To cope with these variations the; **`TBuffer3D`** objects are filled by negotiation with the viewer. ![TBuffer3D class hierarchy](pictures/030000E0.png). **`TBuffer3D`** classes are conceptually divided into enumerated; sections: `kCore`, `kBoundingBox`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:126295,interface,interface,126295,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['interface'],['interface']
Integrability,if ( LLVM_INCLUDE_UTILS ); add_subdirectory(ChildTarget); endif(). set(LLVM_LINK_COMPONENTS; CodeGen; Core; ExecutionEngine; IRReader; Interpreter; JITLink; MC; MCJIT; Object; OrcJIT; OrcDebugging; OrcShared; OrcTargetProcess; Passes; RuntimeDyld; SelectionDAG; Support; Target; TargetParser; TransformUtils; native; ). if( LLVM_USE_OPROFILE ); set(LLVM_LINK_COMPONENTS; ${LLVM_LINK_COMPONENTS}; OProfileJIT; ); endif( LLVM_USE_OPROFILE ). if( LLVM_USE_INTEL_JITEVENTS ); set(LLVM_LINK_COMPONENTS; ${LLVM_LINK_COMPONENTS}; DebugInfoDWARF; IntelJITEvents; Object; ); endif( LLVM_USE_INTEL_JITEVENTS ). if( LLVM_USE_PERF ); set(LLVM_LINK_COMPONENTS; ${LLVM_LINK_COMPONENTS}; DebugInfoDWARF; PerfJITEvents; Object; ); endif( LLVM_USE_PERF ). add_llvm_tool(lli; lli.cpp. DEPENDS; intrinsics_gen; ). export_executable_symbols(lli); ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/CMakeLists.txt:767,DEPEND,DEPENDS,767,interpreter/llvm-project/llvm/tools/lli/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/CMakeLists.txt,1,['DEPEND'],['DEPENDS']
Integrability,"if (DEFINED LLVM_HAVE_TF_AOT OR LLVM_HAVE_TFLITE); include(TensorFlowCompile); set(LLVM_RAEVICT_MODEL_PATH_DEFAULT ""models/regalloc-eviction""). set(LLVM_RAEVICT_MODEL_CURRENT_URL ""<UNSPECIFIED>"" CACHE STRING ""URL to download the LLVM register allocator eviction model""). if (DEFINED LLVM_HAVE_TF_AOT); tf_find_and_compile(; ${LLVM_RAEVICT_MODEL_PATH}; ${LLVM_RAEVICT_MODEL_CURRENT_URL}; ${LLVM_RAEVICT_MODEL_PATH_DEFAULT}; ""../Analysis/models/gen-regalloc-eviction-test-model.py""; serve; action; RegAllocEvictModel; llvm::RegAllocEvictModel; ); endif(). if (LLVM_HAVE_TFLITE); list(APPEND MLLinkDeps ${tensorflow_c_api} ${tensorflow_fx}); endif(); endif(). # This provides the implementation of MVT and LLT.; # Be careful to append deps on this, since Targets' tablegens depend on this.; add_llvm_component_library(LLVMCodeGenTypes; LowLevelType.cpp; PARTIAL_SOURCES_INTENDED. DEPENDS; vt_gen. LINK_COMPONENTS; Support; ). add_llvm_component_library(LLVMCodeGen; AggressiveAntiDepBreaker.cpp; AllocationOrder.cpp; Analysis.cpp; AssignmentTrackingAnalysis.cpp; AtomicExpandPass.cpp; BasicTargetTransformInfo.cpp; BranchFolding.cpp; BranchRelaxation.cpp; BreakFalseDeps.cpp; BasicBlockSections.cpp; BasicBlockPathCloning.cpp; BasicBlockSectionsProfileReader.cpp; CalcSpillWeights.cpp; CallBrPrepare.cpp; CallingConvLower.cpp; CFGuardLongjmp.cpp; CFIFixup.cpp; CFIInstrInserter.cpp; CodeGen.cpp; CodeGenCommonISel.cpp; CodeGenPassBuilder.cpp; CodeGenPrepare.cpp; CommandFlags.cpp; ComplexDeinterleavingPass.cpp; CriticalAntiDepBreaker.cpp; DeadMachineInstructionElim.cpp; DetectDeadLanes.cpp; DFAPacketizer.cpp; DwarfEHPrepare.cpp; EarlyIfConversion.cpp; EdgeBundles.cpp; EHContGuardCatchret.cpp; ExecutionDomainFix.cpp; ExpandLargeDivRem.cpp; ExpandLargeFpConvert.cpp; ExpandMemCmp.cpp; ExpandPostRAPseudos.cpp; ExpandReductions.cpp; ExpandVectorPredication.cpp; FaultMaps.cpp; FEntryInserter.cpp; FinalizeISel.cpp; FixupStatepointCallerSaved.cpp; FuncletLayout.cpp; GCMetadata.cpp; GCMetadataPrinter.cp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CMakeLists.txt:771,depend,depend,771,interpreter/llvm-project/llvm/lib/CodeGen/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CMakeLists.txt,1,['depend'],['depend']
Integrability,"if (LLVM_INCLUDE_UTILS AND LLVM_INCLUDE_TOOLS); add_custom_command(; OUTPUT ${LLVM_TOOLS_BINARY_DIR}/llvm-locstats; DEPENDS ${LLVM_MAIN_SRC_DIR}/utils/llvm-locstats/llvm-locstats.py; DEPENDS llvm-dwarfdump; COMMAND ${CMAKE_COMMAND} -E copy ${LLVM_MAIN_SRC_DIR}/utils/llvm-locstats/llvm-locstats.py ${LLVM_TOOLS_BINARY_DIR}/llvm-locstats; COMMENT ""Copying llvm-locstats into ${LLVM_TOOLS_BINARY_DIR}""; ); add_custom_target(llvm-locstats ALL; DEPENDS ${LLVM_TOOLS_BINARY_DIR}/llvm-locstats; ); if (NOT LLVM_BUILD_TOOLS); set_target_properties(llvm-locstats PROPERTIES EXCLUDE_FROM_ALL ON); endif(); set_target_properties(llvm-locstats PROPERTIES FOLDER ""Tools""); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/llvm-locstats/CMakeLists.txt:116,DEPEND,DEPENDS,116,interpreter/llvm-project/llvm/utils/llvm-locstats/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/llvm-locstats/CMakeLists.txt,3,['DEPEND'],['DEPENDS']
Integrability,if (NOT HAVE_CXX_ATOMICS64_WITHOUT_LIB); set (atomic_lib atomic); endif(). if( CMAKE_HOST_UNIX AND HAVE_LIBRT ); set(rt_lib rt); endif(). add_llvm_component_library(LLVMOrcJIT; COFFVCRuntimeSupport.cpp; COFFPlatform.cpp; CompileOnDemandLayer.cpp; CompileUtils.cpp; Core.cpp; DebugObjectManagerPlugin.cpp; DebugUtils.cpp; EPCDynamicLibrarySearchGenerator.cpp; EPCDebugObjectRegistrar.cpp; EPCEHFrameRegistrar.cpp; EPCGenericDylibManager.cpp; EPCGenericJITLinkMemoryManager.cpp; EPCGenericRTDyldMemoryManager.cpp; EPCIndirectionUtils.cpp; ExecutionUtils.cpp; ObjectFileInterface.cpp; IndirectionUtils.cpp; IRCompileLayer.cpp; IRTransformLayer.cpp; JITTargetMachineBuilder.cpp; LazyReexports.cpp; Layer.cpp; LookupAndRecordAddrs.cpp; LLJIT.cpp; MachOPlatform.cpp; MapperJITLinkMemoryManager.cpp; MemoryMapper.cpp; ELFNixPlatform.cpp; Mangling.cpp; ObjectLinkingLayer.cpp; ObjectTransformLayer.cpp; OrcABISupport.cpp; OrcV2CBindings.cpp; RTDyldObjectLinkingLayer.cpp; SimpleRemoteEPC.cpp; Speculation.cpp; SpeculateAnalyses.cpp; ExecutorProcessControl.cpp; TaskDispatch.cpp; ThreadSafeModule.cpp; ADDITIONAL_HEADER_DIRS; ${LLVM_MAIN_INCLUDE_DIR}/llvm/ExecutionEngine/Orc. DEPENDS; intrinsics_gen. LINK_LIBS; ${LLVM_PTHREAD_LIB}; ${rt_lib}; ${atomic_lib}. LINK_COMPONENTS; Core; ExecutionEngine; JITLink; Object; OrcShared; OrcTargetProcess; WindowsDriver; MC; Passes; RuntimeDyld; Support; Target; TargetParser; TransformUtils; ). add_subdirectory(Debugging); add_subdirectory(Shared); add_subdirectory(TargetProcess). target_link_libraries(LLVMOrcJIT; PRIVATE; LLVMAnalysis; LLVMBitReader; LLVMBitWriter; LLVMPasses; ); ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/CMakeLists.txt:1168,DEPEND,DEPENDS,1168,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/CMakeLists.txt,1,['DEPEND'],['DEPENDS']
Integrability,"if a few conditions are true:. #. The pointer stored through is loop invariant.; #. There are no stores or loads in the loop which *may* alias the pointer.; There are no calls in the loop which mod/ref the pointer. If these conditions are true, we can promote the loads and stores in the; loop of the pointer to use a temporary alloca'd variable. We then use the; :ref:`mem2reg <passes-mem2reg>` functionality to construct the appropriate; SSA form for the variable. ``loop-deletion``: Delete dead loops; ------------------------------------. This file implements the Dead Loop Deletion Pass. This pass is responsible for; eliminating loops with non-infinite computable trip counts that have no side; effects or volatile instructions, and do not contribute to the computation of; the function's return value. .. _passes-loop-extract:. ``loop-extract``: Extract loops into new functions; --------------------------------------------------. A pass wrapper around the ``ExtractLoop()`` scalar transformation to extract; each top-level loop into its own new function. If the loop is the *only* loop; in a given function, it is not touched. This is a pass most useful for; debugging via bugpoint. ``loop-reduce``: Loop Strength Reduction; ----------------------------------------. This pass performs a strength reduction on array references inside loops that; have as one or more of their components the loop induction variable. This is; accomplished by creating a new value to hold the initial value of the array; access for the first iteration, and then creating a new GEP instruction in the; loop to increment the value by the appropriate amount. .. _passes-loop-rotate:. ``loop-rotate``: Rotate Loops; -----------------------------. A simple loop rotation transformation. A summary of it can be found in; :ref:`Loop Terminology for Rotated Loops <loop-terminology-loop-rotate>`. .. _passes-loop-simplify:. ``loop-simplify``: Canonicalize natural loops; ---------------------------------------------. Th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:25641,wrap,wrapper,25641,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['wrap'],['wrapper']
Integrability,"if the pattern starts with a slash). Patterns; containing drive names (e.g. ``C:``) are not supported.; * Patterns follow the rules specified in `POSIX 2.13.1, 2.13.2, and Rule 1 of; 2.13.3 <https://pubs.opengroup.org/onlinepubs/9699919799/utilities/; V3_chap02.html#tag_18_13>`_.; * A pattern is negated if it starts with a bang (``!``). To match all files in a directory, use e.g. ``foo/bar/*``. To match all files in; the directory of the ``.clang-format-ignore`` file, use ``*``.; Multiple ``.clang-format-ignore`` files are supported similar to the; ``.clang-format`` files, with a lower directory level file voiding the higher; level ones. Vim Integration; ===============. There is an integration for :program:`vim` which lets you run the; :program:`clang-format` standalone tool on your current buffer, optionally; selecting regions to reformat. The integration has the form of a `python`-file; which can be found under `clang/tools/clang-format/clang-format.py`. This can be integrated by adding the following to your `.vimrc`:. .. code-block:: vim. if has('python'); map <C-K> :pyf <path-to-this-file>/clang-format.py<cr>; imap <C-K> <c-o>:pyf <path-to-this-file>/clang-format.py<cr>; elseif has('python3'); map <C-K> :py3f <path-to-this-file>/clang-format.py<cr>; imap <C-K> <c-o>:py3f <path-to-this-file>/clang-format.py<cr>; endif. The first line enables :program:`clang-format` for NORMAL and VISUAL mode, the; second line adds support for INSERT mode. Change ""C-K"" to another binding if; you need :program:`clang-format` on a different key (C-K stands for Ctrl+k). With this integration you can press the bound key and clang-format will; format the current line in NORMAL and INSERT mode or the selected region in; VISUAL mode. The line or region is extended to the next bigger syntactic; entity. It operates on the current, potentially unsaved buffer and does not create; or save any files. To revert a formatting, just undo. An alternative option is to format changes when saving a f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst:6652,integrat,integrated,6652,interpreter/llvm-project/clang/docs/ClangFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst,1,['integrat'],['integrated']
Integrability,"if( NOT LLVM_BUILD_TOOLS ); set(EXCLUDE_FROM_ALL ON); endif(). # If we don't need RTTI or EH, there's no reason to export anything; # from this plugin.; if( NOT LLVM_REQUIRES_RTTI ); if( NOT LLVM_REQUIRES_EH ); set(LLVM_EXPORTED_SYMBOL_FILE ${CMAKE_CURRENT_SOURCE_DIR}/bugpoint.exports); endif(); endif(). if(WIN32 OR CYGWIN OR ZOS); set(LLVM_LINK_COMPONENTS Core Support); endif(). add_llvm_library( BugpointPasses MODULE BUILDTREE_ONLY; TestPasses.cpp. DEPENDS; intrinsics_gen; bugpoint; ); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/CMakeLists.txt:455,DEPEND,DEPENDS,455,interpreter/llvm-project/llvm/tools/bugpoint-passes/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/CMakeLists.txt,1,['DEPEND'],['DEPENDS']
Integrability,"if(). include(HandleLLVMOptions). ######. # Configure all of the various header file fragments LLVM uses which depend on; # configuration variables.; set(LLVM_ENUM_TARGETS """"); set(LLVM_ENUM_ASM_PRINTERS """"); set(LLVM_ENUM_ASM_PARSERS """"); set(LLVM_ENUM_DISASSEMBLERS """"); set(LLVM_ENUM_TARGETMCAS """"); set(LLVM_ENUM_EXEGESIS """"); foreach(t ${LLVM_TARGETS_TO_BUILD}); set( td ${LLVM_MAIN_SRC_DIR}/lib/Target/${t} ). # Make sure that any experimental targets were passed via; # LLVM_EXPERIMENTAL_TARGETS_TO_BUILD, not LLVM_TARGETS_TO_BUILD.; # We allow experimental targets that are not in LLVM_ALL_EXPERIMENTAL_TARGETS,; # as long as they are passed via LLVM_EXPERIMENTAL_TARGETS_TO_BUILD.; if ( NOT ""${t}"" IN_LIST LLVM_ALL_TARGETS AND NOT ""${t}"" IN_LIST LLVM_EXPERIMENTAL_TARGETS_TO_BUILD ); if( ""${t}"" IN_LIST LLVM_ALL_EXPERIMENTAL_TARGETS ); message(FATAL_ERROR ""The target `${t}' is experimental and must be passed ""; ""via LLVM_EXPERIMENTAL_TARGETS_TO_BUILD.""); else(); message(FATAL_ERROR ""The target `${t}' is not a core tier target. It may be ""; ""experimental, if so it must be passed via ""; ""LLVM_EXPERIMENTAL_TARGETS_TO_BUILD.\n""; ""Core tier targets: ${LLVM_ALL_TARGETS}\n""; ""Known experimental targets: ${LLVM_ALL_EXPERIMENTAL_TARGETS}""); endif(); else(); set(LLVM_ENUM_TARGETS ""${LLVM_ENUM_TARGETS}LLVM_TARGET(${t})\n""); string(TOUPPER ${t} T_UPPER); set(LLVM_HAS_${T_UPPER}_TARGET 1); endif(). file(GLOB asmp_file ""${td}/*AsmPrinter.cpp""); if( asmp_file ); set(LLVM_ENUM_ASM_PRINTERS; ""${LLVM_ENUM_ASM_PRINTERS}LLVM_ASM_PRINTER(${t})\n""); endif(); if( EXISTS ${td}/AsmParser/CMakeLists.txt ); set(LLVM_ENUM_ASM_PARSERS; ""${LLVM_ENUM_ASM_PARSERS}LLVM_ASM_PARSER(${t})\n""); endif(); if( EXISTS ${td}/Disassembler/CMakeLists.txt ); set(LLVM_ENUM_DISASSEMBLERS; ""${LLVM_ENUM_DISASSEMBLERS}LLVM_DISASSEMBLER(${t})\n""); endif(); if( EXISTS ${td}/MCA/CMakeLists.txt ); set(LLVM_ENUM_TARGETMCAS; ""${LLVM_ENUM_TARGETMCAS}LLVM_TARGETMCA(${t})\n""); endif(); if( EXISTS ${LLVM_MAIN_SRC_DIR}/tools/llvm",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:40230,message,message,40230,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['message'],['message']
Integrability,"if(); endif( LLVM_USE_INTEL_JITEVENTS ). option(LLVM_USE_OPROFILE; ""Use opagent JIT interface to inform OProfile about JIT code"" OFF). option(LLVM_EXTERNALIZE_DEBUGINFO; ""Generate dSYM files and strip executables and libraries (Darwin Only)"" OFF). option(LLVM_EXPERIMENTAL_DEBUGINFO_ITERATORS; ""Add extra Booleans to ilist_iterators to communicate facts for debug-info"" OFF). set(LLVM_CODESIGNING_IDENTITY """" CACHE STRING; ""Sign executables and dylibs with the given identity or skip if empty (Darwin Only)""). # If enabled, verify we are on a platform that supports oprofile.; if( LLVM_USE_OPROFILE ); if( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); message(FATAL_ERROR ""OProfile support is available on Linux only.""); endif( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); endif( LLVM_USE_OPROFILE ). option(LLVM_USE_PERF; ""Use perf JIT interface to inform perf about JIT code"" OFF). # If enabled, verify we are on a platform that supports perf.; if( LLVM_USE_PERF ); if( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); message(FATAL_ERROR ""perf support is available on Linux only.""); endif( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); endif( LLVM_USE_PERF ). set(LLVM_USE_SANITIZER """" CACHE STRING; ""Define the sanitizer used to build binaries and tests.""); option(LLVM_OPTIMIZE_SANITIZED_BUILDS ""Pass -O1 on debug sanitizer builds"" ON); set(LLVM_UBSAN_FLAGS; ""-fsanitize=undefined -fno-sanitize=vptr,function -fno-sanitize-recover=all""; CACHE STRING; ""Compile flags set to enable UBSan. Only used if LLVM_USE_SANITIZER contains 'Undefined'.""); set(LLVM_LIB_FUZZING_ENGINE """" CACHE PATH; ""Path to fuzzing library for linking with fuzz targets""). option(LLVM_USE_SPLIT_DWARF; ""Use -gsplit-dwarf when compiling llvm and --gdb-index when linking."" OFF). # Define an option controlling whether we should build for 32-bit on 64-bit; # platforms, where supported.; if( CMAKE_SIZEOF_VOID_P EQUAL 8 AND NOT (WIN32 OR ${CMAKE_SYSTEM_NAME} MATCHES ""AIX"")); # TODO: support other platforms and toolchains.; option(LLVM_BUILD_32_BI",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:28118,message,message,28118,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['message'],['message']
Integrability,"if(CMAKE_CXX_COMPILER_ID STREQUAL Intel); if(DEFINED ENV{VTUNE_AMPLIFIER_2019_DIR}); set(VTUNE_DIR ENV{VTUNE_AMPLIFIER_2019_DIR}); elseif(DEFINED ENV{VTUNE_PROFILER_2020_DIR}); set(VTUNE_DIR ENV{VTUNE_PROFILER_2020_DIR}); endif(); # To be able to start/stop the vtune profiler, ittnotify must be available.; target_include_directories(VectorisedPDFTests PUBLIC ""${VTUNE_DIR}/include/""); target_link_libraries(VectorisedPDFTests INTERFACE ""${VTUNE_DIR}/lib64/libittnotify.a""); endif(). add_library(VectorisedPDFTests STATIC VectorisedPDFTests.cxx); target_link_libraries(VectorisedPDFTests PUBLIC gtest ROOT::Gpad ROOT::RooFitCore ROOT::RooFit). ROOT_ADD_GTEST(testCompatMode testCompatMode.cxx; LIBRARIES VectorisedPDFTests); ROOT_ADD_GTEST(testGauss testGauss.cxx; LIBRARIES VectorisedPDFTests); ROOT_ADD_GTEST(testPoisson testPoisson.cxx; LIBRARIES VectorisedPDFTests); ROOT_ADD_GTEST(testAddPdf testAddPdf.cxx; LIBRARIES VectorisedPDFTests); ROOT_ADD_GTEST(testExponential testExponential.cxx; LIBRARIES VectorisedPDFTests); ROOT_ADD_GTEST(testNestedPDFs testNestedPDFs.cxx; LIBRARIES VectorisedPDFTests); ROOT_ADD_GTEST(testProductPdf testProductPdf.cxx; LIBRARIES VectorisedPDFTests); ROOT_ADD_GTEST(testJohnson testJohnson.cxx; LIBRARIES VectorisedPDFTests); ROOT_ADD_GTEST(testLandau testLandau.cxx; LIBRARIES VectorisedPDFTests); ROOT_ADD_GTEST(testBukin testBukin.cxx; LIBRARIES VectorisedPDFTests); ROOT_ADD_GTEST(testChebychev testChebychev.cxx; LIBRARIES VectorisedPDFTests); ROOT_ADD_GTEST(testPolynomial testPolynomial.cxx; LIBRARIES VectorisedPDFTests); ROOT_ADD_GTEST(testBernstein testBernstein.cxx; LIBRARIES VectorisedPDFTests); ROOT_ADD_GTEST(testArgusBG testArgusBG.cxx; LIBRARIES VectorisedPDFTests); ROOT_ADD_GTEST(testBifurGauss testBifurGauss.cxx; LIBRARIES VectorisedPDFTests); ROOT_ADD_GTEST(testBreitWigner testBreitWigner.cxx; LIBRARIES VectorisedPDFTests); ROOT_ADD_GTEST(testCBShape testCBShape.cxx; LIBRARIES VectorisedPDFTests); ROOT_ADD_GTEST(testGamma testGamma.cxx;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/vectorisedPDFs/CMakeLists.txt:428,INTERFACE,INTERFACE,428,roofit/roofit/test/vectorisedPDFs/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/vectorisedPDFs/CMakeLists.txt,1,['INTERFACE'],['INTERFACE']
Integrability,"if(LLVM_BYE_LINK_INTO_TOOLS); message(WARNING ""Setting LLVM_BYE_LINK_INTO_TOOLS=ON only makes sense for testing purpose""); endif(). # The plugin expects to not link against the Support and Core libraries,; # but expects them to exist in the process loading the plugin. This doesn't; # work with DLLs on Windows (where a shared library can't have undefined; # references), so just skip this example on Windows.; if (NOT WIN32 AND NOT CYGWIN); add_llvm_pass_plugin(Bye; Bye.cpp; DEPENDS; intrinsics_gen; BUILDTREE_ONLY; ). install(TARGETS ${name} RUNTIME DESTINATION ""${LLVM_EXAMPLES_INSTALL_DIR}""); set_target_properties(${name} PROPERTIES FOLDER ""Examples""); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Bye/CMakeLists.txt:30,message,message,30,interpreter/llvm-project/llvm/examples/Bye/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Bye/CMakeLists.txt,1,['message'],['message']
Integrability,"if(LLVM_EXAMPLEIRTRANSFORMS_LINK_INTO_TOOLS); message(WARNING ""Setting LLVM_EXAMPLEIRTRANSFORMS_LINK_INTO_TOOLS=ON only makes sense for testing purpose""); endif(). # The plugin expects to not link against the Support and Core libraries,; # but expects them to exist in the process loading the plugin. This doesn't; # work with DLLs on Windows (where a shared library can't have undefined; # references), so just skip this example on Windows.; if (NOT WIN32 AND NOT CYGWIN); add_llvm_pass_plugin(ExampleIRTransforms; SimplifyCFG.cpp; DEPENDS; intrinsics_gen; BUILDTREE_ONLY; ). install(TARGETS ${name} RUNTIME DESTINATION ""${LLVM_EXAMPLES_INSTALL_DIR}""); set_target_properties(${name} PROPERTIES FOLDER ""Examples""); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/IRTransforms/CMakeLists.txt:46,message,message,46,interpreter/llvm-project/llvm/examples/IRTransforms/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/IRTransforms/CMakeLists.txt,1,['message'],['message']
Integrability,"if(WIN32); # We need cmake to support exporting of symbols not only from libraries but; # from executables too. This way cling can find symbols from its own; # executable during runtime.; cmake_minimum_required(VERSION 3.6.2); else(WIN32); # support of earlier cmake versions will be removed soon; cmake_minimum_required(VERSION 3.5); endif(WIN32). # If we are not building as a part of LLVM, build Cling as an; # standalone project, using LLVM as an external library:; if( CMAKE_SOURCE_DIR STREQUAL CMAKE_CURRENT_SOURCE_DIR ); project(Cling). # See <https://llvm.org/docs/CMake.html#embedding-llvm-in-your-project>.; find_package(LLVM REQUIRED CONFIG); message(STATUS ""Found LLVM ${LLVM_PACKAGE_VERSION}""); message(STATUS ""Using LLVMConfig.cmake in: ${LLVM_DIR}""). separate_arguments(LLVM_DEFINITIONS_LIST NATIVE_COMMAND ${LLVM_DEFINITIONS}); add_definitions(${LLVM_DEFINITIONS_LIST}). find_package(Clang REQUIRED CONFIG); message(STATUS ""Found supported version: Clang ${CLANG_PACKAGE_VERSION}""); message(STATUS ""Using ClangConfig.cmake in: ${Clang_DIR}""). find_program(LLVM_TABLEGEN_EXE ""llvm-tblgen"" ${LLVM_TOOLS_BINARY_DIR}; NO_DEFAULT_PATH). list(APPEND CMAKE_MODULE_PATH ""${LLVM_CMAKE_DIR}""); include(AddLLVM); include(TableGen); include(HandleLLVMOptions); include(VersionFromVCS). set(PACKAGE_VERSION ""${LLVM_PACKAGE_VERSION}""). if (NOT DEFINED LLVM_INCLUDE_TESTS); set(LLVM_INCLUDE_TESTS ON); endif(). include_directories(""${LLVM_INCLUDE_DIRS}""); link_directories(""${LLVM_LIBRARY_DIR}""). set( CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin ); set( CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib${LLVM_LIBDIR_SUFFIX} ); set( CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib${LLVM_LIBDIR_SUFFIX} ). if(LLVM_INCLUDE_TESTS); find_package(Python3 3.8 REQUIRED COMPONENTS Interpreter). # Check prebuilt llvm/utils.; if(EXISTS ${LLVM_TOOLS_BINARY_DIR}/FileCheck${CMAKE_EXECUTABLE_SUFFIX}; AND EXISTS ${LLVM_TOOLS_BINARY_DIR}/count${CMAKE_EXECUTABLE_SUFFIX}; AND EXISTS ${LLVM_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/CMakeLists.txt:654,message,message,654,interpreter/cling/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/CMakeLists.txt,4,['message'],['message']
Integrability,"ific that will be seen afterwards for the one dimensional one. ![ROOT::Math Numerical Integrator classes](pictures/Integration.png). The rest of the classes shown above in the diagram are the specialized classes provided. Each one implements a different method that will be explained in detail. It is important; to notice that the two grayed classes (the one which name starts by GSL) are part of the *MathMore* library.; We will later show in more detail the differences between the implementations. ### Integration of One-dimensional Functions. #### Using `ROOT::Math::IntegratorOneDim`. Here is a code example on how to use the `ROOT::Math::IntegratorOneDim` class; (note that the class is defined in the header file `Math/Integrator.h`). In this example we create; different instance of the class using some of the available algorithms in ROOT.; If no algorithm is specified, the default one is used. The default Integrator together with other integration options; such as relative and absolute tolerance, can be specified using the static method of the; `ROOT::Math::IntegratorOneDimOptions`. ```{.cpp}; #include ""Math/Integrator.h"". const double ERRORLIMIT = 1E-3;. double f(double x) {; return x;; }. double f2(const double * x) {; return x[0] + x[1];; }. int testIntegration1D() {. const double RESULT = 0.5;; int status = 0;. // set default tolerances for all integrators; ROOT::Math::IntegratorOneDimOptions::SetDefaultAbsTolerance(1.E-6);; ROOT::Math::IntegratorOneDimOptions::SetDefaultRelTolerance(1.E-6);. ROOT::Math::Functor1D wf(&f);; ROOT::Math::Integrator ig(ROOT::Math::IntegrationOneDim::kADAPTIVESINGULAR);; ig.SetFunction(wf);; double val = ig.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::Integrator ig2(ROOT::Math::IntegrationOneDim::kNONADAPTIVE);; ig2.SetFunction(wf);; val = ig2.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ER",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:50876,integrat,integration,50876,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['integrat'],['integration']
Integrability,"ification string. MODULE_CODE_ASM Record; ^^^^^^^^^^^^^^^^^^^^^^. ``[ASM, ...string...]``. The ``ASM`` record (code 4) contains a variable number of values representing; the bytes of ``module asm`` strings, with individual assembly blocks separated; by newline (ASCII 10) characters. .. _MODULE_CODE_SECTIONNAME:. MODULE_CODE_SECTIONNAME Record; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``[SECTIONNAME, ...string...]``. The ``SECTIONNAME`` record (code 5) contains a variable number of values; representing the bytes of a single section name string. There should be one; ``SECTIONNAME`` record for each section name referenced (e.g., in global; variable or function ``section`` attributes) within the module. These records; can be referenced by the 1-based index in the *section* fields of ``GLOBALVAR``; or ``FUNCTION`` records. MODULE_CODE_DEPLIB Record; ^^^^^^^^^^^^^^^^^^^^^^^^^. ``[DEPLIB, ...string...]``. The ``DEPLIB`` record (code 6) contains a variable number of values representing; the bytes of a single dependent library name string, one of the libraries; mentioned in a ``deplibs`` declaration. There should be one ``DEPLIB`` record; for each library name referenced. MODULE_CODE_GLOBALVAR Record; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``[GLOBALVAR, strtab offset, strtab size, pointer type, isconst, initid, linkage, alignment, section, visibility, threadlocal, unnamed_addr, externally_initialized, dllstorageclass, comdat, attributes, preemptionspecifier]``. The ``GLOBALVAR`` record (code 7) marks the declaration or definition of a; global variable. The operand fields are:. * *strtab offset*, *strtab size*: Specifies the name of the global variable.; See `STRTAB_BLOCK Contents`_. * *pointer type*: The type index of the pointer type used to point to this; global variable. * *isconst*: Non-zero if the variable is treated as constant within the module,; or zero if it is not. * *initid*: If non-zero, the value index of the initializer for this variable,; plus 1. .. _linkage type:. * *linkage*: ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst:26763,depend,dependent,26763,interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,1,['depend'],['dependent']
Integrability,"iform.h; RooUniform.h; RooVoigtian.h; RooJohnson.h; SOURCES; src/Roo2DKeysPdf.cxx; src/RooArgusBG.cxx; src/RooBCPEffDecay.cxx; src/RooBCPGenDecay.cxx; src/RooBDecay.cxx; src/RooBernstein.cxx; src/RooBifurGauss.cxx; src/RooBlindTools.cxx; src/RooBMixDecay.cxx; src/RooBreitWigner.cxx; src/RooBukinPdf.cxx; src/RooCBShape.cxx; src/RooCrystalBall.cxx; src/RooCFunction1Binding.cxx; src/RooCFunction2Binding.cxx; src/RooCFunction3Binding.cxx; src/RooCFunction4Binding.cxx; src/RooChebychev.cxx; src/RooChi2MCSModule.cxx; src/RooChiSquarePdf.cxx; src/RooDecay.cxx; src/RooDstD0BG.cxx; src/RooExponential.cxx; src/RooLegacyExpPoly.cxx; src/RooPowerSum.cxx; src/RooFunctor1DBinding.cxx; src/RooFunctorBinding.cxx; src/RooGamma.cxx; src/RooGaussian.cxx; src/RooGaussModel.cxx; src/RooGExpModel.cxx; src/RooHistConstraint.cxx; src/RooIntegralMorph.cxx; src/RooJeffreysPrior.cxx; src/RooKeysPdf.cxx; src/RooLagrangianMorphFunc.cxx; src/RooLandau.cxx; src/RooLognormal.cxx; src/RooMathCoreReg.cxx; src/RooMomentMorph.cxx; src/RooMomentMorphFunc.cxx; src/RooMomentMorphFuncND.cxx; src/RooMultiBinomial.cxx; src/RooNDKeysPdf.cxx; src/RooNonCPEigenDecay.cxx; src/RooNovosibirsk.cxx; src/RooParametricStepFunction.cxx; src/RooParamHistFunc.cxx; src/RooPoisson.cxx; src/RooPolynomial.cxx; src/RooSpline.cxx; src/RooStepFunction.cxx; src/RooTFnBinding.cxx; src/RooTFnPdfBinding.cxx; src/RooTMathReg.cxx; src/RooUnblindCPAsymVar.cxx; src/RooUnblindOffset.cxx; src/RooUnblindPrecision.cxx; src/RooUnblindUniform.cxx; src/RooUniform.cxx; src/RooVoigtian.cxx; src/RooJohnson.cxx; DICTIONARY_OPTIONS; ""-writeEmptyRootPCM""; LINKDEF; LinkDef1.h; LIBRARIES; RooBatchCompute; DEPENDENCIES; Core; RooFitCore; Tree; RIO; Matrix; MathCore; ${EXTRA_DICT_OPTS}; ). # For recent clang, this can facilitate auto-vectorisation.; # In RooFit, the errno side effect is not needed, anyway:; if(""${CMAKE_CXX_COMPILER_ID}"" MATCHES ""Clang""); target_compile_options(RooFit PUBLIC -fno-math-errno); endif(). ROOT_ADD_TEST_SUBDIRECTORY(test); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/CMakeLists.txt:3322,DEPEND,DEPENDENCIES,3322,roofit/roofit/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/CMakeLists.txt,1,['DEPEND'],['DEPENDENCIES']
Integrability,"ig/Disassemblers.def; ); configure_file(; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/Targets.def.in; ${LLVM_INCLUDE_DIR}/llvm/Config/Targets.def; ); configure_file(; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/TargetMCAs.def.in; ${LLVM_INCLUDE_DIR}/llvm/Config/TargetMCAs.def; ); configure_file(; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/TargetExegesis.def.in; ${LLVM_INCLUDE_DIR}/llvm/Config/TargetExegesis.def; ). # They are not referenced. See set_output_directory().; set( CMAKE_RUNTIME_OUTPUT_DIRECTORY ${LLVM_TOOLS_BINARY_DIR} ); set( CMAKE_LIBRARY_OUTPUT_DIRECTORY ${LLVM_LIBRARY_DIR} ); set( CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${LLVM_LIBRARY_DIR} ). # For up-to-date instructions for installing the TFLite dependency, refer to; # the bot setup script: https://github.com/google/ml-compiler-opt/blob/main/buildbot/buildbot_init.sh; set(LLVM_HAVE_TFLITE """" CACHE BOOL ""Use tflite""); if (LLVM_HAVE_TFLITE); find_package(tensorflow-lite REQUIRED); endif(). # For up-to-date instructions for installing the Tensorflow dependency, refer to; # the bot setup script: https://github.com/google/ml-compiler-opt/blob/main/buildbot/buildbot_init.sh; # Specifically, assuming python3 is installed:; # python3 -m pip install --upgrade pip && python3 -m pip install --user tf_nightly==2.3.0.dev20200528; # Then set TENSORFLOW_AOT_PATH to the package install - usually it's ~/.local/lib/python3.7/site-packages/tensorflow; #; set(TENSORFLOW_AOT_PATH """" CACHE PATH ""Path to TensorFlow pip install dir""). if (NOT TENSORFLOW_AOT_PATH STREQUAL """"); set(LLVM_HAVE_TF_AOT ""ON"" CACHE BOOL ""Tensorflow AOT available""); set(TENSORFLOW_AOT_COMPILER; ""${TENSORFLOW_AOT_PATH}/../../../../bin/saved_model_cli""; CACHE PATH ""Path to the Tensorflow AOT compiler""); include_directories(${TENSORFLOW_AOT_PATH}/include); add_subdirectory(${TENSORFLOW_AOT_PATH}/xla_aot_runtime_src; ${CMAKE_ARCHIVE_OUTPUT_DIRECTORY}/tf_runtime); install(TARGETS tf_xla_runtime EXPORT LLVMExports; ARCHIVE DESTINATION lib${LLVM_LIBDIR_SUFFIX} COMPONENT tf_xla_runtim",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:42977,depend,dependency,42977,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['depend'],['dependency']
Integrability,"ight less than precision are excluded. A demo macro for radioactive material features is; `$ROOTSYS/tutorials/geom/RadioNuclides.C` It demonstrates also the decay; of a mixture made of radionuclides. ![Concentracion of elements derived; fromCa53+Sr78](pictures/030001B4.png). ### Tracking Media. The class **`TGeoMedium`** describes tracking media properties. This has; a pointer to a material and the additional data members representing the; properties related to tracking. ``` {.cpp}; TGeoMedium(const char *name,Int_t numed,TGeoMaterial *mat,; Double_t *params=0);; ```. - `name:` name assigned to the medium; - `mat:` pointer to a material; - `params:` array of additional parameters. Another constructor allows effectively defining tracking parameters in; GEANT3 style:. ``` {.cpp}; TGeoMedium(const char *name,Int_t numed,Int_t imat,Int_t ifield,; Double_t fieldm,Double_t tmaxfd,Double_t stemax,; Double_t deemax,Double_t epsil,Double_t stmin);; ```. This constructor is reserved for creating tracking media from the VMC; interface [...]:. - `numed:` user-defined medium index; - `imat:` unique ID of the material; - `others:` see G3 documentation. Looking at our simple world example, one can see that for creating; volumes one needs to create tracking media before. The way to proceed; for those not interested in performing tracking with external MC's is to; define and use only one `dummy tracking medium` as in the example (or a; `NULL` pointer). ### User Interface for Handling Materials and Media. The **`TGeoManager`** class contains the API for accessing and handling; defined materials:. ``` {.cpp}; TGeoManager::GetMaterial(name);; ```. ## Shapes. Shapes are geometrical objects that provide the basic modeling; functionality. They provide the definition of the `local` coordinate; system of the volume. Any volume must have a shape. Any shape recognized; by the modeller has to derive from the base **`TGeoShape`** class,; providing methods for:. - Finding out if a point defined ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:22505,interface,interface,22505,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['interface'],['interface']
Integrability,"ihood ratio. The boundary of the interval is equivalent to a MINUIT/MINOS contour about the maximum likelihood estimator. . HybridCalculator: hypothesis test calculator using a Bayesian-frequentist hybrid method (often called in HEP as CLs method). This class extends the functionality of the TLimit class by taking advantage of the RooFit package. The result of the calculator is returned as an HybridResult pointer. HybridResult implements the HypoTestResult interface. The class HybridPlot allows for a graphical representation of a HybridResult.; ; HybridCalculator implements the interface class HypoTestCalculator. A constructor exists taking as input the pdf's (expressed as RooAbsPdf instances) for the signal+background (alternate) and background only (null) hypothesis and the data set (as RooAbsData instance). One can provide optionally also the nuisance parameters and its pdf which will be marginalized by the calculator. The HypoTestCalculator interface provides also the possibility of setting the model via a Rooworkspace class and names of the pdf. This possibility is not yet supported for the HybridCalculator class. ; ; . Additional classes or functions provided by RooStats are: ; ; NumberCountingUtils: a collection of number counting statistical utilities; 	NumberCountingPdfFactory: a factory for building ; 	the PDF and the data for a number counting combination and adding them in a RooWorkspace. ; 	SPlot: implementation of the SPlot statistical tool to unfold data distributions and based on RooFit. This class uses the same statistical algorithm used in the class TSPlot, but in addition it provides the possibility to model the input distributions using RooFit model classes. This class can then be used in combination of a RooFit maximum likelihood fit. ; 	. RooStats tutorials macros; 	Tutorials are provided in the tutorials/roostats directory:. 	; rs100_numbercounting.C: an example of a combination of two searches using number counting with background uncertainty.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html:11827,interface,interface,11827,roofit/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html,2,['interface'],['interface']
Integrability,"ike so:. .. code-block:: objc. [receiver foo: fooArg bar: barArg baz: bazArg]. This looks in the dynamic class of the receiver for a method with this name,; then in that class's superclass, etc., until it finds something it can execute.; The receiver ""expression"" may also be the name of a class, in which case the; actual receiver is the class object for that class, or (within method; definitions) it may be ``super``, in which case the lookup algorithm starts; with the static superclass instead of the dynamic class. The actual methods; dynamically found in a class are not those declared in the ``@interface``, but; those defined in a separate ``@implementation`` declaration; however, when; compiling a call, typechecking is done based on the methods declared in the; ``@interface``. Method declarations may also be grouped into :arc-term:`protocols`, which are not; inherently associated with any class, but which classes may claim to follow.; Object pointer types may be qualified with additional protocols that the object; is known to support. :arc-term:`Class extensions` are collections of ivars and methods, designed to; allow a class's ``@interface`` to be split across multiple files; however,; there is still a primary implementation file which must see the; ``@interface``\ s of all class extensions. :arc-term:`Categories` allow; methods (but not ivars) to be declared *post hoc* on an arbitrary class; the; methods in the category's ``@implementation`` will be dynamically added to that; class's method tables which the category is loaded at runtime, replacing those; methods in case of a collision. In the standard environment, objects are allocated on the heap, and their; lifetime is manually managed using a reference count. This is done using two; instance methods which all classes are expected to implement: ``retain``; increases the object's reference count by 1, whereas ``release`` decreases it; by 1 and calls the instance method ``dealloc`` if the count reaches 0. To; si",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:5980,protocol,protocols,5980,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['protocol'],['protocols']
Integrability,"il, GSoC, \; Axel Naumann, CERN/SFT,\; Simon Pfreundschuh, GSoC, CERN/SFT,\; Danilo Piparo, CERN/SFT,\; Timur Pocheptsov, CERN/SFT,\; Fons Rademakers, CERN/IT,\; Paul Russo, Fermilab,\; Enric Tejedor Saavedra, CERN/SFT,\; George Troska, Dortmund Univ.,\; Liza Sakellari, CERN/SFT,\; Alex Saperstein, ANL,\; Manuel Tobias Schiller, CERN/LHCb,\; David Smith, CERN/IT,\; Peter Speckmayer,\; Tom Stevenson, Queen Mary University of London, ATLAS\; Matevz Tadel, UCSD/CMS, Eve,\; Peter van Gemmeren, ANL, ATLAS,\; Xavier Valls, CERN/SFT, \; Vassil Vassilev, Fermilab/CMS,\; Stefan Wunsch, KIT, CMS\; Omar Zapata, University of Antioquia, CERN/SFT.; . <a name=""core-libs""></a>. ## General. * Remove many instances of new warnings issued by gcc 6.1; * Significant update of the valgrind suppression file to hide intentional lack; of delete of some entities at the end of the process.; * Resolved several memory leaks.; * Added deprecation system: when compiling against interfaces marked R__DEPRECATED, the compiler will issue a warning showing the ROOT version when the interface will be removed.; * From this version on, building ROOT with CMake requires CMake &gt;= 3.4.3. ## Core Libraries. ROOT prepares for [cxx modules](http://clang.llvm.org/docs/Modules.html). One of; the first requirements is its header files to be self-contained (section ""Missing; Includes""). ROOT header files were cleaned up from extra includes and the missing; includes were added. This could be considered as backward incompatibility (for good however). User; code may need to add extra includes, which were previously resolved indirectly; by including a ROOT header. For example:. * TBuffer.h - TObject.h doesn't include TBuffer.h anymore. Third party code,; replying on the definition of TBufer will need to include TBuffer.h, along; with TObject.h.; * TSystem.h - for some uses of gSystem.; * GeneticMinimizer.h; * ... Other improvements, which may cause compilation errors in third party code:. * If you get `std::type_i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:1853,interface,interfaces,1853,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,2,['interface'],"['interface', 'interfaces']"
Integrability,"il; about what is being run.; If you built LLVM and Clang using CMake, the test suite can be run; with make check-clang from the top-level LLVM directory.; The tests primarily consist of a test runner script running the compiler; under test on individual test files grouped in the directories under the; test directory. The individual test files include comments at the; beginning indicating the Clang compile options to use, to be read; by the test runner. Embedded comments also can do things like telling; the test runner that an error is expected at the current line.; Any output files produced by the test will be placed under; a created Output directory.; During the run of make test, the terminal output will; display a line similar to the following:; --- Running clang tests for i686-pc-linux-gnu ---; followed by a line continually overwritten with the current test; file being compiled, and an overall completion percentage.; After the make test run completes, the absence of any; Failing Tests (count): message indicates that no tests; failed unexpectedly. If any tests did fail, the; Failing Tests (count): message will be followed by a list; of the test source file paths that failed. For example:. Failing Tests (3):; /home/john/llvm/tools/clang/test/SemaCXX/member-name-lookup.cpp; /home/john/llvm/tools/clang/test/SemaCXX/namespace-alias.cpp; /home/john/llvm/tools/clang/test/SemaCXX/using-directive.cpp. If you used the make VERBOSE=1 option, the terminal; output will reflect the error messages from the compiler and; test runner.; The regression suite can also be run with Valgrind by running; make test VG=1 in the top-level clang directory.; For more intensive changes, running; the LLVM; Test Suite with clang is recommended. Currently the best way to; override LLVMGCC, as in: make LLVMGCC=""clang -std=gnu89""; TEST=nightly report (make sure clang is in your PATH or use the; full path). Testing using Visual Studio on Windows. The Clang test suite can be run from either Visual ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:3706,message,message,3706,interpreter/llvm-project/clang/www/hacking.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html,2,['message'],['message']
Integrability,"il; the *absolute* time in seconds and nanoseconds since beginning of; the epoch (January, 1st, 1970) is reached; to use relative timeouts; ‘‘delta'', it is required to calculate the absolute time at the; beginning of waiting ‘‘now''; for example:. ``` {.cpp}; Ulong_t now,then,delta; // seconds; TDatime myTime; // root daytime class; myTime.Set(); // myTime set to ""now""; now=myTime.Convert(); // to seconds since 1970; ```. - Return value wait of `MyCondition.TimedWait` should be 0, if; `MyCondition.Signal()` was received, and should be nonzero, if; timeout was reached. The conditions example shows how three threaded functions are; synchronized using **`TCondition`**: a ROOT script `condstart.C` starts; the threads, which are defined in a shared library; (`conditions.cxx, conditions.h`). #### Xlib Connections. Usually `Xlib` is not thread safe. This means that calls to the X could; fail, when it receives X-messages from different threads. The actual; result depends strongly on which version of `Xlib` has been installed on; your system. The only thing we can do here within ROOT is calling a; special function `XInitThreads() `(which is part of the `Xlib`), which; should (!) prepare the `Xlib` for the usage with threads. To avoid further problems within ROOT some redefinition of the; ***`gPad`*** pointer was done (that's the main reason for the; recompilation). When a thread creates a **`TCanvas`**, this object is; actually created in the main thread; this should be transparent to the; user. Actions on the canvas are controlled via a function, which returns; a pointer to either thread specific data (TSD) or the main thread; pointer. This mechanism works currently only for ***`gPad`***,; ***`gDirectory`***, ***`gFile`*** and will be implemented soon for other; global Objects as e.g. ***`gVirtualX`***. #### Canceling a TThread. Canceling of a thread is a rather dangerous action. In **`TThread`**; canceling is forbidden by default. The user can change this default by; calli",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:10126,depend,depends,10126,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['depend'],['depends']
Integrability,"ilable; transformations are:. - 3D rotation classes. - rotation described by a 3x3 matrix (**`ROOT::Math::Rotation3D`**). - rotation described by Euler angles (**`ROOT::Math::EulerAngles`**). - rotation described by a direction axis and an angle; (**`ROOT::Math::AxisAngle`**). - rotation described by a quaternion (**`ROOT::Math::Quaternion`**). - optimized rotation around `x` (**`ROOT::Math::RotationX`**), `y`; (**`ROOT::Math::RotationY`**) and `z` (**`ROOT::Math::RotationZ`**); and described by just one angle. - 3D transformation: we describe the transformations defined as a; composition between a rotation and a translation using the class; **`ROOT::Math::Transform3D`**. It is important to note that; transformations act differently on vectors and points. The vectors only; rotate, therefore when applying a transformation (rotation +; translation) on a vector, only the rotation operates while the; translation has no effect. The **`Transform3D`** class interface is; similar to the one used in the CLHEP Geometry package (class; <HepGeom::Transform3D>). - Lorentz rotation:. - generic Lorentz rotation described by a `4x4` matrix containing a 3D; rotation part and a boost part (class; **`ROOT::Math::LorentzRotation`**). - a pure boost in an arbitrary direction and described by a 4x4; symmetric matrix or 10 numbers (class **`ROOT::Math::Boost`**). - boost along the axis:` x `(**`ROOT::Math::BoostX`**),; `y `(**`ROOT::Math::BoostY`**) and `z `(**`ROOT::Math::BoostZ`**). #### Minimal Vector Classes Interface. We have tried to keep the interface to a minimal level by:. - Avoiding methods that provide the same functionality but use; different names (like `getX()` and `x()`). - Minimizing the number of setter methods, avoiding methods, which can; be ambiguous and can set the vector classes in an inconsistent; state. We provide only methods which set all the coordinates at the; same time or set only the coordinates on which the vector is based,; for example `SetX()` for a Cartesi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:74071,interface,interface,74071,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['interface'],['interface']
Integrability,"ild; system can cache the resource directory by itself and pass ``-resource-dir <resource-dir>``; explicitly in the command line options:. .. code-block:: console. $ clang-scan-deps -format=p1689 -- <path-to-compiler-executable>/clang++ -std=c++20 -resource-dir <resource-dir> mod.cppm -c -o mod.o. Possible Questions; ==================. How modules speed up compilation; --------------------------------. A classic theory for the reason why modules speed up the compilation is:; if there are ``n`` headers and ``m`` source files and each header is included by each source file,; then the complexity of the compilation is ``O(n*m)``;; But if there are ``n`` module interfaces and ``m`` source files, the complexity of the compilation is; ``O(n+m)``. So, using modules would be a big win when scaling.; In a simpler word, we could get rid of many redundant compilations by using modules. Roughly, this theory is correct. But the problem is that it is too rough.; The behavior depends on the optimization level, as we will illustrate below. First is ``O0``. The compilation process is described in the following graph. .. code-block:: none. ├-------------frontend----------┼-------------middle end----------------┼----backend----┤; │ │ │ │; └---parsing----sema----codegen--┴----- transformations ---- codegen ----┴---- codegen --┘. ┌---------------------------------------------------------------------------------------┐; | │; | source file │; | │; └---------------------------------------------------------------------------------------┘. ┌--------┐; │ │; │imported│; │ │; │ code │; │ │; └--------┘. Here we can see that the source file (could be a non-module unit or a module unit) would get processed by the; whole pipeline.; But the imported code would only get involved in semantic analysis, which is mainly about name lookup,; overload resolution and template instantiation.; All of these processes are fast relative to the whole compilation process.; More importantly, the imported code only n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:40203,depend,depends,40203,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['depend'],['depends']
Integrability,"ile changes (and none of the headers it; depends on), reparsing of that source file can use the precompiled preamble and; start parsing after the ``#include``\ s, so parsing time is proportional to the; size of the source file (rather than all of its includes). However, the; compilation of that translation unit may already use a precompiled header: in; this case, Clang will create the precompiled preamble as a chained precompiled; header that refers to the original precompiled header. This drastically; reduces the time needed to serialize the precompiled preamble for use in; reparsing. Chained precompiled headers get their name because each precompiled header can; depend on one other precompiled header, forming a chain of dependencies. A; translation unit will then include the precompiled header that starts the chain; (i.e., nothing depends on it). This linearity of dependencies is important for; the semantic model of chained precompiled headers, because the most-recent; precompiled header can provide information that overrides the information; provided by the precompiled headers it depends on, just like a header file; ``B.h`` that includes another header ``A.h`` can modify the state produced by; parsing ``A.h``, e.g., by ``#undef``'ing a macro defined in ``A.h``. There are several ways in which chained precompiled headers generalize the AST; file model:. Numbering of IDs; Many different kinds of entities --- identifiers, declarations, types, etc.; --- have ID numbers that start at 1 or some other predefined constant and; grow upward. Each precompiled header records the maximum ID number it has; assigned in each category. Then, when a new precompiled header is generated; that depends on (chains to) another precompiled header, it will start; counting at the next available ID number. This way, one can determine, given; an ID number, which AST file actually contains the entity. Name lookup; When writing a chained precompiled header, Clang attempts to write only; informa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:24963,depend,dependencies,24963,interpreter/llvm-project/clang/docs/PCHInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst,2,['depend'],"['dependencies', 'depends']"
Integrability,"ile lower-order rules save time when the function contains local difficulties, such as discontinuities. If no integration rule; 	 is passed, the 31 points rule is used as default. * 	 `ROOT::Math::Integration::kADAPTIVESINGULAR`: based on `gsl_integration_qags`. It is an integration type which can be used in the case of the presence of singularities.It uses the; Gauss-Kronrod 21-point integration rule. This is the default algorithm. Note that when using the common `ROOT::Math::IntegratorOneDIm` class the enumeration type defining the algorithm must be defined in the namespace `ROOT::Math::IntegrationOneDim` (to distinguish from; the multi-dimensional case) and the rule enumeration (or its corresponding integer) can be passed in the constructor of the `ROOT::Math::IntegratorOneDIm`. ### Multi-dimensional Integration. The multi-dimensional integration algorithm should be applied to functions with dimension larger than one.; Adaptive multi-dimensional integration works for low function dimension, while MC integration can be applied to higher dimensions. #### Using `ROOT::Math::IntegratorMultiDim`. Here is a code example on how to use the `ROOT::Math::IntegratorOneDim` class; (note that the class is defined in the header file `Math/Integrator.h`). In this example we create; different instance of the class using some of the available algorithms in ROOT. ```{.cpp}; #include ""Math/IntegratorMultiDim.h""; #include ""Math/Functor.h"". double f2(const double * x) {; return x[0] + x[1];; }. int testIntegrationMultiDim() {. const double RESULT = 1.0;; const double ERRORLIMIT = 1E-3;; int status = 0;. ROOT::Math::Functor wf(&f2,2);; double a[2] = {0,0};; double b[2] = {1,1};. ROOT::Math::IntegratorMultiDim ig(ROOT::Math::IntegrationMultiDim::kADAPTIVE);; ig.SetFunction(wf);; double val = ig.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::IntegratorMultiDim ig2(ROOT::Math::IntegrationMultiDim::kVEGAS",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:58290,integrat,integration,58290,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,2,['integrat'],['integration']
Integrability,"ile those with the *`quantile_c`* extension calculate the inverse of; the complement of the cumulative distribution (upper tail integral). All; the inverse distributions are in the MathMore library and are defined in; the header file `Math/ProbFuncInv.h`. The following picture illustrates the available statistical functions; (PDF, CDF and quantiles) in the case of the normal distribution. ![PDF, CDF and quantiles in the case of the normal distribution](pictures/03000128.png). ## Numerical Algorithms. ROOT provides C++ classes implementing numerical algorithms to solve a wide set of problem, like:. * Evaluation of function derivatives.; * Evaluation of integrals.; * Finding the roots of a function; * Finding the minimum/maximum of a function. In order to use these algorithm the user needs to provide a function.; ROOT provides a common way of specifying them via some interfaces. ## ROOT::Math Function interfaces. To get a consistency in the mathematical methods within ROOT, there exists a set of interfaces to define the basic behaviour of a mathematical function.; In order to use the classes presented in this chapter, the mathematical functions defined by the user must inherit from any of the classes seen in the figure:. ![ROOT::Math Function interface structure](pictures/function-hierarchy.png). ### One-dimensional Function Interfaces. These interfaces are used for numerical algorithms operating only on one-dimensional functions and cannot be applied to multi-dimensional functions.; For this case the users needs to define a function object which evaluates in one dimension, and the object will have to derivate from the following:. * `ROOT::Math::IBaseFunctionOneDim`: This class is the most basic function. Provides a method to evaluate the function given a value (simple double) by implementing; `double operator() (const double )`. The user class defined only needs to reimplement the pure abstract method `double DoEval(double x)`,; that will do the work of evaluating the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:34849,interface,interfaces,34849,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['interface'],['interfaces']
Integrability,"ile. For example:. .. code-block:: console. $ clang-scan-deps -format=p1689 -- <path-to-compiler-executable>/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o. And we'll get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part""; }; ]; }; ],; ""version"": 1; }. In this way, we can pass the single command line options after the ``--``.; Then clang-scan-deps will extract the necessary information from the options.; Note that we need to specify the path to the compiler executable instead of saying; ``clang++`` simply. The users may want the scanner to get the transitional dependency information for headers.; Otherwise, the users have to scan twice for the project, once for headers and once for modules.; To address the requirement, clang-scan-deps will recognize the specified preprocessor options; in the given command line and generate the corresponding dependency information. For example,. .. code-block:: console. $ clang-scan-deps -format=p1689 -- ../bin/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o -MD -MT impl_part.ddi -MF impl_part.dep; $ cat impl_part.dep. We will get:. .. code-block:: text. impl_part.ddi: \; /usr/include/bits/wchar.h /usr/include/bits/types/wint_t.h \; /usr/include/bits/types/mbstate_t.h \; /usr/include/bits/types/__mbstate_t.h /usr/include/bits/types/__FILE.h \; /usr/include/bits/types/FILE.h /usr/include/bits/types/locale_t.h \; /usr/include/bits/types/__locale_t.h \; ... When clang-scan-deps detects ``-MF`` option, clang-scan-deps will try to write the; dependency information for headers to the file specified by ``-MF``. Possible Issues: Failed to find system headers; ----------------------------------------------. In case the users encounter errors like ``fatal error: 'stddef.h' file not found``,; probably the specified ``<path-to-compil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:37301,depend,dependency,37301,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['depend'],['dependency']
Integrability,"iled.; Linkage relationships between ``JITDylibs`` determine how inter-module; references are resolved, and symbol resolvers are no longer used. See the; section `Design Overview`_ for more details. Unless multiple JITDylibs are needed to model linkage relationships, ORCv1; clients should place all code in a single JITDylib.; MCJIT clients should use LLJIT (see `LLJIT and LLLazyJIT`_), and can place; code in LLJIT's default created main JITDylib (See; ``LLJIT::getMainJITDylib()``). 2. All JIT stacks now need an ``ExecutionSession`` instance. ExecutionSession; manages the string pool, error reporting, synchronization, and symbol; lookup. 3. ORCv2 uses uniqued strings (``SymbolStringPtr`` instances) rather than; string values in order to reduce memory overhead and improve lookup; performance. See the subsection `How to manage symbol strings`_. 4. IR layers require ThreadSafeModule instances, rather than; std::unique_ptr<Module>s. ThreadSafeModule is a wrapper that ensures that; Modules that use the same LLVMContext are not accessed concurrently.; See `How to use ThreadSafeModule and ThreadSafeContext`_. 5. Symbol lookup is no longer handled by layers. Instead, there is a; ``lookup`` method on JITDylib that takes a list of JITDylibs to scan. .. code-block:: c++. ExecutionSession ES;; JITDylib &JD1 = ...;; JITDylib &JD2 = ...;. auto Sym = ES.lookup({&JD1, &JD2}, ES.intern(""_main""));. 6. The removeModule/removeObject methods are replaced by; ``ResourceTracker::remove``.; See the subsection `How to remove code`_. For code examples and suggestions of how to use the ORCv2 APIs, please see; the section `How-tos`_. How-tos; =======. How to manage symbol strings; ----------------------------. Symbol strings in ORC are uniqued to improve lookup performance, reduce memory; overhead, and allow symbol names to function as efficient keys. To get the; unique ``SymbolStringPtr`` for a string value, call the; ``ExecutionSession::intern`` method:. .. code-block:: c++. ExecutionSession ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:21287,wrap,wrapper,21287,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['wrap'],['wrapper']
Integrability,"iler and standard library provide an implmentation, it is used. The type string_view describes an object that can refer to a constant contiguous sequence of char-like objects with the first element of the sequence at position zero. This type is used throughout the ROOT code to avoid copying strings when a; sub-string is needed and to extent interfaces that uses to take a const char*; to take a std::string_view as thus be able to be directly directly passed a; TString, a std::string or a std::string_view. Usage example:. ``` {.cpp}; // With SetName(std::string_view); std::string str; …; obj.SetName( str );; obj.SetName( {str.data()+pos, len} );; ```. ### Meta library. #### Backward Incompatibilities. TIsAProxy's constructor no longer take the optional and unused 2nd argument which was reserved for a 'context'. This context was unused in TIsAProxy itself and was not accessible from derived classes. #### Interpreter. The new interface `TInterpreter::Declare(const char* code)` will declare the; code to the interpreter with all interpreter extensions disabled, i.e. as; ""proper"" C++ code. No autoloading or synamic lookup will be performed. A new R__LOAD_LIBRARY(libWhatever) will load libWhatever at parse time. This allows ROOT to resolve symbols from this library very early on. It is a work-around for the following code from ROOT 5:. ``` {.cpp}; // ROOT 5:; void func() {; gSystem->Load(""libEvent"");; Event* e = new Event;; }; ```. Instead, write:. ``` {.cpp}; // ROOT 6:; R__LOAD_LIBRARY(libEvent); #include ""Event.h"". void func() {; Event* e = new Event;; }; ```. #### TClass. Introduced new overload for calculating the TClass CheckSum:. ``` {.cpp}; UInt_t TClass::GetCheckSum(ECheckSum code, Bool_t &isvalid) const;; ```. which indicates via the 'isvalid' boolean whether the checksum could be; calculated correctly or not. ### TROOT. Implemented new gROOT->GetTutorialsDir() static method to return the actual location of the tutorials directory.; This is $ROOTSYS/tutorials when ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md:2724,interface,interface,2724,README/ReleaseNotes/v604/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md,1,['interface'],['interface']
Integrability,"iling; all back-ends. For that reason, you should also set the; ``TARGETS_TO_BUILD`` to only build the back-end you're targeting to. You must set the ``CMAKE_INSTALL_PREFIX``, otherwise a ``ninja install``; will copy ARM binaries to your root filesystem, which is not what you; want. Hacks; -----. There are some bugs in current LLVM, which require some fiddling before; running CMake:. #. If you're using Clang as the cross-compiler, there is a problem in; the LLVM ARM back-end that is producing absolute relocations on; position-independent code (``R_ARM_THM_MOVW_ABS_NC``), so for now, you; should disable PIC:. .. code-block:: bash. -DLLVM_ENABLE_PIC=False. This is not a problem, since Clang/LLVM libraries are statically; linked anyway, it shouldn't affect much. #. The ARM libraries won't be installed in your system.; But the CMake prepare step, which checks for; dependencies, will check the *host* libraries, not the *target*; ones. Below there's a list of some dependencies, but your project could; have more, or this document could be outdated. You'll see the errors; while linking as an indication of that. Debian based distros have a way to add ``multiarch``, which adds; a new architecture and allows you to install packages for those; systems. See https://wiki.debian.org/Multiarch/HOWTO for more info. But not all distros will have that, and possibly not an easy way to; install them in any anyway, so you'll have to build/download; them separately. A quick way of getting the libraries is to download them from; a distribution repository, like Debian (http://packages.debian.org/jessie/),; and download the missing libraries. Note that the ``libXXX``; will have the shared objects (``.so``) and the ``libXXX-dev`` will; give you the headers and the static (``.a``) library. Just in; case, download both. The ones you need for ARM are: ``libtinfo``, ``zlib1g``,; ``libxml2`` and ``liblzma``. In the Debian repository you'll; find downloads for all architectures. After you download ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileLLVM.rst:4873,depend,dependencies,4873,interpreter/llvm-project/llvm/docs/HowToCrossCompileLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileLLVM.rst,1,['depend'],['dependencies']
Integrability,"ill able to; benefit from their use. The **`TThread`** class is available on all; platforms, which provide a POSIX compliant thread implementation. On; Linux, Xavier Leroy's Linux Threads implementation is widely used, but; the **`TThread`** implementation should be usable on all platforms that; provide `pthread`. **Linux Xlib on SMP machines** is not yet thread-safe. This may cause; crashes during threaded graphics operations; this problem is independent; of ROOT. **Object instantiation:** there is no implicit locking mechanism for; memory allocation and global ROOT lists. The user has to explicitly; protect their code when using them. ## The Signals of ROOT. The list of default signals handled by ROOT is:. ``` {.cpp}; kSigChildkSigPipe; kSigBuskSigAlarm; kSigSegmentationViolationkSigUrgent; kSigIllegalInstructionkSigFloatingException; kSigSystemkSigWindowChanged; ```. The signals ***`kSigFloatingException`***,; ***`kSigSegmentationViolation`***, ***`kSigIllegalInstruction`***, and; ***`kSigBus`*** cause the printing of the ***`*** Break *** `*** message; and make a long jump back to the ROOT prompt. No other custom; **`TSignalHandler`** can be added to these signals. The ***`kSigAlarm`*** signal handles asynchronous timers. The; ***`kSigWindowChanged`*** signal handles the resizing of the terminal; window. The other signals have no other behavior then that to call any; registered **`TSignalHandler`*****`::Notify()`***. When building in interactive application the use of the **`TRint`**; object handles the `kSigInterrupt` signal. It causes the printing of the; message: ***`*** Break *** keyboard interrupt `***and makes a long jump; back to the ROOT command prompt. If no **`TRint`** object is created,; there will be no `kSigInterrupt` handling. All signals can be reset to; their default UNIX behavior via the call of; **`TSytem`**`::ResetSignal()`. All signals can be ignored via; `TSytem::IgnoreSignal()`. The **`TSytem::IgnoreInterrupt()`** is a method; to toggle the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:18219,message,message,18219,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['message'],['message']
Integrability,"implementation extends its corresponding; node and edge types resulting in the inheritance relationship depicted; in the UML diagram below:. .. image:: uml_nodes_and_edges.png. Graph Construction; ------------------. The graph build algorithm considers dependencies between elements of; a given set of instructions or basic blocks. Any dependencies coming; into or going out of instructions that do not belong to that range; are ignored. The steps in the build algorithm for the DDG are very; similar to the steps in the build algorithm for the PDG. As such,; one of the design goals is to reuse the build algorithm code to; allow creation of both DDG and PDG representations while allowing; the two implementations to define their own distinct and independent; node and edge types. This is achieved by using the well-known builder; design pattern to isolate the construction of the dependence graph; from its concrete representation. The following UML diagram depicts the overall structure of the design; pattern as it applies to the dependence graph implementation. .. image:: uml_builder_pattern.png. Notice that the common code for building the two types of graphs are; provided in the ``DependenceGraphBuilder`` class, while the ``DDGBuilder``; and ``PDGBuilder`` control some aspects of how the graph is constructed; by the way of overriding virtual methods defined in ``DependenceGraphBuilder``. Note also that the steps and the names used in this diagram are for; illustrative purposes and may be different from those in the actual; implementation. Design Trade-offs; -----------------. Advantages:; ^^^^^^^^^^^; - Builder allows graph construction code to be reused for DDG and PDG.; - Builder allows us to create DDG and PDG as separate graphs.; - DDG nodes and edges are completely disjoint from PDG nodes and edges allowing them to change easily and independently. Disadvantages:; ^^^^^^^^^^^^^^; - Builder may be perceived as over-engineering at first.; - There are some similarities betw",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst:3575,depend,dependence,3575,interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,1,['depend'],['dependence']
Integrability,"imulated; hardware resources. The processor dispatch width defaults to the value; of the ``IssueWidth`` in LLVM's scheduling model. An instruction can be dispatched if:. * The size of the dispatch group is smaller than processor's dispatch width.; * There are enough entries in the reorder buffer.; * There are enough physical registers to do register renaming.; * The schedulers are not full. Scheduling models can optionally specify which register files are available on; the processor. :program:`llvm-mca` uses that information to initialize register; file descriptors. Users can limit the number of physical registers that are; globally available for register renaming by using the command option; ``-register-file-size``. A value of zero for this option means *unbounded*. By; knowing how many registers are available for renaming, the tool can predict; dispatch stalls caused by the lack of physical registers. The number of reorder buffer entries consumed by an instruction depends on the; number of micro-opcodes specified for that instruction by the target scheduling; model. The reorder buffer is responsible for tracking the progress of; instructions that are ""in-flight"", and retiring them in program order. The; number of entries in the reorder buffer defaults to the value specified by field; `MicroOpBufferSize` in the target scheduling model. Instructions that are dispatched to the schedulers consume scheduler buffer; entries. :program:`llvm-mca` queries the scheduling model to determine the set; of buffered resources consumed by an instruction. Buffered resources are; treated like scheduler resources. Instruction Issue; """"""""""""""""""""""""""""""""""; Each processor scheduler implements a buffer of instructions. An instruction; has to wait in the scheduler's buffer until input register operands become; available. Only at that point, does the instruction becomes eligible for; execution and may be issued (potentially out-of-order) for execution.; Instruction latencies are computed by :",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst:36146,depend,depends,36146,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,1,['depend'],['depends']
Integrability,"in RooStats are provided in the namespace RooStats.; ; RooStats interfaces. ConfInterval: interface for describing a confidence interval. ; IntervalCalculator: interface for a statistical tool producing confidence intervals (class ConfInterval).; HypoTestResult: interface for representing results of a hypothesis test; HypoTestCalculator: interface for a statistical tool performing an hypothesis test. ; CombinedCalculator: interface for a statistical tool which can produce both hypothesis test results and confidence intervals. ; RooStats concrete classes. The concrete classes describing statistical tools implementing the above interfaces are:; ; ProfileLikelihoodCalculator: it is an implementation of a CombinedCalculator using the profile likelihood ratio as a test statistics. After configuring the calculator, one only needs to ask GetHypoTest() (which will return a HypoTestResult pointer) or GetInterval() (which will return an ConfInterval pointer).; LikelihoodInterval: concrete implementation of a ConfInterval interface. It implements connected N-dimensional intervals based on the contour of a likelihood ratio. The boundary of the interval is equivalent to a MINUIT/MINOS contour about the maximum likelihood estimator. . HybridCalculator: hypothesis test calculator using a Bayesian-frequentist hybrid method (often called in HEP as CLs method). This class extends the functionality of the TLimit class by taking advantage of the RooFit package. The result of the calculator is returned as an HybridResult pointer. HybridResult implements the HypoTestResult interface. The class HybridPlot allows for a graphical representation of a HybridResult.; ; HybridCalculator implements the interface class HypoTestCalculator. A constructor exists taking as input the pdf's (expressed as RooAbsPdf instances) for the signal+background (alternate) and background only (null) hypothesis and the data set (as RooAbsData instance). One can provide optionally also the nuisance parameters and i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html:10778,interface,interface,10778,roofit/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html,2,['interface'],['interface']
Integrability,"in other namespaces). .. code-block:: c++. namespace out {; int i;; namespace in {; int i;; }; }. * ``NI_All`` (in configuration: ``All``); Indent in all namespaces. .. code-block:: c++. namespace out {; int i;; namespace in {; int i;; }; }. .. _NamespaceMacros:. **NamespaceMacros** (``List of Strings``) :versionbadge:`clang-format 9` :ref:`¶ <NamespaceMacros>`; A vector of macros which are used to open namespace blocks. These are expected to be macros of the form:. .. code-block:: c++. NAMESPACE(<namespace-name>, ...) {; <namespace-content>; }. For example: TESTSUITE. .. _ObjCBinPackProtocolList:. **ObjCBinPackProtocolList** (``BinPackStyle``) :versionbadge:`clang-format 7` :ref:`¶ <ObjCBinPackProtocolList>`; Controls bin-packing Objective-C protocol conformance list; items into as few lines as possible when they go over ``ColumnLimit``. If ``Auto`` (the default), delegates to the value in; ``BinPackParameters``. If that is ``true``, bin-packs Objective-C; protocol conformance list items into as few lines as possible; whenever they go over ``ColumnLimit``. If ``Always``, always bin-packs Objective-C protocol conformance; list items into as few lines as possible whenever they go over; ``ColumnLimit``. If ``Never``, lays out Objective-C protocol conformance list items; onto individual lines whenever they go over ``ColumnLimit``. .. code-block:: objc. Always (or Auto, if BinPackParameters=true):; @interface ccccccccccccc () <; ccccccccccccc, ccccccccccccc,; ccccccccccccc, ccccccccccccc> {; }. Never (or Auto, if BinPackParameters=false):; @interface ddddddddddddd () <; ddddddddddddd,; ddddddddddddd,; ddddddddddddd,; ddddddddddddd> {; }. Possible values:. * ``BPS_Auto`` (in configuration: ``Auto``); Automatically determine parameter bin-packing behavior. * ``BPS_Always`` (in configuration: ``Always``); Always bin-pack parameters. * ``BPS_Never`` (in configuration: ``Never``); Never bin-pack parameters. .. _ObjCBlockIndentWidth:. **ObjCBlockIndentWidth** (``Unsigned``) :",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:88343,protocol,protocol,88343,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['protocol'],['protocol']
Integrability,"in the code or a bug in the compiler. The first; thing to check is to make sure it is not using undefined behavior (e.g.; reading a variable before it is defined). In particular, check to see if the; program is clean under various `sanitizers; <https://github.com/google/sanitizers>`_ (e.g. ``clang; -fsanitize=undefined,address``) and `valgrind <http://valgrind.org/>`_. Many; ""LLVM bugs"" that we have chased down ended up being bugs in the program being; compiled, not LLVM. Once you determine that the program itself is not buggy, you should choose; which code generator you wish to compile the program with (e.g. LLC or the JIT); and optionally a series of LLVM passes to run. For example:. .. code-block:: bash. bugpoint -run-llc [... optzn passes ...] file-to-test.bc --args -- [program arguments]. bugpoint will try to narrow down your list of passes to the one pass that; causes an error, and simplify the bitcode file as much as it can to assist; you. It will print a message letting you know how to reproduce the; resulting error. The :doc:`OptBisect <OptBisect>` page shows an alternative method for finding; incorrect optimization passes. Incorrect code generation; =========================. Similarly to debugging incorrect compilation by mis-behaving passes, you; can debug incorrect code generation by either LLC or the JIT, using; ``bugpoint``. The process ``bugpoint`` follows in this case is to try to; narrow the code down to a function that is miscompiled by one or the other; method, but since for correctness, the entire program must be run,; ``bugpoint`` will compile the code it deems to not be affected with the C; Backend, and then link in the shared object it generates. To debug the JIT:. .. code-block:: bash. bugpoint -run-jit -output=[correct output file] [bitcode file] \; --tool-args -- [arguments to pass to lli] \; --args -- [program arguments]. Similarly, to debug the LLC, one would run:. .. code-block:: bash. bugpoint -run-llc -output=[correct output file] [bi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSubmitABug.rst:9061,message,message,9061,interpreter/llvm-project/llvm/docs/HowToSubmitABug.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSubmitABug.rst,1,['message'],['message']
Integrability,"in to align the behavior with a TTree. You need to call; TTree::SetCacheSize to enable the TTreeCache.; Correct and clarify the relationship between AutoFlush and AutoSave:; ; Both the AutoFlush and AutoSave interval can be specified in; terms of bytes (a negative value for fAutoFlush or fAutoSave); or in terms of the number of entries (positive values).; An AutoFlush is always done with an AutoSave.; If the interval specified for AutoSave is less than that for; AutoFlush, the AutoSave interval is used for both.; If the AutoFlush interval is less than the AutoSave interval,; the AutoSave interval is adjusted to the largest integer; multiple of the AutoFlush interval that is less than or equal; to the original value of the AutoSave interval. Update MakeProxy so that the resulting skeleton is useable with Proof.; Update MakeProxy, MakeClass and MakeSelector to support more cases of branches names (that includes characters illegal in a C++ symbol); Replace the ReadLeaves virtual function by a fReadLeaves pointer to member function,; this allows the customization of the ReadLeaves function at run-time depending on the; underlying user class layout in TBranchElement. This removes many if statements whose; 'answer' is known at initialization time. Add support for 'array' formula in TTree::Query.; Set the initial value of fCacheSize to zero to indicate clearly that the TreeCache is disabled.; In TChain::SetEntryList use only the treename to lookup the (sub)entryList (instead subdir/treename).; Add support for the branch creation syntax:; TString rootString;; t->Branch(""rootString"",""TString"",&rootString, 1600, 0);; which is 'natural' as it uses the legacy syntax (branch_name,class_name, user_data); but did not work because 'rootString' is an object rather than a pointer to an; object. (However the simplier form:; t->Branch(""rootString"",&rootString, 1600, 0);; works/worked fine). Add type information to the result of TTree::Print in the case of; TBranchElement:; *Br 17 :fH : ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v528/index.html:4008,depend,depending,4008,tree/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v528/index.html,2,['depend'],['depending']
Integrability,"in::GetAsDataHist` functions are deprecated and will be removed in ROOT 6.36. The same functionality can be implemented by calling `RooAbsData::reduce` on the Markov Chain's `RooDataSet*` (obtained using `MarkovChain::GetAsConstDataSet`) and then obtaining its binned clone(for `RooDataHist`). An example in Python would be:. ```py; mcInt = mc.GetInterval() # Obtain the MCMCInterval from a configured MCMCCalculator; mkc = mcInt.GetChain() # Obtain the MarkovChain; mkcData = mkc.GetAsConstDataSet(); mcIntParams = mcInt.GetParameters(). chainDataset = mkcData.reduce(SelectVars=mcIntParams, EventRange=(mcInt.GetNumBurnInSteps(), mkc.Size())); chainDataHist = chainDataset.binnedClone(); ```. * The following methods related to the RooAbsArg interface are deprecated and will be removed in ROOT 6.36.; They should be replaced with the suitable alternatives interfaces:. - `RooAbsArg::getDependents()`: use `getObservables()`; - `RooAbsArg::dependentOverlaps()`: use `observableOverlaps()`; - `RooAbsArg::checkDependents()`: use `checkObservables()`; - `RooAbsArg::recursiveCheckDependents()`: use `recursiveCheckObservables()`. ## Graphics Backends. ## 2D Graphics Libraries. ## 3D Graphics Libraries. ## Geometry Libraries. ## Database Libraries. ## Networking Libraries. ## GUI Libraries. ## Montecarlo Libraries. ## PROOF Libraries. ## PyROOT. ### Typesafe `TTree::SetBranchAddress()` for array inputs. If you call `TTree::SetBranchAddress` with NumPy array or `array.array` inputs, ROOT will now check if the array type matches with the column type.; If it doesn't, `SetBranchAddress()` will return a negative status code and print an error.; Take for example this code snippet:; ```python; arr = array.array(typecode, ""d""); status = t.SetBranchAddress(""name"", arr); print(""Status = %s"" % (status, )); ```; If the branch type is also `double` (like the type of the array indicated by `""d""`), the call to `SetBranchAddress()` would succeed with status code zero.; If the type doesn't match, you ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v634/index.md:6539,depend,dependentOverlaps,6539,README/ReleaseNotes/v634/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v634/index.md,1,['depend'],['dependentOverlaps']
Integrability,"inatorTree`` is called by pass; manager before returning a reference to the desired pass. If your pass is capable of updating analyses if they exist (e.g.,; ``BreakCriticalEdges``, as described above), you can use the; ``getAnalysisIfAvailable`` method, which returns a pointer to the analysis if; it is active. For example:. .. code-block:: c++. if (DominatorSet *DS = getAnalysisIfAvailable<DominatorSet>()) {; // A DominatorSet is active. This code will update it.; }. Implementing Analysis Groups; ----------------------------. Now that we understand the basics of how passes are defined, how they are used,; and how they are required from other passes, it's time to get a little bit; fancier. All of the pass relationships that we have seen so far are very; simple: one pass depends on one other specific pass to be run before it can; run. For many applications, this is great, for others, more flexibility is; required. In particular, some analyses are defined such that there is a single simple; interface to the analysis results, but multiple ways of calculating them.; Consider alias analysis for example. The most trivial alias analysis returns; ""may alias"" for any alias query. The most sophisticated analysis a; flow-sensitive, context-sensitive interprocedural analysis that can take a; significant amount of time to execute (and obviously, there is a lot of room; between these two extremes for other implementations). To cleanly support; situations like this, the LLVM Pass Infrastructure supports the notion of; Analysis Groups. Analysis Group Concepts; ^^^^^^^^^^^^^^^^^^^^^^^. An Analysis Group is a single simple interface that may be implemented by; multiple different passes. Analysis Groups can be given human readable names; just like passes, but unlike passes, they need not derive from the ``Pass``; class. An analysis group may have one or more implementations, one of which is; the ""default"" implementation. Analysis groups are used by client passes just like other passes a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:35079,interface,interface,35079,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['interface'],['interface']
Integrability,"include distributed RDataFrame in the ROOT build is Python 3.8. More information in the relative; [github issue](https://github.com/root-project/root/issues/11515).; - `Stats` and `StdDev` operations are now available in distributed mode.; - `GetColumnNames` operation is now available in distributed mode. ## Histogram Libraries. - New class `TGraph2DAsymmErrors` to create TGraph2D with asymmetric errors.; ![TGraph2DAsymmErrors](TGraph2DAsymmErrors.png). ## Math Libraries. ### Fitter class. Some improvements and small fixes to the internal object memory management have been applied to the `ROOT::Fit::Fitter` class.; - When setting an external FCN (objective function) to the Fitter, the function object is not cloned anymore.; - A memory leak has been fixed, when using the `GSLMultiFit` class.; - A bug has been resolved in setting fixed variables when using the linear fitter (via the `TLinearMinimizer` class). Support for providing the second derivatives (Hessian matrix) from the model function is added to the `Fitter` class and the corresponding function interfaces. The functionality it is then propagated in the implementation of the `FitMethod` classes and it is also added to the `Minimizer` classes for providing a user computed Hessian of the objective functions to the minimizers. Only Minuit2 (see below) has the capabilities of using this external Hessian. The `GradFunctor` class has been improved by providing a new constructor taking an `std::function` implementing the full gradient calculations instead of the single partial derivative. The specialized methods for least-square/likelihood functions such as Fumili, Fumili2 and GSLMultiFit have been improved in case of binned likelihood fits, where a better approximation is used than before. This makes these method work better (conerging with less number of function calls) for these types of fits. ### Minuit2. The support for using an External Hessian calculator has been added. The external Hessian can be used for bo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:15458,interface,interfaces,15458,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['interface'],['interfaces']
Integrability,"include(LLVMExternalProjectUtils). set(CLANG_PGO_TRAINING_DATA ""${CMAKE_CURRENT_SOURCE_DIR}"" CACHE PATH; ""The path to a lit testsuite containing samples for PGO and order file generation""; ); set(CLANG_PGO_TRAINING_DATA_SOURCE_DIR OFF CACHE STRING ""Path to source directory containing cmake project with source files to use for generating pgo data""); set(CLANG_PGO_TRAINING_DEPS """" CACHE STRING ""Extra dependencies needed to build the PGO training data.""). if(LLVM_BUILD_INSTRUMENTED); configure_lit_site_cfg(; ${CMAKE_CURRENT_SOURCE_DIR}/lit.site.cfg.in; ${CMAKE_CURRENT_BINARY_DIR}/pgo-data/lit.site.cfg; ). add_lit_testsuite(generate-profraw ""Generating clang PGO data""; ${CMAKE_CURRENT_BINARY_DIR}/pgo-data/; EXCLUDE_FROM_CHECK_ALL; DEPENDS clang clear-profraw ${CLANG_PGO_TRAINING_DEPS}; ). add_custom_target(clear-profraw; COMMAND ""${Python3_EXECUTABLE}"" ${CMAKE_CURRENT_SOURCE_DIR}/perf-helper.py clean ${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_BINARY_DIR}/profiles/ profraw; COMMENT ""Clearing old profraw data""). if(NOT LLVM_PROFDATA); find_program(LLVM_PROFDATA llvm-profdata); endif(). if(NOT LLVM_PROFDATA); message(STATUS ""To enable merging PGO data LLVM_PROFDATA has to point to llvm-profdata""); else(); add_custom_target(generate-profdata; COMMAND ""${Python3_EXECUTABLE}"" ${CMAKE_CURRENT_SOURCE_DIR}/perf-helper.py merge ${LLVM_PROFDATA} ${CMAKE_CURRENT_BINARY_DIR}/clang.profdata ${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_BINARY_DIR}/profiles/; COMMENT ""Merging profdata""; DEPENDS generate-profraw); if (CLANG_PGO_TRAINING_DATA_SOURCE_DIR); llvm_ExternalProject_Add(generate-profraw-external ${CLANG_PGO_TRAINING_DATA_SOURCE_DIR}; USE_TOOLCHAIN EXLUDE_FROM_ALL NO_INSTALL DEPENDS generate-profraw); add_dependencies(generate-profdata generate-profraw-external); endif(); endif(); endif(). find_program(DTRACE dtrace); # TODO: Look into supporting this for the driver build. It will require changing; # the perf-helper.py file to understand to call `llvm` as `llvm clang`.; if(APPLE AND DTRACE AND N",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/CMakeLists.txt:402,depend,dependencies,402,interpreter/llvm-project/clang/utils/perf-training/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/CMakeLists.txt,1,['depend'],['dependencies']
Integrability,"include_directories( ${CMAKE_CURRENT_SOURCE_DIR}/.. ). if(NOT DEFINED ITTAPI_GIT_REPOSITORY); set(ITTAPI_GIT_REPOSITORY https://github.com/intel/ittapi.git); endif(). if(NOT DEFINED ITTAPI_GIT_TAG); set(ITTAPI_GIT_TAG v3.18.12); endif(). if(NOT DEFINED ITTAPI_SOURCE_DIR); set(ITTAPI_SOURCE_DIR ${PROJECT_BINARY_DIR}); endif(). if(NOT EXISTS ${ITTAPI_SOURCE_DIR}/ittapi); execute_process(COMMAND ${GIT_EXECUTABLE} clone ${ITTAPI_GIT_REPOSITORY}; WORKING_DIRECTORY ${ITTAPI_SOURCE_DIR}; RESULT_VARIABLE GIT_CLONE_RESULT); if(NOT GIT_CLONE_RESULT EQUAL ""0""); message(FATAL_ERROR ""git clone ${ITTAPI_GIT_REPOSITORY} failed with ${GIT_CLONE_RESULT}, please clone ${ITTAPI_GIT_REPOSITORY}""); endif(); endif(). execute_process(COMMAND ${GIT_EXECUTABLE} checkout ${ITTAPI_GIT_TAG}; WORKING_DIRECTORY ${ITTAPI_SOURCE_DIR}/ittapi; RESULT_VARIABLE GIT_CHECKOUT_RESULT); if(NOT GIT_CHECKOUT_RESULT EQUAL ""0""); message(FATAL_ERROR ""git checkout ${ITTAPI_GIT_TAG} failed with ${GIT_CHECKOUT_RESULT}, please checkout ${ITTAPI_GIT_TAG} at ${ITTAPI_SOURCE_DIR}/ittapi""); endif(). include_directories( ${ITTAPI_SOURCE_DIR}/ittapi/include/ ). if( HAVE_LIBDL ); set(LLVM_INTEL_JIT_LIBS ${CMAKE_DL_LIBS}); endif(). set(LLVM_INTEL_JIT_LIBS ${LLVM_PTHREAD_LIB} ${LLVM_INTEL_JIT_LIBS}). add_llvm_component_library(LLVMIntelJITEvents; IntelJITEventListener.cpp; jitprofiling.c; ${ITTAPI_SOURCE_DIR}/ittapi/src/ittnotify/ittnotify_static.c. LINK_LIBS ${LLVM_INTEL_JIT_LIBS}. LINK_COMPONENTS; CodeGen; Core; DebugInfoDWARF; Support; Object; ExecutionEngine; ). add_dependencies(LLVMIntelJITEvents LLVMCodeGen); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/CMakeLists.txt:557,message,message,557,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/CMakeLists.txt,4,['message'],['message']
Integrability,include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../). add_llvm_component_library(LLVMDXILBitWriter; DXILBitcodeWriter.cpp; DXILValueEnumerator.cpp; DXILWriterPass.cpp. DEPENDS; intrinsics_gen. LINK_COMPONENTS; Analysis; BitWriter; Core; DirectXPointerTypeAnalysis; MC; Object; Support; TargetParser; TransformUtils; ); ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/CMakeLists.txt:168,DEPEND,DEPENDS,168,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/CMakeLists.txt,1,['DEPEND'],['DEPENDS']
Integrability,include_directories(; ${LLVM_MAIN_SRC_DIR}/lib/Target/AArch64; ${LLVM_BINARY_DIR}/lib/Target/AArch64; ). set(LLVM_LINK_COMPONENTS; AArch64; CodeGenTypes; Core; Exegesis; MC; Support; ). add_llvm_library(LLVMExegesisAArch64; DISABLE_LLVM_LINK_LLVM_DYLIB; STATIC; Target.cpp. DEPENDS; intrinsics_gen; AArch64CommonTableGen; ); ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/AArch64/CMakeLists.txt:274,DEPEND,DEPENDS,274,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/AArch64/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/AArch64/CMakeLists.txt,1,['DEPEND'],['DEPENDS']
Integrability,include_directories(; ${LLVM_MAIN_SRC_DIR}/lib/Target/Mips; ${LLVM_BINARY_DIR}/lib/Target/Mips; ). set(LLVM_LINK_COMPONENTS; CodeGenTypes; Core; Exegesis; MC; Mips; Support; TargetParser; ). add_llvm_library(LLVMExegesisMips; DISABLE_LLVM_LINK_LLVM_DYLIB; STATIC; Target.cpp. DEPENDS; intrinsics_gen; MipsCommonTableGen; ); ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Mips/CMakeLists.txt:276,DEPEND,DEPENDS,276,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Mips/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Mips/CMakeLists.txt,1,['DEPEND'],['DEPENDS']
Integrability,include_directories(; ${LLVM_MAIN_SRC_DIR}/lib/Target/PowerPC; ${LLVM_BINARY_DIR}/lib/Target/PowerPC; ). set(LLVM_LINK_COMPONENTS; CodeGenTypes; Core; Exegesis; MC; PowerPC; Support; TargetParser; ). add_llvm_library(LLVMExegesisPowerPC; DISABLE_LLVM_LINK_LLVM_DYLIB; STATIC; Target.cpp. DEPENDS; intrinsics_gen; PowerPCCommonTableGen; ); ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PowerPC/CMakeLists.txt:288,DEPEND,DEPENDS,288,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PowerPC/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PowerPC/CMakeLists.txt,1,['DEPEND'],['DEPENDS']
Integrability,include_directories(; ${LLVM_MAIN_SRC_DIR}/lib/Target/X86; ${LLVM_BINARY_DIR}/lib/Target/X86; ). set(LLVM_LINK_COMPONENTS; CodeGen; CodeGenTypes; Core; Exegesis; MC; Support; TargetParser; X86; ). add_llvm_library(LLVMExegesisX86; DISABLE_LLVM_LINK_LLVM_DYLIB; STATIC; Target.cpp; X86Counter.cpp. DEPENDS; intrinsics_gen; X86CommonTableGen; ); ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/CMakeLists.txt:297,DEPEND,DEPENDS,297,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/CMakeLists.txt,1,['DEPEND'],['DEPENDS']
Integrability,"include`` a; system header. Care has been taken to remove all such ``#includes`` from LLVM; while ``lib/Support`` was being developed. Specifically this means that header; files like ""``unistd.h``"", ""``windows.h``"", ""``stdio.h``"", and ""``string.h``""; are forbidden to be included by LLVM source code outside the implementation of; ``lib/Support``. To obtain system-dependent functionality, existing interfaces to the system; found in ``include/llvm/Support`` should be used. If an appropriate interface is; not available, it should be added to ``include/llvm/Support`` and implemented in; ``lib/Support`` for all supported platforms. Don't Expose System Headers; ---------------------------. The Support Library must shield LLVM from **all** system headers. To obtain; system level functionality, LLVM source must; ``#include ""llvm/Support/Thing.h""`` and nothing else. This means that; ``Thing.h`` cannot expose any system header files. This protects LLVM from; accidentally using system specific functionality and only allows it via; the ``lib/Support`` interface. Use Standard C Headers; ----------------------. The **standard** C headers (the ones beginning with ""c"") are allowed to be; exposed through the ``lib/Support`` interface. These headers and the things they; declare are considered to be platform agnostic. LLVM source files may include; them directly or obtain their inclusion through ``lib/Support`` interfaces. Use Standard C++ Headers; ------------------------. The **standard** C++ headers from the standard C++ library and standard; template library may be exposed through the ``lib/Support`` interface. These; headers and the things they declare are considered to be platform agnostic.; LLVM source files may include them or obtain their inclusion through; ``lib/Support`` interfaces. High Level Interface; --------------------. The entry points specified in the interface of ``lib/Support`` must be aimed at; completing some reasonably high level task needed by LLVM. We do not wa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:3146,interface,interface,3146,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['interface'],['interface']
Integrability,"ine the matchers for what the next inner node you want to match is.; #. Repeat until the matcher is finished. .. _astmatchers-bind:. Binding nodes in match expressions; ----------------------------------. Matcher expressions allow you to specify which parts of the AST are interesting; for a certain task. Often you will want to then do something with the nodes; that were matched, like building source code transformations. To that end, matchers that match specific AST nodes (so called node matchers); are bindable; for example, ``recordDecl(hasName(""MyClass"")).bind(""id"")`` will; bind the matched ``recordDecl`` node to the string ""``id``"", to be later; retrieved in the `match callback; <https://clang.llvm.org/doxygen/classclang_1_1ast__matchers_1_1MatchFinder_1_1MatchCallback.html>`_. .. FIXME: Introduce link to ASTMatchersTutorial.html; .. FIXME: Introduce link to ASTMatchersCookbook.html. Writing your own matchers; -------------------------. There are multiple different ways to define a matcher, depending on its type; and flexibility. ``VariadicDynCastAllOfMatcher<Base, Derived>``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Those match all nodes of type *Base* if they can be dynamically casted to; *Derived*. The names of those matchers are nouns, which closely resemble; *Derived*. ``VariadicDynCastAllOfMatchers`` are the backbone of the matcher; hierarchy. Most often, your match expression will start with one of them, and; you can :ref:`bind <astmatchers-bind>` the node they represent to ids for later; processing. ``VariadicDynCastAllOfMatchers`` are callable classes that model variadic; template functions in C++03. They take an arbitrary number of; ``Matcher<Derived>`` and return a ``Matcher<Base>``. ``AST_MATCHER_P(Type, Name, ParamType, Param)``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Most matcher definitions use the matcher creation macros. Those define both; the matcher of type ``Matcher<Type>`` itself, and a matcher-creation function; named *Name* ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchers.rst:4252,depend,depending,4252,interpreter/llvm-project/clang/docs/LibASTMatchers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchers.rst,1,['depend'],['depending']
Integrability,"ing ""``+``"". **""objcinstance"" format**. Example:; ``""method %objcinstance0 not found""``; Class:; ``DeclarationName``; Description:; This is a simple formatter that indicates the ``DeclarationName`` corresponds; to an Objective-C instance method selector. As such, it prints the selector; with a leading ""``-``"". **""q"" format**. Example:; ``""candidate found by name lookup is %q0""``; Class:; ``NamedDecl *``; Description:; This formatter indicates that the fully-qualified name of the declaration; should be printed, e.g., ""``std::vector``"" rather than ""``vector``"". **""diff"" format**. Example:; ``""no known conversion %diff{from $ to $|from argument type to parameter type}1,2""``; Class:; ``QualType``; Description:; This formatter takes two ``QualType``\ s and attempts to print a template; difference between the two. If tree printing is off, the text inside the; braces before the pipe is printed, with the formatted text replacing the $.; If tree printing is on, the text after the pipe is printed and a type tree is; printed after the diagnostic message. **""sub"" format**. Example:; Given the following record definition of type ``TextSubstitution``:. .. code-block:: text. def select_ovl_candidate : TextSubstitution<; ""%select{function|constructor}0%select{| template| %2}1"">;. which can be used as. .. code-block:: text. def note_ovl_candidate : Note<; ""candidate %sub{select_ovl_candidate}3,2,1 not viable"">;. and will act as if it was written; ``""candidate %select{function|constructor}3%select{| template| %1}2 not viable""``.; Description:; This format specifier is used to avoid repeating strings verbatim in multiple; diagnostics. The argument to ``%sub`` must name a ``TextSubstitution`` tblgen; record. The substitution must specify all arguments used by the substitution,; and the modifier indexes in the substitution are re-numbered accordingly. The; substituted text must itself be a valid format string before substitution. .. _internals-producing-diag:. Producing the Diagnostic; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:15036,message,message,15036,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['message'],['message']
Integrability,"ing and objects drawing, one can provide number of URL parameters in address string like:. - file - name of the file, which will be automatically open with page loading; - files - array of file names for loading; - json - name of JSON file with stored ROOT object like histogram or canvas; - item - item name to be displayed; - opt - drawing option for the item; - items - array of items name to be displayed; - opts - array of drawing options for the items; - expand - item name(s) to be expanded in the hierarchy browser; - focus - item name to be focused on in the hierarchy browser; - title - set browser title; - dir - list files in directory on http server, see https://github.com/root-project/jsroot/issues/283; - layout - can be 'simple', 'flex', 'tabs', 'gridNxM', 'horizNMK', 'vertNMK'; - browser - layout of the browser 'fix' (default), 'float', 'no' (hidden), 'off' (fully disabled); - nobrowser - do not display file browser (same as browser=no); - float - display floating browser (same as browser=float); - status - configure status line 'no' (default), 'off' (completely disable), 'size'; - inject - name of extra JavaScript to load, see several examples in demo/ subdir; - optimize - drawing optimization 0:off, 1:only large histograms (default), 2:always; - palette - id of default color palette, 51..121 - new ROOT6 palette (default 57); - interactive - enable/disable interactive functions 0 - disable all, 1 - enable all; - noselect - hide file-selection part in the browser (only when file name is specified); - mathjax - use MathJax for latex output; - latex - 'off', 'symbols', 'normal', 'mathjax', 'alwaysmath' control of TLatex processor; - style - name of TStyle object to define global JSROOT style; - toolbar - show canvas tool buttons 'off', 'on' and 'popup', 'left' or 'right' for position, 'vert' for vertical; - divsize - fixed size in pixels for main div element like &dvisize=1500x800; - canvsize - default canvas size in pixels like &canvsize=1200x800; - optstat - ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:2099,inject,inject,2099,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['inject'],['inject']
Integrability,"ing correctly in the past,; so it's not clear if this is something that will be supported going forward. Monorepo Drawbacks; ------------------. * Using the monolithic repository may add overhead for those contributing to a; standalone sub-project, particularly on runtimes like libcxx and compiler-rt; that don't rely on LLVM; currently, a fresh clone of libcxx is only 15MB (vs.; 1GB for the monorepo), and the commit rate of LLVM may cause more frequent; `git push` collisions when upstreaming. Affected contributors may be able to; use the SVN bridge or the single-subproject Git mirrors. However, it's; undecided if these projects will continue to be maintained.; * Using the monolithic repository may add overhead for those *integrating* a; standalone sub-project, even if they aren't contributing to it, due to the; same disk space concern as the point above. The availability of the; sub-project Git mirrors would addresses this.; * Preservation of the existing read/write SVN-based workflows relies on the; GitHub SVN bridge, which is an extra dependency. Maintaining this locks us; into GitHub and could restrict future workflow changes. Workflows; ^^^^^^^^^. * :ref:`Checkout/Clone a Single Project, without Commit Access <workflow-checkout-commit>`.; * :ref:`Checkout/Clone Multiple Projects, with Commit Access <workflow-monocheckout-multicommit>`.; * :ref:`Commit an API Change in LLVM and Update the Sub-projects <workflow-cross-repo-commit>`.; * :ref:`Branching/Stashing/Updating for Local Development or Experiments <workflow-mono-branching>`.; * :ref:`Bisecting <workflow-mono-bisecting>`. Workflow Before/After; =====================. This section goes through a few examples of workflows, intended to illustrate; how end-users or developers would interact with the repository for; various use-cases. .. _workflow-checkout-commit:. Checkout/Clone a Single Project, with Commit Access; ---------------------------------------------------. Currently; ^^^^^^^^^. ::. # direct SVN check",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:11947,bridg,bridge,11947,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,2,"['bridg', 'depend']","['bridge', 'dependency']"
Integrability,"ing different; categories of editable objects](pictures/020001EB.jpg); ![Accessing/creating different categories of editable; objects](pictures/020001EC.jpg) ![Accessing/creating different; categories of editable objects](pictures/020001ED.jpg); ![Accessing/creating different categories of editable; objects](pictures/020001EE.jpg). The second use case applies when starting to edit an existing geometry.; Supposing the geometry was loaded into memory, besides the first method; that still applies one can also edit drawn geometry objects. For this,; the menu entry View/Editor of the canvas containing for instance a drawn; volume must be activated. For starting the volume editor one can click; on a volume. The GUI of the **`TGeoManager`** class can be started by; clicking on the top-right `40x40` pixels corner of the pad with a drawn; geometry. This is the main entry point for editing the geometry or creating new; objects. Once the interface is created (using one of the methods; described above), several categories can be accessed via a shutter GUI; widget:. - *General.* This allows changing the name/title of the geometry,; setting the top volume, closing the geometry and saving the geometry; in a file. The file name is formed by `geometry_name.C` or `.root`; depending if the geometry need to be saved as a `C` macro or a; `.root` file.; - *Shapes.* The category provides buttons for creation of all; supported shapes. The new shape name is chosen by the interface, but; can be changed from the shape editor GUI. Existing shapes can be; browsed and edited from the same category.; - *Volumes.* The category allows the creation of a new volume having a; given name, shape and medium. For creating a volume assembly only; the name is relevant. Existing volumes can be browsed or edited from; this category.; - *Materials.* Allows creation of new materials/mixtures or editing; existing ones.; - *Media.* The same for creation/editing of tracking media (materials; having a set of proper",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:167714,interface,interface,167714,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['interface'],['interface']
Integrability,"ing if the geometry need to be saved as a `C` macro or a; `.root` file.; - *Shapes.* The category provides buttons for creation of all; supported shapes. The new shape name is chosen by the interface, but; can be changed from the shape editor GUI. Existing shapes can be; browsed and edited from the same category.; - *Volumes.* The category allows the creation of a new volume having a; given name, shape and medium. For creating a volume assembly only; the name is relevant. Existing volumes can be browsed or edited from; this category.; - *Materials.* Allows creation of new materials/mixtures or editing; existing ones.; - *Media.* The same for creation/editing of tracking media (materials; having a set of properties related to tracking); - *Matrices.* Allows creation of translations, rotations or combined; transformations. Existing matrices can also be browser/edited. ### Editing Existing Objects. For editing an existing object from one of the categories described; above, the interface imposes first a selection among all objects of the; corresponding type stored in the geometry. This can be done by clicking; the button next to the blue label *Select \<object\>*. The dialog; interfaces are generally different for different types of objects. The; volume selection dialog offers the possibility to select either a volume; already connected to the geometry hierarchy or non-connected ones.; Selection for shapes and matrices is split into categories represented; by top-level list tree items for: boxes, tubes, translations, rotations,; etc. ![Selection dialogs for different TGeo objects](pictures/030001EF.png). Once a selection is made and the dialog is closed, the selected item; name will appear in the corresponding label and the button Edit will; start the object editor in a transient frame. Closing these transient; frames will not delete, but just hide existing opened editors for later; reuse. Their lifetime is determined by the canvas to which the manager; editor is attache",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:169043,interface,interface,169043,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['interface'],['interface']
Integrability,"ing initial patches can help with; discussions on an RFC. Code-Review Workflow; ====================. Code review can be an iterative process, which continues until the patch is; ready to be committed. Specifically, once a patch is sent out for review, it; needs an explicit approval before it is committed. Do not assume silent; approval, or solicit objections to a patch with a deadline. Acknowledge All Reviewer Feedback; ---------------------------------. All comments by reviewers should be acknowledged by the patch author. It is; generally expected that suggested changes will be incorporated into a future; revision of the patch unless the author and/or other reviewers can articulate a; good reason to do otherwise (and then the reviewers must agree). If a new patch; does not address all outstanding feedback, the author should explicitly state; that when providing the updated patch. When using the web-based code-review; tool, such notes can be provided in the ""Diff"" description (which is different; from the description of the ""Differential Revision"" as a whole used for the; commit message). If you suggest changes in a code review, but don't wish the suggestion to be; interpreted this strongly, please state so explicitly. Aim to Make Efficient Use of Everyone's Time; --------------------------------------------. Aim to limit the number of iterations in the review process. For example, when; suggesting a change, if you want the author to make a similar set of changes at; other places in the code, please explain the requested set of changes so that; the author can make all of the changes at once. If a patch will require; multiple steps prior to approval (e.g., splitting, refactoring, posting data; from specific performance tests), please explain as many of these up front as; possible. This allows the patch author and reviewers to make the most efficient; use of their time. LGTM - How a Patch Is Accepted; ------------------------------. A patch is approved to be committe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst:5597,message,message,5597,interpreter/llvm-project/llvm/docs/CodeReview.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst,1,['message'],['message']
Integrability,"ing of C++ code into Numba traces, for further; expected speedups. Why Numba?; ----------. The advertised premise of Numba is that it ""makes Python code fast.""; However, there is a much more compelling reason: Numba allows developers to; stay in their chosen ecosystem, be it Python or C++, in mixed environments,; without paying for their choice in lost performance.; For example, a Python developer using Numba does not need to rewrite a kernel; into C++ just to run performantly in a C++ framework.; Similarly, a C++ developer can use Numba to compile and create function; pointers to Python code for easy, performant, access.; This becomes even more compelling if the deployment target is a GPU, which; would otherwise certainly require a rewrite of the Python code.; Add that Numba, as a JIT-compiler, is fully run-time just like ``cppyy``,; and the use case for integration is clear.; (Numba does not currently provide support for C++.). Usage; -------. ``cppyy`` does not use Numba extension hooks to minimize accidental; dependencies.; Instead, it requires that the extensions are loaded explicitly by any code; that uses it::. import cppyy.numba_ext. After that, Numba is able to trace ``cppyy`` bound code when applying the; usual ``numba.njit`` decorator. Numba type declarations are done lazily, with the ``numba_ext`` module only; initially registering hooks on proxy base classes, to keep overheads in; Numba's type-resolution to a minimum.; On use in a JITed trace, each C++ type or function call is refined to the; actual, concrete types and type-specific overloads, with templates; instantiated as-needed.; Where possible, lowering is kept generic to reduce the number of callbacks; in Numba's compilation chain. Examples; --------. The following, non-exhaustive, set of examples gives an idea of the; current level of support.; More examples can be found in the `test suite`_. C++ free (global) functions can be called and overloads will be selected, or; a template will be instantia",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/numba.rst:2319,depend,dependencies,2319,bindings/pyroot/cppyy/cppyy/doc/source/numba.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/numba.rst,1,['depend'],['dependencies']
Integrability,"ing of other preprocessor directives. The; output of this stage is typically called a "".i"" (for C), "".ii"" (for C++),; "".mi"" (for Objective-C), or "".mii"" (for Objective-C++) file. Parsing and Semantic Analysis; This stage parses the input file, translating preprocessor tokens into a; parse tree. Once in the form of a parse tree, it applies semantic; analysis to compute types for expressions as well and determine whether; the code is well formed. This stage is responsible for generating most of; the compiler warnings as well as parse errors. The output of this stage is; an ""Abstract Syntax Tree"" (AST). Code Generation and Optimization; This stage translates an AST into low-level intermediate code (known as; ""LLVM IR"") and ultimately to machine code. This phase is responsible for; optimizing the generated code and handling target-specific code generation.; The output of this stage is typically called a "".s"" file or ""assembly"" file. Clang also supports the use of an integrated assembler, in which the code; generator produces object files directly. This avoids the overhead of; generating the "".s"" file and of calling the target assembler. Assembler; This stage runs the target assembler to translate the output of the; compiler into a target object file. The output of this stage is typically; called a "".o"" file or ""object"" file. Linker; This stage runs the target linker to merge multiple object files into an; executable or dynamic library. The output of this stage is typically called; an ""a.out"", "".dylib"" or "".so"" file. :program:`Clang Static Analyzer`. The Clang Static Analyzer is a tool that scans source code to try to find bugs; through code analysis. This tool uses many parts of Clang and is built into; the same driver. Please see <https://clang-analyzer.llvm.org> for more details; on how to use the static analyzer. OPTIONS; -------. Stage Selection Options; ~~~~~~~~~~~~~~~~~~~~~~~. .. option:: -E. Run the preprocessor stage. .. option:: -fsyntax-only. Run the preprocess",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:1948,integrat,integrated,1948,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,1,['integrat'],['integrated']
Integrability,"ing slot where the workload is executed; - Add `DefineSlotEntry`, a `Define` transformation that is aware of the multi-threading slot and of the current entry number; - Add `GetColumnsNames`: users can now get the names of the available columns coming from trees, data sources or `Define`d columns; - Add `OnPartialResult` and `OnPartialResultSlot`: users can now register one or more functions to be executed on partial results of TDF actions during the event loop.; This mechanism is meant to be used to inspect partial results of the analysis or print useful debug information.; For example, both in single- and multi-thread event loops, one can draw a result histogram and update the canvas every 100 entries like this:; ```c++; auto h = tdf.Histo1D(""x"");; TCanvas c(""c"",""x hist"");; h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); h_.Draw(); c.Update(); });; ```; See the tutorials for more examples.; - Add `Sum`, an action that sums all values of a column for the processed entries; - The new TDataSource interface allows developers to pipe any kind of columnar data format into TDataFrame. Two example data sources have been provided: the TRootDS and the TTrivialDS. The former allows to read via the novel data source mechanism ROOT data, while the latter is a simple generator, created for testing and didactic purposes. It is therefore now possible to interface *any* kind of dataset/data format to ROOT as long as an adaptor which implements the pure virtual methods of the TDataSource interface can be written in C++.; - TDF can now read CSV files through a specialized TDataSource. Just create the TDF with `MakeCsvDataFrame(""f.csv"")`. Just create the TDF with MakeCsvDataFrame(""f.csv""). The data types of the CSV columns are automatically inferred. You can also specify if you want to use a different delimiter or if your file does not have headers.; - Users can now configure Snapshot to use different file open modes (""RECREATE"" or ""UPDATE""), compression level, compression algorithm,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:12428,interface,interface,12428,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,1,['interface'],['interface']
Integrability,"ing the block ID we are describing, *not* the ``BLOCKINFO`` block; itself. The abbreviations defined in ``BLOCKINFO`` blocks receive abbreviation; IDs as described in `DEFINE_ABBREV`_. The ``BLOCKNAME`` record (code 2) can optionally occur in this block. The; elements of the record are the bytes of the string name of the block.; llvm-bcanalyzer can use this to dump out bitcode files symbolically. The ``SETRECORDNAME`` record (code 3) can also optionally occur in this block.; The first operand value is a record ID number, and the rest of the elements of; the record are the bytes for the string name of the record. llvm-bcanalyzer can; use this to dump out bitcode files symbolically. Note that although the data in ``BLOCKINFO`` blocks is described as ""metadata,""; the abbreviations they contain are essential for parsing records from the; corresponding blocks. It is not safe to skip them. .. _wrapper:. Bitcode Wrapper Format; ======================. Bitcode files for LLVM IR may optionally be wrapped in a simple wrapper; structure. This structure contains a simple header that indicates the offset; and size of the embedded BC file. This allows additional information to be; stored alongside the BC file. The structure of this file header is:. :raw-html:`<tt><blockquote>`; [Magic\ :sub:`32`, Version\ :sub:`32`, Offset\ :sub:`32`, Size\ :sub:`32`, CPUType\ :sub:`32`]; :raw-html:`</blockquote></tt>`. Each of the fields are 32-bit fields stored in little endian form (as with the; rest of the bitcode file fields). The Magic number is always ``0x0B17C0DE`` and; the version is currently always ``0``. The Offset field is the offset in bytes; to the start of the bitcode stream in the file, and the Size field is the size; in bytes of the stream. CPUType is a target-specific value that can be used to; encode the CPU of the target. .. _native object file:. Native Object File Wrapper Format; =================================. Bitcode files for LLVM IR may also be wrapped in a native obj",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst:18034,wrap,wrapped,18034,interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,2,['wrap'],"['wrapped', 'wrapper']"
Integrability,"ing the libraries using standalone builds. This assumes; that we are building libunwind and ibc++ as DLLs and statically linking libc++abi into; libc++. Other build configurations are possible, but they are not discussed here. Common CMake configuration options:; -----------------------------------. * ``-D_LIBCPP_ABI_FORCE_ITANIUM'``. Tell the libc++ headers that the Itanium C++ ABI is being used. * ``-DCMAKE_C_FLAGS=""-lmsvcrt -llegacy_stdio_definitions -D_NO_CRT_STDIO_INLINE""``. Supply CRT definitions including stdio definitions that have been removed from the MS VS CRT.; We don't want the stdio functions declared inline as they will cause multiple definition; errors when the same symbols are pulled in from legacy_stdio_definitions.ib. * ``-DCMAKE_INSTALL_PREFIX=<install path>``. Where to install the library and headers. Building libunwind:; -------------------. * ``-DLIBUNWIND_ENABLE_SHARED=ON``; * ``-DLIBUNWIND_ENABLE_STATIC=OFF``. libunwind can be built as a DLL. It is not dependent on other projects. * ``-DLIBUNWIND_USE_COMPILER_RT=OFF``. We use the MS runtime. The CMake files will need to be edited to prevent them adding GNU specific libraries to the link line. Building libc++abi:; -------------------. * ``-DLIBCXXABI_ENABLE_SHARED=OFF``; * ``-DLIBCXXABI_ENABLE_STATIC=ON``; * ``-DLIBCXX_ENABLE_SHARED=ON'``; * ``-DLIBCXX_ENABLE_STATIC_ABI_LIBRARY=ON``. To break the symbol dependency between libc++abi and libc++ we; build libc++abi as a static library and then statically link it; into the libc++ DLL. This necessitates setting the CMake file; to ensure that the visibility macros (which expand to dllexport/import); are expanded as they will be needed when creating the final libc++; DLL later, see: https://reviews.llvm.org/D90021. * ``-DLIBCXXABI_LIBCXX_INCLUDES=<path to libcxx>/include``. Where to find the libc++ headers. Building libc++:; ----------------. * ``-DLIBCXX_ENABLE_SHARED=ON``; * ``-DLIBCXX_ENABLE_STATIC=OFF``. We build libc++ as a DLL and statically li",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToBuildWindowsItaniumPrograms.rst:4838,depend,dependent,4838,interpreter/llvm-project/llvm/docs/HowToBuildWindowsItaniumPrograms.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToBuildWindowsItaniumPrograms.rst,1,['depend'],['dependent']
Integrability,"ing values not to be believed, and `APPROXIMATE ERROR` means; that they have been calculated but there is reason to believe that; they may not be accurate. If no mitigating adjective is given, then at least `Minuit` believes; the errors are accurate, although there is always a small chance that; `Minuit` has been fooled. Some visible signs that `Minuit` may have; been fooled:. - Warning messages produced during the minimization or error; analysis. - Failure to find new minimum. - Value of EDM too big (estimated Distance to Minimum). - Correlation coefficients exactly equal to zero, unless some; parameters are known to be uncorrelated with the others. - Correlation coefficients very close to one (greater than 0.99).; This indicates both an exceptionally difficult problem, and one; which has been badly parameterized so that individual errors are; not very meaningful because they are so highly correlated. - Parameter at limit. This condition, signaled by a `Minuit` warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ‘Getting the right parameter; errors with limits'. The best way to be absolutely sure of the errors is to use; ''independent'' calculations and compare them, or compare the; calculated errors with a picture of the function. Theoretically, the; covariance matrix for a ''physical'' function must be; positive-definite at the minimum, although it may not be so for all; points far away from the minimum, even for a well-determined physical; problem. Therefore, if `MIGRAD` reports that it has found a; non-positive-definite covariance matrix, this may be a sign of one or; more of the following:. #### A Non-physical Region. On its way to the minimum, `MIGRAD` may have traversed a region that; has unphysical behavior, which is of course not a serious problem as; long as it recovers and leaves such a region. #### An Underdetermined Problem. If the matrix is not positive-definite even at the minimum, this may;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:62060,message,message,62060,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['message'],['message']
Integrability,"ing(42).size() // .size() is a resolved MemberExpr. Whether or not the ``RecoveryExpr`` has a dependent type, it is always; considered value-dependent, because its value isn't well-defined until the error; is resolved. Among other things, this means that clang doesn't emit more errors; where a RecoveryExpr is used as a constant (e.g. array size), but also won't try; to evaluate it. ContainsErrors bit; ^^^^^^^^^^^^^^^^^^. Beyond the template dependence bits, we add a new “ContainsErrors” bit to; express “Does this expression or anything within it contain errors” semantic,; this bit is always set for RecoveryExpr, and propagated to other related nodes.; This provides a fast way to query whether any (recursive) child of an expression; had an error, which is often used to improve diagnostics. .. code-block:: C++. // C++; void recoveryExpr(int abc) {; unknownFunction(); // type-dependent, value-dependent, contains-errors. std::string(42).size(); // value-dependent, contains-errors,; // not type-dependent, as we know the type is std::string; }. .. code-block:: C. // C; void recoveryExpr(int abc) {; unknownVar + abc; // type-dependent, value-dependent, contains-errors; }. The ASTImporter; ---------------. The ``ASTImporter`` class imports nodes of an ``ASTContext`` into another; ``ASTContext``. Please refer to the document :doc:`ASTImporter: Merging Clang; ASTs <LibASTImporter>` for an introduction. And please read through the; high-level `description of the import algorithm; <LibASTImporter.html#algorithm-of-the-import>`_, this is essential for; understanding further implementation details of the importer. .. _templated:. Abstract Syntax Graph; ^^^^^^^^^^^^^^^^^^^^^. Despite the name, the Clang AST is not a tree. It is a directed graph with; cycles. One example of a cycle is the connection between a; ``ClassTemplateDecl`` and its ""templated"" ``CXXRecordDecl``. The *templated*; ``CXXRecordDecl`` represents all the fields and methods inside the class; template, while the ``C",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:89676,depend,dependent,89676,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,2,['depend'],['dependent']
Integrability,"ing. For example, the user can; have. .. code-block:: c. __attribute__((weak)) int __llvm_profile_dump(void);. // Then later in the same source file; if (__llvm_profile_dump); if (__llvm_profile_dump() != 0) { ... }; // The first if condition tests if the symbol is actually defined.; // Profile dumping only happens if the symbol is defined. Hence,; // the user program works correctly during normal (not profile-generate); // executions. Alternatively, the user program can include the header; ``profile/instr_prof_interface.h``, which contains the API names. For example,. .. code-block:: c. #include ""profile/instr_prof_interface.h"". // Then later in the same source file; if (__llvm_profile_dump() != 0) { ... }. The user code does not need to check if the API names are defined, because; these names are automatically replaced by ``(0)`` or the equivalence of noop; if the ``clang`` is not compiling for profile generation. Such replacement can happen because ``clang`` adds one of two macros depending; on the ``-fprofile-generate`` and the ``-fprofile-use`` flags. * ``__LLVM_INSTR_PROFILE_GENERATE``: defined when one of; ``-fprofile[-instr]-generate``/``-fcs-profile-generate`` is in effect.; * ``__LLVM_INSTR_PROFILE_USE``: defined when one of; ``-fprofile-use``/``-fprofile-instr-use`` is in effect. The two macros can be used to provide more flexibiilty so a user program; can execute code specifically intended for profile generate or profile use.; For example, a user program can have special logging during profile generate:. .. code-block:: c. #if __LLVM_INSTR_PROFILE_GENERATE; expensive_logging_of_full_program_state();; #endif. The logging is automatically excluded during a normal build of the program,; hence it does not impact performance during a normal execution. It is advised to use such fine tuning only in a program's cold regions. The weak; symbols can introduce extra control flow (the ``if`` checks), while the macros; (hence declarations they guard in ``profile/instr_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:113637,depend,depending,113637,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['depend'],['depending']
Integrability,"ingle elements can be defined by their atomic mass; (`A`), charge (`Z`) and density (`rh`o). One can also create a material; by specifying the element that it is made of. Optionally the radiation; and absorption lengths can be also provided; otherwise they can be; computed on-demand [`G3`]. The class representing them is; **`TGeoMaterial`**:. ``` {.cpp}; TGeoMaterial(const char *name,Double_t a,Double_t z,; Double_t density, Double_t radlen=0,Double_t intlen=0);; TGeoMaterial(const char *name, TGeoElement *elem,; Double_t density);; TGeoMaterial(const char* name, Double_t a, Double_t z,; Double_t rho,; TGeoMaterial::EGeoMaterialState state,; Double_t temperature = STP_temperature,; Double_t pressure = STP_pressure); ```. Any material or derived class is automatically indexed after creation.; The assigned index is corresponding to the last entry in the list of; materials owned by **`TGeoManager`** class. This can be changed using; the **`TGeoMaterial`**`::SetIndex()` method, however it is not; recommended while using the geometry package interfaced with a transport; MC. Radiation and absorption lengths can be set using:. ``` {.cpp}; TGeoMaterial::SetRadLen(Double_t radlen, Double_t intlen);; ```. - `radlen:` radiation length. If `radlen<=0` the value is computed; using GSMATE algorithm in GEANT3; - `intlen:` absorption length. Material state, temperature and pressure can be changed via setters.; Another material property is transparency. It can be defined and used; while viewing the geometry with OpenGL. ``` {.cpp}; void SetTransparency (Char_t transparency = 0); ```. - `transparency:` between 0 (opaque default) to 100 (fully; transparent). One can attach to a material a user-defined object storing Cerenkov; properties. Another hook for material shading properties is currently; not in use. Mixtures are materials made of several elements. They are; represented by the class **`TGeoMixture`**, deriving from; **`TGeoMaterial`** and defined by their number of components an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:15134,interface,interfaced,15134,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['interface'],['interfaced']
Integrability,"ingle function. Defining total ordering among the functions set allows us to organize; functions into a binary tree. The lookup procedure complexity would be; estimated as O(log(N)) in this case. But how do we define *total-ordering*?. We have to introduce a single rule applicable to every pair of functions, and; following this rule, then evaluate which of them is greater. What kind of rule; could it be? Let's declare it as the ""compare"" method that returns one of 3; possible values:. -1, left is *less* than right,. 0, left and right are *equal*,. 1, left is *greater* than right. Of course it means, that we have to maintain; *strict and non-strict order relation properties*:. * reflexivity (``a <= a``, ``a == a``, ``a >= a``),; * antisymmetry (if ``a <= b`` and ``b <= a`` then ``a == b``),; * transitivity (``a <= b`` and ``b <= c``, then ``a <= c``); * asymmetry (if ``a < b``, then ``a > b`` or ``a == b``). As mentioned before, the comparison routine consists of; ""sub-comparison-routines"", with each of them also consisting of; ""sub-comparison-routines"", and so on. Finally, it ends up with primitive; comparison. Below, we will use the following operations:. #. ``cmpNumbers(number1, number2)`` is a method that returns -1 if left is less; than right; 0, if left and right are equal; and 1 otherwise. #. ``cmpFlags(flag1, flag2)`` is a hypothetical method that compares two flags.; The logic is the same as in ``cmpNumbers``, where ``true`` is 1, and; ``false`` is 0. The rest of the article is based on *MergeFunctions.cpp* source code; (found in *<llvm_dir>/lib/Transforms/IPO/MergeFunctions.cpp*). We would like; to ask reader to keep this file open, so we could use it as a reference; for further explanations. Now, we're ready to proceed to the next chapter and see how it works. Functions comparison; ====================; At first, let's define how exactly we compare complex objects. Complex object comparison (function, basic-block, etc) is mostly based on its; sub-object co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:10326,rout,routine,10326,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,3,['rout'],"['routine', 'routines']"
Integrability,"ings with, other operations; (except image operations) for all address spaces; (except private, or generic that accesses private); provided the other operation's sync scope is:. - ``system``, ``agent`` or ``workgroup`` and; executed by a thread in the same work-group.; - ``wavefront`` and executed by a thread in the; same wavefront. ``wavefront`` Synchronizes with, and participates in modification; and seq_cst total orderings with, other operations; (except image operations) for all address spaces; (except private, or generic that accesses private); provided the other operation's sync scope is:. - ``system``, ``agent``, ``workgroup`` or; ``wavefront`` and executed by a thread in the; same wavefront. ``singlethread`` Only synchronizes with and participates in; modification and seq_cst total orderings with,; other operations (except image operations) running; in the same thread for all address spaces (for; example, in signal handlers). ``one-as`` Same as ``system`` but only synchronizes with other; operations within the same address space. ``agent-one-as`` Same as ``agent`` but only synchronizes with other; operations within the same address space. ``workgroup-one-as`` Same as ``workgroup`` but only synchronizes with; other operations within the same address space. ``wavefront-one-as`` Same as ``wavefront`` but only synchronizes with; other operations within the same address space. ``singlethread-one-as`` Same as ``singlethread`` but only synchronizes with; other operations within the same address space.; ======================= ===================================================. LLVM IR Intrinsics; ------------------. The AMDGPU backend implements the following LLVM IR intrinsics. *This section is WIP.*. .. table:: AMDGPU LLVM IR Intrinsics; :name: amdgpu-llvm-ir-intrinsics-table. ============================================== ==========================================================; LLVM Intrinsic Description; ============================================== ======",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:34737,synchroniz,synchronizes,34737,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['synchroniz'],['synchronizes']
Integrability,"ings; ^^^^^^^^^^^^^^^^^^. Generate a set of bindings from a set of header files. Somewhat like CMake's; add_library(), the output is a compiler target. In addition ancillary files; are also generated to allow a complete set of bindings to be compiled,; packaged and installed::. cppyy_add_bindings(; pkg; pkg_version; author; author_email; [URL url]; [LICENSE license]; [LANGUAGE_STANDARD std]; [LINKDEFS linkdef...]; [IMPORTS pcm...]; [GENERATE_OPTIONS option...]; [COMPILE_OPTIONS option...]; [INCLUDE_DIRS dir...]; [LINK_LIBRARIES library...]; [H_DIRS H_DIRSectory]; H_FILES h_file...). The bindings are based on https://cppyy.readthedocs.io/en/latest/, and can be; used as per the documentation provided via the cppyy.gbl namespace. First add; the directory of the <pkg>.rootmap file to the LD_LIBRARY_PATH environment; variable, then ""import cppyy; from cppyy.gbl import <some-C++-entity>"". Alternatively, use ""import <pkg>"". This convenience wrapper supports; ""discovery"" of the available C++ entities using, for example Python 3's command; line completion support. The bindings are complete with a setup.py, supporting Wheel-based; packaging, and a test.py supporting pytest/nosetest sanity test of the bindings. The bindings are generated/built/packaged using 3 environments:. - One compatible with the header files being bound. This is used to; generate the generic C++ binding code (and some ancillary files) using; a modified C++ compiler. The needed options must be compatible with the; normal build environment of the header files.; - One to compile the generated, generic C++ binding code using a standard; C++ compiler. The resulting library code is ""universal"" in that it is; compatible with both Python2 and Python3.; - One to package the library and ancillary files into standard Python2/3; wheel format. The packaging is done using native Python tooling. +----------------------+---------------------------------------------------------------------------------------------+; |Argume",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst:4517,wrap,wrapper,4517,bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst,1,['wrap'],['wrapper']
Integrability,"ins <ClangPlugins>` allow you to run additional actions on the; AST as part of a compilation. Plugins are dynamic libraries that are loaded at; runtime by the compiler, and they're easy to integrate into your build; environment. Canonical examples of when to use Clang Plugins:. * special lint-style warnings or errors for your project; * creating additional build artifacts from a single compile step. Use Clang Plugins when you...:. * need your tool to rerun if any of the dependencies change; * want your tool to make or break a build; * need full control over the Clang AST. Do not use Clang Plugins when you...:. * want to run tools outside of your build environment; * want full control on how Clang is set up, including mapping of in-memory; virtual files; * need to run over a specific subset of files in your project which is not; necessarily related to any changes which would trigger rebuilds. LibTooling; ----------. :doc:`LibTooling <LibTooling>` is a C++ interface aimed at writing standalone; tools, as well as integrating into services that run clang tools. Canonical; examples of when to use LibTooling:. * a simple syntax checker; * refactoring tools. Use LibTooling when you...:. * want to run tools over a single file, or a specific subset of files,; independently of the build system; * want full control over the Clang AST; * want to share code with Clang Plugins. Do not use LibTooling when you...:. * want to run as part of the build triggered by dependency changes; * want a stable interface so you don't need to change your code when the AST API; changes; * want high level abstractions like cursors and code completion out of the box; * do not want to write your tools in C++. :doc:`Clang tools <ClangTools>` are a collection of specific developer tools; built on top of the LibTooling infrastructure as part of the Clang project.; They are targeted at automating and improving core development activities of; C/C++ developers. Examples of tools we are building or planning ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst:2141,interface,interface,2141,interpreter/llvm-project/clang/docs/Tooling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst,2,"['integrat', 'interface']","['integrating', 'interface']"
Integrability,"insysroot:` is not specified, the `/vctoolsdir:` argument is consulted; as a location to identify where the Visual C++ Tools are located. If; `/vctoolsversion:` is specified, that version is preferred, otherwise, the; highest version detected is used. 2. Consult the environment. - `/external:[VARIABLE]`. This specifies a user identified environment variable which is treated as; a path delimiter (`;`) separated list of paths to map into `-imsvc`; arguments which are treated as `-isystem`. - `INCLUDE` and `EXTERNAL_INCLUDE`. The path delimiter (`;`) separated list of paths will be mapped to; `-imsvc` arguments which are treated as `-isystem`. - `LIB` (indirectly). The linker `link.exe` or `lld-link.exe` will honour the environment; variable `LIB` which is a path delimiter (`;`) set of paths to consult for; the import libraries to use when linking the final target. The following environment variables will be consulted and used to form paths; to validate and load content from as appropriate:. - `VCToolsInstallDir`; - `VCINSTALLDIR`; - `Path`. 3. Consult `ISetupConfiguration` [Windows Only]. Assuming that the toolchain is built with `USE_MSVC_SETUP_API` defined and; is running on Windows, the Visual Studio COM interface `ISetupConfiguration`; will be used to locate the installation of the MSVC toolset. 4. Fallback to the registry [DEPRECATED]. The registry information is used to help locate the installation as a final; fallback. This is only possible for pre-VS2017 installations and is; considered deprecated. Restrictions and Limitations compared to Clang; ----------------------------------------------. Strict Aliasing; ^^^^^^^^^^^^^^^. Strict aliasing (TBAA) is always off by default in clang-cl. Whereas in clang,; strict aliasing is turned on by default for all optimization levels. To enable LLVM optimizations based on strict aliasing rules (e.g., optimizations; based on type of expressions in C/C++), user will need to explicitly pass; `-fstrict-aliasing` to clang-cl.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:196916,interface,interface,196916,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['interface'],['interface']
Integrability,"integerLiteral(equals(2))); 1 + 2 // Match; 2 + 1 // Match; 1 + 1 // No match; 2 + 2 // No match. Matcher<BinaryOperator>hasRHSMatcher<Expr> InnerMatcher; Matches the right hand side of binary operator expressions. Example matches b (matcher = binaryOperator(hasRHS())); a || b. Matcher<BindingDecl>forDecompositionMatcher<ValueDecl> InnerMatcher; Matches the DecompositionDecl the binding belongs to. For example, in:; void foo(); {; int arr[3];; auto &[f, s, t] = arr;. f = 42;; }; The matcher:; bindingDecl(hasName(""f""),; forDecomposition(decompositionDecl()); matches 'f' in 'auto &[f, s, t]'. Matcher<BlockDecl>hasAnyParameterMatcher<ParmVarDecl> InnerMatcher; Matches any parameter of a function or an ObjC method declaration or a; block. Does not match the 'this' parameter of a method. Given; class X { void f(int x, int y, int z) {} };; cxxMethodDecl(hasAnyParameter(hasName(""y""))); matches f(int x, int y, int z) {}; with hasAnyParameter(...); matching int y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end. the matcher objcMethodDecl(hasAnyParameter(hasName(""y""))); matches the declaration of method f with hasParameter; matching y. For blocks, given; b = ^(int y) { printf(""%d"", y) };. the matcher blockDecl(hasAnyParameter(hasName(""y""))); matches the declaration of the block b with hasParameter; matching y. Matcher<BlockDecl>hasParameterunsigned N, Matcher<ParmVarDecl> InnerMatcher; Matches the n'th parameter of a function or an ObjC method; declaration or a block. Given; class X { void f(int x) {} };; cxxMethodDecl(hasParameter(0, hasType(varDecl()))); matches f(int x) {}; with hasParameter(...); matching int x. For ObjectiveC, given; @interface I - (void) f:(int) y; @end. the matcher objcMethodDecl(hasParameter(0, hasName(""y""))); matches the declaration of method f with hasParameter; matching y. Matcher<BlockDecl>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:142522,interface,interface,142522,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['interface'],['interface']
Integrability,"inter**. Additionally, it contains an index into the buffer, which; allows the direct addressing of structured elements. These components appear; in that order, i.e., the descriptor comes first, then the 32-bit offset; followed by the 32-bit index. The bits in the buffer descriptor must meet the following requirements:; the stride is the size of a structured element, the ""add tid"" flag must be 0,; and the swizzle enable bits must be off. **Streamout Registers**; Dedicated registers used by the GS NGG Streamout Instructions. The register; file is modelled as a memory in a distinct address space because it is indexed; by an address-like offset in place of named registers, and because register; accesses affect LGKMcnt. This is an internal address space used only by the; compiler. Do not use this address space for IR pointers. .. _amdgpu-memory-scopes:. Memory Scopes; -------------. This section provides LLVM memory synchronization scopes supported by the AMDGPU; backend memory model when the target triple OS is ``amdhsa`` (see; :ref:`amdgpu-amdhsa-memory-model` and :ref:`amdgpu-target-triples`). The memory model supported is based on the HSA memory model [HSA]_ which is; based in turn on HRF-indirect with scope inclusion [HRF]_. The happens-before; relation is transitive over the synchronizes-with relation independent of scope; and synchronizes-with allows the memory scope instances to be inclusive (see; table :ref:`amdgpu-amdhsa-llvm-sync-scopes-table`). This is different to the OpenCL [OpenCL]_ memory model which does not have scope; inclusion and requires the memory scopes to exactly match. However, this; is conservatively correct for OpenCL. .. table:: AMDHSA LLVM Sync Scopes; :name: amdgpu-amdhsa-llvm-sync-scopes-table. ======================= ===================================================; LLVM Sync Scope Description; ======================= ===================================================; *none* The default: ``system``. Synchronizes with, and participat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:31692,synchroniz,synchronization,31692,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['synchroniz'],['synchronization']
Integrability,"inter`** client). This; is linked with ROOT graphical libraries loaded on demand in order to; control visualization actions. ## Navigation and Tracking. Tracking is the feature allowing the transport of a given particle; knowing its kinematics. A state is determined by any combination of the; position $\vec{r}$ and direction $\vec{n}$ with respect to the world; reference frame. The direction $\vec{n}$ must be a unit vector having as; components the director cosines. The full classification of a given; state will provide the following information: the deepest physical node; containing the position vector, the distance to the closest boundary; along the direction vector, the next physical node after propagating the; current point with this distance and the safety distance to the nearest; boundary. This information allows the propagation of particles inside a; detector geometry by taking into account both geometrical and physical; constraints. We will hereby describe the user interface of **`TGeo`** to access; tracking functionality. This allows either developing a tracker for; simple navigation within a given geometry, either interfacing to an; external tracking engine such as GEANT. Note that the abstract interface; for external trackers can be found in `$ROOTSYS/vmc` folder and it can; be used to run GEANT3, GEANT4 and FLUKA-based simulations (\*) by using; directly a geometry described with ROOT. The interface methods related to tracking are incorporated into; **`TGeoManager`** class and implemented in the navigator class; **`TGeoNavigator`**. In order to be able to start tracking, one has to; define the initial state providing the starting point $\vec{r_0}$; and direction $\vec{n_0}$ .; There are several ways of doing that. ### TGeoNavigator Class. One geometry may have several independent navigators to query to; localize points or compute distances. The geometry manager holds a list; of active navigators accessible via:. ``` {.cpp}; TObjArray *navigators = gGeoMa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:101728,interface,interface,101728,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['interface'],['interface']
Integrability,"into a `ROOT::Math::IParametricGradFunctionMultiDim`.; Example:. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedMultiTF1.h"". int main(); {. TF2 f(""Sin Function"", ""sin(x) + y"",0,3,0,2);. ROOT::Math::WrappedMultiTF1 wf1(f);. double x[] = {1,2};. cout << f(x) << endl;; cout << wf1(x) << endl;. return 0;; }; ```. ## Numerical Integration. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image.; `ROOT::Math::VirtualIntegrator` defines the most basic functionality while the specific behaviours for one or multiple dimensions are implemented in; `ROOT::Math::VirtualIntegratorOneDim` and `ROOT::Math::VirtualIntegratorMultiDim`.; These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set the integration tolerance.; These methods must be implemented in the concrete classes existing for the different integration algorithms.; The user cannot create directly these virtual integrator interfaces. He needs to create the; `ROOT::Math::IntegratorOneDim` class for integrating one-dimensional functions and `ROOT::Math::IntegratorMultiDim` for multi-dimensional functions.; Through the ROOT Plug-In Manager, the user can initialize `ROOT::Math::IntegratorOneDim` or `ROOT::Math::IntegratorMultiDim` with; any of the concrete integration classes without dealing with them directly.; These two classes provide the same interface as in `VirtualIntegratorOneDim` and `VirtualIntegratorMultiDim`, but with the possibility to choose in the constructor,; which method will be used to perform the integration. The method to set the function to be integrated, must be of the function interface type described before.; `ROOT::Math::IBaseFunctionOneDimFunction` is used for `ROOT::Math::IBaseFunctionMultiDim` and; The only difference between the `ROOT::Math::IntegratorOneDim` and `ROOT::Math::IntegratorMultiDim` resides; in the dimensionality of that function and some spe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:48940,integrat,integrator,48940,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,2,"['integrat', 'interface']","['integrator', 'interfaces']"
Integrability,"invoked by; providing an object (called the :arc-term:`receiver`) and a list of formal; arguments interspersed with the selector, like so:. .. code-block:: objc. [receiver foo: fooArg bar: barArg baz: bazArg]. This looks in the dynamic class of the receiver for a method with this name,; then in that class's superclass, etc., until it finds something it can execute.; The receiver ""expression"" may also be the name of a class, in which case the; actual receiver is the class object for that class, or (within method; definitions) it may be ``super``, in which case the lookup algorithm starts; with the static superclass instead of the dynamic class. The actual methods; dynamically found in a class are not those declared in the ``@interface``, but; those defined in a separate ``@implementation`` declaration; however, when; compiling a call, typechecking is done based on the methods declared in the; ``@interface``. Method declarations may also be grouped into :arc-term:`protocols`, which are not; inherently associated with any class, but which classes may claim to follow.; Object pointer types may be qualified with additional protocols that the object; is known to support. :arc-term:`Class extensions` are collections of ivars and methods, designed to; allow a class's ``@interface`` to be split across multiple files; however,; there is still a primary implementation file which must see the; ``@interface``\ s of all class extensions. :arc-term:`Categories` allow; methods (but not ivars) to be declared *post hoc* on an arbitrary class; the; methods in the category's ``@implementation`` will be dynamically added to that; class's method tables which the category is loaded at runtime, replacing those; methods in case of a collision. In the standard environment, objects are allocated on the heap, and their; lifetime is manually managed using a reference count. This is done using two; instance methods which all classes are expected to implement: ``retain``; increases the object's r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:5821,protocol,protocols,5821,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['protocol'],['protocols']
Integrability,"ion & integration of p.d.f.s, construction of cumulative distribution functions.; rf111_numintconfig.C - Configuration and customization of how numeric (partial) integrals. ; ADDITION AND CONVOLUTION. rf201_composite.C - Composite p.d.f with signal and background component; rf202_extendedmlfit.C - Setting up an extended maximum likelihood fit; rf203_ranges.C - Fitting and plotting in sub ranges; rf204_extrangefit.C - Extended maximum likelihood fit with alternate range definition; rf205_compplot.C - Options for plotting components of composite p.d.f.s.; rf206_treevistools.C - Tools for visualization of RooAbsArg expression trees; rf207_comptools.C - Tools and utilities for manipulation of composite objects; rf208_convolution.C - One-dimensional numeric convolution; rf209_anaconv.C - Decay function p.d.fs with optional B physics. ; MULTIDIMENSIONAL MODELS. rf301_composition.C - Multi-dimensional p.d.f.s through composition, e.g. substituting a p.d.f parameter with a function that depends on other observables; rf302_utilfuncs.C - Utility functions classes available for use in tailoring; rf303_conditional.C - Use of tailored p.d.f as conditional p.d.fs.s; rf304_uncorrprod.C - Simple uncorrelated multi-dimensional p.d.f.s; rf305_condcorrprod.C - Multi-dimensional p.d.f.s with conditional p.d.fs in product; rf306_condpereventerrors.C - Complete example with use of conditional p.d.f. with per-event errors; rf307_fullpereventerrors.C -Complete example with use of full p.d.f. with per-event errors; rf308_normintegration2d.C - Examples on normalization of p.d.f.s in more than one dimension; rf309_ndimplot.C - Making 2 and 3 dimensional plots of p.d.f.s and datasets; rf310_sliceplot.C -Projecting p.d.f and data slices in discrete observables; rf311_rangeplot.C -Projecting p.d.f and data ranges in continuous observables; rf312_multirangefit.C - Performing fits in multiple (disjoint) ranges in one or more dimensions; rf313_paramranges.C - Working with parameterized ranges to def",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html:2212,depend,depends,2212,roofit/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html,2,['depend'],['depends']
Integrability,"ion followed by forward/back-substitution. `ROOT v3.10`; is using the slower Gaussian elimination method. The numerical accuracy; of the `CLHEP` routine is poor:. - up to 6x6 the numerical imprecise Cramer multiplication is hard-coded.; For instance, calculating `U=H*H-1`, where `H` is a (5x5) Hilbert; matrix, results in off-diagonal elements of $10^{-7}$ instead of the $10^{-13}$; using an `LU `according to `Crout`. - scaling protection is non-existent and limits are hard-coded, as a; consequence inversion of a Hilbert matrix for `sizes>(12x12)` fails. In; order to gain speed the `CLHEP` algorithm stores its permutation info of; the pivots points in a static array, making multi-threading not; possible. `GSL` uses LU decomposition without the implicit scaling of `Crout`.; Therefore, its accuracy is not as good. For instance a (10x10) Hilbert; matrix has errors 10 times larger than the `LU Crout` result. In; `ROOT v4.0`, the user can choose between the `Invert()` and; `IvertFast()` routines, where the latter is using the Cramer algorithm; for `sizes<7x7`. The speed graph shows the result for `InvertFast()`. 3. `A*x=b` the execution time is measured for solving the linear; equation `A*x=b`. The same factorizations are used as in the matrix; inversion. However, only 1 forward/back-substitution has to be used; instead of msize as in the inversion of (msize x msize) matrix. As a; consequence the same differences are observed but less amplified. CLHEP; shows the same numerical issues as in step the matrix inversion. Since; ROOT3.10 has no dedicated equation solver, the solution is calculated; through `x=A-1*b`. This will be slower and numerically not as stable. 4. $(A^{T}*A)^{-1}*A^{T}$ timing results for calculation of the pseudo inverse; of matrix a. The sequence of operations measures the impact of several; calls to constructors and destructors in the `C++` packages versus a `C`; library like `GSL`. ![Speed comparison between the different matrix packages](pictures/030",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:51717,rout,routines,51717,documentation/users-guide/LinearAlgebra.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md,1,['rout'],['routines']
Integrability,ion for importing data from ROOT TTree and THx histograms; rf402_datahandling.C - Tools for manipulation of (un)binned datasets; rf403_weightedevts.C - Using weights in unbinned datasets; rf404_categories.C - Working with RooCategory objects to describe discrete variables; rf405_realtocatfuncs.C - Demonstration of real-->discrete mapping functions; rf406_cattocatfuncs.C - Demonstration of discrete-->discrete (invertable) functions; rf407_latextables.C - Latex printing of lists and sets of RooArgSets; ; ORGANIZATION AND SIMULTANEOUS FITS. rf501_simultaneouspdf.C - Using simultaneous p.d.f.s to describe simultaneous fits to multiple datasets; rf502_wspacewrite.C - Creating and writing a workspace; rf503_wspaceread.C - Reading and using a workspace; rf504_simwstool.C - Using RooSimWSTool to construct a simultaneous p.d.f that is built of variations of an input p.d.f; rf505_asciicfg.C - Reading and writing ASCII configuration files; rf506_msgservice.C - Tuning and customizing the RooFit message logging facility; rf507_debugtools.C - Using the RooFit memory tracing debug tool; rf508_listsetmanip.C - RooArgSet and RooArgList tools and tricks; ; LIKELIHOOD AND MINIMIZATION. rf601_intminuit.C - Interactive minimization with MINUIT; rf602_chi2fit.C - Setting up a binning chi^2 fit; rf603_multicpu.C - Setting up a multi-core parallelized unbinned maximum likelihood fit; rf604_constraints.C - Fitting with constraints; rf605_profilell.C - Working with the profile likelihood estimator; rf606_nllerrorhandling.C - Understanding and customizing error handling in likelihood evaluations; rf607_fitresult.C - Demonstration of options of the RooFitResult class; ; SPECIAL PDFS. rf701_efficiencyfit.C - Unbinned maximum likelihood fit of an efficiency eff(x) function; rf702_efficiencyfit_2D.C - Unbinned maximum likelihood fit of an efficiency eff(x) function to; rf703_effpdfprod.C - Using a product of an (acceptance) efficiency and a p.d.f as p.d.f.; rf704_amplitudefit.C - Using a p.d.f def,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html:4611,message,message,4611,roofit/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html,2,['message'],['message']
Integrability,"ion level with; the parameter PROOF_MonitorPerPacket .; Improve treatment of the case when temporary files are asked to be; created on a shared file system not containing the sandboxes. This; case, which seems to be a rather common one, should be now fully; supported.; Correctly honour selector abort status settings; TSelector::kAbortProcess and TSelector::kAbortFile.; Improve reporting of the non-processed {files, events} in the final; 'MissingFiles' list.  ; Improved algorithm for TPacketizerUnit to fix issue with non; homogeneous machines.; Improve the way the information about log files is saved in case of; failures. The log paths for these failing now should be now correctly; saved and accessible via TProofLog.; Improve merging of histograms. Just use TH1::Add whne the axis are; equal; much faster than TH1::Merge. Fixes; ; In TDataSetManagerFile::NotifyUpdate fix handling of the case when; the global list file does not exist yet (new dataset directory). Fixes; error messages during editing dataset operations.; Fix issue with machine names consistency when working on a local; machine ('localhost' or 'localhost.localdomain' are mapped to; gSystem->HostName()); solves possible matching problems in the; packetizer.; In TProofServ, fill the ""grand total"" message with more blanks, so; that no remnants of the previous message are visible on the screen.; In the autoconf/bonjour interface, fix issue preventing the correct; port (the protocol one, which may be different from the application; default) being used when registering the service. . In TProofPlayer::AddQueryResult, fix a bug affecting the order in; whihc query results are registered when the start time is within 1; second.; Fix worker name in TSlaveLite.; Fix problem with enabling packages with option 'notOnClient' in; PROOF-Lite .; Make sure the log file is flushed at the end of startup to avoid; spurious log messages on next commands .; In CreateSession(), fix an issue with the validity check for existing; ses",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v530/index.html:5399,message,messages,5399,proof/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v530/index.html,2,['message'],['messages']
Integrability,"ion needed when binding reference to class rvalue; Duplicate of 391. 292; CD3; Deallocation on exception in new before arguments evaluated; Unknown. 293; open; Syntax of explicit instantiation/specialization too permissive; Not resolved. 294; NAD; Can static_cast drop exception specifications?; No. 295; CD1; cv-qualifiers on function types; Clang 3.7. 296; CD1; Can conversion functions be static?; Yes. 297; NAD; Which template does an explicit specialization specialize?; Unknown. 298; CD1; T::x when T is cv-qualified; Clang 3.1. 299; CD1; Conversion on array bound expression in new; Clang 2.8 (C++11 onwards). 300; CD1; References to functions in template argument deduction; Yes. 301; CD1; Syntax for template-name; Clang 3.5. 302; CD1; Value-initialization and generation of default constructor; Clang 3.0. 303; NAD; Integral promotions on bit-fields; N/A. 304; TC1; Value-initialization of a reference; Clang 2.9. 305; CD1; Name lookup in destructor call; No. 306; CD1; Ambiguity by class name injection; Duplicate of 39. 307; NAD; Initialization of a virtual base class subobject; N/A. 308; NAD; Catching exceptions with ambiguous base classes; Clang 3.7. 309; CD1; Linkage of entities whose names are not simply identifiers, in introduction; Duplicate of 485. 310; open; Can function templates differing only in parameter cv-qualifiers be overloaded?; Not resolved. 311; NAD; Using qualified name to reopen nested namespace; Clang 3.0. 312; CD3; “use” of invalid pointer value not defined; Duplicate of 616. 313; dup; Class with single conversion function to integral as array size in new; Duplicate of 299 (C++11 onwards). 314; C++17; template in base class specifier; No. 315; NAD; Is call of static member function through null pointer undefined?; N/A. 316; NAD; Injected-class-name of template used as template template parameter; Superseded by 1004. 317; CD1; Can a function be declared inline after it has been called?; Clang 3.5. 318; CD1; struct A::A should not name the construct",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:20182,inject,injection,20182,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['inject'],['injection']
Integrability,"ion of the CERNLIB algorithm; DGAUSS by Sigfried Kolbig, and it is used by the TF1::Integral method. The second one uses the Gauss Legendre quadrature formula. It is used by the TF1::IntegralFast method.; These classes implement both the same virtual interface as the adaptive integration methods provided by the MathMore library. They can all be created and used easily via the common class ROOT::Math::IntegratorOneDim providing the interfaces for numerical integration.; New template methods have been also included in the common Integration class in order to be able to integrate automatically any C++ callable object. ROOT::Math::RichardsonDerivator implementing numerical derivation using the Richardson's extrapolation formula (use 2 derivative estimates to compute a third, more accurate estimation). This is used by the TD1::Derivative method. ; BrentRootFinder for finding the root of one-dimensional function using the Brent algorithm. The class inherits from a virtual interface, which is also implemented by the MathMore root finder methods. The user can instantiate, via the common ROOT::Math::RootFinder class, all the various root finder algorithms. The BrentRootFinder class is used by TF1::GetX . ; A similar class, BrentMinimizer1D, provides the possibility to find the minimum of one-dimensional functions using the Brent algorithm. This class is used by TF1::GetMinimum or TF1::GetMaximum; Use ROOT convention for all enumeration names defining the type of numerical algorithms (start with k, like kADAPTIVE for the integration type). This affects both MathCore and MathMore.; . In addition we use now the ROOT convention for all enumeration names defining the type of numerical algorithms. The names start with k, like kADAPTIVE for the integration type. This change affects both MathCore and MathMore and it breaks backward compatibility. MathCore Function interfaces; Mathcore provides as well interfaces for the evaluation of mathematical and parametric functions to be used ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:7821,interface,interface,7821,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,2,['interface'],['interface']
Integrability,"ion over the range of the X errors, rather than taking the central value by adding; an Integrate(true) argument to chi2FitTo(); Two new arguments, StoreError(const RooArgSet&) and StoreAsymError(const RooArgSet&); have been added to the RooDataSet constructor to simplify the process of storing the errors; of X and Y variables along with their values in a dataset. The newly added tutorial macro rf609_xychi2fit.C illustrates the use of all this; new functionality. Uniform interface for creation of (profile likelihoods) and chi-squared from p.d.f.s; It is now recommended to use the method RooAbsPdf::createNLL(RooAbsData&,...) to; create a likelihood from a p.d.f and a dataset rather than constructing a RooNLLVar; object directly. This is because part of the likelihood construction functionality such a using; multiple Range()s, or the inclusion for constraint terms are only available through; createNLL(). To promote the consistency of this interface, a similar method RooAbsReal::createChi2(); has been added to construct chi-squared functions of a dataset and a function or p.d.f. Along the same lines, it is recommended to use RooAbsReal::createProfile() rather; than constructing a RooProfileLL object directly as the former will efficiently; recast a profile of a profile into a single profile object. Multivariate Gaussian modeling of parameters estimates from a fit; You can now construct a multivariate Gaussian p.d.f on the parameters of a model that; represents the result of a fit, from any RooFitResult object. RooAbsPdf* paramPdf = fitresult->createHessePdf(RooArgSet(a,b)) ;. The returned object is an instance of the newly added class RooMultiVarGaussian, that can; model correlated Gaussian distributions in an arbitrary number of dimensions, given a; vector of mean values and a covariance matrix. Class RooMultivarGaussian implements analytical; integration as well as analytical partial integrals over the first 31 dimensions (if you have; that many) and implements in effe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:9706,interface,interface,9706,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,2,['interface'],['interface']
Integrability,"ion the rights; > to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; > copies of the Software, and to permit persons to whom the Software is; > furnished to do so, subject to the following conditions:; >; > The above copyright notice and this permission notice shall be included in; > all copies or substantial portions of the Software.; >; > THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; > IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; > FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; > AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; > LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; > OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN; > THE SOFTWARE. zlib License; ------. ### Included only if built with zlib support. https://www.zlib.net/zlib_license.html. > zlib.h -- interface of the 'zlib' general purpose compression library; > version 1.2.11, January 15th, 2017; >; > Copyright (C) 1995-2017 Jean-loup Gailly and Mark Adler; >; > This software is provided 'as-is', without any express or implied; > warranty. In no event will the authors be held liable for any damages; > arising from the use of this software.; >; > Permission is granted to anyone to use this software for any purpose,; > including commercial applications, and to alter it and redistribute it; > freely, subject to the following restrictions:; >; > 1. The origin of this software must not be misrepresented; you must not; > claim that you wrote the original software. If you use this software; > in a product, an acknowledgment in the product documentation would be; > appreciated but is not required.; > 2. Altered source versions must be plainly marked as such, and must not be; > misrepresented as being the original software.; > 3. This notice may not be removed or altered from any source distribution.; >; > Jean-loup Gailly",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/LICENSE.md:9024,interface,interface,9024,net/http/civetweb/LICENSE.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/LICENSE.md,1,['interface'],['interface']
Integrability,"ion with a explicit cast to the wanted function.; - The system works with templates and the template can not resolve the correct type of function because it is overloaded.; - If you pass a function without the explicit cast you will get a very ugly traceback.; - A lot of common standard functions for example from math.h like sin, cos etc.. are overloaded, take care passing it. ~~~{.cxx}; #include<TRInterface.h>. Double_t myfun(Double_t x); {; return 2*cos(x);; }. Int_t myfun(Int_t x); {; return x;; }. void fun(); {; ROOT::R::TRInterface &r=ROOT::R::TRInterface::Instance();; r[""myfund""]<<(Double_t (*)(Double_t))myfun;; r[""myfuni""]<<(Int_t (*)(Int_t))myfun;. r<<""print(myfund(0.0))"";; r<<""print(myfuni(1))"";; }; ~~~. ## Wrapping a class; You can wrap a class and expose it in R environment using only a pair of macrodefinitions and the template class; `ROOT::R::class_<>`; The `ROOTR_EXPOSED_CLASS(Class)` macro allows you to expose the class as a new datatype of R, but it has to be alongside; the `ROOTR_MODULE(Module)` macro which allows you to create an internal R module and make the class wrapping; To do this you must use inside the `ROOTR_MODULE` braces the class `ROOT::R::class_<>` and specify; each constructor, attribute or method that the class to export has.; Then the macrodefinition `LOAD_ROOTR_MODULE(Module)` can load the module and the class in R's environment.; You can find a more clear instruction by looking at a example below in Functor section. ##DataFrames; DataFrame? is a very important datatype in R and in ROOTR we have a class to manipulate; dataframes called TRDataFrame, with a lot of very useful operators overloaded to work with TRDataFrame's objects; in a similar way that in the R environment but from c++ in ROOT.; Example:. Lets to create need data to play with dataframe features. ~~~{.cxx}; ////////////////////////; //creating variables//; ////////////////////////; TVectorD v1(3);; std::vector<Double_t> v2(3);; std::array<Int_t,3> v3{ {1,2,3} };; std",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/r/doc/users-guide/ROOTR_Users_Guide.md:6751,wrap,wrap,6751,bindings/r/doc/users-guide/ROOTR_Users_Guide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/r/doc/users-guide/ROOTR_Users_Guide.md,2,['wrap'],"['wrap', 'wrapping']"
Integrability,"ion). �; We introduced an interface for any tool that can produce a; SamplingDistribution, called TestStatSampler. �The interface is; essentially GetSamplingDistribution(parameterPoint) which returns a; SamplingDistribution based on a given probability density function. �We; foresee a few versions of this tool based on toy Monte Carlo, importance; sampling, Fourier transforms, etc. �The following concrete implementation; of the TestStatSampler interface are currently available. ToyMCSamplerUses a Toy Monte Carlo approach to build the; sampling distribution. �The pdf's generate method to generate is used to; generate toy data, and then the test statistic is evaluated at the; requested parameter point. ; DebuggingSampler Simply returns a uniform distribution; between 0,1. �Useful for debugging. NeymanConstruction and FeldmanCousins; A flexible framework for the Neyman Construction was added in this; release. The NeymanConstruction is a concrete implementation of the; IntervalCalculator interface, but it needs several; additional components�to be specified before use. The design; factorizes the choice of the parameter points to be tested,�the choice of; the test statistic, and the generation of sampling distribution into; separate parts (described above). �Finally, the NeymanConstruction class; is simply in charge of using these parts (strategies) and constructing; the confidence belt and confidence intervals. �The ConfidenceBelt class; is still under development, but the current version works fine for; producing ConfidenceIntervals. �We are also working to make this class; work with parallelization approaches, which is not yet complete.; The FeldmanCousins class is a separate concrete implementation of the; IntervalCalculator interface. �It uses the NeymanConstruction internally,; and�enforces�specific choices of the test statistic and ordering; principle to realize the Unified intervals described by Feldman and; Cousins in their paper�Phys.Rev.D57:3873-3889,1998. In ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:27866,interface,interface,27866,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,2,['interface'],['interface']
Integrability,"ion, ROOT::Math::IParamMultiGradFunction interfaces, where the parameter values are now required for calculating the partial derivatives with respect to the parameters.; This changes the signature of the pure abstract method, DoParameterDerivative(const double *x, const double * p, , which takes also a pointer (type const double *) to the parameters.; In addition, these classes do not inherit anymore from the function gradient interface (ROOT::Math::IGradFunction and ROOT::Math::IMultiGradFunction). They define only the parameter gradient which is needed for fitting and not the coordinate gradient. A derived class, like ROOT::Math::Polynomial, implementing both functionality (coordinate and parameter gradient) inherits then from both interfaces.; . More detailed description of the current MathCore release can be found at this location. MathMore; This new release contains:. Modify and rename the class ROOT::Math::RootFinder to ROOT::Math::GSLRootFinder to distinguish from the main interface class which has been put in the Mathcore library and it can create the GSLRootFinder using the plug-in manager. Furthermore, the class ROOT::Math::GSLRootFinder is not anymore a template class on the algorithm. They type of root-finder algorithm can now be selected via an enumeration; Fixed a bug in the ROOT::Math::GSLNLSMultiFi class.; Changes also in the class for the new enumeration names (all names start with k, like kADAPTIVE for the integration types).; . More detailed description of the current MathMore release can be found at this location. GenVector; The new physics vector classes have been moved out from the MathCore library in a new library, libGenVector. The library contains as well the CINT dictionary including main instantiations for the template classes. For this release the instantiation of some extra methods, in particular of the class ROOT::Math::TRansform3D have been added in the dictionary library.; Due to a CINT limitation, the dictionary for explicit template ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:10427,interface,interface,10427,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,2,['interface'],['interface']
Integrability,"ion,; * a message send, and the declared method either has the; ``cf_returns_not_retained`` attribute or it has neither the; ``cf_returns_retained`` attribute nor a :ref:`selector family; <arc.method-families>` that implies a retained result, or; * :when-revised:`[beginning LLVM 3.6]` :revision:`a load from a` ``const``; :revision:`non-system global variable.`. An expression is :arc-term:`known retained` if it is an rvalue of :ref:`C; retainable pointer type <arc.misc.c-retainable>` and it is:. * a message send, and the declared method either has the; ``cf_returns_retained`` attribute, or it does not have the; ``cf_returns_not_retained`` attribute but it does have a :ref:`selector; family <arc.method-families>` that implies a retained result. Furthermore:. * a comma expression is classified according to its right-hand side,; * a statement expression is classified according to its result expression, if; it has one,; * an lvalue-to-rvalue conversion applied to an Objective-C property lvalue is; classified according to the underlying message send, and; * a conditional operator is classified according to its second and third; operands, if they agree in classification, or else the other if one is known; retain-agnostic. If the cast operand is known retained, the conversion is treated as a; ``__bridge_transfer`` cast. If the cast operand is known unretained or known; retain-agnostic, the conversion is treated as a ``__bridge`` cast. .. admonition:: Rationale. Bridging casts are annoying. Absent the ability to completely automate the; management of CF objects, however, we are left with relatively poor attempts; to reduce the need for a glut of explicit bridges. Hence these rules. We've so far consciously refrained from implicitly turning retained CF; results from function calls into ``__bridge_transfer`` casts. The worry is; that some code patterns --- for example, creating a CF value, assigning it; to an ObjC-typed local, and then calling ``CFRelease`` when done --- are a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:27735,message,message,27735,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['message'],['message']
Integrability,"ion. This rule applies to the set of operating; systems supported for a given class of operating system (e.g. Unix, Win32). No Virtual Methods; ------------------. The Support Library interfaces can be called quite frequently by LLVM. In order; to make those calls as efficient as possible, we discourage the use of virtual; methods. There is no need to use inheritance for implementation differences, it; just adds complexity. The ``#include`` mechanism works just fine. No Exposed Functions; --------------------. Any functions defined by system libraries (i.e. not defined by ``lib/Support``); must not be exposed through the ``lib/Support`` interface, even if the header; file for that function is not exposed. This prevents inadvertent use of system; specific functionality. For example, the ``stat`` system call is notorious for having variations in the; data it provides. ``lib/Support`` must not declare ``stat`` nor allow it to be; declared. Instead it should provide its own interface to discovering; information about files and directories. Those interfaces may be implemented in; terms of ``stat`` but that is strictly an implementation detail. The interface; provided by the Support Library must be implemented on all platforms (even; those without ``stat``). No Exposed Data; ---------------. Any data defined by system libraries (i.e. not defined by ``lib/Support``) must; not be exposed through the ``lib/Support`` interface, even if the header file; for that function is not exposed. As with functions, this prevents inadvertent; use of data that might not exist on all platforms. Minimize Soft Errors; --------------------. Operating system interfaces will generally provide error results for every; little thing that could go wrong. In almost all cases, you can divide these; error results into two groups: normal/good/soft and abnormal/bad/hard. That is,; some of the errors are simply information like ""file not found"", ""insufficient; privileges"", etc. while other errors are much",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:6596,interface,interface,6596,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['interface'],['interface']
Integrability,"ion.; `Kaleidoscope Tutorial for complete beginner; <https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html>`_. - BuildingAJIT: Examples of the `BuildingAJIT tutorial; <https://llvm.org/docs/tutorial/BuildingAJIT1.html>`_ that shows how LLVM’s; ORC JIT APIs interact with other parts of LLVM. It also, teaches how to; recombine them to build a custom JIT that is suited to your use-case. ``llvm/include``; ----------------. Public header files exported from the LLVM library. The three main subdirectories:. ``llvm/include/llvm``. All LLVM-specific header files, and subdirectories for different portions of; LLVM: ``Analysis``, ``CodeGen``, ``Target``, ``Transforms``, etc... ``llvm/include/llvm/Support``. Generic support libraries provided with LLVM but not necessarily specific to; LLVM. For example, some C++ STL utilities and a Command Line option processing; library store header files here. ``llvm/include/llvm/Config``. Header files configured by ``cmake``. They wrap ""standard"" UNIX and; C header files. Source code can include these header files which; automatically take care of the conditional #includes that ``cmake``; generates. ``llvm/lib``; ------------. Most source files are here. By putting code in libraries, LLVM makes it easy to; share code among the `tools`_. ``llvm/lib/IR/``. Core LLVM source files that implement core classes like Instruction and; BasicBlock. ``llvm/lib/AsmParser/``. Source code for the LLVM assembly language parser library. ``llvm/lib/Bitcode/``. Code for reading and writing bitcode. ``llvm/lib/Analysis/``. A variety of program analyses, such as Call Graphs, Induction Variables,; Natural Loop Identification, etc. ``llvm/lib/Transforms/``. IR-to-IR program transformations, such as Aggressive Dead Code Elimination,; Sparse Conditional Constant Propagation, Inlining, Loop Invariant Code Motion,; Dead Global Elimination, and many others. ``llvm/lib/Target/``. Files describing target architectures for code generation. For example,; ``llvm",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:35895,wrap,wrap,35895,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['wrap'],['wrap']
Integrability,"ion.inc.in; ${CMAKE_CURRENT_BINARY_DIR}/include/clang/Basic/Version.inc). # Add appropriate flags for GCC; if (LLVM_COMPILER_IS_GCC_COMPATIBLE); set(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} -fno-common -Woverloaded-virtual""); if (NOT ""${CMAKE_CXX_COMPILER_ID}"" MATCHES ""Clang""); set(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} -fno-strict-aliasing""); endif (). # Enable -pedantic for Clang even if it's not enabled for LLVM.; if (NOT LLVM_ENABLE_PEDANTIC); set(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} -pedantic -Wno-long-long""); endif (). check_cxx_compiler_flag(""-Werror -Wnested-anon-types"" CXX_SUPPORTS_NO_NESTED_ANON_TYPES_FLAG); if( CXX_SUPPORTS_NO_NESTED_ANON_TYPES_FLAG ); set(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} -Wno-nested-anon-types"" ); endif(); endif (). # Determine HOST_LINK_VERSION on Darwin.; set(HOST_LINK_VERSION); if (APPLE AND NOT CMAKE_LINKER MATCHES "".*lld.*""); set(LD_V_OUTPUT); execute_process(; COMMAND sh -c ""${CMAKE_LINKER} -v 2>&1 | head -1""; RESULT_VARIABLE HAD_ERROR; OUTPUT_VARIABLE LD_V_OUTPUT; ); if (HAD_ERROR); message(FATAL_ERROR ""${CMAKE_LINKER} failed with status ${HAD_ERROR}""); endif(); if (""${LD_V_OUTPUT}"" MATCHES "".*ld64-([0-9.]+).*""); string(REGEX REPLACE "".*ld64-([0-9.]+).*"" ""\\1"" HOST_LINK_VERSION ${LD_V_OUTPUT}); elseif (""${LD_V_OUTPUT}"" MATCHES ""[^0-9]*([0-9.]+).*""); string(REGEX REPLACE ""[^0-9]*([0-9.]+).*"" ""\\1"" HOST_LINK_VERSION ${LD_V_OUTPUT}); endif(); message(STATUS ""Host linker version: ${HOST_LINK_VERSION}""); endif(). include(CMakeParseArguments); include(AddClang). set(CMAKE_INCLUDE_CURRENT_DIR ON). include_directories(BEFORE; ${CMAKE_CURRENT_BINARY_DIR}/include; ${CMAKE_CURRENT_SOURCE_DIR}/include; ). if (NOT LLVM_INSTALL_TOOLCHAIN_ONLY); install(DIRECTORY include/clang include/clang-c; DESTINATION ""${CMAKE_INSTALL_INCLUDEDIR}""; COMPONENT clang-headers; FILES_MATCHING; PATTERN ""*.def""; PATTERN ""*.h""; PATTERN ""config.h"" EXCLUDE; ). install(DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/include/clang; DESTINATION ""${CMAKE_INSTALL_INCLUDEDIR}""; COMPONENT cl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:13124,message,message,13124,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,1,['message'],['message']
Integrability,"ion:. .. code-block:: c++. const DataLayout &DL = getDataLayout();; MangleAndInterner Mangle(ES, DL);. auto &JD = ES.createJITDylib(""main"");. JD.define(; absoluteSymbols({; { Mangle(""puts""), ExecutorAddr::fromPtr(&puts)},; { Mangle(""gets""), ExecutorAddr::fromPtr(&getS)}; }));. Using absoluteSymbols is reasonable if the set of symbols to be reflected is; small and fixed. On the other hand, if the set of symbols is large or variable; it may make more sense to have the definitions added for you on demand by a; *definition generator*.A definition generator is an object that can be attached; to a JITDylib, receiving a callback whenever a lookup within that JITDylib fails; to find one or more symbols. The definition generator is given a chance to; produce a definition of the missing symbol(s) before the lookup proceeds. ORC provides the ``DynamicLibrarySearchGenerator`` utility for reflecting symbols; from the process (or a specific dynamic library) for you. For example, to reflect; the whole interface of a runtime library:. .. code-block:: c++. const DataLayout &DL = getDataLayout();; auto &JD = ES.createJITDylib(""main"");. if (auto DLSGOrErr =; DynamicLibrarySearchGenerator::Load(""/path/to/lib""; DL.getGlobalPrefix())); JD.addGenerator(std::move(*DLSGOrErr);; else; return DLSGOrErr.takeError();. // IR added to JD can now link against all symbols exported by the library; // at '/path/to/lib'.; CompileLayer.add(JD, loadModule(...));. The ``DynamicLibrarySearchGenerator`` utility can also be constructed with a; filter function to restrict the set of symbols that may be reflected. For; example, to expose an allowed set of symbols from the main process:. .. code-block:: c++. const DataLayout &DL = getDataLayout();; MangleAndInterner Mangle(ES, DL);. auto &JD = ES.createJITDylib(""main"");. DenseSet<SymbolStringPtr> AllowList({; Mangle(""puts""),; Mangle(""gets""); });. // Use GetForCurrentProcess with a predicate function that checks the; // allowed list.; JD.addGenerator(cantFail(D",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:33115,interface,interface,33115,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['interface'],['interface']
Integrability,"ions can be found in the; :doc:`../TestingGuide`. TEST RUN OUTPUT FORMAT; ~~~~~~~~~~~~~~~~~~~~~~. The :program:`lit` output for a test run conforms to the following schema, in; both short and verbose modes (although in short mode no PASS lines will be; shown). This schema has been chosen to be relatively easy to reliably parse by; a machine (for example in buildbot log scraping), and for other tools to; generate. Each test result is expected to appear on a line that matches:. .. code-block:: none. <result code>: <test name> (<progress info>). where ``<result-code>`` is a standard test result such as PASS, FAIL, XFAIL,; XPASS, UNRESOLVED, or UNSUPPORTED. The performance result codes of IMPROVED and; REGRESSED are also allowed. The ``<test name>`` field can consist of an arbitrary string containing no; newline. The ``<progress info>`` field can be used to report progress information such; as (1/300) or can be empty, but even when empty the parentheses are required. Each test result may include additional (multiline) log information in the; following format:. .. code-block:: none. <log delineator> TEST '(<test name>)' <trailing delineator>; ... log message ...; <log delineator>. where ``<test name>`` should be the name of a preceding reported test, ``<log; delineator>`` is a string of ""*"" characters *at least* four characters long; (the recommended length is 20), and ``<trailing delineator>`` is an arbitrary; (unparsed) string. The following is an example of a test run output which consists of four tests A,; B, C, and D, and a log message for the failing test C:. .. code-block:: none. PASS: A (1 of 4); PASS: B (2 of 4); FAIL: C (3 of 4); ******************** TEST 'C' FAILED ********************; Test 'C' failed as a result of exit code 1.; ********************; PASS: D (4 of 4). LIT EXAMPLE TESTS; ~~~~~~~~~~~~~~~~~. The :program:`lit` distribution contains several example implementations of; test suites in the *ExampleTests* directory. SEE ALSO; --------. valgrind(1); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:23271,message,message,23271,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,2,['message'],['message']
Integrability,"ions of friend function specializations, e.g. ``friend void f<>(int) {}``.; - Clang now diagnoses narrowing conversions involving const references.; (`#63151 <https://github.com/llvm/llvm-project/issues/63151>`_).; - Clang now diagnoses unexpanded packs within the template argument lists of function template specializations.; - The warning `-Wnan-infinity-disabled` is now emitted when ``INFINITY``; or ``NAN`` are used in arithmetic operations or function arguments in; floating-point mode where ``INFINITY`` or ``NAN`` don't have the expected; values. - Clang now diagnoses attempts to bind a bitfield to an NTTP of a reference type as erroneous; converted constant expression and not as a reference to subobject.; - Clang now diagnoses ``auto`` and ``decltype(auto)`` in declarations of conversion function template; (`CWG1878 <https://cplusplus.github.io/CWG/issues/1878.html>`_); - Clang now diagnoses the requirement that non-template friend declarations with requires clauses; and template friend declarations with a constraint that depends on a template parameter from an; enclosing template must be a definition.; - Clang now diagnoses incorrect usage of ``const`` and ``pure`` attributes, so ``-Wignored-attributes`` diagnoses more cases.; - Clang now emits more descriptive diagnostics for 'unusual' expressions (e.g. incomplete index; expressions on matrix types or builtin functions without an argument list) as placement-args; to new-expressions. Before:. .. code-block:: text. error: no matching function for call to 'operator new'; 13 | new (__builtin_memset) S {};; | ^ ~~~~~~~~~~~~~~~~~~. note: candidate function not viable: no known conversion from '<builtin fn type>' to 'int' for 2nd argument; 5 | void* operator new(__SIZE_TYPE__, int);; | ^. After:. .. code-block:: text. error: builtin functions must be directly called; 13 | new (__builtin_memset) S {};; | ^. - Clang now diagnoses import before module declarations but not in global; module fragment.; (`#67627 <https://g",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:31123,depend,depends,31123,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['depend'],['depends']
Integrability,"ions(Function*,; Function*)``. Operation affects ``FnTree`` contents with next way: *F* will stay in; ``FnTree``. *G* being equal to *F* will not be added to ``FnTree``. Calls of; *G* would be replaced with something else. It changes bodies of callers. So,; functions that calls *G* would be put into ``Deferred`` set and removed from; ``FnTree``, and analyzed again. The approach is next:. 1. Most wished case: when we can use alias and both of *F* and *G* are weak. We; make both of them with aliases to the third strong function *H*. Actually *H*; is *F*. See below how it's made (but it's better to look straight into the; source code). Well, this is a case when we can just replace *G* with *F*; everywhere, we use ``replaceAllUsesWith`` operation here (*RAUW*). 2. *F* could not be overridden, while *G* could. It would be good to do the; next: after merging the places where overridable function were used, still use; overridable stub. So try to make *G* alias to *F*, or create overridable tail; call wrapper around *F* and replace *G* with that call. 3. Neither *F* nor *G* could be overridden. We can't use *RAUW*. We can just; change the callers: call *F* instead of *G*. That's what; ``replaceDirectCallers`` does. Below is a detailed body description. If “F” may be overridden; ------------------------; As follows from ``mayBeOverridden`` comments: “whether the definition of this; global may be replaced by something non-equivalent at link time”. If so, that's; ok: we can use alias to *F* instead of *G* or change call instructions itself. HasGlobalAliases, removeUsers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; First consider the case when we have global aliases of one function name to; another. Our purpose is make both of them with aliases to the third strong; function. Though if we keep *F* alive and without major changes we can leave it; in ``FnTree``. Try to combine these two goals. Do stub replacement of *F* itself with an alias to *F*. 1. Create stub function *H*, with the same nam",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:27231,wrap,wrapper,27231,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,1,['wrap'],['wrapper']
Integrability,"ips: false. TBrowser. Automatically switch to the tab containing the current canvas (if any) when e.g. drawing a histogram by double-clicking on its list tree item in a root file.; Automatically switch to (and update) the list of files in the file browser (left panel) when opening a ROOT file from the ""Open File"" menu. TGListView. Keyboard navigation is now fully working in the list view. TGMainFrame. Allow to save a snapshot of the GUI in a picture file. The supported formats are gif, jpg, png, tiff, and xpm. TGFileDialog. Allow to change directory by typing its name in the text entry field of the dialog. TProofProgressDialog. Added a speedometer widget (TGSpeedo) to display the processing rate; Added a check button to enable/disable smooth update of the speedometer (enabled by default). This could be useful in the case of slow displays (e.g. when using it via ssh); Several layout improvements. TRecorder. Improvements and consolidation of the cross-platform interoperability, allowing to record and replay sessions between different platforms with less side effects. NB: Using different OS/WM (Window Managers) and using different ROOT GUI settings (via e.g. system.rootrc) between recording and replaying may still produce a wrong behavior of the recorder.; New tutorial guitest_playback.C replaying a recorded session showing and validating the GUI (using guitest.C). GUI Builder; New features, new user interface; Several important features have been added to the builder, and its user interface has been redesigned.; Editing modes are now clearly distinguished with enabled and disabled layout mode. Possibility to enable automatic layout fasten the interface development, as the positioning doesn't have to be done manually anymore; Major changes in the user interface:. Added a list tree displaying the complete structure of the GUI; The name of every element of the GUI is now editable; New, more intuitive interface for padding and layout hints; Color settings option was added",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v526/index.html:1340,interoperab,interoperability,1340,gui/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v526/index.html,2,['interoperab'],['interoperability']
Integrability,"ipulation library. - `libCling` is the C++ interpreter (Cling). - `libCore` is the Base classes. - `libEG` is the abstract event generator interface classes. - \*`libEGPythia` is the Pythia5 event generator interface. - \*`libEGPythia6` is the Pythia6 event generator interface. - `libFitPanel` contains the GUI used for fitting. - `libGed` contains the GUI used for editing the properties of; histograms, graphs, etc. - `libGeom` is the geometry package (with builder and painter). - `libGpad` is the pad and canvas classes which depend on low level; graphics. - `libGraf` is the 2D graphics primitives (can be used independent; of libGpad). - `libGraf3d` is the 3D graphics primitives. - `libGui` is the GUI classes (depend on low level graphics). - `libGuiBld` is the GUI designer. - `libGuiHtml` contains the embedded HTML browser. - `libGX11` is the low level graphics interface to the X11 system. - \*`libGX11TTF` is an add-on library to libGX11 providing TrueType; fonts. - `libHbook` is for interface ROOT - HBOOK. - `libHist` is the histogram classes (with accompanying painter; library). - `libHtml` is the HTML documentation generation system. - `libMatrix` is the matrix and vector manipulation. - `libMathCore` contains the core mathematics and physics vector; classes. - `libMathMore` contains additional functions, interfacing the GSL; math library. - `libMinuit` is the MINUIT fitter. - `libNet` contains functionality related to network transfer. - `libNew` is the special global new/delete, provides extra memory; checking and interface for shared memory (optional). - `libPhysics` contains the legacy physics classes (TLorentzVector,; etc.). - `libPostscript` is the PostScript interface. - `libProof` is the parallel ROOT Facility classes. - `libPython` provides the interface to Python. - \*`libRFIO` is the interface to CERN RFIO remote I/O system. - \*`libRGL` is the interface to OpenGL. - `libReflex` is the runtime type database library used by Cling. - `libRint` is the int",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:14382,interface,interface,14382,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['interface'],['interface']
Integrability,"ird_party_module""; }; ]; },; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; },; {; ""primary-output"": ""interface_part.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; }; ],; ""version"": 1; }. See the P1689 paper for the meaning of the fields. And if the user want a finer-grained control for any reason, e.g., to scan the generated source files,; the user can choose to get the dependency information per file. For example:. .. code-block:: console. $ clang-scan-deps -format=p1689 -- <path-to-compiler-executable>/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o. And we'll get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part""; }; ]; }; ],; ""version"": 1; }. In this way, we can pass the single command line options after the ``--``.; Then clang-scan-deps will extract the necessary information from the options.; Note that we need to specify the path to the compiler executable instead of saying; ``clang++`` simply. The users may want the scanner to get the transitional dependency information for headers.; Otherwise, the users have to scan twice for the project, once for headers and once for modules.; To address the requirement, clang-scan-deps will recognize the specified preprocessor options; in the given command line and generate the corresponding dependency information. For example,. .. code-block:: console. $ clang-scan-deps -format=p1689 -- ../bin/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o -MD -MT impl_part.ddi -MF impl_part.dep; $ cat impl_part.dep. We will get:. .. code-block:: t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:36525,interface,interface,36525,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['interface'],['interface']
Integrability,"irectives. .. warning::. Setting this option to ``true`` could lead to incorrect code formatting; due to clang-format's lack of complete semantic information. As such,; extra care should be taken to review code changes made by this option. .. code-block:: c++. false: true:. if (isa<FunctionDecl>(D)) vs. if (isa<FunctionDecl>(D)) {; handleFunctionDecl(D); handleFunctionDecl(D);; else if (isa<VarDecl>(D)) } else if (isa<VarDecl>(D)) {; handleVarDecl(D); handleVarDecl(D);; else } else {; return; return;; }. while (i--) vs. while (i--) {; for (auto *A : D.attrs()) for (auto *A : D.attrs()) {; handleAttr(A); handleAttr(A);; }; }. do vs. do {; --i; --i;; while (i); } while (i);. .. _InsertNewlineAtEOF:. **InsertNewlineAtEOF** (``Boolean``) :versionbadge:`clang-format 16` :ref:`¶ <InsertNewlineAtEOF>`; Insert a newline at end of file if missing. .. _InsertTrailingCommas:. **InsertTrailingCommas** (``TrailingCommaStyle``) :versionbadge:`clang-format 11` :ref:`¶ <InsertTrailingCommas>`; If set to ``TCS_Wrapped`` will insert trailing commas in container; literals (arrays and objects) that wrap across multiple lines.; It is currently only available for JavaScript; and disabled by default ``TCS_None``.; ``InsertTrailingCommas`` cannot be used together with ``BinPackArguments``; as inserting the comma disables bin-packing. .. code-block:: c++. TSC_Wrapped:; const someArray = [; aaaaaaaaaaaaaaaaaaaaaaaaaa,; aaaaaaaaaaaaaaaaaaaaaaaaaa,; aaaaaaaaaaaaaaaaaaaaaaaaaa,; // ^ inserted; ]. Possible values:. * ``TCS_None`` (in configuration: ``None``); Do not insert trailing commas. * ``TCS_Wrapped`` (in configuration: ``Wrapped``); Insert trailing commas in container literals that were wrapped over; multiple lines. Note that this is conceptually incompatible with; bin-packing, because the trailing comma is used as an indicator; that a container should be formatted one-per-line (i.e. not bin-packed).; So inserting a trailing comma counteracts bin-packing. .. _IntegerLiteralSeparator:. **I",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:76324,wrap,wrap,76324,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['wrap'],['wrap']
Integrability,"irectory--------; configure_file(${CMAKE_CURRENT_SOURCE_DIR}/CTestCustom.cmake ${CMAKE_CURRENT_BINARY_DIR} COPYONLY). #---Provide a rootlogon.C file in the current build directory that; # will affect the way we run all tutorials.; # This overwrites the existing rootlogon.C and rootalias.C in the; # tutorials directory which is copied to the build area.; #-------------------------------------------------------------------; file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/rootlogon.C ""{; // Needed by ACLiC to use the current directory for scratch area; gSystem->SetBuildDir(\"".\"", kTRUE);; }""); file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/rootalias.C """"); file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/rootlogoff.C ""{}""); file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/.rootrc ""; Proof.Sandbox: /tmp/proof; Rint.History: .root_hist; ACLiC.LinkLibs: 1; ""). #---Tutorials that need substantial network to work------------------; set(need_network dataframe/df027_SQliteDependencyOverVersion.C). #---Tutorials disabled depending on the build components-------------. if(NOT clad); set(clad_veto fit/minuit2GausFit.C; # TODO: the next veto should not be necessary!; # The tutorial should also work without clad.; # See https://github.com/root-project/root/issues/15091.; fit/exampleFit3D.C; ); endif(). if(MSVC AND NOT win_broken_tests); # RBatchGenerator tutorials don't work on Windows at the moment.; list(APPEND dataframe_veto tmva/RBatchGenerator_NumPy.py); list(APPEND dataframe_veto tmva/RBatchGenerator_TensorFlow.py); list(APPEND dataframe_veto tmva/RBatchGenerator_PyTorch.py); list(APPEND dataframe_veto tmva/RBatchGenerator_filters_vectors.py); # df036* and df037* seem to trigger OS errors when trying to delete the; # test files created in the tutorials. It is unclear why.; list(APPEND dataframe_veto dataframe/df036_missingBranches.C); list(APPEND dataframe_veto dataframe/df036_missingBranches.py); list(APPEND dataframe_veto dataframe/df037_TTreeEventMatching.C); list(APPEND dataframe_veto dataframe/df037_TTreeEv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt:2741,depend,depending,2741,tutorials/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt,1,['depend'],['depending']
Integrability,"irement, the :ref:`PassManager; <writing-an-llvm-pass-passmanager>` scans the available passes to see if any; implementations of the analysis group are available. If none is available, the; default implementation is created for the pass to use. All standard rules for; :ref:`interaction between passes <writing-an-llvm-pass-interaction>` still; apply. Although :ref:`Pass Registration <writing-an-llvm-pass-registration>` is; optional for normal passes, all analysis group implementations must be; registered, and must use the :ref:`INITIALIZE_AG_PASS; <writing-an-llvm-pass-RegisterAnalysisGroup>` template to join the; implementation pool. Also, a default implementation of the interface **must**; be registered with :ref:`RegisterAnalysisGroup; <writing-an-llvm-pass-RegisterAnalysisGroup>`. As a concrete example of an Analysis Group in action, consider the; `AliasAnalysis <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`_; analysis group. The default implementation of the alias analysis interface; (the `basic-aa <https://llvm.org/doxygen/structBasicAliasAnalysis.html>`_ pass); just does a few simple checks that don't require significant analysis to; compute (such as: two different globals can never alias each other, etc).; Passes that use the `AliasAnalysis; <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`_ interface (for; example the `gvn <https://llvm.org/doxygen/classllvm_1_1GVN.html>`_ pass), do not; care which implementation of alias analysis is actually provided, they just use; the designated interface. From the user's perspective, commands work just like normal. Issuing the; command ``opt -gvn ...`` will cause the ``basic-aa`` class to be instantiated; and added to the pass sequence. Issuing the command ``opt -somefancyaa -gvn; ...`` will cause the ``gvn`` pass to use the ``somefancyaa`` alias analysis; (which doesn't actually exist, it's just a hypothetical example) instead. .. _writing-an-llvm-pass-RegisterAnalysisGroup:. Using ``RegisterAnaly",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:37191,interface,interface,37191,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['interface'],['interface']
Integrability,"irrelevant, since in both cases; the error matrix will be unreliable and the minimum suspicious. ## Additional trouble–shooting ##. When M just doesn't work, some of the more common causes are:. - **Precision mismatch.** Make sure your $\mbox{FCN}$ uses; internally the same precision as M . If the problem is only one of precision, and not of word length; mismatch, an appropriate MnMachinePrecision::setPrecision() may fix; it. - **Trivial bugs in $\mbox{FCN}$.** The possibilities for bugs are; numerous. Probably the most common among physicists inexperienced in; is the confusion between double and int types, which you can; sometimes get away with, but not always. [^3] M can spot some; trivial bugs itself, and issues a warning when it detects an unusual; $\mbox{FCN}$ behaviour. Such a warning should be taken; seriously. M also offers some tools (especially $\mbox{SCAN}$) which can; help the user to find trivial bugs. - **An ill–posed problem.** For questions of parameter dependence, see; the discussion above on postive–definiteness. Other mathematical; problems which can arise are: **excessive numerical roundoff** — be; especially careful of exponential and factorial functions which get; big very quickly and lose accuracy; **starting too far from the; solution** — the function may have unphysical local minima,; especially at infinity in some variables; **incorrect; normalization** — in likelihood functions, the probability; distributions must be normalized or at least have an integral which; is independent of the values of the variable parameters. - **A bug in M .** This is unlikely, but it happens. If a bug is; suspected, and all other possible causes can be eliminated, please; try to save a copy of the input and output files, listing of; $\mbox{FCN}$, and other information that may be relevant, and; send them to $\mbox{fred.james@cern.ch}$. # A complete example #. [example:example]. Here a full example of a fit is presented, following the example; DemoGaussSim.cpp. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:74426,depend,dependence,74426,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['depend'],['dependence']
Integrability,"is chapter and later require LLVM 3.7 or; later. LLVM 3.6 and before will not work with it. Also note that you; need to use a version of this tutorial that matches your LLVM release:; If you are using an official LLVM release, use the version of the; documentation included with your release or on the `llvm.org releases; page <https://llvm.org/releases/>`_. Code Generation Setup; =====================. In order to generate LLVM IR, we want some simple setup to get started.; First we define virtual code generation (codegen) methods in each AST; class:. .. code-block:: c++. /// ExprAST - Base class for all expression nodes.; class ExprAST {; public:; virtual ~ExprAST() = default;; virtual Value *codegen() = 0;; };. /// NumberExprAST - Expression class for numeric literals like ""1.0"".; class NumberExprAST : public ExprAST {; double Val;. public:; NumberExprAST(double Val) : Val(Val) {}; Value *codegen() override;; };; ... The codegen() method says to emit IR for that AST node along with all; the things it depends on, and they all return an LLVM Value object.; ""Value"" is the class used to represent a ""`Static Single Assignment; (SSA) <http://en.wikipedia.org/wiki/Static_single_assignment_form>`_; register"" or ""SSA value"" in LLVM. The most distinct aspect of SSA values; is that their value is computed as the related instruction executes, and; it does not get a new value until (and if) the instruction re-executes.; In other words, there is no way to ""change"" an SSA value. For more; information, please read up on `Static Single; Assignment <http://en.wikipedia.org/wiki/Static_single_assignment_form>`_; - the concepts are really quite natural once you grok them. Note that instead of adding virtual methods to the ExprAST class; hierarchy, it could also make sense to use a `visitor; pattern <http://en.wikipedia.org/wiki/Visitor_pattern>`_ or some other; way to model this. Again, this tutorial won't dwell on good software; engineering practices: for our purposes, adding a virtua",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:1658,depend,depends,1658,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['depend'],['depends']
Integrability,"is future demand we can figure out if it makes sense to; introduce a new library, move the general classes somewhere else, or introduce; some other solution. We describe the roles of these classes in order of their dependencies. The Diagnostics Subsystem; -------------------------. The Clang Diagnostics subsystem is an important part of how the compiler; communicates with the human. Diagnostics are the warnings and errors produced; when the code is incorrect or dubious. In Clang, each diagnostic produced has; (at the minimum) a unique ID, an English translation associated with it, a; :ref:`SourceLocation <SourceLocation>` to ""put the caret"", and a severity; (e.g., ``WARNING`` or ``ERROR``). They can also optionally include a number of; arguments to the diagnostic (which fill in ""%0""'s in the string) as well as a; number of source ranges that related to the diagnostic. In this section, we'll be giving examples produced by the Clang command line; driver, but diagnostics can be :ref:`rendered in many different ways; <DiagnosticConsumer>` depending on how the ``DiagnosticConsumer`` interface is; implemented. A representative example of a diagnostic is:. .. code-block:: text. t.c:38:15: error: invalid operands to binary expression ('int *' and '_Complex float'); P = (P-42) + Gamma*4;; ~~~~~~ ^ ~~~~~~~. In this example, you can see the English translation, the severity (error), you; can see the source location (the caret (""``^``"") and file/line/column info),; the source ranges ""``~~~~``"", arguments to the diagnostic (""``int*``"" and; ""``_Complex float``""). You'll have to believe me that there is a unique ID; backing the diagnostic :). Getting all of this to happen has several steps and involves many moving; pieces, this section describes them and talks about best practices when adding; a new diagnostic. The ``Diagnostic*Kinds.td`` files; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Diagnostics are created by adding an entry to one of the; ``clang/Basic/Diagnostic*Kinds.td`` files, de",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:2551,depend,depending,2551,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,2,"['depend', 'interface']","['depending', 'interface']"
Integrability,"is means that; rootcling may now issue:. ``` {.cpp}; Error: in this version of ROOT, the option '!' used in a linkdef file; implies the actual existence of customized operators.; The following declaration is now required:; TBuffer &operator<<(TBuffer &,const THit *);; ```. if the operator `<<` declaration is missing. To steer the parsing done during the execution of rootcling, a new; macro: *\_\_ROOTCLING\_\_* is now defined during the parsing. The macros; *\_\_CINT\_\_* and *\_\_MAKECINT\_\_* are defined only when looking for; `#pragma` statement. The genreflex executable is still available, it preserves the same command; line options as in version 5 and provides new ones. Old selection XML files; are transparently usable by the new implementation. On the other hand some; of the new functionalities can be hardly backported to version 5. See; genreflex help for all the details about commandline switches and selection; files. It is important to note that it is not anymore a python script; interfaced to GCCXML but rather a wrapper around rootcling. In order to specify the classes selection, three methods are available:. 1) Selection XML file. This file can be read by both genreflex and rootcling.; 2) LinkDef file. This file can be read by rootcling.; 3) Selection namespace (also called *dictselection*). Available both for; rootcling and genreflex. See the documentation of the; `ROOT::Meta::Selection` namespace for all the details. *Warning*. It is important to note that during the parsing of the header files,; rootcint no longer defines *\_\_CINT\_\_* and genreflex no longer defines; *\_\_GCCXML\_\_*. This means in particular that data members that were; made transient by hiding them from rootcint or genreflex now *must* be; *explicitly* marked as transient. For rootcint or rootcling use:. ``` {.cpp}; sometype datamember; //! The exclamation mark signals the transientness; ```. and for genreflex. ``` {.cpp}; <class name=""edm::Particle"" >; <field name=""m_calculated"" tr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v600/index.md:7803,interface,interfaced,7803,core/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v600/index.md,2,"['interface', 'wrap']","['interfaced', 'wrapper']"
Integrability,"is not considered reasonable to revert without at least the promise to; provide a means for the patch author to debug the root issue. If a situation; arises where a public reproducer can not be shared for some reason (e.g.; requires hardware patch author doesn't have access to, sharp regression in; compile time of internal workload, etc.), the reverter is expected to be; proactive about working with the patch author to debug and test candidate; patches.; * Reverts should be reasonably timely. A change submitted two hours ago; can be reverted without prior discussion. A change submitted two years ago; should not be. Where exactly the transition point is is hard to say, but; it's probably in the handful of days in tree territory. If you are unsure,; we encourage you to reply to the commit thread, give the author a bit to; respond, and then proceed with the revert if the author doesn't seem to be; actively responding.; * When re-applying a reverted patch, the commit message should be updated to; indicate the problem that was addressed and how it was addressed. Obtaining Commit Access; -----------------------. We grant commit access to contributors with a track record of submitting high; quality patches. If you would like commit access, please send an email to; `Chris <mailto:clattner@llvm.org>`_ with your GitHub username. This is true; for former contributors with SVN access as well as new contributors. If; approved, a GitHub invitation will be sent to your GitHub account. In case you; don't get notification from GitHub, go to; `Invitation Link <https://github.com/orgs/llvm/invitation>`_ directly. Once; accept the invitation, you'll get commit access. Prior to obtaining commit access, it is common practice to request that; someone with commit access commits on your behalf. When doing so, please; provide the name and email address you would like to use in the Author; property of the commit. For external tracking purposes, committed changes are automatically reflected; on",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:22839,message,message,22839,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['message'],['message']
Integrability,"is relative to the directory of the ``.clang-format-ignore`` file; (or the root directory if the pattern starts with a slash). Patterns; containing drive names (e.g. ``C:``) are not supported.; * Patterns follow the rules specified in `POSIX 2.13.1, 2.13.2, and Rule 1 of; 2.13.3 <https://pubs.opengroup.org/onlinepubs/9699919799/utilities/; V3_chap02.html#tag_18_13>`_.; * A pattern is negated if it starts with a bang (``!``). To match all files in a directory, use e.g. ``foo/bar/*``. To match all files in; the directory of the ``.clang-format-ignore`` file, use ``*``.; Multiple ``.clang-format-ignore`` files are supported similar to the; ``.clang-format`` files, with a lower directory level file voiding the higher; level ones. Vim Integration; ===============. There is an integration for :program:`vim` which lets you run the; :program:`clang-format` standalone tool on your current buffer, optionally; selecting regions to reformat. The integration has the form of a `python`-file; which can be found under `clang/tools/clang-format/clang-format.py`. This can be integrated by adding the following to your `.vimrc`:. .. code-block:: vim. if has('python'); map <C-K> :pyf <path-to-this-file>/clang-format.py<cr>; imap <C-K> <c-o>:pyf <path-to-this-file>/clang-format.py<cr>; elseif has('python3'); map <C-K> :py3f <path-to-this-file>/clang-format.py<cr>; imap <C-K> <c-o>:py3f <path-to-this-file>/clang-format.py<cr>; endif. The first line enables :program:`clang-format` for NORMAL and VISUAL mode, the; second line adds support for INSERT mode. Change ""C-K"" to another binding if; you need :program:`clang-format` on a different key (C-K stands for Ctrl+k). With this integration you can press the bound key and clang-format will; format the current line in NORMAL and INSERT mode or the selected region in; VISUAL mode. The line or region is extended to the next bigger syntactic; entity. It operates on the current, potentially unsaved buffer and does not create; or save any files. To ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst:6526,integrat,integration,6526,interpreter/llvm-project/clang/docs/ClangFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst,1,['integrat'],['integration']
Integrability,"is the next crossed one, but the physical path (state) AFTER crossing; the boundary is not determined. In order to find out this new state, one; has to propagate the point with a distance slightly bigger that the; computed step value (which is accurate within numerical precision). A; method that performs this task finding the next location is; `TGeoManager::Step()`, described in "" Making a Step "", but users may; implement more precise methods to insure post-step boundary crossing. ## Geometry Graphical User Interface. The geombuilder package allows you to create and edit geometries. The; package provides a library of all GUI classes related to geometry. Each; editable geometry class **`TGeoXXX`** have a correspondent editor; **`TGeoXXXEditor`** that provides a graphics user interface allowing to; edit some (or all) parameters of a geometry object. The editable objects; are geometry manager, volumes, nodes, shapes, media, materials and; matrices. The interfaces provide also access to specific functionality; of geometry objects. The editing mechanism is based on ROOT GED; (Graphics Editors) functionality and the library is loaded using the; plug-in mechanism. ### Editing a Geometry. There are two different use cases having different ways of invoking the; geometry editors. The first one applies when starting with geometry from; scratch and using the builder functionality to create new geometry; objects. In this case, one should use the sequence:. ``` {.cpp}; root[] TGeoManager *geom = new TGeoManager(""MyGeom"",; ""Test builder"");; root[] geom->Edit(Option_t *option="""");; ```. The lines above will create a new **`TGeoManager`** class, create an; empty canvas and start the editor in the left-sided editor frame; attached to the canvas. To open the editor in a separate frame one; should provide a non-empty string as option to the `Edit()` method. ![The geometry manager editor](pictures/030001E9.png). ### The Geometry Manager Editor. ![Accessing/creating different categories o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:165675,interface,interfaces,165675,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['interface'],['interfaces']
Integrability,"is transformation analyzes and transforms the induction variables (and; computations derived from them) into simpler forms suitable for subsequent; analysis and transformation. This transformation makes the following changes to each loop with an; identifiable induction variable:. * All loops are transformed to have a *single* canonical induction variable; which starts at zero and steps by one.; * The canonical induction variable is guaranteed to be the first PHI node in; the loop header block.; * Any pointer arithmetic recurrences are raised to use array subscripts. If the trip count of a loop is computable, this pass also makes the following; changes:. * The exit condition for the loop is canonicalized to compare the induction; value against the exit value. This turns loops like:. .. code-block:: c++. for (i = 7; i*i < 1000; ++i). into. .. code-block:: c++. for (i = 0; i != 25; ++i). * Any use outside of the loop of an expression derived from the indvar is; changed to compute the derived value outside of the loop, eliminating the; dependence on the exit value of the induction variable. If the only purpose; of the loop is to compute the exit value of some derived expression, this; transformation will make the loop dead. This transformation should be followed by strength reduction after all of the; desired loop transformations have been performed. Additionally, on targets; where it is profitable, the loop could be transformed to count down to zero; (the ""do loop"" optimization). ``inline``: Function Integration/Inlining; -----------------------------------------. Bottom-up inlining of functions into callees. .. _passes-instcombine:. ``instcombine``: Combine redundant instructions; -----------------------------------------------. Combine instructions to form fewer, simple instructions. This pass does not; modify the CFG. This pass is where algebraic simplification happens. This pass combines things like:. .. code-block:: llvm. %Y = add i32 %X, 1; %Z = add i32 %Y, 1. in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:18681,depend,dependence,18681,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['depend'],['dependence']
Integrability,"is very infrequently used, it is important for; providing information about the current target machine being compiled for, and; other static information that can affect the various transformations. ``ImmutablePass``\ es never invalidate other transformations, are never; invalidated, and are never ""run"". .. _writing-an-llvm-pass-ModulePass:. The ``ModulePass`` class; ------------------------. The `ModulePass <https://llvm.org/doxygen/classllvm_1_1ModulePass.html>`_ class; is the most general of all superclasses that you can use. Deriving from; ``ModulePass`` indicates that your pass uses the entire program as a unit,; referring to function bodies in no predictable order, or adding and removing; functions. Because nothing is known about the behavior of ``ModulePass``; subclasses, no optimization can be done for their execution. A module pass can use function level passes (e.g. dominators) using the; ``getAnalysis`` interface ``getAnalysis<DominatorTree>(llvm::Function *)`` to; provide the function to retrieve analysis result for, if the function pass does; not require any module or immutable passes. Note that this can only be done; for functions for which the analysis ran, e.g. in the case of dominators you; should only ask for the ``DominatorTree`` for function definitions, not; declarations. To write a correct ``ModulePass`` subclass, derive from ``ModulePass`` and; override the ``runOnModule`` method with the following signature:. The ``runOnModule`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool runOnModule(Module &M) = 0;. The ``runOnModule`` method performs the interesting work of the pass. It; should return ``true`` if the module was modified by the transformation and; ``false`` otherwise. .. _writing-an-llvm-pass-CallGraphSCCPass:. The ``CallGraphSCCPass`` class; ------------------------------. The `CallGraphSCCPass; <https://llvm.org/doxygen/classllvm_1_1CallGraphSCCPass.html>`_ is used by; passes that need to traverse the program bottom",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:13242,interface,interface,13242,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['interface'],['interface']
Integrability,"isible context (e.g., function prototype, struct definition, etc.). .. _Default pointer types in typeof:. Default pointer types in ``typeof()``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When ``typeof()`` takes an expression, it respects the bounds annotation on; the expression type, including the bounds annotation is implcit. For example,; the global variable ``g`` in the following code is implicitly ``__single`` so; ``typeof(g)`` gets ``char *__single``. The similar is true for the parameter; ``p``, so ``typeof(p)`` returns ``void *__single``. The local variable ``l`` is; implicitly ``__bidi_indexable``, so ``typeof(l)`` becomes; ``int *__bidi_indexable``. .. code-block:: C. char *g; // typeof(g) == char *__single. void foo(void *p) {; // typeof(p) == void *__single. int *l; // typeof(l) == int *__bidi_indexable; }. When the type of expression has an ""external"" bounds annotation, e.g.,; ``__sized_by``, ``__counted_by``, etc., the compiler may report an error on; ``typeof`` if the annotation creates a dependency with another declaration or; variable. For example, the compiler reports an error on ``typeof(p1)`` shown in; the following code because allowing it can potentially create another type; dependent on the parameter ``size`` in a different context (Please note that an; external bounds annotation on a parameter may only refer to another parameter of; the same function). On the other hand, ``typeof(p2)`` works resulting in ``int; *__counted_by(10)``, since it doesn't depend on any other declaration. .. TODO: add a section describing constraints on external bounds annotations. .. code-block:: C. void foo(int *__counted_by(size) p1, size_t size) {; // typeof(p1) == int *__counted_by(size); // -> a compiler error as it tries to create another type; // dependent on `size`. int *__counted_by(10) p2; // typeof(p2) == int *__counted_by(10); // -> no error. }. When ``typeof()`` takes a type name, the compiler doesn't apply an implicit; bounds annotation on the named pointer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:26312,depend,dependency,26312,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['depend'],['dependency']
Integrability,"ist. * Text formatting and spelling should follow the same rules as documentation; and in-code comments, ex. capitalization, full stop, etc. * If the commit is a bug fix on top of another recently committed patch, or a; revert or reapply of a patch, include the git commit hash of the prior; related commit. This could be as simple as ""Revert commit NNNN because it; caused PR#"". * If the patch has been reviewed, add a link to its review page, as shown; `here <https://www.llvm.org/docs/Phabricator.html#committing-a-change>`__.; If the patch fixes a bug in GitHub Issues, we encourage adding a reference to; the issue being closed, as described; `here <https://llvm.org/docs/BugLifeCycle.html#resolving-closing-bugs>`__. * It is also acceptable to add other metadata to the commit message to automate; processes, including for downstream consumers. This metadata can include; links to resources that are not available to the entire community. However,; such links and/or metadata should not be used in place of making the commit; message self-explanatory. Note that such non-public links should not be; included in the submitted code. For minor violations of these recommendations, the community normally favors; reminding the contributor of this policy over reverting. Minor corrections and; omissions can be handled by sending a reply to the commits mailing list. .. _revert_policy:. Patch reversion policy; ----------------------. As a community, we strongly value having the tip of tree in a good state while; allowing rapid iterative development. As such, we tend to make much heavier; use of reverts to keep the tree healthy than some other open source projects,; and our norms are a bit different. How should you respond if someone reverted your change?. * Remember, it is normal and healthy to have patches reverted. Having a patch; reverted does not necessarily mean you did anything wrong.; * We encourage explicitly thanking the person who reverted the patch for doing; the task on your b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:18111,message,message,18111,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['message'],['message']
Integrability,"isualisation settings and division interface for volumes"" width=600px. - *Division*. Allows dividing the edited volume according a given; pattern. The division axes that are allowed are presented in a; radio-button group. The number entries labeled ""From"", ""Step""; and ""Nslices"" correspond to the divisioning parameters on the; selected axis. The range of the division is between `start` and; `start+ndiv*step` values and its validity is checked upon changing; one of the values. NOTE: When changing a value in a number entry by typing a number, press; ENTER at the end to validate. This applies for taking into account and; validation of any number change in the geometry editors. \anchor GP08f; ### How to Create a Valid Geometry with Geometry Editors. 1. Create a new geometry manager and start the editor as described at; the beginning. 2. Create at least one material from the ""Materials"" shutter item; category. Generally, for creating objects, the interface is always in; the TGeoManagerEditor in different categories - one should just; provide a name and requested parameters. 3. Create a shape that will be used for the top volume within the; ""Shapes"" category. For the moment, the shapes that have editors are; Box, Para, Trd1, Trd2, Tube, Tube segment, Cone, Cone segment, Hype,; Pcon, Torus and Sphere. 4. Create a medium from one of the existing materials from the; ""Medium"" category. You will notice that some categories as ""Volume""; and ""Medium"" are inactive at the beginning because at that time there; is no material yet (for making a medium) and no shape (for making a; volume). These categories are dynamically activated once all the; required components are defined. 5. Create a volume from the ""Volumes"" category. You will notice that; contrary to the other editors, the volume editor is opened in a tab, not; transient - this is because it is more complex. 6. Go back to ""General"" category and select the newly created volume; as the top one (you can do it also from the volume c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:134342,interface,interface,134342,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['interface'],['interface']
Integrability,"it clone https://github.com/wlav/cppyy-backend.git; $ cd cppyy-backend/cling; $ python setup.py egg_info; $ python create_src_directory.py; $ python setup.py bdist_wheel; $ python -m pip install dist/cppyy_cling-* --upgrade. .. note::; ``cppyy-cling`` wheels do not depend on the Python interpreter and can; thus be re-used for any version of Python or PyPy. The ``egg_info`` setup command is needed for ``create_src_directory.py`` to; find the right version.; That script in turn downloads the proper release from `upstream`_, trims and; patches it,; and installs the result in the ""src"" directory.; When done, the structure of ``cppyy-cling`` looks again like a PyPA package; and can be used/installed as expected, here done with ``pip``. By default, the setup script will use all cores (x2 if hyperthreading is; enabled).; You can change this behavior by setting the ``MAKE_NPROCS`` envar to the; desired number of allowable sub jobs. If on the other hand you are building from source to develop/modify; ``cppyy-cling``, consider using the ``cmake`` interface.; The first installation will still be just as slow, but subsequent builds can; be incremental and thus much faster.; For this use, first install the latest version from a pre-built wheel, which; will setup the proper directory structure, then use cmake to build and; install the latest or modified version of ``cppyy-cling`` into that::. $ python -m pip install cppyy-cling; $ git clone https://github.com/wlav/cppyy-backend.git; $ cd cppyy-backend/cling; $ python setup.py egg_info; $ python create_src_directory.py; $ mkdir dev; $ cd dev; $ cmake ../src -Wno-dev -DCMAKE_CXX_STANDARD=17 -DLLVM_ENABLE_EH=0 -DLLVM_ENABLE_RTTI=0 -DLLVM_ENABLE_TERMINFO=0 -DLLVM_ENABLE_ASSERTIONS=0 -Dminimal=ON -Druntime_cxxmodules=OFF -Dbuiltin_zlib=ON -Dbuiltin_cling=ON -DCMAKE_BUILD_TYPE=RelWithDebInfo -DCMAKE_INSTALL_PREFIX=<path to environment python site-packages>; $ make -j <N> install. where the ``cmake`` command needs to be given the full p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/repositories.rst:3931,interface,interface,3931,bindings/pyroot/cppyy/cppyy/doc/source/repositories.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/repositories.rst,1,['interface'],['interface']
Integrability,"it does have problems. In particular, because the; conservative garbage collector cannot *know* that a particular word in the; machine is a pointer, it cannot move live objects in the heap (preventing the; use of compacting and generational GC algorithms) and it can occasionally suffer; from memory leaks due to integer values that happen to point to objects in the; program. In addition, some aggressive compiler transformations can break; conservative garbage collectors (though these seem rare in practice). Accurate garbage collectors do not suffer from any of these problems, but they; can suffer from degraded scalar optimization of the program. In particular,; because the runtime must be able to identify and update all pointers active in; the program, some optimizations are less effective. In practice, however, the; locality and performance benefits of using aggressive garbage collection; techniques dominates any low-level losses. This document describes the mechanisms and interfaces provided by LLVM to; support accurate garbage collection. Goals and non-goals; -------------------. LLVM's intermediate representation provides :ref:`garbage collection intrinsics; <gc_intrinsics>` that offer support for a broad class of collector models. For; instance, the intrinsics permit:. * semi-space collectors. * mark-sweep collectors. * generational collectors. * incremental collectors. * concurrent collectors. * cooperative collectors. * reference counting. We hope that the support built into the LLVM IR is sufficient to support a; broad class of garbage collected languages including Scheme, ML, Java, C#,; Perl, Python, Lua, Ruby, other scripting languages, and more. Note that LLVM **does not itself provide a garbage collector** --- this should; be part of your language's runtime library. LLVM provides a framework for; describing the garbage collectors requirements to the compiler. In particular,; LLVM provides support for generating stack maps at call sites, polling for a; saf",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:4923,interface,interfaces,4923,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['interface'],['interfaces']
Integrability,"it. There's no need to worry; about the index of these loops, because they get propagated. For example, if; you want to iterate over a vector of RooFit objects using a loop, you don't; have to think about indexing them properly because the `beginLoop()` function; takes care of that. Simply call this function, place your function call in a; scope and after the scope ends, the loop will also end. - `addToCodeBody()` helps add things to the body of the C++ function that; you're creating. It takes whatever string is computed in its arguments and; adds it to the overall function string (which will later be just-in-time; compiled). The `addToCodeBody()` function is important since not everything; can be added in-line and this function helps split the code into multiple; lines. ### Step 3. analyticalIntegral() Use Case. > Besides the `evaluate()` function, this tutorial illustrates how the; `analyticalIntegral()` can be updated. This highly dependent on the class that; is being transformed for AD support, but will be necessary in those specific; instances. Let's consider a fictional class RooFoo, that performs some arbitrary; mathematical operations called 'Foo' (as seen in doFoo() function below). > Note that doFoo is a simplified example, in many cases the mathematical; operations are not limited to a single function, so they need to be spotted; within the `evaluate()` function. ``` {.cpp}; class RooFoo : public RooAbsReal {; int a;; int b;; int doFoo() { return a* b + a + b; }; int integralFoo() { return /* whatever */;}; public:; // Other functions...; double evaluate() override {; // Do some bookkeeping; return doFoo();; };; double analyticalIntegral(Int_t code, const char* rangeName) override {; // Select the right paths for integration using codes or whatever.; return integralFoo();; }; };; ```. \note All RooFit classes are deriving from the RooAbsReal object, but; its details are not relevant to the current example. Note how the `evaluate()` function overrides the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:18870,depend,dependent,18870,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['depend'],['dependent']
Integrability,"ith C++ Modules which is important but; unfair comparison. As we noted earlier, PCH is very efficient, it cannot be; extended to the experiments’ software stacks because of its design constraints.; On the contrary, the C++ Modules can be used in third-party code where the PCH; is not available. The comparisons are to give a good metric when we are ready to switch ROOT to use; C++ Modules by default. However, since it is essentially the same technology,; optimizations of C++ Modules also affect the PCH. We have a few tricks up in; the sleeves to but they come with given trade-offs. #### Preloading of C++ Modules. The main focus for the technology preview was not in performance until recently.; We have invested some resources in optimizations and we would like to show you; (probably outdated) performance results:. * Memory footprint -- mostly due to importing all C++ Modules at startup; we see overhead which depends on the number of preloaded modules. For; ROOT it is between 40-60 MB depending on the concrete configuration.; When the workload increases we notice that the overall memory performance; decreases in number of cases.; * Execution times -- likewise we have an execution overhead. For ; workflows which take ms the slowdown can be 2x. Increasing of the work; to seconds shows 50-60% slowdowns. The performance is dependent on many factors such as configuration of ROOT and; workflow. You can read more at our Intel IPCC-ROOT Showcase presentation; here (pp 25-33)[[8]]. #### Loading C++ Modules on Demand. In long term, we should optimize the preloading of modules to be a no-op and; avoid recursive behavior based on identifier lookup callbacks. Unfortunately,; at the moment the loading of C++ modules on demand shows significantly better; performance results. You can visit our continuous performance monitoring tool where we compare; the performance of ROOT against ROOT with a PCH [[9]].; *Note: if you get error 400, clean your cache or open a private browser session.*",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:18349,depend,depending,18349,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,1,['depend'],['depending']
Integrability,"ith `&storage_prefix=name` URL #290; 7. Let customize URL for ""Show in new tab"" menu command; 8. Support both new and old TRatioPlot drawings; 10. Synchronize X/Y range selection with native ROOT; 11. Proper handle attributes from TH2Poly bins, support ""p"" for markers drawing; 12. Correctly scale size of axis ticks - take into account NDC axis length; 13. Set name and userData in geometry `build()` function #303; 14. Draw histogram title afterwards - place in front of stats box; 15. Upgrade three.js r158 -> r162, last with WebGL1 support; 16. Split extras into three_addons.mjs, provide jsroot geometry build without three.js; 17. Fix - correctly draw only grids with AXIG draw option; 18. Fix - log scales on TH3 drawings #306; 19. Fix - draw geometry top node volume if all childs not visible #308; 20. Fix - properly process 206 server response without Accept-Ranges header https://root-forum.cern.ch/t/59426/. ## Changes in 7.6.1; 1. Remove source_dir output in node.js #296; 2. Fully integrate svg2pdf.js into jsroot repo; 3. Fix - support plain TRI option for TGraph2D; 4. Fix - let read object from ROOT file with empty name; 5. Fix - graph drawing fix custom labels on X axis #297; 6. Fix - draw at least line for TGraphErrors ROOT-8131; 7. Fix - preserve attributes and draw options when call drawingJSON() #307; 8. Fix - menu for text align selection typo. ## Changes in 7.6.0; 1. Implement ""tickz"" draw option, used for color palette ticks; 2. Implement skewness and kurtosis calculations for histogram stats box; 3. Introduce ""logv"" draw option for `TH3`, configures logarithmic scale for box volume; 4. Implement color palette drawing for `TH3`; 5. Implement cutg draw option for `TH2`/`TF2` surface plots; 6. Implement `TMath::Sq()` function and several others like SinH, ASinH, ...; 7. Implement histogram drawing build from `TGraph2D` using Delaunay interpolation; 8. Provide preliminary `TF3` support; 9. Support `TLinearGradient` and `TRadialGradient` colors; 10. Support LZMA ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:5457,integrat,integrate,5457,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['integrat'],['integrate']
Integrability,"ither the variable stops; being used completely or a new value is stored in the variable. The intent of the third rule is to say that return values may be; released after they've been used. A computation history depends on a pointer value ``P`` if it:. * performs a pointer comparison with ``P``,; * loads from ``P``,; * stores to ``P``,; * depends on a pointer value ``Q`` derived via pointer arithmetic; from ``P`` (including an instance-variable or field access), or; * depends on a pointer value ``Q`` loaded from ``P``. Dependency applies only to values derived directly or indirectly from; a particular expression result and does not occur merely because a; separate pointer value dynamically aliases ``P``. Furthermore, this; dependency is not carried by values that are stored to objects. .. admonition:: Rationale. The restrictions on dependency are intended to make this analysis; feasible by an optimizer with only incomplete information about a; program. Essentially, dependence is carried to ""obvious"" uses of a; pointer. Merely passing a pointer argument to a function does not; itself cause dependence, but since generally the optimizer will not; be able to prove that the function doesn't depend on that parameter,; it will be forced to conservatively assume it does. Dependency propagates to values loaded from a pointer because those; values might be invalidated by deallocating the object. For; example, given the code ``__strong id x = p->ivar;``, ARC must not; move the release of ``p`` to between the load of ``p->ivar`` and the; retain of that value for storing into ``x``. Dependency does not propagate through stores of dependent pointer; values because doing so would allow dependency to outlive the; full-expression which produced the original value. For example, the; address of an instance variable could be written to some global; location and then freely accessed during the lifetime of the local,; or a function could return an inner pointer of an object and store; it",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:80600,depend,dependence,80600,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['depend'],['dependence']
Integrability,"itial adjustment. .. code-block:: c++. enum RelocationType {; reloc_pcrel_word = 0, // add reloc value after adjusting for the PC loc; reloc_picrel_word = 1, // add reloc value after adjusting for the PIC base; reloc_absolute_word = 2, // absolute relocation; no additional adjustment; reloc_absolute_dword = 3 // absolute relocation; no additional adjustment; };. Target JIT Info; ---------------. ``XXXJITInfo.cpp`` implements the JIT interfaces for target-specific; code-generation activities, such as emitting machine code and stubs. At; minimum, a target-specific version of ``XXXJITInfo`` implements the following:. * ``getLazyResolverFunction`` --- Initializes the JIT, gives the target a; function that is used for compilation. * ``emitFunctionStub`` --- Returns a native function with a specified address; for a callback function. * ``relocate`` --- Changes the addresses of referenced globals, based on; relocation types. * Callback function that are wrappers to a function stub that is used when the; real target is not initially known. ``getLazyResolverFunction`` is generally trivial to implement. It makes the; incoming parameter as the global ``JITCompilerFunction`` and returns the; callback function that will be used a function wrapper. For the Alpha target; (in ``AlphaJITInfo.cpp``), the ``getLazyResolverFunction`` implementation is; simply:. .. code-block:: c++. TargetJITInfo::LazyResolverFn AlphaJITInfo::getLazyResolverFunction(; JITCompilerFn F) {; JITCompilerFunction = F;; return AlphaCompilationCallback;; }. For the X86 target, the ``getLazyResolverFunction`` implementation is a little; more complicated, because it returns a different callback function for; processors with SSE instructions and XMM registers. The callback function initially saves and later restores the callee register; values, incoming arguments, and frame and return address. The callback; function needs low-level access to the registers or stack, so it is typically; implemented with assembler.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:82915,wrap,wrapper,82915,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['wrap'],['wrapper']
Integrability,itializer in non-type template default argument; Clang 18. 2050; NAD; Consolidate specification of linkage; Unknown. 2051; CD5; Simplifying alias rules; Unknown. 2052; CD4; Template argument deduction vs overloaded operators; Unknown. 2053; C++20; auto in non-generic lambdas; Unknown. 2054; DR; Missing description of class SFINAE; Unknown. 2055; drafting; Explicitly-specified non-deduced parameter packs; Not resolved. 2056; drafting; Member function calls in partially-initialized class objects; Not resolved. 2057; drafting; Template template arguments with default arguments; Not resolved. 2058; CD6; More errors from internal-linkage namespaces; Unknown. 2059; CD5; Linkage and deduced return types; Unknown. 2060; NAD; Deduced return type for explicit specialization; Unknown. 2061; CD4; Inline namespace after simplifications; Yes. 2062; CD6; Class template redeclaration requirements; Unknown. 2063; CD4; Type/nontype hiding in class scope; Unknown. 2064; CD4; Conflicting specifications for dependent decltype-specifiers; Unknown. 2065; CD6; Current instantiation of a partial specialization; Unknown. 2066; CD4; Does type-dependent imply value-dependent?; Unknown. 2067; open; Generated variadic templates requiring empty pack; Not resolved. 2068; CD4; When can/must a defaulted virtual destructor be defined?; Unknown. 2069; CD4; Do destructors have names?; Unknown. 2070; CD6; using-declaration with dependent nested-name-specifier; Unknown. 2071; CD4; typedef with no declarator; Unknown. 2072; C++23; Default argument instantiation for member functions of templates; Unknown. 2073; drafting; Allocating memory for exception objects; Not resolved. 2074; drafting; Type-dependence of local class of function template; Not resolved. 2075; CD4; Passing short initializer lists to array reference parameters; Unknown. 2076; CD4; List-initialization of arguments for constructor parameters; Clang 13. 2077; drafting; Overload resolution and invalid rvalue-reference initialization; Not reso,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:140284,depend,dependent,140284,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['depend'],['dependent']
Integrability,"itly* encode. The trend; that we are seeing supports this greatly:. 1. Commodity processors are getting massive SIMD support:; * Intel/Amd MMX/MMX2; * AMD's 3Dnow!; * Intel's SSE/SSE2; * Sun's VIS; 2. SMP is becoming much more common, especially in the server space.; 3. Multiple processors on a die are right around the corner. If nothing else, not designing this in would severely limit our future; expansion of the project... > Also, this will require some reading on at least two other; > projects:; > -- Multiscalar architecture from Wisconsin; > -- Simultaneous multithreading architecture from Washington; >; > o Or forget all this and stick to a traditional instruction set?. Heh... :) Well, from a pure research point of view, it is almost more; attactive to go with the most extreme/different ISA possible. On one axis; you get safety and conservatism, and on the other you get degree of; influence that the results have. Of course the problem with pure research; is that often times there is no concrete product of the research... :). > BTW, on an unrelated note, after the meeting yesterday, I did remember; > that you had suggested doing instruction scheduling on SSA form instead; > of a dependence DAG earlier in the semester. When we talked about; > it yesterday, I didn't remember where the idea had come from but I; > remembered later. Just giving credit where its due... :) Thanks. . > Perhaps you can save the above as a file under RCS so you and I can; > continue to expand on this. I think it makes sense to do so when we get our ideas more formalized and; bounce it back and forth a couple of times... then I'll do a more formal; writeup of our goals and ideas. Obviously our first implementation will; not want to do all of the stuff that I pointed out above... be we will; want to design the project so that we do not artificially limit ourselves; at sometime in the future... Anyways, let me know what you think about these ideas... and if they sound; reasonable... -Chris. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt:8713,depend,dependence,8713,interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt,1,['depend'],['dependence']
Integrability,"itors Control. Full control over base-class editors can be achieved by re-implementing; virtual method void `TGedFrame::ActivateBaseClassEditors(TClass` `*cl)`.; It is called during each compound editor rebuild and the default; implementation simply offers all base-classes to the publishing; mechanism. To prevent inclusion of a base-class into the compound editor, call:. ``` {.cpp}; void TGedEditor::ExcludeClassEditor(TClass* class, Bool_t recurse); ```. Pointer to the compound GED-editor is available in **`TGedFrame`**‘s; data-member:. ``` {.cpp}; TGedEditor *fGedEditor; ```. Ordering of base-class editor frames follows the order of the classes in; the class hierarchy. This order can be changed by modifying the value of; **`TGedFrame`**'s data member `Int_t fPriority`. The default value is; 50; smaller values move the frame towards to the top. This priority; should be set in the editor constructor. ## Drag and Drop. Drag and Drop support is introduced for Linux (via Xdnd - the drag and; drop protocol for X window system) and for Windows (via Clipboard).; Users can selects something in ROOT with a mouse press, drags it (moves; the mouse while keeping the mouse button pressed) and releases the mouse; button someplace else. When the button is released the selected data is; ""dropped"" at that location. This way, a histogram from an opened ROOT; file in the browser can be dragged to any **`TCanvas`**. ![](pictures/03000223.png). A script file from the browser can be dropped to a **`TGTextView`** or; TGTextEdit widget in **`TGTextEditor`**. On Linux, it is possible to drag objects between ROOT and an external; application. For example to drag a macro file from the ROOT browser to; the Kate editor. On Windows, drag and drop works only within a single; ROOT application (for the time being), but works also from Windows; Explorer to **`TCanvas`** ot to **`TGTextEdit`**. ### Drag and Drop Data Class. The Drag and Drop Cata class **`TDNDdata`** is used to describe and; handle t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:107622,protocol,protocol,107622,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['protocol'],['protocol']
Integrability,"itory; if(roottest_force_checkout); set(roottest_opts FORCE); endif(); relatedrepo_Checkout(REPO_NAME roottest FETCHURL ${roottest_url} FETCHREF ""${roottest_ref}""; REPO_DIR_VARIABLE roottest_dir ${roottest_opts}); if(NOT IS_DIRECTORY ${roottest_dir}); message(FATAL_ERROR ""Expected roottest at '${roottest_dir}' (not a directory?)""); endif(); file(REMOVE_RECURSE ${CMAKE_CURRENT_BINARY_DIR}/roottest); add_subdirectory(${roottest_dir} roottest); endif(). if(rootbench); find_package(Git REQUIRED); if(rootbench_force_checkout); set(rootbench_opts FORCE); endif(); relatedrepo_Checkout(REPO_NAME rootbench FETCHURL ${upstreamprefix} FETCHREF master; REPO_DIR_VARIABLE rootbench_dir ${rootbench_opts}); if(NOT IS_DIRECTORY ${rootbench_dir}); message(FATAL_ERROR ""Expected rootbench at '${rootbench_dir}' (not a directory?)""); endif(); file(REMOVE_RECURSE ${CMAKE_CURRENT_BINARY_DIR}/rootbench); add_subdirectory(${rootbench_dir} rootbench); endif(); endif(). if(LLVM_LINKER_IS_MOLD); message(FATAL_ERROR ""The mold linker is not supported by ROOT. Please use a different linker""); endif(). cmake_host_system_information(RESULT PROCESSOR QUERY PROCESSOR_DESCRIPTION). message(STATUS ""ROOT Configuration \n; System: ${CMAKE_SYSTEM}; ROOT Platform: ${ROOT_PLATFORM}; ROOT Architecture: ${ROOT_ARCHITECTURE}; Processor: ${PROCESSOR} (${CMAKE_SYSTEM_PROCESSOR}); Build type: ${CMAKE_BUILD_TYPE}; Install path: ${CMAKE_INSTALL_PREFIX}; Compiler: ${CMAKE_CXX_COMPILER_ID} ${CMAKE_CXX_COMPILER_VERSION}; C++ standard: ${CMAKE_CXX_STANDARD}; Compiler flags:""); if(MSVC AND NOT CMAKE_GENERATOR MATCHES Ninja); message(STATUS ""; - C: ${CMAKE_C_FLAGS}; - C (build type specific):; Debug: ${CMAKE_C_FLAGS_DEBUG}; Release: ${CMAKE_C_FLAGS_RELEASE}; MinSizeRel: ${CMAKE_C_FLAGS_MINSIZEREL}; RelWithDebInfo: ${CMAKE_C_FLAGS_RELWITHDEBINFO}; - C++: ${CMAKE_CXX_FLAGS}; - C++ (build type specific):; Debug: ${CMAKE_CXX_FLAGS_DEBUG}; Release: ${CMAKE_CXX_FLAGS_RELEASE}; MinSizeRel: ${CMAKE_CXX_FLAGS_MINSIZEREL}; RelWithD",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt:30441,message,message,30441,CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt,1,['message'],['message']
Integrability,"itrary location description (such as a vector register); is required. The offset operations provide this ability since they can be used; to compute a location description on the stack. It could be possible to define ``DW_OP_plus``, ``DW_OP_plus_uconst``, and; ``DW_OP_minus`` to operate on location descriptions to avoid needing; ``DW_OP_LLVM_offset`` and ``DW_OP_LLVM_offset_uconst``. However, this is not; proposed since currently the arithmetic operations are defined to require values; of the same base type and produces a result with the same base type. Allowing; these operations to act on location descriptions would permit the first operand; to be a location description and the second operand to be an integral value; type, or vice versa, and return a location description. This complicates the; rules for implicit conversions between default address space memory location; descriptions and generic base type values. Currently the rules would convert; such a location description to the memory address value and then perform two's; compliment wrap around arithmetic. If the result was used as a location; description, it would be implicitly converted back to a default address space; memory location description. This is different to the overflow rules on location; descriptions. To allow control, an operation that converts a memory location; description to an address integral type value would be required. Keeping a; separation of location description operations and arithmetic operations avoids; this semantic complexity. See ``DW_OP_LLVM_offset``, ``DW_OP_LLVM_offset_uconst``, and; ``DW_OP_LLVM_bit_offset`` in; :ref:`amdgpu-dwarf-general-location-description-operations`. 2.5 Generalize Creation of Undefined Location Descriptions; ----------------------------------------------------------. Current DWARF uses an empty expression to indicate an undefined location; description. Since; :ref:`amdgpu-dwarf-allow-location-description-on-the-dwarf-evaluation-stack`; allows location desc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:13978,wrap,wrap,13978,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['wrap'],['wrap']
Integrability,"itself is a subclass of; ``Value``. The operands of a ``User`` point directly to the LLVM ``Value`` that it refers; to. Because LLVM uses Static Single Assignment (SSA) form, there can only be; one definition referred to, allowing this direct connection. This connection; provides the use-def information in LLVM. .. _m_User:. Important Public Members of the ``User`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``User`` class exposes the operand list in two ways: through an index access; interface and through an iterator based interface. * | ``Value *getOperand(unsigned i)``; | ``unsigned getNumOperands()``. These two methods expose the operands of the ``User`` in a convenient form for; direct access. * | ``User::op_iterator`` - Typedef for iterator over the operand list; | ``op_iterator op_begin()`` - Get an iterator to the start of the operand; list.; | ``op_iterator op_end()`` - Get an iterator to the end of the operand list. Together, these methods make up the iterator based interface to the operands; of a ``User``. .. _Instruction:. The ``Instruction`` class; -------------------------. ``#include ""llvm/IR/Instruction.h""``. header source: `Instruction.h; <https://llvm.org/doxygen/Instruction_8h_source.html>`_. doxygen info: `Instruction Class; <https://llvm.org/doxygen/classllvm_1_1Instruction.html>`_. Superclasses: User_, Value_. The ``Instruction`` class is the common base class for all LLVM instructions.; It provides only a few methods, but is a very commonly used class. The primary; data tracked by the ``Instruction`` class itself is the opcode (instruction; type) and the parent BasicBlock_ the ``Instruction`` is embedded into. To; represent a specific type of instruction, one of many subclasses of; ``Instruction`` are used. Because the ``Instruction`` class subclasses the User_ class, its operands can; be accessed in the same way as for other ``User``\ s (with the; ``getOperand()``/``getNumOperands()`` and ``op_begin()``/``op_end()`` methods).; A",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:146129,interface,interface,146129,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['interface'],['interface']
Integrability,"itself, because it is ""abstract"":. .. code-block:: c++. static RegisterAnalysisGroup<AliasAnalysis> A(""Alias Analysis"");. Once the analysis is registered, passes can declare that they are valid; implementations of the interface by using the following code:. .. code-block:: c++. namespace {; // Declare that we implement the AliasAnalysis interface; INITIALIZE_AG_PASS(FancyAA, AliasAnalysis , ""somefancyaa"",; ""A more complex alias analysis implementation"",; false, // Is CFG Only?; true, // Is Analysis?; false); // Is default Analysis Group implementation?; }. This just shows a class ``FancyAA`` that uses the ``INITIALIZE_AG_PASS`` macro; both to register and to ""join"" the `AliasAnalysis; <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`_ analysis group.; Every implementation of an analysis group should join using this macro. .. code-block:: c++. namespace {; // Declare that we implement the AliasAnalysis interface; INITIALIZE_AG_PASS(BasicAA, AliasAnalysis, ""basic-aa"",; ""Basic Alias Analysis (default AA impl)"",; false, // Is CFG Only?; true, // Is Analysis?; true); // Is default Analysis Group implementation?; }. Here we show how the default implementation is specified (using the final; argument to the ``INITIALIZE_AG_PASS`` template). There must be exactly one; default implementation available at all times for an Analysis Group to be used.; Only default implementation can derive from ``ImmutablePass``. Here we declare; that the `BasicAliasAnalysis; <https://llvm.org/doxygen/structBasicAliasAnalysis.html>`_ pass is the default; implementation for the interface. Pass Statistics; ===============. The `Statistic <https://llvm.org/doxygen/Statistic_8h_source.html>`_ class is; designed to be an easy way to expose various success metrics from passes.; These statistics are printed at the end of a run, when the :option:`-stats`; command line option is enabled on the command line. See the :ref:`Statistics; section <Statistic>` in the Programmer's Manual for details. ..",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:39544,interface,interface,39544,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['interface'],['interface']
Integrability,"ity Assurance. Each contribution should contain developer documentation in the form of code; comments and sufficient amount of tests in the form of unit and/or integration; tests. Unit tests are relatively small and quick programs focused to check if; small pieces of code and API work as expected. Integration tests are checks; which ensure the synergy between different (unit tested) components. Put in; practice, unit tests verify (member) function behavior whereas integration tests; check classes and their cooperation. The boundary between both kinds of testing; is blurred. ROOT has support for both kinds of tests in the [roottest repository](https://github.com/root-project/roottest); and supports ""inline"" unit tests in each component's `test` folder. Unit testing; uses the [GTest and GMock](https://github.com/google/googletest) infrastructure; along with small ROOT-specific extensions located in; [TestSupport](../core/test_support/). The documentation of GTest; and GMock is rather extensive and we will describe some of the features of; ROOT::TestSupport. In order to write an inline unit test, add a new file in the; nearest to the tested component's `test` folder and call `ROOT_ADD_GTEST` in the; `CMakeLists.txt` file. In many cases using standard GTest facility is sufficient to write a good test.; However, we disallow error messages in gtests, or sometimes we want to test the; error conditions of an interface and its diagnostics. For example,. ```cpp. void MyROOTFunc(unsigned x); {; if (x == 0) {; Error(""MyROOTFunc"", ""x should be greater than 0!"");; return;; }; /* some work */; }. ```. In order to check if the error is printed on the right spot we can write the; following test:. ```cpp. #include ""ROOT/TestSupport.hxx"". #include ""gtest/gtest.h"". TEST(MyROOTFunc, ErrorCases); {; ROOT_EXPECT_ERROR(MyROOTFunc(0), ""MyROOTFunc"", ""x should be greater than 0!"");; // Also ROOT_EXPECT_WARNING, ROOT_EXPECT_INFO, ROOT_EXPECT_NODIAG and ROOT_EXPECT_SYSERROR available.; }. ```. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/DEVELOPMENT.md:2025,message,messages,2025,README/DEVELOPMENT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/DEVELOPMENT.md,2,"['interface', 'message']","['interface', 'messages']"
Integrability,"ity class has been added, to provide information about the on-disk metadata of an RNTuple.; - A new `RNTupleParallelWriter` class has been added, providing (initial) support for parallel writing of RNTuples.; - A new static method `RFieldBase::Check()` has been added, which produces a support status report of a type with regards to RNTuple I/O.; - A new internal `RNTupleMerger` class has been added, enabling the merging of different page sources into one page sink. This also means that RNTuples can be merged through `hadd`.; - Zero-copy bulk reading has been added, with extra optimizations for `ROOT::RVec` fields.; - It is now possible to use the `RNTupleView` with an external address with type erasure, e.g.:; ```cpp; std::shared_ptr<void> data{new float()};; auto view = reader->GetView(""pt"", data);; ```; This enables use cases such as reading one specific entry of one specific field into a previously allocated memory location.; - Further integration with [RDataFrame](#rdataframe): it is now possible to create RDataFrame for chains of RNTuples. This addition also comes with improvements to the multi-threaded work scheduling.; - Many additional bug fixes and improvements. Please, report any issues regarding the above mentioned features should you encounter them. RNTuple is still in pre-production. The on-disk format is scheduled to be finalized by the end of 2024. Thus, we appreciate feedback and suggestions for improvement. ## Histogram Libraries. - Implement the FLT_MAX mechanism for `THStack::GetMaximum()` and `THStack::GetMiniumum()`.; - Print a warning when the range given to `TAxis::SetRange` is invalid.; - Fix projection name in `TH3` as requested [here](https://root-forum.cern.ch/t/project3d-letter-d-in-name-option/57612). ## Parallelism; - The ROOT::Experimental::TFuture template has been removed. ## RooFit Libraries. ### New CPU likelihood evaluation backend by default. The new vectorizing CPU evaluation backend is not the default for RooFit likelihoods.; Li",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:6104,integrat,integration,6104,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['integrat'],['integration']
Integrability,"ive username among the available choices; if not; match is found the handshake does any longer fail, the first mapped; username is chosen instead.; In XrdProofd, allow 'xpd.allowedgroups' to control also PROOF; groups, not only UNIX ones.In XrdProofd, simplify error; messages in case of login failure because of non-authorization.; Remove hardcoded additions of dirname(COMPILER) and of; '/bin:/usr/bin:/usr/local/bin' in front of PATH. These uncontrolled; additions could hide specific settings in PATH and be the source of; weird problems appearing in PROOF only.; Add more flexibility to the definition of the library path seen by; proofserv. So far to avoid ambiguites in some cases, $ROOTSYS/lib was; removed and the one of the ROOT version chosen was added later on in; front, which proved to be to aggressive in some cases.; All changes (and fixes) needed to build against the version of Xrootd,; now always installed as external.; Fixes. Fix GetSessionLogs in PROOF-Lite; Restore correct parsing of ""workers=N"" in PROOF-Lite; In Proof-Bench, make sure that it can be run from any directory; and no matter how ROOT was installed; Fix issue in TProofPlayer::HandleHistogram preventing proper; histogram cleaning right after merging when using TH1::Add; histogram; were still destroyed at the end of the query, but there was no; memory advantage in TH1::Add wrt TH1::Merge.; Make sure that the performance tree is removed from the output; list when saved to the output file. Solves a segv at quit.; Decouple from registered TChains in already TProof::Close(); allows; to avoid possible crash at exit ('.q') occuring after the recent; revision of the socket cleanup policy.; In XrdProofd, fix a few issues with option 'xpd.multiuser'.; In TXSocket::ProcessUnsolicitedMsg, fix an issue preventig server; messages to be displayed during setup, i.e. when the XrdClientConn; instance is not yet defined.; In XrdProofd, fix the behavior of the 'xpd.allowedusers' and; 'xpd.allowedgroups' directives. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v532/index.html:4479,message,messages,4479,proof/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v532/index.html,2,['message'],['messages']
Integrability,"ive-C object pointer shall; not be converted to ``void*``. As an exception, cast to ``intptr_t`` is; allowed because such casts are not transferring ownership. The :ref:`bridged; casts <arc.objects.operands.casts>` may be used to perform these conversions; where necessary. .. admonition:: Rationale. We cannot ensure the correct management of the lifetime of objects if they; may be freely passed around as unmanaged types. The bridged casts are; provided so that the programmer may explicitly describe whether the cast; transfers control into or out of ARC. However, the following exceptions apply. .. _arc.objects.restrictions.conversion.with.known.semantics:. Conversion to retainable object pointer type of expressions with known semantics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. :when-revised:`[beginning Apple 4.0, LLVM 3.1]`; :revision:`These exceptions have been greatly expanded; they previously applied; only to a much-reduced subset which is difficult to categorize but which; included null pointers, message sends (under the given rules), and the various; global constants.`. An unbridged conversion to a retainable object pointer type from a type other; than a retainable object pointer type is ill-formed, as discussed above, unless; the operand of the cast has a syntactic form which is known retained, known; unretained, or known retain-agnostic. An expression is :arc-term:`known retain-agnostic` if it is:. * an Objective-C string literal,; * a load from a ``const`` system global variable of :ref:`C retainable pointer; type <arc.misc.c-retainable>`, or; * a null pointer constant. An expression is :arc-term:`known unretained` if it is an rvalue of :ref:`C; retainable pointer type <arc.misc.c-retainable>` and it is:. * a direct call to a function, and either that function has the; ``cf_returns_not_retained`` attribute or it is an :ref:`audited; <arc.misc.c-retainable.audit>` function that does not have the; ``cf_returns_retained`` ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:25682,message,message,25682,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['message'],['message']
Integrability,"izations---┴--- optimizations -┘. ┌-----------------------------------------------------------------------------------------------┐; │ │; │ source file │; │ │; └-----------------------------------------------------------------------------------------------┘; ┌---------------------------------------┐; │ │; │ │; │ imported code │; │ │; │ │; └---------------------------------------┘. It would be very unfortunate if we end up with worse performance after using modules.; The main concern is that when we compile a source file, the compiler needs to see the function body; of imported module units so that it can perform IPO (InterProcedural Optimization, primarily inlining; in practice) to optimize functions in current source file with the help of the information provided by; the imported module units.; In other words, the imported code would be processed again and again in importee units; by optimizations (including IPO itself).; The optimizations before IPO and the IPO itself are the most time-consuming part in whole compilation process.; So from this perspective, we might not be able to get the improvements described in the theory.; But we could still save the time for optimizations after IPO and the whole backend. Overall, at ``O0`` the implementations of functions defined in a module will not impact module users,; but at higher optimization levels the definitions of such functions are provided to user compilations for the; purposes of optimization (but definitions of these functions are still not included in the use's object file)-; this means the build speedup at higher optimization levels may be lower than expected given ``O0`` experience,; but does provide by more optimization opportunities. Interoperability with Clang Modules; -----------------------------------. We **wish** to support clang modules and standard c++ modules at the same time,; but the mixed using form is not well used/tested yet. Please file new github issues as you find interoperability problems.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:43675,interoperab,interoperability,43675,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['interoperab'],['interoperability']
Integrability,"ize, one needs to provide the interval range to find the minimum.; In the `Minimize` call, the maximum number of function calls, the relative and absolute tolerance must be provided. #### `ROOT::Math::GSLMInimizer1D`. This class wraps two different methods from the GSL.; The algorithms which can be chosen at construction time are *GOLDENSECTION*, which is the simplest method; but the slowest and *BRENT* (the default one) which combines the golden section with a parabolic interpolation.; The algorithm can be chosen as a different enumeration in the constructor:; * `ROOT::Math::Minim1D::kBRENT` for the Brent algorithm (default); * `ROOT::Math::Minim1D::kGOLDENSECTION` for the golden section algorithm. ```{.cpp}; // this makes class with the default Brent algorithm; ROOT::Math::GSLMinimizer1D minBrent;; // this make the class with the Golden Section algorithm; ROOT::Math::GSLMinimizer1D minGold(ROOT::Math::Minim1D::kGOLDENSECTION);; ```. The interface to set the function and to minimize is the same as in the case of the `BrentMinimizer1D`. #### Using the TF1 class. It is possible to perform the one-dimensional minimization/maximization of a function by using directly the function class in ROOT, `TF1` of the *Hist* library.; The minmization is implemented in `TF1` using the BrentMInimizer1D and available with the class member functions; * `TF1::GetMinimum`/`TF1::GetMaximum` to find the function minimum/maximum value; * `TF1::GetMinimumX`/`TF1::GetMaximumX` to find the x value corresponding at the function minimum. The interval to search for the minimum (the default is the `TF1` range), tolerance and maximum iterations can be provided as optional parameters of the; `TF1::GetMinimum/Maximum` functions. ### Multi-Dimensional Minimization. All the algorithms for multi-dimensional minimization are implementing the `ROOT::Math::Minimizer`; interface and they can be used in the same way and one can switch between minimizer at run-time.; The minimizer concrete class can be in d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:65702,interface,interface,65702,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['interface'],['interface']
Integrability,"ject, it generates the files needed by your build tool; (GNU make, Visual Studio, etc.) for building LLVM. If **you are a new contributor**, please start with the :doc:`GettingStarted`; page. This page is geared for existing contributors moving from the; legacy configure/make system. If you are really anxious about getting a functional LLVM build, go to the; `Quick start`_ section. If you are a CMake novice, start with `Basic CMake usage`_; and then go back to the `Quick start`_ section once you know what you are doing. The; `Options and variables`_ section is a reference for customizing your build. If; you already have experience with CMake, this is the recommended starting point. This page is geared towards users of the LLVM CMake build. If you're looking for; information about modifying the LLVM CMake build system you may want to see the; :doc:`CMakePrimer` page. It has a basic overview of the CMake language. .. _Quick start:. Quick start; ===========. We use here the command-line, non-interactive CMake interface. #. `Download <http://www.cmake.org/cmake/resources/software.html>`_ and install; CMake. Version 3.20.0 is the minimum required. #. Open a shell. Your development tools must be reachable from this shell; through the PATH environment variable. #. Create a build directory. Building LLVM in the source; directory is not supported. cd to this directory:. .. code-block:: console. $ mkdir mybuilddir; $ cd mybuilddir. #. Execute this command in the shell replacing `path/to/llvm/source/root` with; the path to the root of your LLVM source tree:. .. code-block:: console. $ cmake path/to/llvm/source/root. CMake will detect your development environment, perform a series of tests, and; generate the files required for building LLVM. CMake will use default values; for all build parameters. See the `Options and variables`_ section for; a list of build parameters that you can modify. This can fail if CMake can't detect your toolset, or if it thinks that the; environment is",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:1256,interface,interface,1256,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['interface'],['interface']
Integrability,ject/issues/78128>`_). - Clang now allows parenthesized initialization of arrays in `operator new[]`.; Fixes: (`#68198 <https://github.com/llvm/llvm-project/issues/68198>`_). - Fixes CTAD for aggregates on nested template classes. Fixes:; (`#77599 <https://github.com/llvm/llvm-project/issues/77599>`_). - Fix crash when importing the same module with an dynamic initializer twice; in different visibility.; Fixes (`#67893 <https://github.com/llvm/llvm-project/issues/67893>`_). - Remove recorded `#pragma once` state for headers included in named modules.; Fixes (`#77995 <https://github.com/llvm/llvm-project/issues/77995>`_). - Set the ``__cpp_auto_cast`` feature test macro in C++23 mode. - Fix crash for inconsistent deducing state of function return types; in importing modules.; Fixes (`#78830 <https://github.com/llvm/llvm-project/issues/78830>`_); Fixes (`#60085 <https://github.com/llvm/llvm-project/issues/60085>`_). - Fixed a bug where variables referenced by requires-clauses inside; nested generic lambdas were not properly injected into the constraint scope.; (`#73418 <https://github.com/llvm/llvm-project/issues/73418>`_). - Fix incorrect code generation caused by the object argument of ``static operator()`` and ``static operator[]`` calls not being evaluated.; Fixes (`#67976 <https://github.com/llvm/llvm-project/issues/67976>`_). - Fix crash when using an immediate-escalated function at global scope.; (`#82258 <https://github.com/llvm/llvm-project/issues/82258>`_); - Correctly immediate-escalate lambda conversion functions.; (`#82258 <https://github.com/llvm/llvm-project/issues/82258>`_); - Fix a crash when an unresolved overload set is encountered on the RHS of a ``.*`` operator.; (`#53815 <https://github.com/llvm/llvm-project/issues/53815>`_). - Fixed a regression in CTAD that a friend declaration that befriends itself may cause; incorrect constraint substitution.; (`#86769 <https://github.com/llvm/llvm-project/issues/86769>`_). Bug Fixes to AST Handling; ^^^^^^^^,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:55314,inject,injected,55314,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['inject'],['injected']
Integrability,"jectAtIndexedSubscript:(unsigned int)index;; @end. @interface MyClass : Subscriptable; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; id i = obj1[0]; // warn: uninitialized object pointer; }. core.DivideZero; (C, C++, ObjC); Check for division by zero.co. void test(int z) {; if (z == 0); int x = 1 / z; // warn; }. void test() {; int x = 1;; int y = x % 0; // warn; }. core.NonNullParamChecker; (C, C++, ObjC); Check for null pointers passed as arguments to a function whose arguments are; marked with the nonnull attribute. int f(int *p) __attribute__((nonnull));. void test(int *p) {; if (!p); f(p); // warn; }. core.NullDereference; (C, C++, ObjC); Check for dereferences of null pointers. // C; void test(int *p) {; if (p); return;. int x = p[0]; // warn; }. // C; void test(int *p) {; if (!p); *p = 0; // warn; }. // C++; class C {; public:; int x;; };. void test() {; C *pc = 0;; int k = pc->x; // warn; }. // Objective-C; @interface MyClass {; @public; int x;; }; @end. void test() {; MyClass *obj = 0;; obj->x = 1; // warn; }. core.StackAddressEscape; (C); Check that addresses of stack memory do not escape the function. char const *p;. void test() {; char const str[] = ""string"";; p = str; // warn; }. void* test() {; return __builtin_alloca(12); // warn; }. void test() {; static int *x;; int y;; x = &y; // warn; }. core.UndefinedBinaryOperatorResult; (C); Check for undefined results of binary operators. void test() {; int x;; int y = x + 1; // warn: left operand is garbage; }. core.VLASize; (C); Check for declarations of VLA of undefined or zero size. void test() {; int x;; int vla1[x]; // warn: garbage as size; }. void test() {; int x = 0;; int vla2[x]; // warn: zero size; }. core.uninitialized.ArraySubscript; (C); Check for uninitialized values used as array subscripts. void test() {; int i, a[10];; int x = a[i]; // warn: array subscript is undefined; }. core.uninitialized.Assign; (C); Check for assigning uninitialize",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:3503,interface,interface,3503,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,2,['interface'],['interface']
Integrability,"jects as input and; returns MustAlias, PartialAlias, MayAlias, or NoAlias as appropriate. Like all ``AliasAnalysis`` interfaces, the ``alias`` method requires that either; the two pointer values be defined within the same function, or at least one of; the values is a :ref:`constant <constants>`. .. _Must, May, or No:. Must, May, and No Alias Responses; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``NoAlias`` response may be used when there is never an immediate dependence; between any memory reference *based* on one pointer and any memory reference; *based* the other. The most obvious example is when the two pointers point to; non-overlapping memory ranges. Another is when the two pointers are only ever; used for reading memory. Another is when the memory is freed and reallocated; between accesses through one pointer and accesses through the other --- in this; case, there is a dependence, but it's mediated by the free and reallocation. As an exception to this is with the :ref:`noalias <noalias>` keyword;; the ""irrelevant"" dependencies are ignored. The ``MayAlias`` response is used whenever the two pointers might refer to the; same object. The ``PartialAlias`` response is used when the two memory objects are known to; be overlapping in some way, regardless whether they start at the same address; or not. The ``MustAlias`` response may only be returned if the two memory objects are; guaranteed to always start at exactly the same location. A ``MustAlias``; response does not imply that the pointers compare equal. The ``getModRefInfo`` methods; -----------------------------. The ``getModRefInfo`` methods return information about whether the execution of; an instruction can read or modify a memory location. Mod/Ref information is; always conservative: if an instruction **might** read or write a location,; ``ModRef`` is returned. The ``AliasAnalysis`` class also provides a ``getModRefInfo`` method for testing; dependencies between function calls. This method takes two call sites ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:5451,depend,dependencies,5451,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['depend'],['dependencies']
Integrability,"jemitter -c test.cl. Note that only very basic functionality is supported at this point and therefore; it is not suitable for arbitrary use cases. This feature is only enabled when clang; build is configured with ``-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=SPIRV`` option. Linking is done using ``spirv-link`` from `the SPIRV-Tools project; <https://github.com/KhronosGroup/SPIRV-Tools#linker>`_. Similar to other external; linkers, Clang will expect ``spirv-link`` to be installed separately and to be; present in the ``PATH`` environment variable. Please refer to `the build and; installation instructions; <https://github.com/KhronosGroup/SPIRV-Tools#build>`_. .. code-block:: console. $ clang --target=spirv64 test1.cl test2.cl. More information about the SPIR-V target settings and supported versions of SPIR-V; format can be found in `the SPIR-V target guide; <https://llvm.org/docs/SPIRVUsage.html>`__. .. _clang-cl:. clang-cl; ========. clang-cl is an alternative command-line interface to Clang, designed for; compatibility with the Visual C++ compiler, cl.exe. To enable clang-cl to find system headers, libraries, and the linker when run; from the command-line, it should be executed inside a Visual Studio Native Tools; Command Prompt or a regular Command Prompt where the environment has been set; up using e.g. `vcvarsall.bat <https://msdn.microsoft.com/en-us/library/f2ccy3wt.aspx>`_. clang-cl can also be used from inside Visual Studio by selecting the LLVM; Platform Toolset. The toolset is not part of the installer, but may be installed; separately from the; `Visual Studio Marketplace <https://marketplace.visualstudio.com/items?itemName=LLVMExtensions.llvm-toolchain>`_.; To use the toolset, select a project in Solution Explorer, open its Property; Page (Alt+F7), and in the ""General"" section of ""Configuration Properties""; change ""Platform Toolset"" to LLVM. Doing so enables an additional Property; Page for selecting the clang-cl executable to use for builds. To use the toolset wi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:168431,interface,interface,168431,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['interface'],['interface']
Integrability,"jor releases. The same applies to the; main development branch. It is therefore important to ensure the ``llvm-spirv``; version is in alignment with the Clang version. For troubleshooting purposes; ``llvm-spirv`` can be `tested in isolation; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator#test-instructions>`_. Example usage for OpenCL kernel compilation:. .. code-block:: console. $ clang --target=spirv32 -c test.cl; $ clang --target=spirv64 -c test.cl. Both invocations of Clang will result in the generation of a SPIR-V binary file; `test.o` for 32 bit and 64 bit respectively. This file can be imported; by an OpenCL driver that support SPIR-V consumption or it can be compiled; further by offline SPIR-V consumer tools. Converting to SPIR-V produced with the optimization levels other than `-O0` is; currently available as an experimental feature and it is not guaranteed to work; in all cases. Clang also supports integrated generation of SPIR-V without use of ``llvm-spirv``; tool as an experimental feature when ``-fintegrated-objemitter`` flag is passed in; the command line. .. code-block:: console. $ clang --target=spirv32 -fintegrated-objemitter -c test.cl. Note that only very basic functionality is supported at this point and therefore; it is not suitable for arbitrary use cases. This feature is only enabled when clang; build is configured with ``-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=SPIRV`` option. Linking is done using ``spirv-link`` from `the SPIRV-Tools project; <https://github.com/KhronosGroup/SPIRV-Tools#linker>`_. Similar to other external; linkers, Clang will expect ``spirv-link`` to be installed separately and to be; present in the ``PATH`` environment variable. Please refer to `the build and; installation instructions; <https://github.com/KhronosGroup/SPIRV-Tools#build>`_. .. code-block:: console. $ clang --target=spirv64 test1.cl test2.cl. More information about the SPIR-V target settings and supported versions of SPIR-V; format can be found in `the SP",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:167221,integrat,integrated,167221,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['integrat'],['integrated']
Integrability,"k prebuilt llvm/utils.; if(EXISTS ${LLVM_TOOLS_BINARY_DIR}/FileCheck${CMAKE_EXECUTABLE_SUFFIX}; AND EXISTS ${LLVM_TOOLS_BINARY_DIR}/count${CMAKE_EXECUTABLE_SUFFIX}; AND EXISTS ${LLVM_TOOLS_BINARY_DIR}/not${CMAKE_EXECUTABLE_SUFFIX}); set(LLVM_UTILS_PROVIDED ON); endif(). # Seek installed Lit.; find_program(LLVM_LIT; NAMES llvm-lit lit.py lit; PATHS ""${LLVM_MAIN_SRC_DIR}/utils/lit""; DOC ""Path to lit.py""). if(EXISTS ${LLVM_MAIN_SRC_DIR}/utils/lit/lit.py); # Note: path not really used, except for checking if lit was found; if(EXISTS ${LLVM_MAIN_SRC_DIR}/utils/llvm-lit); add_subdirectory(${LLVM_MAIN_SRC_DIR}/utils/llvm-lit utils/llvm-lit); endif(); if(NOT LLVM_UTILS_PROVIDED); add_subdirectory(${LLVM_MAIN_SRC_DIR}/utils/FileCheck utils/FileCheck); add_subdirectory(${LLVM_MAIN_SRC_DIR}/utils/count utils/count); add_subdirectory(${LLVM_MAIN_SRC_DIR}/utils/not utils/not); set(LLVM_UTILS_PROVIDED ON); set(CLANG_TEST_DEPS FileCheck count not); endif(); endif(). if (NOT TARGET llvm_gtest); message(FATAL_ERROR ""llvm-gtest not found. Please install llvm-gtest or disable tests with -DLLVM_INCLUDE_TESTS=OFF""); endif(). if(LLVM_LIT); # Define the default arguments to use with 'lit', and an option for the user; # to override.; set(LIT_ARGS_DEFAULT ""-sv""); if (MSVC OR XCODE); set(LIT_ARGS_DEFAULT ""${LIT_ARGS_DEFAULT} --no-progress-bar""); endif(); set(LLVM_LIT_ARGS ""${LIT_ARGS_DEFAULT}"" CACHE STRING ""Default options for lit""). get_errc_messages(LLVM_LIT_ERRC_MESSAGES). # On Win32 hosts, provide an option to specify the path to the GnuWin32 tools.; if( WIN32 AND NOT CYGWIN ); set(LLVM_LIT_TOOLS_DIR """" CACHE PATH ""Path to GnuWin32 tools""); endif(); else(); set(LLVM_INCLUDE_TESTS OFF); endif(). umbrella_lit_testsuite_begin(check-all); endif() # LLVM_INCLUDE_TESTS; endif() # standalone. # Make sure that our source directory is on the current cmake module path so that; # we can include cmake files from this directory.; list(INSERT CMAKE_MODULE_PATH 0; ""${CMAKE_CURRENT_SOURCE_DIR}/cmake/modu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:4172,message,message,4172,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,1,['message'],['message']
Integrability,"k shrinks for B, then for A:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE // Error! Set an error to E; AB // Set an error to B; A // Set an error to A. However, during the import we could import C and D without any error and they; are independent of A,B and E. We must not set up an error for C and D. So, at; the end of the import we have an entry in ``ImportDeclErrors`` for A,B,E but; not for C,D. Now, what happens if there is a cycle in the import path? Let's consider this; AST:. .. code-block:: text. A->B->C->A; `->E. During the visitation, we will have the below import paths and if during the; visit of E there is an error then we will set up an error for E,B,A. But what's; up with C?. .. code-block:: text. A; AB; ABC; ABCA; ABC; AB; ABE // Error! Set an error to E; AB // Set an error to B; A // Set an error to A. This time we know that both B and C are dependent on A. This means we must set; up an error for C too. As the call stack reverses back we get to A and we must; set up an error to all nodes which depend on A (this includes C). But C is no; longer on the import path, it just had been previously. Such a situation can; happen only if during the visitation we had a cycle. If we didn't have any; cycle, then the normal way of passing an Error object through the call stack; could handle the situation. This is why we must track cycles during the import; process for each visited declaration. Lookup Problems; ^^^^^^^^^^^^^^^. When we import a declaration from the source context then we check whether we; already have a structurally equivalent node with the same name in the ""to""; context. If the ""from"" node is a definition and the found one is also a; definition, then we do not create a new node, instead, we mark the found node; as the imported node. If the found definition and the one we want to import; have the same name but they are structurally in-equivalent, then we have an ODR; violation in case of C++. If the ""from"" node is not a definition then we add",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:103900,depend,depend,103900,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['depend'],['depend']
Integrability,"k traces. Therefore, it should be used with care,; and only if absolutely required; for example for certain code that cannot; tolerate any instrumentation and resulting side-effects. This attribute; overrides ``no_sanitize(""thread"")``. Ignorelist; ----------. ThreadSanitizer supports ``src`` and ``fun`` entity types in; :doc:`SanitizerSpecialCaseList`, that can be used to suppress data race reports; in the specified source files or functions. Unlike functions marked with; ``no_sanitize(""thread"")`` attribute, ignored functions are not instrumented; at all. This can lead to false positives due to missed synchronization via; atomic operations and missed stack frames in reports. Limitations; -----------. * ThreadSanitizer uses more real memory than a native run. At the default; settings the memory overhead is 5x plus 1Mb per each thread. Settings with 3x; (less accurate analysis) and 9x (more accurate analysis) overhead are also; available.; * ThreadSanitizer maps (but does not reserve) a lot of virtual address space.; This means that tools like ``ulimit`` may not work as usually expected.; * Libc/libstdc++ static linking is not supported.; * Non-position-independent executables are not supported. Therefore, the; ``fsanitize=thread`` flag will cause Clang to act as though the ``-fPIE``; flag had been supplied if compiling without ``-fPIC``, and as though the; ``-pie`` flag had been supplied if linking an executable. Current Status; --------------. ThreadSanitizer is in beta stage. It is known to work on large C++ programs; using pthreads, but we do not promise anything (yet). C++11 threading is; supported with llvm libc++. The test suite is integrated into CMake build; and can be run with ``make check-tsan`` command. We are actively working on enhancing the tool --- stay tuned. Any help,; especially in the form of minimized standalone tests is more than welcome. More Information; ----------------; `<https://github.com/google/sanitizers/wiki/ThreadSanitizerCppManual>`_; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst:4905,integrat,integrated,4905,interpreter/llvm-project/clang/docs/ThreadSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst,1,['integrat'],['integrated']
Integrability,"ke file.; set(LLVM_EXPORTS_FILE ${llvm_cmake_builddir}/LLVMExports.cmake); get_property(LLVM_EXPORTS GLOBAL PROPERTY LLVM_EXPORTS); export(TARGETS ${LLVM_EXPORTS} FILE ${LLVM_EXPORTS_FILE}). # Then for users who want to link against the LLVM build tree, provide the; # normal targets and the build tree only targets.; set(LLVM_BUILDTREEONLY_EXPORTS_FILE ${llvm_cmake_builddir}/LLVMBuildTreeOnlyTargets.cmake); get_property(LLVM_EXPORTS_BUILDTREE_ONLY GLOBAL PROPERTY LLVM_EXPORTS_BUILDTREE_ONLY); export(TARGETS ${LLVM_EXPORTS_BUILDTREE_ONLY} FILE ${LLVM_BUILDTREEONLY_EXPORTS_FILE}). get_property(LLVM_AVAILABLE_LIBS GLOBAL PROPERTY LLVM_LIBS). foreach(lib ${LLVM_AVAILABLE_LIBS}); get_property(llvm_lib_deps GLOBAL PROPERTY LLVMBUILD_LIB_DEPS_${lib}); set(all_llvm_lib_deps; ""${all_llvm_lib_deps}\nset_property(GLOBAL PROPERTY LLVMBUILD_LIB_DEPS_${lib} ${llvm_lib_deps})""); endforeach(lib). # CMake requires that all targets expressed as dependencies exist, so we can't; # have intrinsics_gen in LLVM_COMMON_DEPENDS when it is written out, otherwise; # projects building out of tree will have CMake errors. This only gets hit when; # LLVM_ENABLE_MODULES=On. Eventually we should come up with a better solution to; # this, but there is no easy solution.; if(intrinsics_gen IN_LIST LLVM_COMMON_DEPENDS); list(REMOVE_ITEM LLVM_COMMON_DEPENDS intrinsics_gen); endif(); if(omp_gen IN_LIST LLVM_COMMON_DEPENDS); list(REMOVE_ITEM LLVM_COMMON_DEPENDS omp_gen); endif(). #; # Generate LLVMConfig.cmake for the build tree.; #. set(LLVM_CONFIG_CODE ""; # LLVM_BUILD_* values available only from LLVM build tree.; set(LLVM_BUILD_BINARY_DIR \""${LLVM_BINARY_DIR}\""); set(LLVM_BUILD_LIBRARY_DIR \""${LLVM_LIBRARY_DIR}\""); set(LLVM_BUILD_MAIN_INCLUDE_DIR \""${LLVM_MAIN_INCLUDE_DIR}\""); set(LLVM_BUILD_MAIN_SRC_DIR \""${LLVM_MAIN_SRC_DIR}\""); ""). set(LLVM_CONFIG_MAIN_INCLUDE_DIR ""${LLVM_MAIN_INCLUDE_DIR}""); set(LLVM_CONFIG_INCLUDE_DIR ""${LLVM_INCLUDE_DIR}""); set(LLVM_CONFIG_INCLUDE_DIRS; ""${LLVM_CONFIG_MAIN_INCLUDE",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/cmake/modules/CMakeLists.txt:1313,depend,dependencies,1313,interpreter/llvm-project/llvm/cmake/modules/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/cmake/modules/CMakeLists.txt,1,['depend'],['dependencies']
Integrability,"ke:. .. code-block:: c++. if (auto Err =; handleErrors(; processFormattedFile(...),; [](const BadFileFormat &BFF) {; report(""Unable to process "" + BFF.Path + "": bad format"");; },; [](const FileNotFound &FNF) {; report(""File not found "" + FNF.Path);; })); return Err;. In cases where you truly know that the handler list is exhaustive the; ``handleAllErrors`` function can be used instead. This is identical to; ``handleErrors`` except that it will terminate the program if an unhandled; error is passed in, and can therefore return void. The ``handleAllErrors``; function should generally be avoided: the introduction of a new error type; elsewhere in the program can easily turn a formerly exhaustive list of errors; into a non-exhaustive list, risking unexpected program termination. Where; possible, use handleErrors and propagate unknown errors up the stack instead. For tool code, where errors can be handled by printing an error message then; exiting with an error code, the :ref:`ExitOnError <err_exitonerr>` utility; may be a better choice than handleErrors, as it simplifies control flow when; calling fallible functions. In situations where it is known that a particular call to a fallible function; will always succeed (for example, a call to a function that can only fail on a; subset of inputs with an input that is known to be safe) the; :ref:`cantFail <err_cantfail>` functions can be used to remove the error type,; simplifying control flow. StringError; """""""""""""""""""""". Many kinds of errors have no recovery strategy, the only action that can be; taken is to report them to the user so that the user can attempt to fix the; environment. In this case representing the error as a string makes perfect; sense. LLVM provides the ``StringError`` class for this purpose. It takes two; arguments: A string error message, and an equivalent ``std::error_code`` for; interoperability. It also provides a ``createStringError`` function to simplify; common usage of this class:. .. code-block:: c++",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:26079,message,message,26079,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['message'],['message']
Integrability,"ker symbols*.; All cppyy uses, the basic and the more advanced, are variations on the; theme of bringing these two together at the point of use. Definitions typically live in header files and symbols in libraries.; Headers can be loaded with ``cppyy.include`` and libraries with the; ``cppyy.load_library`` call.; Loading the header is sufficient to start exploring, with ``cppyy.gbl`` the; starting point of all things C++, while the linker symbols are only needed at ; the point of first use. Here is an example using the `zlib`_ library, which is likely available on; your system:. .. code-block:: python. >>> import cppyy; >>> cppyy.include('zlib.h') # bring in C++ definitions; >>> cppyy.load_library('libz') # load linker symbols; >>> cppyy.gbl.zlibVersion() # use a zlib API; '1.2.11'; >>>. Since header files can include other header files, it is easy to aggregate; all relevant ones into a single header to include.; If there are project-specific include paths, you can add those paths through; ``cppyy.add_include_path``.; If a header is C-only and not set for use with C++, use ``cppyy.c_include``,; which adds ``extern ""C""`` around the header. Library files can be aggregated by linking all relevant ones to a single; library to load.; Using the linker for this purpose allows regular system features such as; ``rpath`` and envars such as ``LD_LIBRARY_PATH`` to be applied as usual.; Note that any mechanism that exposes the library symbols will work.; For example, you could also use the standard module ``ctypes`` through; ``ctypes.CDLL`` with the ``ctypes.RTLD_GLOBAL`` option. To explore, start from ``cppyy.gbl`` to access your namespaces, classes,; functions, etc., etc. directly; or use python's ``dir`` (or tab-completion); to see what is available.; Use python's ``help`` to see list the methods and data members of classes and; see the interfaces of functions. Now try this out for some of your own headers, libraries, and APIs!. .. _`zlib`: https://en.wikipedia.org/wiki/Zlib; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/starting.rst:2740,interface,interfaces,2740,bindings/pyroot/cppyy/cppyy/doc/source/starting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/starting.rst,1,['interface'],['interfaces']
Integrability,"ket and ask the socket to receive; input. ``` {.cpp}; { // client; TSocket *socket = new TSocket(""localhost"",9090);; Char str[32];; socket->Recv(str,32);; }; ```. ## Sending Objects over the Network. We have just established a connection and you just saw how to send and; receive a string with the example ""go"". Now let's send a histogram. *To send an object (in our case on the client side*) it has to derive; from **`TObject`** class because it uses the `Streamers` to fill a; buffer that is then sent over the connection. On the receiving side, the; `Streamers` are used to read the object from the message sent via the; socket. For network communication, we have a specialized **`TBuffer`**,; a descendant of **`TBuffer`** called **`TMessage`**. In the following; example, we create a **`TMessage`** with the intention to store an; object, hence the constant `kMESS_OBJECT` in the constructor. We create; and fill the histogram and write it into the message. Then we call; **`TSocket`**`::Send` to send the message with the histogram. ``` {.cpp}; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; socket->Send(message);; ...; ```. On the receiving end (in our case the server side), we write a while; loop to wait and receive a message with a histogram. Once we have a; message, we call `TMessage::ReadObject`, which returns a pointer to; **`TObject`**. We have to cast it to a **`TH1`** pointer, and now we; have a histogram. At the end of the loop, the message is deleted, and; another one is created at the beginning. ``` {.cpp}; while (1) {; TMessage *message;; socket->Recv(message);; TH1 *h = (TH1*)message->ReadObject(message->GetClass());; delete message;; }; ```. ## Closing the Connection. Once we are done sending objects, we close the conn",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md:1663,message,message,1663,documentation/users-guide/Networking.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md,1,['message'],['message']
Integrability,known. 1428; CD3; Dynamic const objects; Unknown. 1429; NAD; Scope of a member template's template parameter; Unknown. 1430; open; Pack expansion into fixed alias template parameter list; Not resolved. 1431; CD3; Exceptions from other than throw-expressions; Unknown. 1432; C++17; Newly-ambiguous variadic template expansions; Clang 16. 1433; NAD; trailing-return-type and point of declaration; Unknown. 1434; NAD; Parenthesized braced-init-list; Unknown. 1435; CD3; template-id as the declarator for a class template constructor; Unknown. 1436; open; Interaction of constant expression changes with preprocessor expressions; Not resolved. 1437; CD3; alignas in alias-declaration; Unknown. 1438; CD3; Non-dereference use of invalid pointers; Unknown. 1439; CD3; Lookup and friend template declarations; Unknown. 1440; CD3; Acceptable decltype-specifiers used as nested-name-specifiers; Unknown. 1441; C++14; Unclear wording for signal handler restrictions; Unknown. 1442; CD3; Argument-dependent lookup in the range-based for; Unknown. 1443; NAD; Default arguments and non-static data members; Yes. 1444; drafting; Type adjustments of non-type template parameters; Not resolved. 1445; dup; Argument-dependent lookup of begin and end; Unknown. 1446; CD4; Member function with no ref-qualifier and non-member function with rvalue reference; Unknown. 1447; CD3; static_cast of bit-field lvalue to rvalue reference; Unknown. 1448; NAD; Integral values of type bool; Unknown. 1449; CD3; Narrowing conversion of negative value to unsigned type; Unknown. 1450; CD3; INT_MIN % -1; Unknown. 1451; CD4; Objects with no linkage in non-type template arguments; Unknown. 1452; NAD; Value-initialized objects may be constants; Unknown. 1453; CD3; Volatile members in literal classes?; Unknown. 1454; CD3; Passing constants through constexpr functions via references; Unknown. 1455; CD3; Lvalue converted constant expressions; Unknown. 1456; CD3; Address constant expression designating the one-past-the-end address,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:96898,depend,dependent,96898,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['depend'],['dependent']
Integrability,"ks best when loops have; been canonicalized by the :ref:`indvars <passes-indvars>` pass, allowing it to; determine the trip counts of loops easily. ``loop-unroll-and-jam``: Unroll and Jam loops; ---------------------------------------------. This pass implements a simple unroll and jam classical loop optimisation pass.; It transforms loop from:. .. code-block:: c++. for i.. i+= 1 for i.. i+= 4; for j.. for j..; code(i, j) code(i, j); code(i+1, j); code(i+2, j); code(i+3, j); remainder loop. Which can be seen as unrolling the outer loop and ""jamming"" (fusing) the inner; loops into one. When variables or loads can be shared in the new inner loop, this; can lead to significant performance improvements. It uses; :ref:`Dependence Analysis <passes-da>` for proving the transformations are safe. ``lower-global-dtors``: Lower global destructors; ------------------------------------------------. This pass lowers global module destructors (``llvm.global_dtors``) by creating; wrapper functions that are registered as global constructors in; ``llvm.global_ctors`` and which contain a call to ``__cxa_atexit`` to register; their destructor functions. ``loweratomic``: Lower atomic intrinsics to non-atomic form; -----------------------------------------------------------. This pass lowers atomic intrinsics to non-atomic form for use in a known; non-preemptible environment. The pass does not verify that the environment is non-preemptible (in general; this would require knowledge of the entire call graph of the program including; any libraries which may not be available in bitcode form); it simply lowers; every atomic intrinsic. ``lowerinvoke``: Lower invokes to calls, for unwindless code generators; -----------------------------------------------------------------------. This transformation is designed for use by code generators which do not yet; support stack unwinding. This pass converts ``invoke`` instructions to; ``call`` instructions, so that any exception-handling ``landingpad`` b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:28979,wrap,wrapper,28979,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['wrap'],['wrapper']
Integrability,"ks; operate in the LLVM backed can be found in LLVM's documentation. By default MisExpect checking is quite strict, because the use of the; ``llvm.expect`` intrinsic is designed for specialized cases, where the outcome; of a condition is severely skewed. As a result, the optimizer can be extremely; aggressive, which can result in performance degradation if the outcome is less; predictable than the annotation suggests. Even when the annotation is correct; 90% of the time, it may be beneficial to either remove the annotation or to use; a different intrinsic that can communicate the probability more directly. Because this may be too strict, MisExpect diagnostics are not enabled by; default, and support an additional flag to tolerate some deviation from the; exact thresholds. The ``-fdiagnostic-misexpect-tolerance=N`` accepts; deviations when comparing branch weights within ``N%`` of the expected values.; So passing ``-fdiagnostic-misexpect-tolerance=5`` will not report diagnostic messages; if the branch weight from the profile is within 5% of the weight added by; the ``llvm.expect`` intrinsic. MisExpect diagnostics are also available in the form of optimization remarks,; which can be serialized and processed through the ``opt-viewer.py``; scripts in LLVM. .. option:: -Rpass=misexpect. Enables optimization remarks for misexpect when profiling data conflicts with; use of ``llvm.expect`` intrinsics. .. option:: -Wmisexpect. Enables misexpect warnings when profiling data conflicts with use of; ``llvm.expect`` intrinsics. .. option:: -fdiagnostic-misexpect-tolerance=N. Relaxes misexpect checking to tolerate profiling values within N% of the; expected branch weight. e.g., a value of ``N=5`` allows misexpect to check against; ``0.95 * Threshold``. LLVM supports 4 types of profile formats: Frontend, IR, CS-IR, and; Sampling. MisExpect Diagnostics are compatible with all Profiling formats. +----------------+------------------------------------------------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MisExpect.rst:2003,message,messages,2003,interpreter/llvm-project/clang/docs/MisExpect.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MisExpect.rst,1,['message'],['messages']
Integrability,"l *ret_label);. If a function defined in the translation unit being compiled belongs to the; ``uninstrumented`` category, it will be compiled so as to conform to the; native ABI. Its arguments will be assumed to be unlabelled, but it will; propagate labels in shadow memory. For example:. .. code-block:: none. # main is called by the C runtime using the native ABI.; fun:main=uninstrumented; fun:main=discard. # malloc only writes to its internal data structures, not user-accessible memory.; fun:malloc=uninstrumented; fun:malloc=discard. # tolower is a pure function.; fun:tolower=uninstrumented; fun:tolower=functional. # memcpy needs to copy the shadow from the source to the destination region.; # This is done in a custom function.; fun:memcpy=uninstrumented; fun:memcpy=custom. For instrumented functions, the ABI list supports a ``force_zero_labels``; category, which will make all stores and return values set zero labels.; Functions should never be labelled with both ``force_zero_labels``; and ``uninstrumented`` or any of the uninstrumented wrapper kinds. For example:. .. code-block:: none. # e.g. void writes_data(char* out_buf, int out_buf_len) {...}; # Applying force_zero_labels will force out_buf shadow to zero.; fun:writes_data=force_zero_labels. Compilation Flags; -----------------. * ``-dfsan-abilist`` -- The additional ABI list files that control how shadow; parameters are passed. File names are separated by comma.; * ``-dfsan-combine-pointer-labels-on-load`` -- Controls whether to include or; ignore the labels of pointers in load instructions. Its default value is true.; For example:. .. code-block:: c++. v = *p;. If the flag is true, the label of ``v`` is the union of the label of ``p`` and; the label of ``*p``. If the flag is false, the label of ``v`` is the label of; just ``*p``. * ``-dfsan-combine-pointer-labels-on-store`` -- Controls whether to include or; ignore the labels of pointers in store instructions. Its default value is; false. For example:. .. co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:5508,wrap,wrapper,5508,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,1,['wrap'],['wrapper']
Integrability,"l FileSizeParser::parse(cl::Option &O, StringRef ArgName,; const std::string &Arg, unsigned &Val) {; const char *ArgStart = Arg.c_str();; char *End;. // Parse integer part, leaving 'End' pointing to the first non-integer char; Val = (unsigned)strtol(ArgStart, &End, 0);. while (1) {; switch (*End++) {; case 0: return false; // No error; case 'i': // Ignore the 'i' in KiB if people use that; case 'b': case 'B': // Ignore B suffix; break;. case 'g': case 'G': Val *= 1024*1024*1024; break;; case 'm': case 'M': Val *= 1024*1024; break;; case 'k': case 'K': Val *= 1024; break;. default:; // Print an error message if unrecognized character!; return O.error(""'"" + Arg + ""' value invalid for file size argument!"");; }; }; }. This function implements a very simple parser for the kinds of strings we are; interested in. Although it has some holes (it allows ""``123KKK``"" for example),; it is good enough for this example. Note that we use the option itself to print; out the error message (the ``error`` method always returns true) in order to get; a nice error message (shown below). Now that we have our parser class, we can; use it like this:. .. code-block:: c++. static cl::opt<unsigned, false, FileSizeParser>; MFS(""max-file-size"", cl::desc(""Maximum file size to accept""),; cl::value_desc(""size""));. Which adds this to the output of our program:. ::. OPTIONS:; -help - display available options (-help-hidden for more); ...; -max-file-size=<size> - Maximum file size to accept. And we can test that our parse works correctly now (the test program just prints; out the max-file-size argument value):. ::. $ ./test; MFS: 0; $ ./test -max-file-size=123MB; MFS: 128974848; $ ./test -max-file-size=3G; MFS: 3221225472; $ ./test -max-file-size=dog; -max-file-size option: 'dog' value invalid for file size argument!. It looks like it works. The error message that we get is nice and helpful, and; we seem to accept reasonable file sizes. This wraps up the ""custom parser""; tutorial. Exploiting external ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:65432,message,message,65432,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,2,['message'],['message']
Integrability,"l ROOT Facility classes. - `libPython` provides the interface to Python. - \*`libRFIO` is the interface to CERN RFIO remote I/O system. - \*`libRGL` is the interface to OpenGL. - `libReflex` is the runtime type database library used by Cling. - `libRint` is the interactive interface to ROOT (provides command; prompt). - `libRIO` provides the functionality to write and read objects to; and from ROOT files. - `libRooFit` is the RooFit fitting framework. - `libRuby` is the interface to Ruby. - `libSpectrum` provides functionality for spectral analysis. - \*`libThread` is the interface to TThread classes. - `libTMVA` contains the multivariate analysis toolkit. - `libTree` is the TTree object container system. - `libTreePlayer` is the TTree drawing classes. - `libTreeViewer` is the graphical TTree query interface. #### Library Dependencies. ![ROOT libraries dependencies](pictures/03000005.png). The libraries are designed and organized to minimize dependencies,; such that you can load just enough code for the task at hand rather; than having to load all libraries or one monolithic chunk. The core; library (`libCore.so`) contains the essentials; it is a part of all; ROOT applications. In the Figure 1-2 you see that libCore.so is made; up of base classes, container classes, meta information classes,; operating system specific classes, and the ZIP algorithm used for; compression of the ROOT files. The Cling library (`libCling.so`) is also needed in all ROOT; applications, and even by `libCore`. A; program referencing only **`TObject`** only needs `libCore`;; `libCling` will be opened automatically. To add the ability to read and write; ROOT objects one also has to load `libRIO`. As one would expect, none of that; depends on graphics or the GUI. Library dependencies have different consequences; depending on whether; you try to build a binary, or you just try to access a class that is; defined in a library. #### Linktime Library Dependencies. When building your own executable ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:16074,depend,dependencies,16074,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['depend'],['dependencies']
Integrability,"l clone of the; # repository is found, refuse to update it unless the `FORCE` option is in place.; function(relatedrepo_Checkout); cmake_parse_arguments(_ ""FORCE"" ""REPO_NAME;FETCHURL;FETCHREF;REPO_DIR_VARIABLE"" """" ${ARGN}). # Check whether the repository exists in the source directory or its parent; get_filename_component(source_dir ${CMAKE_CURRENT_SOURCE_DIR} REALPATH); if(IS_DIRECTORY ${source_dir}/${__REPO_NAME}); set(repo_dir ${source_dir}/${__REPO_NAME}); elseif(IS_DIRECTORY ${source_dir}/../${__REPO_NAME}); set(repo_dir ${source_dir}/../${__REPO_NAME}); endif(). if(NOT DEFINED repo_dir); message(STATUS ""Cloning ${__REPO_NAME} from '${__FETCHURL}' (${__FETCHREF})""); if(NOT ""${__FETCHREF}"" STREQUAL """"); string(PREPEND __FETCHREF ""-b""); endif(); execute_process(COMMAND ${GIT_EXECUTABLE} clone ${__FETCHREF} ${__FETCHURL}; WORKING_DIRECTORY ${source_dir}); set(repo_dir ${source_dir}/${__REPO_NAME}); else(); message(STATUS ""Found ${__REPO_NAME}: ${repo_dir}""); if(${__FORCE}); message(STATUS ""Updating ${__REPO_NAME} from '${__FETCHURL}' (${__FETCHREF})""); execute_process(COMMAND ${GIT_EXECUTABLE} fetch -fu ${__FETCHURL} ${__FETCHREF}:${__FETCHREF}; WORKING_DIRECTORY ${repo_dir}); execute_process(COMMAND ${GIT_EXECUTABLE} checkout -f ${__FETCHREF}; WORKING_DIRECTORY ${repo_dir}); endif(); endif(); if(DEFINED __REPO_DIR_VARIABLE); set(${__REPO_DIR_VARIABLE} ${repo_dir} PARENT_SCOPE); endif(); endfunction(). #---Enable asserts------------------------------------------------------------------------------; if(asserts); string(REGEX REPLACE ""-[UD]NDEBUG(=.*)?"" """" ""CMAKE_CXX_FLAGS_${_BUILD_TYPE_UPPER}"" ""${CMAKE_CXX_FLAGS_${_BUILD_TYPE_UPPER}}""); string(REGEX REPLACE ""-[UD]NDEBUG(=.*)?"" """" ""CMAKE_C_FLAGS_${_BUILD_TYPE_UPPER}"" ""${CMAKE_C_FLAGS_${_BUILD_TYPE_UPPER}}""); endif(). #---Enable CCache ------------------------------------------------------------------------------; if(ccache); find_program(CCACHE_COMMAND NAMES ccache ccache-swig); mark_as_advanced(CCACHE_COMMAND ${CCAC",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt:7383,message,message,7383,CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt,3,['message'],['message']
Integrability,"l data structure may use an integer for time (seconds since; some epoch), but in YAML it would be much nicer to express that integer in; some time format (e.g. 4-May-2012 10:30pm). YAML I/O has a way to support; custom formatting and parsing of scalar types by specializing ScalarTraits<> on; your data type. When writing, YAML I/O will provide the native type and; your specialization must create a temporary llvm::StringRef. When reading,; YAML I/O will provide an llvm::StringRef of scalar and your specialization; must convert that to your native data type. An outline of a custom scalar type; looks like:. .. code-block:: c++. using llvm::yaml::ScalarTraits;; using llvm::yaml::IO;. template <>; struct ScalarTraits<MyCustomType> {; static void output(const MyCustomType &value, void*,; llvm::raw_ostream &out) {; out << value; // do custom formatting here; }; static StringRef input(StringRef scalar, void*, MyCustomType &value) {; // do custom parsing here. Return the empty string on success,; // or an error message on failure.; return StringRef();; }; // Determine if this scalar needs quotes.; static QuotingType mustQuote(StringRef) { return QuotingType::Single; }; };. Block Scalars; -------------. YAML block scalars are string literals that are represented in YAML using the; literal block notation, just like the example shown below:. .. code-block:: yaml. text: |; First line; Second line. The YAML I/O library provides support for translating between YAML block scalars; and specific C++ types by allowing you to specialize BlockScalarTraits<> on; your data type. The library doesn't provide any built-in support for block; scalar I/O for types like std::string and llvm::StringRef as they are already; supported by YAML I/O and use the ordinary scalar notation by default. BlockScalarTraits specializations are very similar to the; ScalarTraits specialization - YAML I/O will provide the native type and your; specialization must create a temporary llvm::StringRef when writing, an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst:13216,message,message,13216,interpreter/llvm-project/llvm/docs/YamlIO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst,1,['message'],['message']
Integrability,"l enumeration names defining the type of numerical algorithms. The names start with k, like kADAPTIVE for the integration type. This change affects both MathCore and MathMore and it breaks backward compatibility. MathCore Function interfaces; Mathcore provides as well interfaces for the evaluation of mathematical and parametric functions to be used in the numerical methods. This release contains the following changes:. The ROOT::Math::IParamFunction, ROOT::Math::IParamMultiFunction interfaces (used mainly for fitting) require now a pointer to the parameters (type const double *), when evaluating the function. The derived classes must implement now the const; method DoEvalPar (and not DoEval as before). In addition the method; operator()(const double * x, const double * p) is now const. This change makes the caching of parameter not hidden and the interface is now; thread-safe. ; A similar change in the ROOT::Math::IParamGradFunction, ROOT::Math::IParamMultiGradFunction interfaces, where the parameter values are now required for calculating the partial derivatives with respect to the parameters.; This changes the signature of the pure abstract method, DoParameterDerivative(const double *x, const double * p, , which takes also a pointer (type const double *) to the parameters.; In addition, these classes do not inherit anymore from the function gradient interface (ROOT::Math::IGradFunction and ROOT::Math::IMultiGradFunction). They define only the parameter gradient which is needed for fitting and not the coordinate gradient. A derived class, like ROOT::Math::Polynomial, implementing both functionality (coordinate and parameter gradient) inherits then from both interfaces.; . More detailed description of the current MathCore release can be found at this location. MathMore; This new release contains:. Modify and rename the class ROOT::Math::RootFinder to ROOT::Math::GSLRootFinder to distinguish from the main interface class which has been put in the Mathcore library and",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:9473,interface,interfaces,9473,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,2,['interface'],['interfaces']
Integrability,"l for its machine code entry point. .. _amdgpu-relocation-records:. Relocation Records; ------------------. The AMDGPU backend generates ``Elf64_Rela`` relocation records for; AMDHSA or ``Elf64_Rel`` relocation records for Mesa/AMDPAL. Supported; relocatable fields are:. ``word32``; This specifies a 32-bit field occupying 4 bytes with arbitrary byte; alignment. These values use the same byte order as other word values in the; AMDGPU architecture. ``word64``; This specifies a 64-bit field occupying 8 bytes with arbitrary byte; alignment. These values use the same byte order as other word values in the; AMDGPU architecture. Following notations are used for specifying relocation calculations:. **A**; Represents the addend used to compute the value of the relocatable field. If; the addend field is smaller than 64 bits then it is zero-extended to 64 bits; for use in the calculations below. (In practice this only affects ``_HI``; relocation types on Mesa/AMDPAL, where the addend comes from the 32-bit field; but the result of the calculation depends on the high part of the full 64-bit; address.). **G**; Represents the offset into the global offset table at which the relocation; entry's symbol will reside during execution. **GOT**; Represents the address of the global offset table. **P**; Represents the place (section offset for ``et_rel`` or address for ``et_dyn``); of the storage unit being relocated (computed using ``r_offset``). **S**; Represents the value of the symbol whose index resides in the relocation; entry. Relocations not using this must specify a symbol index of; ``STN_UNDEF``. **B**; Represents the base address of a loaded executable or shared object which is; the difference between the ELF address and the actual load address.; Relocations using this are only valid in executable or shared objects. The following relocation types are supported:. .. table:: AMDGPU ELF Relocation Records; :name: amdgpu-elf-relocation-records-table. ========================== =====",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:80342,depend,depends,80342,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['depend'],['depends']
Integrability,"l program path of name. .. option:: -print-search-dirs. Print the paths used for finding libraries and programs. .. option:: -save-temps. Save intermediate compilation results. .. option:: -save-stats, -save-stats=cwd, -save-stats=obj. Save internal code generation (LLVM) statistics to a file in the current; directory (:option:`-save-stats`/""-save-stats=cwd"") or the directory; of the output file (""-save-state=obj""). You can also use environment variables to control the statistics reporting.; Setting ``CC_PRINT_INTERNAL_STAT`` to ``1`` enables the feature, the report; goes to stdout in JSON format. Setting ``CC_PRINT_INTERNAL_STAT_FILE`` to a file path makes it report; statistics to the given file in the JSON format. Note that ``-save-stats`` take precedence over ``CC_PRINT_INTERNAL_STAT``; and ``CC_PRINT_INTERNAL_STAT_FILE``. .. option:: -integrated-as, -no-integrated-as. Used to enable and disable, respectively, the use of the integrated; assembler. Whether the integrated assembler is on by default is target; dependent. .. option:: -time. Time individual commands. .. option:: -ftime-report. Print timing summary of each stage of compilation. .. option:: -v. Show commands to run and use verbose output. Diagnostics Options; ~~~~~~~~~~~~~~~~~~~. .. option:: -fshow-column, -fshow-source-location, -fcaret-diagnostics, -fdiagnostics-fixit-info, -fdiagnostics-parseable-fixits, -fdiagnostics-print-source-range-info, -fprint-source-range-info, -fdiagnostics-show-option, -fmessage-length. These options control how Clang prints out information about diagnostics; (errors and warnings). Please see the Clang User's Manual for more information. Preprocessor Options; ~~~~~~~~~~~~~~~~~~~~. .. option:: -D<macroname>=<value>. Adds an implicit #define into the predefines buffer which is read before the; source file is preprocessed. .. option:: -U<macroname>. Adds an implicit #undef into the predefines buffer which is read before the; source file is preprocessed. .. option:: -include <f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:18198,integrat,integrated,18198,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,2,"['depend', 'integrat']","['dependent', 'integrated']"
Integrability,"l properties changes are undoable. The mixture editor; currently allows adding elements one by one in the mixture composition.; This can be done either by element weight fraction or by number of; atoms. Once an element was added using one method the other method is not; selectable anymore. Summing component fractions up to 1 in the final; mixture is the user responsibility. Adding materials as components of a; mixture is not supported in this version. The elements that were added to the mixture appear in the bottom of the; mixture editor. The operations performed on mixture are not undoable. ### Creation of New Objects. As described above, all geometry object creators are accessible within; the geometry manager editor frame. Generally, if the new object that; needs to be created does not depend on other objects, it will be built; with a set of default parameters. This is the case for all shapes; (except composite shapes) and matrices. For all the other objects the; interface forces the selection of components before creating the object. ### Editing Volumes. Volumes are hierarchical components in the geometry, therefore their; editor is more complex. It provides the following functionalities:. - *General*. This category allows changing the name of the volume and; selecting other shape or medium among existing ones. - *Daughters*. The category allows removing existing daughter nodes or; adding new ones. The button ""*Position*"" allows editing the; positioning matrix of a given node. ![Setting volume properties and modifying volume hierarchy](pictures/020001F5.jpg); ![Setting volume properties and modifying volume hierarchy](pictures/020001F6.jpg). - *Visualization*. This category allows changing the visibility of the; edited volume or for its daughters, as well as other visualization; settings. The radio button ""*All*"" allows viewing all volumes down; to the selected depth. ""*Leaves*"" will draw only the deepest nodes; that have the selected depth or lower level ones th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:172142,interface,interface,172142,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['interface'],['interface']
Integrability,"l snippet of code - aka a script. This can be done in cling by inserting the bash-like style line: ; . #!/usr/bin/cling; . Rapid Application Development (RAD) . ; Cling can be used successfully for Rapid Application Development allowing for prototyping and proofs of concept taking advantage of dynamicity and feedback during the implementation process.; . Runtime-Generated Code ; ; Sometime it's convenient to create code as a reaction to input; (user/network/configuration).; Runtime-generated code can interface with C++ libraries.; . Embedding Cling . The functionality of an application can be enriched by embedding Cling. To embed Cling, the main program has to be provided. One of the things this main program has to do is initialize the Cling interpreter. There are optional calls to pass command line arguments to Cling. Afterwards, you can call the interpreter from any anywhere within the application. For compilation and linkage the application needs the path to the clang and llvm libraries and the invocation is order dependent since the linker cannot do backward searches. g++ embedcling.cxx -std=c++11 -L/usr/local/lib; -lclingInterpreter -lclingUtils ; -lclangFrontend -lclangSerialization -lclangParse -lclangSema ; -lclangAnalysis -lclangEdit -lclangLex -lclangDriver -lclangCodeGen ; -lclangBasic -lclangAST ; `llvm-config ; --libs bitwriter mcjit orcjit native option ; ipo profiledata instrumentation objcarcopts` ; -lz -pthread -ldl -ltinfo ; -o embedcling; . Embedding cling requires the creation of the interpreter. Optionally compiler arguments and the resource directory of llvm can be passed. An example is the following:. #include ""cling/Interpreter/Interpreter.h"". int main(int argc, char** argv) {; const char* LLVMRESDIR = ""/usr/local/""; //path to llvm resource directory; cling::Interpreter interp(argc, argv, LLVMRESDIR);. interp.declare(""int p=0;"");; }; ; A more complete example could be found in tools/demo/cling-demo.cpp; Download . We are developing Cling accor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html:2109,depend,dependent,2109,interpreter/cling/www/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html,2,['depend'],['dependent']
Integrability,"l spectrum with many identified peaks](figures/image060.png). However, when we have noisy data, the number of peaks can be enormous. One; such an example is given in Figure 3.3. ![With noisy data the number of peaks can be enormous](figures/image062.png). Therefore it can be useful to have a possibility to set a threshold value and to consider only the peaks higher than this threshold (see Figure 3.4, only three peaks were identified, threshold=50). The value in the center of the peak (`value[i]`) minus the average value in two symmetrically positioned channels (channels `i-3*sigma`, `i+3*sigma`) must be greater than threshold.; Otherwise the peak is ignored. ![Iwth threshold=50, only three peaks were identified](figures/image064.png). An alternative approach was proposed in [6]. The algorithm generates; new invariant spectrum based on discrete Markov chains. In this spectrum; the noise is suppressed, the spectrum is smoother than the original one.; On the other hand it emphasizes peaks (depending on the averaging; window). The example of the part of original noisy spectrum and Markov; spectrum for `window=3` is given in Figure 3.5 Then the peaks can be found in; Markov spectrum using standard above-presented algorithm. ![Part of original noisy spectrum and Markov spectrum for window=3](figures/image066.png). The form of the generalized peak searching function is as follows:. ```{.cpp}; Int_t Search1General(float *spectrum,; int size,; float sigma,; int threshold,; bool markov,; int aver_window);; ```. This function searches for peaks in the source spectrum. The number of found; peaks and their positions are written into the structure pointed by the; `one_dim_peak` structure pointer. Function parameters:. - **`spectrum`**: pointer to the vector of the source spectrum. This source spectrum is replaced by the new spectrum calculated using Markov chains method.; - **`size`**: length of the source spectrum; - **`sigma`**: sigma of searched peaks; - **`threshold`**: thres",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:18938,depend,depending,18938,documentation/spectrum/Spectrum.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md,1,['depend'],['depending']
Integrability,"l"" via the :ref:`datalayout string<langref_datalayout>`.; Non-integral pointer types represent pointers that have an *unspecified* bitwise; representation; that is, the integral representation may be target dependent or; unstable (not backed by a fixed integer). ``inttoptr`` and ``ptrtoint`` instructions have the same semantics as for; integral (i.e. normal) pointers in that they convert integers to and from; corresponding pointer types, but there are additional implications to be; aware of. Because the bit-representation of a non-integral pointer may; not be stable, two identical casts of the same operand may or may not; return the same value. Said differently, the conversion to or from the; non-integral type depends on environmental state in an implementation; defined manner. If the frontend wishes to observe a *particular* value following a cast, the; generated IR must fence with the underlying environment in an implementation; defined manner. (In practice, this tends to require ``noinline`` routines for; such operations.). From the perspective of the optimizer, ``inttoptr`` and ``ptrtoint`` for; non-integral types are analogous to ones on integral types with one; key exception: the optimizer may not, in general, insert new dynamic; occurrences of such casts. If a new cast is inserted, the optimizer would; need to either ensure that a) all possible values are valid, or b); appropriate fencing is inserted. Since the appropriate fencing is; implementation defined, the optimizer can't do the latter. The former is; challenging as many commonly expected properties, such as; ``ptrtoint(v)-ptrtoint(v) == 0``, don't hold for non-integral types.; Similar restrictions apply to intrinsics that might examine the pointer bits,; such as :ref:`llvm.ptrmask<int_ptrmask>`. . The alignment information provided by the frontend for a non-integral pointer; (typically using attributes or metadata) must be valid for every possible ; representation of the pointer. .. _globalvars:. Globa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:29366,rout,routines,29366,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['rout'],['routines']
Integrability,"l; Specifications that will help drive the future of the C++ programming; language.; The LLVM bug tracker uses; the ""c++"" label, as well as mode-specific labels such as ""c++11"", ""c++14"",; and so on, to track known bugs with Clang's language conformance.; C++2c implementation status. Clang has support for some of the features of the C++ standard following; C++23, informally referred to as C++26.; You can use Clang in C++2c mode with the -std=c++2c option. List of features and minimum Clang version with support. Language Feature; C++26 Proposal; Available in Clang?. Remove undefined behavior from lexing; P2621R2 (DR); Clang 3.3. Making non-encodable string literals ill-formed; P1854R4 (DR); Clang 14. Unevaluated strings; P2361R6; Clang 18. Add @, $, and ` to the basic character set; P2558R2; Yes. constexpr cast from void*; P2738R1; Clang 17. On the ignorability of standard attributes; P2552R3 (DR); No. Static storage for braced initializers; P2752R3 (DR); No. User-generated static_assert messages; P2741R3; Clang 17. Placeholder variables with no name; P2169R4; Clang 18. Template parameter initialization; P2308R1 (DR); Clang 18. Pack Indexing; P2662R3; No. Remove Deprecated Arithmetic Conversion on Enumerations; P2864R2; Clang 18. C++23 implementation status. Clang has support for some of the features of the ISO C++ 2023 standard.; You can use Clang in C++23 mode with the -std=c++23 option. List of features and minimum Clang version with support. Language Feature; C++23 Proposal; Available in Clang?. Literal suffix uz, z for size_t, ssize_t; P0330R8; Clang 13. Make () in lambdas optional in all cases; P1102R2; Clang 13. Simpler implicit move; P2266R1; Clang 13. if consteval; P1938R3; Clang 14. Allow duplicate attributes; P2156R1; Clang 13. Narrowing contextual conversions to bool; P1401R5; Clang 14. Trimming whitespaces before line splicing; P2223R2; Yes. Make declaration order layout mandated; P1874R4; Yes. C++ identifier syntax using UAX 31; P1949R7; Clang 14. Mixed ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:1672,message,messages,1672,interpreter/llvm-project/clang/www/cxx_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html,2,['message'],['messages']
Integrability,"lTree.h; ^^^^^^^^^^^^^^^^^^^^^^^. ``llvm::IntervalTree`` is a light tree data structure to hold intervals. It; allows finding all intervals that overlap with any given point. At this time,; it does not support any deletion or rebalancing operations. The IntervalTree is designed to be set up once, and then queried without any; further additions. .. _dss_map:. <map>; ^^^^^. std::map has similar characteristics to :ref:`std::set <dss_set>`: it uses a; single allocation per pair inserted into the map, it offers log(n) lookup with; an extremely large constant factor, imposes a space penalty of 3 pointers per; pair in the map, etc. std::map is most useful when your keys or values are very large, if you need to; iterate over the collection in sorted order, or if you need stable iterators; into the map (i.e. they don't get invalidated if an insertion or deletion of; another element takes place). .. _dss_mapvector:. llvm/ADT/MapVector.h; ^^^^^^^^^^^^^^^^^^^^. ``MapVector<KeyT,ValueT>`` provides a subset of the DenseMap interface. The; main difference is that the iteration order is guaranteed to be the insertion; order, making it an easy (but somewhat expensive) solution for non-deterministic; iteration over maps of pointers. It is implemented by mapping from key to an index in a vector of key,value; pairs. This provides fast lookup and iteration, but has two main drawbacks:; the key is stored twice and removing elements takes linear time. If it is; necessary to remove elements, it's best to remove them in bulk using; ``remove_if()``. .. _dss_inteqclasses:. llvm/ADT/IntEqClasses.h; ^^^^^^^^^^^^^^^^^^^^^^^. IntEqClasses provides a compact representation of equivalence classes of small; integers. Initially, each integer in the range 0..n-1 has its own equivalence; class. Classes can be joined by passing two class representatives to the; join(a, b) method. Two integers are in the same class when findLeader() returns; the same representative. Once all equivalence classes are form",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:94127,interface,interface,94127,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['interface'],['interface']
Integrability,"lVar to categories with labels that correspond to bins of input RooRealVar. See rf405_realtocatfuncs.C for details . RooStats; This is a new package introduced in this version for statistical tools built on top of RooFit. It is a joint effort between the LHC experiments and the ROOT team (see the RooStats Wiki page).; ; This version contains the interfaces for performing the statistical calculations and dealing with the obtained results and concrete classes implementing the statistical methods.; ; All the classes and functions in RooStats are provided in the namespace RooStats.; ; RooStats interfaces. ConfInterval: interface for describing a confidence interval. ; IntervalCalculator: interface for a statistical tool producing confidence intervals (class ConfInterval).; HypoTestResult: interface for representing results of a hypothesis test; HypoTestCalculator: interface for a statistical tool performing an hypothesis test. ; CombinedCalculator: interface for a statistical tool which can produce both hypothesis test results and confidence intervals. ; RooStats concrete classes. The concrete classes describing statistical tools implementing the above interfaces are:; ; ProfileLikelihoodCalculator: it is an implementation of a CombinedCalculator using the profile likelihood ratio as a test statistics. After configuring the calculator, one only needs to ask GetHypoTest() (which will return a HypoTestResult pointer) or GetInterval() (which will return an ConfInterval pointer).; LikelihoodInterval: concrete implementation of a ConfInterval interface. It implements connected N-dimensional intervals based on the contour of a likelihood ratio. The boundary of the interval is equivalent to a MINUIT/MINOS contour about the maximum likelihood estimator. . HybridCalculator: hypothesis test calculator using a Bayesian-frequentist hybrid method (often called in HEP as CLs method). This class extends the functionality of the TLimit class by taking advantage of the RooFit package. T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html:10177,interface,interface,10177,roofit/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html,2,['interface'],['interface']
Integrability,"l\@apple.com (email), rjmccall (Phabricator), rjmccall (GitHub). Microsoft ABI; ~~~~~~~~~~~~~; | Reid Kleckner; | rnk\@google.com (email), rnk (Phabricator), rnk (GitHub). ARM EABI; ~~~~~~~~; | Anton Korobeynikov; | anton\@korobeynikov.info (email), asl (Phabricator), asl (GitHub). Compiler-Wide Topics; --------------------; The following people are responsible for functionality that does not fit into; a single part of the compiler, but instead span multiple components within the; compiler. Attributes; ~~~~~~~~~~; | Erich Keane; | ekeane\@nvidia.com (email), ErichKeane (Phabricator), erichkeane (GitHub). Inline assembly; ~~~~~~~~~~~~~~~; | Eric Christopher; | echristo\@gmail.com (email), echristo (Phabricator), echristo (GitHub). Text encodings; ~~~~~~~~~~~~~~; | Tom Honermann; | tom\@honermann.net (email), tahonermann (Phabricator), tahonermann (GitHub). | Corentin Jabot; | corentin.jabot\@gmail.com (email), cor3ntin (Phabricator), cor3ntin (GitHub). CMake integration; ~~~~~~~~~~~~~~~~~; | Petr Hosek; | phosek\@google.com (email), phosek (Phabricator), petrhosek (GitHub). | John Ericson; | git\@johnericson.me (email), Ericson2314 (Phabricator), Ericson2314 (GitHub). General Windows support; ~~~~~~~~~~~~~~~~~~~~~~~; | Reid Kleckner; | rnk\@google.com (email), rnk (Phabricator), rnk (GitHub). Incremental compilation, REPLs, clang-repl; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; | Vassil Vassilev; | Vassil.Vassilev\@cern.ch (email), v.g.vassilev (Phabricator), vgvassilev (GitHub). Standards Conformance; ---------------------; The following people are responsible for validating that changes are conforming; to a relevant standard. Contact them for questions about how to interpret a; standard, when fixing standards bugs, or when implementing a new standard feature. C conformance; ~~~~~~~~~~~~~; | Aaron Ballman; | aaron\@aaronballman.com (email), aaron.ballman (Phabricator), AaronBallman (GitHub), AaronBallman (Discourse), aaronballman (Discord), AaronBallman (IRC). C++ ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CodeOwners.rst:4826,integrat,integration,4826,interpreter/llvm-project/clang/CodeOwners.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CodeOwners.rst,1,['integrat'],['integration']
Integrability,"lable, usually at ``O(n * log(n))``. This algorithm is capable of responding to a full variety of alias analysis; queries, and can provide context-sensitive mod/ref information as well. The; only major facility not implemented so far is support for must-alias; information. .. note::. ``-ds-aa`` is available in the optional ""poolalloc"" module. It is not part of; the LLVM core. The ``-scev-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^. The ``-scev-aa`` pass implements AliasAnalysis queries by translating them into; ScalarEvolution queries. This gives it a more complete understanding of; ``getelementptr`` instructions and loop induction variables than other alias; analyses have. Alias analysis driven transformations; -------------------------------------. LLVM includes several alias-analysis driven transformations which can be used; with any of the implementations above. The ``-adce`` pass; ^^^^^^^^^^^^^^^^^^. The ``-adce`` pass, which implements Aggressive Dead Code Elimination uses the; ``AliasAnalysis`` interface to delete calls to functions that do not have; side-effects and are not used. The ``-licm`` pass; ^^^^^^^^^^^^^^^^^^. The ``-licm`` pass implements various Loop Invariant Code Motion related; transformations. It uses the ``AliasAnalysis`` interface for several different; transformations:. * It uses mod/ref information to hoist or sink load instructions out of loops if; there are no instructions in the loop that modifies the memory loaded. * It uses mod/ref information to hoist function calls out of loops that do not; write to memory and are loop-invariant. * It uses alias information to promote memory objects that are loaded and stored; to in loops to live in a register instead. It can do this if there are no may; aliases to the loaded/stored memory location. The ``-argpromotion`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``-argpromotion`` pass promotes by-reference arguments to be passed in; by-value instead. In particular, if pointer arguments are only loaded from it; pas",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:27425,interface,interface,27425,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['interface'],['interface']
Integrability,"lar semantic meaning. ``RegularKeyword`` provides an alternative way of spelling such attributes.; It reuses the production rules for standard attributes, but it applies them; to plain keywords rather than to ``[[…]]`` sequences. Compilers that don't; recognize the keyword are likely to report an error of some kind. For example, the ``ArmStreaming`` function type attribute affects; both the type system and the binary interface of the function.; It cannot therefore be spelled ``[[arm::streaming]]``, since compilers; that don't understand ``arm::streaming`` would ignore it and miscompile; the code. ``ArmStreaming`` is instead spelled ``__arm_streaming``, but it; can appear wherever a hypothetical ``[[arm::streaming]]`` could appear. Subjects; ~~~~~~~~; Attributes appertain to one or more subjects. If the attribute attempts to; attach to a subject that is not in the subject list, a diagnostic is issued; automatically. Whether the diagnostic is a warning or an error depends on how; the attribute's ``SubjectList`` is defined, but the default behavior is to warn.; The diagnostics displayed to the user are automatically determined based on the; subjects in the list, but a custom diagnostic parameter can also be specified in; the ``SubjectList``. The diagnostics generated for subject list violations are; calculated automatically or specified by the subject list itself. If a; previously unused Decl node is added to the ``SubjectList``, the logic used to; automatically determine the diagnostic parameter in `utils/TableGen/ClangAttrEmitter.cpp; <https://github.com/llvm/llvm-project/blob/main/clang/utils/TableGen/ClangAttrEmitter.cpp>`_; may need to be updated. By default, all subjects in the SubjectList must either be a Decl node defined; in ``DeclNodes.td``, or a statement node defined in ``StmtNodes.td``. However,; more complex subjects can be created by creating a ``SubsetSubject`` object.; Each such object has a base subject which it appertains to (which must be a; Decl or ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:132616,depend,depends,132616,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['depend'],['depends']
Integrability,"larations of both; c and d. Matcher<Type>enumTypeMatcher<EnumType>...; Matches enum types. Given; enum C { Green };; enum class S { Red };. C c;; S s;. enumType() matches the type of the variable declarations of both c and; s. Matcher<Type>functionProtoTypeMatcher<FunctionProtoType>...; Matches FunctionProtoType nodes. Given; int (*f)(int);; void g();; functionProtoType(); matches ""int (*f)(int)"" and the type of ""g"" in C++ mode.; In C mode, ""g"" is not matched because it does not contain a prototype. Matcher<Type>functionTypeMatcher<FunctionType>...; Matches FunctionType nodes. Given; int (*f)(int);; void g();; functionType(); matches ""int (*f)(int)"" and the type of ""g"". Matcher<Type>incompleteArrayTypeMatcher<IncompleteArrayType>...; Matches C arrays with unspecified size. Given; int a[] = { 2, 3 };; int b[42];; void f(int c[]) { int d[a[0]]; };; incompleteArrayType(); matches ""int a[]"" and ""int c[]"". Matcher<Type>injectedClassNameTypeMatcher<InjectedClassNameType>...; Matches injected class name types. Example matches S s, but not S<T> s.; (matcher = parmVarDecl(hasType(injectedClassNameType()))); template <typename T> struct S {; void f(S s);; void g(S<T> s);; };. Matcher<Type>lValueReferenceTypeMatcher<LValueReferenceType>...; Matches lvalue reference types. Given:; int *a;; int &b = *a;; int &&c = 1;; auto &d = b;; auto &&e = c;; auto &&f = 2;; int g = 5;. lValueReferenceType() matches the types of b, d, and e. e is; matched since the type is deduced as int& by reference collapsing rules. Matcher<Type>macroQualifiedTypeMatcher<MacroQualifiedType>...; Matches qualified types when the qualifier is applied via a macro. Given; #define CDECL __attribute__((cdecl)); typedef void (CDECL *X)();; typedef void (__attribute__((cdecl)) *Y)();; macroQualifiedType(); matches the type of the typedef declaration of X but not Y. Matcher<Type>memberPointerTypeMatcher<MemberPointerType>...; Matches member pointer types.; Given; struct A { int i; }; A::* ptr = A::i;; memberPointerT",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:48793,inject,injected,48793,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['inject'],['injected']
Integrability,"lass, etc., until it finds something it can execute.; The receiver ""expression"" may also be the name of a class, in which case the; actual receiver is the class object for that class, or (within method; definitions) it may be ``super``, in which case the lookup algorithm starts; with the static superclass instead of the dynamic class. The actual methods; dynamically found in a class are not those declared in the ``@interface``, but; those defined in a separate ``@implementation`` declaration; however, when; compiling a call, typechecking is done based on the methods declared in the; ``@interface``. Method declarations may also be grouped into :arc-term:`protocols`, which are not; inherently associated with any class, but which classes may claim to follow.; Object pointer types may be qualified with additional protocols that the object; is known to support. :arc-term:`Class extensions` are collections of ivars and methods, designed to; allow a class's ``@interface`` to be split across multiple files; however,; there is still a primary implementation file which must see the; ``@interface``\ s of all class extensions. :arc-term:`Categories` allow; methods (but not ivars) to be declared *post hoc* on an arbitrary class; the; methods in the category's ``@implementation`` will be dynamically added to that; class's method tables which the category is loaded at runtime, replacing those; methods in case of a collision. In the standard environment, objects are allocated on the heap, and their; lifetime is manually managed using a reference count. This is done using two; instance methods which all classes are expected to implement: ``retain``; increases the object's reference count by 1, whereas ``release`` decreases it; by 1 and calls the instance method ``dealloc`` if the count reaches 0. To; simplify certain operations, there is also an :arc-term:`autorelease pool`, a; thread-local list of objects to call ``release`` on later; an object can be; added to this pool by calling",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:6127,interface,interface,6127,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,2,['interface'],['interface']
Integrability,"lass, return 1. 2.1.3. If both types are of the first class type, proceed to the next step; (2.1.3.1). 2.1.3.1. If types are vectors, compare their bitwidth using the; *cmpNumbers*. If result is not 0, return it. 2.1.3.2. Different types, but not a vectors:. * if both of them are pointers, good for us, we can proceed to step 3.; * if one of types is pointer, return result of *isPointer* flags; comparison (*cmpFlags* operation).; * otherwise we have no methods to prove bitcastability, and thus return; result of types comparison (-1 or 1). Steps below are for the case when types are equal, or case when constants are; bitcastable:. 3. One of constants is a ""*null*"" value. Return the result of; ``cmpFlags(L->isNullValue, R->isNullValue)`` comparison. 4. Compare value IDs, and return result if it is not 0:. .. code-block:: c++. if (int Res = cmpNumbers(L->getValueID(), R->getValueID())); return Res;. 5. Compare the contents of constants. The comparison depends on the kind of; constants, but on this stage it is just a lexicographical comparison. Just see; how it was described in the beginning of ""*Functions comparison*"" paragraph.; Mathematically, it is equal to the next case: we encode left constant and right; constant (with similar way *bitcode-writer* does). Then compare left code; sequence and right code sequence. compare(const BasicBlock*, const BasicBlock*); ---------------------------------------------; Compares two *BasicBlock* instances. It enumerates instructions from left *BB* and right *BB*. 1. It assigns serial numbers to the left and right instructions, using; ``cmpValues`` method. 2. If one of left or right is *GEP* (``GetElementPtr``), then treat *GEP* as; greater than other instructions. If both instructions are *GEPs* use ``cmpGEP``; method for comparison. If result is -1 or 1, pass it to the top-level; comparison (return it). 3.1. Compare operations. Call ``cmpOperation`` method. If result is -1 or; 1, return it. 3.2. Compare number of operands, if resul",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:23133,depend,depends,23133,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,1,['depend'],['depends']
Integrability,lates; Yes. 589; CD2; Direct binding of class and array rvalues in reference initialization; Yes. 590; C++11; Nested classes and the “current instantiation”; Yes. 591; CD4; When a dependent base class is the current instantiation; No. 592; CD1; Exceptions during construction of local static objects; N/A. 593; NAD; Falling off the end of a destructor's function-try-block handler; Unknown. 594; CD1; Coordinating issues 119 and 404 with delegating constructors; N/A. 595; dup; Exception specifications in templates instantiated from class bodies; Duplicate of 1330. 596; NAD; Replacing an exception object; Unknown. 597; CD3; Conversions applied to out-of-lifetime non-POD lvalues; N/A. 598; CD2; Associated namespaces of overloaded functions and function templates; Yes. 599; CD2; Deleting a null function pointer; Partial. 600; CD6; Does access control apply to members or to names?; Clang 2.8. 601; CD2; Type of literals in preprocessing expressions; Yes. 602; C++11; When is the injected-class-name of a class template a template?; Yes. 603; CD1; Type equivalence and unsigned overflow; Yes. 604; CD2; Argument list for overload resolution in copy-initialization; N/A. 605; C++11; Linkage of explicit specializations; Unknown. 606; CD1; Template argument deduction for rvalue references; Clang 3.0. 607; CD6; Lookup of mem-initializer-ids; Yes. 608; CD2; Determining the final overrider of a virtual function; Yes. 609; CD4; What is a “top-level” cv-qualifier?; Unknown. 610; NAD; Computing the negative of 0U; Yes. 611; CD2; Zero-initializing references; Yes. 612; CD2; Requirements on a conforming implementation; N/A. 613; CD1; Unevaluated uses of non-static class members; Yes (C++11 onwards). 614; CD1; Results of integer / and %; Yes. 615; C++11; Incorrect description of variables that can be initialized; Yes. 616; CD3; Definition of “indeterminate value”; Clang 4. 617; NAD; Lvalue-to-rvalue conversions of uninitialized char objects; Unknown. 618; CD2; Casts in preprocessor conditiona,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:41297,inject,injected-class-name,41297,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['inject'],['injected-class-name']
Integrability,"lative to File; Size. This is the size of the definitions of all types in the bitcode file. **Constant Pool Bytes**. The size, in bytes, of the Constant Pool Blocks Percentage is relative to File; Size. **Module Globals Bytes**. Ths size, in bytes, of the Global Variable Definitions and their initializers.; Percentage is relative to File Size. **Instruction List Bytes**. The size, in bytes, of all the instruction lists in all the functions.; Percentage is relative to File Size. Note that this value is also included in; the Function Bytes. **Compaction Table Bytes**. The size, in bytes, of all the compaction tables in all the functions.; Percentage is relative to File Size. Note that this value is also included in; the Function Bytes. **Symbol Table Bytes**. The size, in bytes, of all the symbol tables in all the functions. Percentage is; relative to File Size. Note that this value is also included in the Function; Bytes. **Dependent Libraries Bytes**. The size, in bytes, of the list of dependent libraries in the module. Percentage; is relative to File Size. Note that this value is also included in the Module; Global Bytes. **Number Of Bitcode Blocks**. The total number of blocks of any kind in the bitcode file. **Number Of Functions**. The total number of function definitions in the bitcode file. **Number Of Types**. The total number of types defined in the Global Types Pool. **Number Of Constants**. The total number of constants (of any type) defined in the Constant Pool. **Number Of Basic Blocks**. The total number of basic blocks defined in all functions in the bitcode file. **Number Of Instructions**. The total number of instructions defined in all functions in the bitcode file. **Number Of Long Instructions**. The total number of long instructions defined in all functions in the bitcode; file. Long instructions are those taking greater than 4 bytes. Typically long; instructions are GetElementPtr with several indices, PHI nodes, and calls to; functions with larg",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-bcanalyzer.rst:3131,depend,dependent,3131,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-bcanalyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-bcanalyzer.rst,1,['depend'],['dependent']
Integrability,"ld focus on this. :). Here are some other auxiliary goals that I think we should consider:. 1. Primary goal: Support a high performance dynamic compilation; system. This means that we have an ""ideal"" division of labor between; the runtime and static compilers. Of course, the other goals of the; system somewhat reduce the importance of this point (f.e. portability; reduces performance, but hopefully not much); 2. Portability to different processors. Since we are most familiar with; x86 and solaris, I think that these two are excellent candidates when; we get that far...; 3. Support for all languages & styles of programming (general purpose; VM). This is the point that disallows java style bytecodes, where all; array refs are checked for bounds, etc...; 4. Support linking between different language families. For example, call; C functions directly from Java without using the nasty/slow/gross JNI; layer. This involves several subpoints:; A. Support for languages that require garbage collectors and integration; with languages that don't. As a base point, we could insist on; always using a conservative GC, but implement free as a noop, f.e. > b. A strongly-typed VM. One question is do we need the types to be; > explicitly declared or should they be inferred by the dynamic; > compiler?. B. This is kind of similar to another idea that I have: make OOP; constructs (virtual function tables, class heirarchies, etc) explicit; in the VM representation. I believe that the number of additional; constructs would be fairly low, but would give us lots of important; information... something else that would/could be important is to; have exceptions as first class types so that they would be handled in; a uniform way for the entire VM... so that C functions can call Java; functions for example... > c. How do we get more high-level information into the VM while keeping; > to a low-level VM design?; > o Explicit array references as operands? An alternative is; > to have just an array typ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt:4107,integrat,integration,4107,interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt,1,['integrat'],['integration']
Integrability,"ld hide complete folder from 'guest' account:. ```cpp; serv->Restrict(""/Folder"", ""hidden=guest"");; ```. Or one could hide from all but 'admin' account:. ```cpp; serv->Restrict(""/Folder"", ""visible=admin"");; ```. Hidden folders or objects can not be accessed via http protocol. By default server runs in readonly mode and do not allow methods execution via 'exe.json' or 'exe.bin' requests. To allow such action, one could either grant generic access for all or one could allow to execute only special method:. ```cpp; serv->Restrict(""/Folder/histo1"", ""allow=all"");; serv->Restrict(""/Folder/histo1"", ""allow_method=GetTitle"");; ```. One could provide several options for the same item, separating them with '&' sign:. ```cpp; serv->Restrict(""/Folder/histo1"", ""allow_method=GetTitle&hide=guest"");; ```. Complete list of supported options could be found in [TRootSniffer:Restrict()](https://root.cern/doc/master/classTRootSniffer.html#a8af1f11cbfb9c895f968ec0594794120) method documentation. ## Using FastCGI interface. [FastCGI](http://en.wikipedia.org/wiki/FastCGI) is a protocol for interfacing interactive programs with a web server like `Apache`, `lighttpd`, `Microsoft ISS` and many others. When starting THttpServer, one could specify:. ```cpp; serv = new THttpServer(""fastcgi:9000"");; ```. In fact, the FastCGI interface can run in parallel to http server. One can just call:. ```cpp; serv = new THttpServer(""http:8080"");; serv->CreateEngine(""fastcgi:9000"");; ```. One could specify a debug parameter to be able to adjust the FastCGI configuration on the web server:. ```cpp; serv->CreateEngine(""fastcgi:9000?debug=1"");; ```. By default 10 threads are used to process FastCGI requests. This number can be changed with ""thrds"" url parameter:. ```cpp; serv->CreateEngine(""fastcgi:9000?thrds=20"");; ```. If `thrds=0` parameter specified, the only thread will be use to received and process all requests. All user access will be ruled by the main web server. Authorized account names could be used to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:9988,interface,interface,9988,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['interface'],['interface']
Integrability,"ld its data, and; it calls back to general heap allocation when required. Since it owns its data,; it is very safe to use and supports full mutation of the string. Like SmallVector's, the big downside to SmallString is their sizeof. While they; are optimized for small strings, they themselves are not particularly small.; This means that they work great for temporary scratch buffers on the stack, but; should not generally be put into the heap: it is very rare to see a SmallString; as the member of a frequently-allocated heap data structure or returned; by-value. .. _dss_stdstring:. std::string; ^^^^^^^^^^^. The standard C++ std::string class is a very general class that (like; SmallString) owns its underlying data. sizeof(std::string) is very reasonable; so it can be embedded into heap data structures and returned by-value. On the; other hand, std::string is highly inefficient for inline editing (e.g.; concatenating a bunch of stuff together) and because it is provided by the; standard library, its performance characteristics depend a lot of the host; standard library (e.g. libc++ and MSVC provide a highly optimized string class,; GCC contains a really slow implementation). The major disadvantage of std::string is that almost every operation that makes; them larger can allocate memory, which is slow. As such, it is better to use; SmallVector or Twine as a scratch buffer, but then use std::string to persist; the result. .. _ds_set:. Set-Like Containers (std::set, SmallSet, SetVector, etc); --------------------------------------------------------. Set-like containers are useful when you need to canonicalize multiple values; into a single representation. There are several different choices for how to do; this, providing various trade-offs. .. _dss_sortedvectorset:. A sorted 'vector'; ^^^^^^^^^^^^^^^^^. If you intend to insert a lot of elements, then do a lot of queries, a great; approach is to use an std::vector (or other sequential container) with; std::sort+std::uniqu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:76297,depend,depend,76297,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['depend'],['depend']
Integrability,"ldInvoke2; LLVMBuildGEP -> LLVMBuildGEP2; LLVMBuildInBoundsGEP -> LLVMBuildInBoundsGEP2; LLVMBuildStructGEP -> LLVMBuildStructGEP2; LLVMBuildPtrDiff -> LLVMBuildPtrDiff2; LLVMConstGEP -> LLVMConstGEP2; LLVMConstInBoundsGEP -> LLVMConstInBoundsGEP2; LLVMAddAlias -> LLVMAddAlias2. Additionally, it will no longer be possible to call ``LLVMGetElementType()``; on a pointer type. It is possible to control whether opaque pointers are used (if you want to; override the default) using ``LLVMContext::setOpaquePointers``. Temporarily disabling opaque pointers; =====================================. In LLVM 15, opaque pointers are enabled by default, but it it still possible to; use typed pointers using a number of opt-in flags. For users of the clang driver interface, it is possible to temporarily restore; the old default using the ``-DCLANG_ENABLE_OPAQUE_POINTERS=OFF`` cmake option,; or by passing ``-Xclang -no-opaque-pointers`` to a single clang invocation. For users of the clang cc1 interface, ``-no-opaque-pointers`` can be passed.; Note that the ``CLANG_ENABLE_OPAQUE_POINTERS`` cmake option has no effect on; the cc1 interface. Usage for LTO can be disabled by passing ``-Wl,-plugin-opt=no-opaque-pointers``; to the clang driver. For users of LLVM as a library, opaque pointers can be disabled by calling; ``setOpaquePointers(false)`` on the ``LLVMContext``. For users of LLVM tools like opt, opaque pointers can be disabled by passing; ``-opaque-pointers=0``. Version Support; ===============. **LLVM 14:** Supports all necessary APIs for migrating to opaque pointers and deprecates/removes incompatible APIs. However, using opaque pointers in the optimization pipeline is **not** fully supported. This release can be used to make out-of-tree code compatible with opaque pointers, but opaque pointers should **not** be enabled in production. **LLVM 15:** Opaque pointers are enabled by default. Typed pointers are still; supported. **LLVM 16:** Opaque pointers are enabled by default. Typed",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OpaquePointers.rst:11176,interface,interface,11176,interpreter/llvm-project/llvm/docs/OpaquePointers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OpaquePointers.rst,1,['interface'],['interface']
Integrability,"le -o Hello.pcm; $ clang++ -std=c++20 use.cpp -fprebuilt-module-path=. Hello.pcm -o Hello.out; $ ./Hello.out; Hello World!. Module name requirement; ~~~~~~~~~~~~~~~~~~~~~~~. [module.unit]p1 says:. .. code-block:: text. All module-names either beginning with an identifier consisting of std followed by zero; or more digits or containing a reserved identifier ([lex.name]) are reserved and shall not; be specified in a module-declaration; no diagnostic is required. If any identifier in a reserved; module-name is a reserved identifier, the module name is reserved for use by C++ implementations;; otherwise it is reserved for future standardization. So all of the following name is not valid by default:. .. code-block:: text. std; std1; std.foo; __test; // and so on ... If you still want to use the reserved module names for any reason, use; ``-Wno-reserved-module-identifier`` to suppress the warning. How to specify the dependent BMIs; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. There are 3 methods to specify the dependent BMIs:. * (1) ``-fprebuilt-module-path=<path/to/directory>``.; * (2) ``-fmodule-file=<path/to/BMI>`` (Deprecated).; * (3) ``-fmodule-file=<module-name>=<path/to/BMI>``. The option ``-fprebuilt-module-path`` tells the compiler the path where to search for dependent BMIs.; It may be used multiple times just like ``-I`` for specifying paths for header files. The look up rule here is:. * (1) When we import module M. The compiler would look up M.pcm in the directories specified; by ``-fprebuilt-module-path``.; * (2) When we import partition module unit M:P. The compiler would look up M-P.pcm in the; directories specified by ``-fprebuilt-module-path``. The option ``-fmodule-file=<path/to/BMI>`` tells the compiler to load the specified BMI directly.; The option ``-fmodule-file=<module-name>=<path/to/BMI>`` tells the compiler to load the specified BMI; for the module specified by ``<module-name>`` when necessary. The main difference is that; ``-fmodule-file=<path/to/BMI>`` w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:10794,depend,dependent,10794,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['depend'],['dependent']
Integrability,"le ``array`` or ``ndarray`` from Numpy). The low-level module adds the following functions:. * **ll.malloc**: an interface on top of C's malloc.; Use it as a template with the number of elements (not the number types) to; be allocated.; The result is a ``cppyy.LowLevelView`` with the proper type and size:. .. code-block:: python. >>> arr = cppyy.ll.malloc[int](4) # allocates memory for 4 C ints; >>> print(len(arr)); 4; >>> print(type(arr[0])); <type 'int'>; >>>. The actual C malloc can also be used directly, through ``cppyy.gbl.malloc``,; taking the number of *bytes* to be allocated and returning a ``void*``. * **ll.free**: an interface to C's free, to deallocate memory allocated by; C's malloc.; To continue to example above:. .. code-block:: python. >>> cppyy.ll.free(arr); >>>. The actual C free can also be used directly, through ``cppyy.gbl.free``. * **ll.array_new**: an interface on top of C++'s ``new[]``.; Use it as a template; the result is a ``cppyy.LowLevelView`` with the; proper type and size:. .. code-block:: python. >>> arr = cppyy.ll.array_new[int](4) # allocates memory for 4 C ints; >>> print(len(arr)); 4; >>> print(type(arr[0])); <type 'int'>; >>>. * **ll.array_delete**: an interface on top of C++'s ``delete[]``.; To continue to example above:. .. code-block:: python. >>> cppyy.ll.array_delete(arr); >>>. `argc/argv`; -----------. C/C++'s ``main`` function can take the number of command line arguments; (``argc``) and their values (``argv``) as function arguments.; A common idiom has these values subsequently passed on to the entry point of; e.g. a framework or library.; Since the type of ``argv`` in particular (``char*[]``) is clunky to work with; in Python, the low level module contains two convenient helper functions,; ``ll.argc()`` and ``ll.argv()``, that convert the command line arguments as; provided by Python's ``sys`` module, into typed values that are can be passed; to by C/C++. .. _`ctypes module`: https://docs.python.org/3/library/ctypes.html; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst:10873,interface,interface,10873,bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,1,['interface'],['interface']
Integrability,"le order book using C++, CLion, Google Test and, of course, Cling. ; * - `Cling C++ interpreter testdrive <https://www.youtube.com/watch?v=1IGTHusaJ18>`_; - Dimitri Nesteruk 2015 Youtube; - This tutorial describes Cling’s general features. You will learn how to start Cling on Ubuntu, how to write a simple expression (N=5, N++) and how to define a Class for calculating body mass index. ; * - `Cling Interactive OpenGL Demo <https://www.youtube.com/watch?v=eoIuqLNvzFs>`_; - *Alexander Penev* 2012 Youtube; - This demo shows how to use Cling for interactive OpenGL. A rotating triangle with changing color, a static figure, and a figure with light effects are created.; ; . .. list-table:: Language Interoperability with Cling:; :widths: 25 25 50; :header-rows: 1. * - Link; - Info ; - Description; * - `Compiler Research - Calling C++ libraries from a D-written DSL: A cling/cppyy-based approach <https://www.youtube.com/watch?v=7teqrCNzrD8>`_; - *Alexandru Militaru* 2021 Compiler-Research Meeting; - This video presents D and C++ interoperability through SIL-Cling architecture. .. list-table:: Interactive CUDA C++ with Cling:; :widths: 25 25 50; :header-rows: 1. * - Link; - Info ; - Description; * - `Adding CUDA® Support to Cling: JIT Compile to GPUs <https://www.youtube.com/watch?v=XjjZRhiFDVs>`_; - *Simeon Ehrig* 2020 LLVM Developer Meeting; - Interactive CUDA-C++ through Cling is presented. Cling-CUDA architecture is discussed in detail, and an example of interactive simulation for laser plasma applications is shown. . .. list-table:: C++ in Jupyter Notebook - Xeus Cling:; :widths: 25 25 50; :header-rows: 1; ; * - Link; - Info ; - Description; * - `Interactive C++ code development using C++Explorer and GitHub Classroom for educational purposes <https://www.youtube.com/watch?v=HBgF2Yr0foA>`_; - *Patrick Diehl* 2020 Youtube; - C++Explorer is a novel teaching environment based on Jupyterhub and Cling, adapted to teaching C++ programming and source code management.; * - `Deep div",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/references.rst:6087,interoperab,interoperability,6087,interpreter/cling/docs/chapters/references.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/references.rst,1,['interoperab'],['interoperability']
Integrability,"le throughput and info sending was; just sending 'regular' samples about the activity of the single TFile; instance that happened to trigger an activity in the right moment.; Now TMonaLisaWriter keeps internally track of every; activity; and regularly sends summaries valid for all the files which had; activity in the last time interval.; Additionally, it's now finalized the infrastructure able to; measure; and keep track of the file Open latency. A packet is sent for each; successful Open, sending the measures of the latencies for the; various phases of the open. Currently exploited fully by TAlienFile; and TXNetFile. Easy to report from other TFiles too.; Now, the hook for the Close() func triggers sending of a; packet containing various information about the performance related to; that file only.; Added support also for performance monitoring when writing. RGLITE: A ROOT GRID interface. RGLite plug-in - a ROOT plug-in module, which implements the ROOT Grid; interface and offers to ROOT users possibilities to perform a number of; operations using gLite middleware from within ROOT. Supported features:. Workload Management System operations:; ; job submission – normal, DAG and parametric; jobs (gLite; WMProxy API), ; smart look-up algorithm for WMP-Endpoints, ; job status querying (gLite LB API), ; job output retrieving (Globus GridFTP). . File Catalog operations (gLite/LCG LFC API):; ; smart session manager, ; set/query the current working catalog directory, ; list files, directories and their stats, ; add/remove files in a catalog namespace, ; add/remove directories, ; add/remove replicas from a given file. . An executive logging. ; Support of an external XML configuration file with; according XML; schema. . Usage examples:. Job operations. // loading RGLite plug-in. TGrid::Connect(""glite"");; // submitting Grid job. TGridJob *job = gGrid->Submit(""JDLs/simple.jdl"");; // getting status object. TGridJobStatus *status = job->GetJobStatus();; // getting status of the jo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/doc/v520/index.html:3137,interface,interface,3137,net/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/doc/v520/index.html,2,['interface'],['interface']
Integrability,"le unit whose module declaration is; ``export module module_name;``. The ``module_name`` here denotes the name of the; module. A module should have one and only one primary module interface unit. A module implementation unit is a module unit whose module declaration is; ``module module_name;``. A module could have multiple module implementation; units with the same declaration. A module interface partition unit is a module unit whose module declaration is; ``export module module_name:partition_name;``. The ``partition_name`` should be; unique within any given module. An internal module partition unit is a module unit whose module declaration; is ``module module_name:partition_name;``. The ``partition_name`` should be; unique within any given module. In this document, we use the following umbrella terms:. * A ``module interface unit`` refers to either a ``primary module interface unit``; or a ``module interface partition unit``. * An ``importable module unit`` refers to either a ``module interface unit``; or a ``internal module partition unit``. * A ``module partition unit`` refers to either a ``module interface partition unit``; or a ``internal module partition unit``. Built Module Interface file; ~~~~~~~~~~~~~~~~~~~~~~~~~~~. A ``Built Module Interface file`` stands for the precompiled result of an importable module unit.; It is also called the acronym ``BMI`` generally. Global module fragment; ~~~~~~~~~~~~~~~~~~~~~~. In a module unit, the section from ``module;`` to the module declaration is called the global module fragment. How to build projects using modules; -----------------------------------. Quick Start; ~~~~~~~~~~~. Let's see a ""hello world"" example that uses modules. .. code-block:: c++. // Hello.cppm; module;; #include <iostream>; export module Hello;; export void hello() {; std::cout << ""Hello World!\n"";; }. // use.cpp; import Hello;; int main() {; hello();; return 0;; }. Then we type:. .. code-block:: console. $ clang++ -std=c++20 Hello.cppm --precompile",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:3755,interface,interface,3755,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['interface'],['interface']
Integrability,"le. A module should have one and only one primary module interface unit. A module implementation unit is a module unit whose module declaration is; ``module module_name;``. A module could have multiple module implementation; units with the same declaration. A module interface partition unit is a module unit whose module declaration is; ``export module module_name:partition_name;``. The ``partition_name`` should be; unique within any given module. An internal module partition unit is a module unit whose module declaration; is ``module module_name:partition_name;``. The ``partition_name`` should be; unique within any given module. In this document, we use the following umbrella terms:. * A ``module interface unit`` refers to either a ``primary module interface unit``; or a ``module interface partition unit``. * An ``importable module unit`` refers to either a ``module interface unit``; or a ``internal module partition unit``. * A ``module partition unit`` refers to either a ``module interface partition unit``; or a ``internal module partition unit``. Built Module Interface file; ~~~~~~~~~~~~~~~~~~~~~~~~~~~. A ``Built Module Interface file`` stands for the precompiled result of an importable module unit.; It is also called the acronym ``BMI`` generally. Global module fragment; ~~~~~~~~~~~~~~~~~~~~~~. In a module unit, the section from ``module;`` to the module declaration is called the global module fragment. How to build projects using modules; -----------------------------------. Quick Start; ~~~~~~~~~~~. Let's see a ""hello world"" example that uses modules. .. code-block:: c++. // Hello.cppm; module;; #include <iostream>; export module Hello;; export void hello() {; std::cout << ""Hello World!\n"";; }. // use.cpp; import Hello;; int main() {; hello();; return 0;; }. Then we type:. .. code-block:: console. $ clang++ -std=c++20 Hello.cppm --precompile -o Hello.pcm; $ clang++ -std=c++20 use.cpp -fmodule-file=Hello=Hello.pcm Hello.pcm -o Hello.out; $ ./Hello.out; Hello Worl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:3872,interface,interface,3872,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['interface'],['interface']
Integrability,"le:. If JITDylib ``JD`` contains definitions for symbols ``foo_body`` and; ``bar_body``, we can create lazy entry points ``Foo`` and ``Bar`` in JITDylib; ``JD2`` by calling:. .. code-block:: c++. auto ReexportFlags = JITSymbolFlags::Exported | JITSymbolFlags::Callable;; JD2.define(; lazyReexports(CallThroughMgr, StubsMgr, JD,; SymbolAliasMap({; { Mangle(""foo""), { Mangle(""foo_body""), ReexportedFlags } },; { Mangle(""bar""), { Mangle(""bar_body""), ReexportedFlags } }; }));. A full example of how to use lazyReexports with the LLJIT class can be found at; ``llvm/examples/OrcV2Examples/LLJITWithLazyReexports``. Supporting Custom Compilers; ===========================. TBD. .. _transitioning_orcv1_to_orcv2:. Transitioning from ORCv1 to ORCv2; =================================. Since LLVM 7.0, new ORC development work has focused on adding support for; concurrent JIT compilation. The new APIs (including new layer interfaces and; implementations, and new utilities) that support concurrency are collectively; referred to as ORCv2, and the original, non-concurrent layers and utilities; are now referred to as ORCv1. The majority of the ORCv1 layers and utilities were renamed with a 'Legacy'; prefix in LLVM 8.0, and have deprecation warnings attached in LLVM 9.0. In LLVM; 12.0 ORCv1 will be removed entirely. Transitioning from ORCv1 to ORCv2 should be easy for most clients. Most of the; ORCv1 layers and utilities have ORCv2 counterparts [2]_ that can be directly; substituted. However there are some design differences between ORCv1 and ORCv2; to be aware of:. 1. ORCv2 fully adopts the JIT-as-linker model that began with MCJIT. Modules; (and other program representations, e.g. Object Files) are no longer added; directly to JIT classes or layers. Instead, they are added to ``JITDylib``; instances *by* layers. The ``JITDylib`` determines *where* the definitions; reside, the layers determine *how* the definitions will be compiled.; Linkage relationships between ``JITDylibs`` determine h",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:19302,interface,interfaces,19302,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['interface'],['interfaces']
Integrability,"leared; ); add_custom_command(; OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/${NEXT_CLANG_STAGE}-cleared; DEPENDS clang-bootstrap-deps; COMMAND ${CMAKE_COMMAND} -E remove_directory ${BINARY_DIR}; COMMAND ${CMAKE_COMMAND} -E make_directory ${BINARY_DIR}; COMMAND ${CMAKE_COMMAND} -E remove_directory ${STAMP_DIR}; COMMAND ${CMAKE_COMMAND} -E make_directory ${STAMP_DIR}; COMMENT ""Clobberring ${NEXT_CLANG_STAGE} build and stamp directories""; ). if(CMAKE_VERBOSE_MAKEFILE); set(verbose -DCMAKE_VERBOSE_MAKEFILE=On); endif(). set(_BOOTSTRAP_DEFAULT_PASSTHROUGH; PACKAGE_VERSION; PACKAGE_VENDOR; LLVM_VERSION_MAJOR; LLVM_VERSION_MINOR; LLVM_VERSION_PATCH; CLANG_VERSION_MAJOR; CLANG_VERSION_MINOR; CLANG_VERSION_PATCHLEVEL; CLANG_VERSION_SUFFIX; CLANG_VENDOR; LLVM_VERSION_SUFFIX; LLVM_BINUTILS_INCDIR; CLANG_REPOSITORY_STRING; CMAKE_MAKE_PROGRAM; CMAKE_OSX_ARCHITECTURES; CMAKE_BUILD_TYPE; LLVM_ENABLE_PROJECTS; LLVM_ENABLE_RUNTIMES). # We don't need to depend on compiler-rt/libcxx if we're building instrumented; # because the next stage will use the same compiler used to build this stage.; if(NOT LLVM_BUILD_INSTRUMENTED); if(TARGET compiler-rt); add_dependencies(clang-bootstrap-deps compiler-rt); endif(); if(TARGET cxx-headers); add_dependencies(clang-bootstrap-deps cxx-headers); endif(); endif(). set(C_COMPILER ""clang""); set(CXX_COMPILER ""clang++""); if(WIN32); set(C_COMPILER ""clang-cl.exe""); set(CXX_COMPILER ""clang-cl.exe""); endif(). set(COMPILER_OPTIONS; -DCMAKE_CXX_COMPILER=${LLVM_RUNTIME_OUTPUT_INTDIR}/${CXX_COMPILER}; -DCMAKE_C_COMPILER=${LLVM_RUNTIME_OUTPUT_INTDIR}/${C_COMPILER}; -DCMAKE_ASM_COMPILER=${LLVM_RUNTIME_OUTPUT_INTDIR}/${C_COMPILER}; -DCMAKE_ASM_COMPILER_ID=Clang). # cmake requires CMAKE_LINKER to be specified if the compiler is MSVC-like,; # otherwise it defaults the linker to be link.exe.; if(BOOTSTRAP_LLVM_ENABLE_LLD); if((WIN32 AND NOT BOOTSTRAP_CMAKE_SYSTEM_NAME) OR BOOTSTRAP_CMAKE_SYSTEM_NAME STREQUAL ""Windows""); set(${CLANG_STAGE}_LINKER -DCMAKE_LINKER=${LLVM_RUNTIME_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:24032,depend,depend,24032,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,1,['depend'],['depend']
Integrability,"leased after they've been used. A computation history depends on a pointer value ``P`` if it:. * performs a pointer comparison with ``P``,; * loads from ``P``,; * stores to ``P``,; * depends on a pointer value ``Q`` derived via pointer arithmetic; from ``P`` (including an instance-variable or field access), or; * depends on a pointer value ``Q`` loaded from ``P``. Dependency applies only to values derived directly or indirectly from; a particular expression result and does not occur merely because a; separate pointer value dynamically aliases ``P``. Furthermore, this; dependency is not carried by values that are stored to objects. .. admonition:: Rationale. The restrictions on dependency are intended to make this analysis; feasible by an optimizer with only incomplete information about a; program. Essentially, dependence is carried to ""obvious"" uses of a; pointer. Merely passing a pointer argument to a function does not; itself cause dependence, but since generally the optimizer will not; be able to prove that the function doesn't depend on that parameter,; it will be forced to conservatively assume it does. Dependency propagates to values loaded from a pointer because those; values might be invalidated by deallocating the object. For; example, given the code ``__strong id x = p->ivar;``, ARC must not; move the release of ``p`` to between the load of ``p->ivar`` and the; retain of that value for storing into ``x``. Dependency does not propagate through stores of dependent pointer; values because doing so would allow dependency to outlive the; full-expression which produced the original value. For example, the; address of an instance variable could be written to some global; location and then freely accessed during the lifetime of the local,; or a function could return an inner pointer of an object and store; it to a local. These cases would be potentially impossible to; reason about and so would basically prevent any optimizations based; on imprecise lifetime. There ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:80726,depend,dependence,80726,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,2,['depend'],"['depend', 'dependence']"
Integrability,"lecting other shape or medium among existing ones. - *Daughters*. The category allows removing existing daughter nodes or; adding new ones. The button ""Position"" allows editing the; positioning matrix of a given node. \image html geometry022.jpg width=600px; \image html geometry023.jpg ""Setting volume properties and modifying volume hierarchy"" width=600px. - *Visualization*. This category allows changing the visibility of the; edited volume or for its daughters, as well as other visualization; settings. The radio button ""All"" allows viewing all volumes down; to the selected depth. ""Leaves"" will draw only the deepest nodes; that have the selected depth or lower level ones that have no; daughters inside. ""Only"" will allow drawing only the edited; volume. The check button ""Raytrace"" will just draw the current; selection in solid mode using the ray-tracing algorithm provided by; TGeo. \image html geometry024.jpg width=600px; \image html geometry025.jpg ""Volume visualisation settings and division interface for volumes"" width=600px. - *Division*. Allows dividing the edited volume according a given; pattern. The division axes that are allowed are presented in a; radio-button group. The number entries labeled ""From"", ""Step""; and ""Nslices"" correspond to the divisioning parameters on the; selected axis. The range of the division is between `start` and; `start+ndiv*step` values and its validity is checked upon changing; one of the values. NOTE: When changing a value in a number entry by typing a number, press; ENTER at the end to validate. This applies for taking into account and; validation of any number change in the geometry editors. \anchor GP08f; ### How to Create a Valid Geometry with Geometry Editors. 1. Create a new geometry manager and start the editor as described at; the beginning. 2. Create at least one material from the ""Materials"" shutter item; category. Generally, for creating objects, the interface is always in; the TGeoManagerEditor in different categories - on",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:133422,interface,interface,133422,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['interface'],['interface']
Integrability,"lementation for migrad(),hesse(),minos() etc...; The minimizer(const char* package, const char* alg) provides a completely generic interface; to all minimizers, where package is the package (minuit,GSLminimizer) and alg is the algorithm (migrad) to be used. By default, RooMinuit is still used when RooAbsPdf::fitTo() is called, but can be overridden with; a Minimizer() named argument. // Minimization with MINUIT/MIGRAD through RooMinuit; pdf->fitTo(data) ;. // Minimization with MINUIT/MIGRAD through RooMinimizer; pdf->fitTo(data,Minimizer(""minuit"")) ;. // Minimization with MINUIT2/MIGRAD through RooMinimizer; pdf->fitTo(data,Minimizer(""minuit2"")) ;. // Minimization with GSLMultiMin/conjugatefr through RooMinimizer; pdf->fitTo(data,Minimizer(""GSLMultiMin"",""conjugatefr"")) ;. Note that installation of GSL and the ROOT MathMore package is needed to access the GSL Minimizers and that the GSL; Minimizer do not implement error analysis. New numeric integration algorithms available; RooFit can now interface all MathCore numeric integration; algorithms. In this release ROOT::Math::AdaptiveIntegratorMultiDim,; which implements the 'Genz & Malik' algorithm has been interfaced; in RooAdaptiveIntegratorND and is now the default numeric integrator; for numeric integrations in two or more dimensions. This new default integrator has much improved stability and speed; for relatively smooth p.d.f.s in two or three dimensions and can; generally be used well for p.d.f. normalization integrals without; causing MINUIT converge problems due to numeric precision issues. In future release some more numeric integrators will be migrated to; a MathCore implementation. Interface to TFoam adaptive MC sampler added; RooFit can now use the TFoam adaptive MC sampler for event generation of p.d.f.s that; do not have an internal generator. The TFoam generator adaptively subdivides the; observable space and is generally more efficient both warmup and generation than the original; RooAcceptReject algorit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:4535,integrat,integration,4535,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,6,"['integrat', 'interface']","['integration', 'interface']"
Integrability,"les are copied to llvm/include/llvm/Demangle. The simple reason for; this comes from before the monorepo, and both [sub]projects need to; demangle symbols, but neither can depend on each other. * libcxxabi needs the demangler to implement __cxa_demangle, which is; part of the itanium ABI spec. * LLVM needs a copy for a bunch of places, and cannot rely on the; system's __cxa_demangle because it a) might not be available (i.e.,; on Windows), and b) may not be up-to-date on the latest language; features. The copy of the demangler in LLVM has some extra stuff that aren't; needed in libcxxabi (ie, the MSVC demangler, ItaniumPartialDemangler),; which depend on the shared generic components. Despite these; differences, we want to keep the ""core"" generic demangling library; identical between both copies to simplify development and testing. If you're working on the generic library, then do the work first in; libcxxabi, then run libcxxabi/src/demangle/cp-to-llvm.sh. This; script takes as an optional argument the path to llvm, and copies the; changes you made to libcxxabi over. Note that this script just; blindly overwrites all changes to the generic library in llvm, so be; careful. Because the core demangler needs to work in libcxxabi, everything; needs to be declared in an anonymous namespace (see; DEMANGLE_NAMESPACE_BEGIN), and you can't introduce any code that; depends on the libcxx dylib. FIXME: Now that LLVM is a monorepo, it should be possible to; de-duplicate this code, and have both LLVM and libcxxabi depend on a; shared demangler library. Testing; -------. The tests are split up between libcxxabi/test/{unit,}test_demangle.cpp, and; llvm/unittest/Demangle. The llvm directory should only get tests for stuff not; included in the core library. In the future though, we should probably move all; the tests to LLVM. It is also a really good idea to run libFuzzer after non-trivial changes, see; libcxxabi/fuzz/cxa_demangle_fuzzer.cpp and https://llvm.org/docs/LibFuzzer.html.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/README.txt:2038,depend,depends,2038,interpreter/llvm-project/llvm/include/llvm/Demangle/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/README.txt,2,['depend'],"['depend', 'depends']"
Integrability,"les like ""``unistd.h``"", ""``windows.h``"", ""``stdio.h``"", and ""``string.h``""; are forbidden to be included by LLVM source code outside the implementation of; ``lib/Support``. To obtain system-dependent functionality, existing interfaces to the system; found in ``include/llvm/Support`` should be used. If an appropriate interface is; not available, it should be added to ``include/llvm/Support`` and implemented in; ``lib/Support`` for all supported platforms. Don't Expose System Headers; ---------------------------. The Support Library must shield LLVM from **all** system headers. To obtain; system level functionality, LLVM source must; ``#include ""llvm/Support/Thing.h""`` and nothing else. This means that; ``Thing.h`` cannot expose any system header files. This protects LLVM from; accidentally using system specific functionality and only allows it via; the ``lib/Support`` interface. Use Standard C Headers; ----------------------. The **standard** C headers (the ones beginning with ""c"") are allowed to be; exposed through the ``lib/Support`` interface. These headers and the things they; declare are considered to be platform agnostic. LLVM source files may include; them directly or obtain their inclusion through ``lib/Support`` interfaces. Use Standard C++ Headers; ------------------------. The **standard** C++ headers from the standard C++ library and standard; template library may be exposed through the ``lib/Support`` interface. These; headers and the things they declare are considered to be platform agnostic.; LLVM source files may include them or obtain their inclusion through; ``lib/Support`` interfaces. High Level Interface; --------------------. The entry points specified in the interface of ``lib/Support`` must be aimed at; completing some reasonably high level task needed by LLVM. We do not want to; simply wrap each operating system call. It would be preferable to wrap several; operating system calls that are always used in conjunction with one another by; LLVM. F",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:3317,interface,interface,3317,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['interface'],['interface']
Integrability,"les the test if all expressions are true.; | ``UNSUPPORTED`` disables the test if any expression is true.; | ``XFAIL`` expects the test to fail if any expression is true. As a special case, ``XFAIL: *`` is expected to fail everywhere. .. code-block:: llvm. ; This test is disabled when running on Windows,; ; and is disabled when targeting Linux, except for Android Linux.; ; UNSUPPORTED: system-windows, target={{.*linux.*}} && !target={{.*android.*}}; ; This test is expected to fail when targeting PowerPC or running on Darwin.; ; XFAIL: target=powerpc{{.*}}, system-darwin. Tips for writing constraints; ----------------------------. **``REQUIRES`` and ``UNSUPPORTED``**. These are logical inverses. In principle, ``UNSUPPORTED`` isn't absolutely; necessary (the logical negation could be used with ``REQUIRES`` to get; exactly the same effect), but it can make these clauses easier to read and; understand. Generally, people use ``REQUIRES`` to state things that the test; depends on to operate correctly, and ``UNSUPPORTED`` to exclude cases where; the test is expected never to work. **``UNSUPPORTED`` and ``XFAIL``**. Both of these indicate that the test isn't expected to work; however, they; have different effects. ``UNSUPPORTED`` causes the test to be skipped;; this saves execution time, but then you'll never know whether the test; actually would start working. Conversely, ``XFAIL`` actually runs the test; but expects a failure output, taking extra execution time but alerting you; if/when the test begins to behave correctly (an XPASS test result). You; need to decide which is more appropriate in each case. **Using ``target=...``**. Checking the target triple can be tricky; it's easy to mis-specify. For; example, ``target=mips{{.*}}`` will match not only mips, but also mipsel,; mips64, and mips64el. ``target={{.*}}-linux-gnu`` will match; x86_64-unknown-linux-gnu, but not armv8l-unknown-linux-gnueabihf.; Prefer to use hyphens to delimit triple components (``target=mips-{{.*}}",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:22156,depend,depends,22156,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['depend'],['depends']
Integrability,"les; to generate: ``sync`` for normal unwind tables, ``async`` for asynchronous; (instruction precise) unwind tables. Without the parameter, the attribute; ``uwtable`` is equivalent to ``uwtable(async)``.; ``nocf_check``; This attribute indicates that no control-flow check will be performed on; the attributed entity. It disables -fcf-protection=<> for a specific; entity to fine grain the HW control flow protection mechanism. The flag; is target independent and currently appertains to a function or function; pointer.; ``shadowcallstack``; This attribute indicates that the ShadowCallStack checks are enabled for; the function. The instrumentation checks that the return address for the; function has not changed between the function prolog and epilog. It is; currently x86_64-specific. .. _langref_mustprogress:. ``mustprogress``; This attribute indicates that the function is required to return, unwind,; or interact with the environment in an observable way e.g. via a volatile; memory access, I/O, or other synchronization. The ``mustprogress``; attribute is intended to model the requirements of the first section of; [intro.progress] of the C++ Standard. As a consequence, a loop in a; function with the `mustprogress` attribute can be assumed to terminate if; it does not interact with the environment in an observable way, and; terminating loops without side-effects can be removed. If a `mustprogress`; function does not satisfy this contract, the behavior is undefined. This; attribute does not apply transitively to callees, but does apply to call; sites within the function. Note that `willreturn` implies `mustprogress`.; ``""warn-stack-size""=""<threshold>""``; This attribute sets a threshold to emit diagnostics once the frame size is; known should the frame size exceed the specified value. It takes one; required integer value, which should be a non-negative integer, and less; than `UINT_MAX`. It's unspecified which threshold will be used when; duplicate definitions are linked to",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:109992,synchroniz,synchronization,109992,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['synchroniz'],['synchronization']
Integrability,"less of that; implementation, however. For example, if a1.cpp and a2.cpp both define a; function ""foo"" then ORCv2 will generate a duplicate definition error. On the; other hand, if a1.cpp and b1.cpp both define ""foo"" there is no error (different; dynamic libraries may define the same symbol). If main.cpp refers to ""foo"", it; should bind to the definition in LibA rather than the one in LibB, since; main.cpp is part of the ""main"" dylib, and the main dylib links against LibA; before LibB. Many JIT clients will have no need for this strict adherence to the usual; ahead-of-time linking rules, and should be able to get by just fine by putting; all of their code in a single JITDylib. However, clients who want to JIT code; for languages/projects that traditionally rely on ahead-of-time linking (e.g.; C++) will find that this feature makes life much easier. Symbol lookup in ORC serves two other important functions, beyond providing; addresses for symbols: (1) It triggers compilation of the symbol(s) searched for; (if they have not been compiled already), and (2) it provides the; synchronization mechanism for concurrent compilation. The pseudo-code for the; lookup process is:. .. code-block:: none. construct a query object from a query set and query handler; lock the session; lodge query against requested symbols, collect required materializers (if any); unlock the session; dispatch materializers (if any). In this context a materializer is something that provides a working definition; of a symbol upon request. Usually materializers are just wrappers for compilers,; but they may also wrap a jit-linker directly (if the program representation; backing the definitions is an object file), or may even be a class that writes; bits directly into memory (for example, if the definitions are; stubs). Materialization is the blanket term for any actions (compiling, linking,; splatting bits, registering with runtimes, etc.) that are required to generate a; symbol definition that is safe to",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:9453,synchroniz,synchronization,9453,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['synchroniz'],['synchronization']
Integrability,"less, some of the them also offer some security checks or a better precision, like the trigonometrical functions `ASin(x)`, `ACos(x)` or `ATan(x)`. ```{.cpp}; // Generate a vector with 10 random numbers; vector<double> v(10);; std::generate(v.begin(), v.end(), rand);. // Find the minimum value of the vector (iterator version); vector<double>::iterator it;; it = TMath::LocMin(v.begin(), v.end());; std::cout << *it << std::endl;. // The same with the old-style version; int i;; i = TMath::LocMin(10, &v[0]);; std::cout << v[i] << std::endl;; ```. Another example of these functions can be found in $ROOTSYS/tutorials/permute.C. ### Statistic Functions Operating on Arrays. This set of functions processes arrays to calculate:. * Mean.; * Median.; * Geometrical mean.; * Sample Standard Deviation (*RMS*).; * The kth smallest element. These functions, as the array algorithms, have two different interfaces. An old-style one where the size of the array is passed as a first argument followed by a pointer to the array itself; and a modern C++-like interface that receives two iterators to it. ```{.cpp}; // Size of the array; const int n = 100;. // Vector v with random values; vector<double> v(n);; std::generate(v.begin(), v.end(), rand);. // Weight vector w; vector<double> w(n);; std::fill(w.begin(), w.end, 1);. double mean;. // Calculate the mean of the vector; // with iterators; mean = TMath::Mean(v.begin(), v.end());. // old-style; mean = TMath::Mean(n, &v[0]);. // Calculate the mean with a weight vector; // with iterators; mean = TMath::Mean(v.begin(), v.end(), w.begin());. // old-style; mean = TMath::Mean(n, &v[0], &w[0]);; ```. ### Special and Statistical Functions. `TMath` also provides special functions like Bessel, Error functions, Gamma or similar plus statistical mathematical functions, including probability density functions, cumulative distribution and their inverse. The majority of the special functions and the statistical distributions are provided also as free functi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:8816,interface,interface,8816,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['interface'],['interface']
Integrability,"lete index; expressions on matrix types or builtin functions without an argument list) as placement-args; to new-expressions. Before:. .. code-block:: text. error: no matching function for call to 'operator new'; 13 | new (__builtin_memset) S {};; | ^ ~~~~~~~~~~~~~~~~~~. note: candidate function not viable: no known conversion from '<builtin fn type>' to 'int' for 2nd argument; 5 | void* operator new(__SIZE_TYPE__, int);; | ^. After:. .. code-block:: text. error: builtin functions must be directly called; 13 | new (__builtin_memset) S {};; | ^. - Clang now diagnoses import before module declarations but not in global; module fragment.; (`#67627 <https://github.com/llvm/llvm-project/issues/67627>`_). - Clang now diagnoses include headers with angle in module purviews, which is; not usually intended.; (`#68615 <https://github.com/llvm/llvm-project/issues/68615>`_). - Clang now won't mention invisible namespace when diagnose invisible declarations; inside namespace. The original diagnostic message is confusing.; (`#73893 <https://github.com/llvm/llvm-project/issues/73893>`_). Improvements to Clang's time-trace; ----------------------------------; - Two time-trace scope variables are added. A time trace scope variable of; ``ParseDeclarationOrFunctionDefinition`` with the function's source location; is added to record the time spent parsing the function's declaration or; definition. Another time trace scope variable of ``ParseFunctionDefinition``; is also added to record the name of the defined function. Bug Fixes in This Version; -------------------------; - Fixed an issue where a class template specialization whose declaration is; instantiated in one module and whose definition is instantiated in another; module may end up with members associated with the wrong declaration of the; class, which can result in miscompiles in some cases.; - Fix crash on use of a variadic overloaded operator.; (`#42535 <https://github.com/llvm/llvm-project/issues/42535>`_); - Fix a hang on ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:32420,message,message,32420,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['message'],['message']
Integrability,"level contributions. If you commit a patch for someone; else, please follow the attribution of changes in the simple manner as outlined; by the `commit messages`_ section. Overall, please do not add contributor names; to the source code. Also, don't commit patches authored by others unless they have submitted the; patch to the project or you have been authorized to submit them on their behalf; (you work together and your company authorized you to contribute the patches,; etc.). The author should first submit them to the relevant project's commit; list, development list, or LLVM bug tracker component. If someone sends you; a patch privately, encourage them to submit it to the appropriate list first. Our previous version control system (subversion) did not distinguish between the; author and the committer like git does. As such, older commits used a different; attribution mechanism. The previous method was to include ""Patch by John Doe.""; in a separate line of the commit message and there are automated processes that; rely on this format. .. _IR backwards compatibility:. IR Backwards Compatibility; --------------------------. When the IR format has to be changed, keep in mind that we try to maintain some; backwards compatibility. The rules are intended as a balance between convenience; for llvm users and not imposing a big burden on llvm developers:. * The textual format is not backwards compatible. We don't change it too often,; but there are no specific promises. * Additions and changes to the IR should be reflected in; ``test/Bitcode/compatibility.ll``. * The current LLVM version supports loading any bitcode since version 3.0. * After each X.Y release, ``compatibility.ll`` must be copied to; ``compatibility-X.Y.ll``. The corresponding bitcode file should be assembled; using the X.Y build and committed as ``compatibility-X.Y.ll.bc``. * Newer releases can ignore features from older releases, but they cannot; miscompile them. For example, if nsw is ever replaced with ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:31197,message,message,31197,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['message'],['message']
Integrability,"lf.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMethodDecl>isClassMethod; Returns true when the Objective-C method declaration is a class method. Example; matcher = objcMethodDecl(isClassMethod()); matches; @interface I + (void)foo; @end; but not; @interface I - (void)bar; @end. Matcher<ObjCMethodDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<ObjCMethodDecl>isInstanceMethod; Returns true when the Objective-C method declaration is an instance method. Example; matcher = objcMethodDecl(isInstanceMethod()); matches; @interface I - (void)bar; @end; but not; @interface I + (void)foo; @end. Matcher<ParmVarDecl>hasDefaultArgument; Matches a declaration that has default arguments. Example matches y (matcher = parmVarDecl(hasDefaultArgument())); void x(int val) {}; void y(int val = 0) {}. Deprecated. Use hasInitializer() instead to be able to; match on the contents of the default argument. For example:. void x(int val = 7) {}; void y(int val = 42) {}; parmVarDecl(hasInitializer(integerLiteral(equals(42)))); matches the parameter of y. A matcher such as; parmVarDecl(hasInitializer(anything())); is equivalent to parmVarDecl(hasDefaultArgument()). Matcher<ParmVarDecl>isAtPositionunsigned N; Matches the ParmVarDecl nodes that are at the N'th position in the parameter; list. The parameter list could be that of either a block, function, or; objc-method. Given. void f(int a, int b, int c) {; }. ``parmVarDecl(isAtPosition(0))`` matches ``int a``. ``parmVarDecl(isAtPosition(1))`` matches ``int b``. Matcher<QualType>",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:109678,interface,interface,109678,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,4,['interface'],['interface']
Integrability,"li->SetLineColor(color); ```. The argument `color` is a color number. The colors are described in; ""Color and Color Palettes"". The line style may be set by a method call. What is said here applies to; all objects deriving from **`TAttLine`**, and there are many; (histograms, plots). We will take an example that may be transposed to; other types. Suppose ""`li`"" is a **`TLine`** object. The line style is; set with:. ``` {.cpp}; root[] li->SetLineStyle(style); ```. The argument style is one of: 1=solid, 2=dash, 3=dot, 4=dash-dot. The line width may be set by a method call. What is said here applies to; all objects deriving from **`TAttLine`**, and there are many; (histograms, plots). We will take an example that may be transposed to; other types. Suppose ""`li`"" is a **`TLine`** object. The line width is; set with:. ``` {.cpp}; root[] li->SetLineWidth(width); ```. The `width` is the width expressed in pixel units. ![](pictures/030000D1.png) The user interface for changing the line; color, line width and style looks like shown in this picture. It takes; place in the editor frame anytime the selected object inherits the class; **`TAttLine`**. ### Fill Attributes. Almost all graphics classes have a fill area somewhere. These classes; have to deal with fill attributes. This is done by using secondary; inheritance of the class **`TAttFill`**. Fill color may be set by a; method call. What is said here applies to all objects deriving from; **`TAttFill`**, and there are many (histograms, plots). We will take an; example that may be transposed to other types. Suppose ""`h`"" is a; **`TH1F`** (1 dim histogram) object. The histogram fill color is set; with:. ``` {.cpp}; root[] h->SetFillColor(color); ```. The color is a color number. The colors are described in ""Color and; color palettes"". Fill style may be set by a method call. What is said here applies to all; objects deriving from `TAttFill`, and there are many (histograms,; plots). We will take an example that may be transposed ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:77055,interface,interface,77055,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['interface'],['interface']
Integrability,"lib-path`` compiler option; 2. ``HIP_DEVICE_LIB_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). .. list-table::; :header-rows: 1. * - Compiler Option; - Environment Variable; - Description; - Default Value; * - ``--rocm-path=<path>``; - ``ROCM_PATH``; - Specifies the ROCm installation path.; - Automatic detection; * - ``--hip-path=<path>``; - ``HIP_PATH``; - Specifies the HIP runtime installation path.; - Determined by ROCm directory structure; * - ``--hip-device-lib-path=<path>``; - ``HIP_DEVICE_LIB_PATH``; - Specifies the HIP device library installation path.; - Determined by ROCm directory structure. .. note::. We recommend using the compiler options as the primary method for specifying these paths. While the environment variables ``ROCM_PATH``, ``HIP_PATH``, and ``HIP_DEVICE_LIB_PATH`` are supported, their use can lead to implicit dependencies that might cause issues in the long run. Use them with caution. Predefined Macros; =================. .. list-table::; :header-rows: 1. * - Macro; - Description; * - ``__CLANG_RDC__``; - Defined when Clang is compiling code in Relocatable Device Code (RDC) mode. RDC, enabled with the ``-fgpu-rdc`` compiler option, is necessary for linking device codes across translation units.; * - ``__HIP__``; - Defined when compiling with HIP language support, indicating that the code targets the HIP environment.; * - ``__HIPCC__``; - Alias to ``__HIP__``.; * - ``__HIP_DEVICE_COMPILE__``; - Defined during device code compilation in Clang's separate compilation process for the host and each offloading GPU architecture.; * - ``__HIP_MEMORY_SCOPE_SINGLETHREAD``; - Represents single-thread memory scope in HIP (value is 1).; * - ``__HIP_MEMORY_SCOPE_WAVEFRONT``; - Represents wavefront memory scope in HIP (value is 2).; * - ``__HIP_MEMORY_SCOPE_WORKGROU",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst:5443,depend,dependencies,5443,interpreter/llvm-project/clang/docs/HIPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst,1,['depend'],['dependencies']
Integrability,"libraries get confused if you don't; # explicitly specify an architecture setting with the Xcode generator.; set(CMAKE_OSX_ARCHITECTURES ""x86_64""); endif(). project(LLVM; VERSION ${LLVM_VERSION_MAJOR}.${LLVM_VERSION_MINOR}.${LLVM_VERSION_PATCH}; LANGUAGES C CXX ASM). if (NOT DEFINED CMAKE_INSTALL_LIBDIR AND DEFINED LLVM_LIBDIR_SUFFIX); # Must go before `include(GNUInstallDirs)`.; set(CMAKE_INSTALL_LIBDIR ""lib${LLVM_LIBDIR_SUFFIX}""); endif(). # Must go after `DEFINED LLVM_LIBDIR_SUFFIX` check.; set(LLVM_LIBDIR_SUFFIX """" CACHE STRING ""Define suffix of library directory name (32/64)"" ). # Must go after `project(..)`.; include(GNUInstallDirs). # This C++ standard is required to build LLVM.; set(LLVM_REQUIRED_CXX_STANDARD 17). # If we find that the cache contains CMAKE_CXX_STANDARD it means that it's a old CMakeCache.txt; # and we can just inform the user and then reset it.; if($CACHE{CMAKE_CXX_STANDARD} AND $CACHE{CMAKE_CXX_STANDARD} LESS ${LLVM_REQUIRED_CXX_STANDARD}); message(WARNING ""Resetting cache value for CMAKE_CXX_STANDARD to ${LLVM_REQUIRED_CXX_STANDARD}""); unset(CMAKE_CXX_STANDARD CACHE); endif(). # if CMAKE_CXX_STANDARD is still set after the cache unset above it means that the user requested it; # and we allow it to be set to something newer than the required standard but otherwise we fail.; if(DEFINED CMAKE_CXX_STANDARD AND CMAKE_CXX_STANDARD LESS ${LLVM_REQUIRED_CXX_STANDARD}); message(FATAL_ERROR ""Requested CMAKE_CXX_STANDARD=${CMAKE_CXX_STANDARD} which is less than the required ${LLVM_REQUIRED_CXX_STANDARD}.""); endif(). set(CMAKE_CXX_STANDARD ${LLVM_REQUIRED_CXX_STANDARD} CACHE STRING ""C++ standard to conform to""); set(CMAKE_CXX_STANDARD_REQUIRED YES). if (CYGWIN); # Cygwin is a bit stricter and lack things like 'strdup', 'stricmp', etc in; # c++xx mode.; set(CMAKE_CXX_EXTENSIONS YES); else(); set(CMAKE_CXX_EXTENSIONS NO); endif(). if (NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES); message(FATAL_ERROR ""; No build type selected. You need to pass ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:2884,message,message,2884,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['message'],['message']
Integrability,"libz`` and the ``Cocoa``; framework::. !0 = !{ !""-lz"" }; !1 = !{ !""-framework"", !""Cocoa"" }; !llvm.linker.options = !{ !0, !1 }. The metadata encoding as lists of lists of options, as opposed to a collapsed; list of options, is chosen so that the IR encoding can use multiple option; strings to specify e.g., a single library, while still having that specifier be; preserved as an atomic element that can be recognized by a target specific; assembly writer or object file emitter. Each individual option is required to be either a valid option for the target's; linker, or an option that is reserved by the target specific assembly writer or; object file emitter. No other aspect of these options is defined by the IR. Dependent Libs Named Metadata; =============================. Some targets support embedding of strings into object files to indicate; a set of libraries to add to the link. Typically this is used in conjunction; with language extensions which allow source files to explicitly declare the; libraries they depend on, and have these automatically be transmitted to the; linker via object files. The list is encoded in the IR using named metadata with the name; ``!llvm.dependent-libraries``. Each operand is expected to be a metadata node; which should contain a single string operand. For example, the following metadata section contains two library specifiers::. !0 = !{!""a library specifier""}; !1 = !{!""another library specifier""}; !llvm.dependent-libraries = !{ !0, !1 }. Each library specifier will be handled independently by the consuming linker.; The effect of the library specifiers are defined by the consuming linker. .. _summary:. ThinLTO Summary; ===============. Compiling with `ThinLTO <https://clang.llvm.org/docs/ThinLTO.html>`_; causes the building of a compact summary of the module that is emitted into; the bitcode. The summary is emitted into the LLVM assembly and identified; in syntax by a caret ('``^``'). The summary is parsed into a bitcode output, along wit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:337990,depend,depend,337990,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['depend']
Integrability,"licit; conversion, a second round is tried where implicit conversion, including; instantiation of temporaries, is allowed.; The implicit creation of temporaries, although convenient, can be costly in; terms of run-time performance. During some template calls, implicit conversion is not allowed, giving; preference to new instantiations (as is the case in C++).; If, however, a previously instantiated overload is available and would match; with promotion, it is preferred over a (costly) new instantiation, unless a; template overload is explicitly selected using template arguments.; For example:. .. code-block:: python. >>> cppyy.cppdef(r""""""\; ... template<typename T>; ... T process_T(T t) { return t; }""""""); True; >>> type(cppyy.gbl.process_T(1.0)); <class 'float'>; >>> type(cppyy.gbl.process_T(1)) # selects available ""double"" overload; <class 'float'>; >>> type(cppyy.gbl.process_T[int](1)) # explicit selection of ""int"" overload; <class 'int'>; >>>. The template parameters used for instantiation can depend on the argument; values.; For example, if the type of an argument is Python ``int``, but its value is; too large for a 4-byte C++ ``int``, the template may be instantiated with,; for example, an ``int64_t`` instead (if available on the platform).; Since Python does not have unsigned types, the instantiation mechanism; strongly prefers signed types.; However, if an argument value is too large to fit in a signed integer type,; but would fit in an unsigned type, then that will be used. If it is important that a specific overload is selected, then use the; ``__overload__`` method to match a specific function signature.; An optional boolean second parameter can be used to restrict the selected; method to be const (if ``True``) or non-const (if ``False``).; The return value of which is a first-class callable object, that can be; stored to by-pass the overload resolution:. .. code-block:: python. >>> gf_double = global_function.__overload__('double'); >>> gf_double(1) # int i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/functions.rst:8399,depend,depend,8399,bindings/pyroot/cppyy/cppyy/doc/source/functions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/functions.rst,1,['depend'],['depend']
Integrability,"lick; *Continue*.; * Leave the Repository field blank. (We previously filled out the Repository; for the review request.); * Add comments about the changes in the new diff. Click *Save*. Choosing reviewers: You typically pick one or two people as initial reviewers.; This choice is not crucial, because you are merely suggesting and not requiring; them to participate. Many people will see the email notification on cfe-commits; or llvm-commits, and if the subject line suggests the patch is something they; should look at, they will. .. _creating-a-patch-series:. Creating a patch series; -----------------------. Chaining reviews together requires some manual work. There are two ways to do it; (these are also described `here <https://moz-conduit.readthedocs.io/en/latest/arcanist-user.html#series-of-commits>`_; along with some screenshots of what to expect). .. _using-the-web-interface:. Using the web interface; ^^^^^^^^^^^^^^^^^^^^^^^. This assumes that you've already created a Phabricator review for each commit,; using `arc` or the web interface. * Go to what will be the last review in the series (the most recent).; * Click ""Edit Related Revisions"" then ""Edit Parent Revisions"".; * This will open a dialog where you will enter the patch number of the parent patch; (or patches). The patch number is of the form D<number> and you can find it by; looking at the URL for the review e.g. reviews.llvm/org/D12345.; * Click ""Save Parent Revisions"" after entering them.; * You should now see a ""Stack"" tab in the ""Revision Contents"" section of the web; interface, showing the parent patch that you added. Repeat this with each previous review until you reach the first in the series. This; one won't have a parent since it's the start of the series. If you prefer to start with the first in the series and go forward, you can use the; ""Edit Child Revisions"" option instead. .. _using-patch-summaries:. Using patch summaries; ^^^^^^^^^^^^^^^^^^^^^. This applies to new and existing reviews, uplo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:5618,interface,interface,5618,interpreter/llvm-project/llvm/docs/Phabricator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst,1,['interface'],['interface']
Integrability,"ligned stores of the same width as the unaligned store. Backends are; also expected to generate an i8 store as an i8 store, and not an instruction; which writes to surrounding bytes. (If you are writing a backend for an; architecture which cannot satisfy these restrictions and cares about; concurrency, please send an email to llvm-dev.). Unordered; ---------. Unordered is the lowest level of atomicity. It essentially guarantees that races; produce somewhat sane results instead of having undefined behavior. It also; guarantees the operation to be lock-free, so it does not depend on the data; being part of a special atomic structure or depend on a separate per-process; global lock. Note that code generation will fail for unsupported atomic; operations; if you need such an operation, use explicit locking. Relevant standard; This is intended to match the Java memory model for shared variables. Notes for frontends; This cannot be used for synchronization, but is useful for Java and other; ""safe"" languages which need to guarantee that the generated code never; exhibits undefined behavior. Note that this guarantee is cheap on common; platforms for loads of a native width, but can be expensive or unavailable for; wider loads, like a 64-bit store on ARM. (A frontend for Java or other ""safe""; languages would normally split a 64-bit store on ARM into two 32-bit unordered; stores.). Notes for optimizers; In terms of the optimizer, this prohibits any transformation that transforms a; single load into multiple loads, transforms a store into multiple stores,; narrows a store, or stores a value which would not be stored otherwise. Some; examples of unsafe optimizations are narrowing an assignment into a bitfield,; rematerializing a load, and turning loads and stores into a memcpy; call. Reordering unordered operations is safe, though, and optimizers should; take advantage of that because unordered operations are common in languages; that need them. Notes for code generation; These o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst:8533,synchroniz,synchronization,8533,interpreter/llvm-project/llvm/docs/Atomics.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst,1,['synchroniz'],['synchronization']
Integrability,"line; D: Miscellaneous bug fixes; D: WebAssembly Backend. N: Renato Golin; E: rengolin@systemcall.eu; E: rengolin@gmail.com; D: ARM/AArch64 back-end improvements; D: Loop Vectorizer improvements; D: Regression and Test Suite improvements; D: Linux compatibility (GNU, musl, etc); D: Initial Linux kernel / Android support effort; I: rengolin. N: David Goodwin; E: david@goodwinz.net; D: Thumb-2 code generator. N: David Greene; E: greened@obbligato.org; D: Miscellaneous bug fixes; D: Register allocation refactoring. N: Gabor Greif; E: ggreif@gmail.com; D: Improvements for space efficiency. N: James Grosbach; E: grosbach@apple.com; I: grosbach; D: SjLj exception handling support; D: General fixes and improvements for the ARM back-end; D: MCJIT; D: ARM integrated assembler and assembly parser; D: Led effort for the backend formerly known as ARM64. N: Lang Hames; E: lhames@gmail.com; D: PBQP-based register allocator. N: Gordon Henriksen; E: gordonhenriksen@mac.com; D: Pluggable GC support; D: C interface; D: Ocaml bindings. N: Raul Fernandes Herbster; E: raul@dsc.ufcg.edu.br; D: JIT support for ARM. N: Paolo Invernizzi; E: arathorn@fastwebnet.it; D: Visual C++ compatibility fixes. N: Patrick Jenkins; E: patjenk@wam.umd.edu; D: Nightly Tester. N: Tony(Yanjun) Jiang; E: jtony@ca.ibm.com; D: PowerPC Backend Developer; D: Improvements to the PPC backend and miscellaneous bug fixes. N: Dale Johannesen; E: dalej@apple.com; D: ARM constant islands improvements; D: Tail merging improvements; D: Rewrite X87 back end; D: Use APFloat for floating point constants widely throughout compiler; D: Implement X87 long double. N: Brad Jones; E: kungfoomaster@nondot.org; D: Support for packed types. N: Rod Kay; E: rkay@auroraux.org; D: Author of LLVM Ada bindings. N: Erich Keane; E: erich.keane@intel.com; D: A variety of Clang contributions including function multiversioning, regcall/vectorcall.; I: ErichKeane. N: Eric Kidd; W: http://randomhacks.net/; D: llvm-config script. N: Anton Korobeyn",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CREDITS.TXT:5322,interface,interface,5322,interpreter/llvm-project/llvm/CREDITS.TXT,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CREDITS.TXT,1,['interface'],['interface']
Integrability,"ling LLVM and Clang; set(CMAKE_CXX_FLAGS ${cxx_flags_prev}); unset(cxx_flags_prev). add_custom_target(CLING); set(CLING_LIBRARIES clingInterpreter;clingMetaProcessor;clingUtils CACHE STRING """"); if (builtin_cling). # Extract the compilation flags from LLVM and make them public to the; # rest of ROOT so that we can compile against LLVM with matching flags. # LLVM doesn't really give us a API to get this with an in-source build; # so we just use the normal way of doing this and read the llvm directory; # compilation properties.; if (builtin_llvm); get_directory_property(LLVM_DEFS DIRECTORY llvm-project/llvm COMPILE_DEFINITIONS); # Turns DEFINE1;DEFINE2 to -DDEFINE1 -DDEFINE2; string (REPLACE "";"" "" -D"" LLVM_DEFS "";${LLVM_DEFS}""); endif(). # FIXME: Reduce the usage of CLING_CXXFLAGS by adding a cmake routine in; # RootMacros.cmake for all cling-dependent libraries; if(MSVC); set(CLING_CXXFLAGS "" ${LLVM_DEFS} -DNOMINMAX -D_XKEYCHECK_H""); else(); # FIXME: Work hard to remove -Wno-shadow and -Wno-unused-parameter; set(CLING_CXXFLAGS "" ${LLVM_DEFS} -fno-strict-aliasing -Wwrite-strings -Wno-shadow -Wno-unused-parameter -Wno-deprecated-declarations""); endif(). # Set the flags in the parent scope for the rest of the cling-based libraries in ROOT.; set(CLING_CXXFLAGS ${CLING_CXXFLAGS} PARENT_SCOPE). string(APPEND CMAKE_CXX_FLAGS ${CLING_CXXFLAGS}); if (LLVM_ENABLE_PIC AND NOT MSVC); # FIXME: LLVM_ENABLE_PIC is ON by default, however not propagated to cling.; # FIXME: fPIC is required by the linker for libCling. Can we do that using; # cmake: set_property(TARGET clingInterpreter PROPERTY POSITION_INDEPENDENT_CODE ON)?; string(APPEND CMAKE_CXX_FLAGS "" -fPIC""); string(APPEND CMAKE_C_FLAGS "" -fPIC""); endif(LLVM_ENABLE_PIC AND NOT MSVC); # Avoid cling being installed under ROOTSYS/include.; set(CLING_ROOT_BUILD ON); add_subdirectory(cling EXCLUDE_FROM_ALL); add_dependencies(CLING ${CLING_LIBRARIES}). set(CLING_INCLUDE_DIRS ${CMAKE_SOURCE_DIR}/interpreter/cling/include CACHE STRING """"",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt:21233,depend,dependent,21233,interpreter/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt,1,['depend'],['dependent']
Integrability,"ling conventions. However, Microsoft's; extension is non-conforming. Template instantiation and name lookup; ======================================. MSVC allows many invalid constructs in class templates that Clang has; historically rejected. In order to parse widely distributed headers for; libraries such as the Active Template Library (ATL) and Windows Runtime Library; (WRL), some template rules have been relaxed or extended in Clang on Windows. The first major semantic difference is that MSVC appears to defer all parsing; an analysis of inline method bodies in class templates until instantiation; time. By default on Windows, Clang attempts to follow suit. This behavior is; controlled by the ``-fdelayed-template-parsing`` flag. While Clang delays; parsing of method bodies, it still parses the bodies *before* template argument; substitution, which is not what MSVC does. The following compatibility tweaks; are necessary to parse the template in those cases. MSVC allows some name lookup into dependent base classes. Even on other; platforms, this has been a `frequently asked question`_ for Clang users. A; dependent base class is a base class that depends on the value of a template; parameter. Clang cannot see any of the names inside dependent bases while it; is parsing your template, so the user is sometimes required to use the; ``typename`` keyword to assist the parser. On Windows, Clang attempts to; follow the normal lookup rules, but if lookup fails, it will assume that the; user intended to find the name in a dependent base. While parsing the; following program, Clang will recover as if the user had written the; commented-out code:. .. _frequently asked question:; https://clang.llvm.org/compatibility.html#dep_lookup. .. code-block:: c++. template <typename T>; struct Foo : T {; void f() {; /*typename*/ T::UnknownType x = /*this->*/unknownMember;; }; };. After recovery, Clang warns the user that this code is non-standard and issues; a hint suggesting how to fix the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst:5778,depend,dependent,5778,interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,1,['depend'],['dependent']
Integrability,"ling distributions for a user-defined test statistic. �; The following concrete implementations of the TestStatistic interface; are currently available. ProfileLikelihoodTestStatReturns the log of profile; likelihood ratio. �Generally a powerful test statistic. ; NumEventsTestStatReturns the number of events in the; dataset. �Useful for number counting experiments.; DebuggingTestStat Simply returns a uniform random number; between 0,1. �Useful for debugging. SamplingDistribution and the�TestStatSampler interface and; implementations; We introduced a ``result'' or data model class called; SamplingDistribution, which holds the sampling distribution of an; arbitrary real valued test statistic. �The class also can return the; inverse of the cumulative distribution function (with or without; interpolation). �; We introduced an interface for any tool that can produce a; SamplingDistribution, called TestStatSampler. �The interface is; essentially GetSamplingDistribution(parameterPoint) which returns a; SamplingDistribution based on a given probability density function. �We; foresee a few versions of this tool based on toy Monte Carlo, importance; sampling, Fourier transforms, etc. �The following concrete implementation; of the TestStatSampler interface are currently available. ToyMCSamplerUses a Toy Monte Carlo approach to build the; sampling distribution. �The pdf's generate method to generate is used to; generate toy data, and then the test statistic is evaluated at the; requested parameter point. ; DebuggingSampler Simply returns a uniform distribution; between 0,1. �Useful for debugging. NeymanConstruction and FeldmanCousins; A flexible framework for the Neyman Construction was added in this; release. The NeymanConstruction is a concrete implementation of the; IntervalCalculator interface, but it needs several; additional components�to be specified before use. The design; factorizes the choice of the parameter points to be tested,�the choice of; the test statistic, and",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:26987,interface,interface,26987,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,2,['interface'],['interface']
Integrability,ling/Syntax/Pseudo/Grammar.cpp; clang/lib/Tooling/Syntax/Pseudo/GrammarBNF.cpp; clang/lib/Tooling/Syntax/Pseudo/Lex.cpp; clang/lib/Tooling/Syntax/Pseudo/LRGraph.cpp; clang/lib/Tooling/Syntax/Pseudo/LRTable.cpp; clang/lib/Tooling/Syntax/Pseudo/LRTableBuild.cpp; clang/lib/Tooling/Syntax/Pseudo/Preprocess.cpp; clang/lib/Tooling/Syntax/Pseudo/Token.cpp; clang/lib/Tooling/Transformer/Parsing.cpp; clang/lib/Tooling/Transformer/SourceCodeBuilders.cpp; clang/lib/Tooling/Transformer/Stencil.cpp; clang/lib/Tooling/Transformer/Transformer.cpp; clang/tools/amdgpu-arch/AMDGPUArch.cpp; clang/tools/apinotes-test/APINotesTest.cpp; clang/tools/clang-format/ClangFormat.cpp; clang/tools/clang-fuzzer/ClangFuzzer.cpp; clang/tools/clang-fuzzer/DummyClangFuzzer.cpp; clang/tools/clang-fuzzer/ExampleClangLLVMProtoFuzzer.cpp; clang/tools/clang-fuzzer/ExampleClangLoopProtoFuzzer.cpp; clang/tools/clang-fuzzer/handle-llvm/handle_llvm.h; clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp; clang/tools/clang-linker-wrapper/OffloadWrapper.cpp; clang/tools/clang-pseudo/ClangPseudo.cpp; clang/tools/clang-refactor/ClangRefactor.cpp; clang/tools/clang-refactor/TestSupport.cpp; clang/tools/clang-refactor/TestSupport.h; clang/tools/clang-refactor/ToolRefactoringResultConsumer.h; clang/tools/clang-rename/ClangRename.cpp; clang/tools/clang-repl/ClangRepl.cpp; clang/tools/clang-scan-deps/ClangScanDeps.cpp; clang/tools/clang-shlib/clang-shlib.cpp; clang/tools/driver/cc1gen_reproducer_main.cpp; clang/tools/libclang/CIndex.cpp; clang/tools/libclang/CIndexUSRs.cpp; clang/tools/libclang/CursorVisitor.h; clang/tools/libclang/CXCursor.cpp; clang/tools/libclang/CXCursor.h; clang/tools/scan-build-py/tests/functional/src/include/clean-one.h; clang/unittests/Analysis/CFGBuildResult.h; clang/unittests/Analysis/MacroExpansionContextTest.cpp; clang/unittests/Analysis/FlowSensitive/DataflowAnalysisContextTest.cpp; clang/unittests/Analysis/FlowSensitive/DataflowEnvironmentTest.cpp; clang/unittests/Analysis/FlowSensitiv,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:27895,wrap,wrapper,27895,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['wrap'],['wrapper']
Integrability,"list(APPEND LLVM_COMMON_DEPENDS intrinsics_gen). list(APPEND LLVM_TABLEGEN_FLAGS -I ${LLVM_MAIN_SRC_DIR}/lib/Target). add_llvm_component_library(LLVMTarget; Target.cpp; TargetIntrinsicInfo.cpp; TargetLoweringObjectFile.cpp; TargetMachine.cpp; TargetMachineC.cpp. ADDITIONAL_HEADER_DIRS; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Target. LINK_COMPONENTS; Analysis; Core; MC; Support; TargetParser; ). # When building shared objects for each target there are some internal APIs; # that are used across shared objects which we can't hide.; if (NOT BUILD_SHARED_LIBS AND NOT APPLE AND; (NOT (WIN32 OR CYGWIN) OR (MINGW AND CMAKE_CXX_COMPILER_ID MATCHES ""Clang"")) AND; NOT (${CMAKE_SYSTEM_NAME} MATCHES ""AIX"") AND; NOT DEFINED CMAKE_CXX_VISIBILITY_PRESET); # Set default visibility to hidden, so we don't export all the Target classes; # in libLLVM.so.; set(CMAKE_CXX_VISIBILITY_PRESET hidden); endif(). foreach(t ${LLVM_TARGETS_TO_BUILD}); message(STATUS ""Targeting ${t}""); add_subdirectory(${t}); endforeach(). # Currently we do not allow libraries from lib to reference targets directly.; # This property is used to enforce that convention. It is important because the; # logic in llvm_map_components_to_libnames is order dependent on the target; # libraries being created.; set_property(GLOBAL PROPERTY LLVM_TARGETS_CONFIGURED On); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CMakeLists.txt:924,message,message,924,interpreter/llvm-project/llvm/lib/Target/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CMakeLists.txt,4,"['depend', 'message']","['dependent', 'message']"
Integrability,"list(LENGTH pytutorials nAfterVeto). message(STATUS ""${nAfterVeto}/${nTotal} python tutorials have been activated.""). #---Python tutorials dependencies--------------------------------------; set(pyroot-ntuple1-depends tutorial-pyroot-hsimple-py); set(pyroot-h1ReadAndDraw-depends tutorial-pyroot-hsimple-py); set(pyroot-benchmarks-depends tutorial-pyroot-hsimple-py; tutorial-pyroot-fit1-py; tutorial-pyroot-na49view-py; tutorial-pyroot-h1ReadAndDraw-py; tutorial-pyroot-ntuple1-py); set(pyroot-fit1-depends tutorial-hist-fillrandom-py); set(pyroot-na49view-depends tutorial-pyroot-geometry-py); set(roofit-rf503_wspaceread-depends tutorial-roofit-rf502_wspacewrite-py); set(roofit-rf618_mixture_models-depends tutorial-dataframe-df106_HiggsToFourLeptons-py). # Avoid a race condition: make sure Python tutorial is run after C++ tutorial; set(roofit-rf104_classfactory-depends tutorial-roofit-rf104_classfactory); set(roofit-rf512_wsfactory_oper-depends tutorial-roofit-rf512_wsfactory_oper); set (tmva-TMVA_Higgs_Classification-depends tutorial-tmva-TMVA_Higgs_Classification); set (tmva-TMVA_CNN_Classification-depends tutorial-tmva-TMVA_CNN_Classification); set (tmva-TMVA_RNN_Classification-depends tutorial-tmva-TMVA_RNN_Classification). #----------------------------------------------------------------------; # List requirements for python tutorials.; # To add a new requirement, add a glob expression that's named requires_<packageName>,; # and add it to the list ""fixtureLists"" below.; file(GLOB requires_numpy RELATIVE ${CMAKE_CURRENT_SOURCE_DIR}; dataframe/df026_AsNumpyArrays.py; dataframe/df032_RDFFromNumpy.py; fit/combinedFit.py; fit/multifit.py; roofit/rf409_NumPyPandasToRooFit.py); file(GLOB requires_numba RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} pyroot/pyroot004_NumbaDeclare.py); file(GLOB requires_pandas RELATIVE ${CMAKE_CURRENT_SOURCE_DIR}; dataframe/df026_AsNumpyArrays.py; roofit/rf409_NumPyPandasToRooFit.py); file(GLOB requires_keras RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} tmva/k",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt:31534,depend,depends,31534,tutorials/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt,5,['depend'],['depends']
Integrability,list; Clang 3.5. 578; CD6; Phase 1 replacement of characters with universal-character-names; Unknown. 579; open; What is a “nested” > or >>?; Not resolved. 580; C++11; Access in template-parameters of member and friend definitions; Partial. 581; CD5; Can a templated constructor be explicitly instantiated or specialized?; Unknown. 582; CD1; Template conversion functions; N/A. 583; CD3; Relational pointer comparisons against the null pointer constant; Clang 4. 584; NAD; Unions and aliasing; N/A. 585; NAD; Friend template template parameters; Clang 3.0. 586; NAD; Default template-arguments and template argument deduction; N/A. 587; CD2; Lvalue operands of a conditional expression differing only in cv-qualification; Clang 3.2. 588; CD2; Searching dependent bases of classes local to function templates; Yes. 589; CD2; Direct binding of class and array rvalues in reference initialization; Yes. 590; C++11; Nested classes and the “current instantiation”; Yes. 591; CD4; When a dependent base class is the current instantiation; No. 592; CD1; Exceptions during construction of local static objects; N/A. 593; NAD; Falling off the end of a destructor's function-try-block handler; Unknown. 594; CD1; Coordinating issues 119 and 404 with delegating constructors; N/A. 595; dup; Exception specifications in templates instantiated from class bodies; Duplicate of 1330. 596; NAD; Replacing an exception object; Unknown. 597; CD3; Conversions applied to out-of-lifetime non-POD lvalues; N/A. 598; CD2; Associated namespaces of overloaded functions and function templates; Yes. 599; CD2; Deleting a null function pointer; Partial. 600; CD6; Does access control apply to members or to names?; Clang 2.8. 601; CD2; Type of literals in preprocessing expressions; Yes. 602; C++11; When is the injected-class-name of a class template a template?; Yes. 603; CD1; Type equivalence and unsigned overflow; Yes. 604; CD2; Argument list for overload resolution in copy-initialization; N/A. 605; C++11; Linkage of e,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:40493,depend,dependent,40493,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['depend'],['dependent']
Integrability,"lit - LLVM Integrated Tester; ============================. .. program:: lit. SYNOPSIS; --------. :program:`lit` [*options*] [*tests*]. DESCRIPTION; -----------. :program:`lit` is a portable tool for executing LLVM and Clang style test; suites, summarizing their results, and providing indication of failures.; :program:`lit` is designed to be a lightweight testing tool with as simple a; user interface as possible. :program:`lit` should be run with one or more *tests* to run specified on the; command line. Tests can be either individual test files or directories to; search for tests (see :ref:`test-discovery`). Each specified test will be executed (potentially concurrently) and once all; tests have been run :program:`lit` will print summary information on the number; of tests which passed or failed (see :ref:`test-status-results`). The; :program:`lit` program will execute with a non-zero exit code if any tests; fail. By default :program:`lit` will use a succinct progress display and will only; print summary information for test failures. See :ref:`output-options` for; options controlling the :program:`lit` progress display and output. :program:`lit` also includes a number of options for controlling how tests are; executed (specific features may depend on the particular test format). See; :ref:`execution-options` for more information. Finally, :program:`lit` also supports additional options for only running a; subset of the options specified on the command line, see; :ref:`selection-options` for more information. :program:`lit` parses options from the environment variable ``LIT_OPTS`` after; parsing options from the command line. ``LIT_OPTS`` is primarily useful for; supplementing or overriding the command-line options supplied to :program:`lit`; by ``check`` targets defined by a project's build system. :program:`lit` can also read options from response files which are specified as; inputs using the ``@path/to/file.rsp`` syntax. Arguments read from a file must; be one p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:394,interface,interface,394,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['interface'],['interface']
Integrability,"lite); # RDF+SQlite tutorials; list(APPEND dataframe_veto dataframe/*SQlite*); endif(); if(NOT davix); list(APPEND dataframe_veto dataframe/df027_SQliteDependencyOverVersion.C); list(APPEND dataframe_veto dataframe/df028_SQliteIPLocation.C); list(APPEND dataframe_veto dataframe/df029_SQlitePlatformDistribution.C); list(APPEND dataframe_veto dataframe/df030_SQliteVersionsOfROOT.C); endif(). if(MACOSX_VERSION VERSION_EQUAL 10.13); list(APPEND dataframe_veto dataframe/df103_NanoAODHiggsAnalysis.*); endif(). if(NOT geom); set(geom_veto geom/*.C); endif(). if(NOT ROOT_proof_FOUND); set(proof_veto roostats/StandardFrequentistDiscovery.C); endif(). if(NOT ROOT_spectrum_FOUND); set(spectrum_veto spectrum/*.C); endif(). if(NOT ROOT_roofit_FOUND); set(roofit_veto roofit/*.C roofit/*.py; roostats/*.C roostats/*.py; histfactory/*.C histfactory/*.py); else(); if(MSVC AND CMAKE_SIZEOF_VOID_P EQUAL 4 AND NOT llvm13_broken_tests); # The following tutorials are failing with this error:; # IncrementalExecutor::executeFunction: symbol '__std_find_trivial_4@12' unresolved while linking [cling interface function]!; # on Windows 32 bit and Visual Studio v17.8; list(APPEND roofit_veto roofit/rf509_wsinteractive.C roofit/rf614_binned_fit_problems.C); # The following tutorial fails with a segfault (see #15364); list(APPEND roofit_veto roostats/rs101_limitexample.py); endif(); endif(). if(NOT ROOT_unuran_FOUND); set(unuran_veto math/testrandom.C unuran/unuranDemo.C unuran/unuranFoamTest.C; math/multidimSampling.C); endif(). if(NOT ROOT_xml_FOUND); set(xml_veto xml/*.C; histfactory/*.C # histfactory requires xml; histfactory/*.py; roostats/*.C # most roostats tutorials require xml too,; roostats/*.py) # because they create test data with histfactory; endif(). if(NOT ROOT_unfold_FOUND); list(APPEND xml_veto unfold/*.C); endif(). if(NOT ROOT_mpi_FOUND); set(mpi_veto io/testTMPIFile.C); endif(). if(NOT xrootd); set(xrootd_veto dataframe/df101_h1Analysis.C; dataframe/df102_NanoAODDimuonAnalysis.C",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt:6187,interface,interface,6187,tutorials/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt,1,['interface'],['interface']
Integrability,"lity R,; ThreadSafeModule TSM) {; assert(TSM.getModule() && ""Module must not be null"");. if (auto TransformedTSM = Transform(std::move(TSM), R)); BaseLayer.emit(std::move(R), std::move(*TransformedTSM));; else {; R.failMaterialization();; getExecutionSession().reportError(TransformedTSM.takeError());; }; }. This is the whole definition of IRTransformLayer, from; ``llvm/include/llvm/ExecutionEngine/Orc/IRTransformLayer.h`` and; ``llvm/lib/ExecutionEngine/Orc/IRTransformLayer.cpp``. This class is concerned; with two very simple jobs: (1) Running every IR Module that is emitted via this; layer through the transform function object, and (2) implementing the ORC; ``IRLayer`` interface (which itself conforms to the general ORC Layer concept,; more on that below). Most of the class is straightforward: a typedef for the; transform function, a constructor to initialize the members, a setter for the; transform function value, and a default no-op transform. The most important; method is ``emit`` as this is half of our IRLayer interface. The emit method; applies our transform to each module that it is called on and, if the transform; succeeds, passes the transformed module to the base layer. If the transform; fails, our emit function calls; ``MaterializationResponsibility::failMaterialization`` (this JIT clients who; may be waiting on other threads know that the code they were waiting for has; failed to compile) and logs the error with the execution session before bailing; out. The other half of the IRLayer interface we inherit unmodified from the IRLayer; class:. .. code-block:: c++. Error IRLayer::add(JITDylib &JD, ThreadSafeModule TSM, VModuleKey K) {; return JD.define(std::make_unique<BasicIRLayerMaterializationUnit>(; *this, std::move(K), std::move(TSM)));; }. This code, from ``llvm/lib/ExecutionEngine/Orc/Layer.cpp``, adds a; ThreadSafeModule to a given JITDylib by wrapping it up in a; ``MaterializationUnit`` (in this case a ``BasicIRLayerMaterializationUnit``).; Most laye",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst:8454,interface,interface,8454,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,1,['interface'],['interface']
Integrability,"ll call; ``abandon`` to indicate that some error occurred during linking. A call to the; ``InFlightAlloc::finalize`` method should cause content for the allocation to be; transferred from working to executor memory, and permissions to be run. A call; to ``abandon`` should result in both kinds of memory being deallocated. On successful finalization, the ``InFlightAlloc::finalize`` method should; construct a ``FinalizedAlloc`` object (an opaque uint64_t id that the; ``JITLinkMemoryManager`` can use to identify executor memory for deallocation); and pass it to the ``OnFinalized`` callback. Finalized allocations (represented by ``FinalizedAlloc`` objects) can be; deallocated by calling the ``JITLinkMemoryManager::dealloc`` method. This method; takes a vector of ``FinalizedAlloc`` objects, since it is common to deallocate; multiple objects at the same time and this allows us to batch these requests for; transmission to the executing process. JITLink provides a simple in-process implementation of this interface:; ``InProcessMemoryManager``. It allocates pages once and re-uses them as both; working and target memory. ORC provides a cross-process-capable ``MapperJITLinkMemoryManager`` that can use; shared memory or ORC-RPC-based communication to transfer content to the executing; process. JITLinkMemoryManager and Security; ---------------------------------. JITLink's ability to link JIT'd code for a separate executor process can be; used to improve the security of a JIT system: The executor process can be; sandboxed, run within a VM, or even run on a fully separate machine. JITLink's memory manager interface is flexible enough to allow for a range of; trade-offs between performance and security. For example, on a system where code; pages must be signed (preventing code from being updated), the memory manager; can deallocate working memory pages after linking to free memory in the process; running JITLink. Alternatively, on a system that allows RWX pages, the memory; manager",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:30371,interface,interface,30371,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['interface'],['interface']
Integrability,"ll deprecated and declaring the struct to the interpreter and passing the object directly to create the branch is much better).; * Provide an implicitly parallel implementation of `TTree::GetEntry`. The approach is based on creating a task per top-level branch in order to do the reading, unzipping and deserialisation in parallel. In addition, a getter and a setter methods are provided to check the status and enable/disable implicit multi-threading for that tree (see Parallelisation section for more information about implicit multi-threading).; * Properly support `std::cin` (and other stream that can not be rewound) in `TTree::ReadStream`. This fixes [ROOT-7588].; * Prevent `TTreeCloner::CopyStreamerInfos()` from causing an autoparse on an abstract base class. ## Histogram Libraries. * TH2Poly has a functional Merge method.; * Implemented the `TGraphAsymmErrors` constructor directly from an ASCII file. ## Math Libraries. * New template class `TRandomGen<Engine>` which derives from `TRandom` and integrate new random generator engines as TRandom classes.; * New TRandom specific types have been defined for these following generators:; * `TRandomMixMax` - recommended MIXMAX generator with N=240; * `TRandomMixMax17` - MIXMAX generator with smaller state (N=17) and faster seeding time; * `TRandomMixMax256` - old version of MIXMAX generator (N=256); * `TRandomMT64` - 64 bit Mersenenne Twister generator from the standard library (based on `std::mt19937_64`). This generates 64 bit random numbers, while `TRandom3` generates only 32 bit random numbers.; * `TRandomRanlux48` - 48 bit Ranlux generator. Note that `TRandom1` is a 24 bit generator. ; * Improve thread safety of `TMinuit` constructor [ROOT-8217]; * Vc has ben removed from the ROOT sources. If the option 'vc' is enabled, the package will be searched (by default),; alternatively the source tarfile can be downloded and build with the option 'builtin_vc'. ## TMVA Libraries. * New `DataLoader` class that allows flexibility ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:11579,integrat,integrate,11579,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,1,['integrat'],['integrate']
Integrability,"ll globals;. #pragma link off all typedef;; #pragma link C++ defined_in file1.h;; #endif; ```. The next pragma statements turn on or off the dictionary generation of; the object defined in a specific scope. The [`scope_name`] should be; `class` name, `struct` name or `namespace` name. When using these; pragmas, it is recommended to use also:. ``` {.cpp}; #pragma link C++ nestedclass; ```. Otherwise, definitions in enclosed scope do not appear in the; dictionary. ``` {.cpp}; #pragma link [C|C++|off] defined_in [scope_name];; #pragma link [C|C++|off] defined_in; [class|struct|namespace] [scope_name];; ```. Example:. ``` {.cpp}; namespace ns {; int a;; double b;; };; ```. The pragma statements are:. ``` {.cpp}; #ifdef __ROOTCLING__; #pragma link C++ defined_in ns;; #pragma link C++ nestedclass;; #endif; ```. This statements controls default link mode for `rootcling`. ``` {.cpp}; #pragma link default [on|off]; ```. By turning default 'on', all language constructs in given header files; will be included in generated Cling dictionary (interface method source; file). If default is set to 'off', nothing will be included in the; generated dictionary. The next statement explicitly set linkage to each; item:. ``` {.cpp}; #pragma link [C|C++|off] [class|function|global]; ```. This pragma statement must be given before `rootcling` reads any; C/C++ definitions from header files. Example:. ``` {.cpp}; #ifdef __ROOTCLING__; #pragma link default off;; #endif. class A {; int a;; double b;; };. class B {; int d;; double e;; };. #ifdef __ROOTCLING__; #pragma link C++ class A; // only class A is linked, not B; #endif; ```. ##### Compilation. **Step 4:** Compile the class using the `Makefile. `In the `Makefile`; call `rootcling` to make the dictionary for the class. Call it; `SClassDict.cxx`. The `rootcling` utility generates the methods; `Streamer`, **`TBuffer`** &operator\>\>() and `ShowMembers `for ROOT; classes. ``` {.cpp}; gmake -f Makefile; ```. Load the shared library:. ``` {.cpp}",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:32346,interface,interface,32346,documentation/users-guide/AddingaClass.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md,1,['interface'],['interface']
Integrability,"ll render an order of; magnitude faster with the COL2 option. The COL2 option will also scale its performance based on the size of the pixmap; the histogram image is being rendered into. It also is much better optimized for; sessions where the user is forwarding X11 windows through an `ssh` connection. For the most part, the COL2 and COLZ2 options are a drop in replacement to the COL; and COLZ options. There is one major difference and that concerns the treatment of; bins with zero content. The COL2 and COLZ2 options color these bins the color of zero. This has been implemented by Jeromy Tompkins <Tompkins@nscl.msu.edu>. ## Geometry Libraries; A new module geom/vecgeom was introduced to give transparent access to VecGeom ; solid primitives. VecGeom is a high performance geometry package (link) providing ; SIMD vectorization for the CPU-intensive geometry algorithms used for geometry; navigation. The module creates a new library libConverterVG.so depending on the; VecGeom main library and loaded using the ROOT plug-in mechanism. The main functionality provided by the new vecgeom module is to make a conversion ; in memory of all the shapes in a loaded TGeo geometry into a special adapter; shape TGeoVGShape, redirecting all navigation calls to the corresponding VecGeom ; solid. The library loading and geometry conversion can be done with a single call ; `TVirtualGeoConverter::Instance()->ConvertGeometry()`; . After the conversion is done, all existing TGeo functionality is available as for; a native geometry, only that most of the converted solids provide better navigation ; performance, despite the overhead introduced by the new adapter shape. Prerequisites: installation of VecGeom. ; The installation instructions are available at <http://geant.web.cern.ch/content/installation>; Due to the fact that VecGeom provides for the moment static libraries ; and depends on ROOT, is is advised to compile first ROOT without VecGeom support, ; then compile VecGeom against this RO",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:23355,depend,depending,23355,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,1,['depend'],['depending']
Integrability,"ll retrieve reviewers, the ``Differential Revision``, etc from the review; and place it in the commit message. You may also commit an accepted change; directly using ``git push``, per the section in the :ref:`getting started; guide <commit_from_git>`. Note that if you commit the change without using Arcanist and forget to add the; ``Differential Revision`` line to your commit message then it is recommended; that you close the review manually. In the web UI, under ""Leap Into Action"" put; the git revision number in the Comment, set the Action to ""Close Revision"" and; click Submit. Note the review must have been Accepted first. Committing someone's change from Phabricator; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. On a clean Git repository on an up to date ``main`` branch run the; following (where ``<Revision>`` is the Phabricator review number):. ::. arc patch D<Revision>. This will create a new branch called ``arcpatch-D<Revision>`` based on the; current ``main`` and will create a commit corresponding to ``D<Revision>`` with a; commit message derived from information in the Phabricator review. Check you are happy with the commit message and amend it if necessary.; For example, ensure the 'Author' property of the commit is set to the original author.; You can use a command to correct the author property if it is incorrect:. ::. git commit --amend --author=""John Doe <jdoe@llvm.org>"". Then, make sure the commit is up-to-date, and commit it. This can be done by running; the following:. ::. git pull --rebase https://github.com/llvm/llvm-project.git main; git show # Ensure the patch looks correct.; ninja check-$whatever # Rerun the appropriate tests if needed.; git push https://github.com/llvm/llvm-project.git HEAD:main. Abandoning a change; -------------------. If you decide you should not commit the patch, you should explicitly abandon; the review so that reviewers don't think it is still open. In the web UI,; scroll to the bottom of the page where normally you would",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:15374,message,message,15374,interpreter/llvm-project/llvm/docs/Phabricator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst,1,['message'],['message']
Integrability,"ll return the; dereferenced value same as plain C pointers, modulo the extra bounds checks; being performed before dereferencing the wide pointer. This means mapping the; wide pointers to struct types with equivalent layout won’t be sufficient. To; represent the wide pointers in Clang AST, we add an extra field in the; PointerType class to indicate the internal bounds of the pointer. This ensures; pointers of different representations are mapped to different canonical types; while they are still treated as pointers. In LLVM IR, wide pointers will be emitted as structs of equivalent; representations. Clang CodeGen will handle them as Aggregate in; ``TypeEvaluationKind (TEK)``. ``AggExprEmitter`` was extended to handle pointer; operations returning wide pointers. Alternatively, a new ``TEK`` and an; expression emitter dedicated to wide pointers could be introduced. Default bounds annotations; ==========================. The model may implicitly add ``__bidi_indexable`` or ``__single`` depending on; the context of the declaration that has the pointer type. ``__bidi_indexable``; implicitly adds to local variables, while ``__single`` implicitly adds to; pointer types specifying struct fields, function parameters, or global; variables. This means the parser may first create the pointer type without any; default pointer attribute and then recreate the type once the parser has the; declaration context and determined the default attribute accordingly. This also requires the parser to reset the type of the declaration with the; newly created type with the right default attribute. Promotion expression; ====================. A new expression will be introduced to represent the conversion from a pointer; with an external bounds annotation, such as ``__counted_by``, to; ``__bidi_indexable``. This type of conversion cannot be handled by normal; CastExprs because it requires an extra subexpression(s) to provide the bounds; information necessary to create a wide pointer. Bounds chec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:3562,depend,depending,3562,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,1,['depend'],['depending']
Integrability,"ll; ${CMAKE_CURRENT_BINARY_DIR}/libCustomStruct.dll); endif(). ROOT_ADD_GTEST(ntuple_basics ntuple_basics.cxx LIBRARIES ROOTNTuple CustomStruct); ROOT_ADD_GTEST(ntuple_bulk ntuple_bulk.cxx LIBRARIES ROOTNTuple CustomStruct); ROOT_ADD_GTEST(ntuple_cast ntuple_cast.cxx LIBRARIES ROOTNTuple); ROOT_ADD_GTEST(ntuple_checksum ntuple_checksum.cxx ntuple_test.cxx LIBRARIES ROOTNTuple); ROOT_ADD_GTEST(ntuple_cluster ntuple_cluster.cxx LIBRARIES ROOTNTuple); ROOT_ADD_GTEST(ntuple_compat ntuple_compat.cxx RXTuple.cxx LIBRARIES ROOTNTuple xxHash::xxHash); ROOT_GENERATE_DICTIONARY(RXTupleDict ${CMAKE_CURRENT_SOURCE_DIR}/RXTuple.hxx; MODULE ntuple_compat; LINKDEF RXTupleLinkDef.h; DEPENDENCIES RIO); ROOT_ADD_GTEST(ntuple_descriptor ntuple_descriptor.cxx LIBRARIES ROOTNTuple CustomStruct); ROOT_GENERATE_DICTIONARY(RNTupleDescriptorDict ${CMAKE_CURRENT_SOURCE_DIR}/RNTupleDescriptorDict.hxx; MODULE ntuple_descriptor; LINKDEF RNTupleDescriptorLinkDef.h; OPTIONS -inlineInputHeader; DEPENDENCIES RIO CustomStruct); ROOT_ADD_GTEST(ntuple_endian ntuple_endian.cxx LIBRARIES ROOTNTuple); if(NOT MSVC); # The unit test relies on fork(), which is not available on Windows.; ROOT_ADD_GTEST(ntuple_evolution ntuple_evolution.cxx LIBRARIES ROOTNTuple); endif(); ROOT_ADD_GTEST(ntuple_friends ntuple_friends.cxx LIBRARIES ROOTNTuple CustomStruct); ROOT_ADD_GTEST(ntuple_index ntuple_index.cxx LIBRARIES ROOTNTuple); ROOT_ADD_GTEST(ntuple_merger ntuple_merger.cxx LIBRARIES ROOTNTuple CustomStruct ZLIB::ZLIB); ROOT_ADD_GTEST(ntuple_metrics ntuple_metrics.cxx LIBRARIES ROOTNTuple CustomStruct); ROOT_ADD_GTEST(ntuple_model ntuple_model.cxx LIBRARIES ROOTNTuple CustomStruct); ROOT_ADD_GTEST(ntuple_multi_column ntuple_multi_column.cxx LIBRARIES ROOTNTuple); ROOT_ADD_GTEST(ntuple_packing ntuple_packing.cxx LIBRARIES ROOTNTuple CustomStruct); ROOT_ADD_GTEST(ntuple_pages ntuple_pages.cxx LIBRARIES ROOTNTuple CustomStruct); ROOT_ADD_GTEST(ntuple_print ntuple_print.cxx LIBRARIES ROOTNTuple CustomStruct); ROOT_ADD_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/CMakeLists.txt:1628,DEPEND,DEPENDENCIES,1628,tree/ntuple/v7/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/CMakeLists.txt,1,['DEPEND'],['DEPENDENCIES']
Integrability,"ll; be added with the option it had in `multigraph`.; - The option ""A"" in the `Draw()` was not cleaning properly the; current pad.; - Implement this option `pads`. This option is equivalent to the one in; `THStack`. It allows to draw all the `TGraphs` in separated pads. ### THStack. - By default the background of the histograms is erased before drawing the; histograms. The new option `noclear` avoid this behaviour. This is useful; when drawing a `THStack` on top of an other plot. If the patterns used to; draw the histograms in the stack are transparents, then the plot behind; will be visible. ### TH2Poly. - Implement a simple version of ""Scale"". ### TF1. - Change `TF1::Integral(double a, double b, double * params = 0, double eps = 1.E-12)` to; `TF1::Integral(doubnle a, double b, double epsrel=1.E-12)`. One should use `TF1::SetParameters` to; set the function parameters before computing the integral. - Add a new function `TF1::IntegralOneDim(Double_t a, Double_t b, Double_t epsrel, Double_t epsabs, Double_t &err)`; that returns as last argument the error in the integration. `TF1::Integral` is implemented using `Tf1::IntegralOneDim`. - The one-dim and multi-dim integral functions are now implemented using the `ROOT::Math::IntegratorOneDim` and `ROOT::Math::IntegratorMultiDim`; classes. This allows to change the integration algorithm used in `TF1` using the static methods of the classes; `ROOT::Math::IntegratorOneDimOptions` and `ROOT::Math::IntegratorMultiDimOptions`. The default algorithm used are; `ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorType()` and `ROOT::Math::IntegratorMultiDimOptions::DefaultIntegratorType()`.; For example, if ROOT has been built with mathmore the default one-dim integration type is the GSL AdaptiveSingular integration algorithm. - Implement the possibility to save a `TF1` as C code indenpant from; ROOT. It is enough to save the function as a "".cc"" file. \; Example:. ``` {.cpp}; root [0] TF1 *f1 = new TF1(""f1"",""x*x"",-10,10); root [1",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v600/index.md:12773,integrat,integration,12773,hist/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v600/index.md,1,['integrat'],['integration']
Integrability,"llAnalysesOn<Function>>()); return true;. // Check transitive dependencies.; return Inv.invalidate<BarAnalysis>(F, PA) ||; Inv.invalidate<BazAnalysis>(F, PA);; }. Combining invalidation and analysis manager proxies results in some; complexity. For example, when we invalidate all analyses in a module pass,; we have to make sure that we also invalidate function analyses accessible via; any existing inner proxies. The inner proxy's ``invalidate()`` first checks; if the proxy itself should be invalidated. If so, that means the proxy may; contain pointers to IR that is no longer valid, meaning that the inner proxy; needs to completely clear all relevant analysis results. Otherwise the proxy; simply forwards the invalidation to the inner analysis manager. Generally for outer proxies, analysis results from the outer analysis manager; should be immutable, so invalidation shouldn't be a concern. However, it is; possible for some inner analysis to depend on some outer analysis, and when; the outer analysis is invalidated, we need to make sure that dependent inner; analyses are also invalidated. This actually happens with alias analysis; results. Alias analysis is a function-level analysis, but there are; module-level implementations of specific types of alias analysis. Currently; ``GlobalsAA`` is the only module-level alias analysis and it generally is not; invalidated so this is not so much of a concern. See; ``OuterAnalysisManagerProxy::Result::registerOuterAnalysisInvalidation()``; for more details. Invoking ``opt``; ================. .. code-block:: shell. $ opt -passes='pass1,pass2' /tmp/a.ll -S; # -p is an alias for -passes; $ opt -p pass1,pass2 /tmp/a.ll -S. The new PM typically requires explicit pass nesting. For example, to run a; function pass, then a module pass, we need to wrap the function pass in a module; adaptor:. .. code-block:: shell. $ opt -passes='function(no-op-function),no-op-module' /tmp/a.ll -S. A more complete example, and ``-debug-pass-manager`` to s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:17751,depend,depend,17751,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,2,['depend'],"['depend', 'dependent']"
Integrability,"llaneous improvements other. The RooFit messagee service class RooMsgService has been augmented with a stack that; can store its configurate state information. A call to saveState() will save the; present configuration, which can be restored through a subsequent call to restoreState().; In addition to the method RooAbsArg::printCompactTree() which is mostly intende for; debugging, a new method RooAbsArg::printComponentTree() has been added that prints; the tree structure of a pdf in a more user-friendly content oriented way. The printing ; of the leaf nodes (the variables) is omitted in this method to keep the output compact. RooStats. This release contains significant bug fixes and it is strongly; recommended to update to this version if using older ones. . Major Changes in LimitCalculator and HypoTestCalculator classes: usage of ModelConfig class. The RooStats calculator interfaces have been changed to use the ModelConfig class.; All the setter methods with the parameter lists, pdf instances and name have been removed from the interfaces.; The SetWorkspace(RooWorkspace & ) has also been removed, while a SetModel(const ModelConfig &); function is introduced. Users are supposed to pass all the model information using the; ModelConfig class rather than via the; RooWorkspace or specifying directly the pdf and parameter; objects in the constructors. ; Setter methods using pdf instances and parameter lists are maintained in the derived classes, like the ProfileLikelihoodCalculator or the HybridCalculator, but those passing a string for the name of the pdf have been removed. ; All the calculator classes do not keep anymore a pointer to the workspace, but they contain pointers to the pdf, the data and the parameters required to run the calculator. These pointers are managed outside by the users or by the RooWorkspace. They can be passed either directly to the classes, for example via the constructor, or by using the ModelConfig class. The ModelConfig class acts as an inte",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html:11693,interface,interfaces,11693,roofit/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html,2,['interface'],['interfaces']
Integrability,"lled with; :ref:`undef <undefvalues>`.; If ``<pointer>`` is not a well-defined value, the behavior is undefined. Example:; """""""""""""""". .. code-block:: llvm. %ptr = alloca i32 ; yields ptr; store i32 3, ptr %ptr ; yields void; %val = load i32, ptr %ptr ; yields i32:val = i32 3. .. _i_fence:. '``fence``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. fence [syncscope(""<target-scope>"")] <ordering> ; yields void. Overview:; """""""""""""""""". The '``fence``' instruction is used to introduce happens-before edges; between operations. Arguments:; """""""""""""""""""". '``fence``' instructions take an :ref:`ordering <ordering>` argument which; defines what *synchronizes-with* edges they add. They can only be given; ``acquire``, ``release``, ``acq_rel``, and ``seq_cst`` orderings. Semantics:; """""""""""""""""""". A fence A which has (at least) ``release`` ordering semantics; *synchronizes with* a fence B with (at least) ``acquire`` ordering; semantics if and only if there exist atomic operations X and Y, both; operating on some atomic object M, such that A is sequenced before X, X; modifies M (either directly or through some side effect of a sequence; headed by X), Y is sequenced before B, and Y observes M. This provides a; *happens-before* dependency between A and B. Rather than an explicit; ``fence``, one (but not both) of the atomic operations X or Y might; provide a ``release`` or ``acquire`` (resp.) ordering constraint and; still *synchronize-with* the explicit ``fence`` and establish the; *happens-before* edge. A ``fence`` which has ``seq_cst`` ordering, in addition to having both; ``acquire`` and ``release`` semantics specified above, participates in; the global program order of other ``seq_cst`` operations and/or; fences. Furthermore, the global ordering created by a ``seq_cst``; fence must be compatible with the individual total orders of; ``monotonic`` (or stronger) memory accesses occurring before and after; such a fence. The exact semantics of this interaction are somewhat; comp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:424001,synchroniz,synchronizes,424001,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['synchroniz'],['synchronizes']
Integrability,"lled; if the loop count is not known at compile time. .. code-block:: c++. #pragma clang loop unroll(full); for(...) {; ...; }. The unroll count can be specified explicitly with ``unroll_count(_value_)`` where; _value_ is a positive integer. If this value is greater than the trip count the; loop will be fully unrolled. Otherwise the loop is partially unrolled subject; to the same code size limit as with ``unroll(enable)``. .. code-block:: c++. #pragma clang loop unroll_count(8); for(...) {; ...; }. Unrolling of a loop can be prevented by specifying ``unroll(disable)``. Loop unroll parameters can be controlled by options; `-mllvm -unroll-count=n` and `-mllvm -pragma-unroll-threshold=n`. Loop Distribution; -----------------. Loop Distribution allows splitting a loop into multiple loops. This is; beneficial for example when the entire loop cannot be vectorized but some of the; resulting loops can. If ``distribute(enable))`` is specified and the loop has memory dependencies; that inhibit vectorization, the compiler will attempt to isolate the offending; operations into a new loop. This optimization is not enabled by default, only; loops marked with the pragma are considered. .. code-block:: c++. #pragma clang loop distribute(enable); for (i = 0; i < N; ++i) {; S1: A[i + 1] = A[i] + B[i];; S2: C[i] = D[i] * E[i];; }. This loop will be split into two loops between statements S1 and S2. The; second loop containing S2 will be vectorized. Loop Distribution is currently not enabled by default in the optimizer because; it can hurt performance in some cases. For example, instruction-level; parallelism could be reduced by sequentializing the execution of the; statements S1 and S2 above. If Loop Distribution is turned on globally with; ``-mllvm -enable-loop-distribution``, specifying ``distribute(disable)`` can; be used the disable it on a per-loop basis. Additional Information; ----------------------. For convenience multiple loop hints can be specified on a single line. .. code",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:168089,depend,dependencies,168089,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['depend'],['dependencies']
Integrability,"llenot, CERN/SFT,\; Brian Bockelman, UNL,\; Rene Brun, CERN/SFT,\; Philippe Canal, FNAL,\; David Clark, ANL (SULI),\; Olivier Couet, CERN/SFT,\; Gerri Ganis, CERN/SFT,\; Andrei Gheata, CERN/SFT,\; Enrico Guiraud, CERN/SFT,\; Raphael Isemann, Chalmers Univ. of Tech.,\; Sergey Linev, GSI,\; Timur Pocheptsov, CERN/SFT,\; Pere Mato, CERN/SFT,\; Lorenzo Moneta, CERN/SFT,\; Axel Naumann, CERN/SFT,\; Simon Pfreundschuh,\; Danilo Piparo, CERN/SFT,\; Fons Rademakers, CERN/SFT,\; Enric Tejedor Saavedra, CERN/SFT,\; Oksana Shadura, UNL,\; Arthur Tsang, CERN/SFT, \; Peter van Gemmeren, ANL,\; Vassil Vassilev, Princeton Univ./CMS,\; Xavier Valls Pla, CERN/UJI, \; Wouter Verkerke, NIKHEF/Atlas, RooFit,\; Stefan Wunsch, KIT,\; Omar Zapata. ## General News. This release now supports building with C++17 enabled using either libstdc++ or; libc++. This requires Clang >= 5.0, or GCC >= 7.3.0. At the date of this; release, GCC 7.2.0 still does not provide full support to compile ROOT with C++17. ## Removed interfaces. The following interfaces have been removed, after deprecation in v6.10. - Remove the deprecated `TSelectorCint.h` and `TSelectorCint.cxx`.; - Remove the deprecated `Riosfwd.h` and `Rtypeinfo.h`.; - `TTreeReader::SetLastEntry()` was replaced by `TTreeReader::SetEntriesRange()`. ## Core Libraries. - Added support for XCode 9 and MacOS High Sierra.; - When invoking root with the ""-t"" argument, ROOT enables thread-safety and,; if configured, implicit multithreading within ROOT.; - `NULL` is not defined by `Rtypes.h` anymore. Instead, its definition is expected to be; provided by `Rtype.h`'s `#include` of `stddef.h`.; - ROOT now supports dictionaries, autoload and autoparse for classes with template parameter packs.; - std::make_unique has been backported; - If a class overloads TObject::Hash, this derived class should also add; ```; ROOT::CallRecursiveRemoveIfNeeded(*this); ```; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this; type of object, the tra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:1345,interface,interfaces,1345,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,1,['interface'],['interfaces']
Integrability,"lling for the; token includes a trigraph or escaped newline. Since this is uncommon,; many pieces of code can fast-path on tokens that did not need cleaning. One interesting (and somewhat unusual) aspect of normal tokens is that they; don't contain any semantic information about the lexed value. For example, if; the token was a pp-number token, we do not represent the value of the number; that was lexed (this is left for later pieces of code to decide).; Additionally, the lexer library has no notion of typedef names vs variable; names: both are returned as identifiers, and the parser is left to decide; whether a specific identifier is a typedef or a variable (tracking this; requires scope information among other things). The parser can do this; translation by replacing tokens returned by the preprocessor with ""Annotation; Tokens"". .. _AnnotationToken:. Annotation Tokens; -----------------. Annotation tokens are tokens that are synthesized by the parser and injected; into the preprocessor's token stream (replacing existing tokens) to record; semantic information found by the parser. For example, if ""``foo``"" is found; to be a typedef, the ""``foo``"" ``tok::identifier`` token is replaced with an; ``tok::annot_typename``. This is useful for a couple of reasons: 1) this makes; it easy to handle qualified type names (e.g., ""``foo::bar::baz<42>::t``"") in; C++ as a single ""token"" in the parser. 2) if the parser backtracks, the; reparse does not need to redo semantic analysis to determine whether a token; sequence is a variable, type, template, etc. Annotation tokens are created by the parser and reinjected into the parser's; token stream (when backtracking is enabled). Because they can only exist in; tokens that the preprocessor-proper is done with, it doesn't need to keep; around flags like ""start of line"" that the preprocessor uses to do its job.; Additionally, an annotation token may ""cover"" a sequence of preprocessor tokens; (e.g., ""``a::b::c``"" is five preprocessor tok",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:48887,inject,injected,48887,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['inject'],['injected']
Integrability,"lling with the ``gnu`` namespace. Attributes; should only specify this spelling for attributes; supported by GCC.; ``Clang`` Specifies two or three spellings: the first is a; GNU-style spelling, the second is a C++-style spelling; with the ``clang`` namespace, and the third is an; optional C-style spelling with the ``clang`` namespace.; By default, a C-style spelling is provided.; ``Pragma`` The attribute is spelled as a ``#pragma``, and requires; custom processing within the preprocessor. If the; attribute is meant to be used by Clang, it should; set the namespace to ``""clang""``. Note that this; spelling is not used for declaration attributes.; ================== =========================================================. The C++ standard specifies that “any [non-standard attribute] that is not; recognized by the implementation is ignored” (``[dcl.attr.grammar]``).; The rule for C is similar. This makes ``CXX11`` and ``C23`` spellings; unsuitable for attributes that affect the type system, that change the; binary interface of the code, or that have other similar semantic meaning. ``RegularKeyword`` provides an alternative way of spelling such attributes.; It reuses the production rules for standard attributes, but it applies them; to plain keywords rather than to ``[[…]]`` sequences. Compilers that don't; recognize the keyword are likely to report an error of some kind. For example, the ``ArmStreaming`` function type attribute affects; both the type system and the binary interface of the function.; It cannot therefore be spelled ``[[arm::streaming]]``, since compilers; that don't understand ``arm::streaming`` would ignore it and miscompile; the code. ``ArmStreaming`` is instead spelled ``__arm_streaming``, but it; can appear wherever a hypothetical ``[[arm::streaming]]`` could appear. Subjects; ~~~~~~~~; Attributes appertain to one or more subjects. If the attribute attempts to; attach to a subject that is not in the subject list, a diagnostic is issued; automaticall",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:131593,interface,interface,131593,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['interface'],['interface']
Integrability,"llvm-locstats - calculate statistics on DWARF debug location; ============================================================. .. program:: llvm-locstats. SYNOPSIS; --------. :program:`llvm-locstats` [*options*] [*filename*]. DESCRIPTION; -----------. :program:`llvm-locstats` works like a wrapper around :program:`llvm-dwarfdump`.; It parses :program:`llvm-dwarfdump` statistics regarding debug location by; pretty printing it in a more human readable way. The line 0% shows the number and the percentage of DIEs with no location; information, but the line 100% shows the information for DIEs where there is; location information in all code section bytes (where the variable or parameter; is in the scope). The line [50%,60%) shows the number and the percentage of DIEs; where the location information is between 50 and 60 percentage of its scope; covered. OPTIONS; -------. .. option:: --only-variables. calculate the location statistics only for local variables. .. option:: --only-formal-parameters. calculate the location statistics only for formal parameters. .. option:: --ignore-debug-entry-values. ignore the location statistics on locations containing the; debug entry values DWARF operation. .. option:: --draw-plot. make histogram of location buckets generated (requires; matplotlib). .. option:: --compare. compare the debug location coverage on two files provided, and draw; a plot showing the difference (requires matplotlib). EXIT STATUS; -----------. :program:`llvm-locstats` returns 0 if the input file were parsed; successfully. Otherwise, it returns 1. EXAMPLE 1; --------------. Pretty print the location coverage on the standard output. .. code-block:: none. llvm-locstats a.out. =================================================; Debug Location Statistics; =================================================; cov% samples percentage(~); -------------------------------------------------; 0% 1 16%; (0%,10%) 0 0%; [10%,20%) 0 0%; [20%,30%) 0 0%; [30%,40%) 0 0%; [40%,50%) 0 0%; [50%",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-locstats.rst:287,wrap,wrapper,287,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-locstats.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-locstats.rst,1,['wrap'],['wrapper']
Integrability,"llvm-readobj - LLVM Object Reader; =================================. .. program:: llvm-readobj. SYNOPSIS; --------. :program:`llvm-readobj` [*options*] [*input...*]. DESCRIPTION; -----------. The :program:`llvm-readobj` tool displays low-level format-specific information; about one or more object files. If ``input`` is ""``-``"", :program:`llvm-readobj` reads from standard; input. Otherwise, it will read from the specified ``filenames``. DIFFERENCES TO LLVM-READELF; ---------------------------. :program:`llvm-readelf` is an alias for the :manpage:`llvm-readobj` tool with a; slightly different command-line interface and output that is GNU compatible.; Following is a list of differences between :program:`llvm-readelf` and; :program:`llvm-readobj`:. - :program:`llvm-readelf` uses `GNU` for the :option:`--elf-output-style` option; by default. :program:`llvm-readobj` uses `LLVM`.; - :program:`llvm-readelf` allows single-letter grouped flags (e.g.; ``llvm-readelf -SW`` is the same as ``llvm-readelf -S -W``).; :program:`llvm-readobj` does not allow grouping.; - :program:`llvm-readelf` provides :option:`-s` as an alias for; :option:`--symbols`, for GNU :program:`readelf` compatibility, whereas it is; an alias for :option:`--section-headers` in :program:`llvm-readobj`.; - :program:`llvm-readobj` provides ``-t`` as an alias for :option:`--symbols`.; :program:`llvm-readelf` does not.; - :program:`llvm-readobj` provides ``--sr``, ``--sd``, ``--st`` and ``--dt`` as; aliases for :option:`--section-relocations`, :option:`--section-data`,; :option:`--section-symbols` and :option:`--dyn-symbols` respectively.; :program:`llvm-readelf` does not provide these aliases, to avoid conflicting; with grouped flags. GENERAL AND MULTI-FORMAT OPTIONS; --------------------------------. These options are applicable to more than one file format, or are unrelated to; file formats. .. option:: --all. Equivalent to specifying all the main display options relevant to the file; format. .. option:: --addr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-readobj.rst:612,interface,interface,612,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-readobj.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-readobj.rst,1,['interface'],['interface']
Integrability,"llvm.reset.fpmode``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.reset.fpmode(). Overview:; """""""""""""""""". The '``llvm.reset.fpmode``' intrinsic sets the default dynamic floating-point; control modes. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". The '``llvm.reset.fpmode``' intrinsic sets the current dynamic floating-point; environment to default state. It is similar to the C library function call; 'fesetmode(FE_DFL_MODE)', however this function does not return any value. Floating-Point Test Intrinsics; ------------------------------. These functions get properties of floating-point values. .. _llvm.is.fpclass:. '``llvm.is.fpclass``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i1 @llvm.is.fpclass(<fptype> <op>, i32 <test>); declare <N x i1> @llvm.is.fpclass(<vector-fptype> <op>, i32 <test>). Overview:; """""""""""""""""". The '``llvm.is.fpclass``' intrinsic returns a boolean value or vector of boolean; values depending on whether the first argument satisfies the test specified by; the second argument. If the first argument is a floating-point scalar, then the result type is a; boolean (:ref:`i1 <t_integer>`). If the first argument is a floating-point vector, then the result type is a; vector of boolean with the same number of elements as the first argument. Arguments:; """""""""""""""""""". The first argument to the '``llvm.is.fpclass``' intrinsic must be; :ref:`floating-point <t_floating>` or :ref:`vector <t_vector>`; of floating-point values. The second argument specifies, which tests to perform. It must be a compile-time; integer constant, each bit in which specifies floating-point class:. +-------+----------------------+; | Bit # | floating-point class |; +=======+======================+; | 0 | Signaling NaN |; +-------+----------------------+; | 1 | Quiet NaN |; +-------+----------------------+; | 2 | Negative infinity |; +-------+----------------------+; | 3 | Negative normal |; +-------+----------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:921626,depend,depending,921626,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['depending']
Integrability,llvm/llvm-project/pull/78311>`_). Before:. .. code-block:: c++. label:; #pragma omp barrier // ok. After:. .. code-block:: c++. label:; #pragma omp barrier // error: '#pragma omp barrier' cannot be an immediate substatement. - Fixed an issue that a benign assertion might hit when instantiating a pack expansion; inside a lambda. (`#61460 <https://github.com/llvm/llvm-project/issues/61460>`_); - Fix crash during instantiation of some class template specializations within class; templates. Fixes (`#70375 <https://github.com/llvm/llvm-project/issues/70375>`_); - Fix crash during code generation of C++ coroutine initial suspend when the return; type of await_resume is not trivially destructible.; Fixes (`#63803 <https://github.com/llvm/llvm-project/issues/63803>`_); - ``__is_trivially_relocatable`` no longer returns true for non-object types; such as references and functions.; Fixes (`#67498 <https://github.com/llvm/llvm-project/issues/67498>`_); - Fix crash when the object used as a ``static_assert`` message has ``size`` or ``data`` members; which are not member functions.; - Support UDLs in ``static_assert`` message.; - Fixed false positive error emitted by clang when performing qualified name; lookup and the current class instantiation has dependent bases.; Fixes (`#13826 <https://github.com/llvm/llvm-project/issues/13826>`_); - Fix a ``clang-17`` regression where a templated friend with constraints is not; properly applied when its parameters reference an enclosing non-template class.; Fixes (`#71595 <https://github.com/llvm/llvm-project/issues/71595>`_); - Fix the name of the ifunc symbol emitted for multiversion functions declared with the; ``target_clones`` attribute. This addresses a linker error that would otherwise occur; when these functions are referenced from other TUs.; - Fixes compile error that double colon operator cannot resolve macro with parentheses.; Fixes (`#64467 <https://github.com/llvm/llvm-project/issues/64467>`_); - Clang's ``-Wchar-subscripts``,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:41140,message,message,41140,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['message'],['message']
Integrability,"lly command line tools) this can be a reasonable approach. Calling; ``exit`` upon encountering an error dramatically simplifies control flow as the; error no longer needs to be propagated up the stack. This allows code to be; written in straight-line style, as long as each fallible call is wrapped in a; check and call to exit. The ``ExitOnError`` class supports this pattern by; providing call operators that inspect ``Error`` values, stripping the error away; in the success case and logging to ``stderr`` then exiting in the failure case. To use this class, declare a global ``ExitOnError`` variable in your program:. .. code-block:: c++. ExitOnError ExitOnErr;. Calls to fallible functions can then be wrapped with a call to ``ExitOnErr``,; turning them into non-failing calls:. .. code-block:: c++. Error mayFail();; Expected<int> mayFail2();. void foo() {; ExitOnErr(mayFail());; int X = ExitOnErr(mayFail2());; }. On failure, the error's log message will be written to ``stderr``, optionally; preceded by a string ""banner"" that can be set by calling the setBanner method. A; mapping can also be supplied from ``Error`` values to exit codes using the; ``setExitCodeMapper`` method:. .. code-block:: c++. int main(int argc, char *argv[]) {; ExitOnErr.setBanner(std::string(argv[0]) + "" error:"");; ExitOnErr.setExitCodeMapper(; [](const Error &Err) {; if (Err.isA<BadFileFormat>()); return 2;; return 1;; });. Use ``ExitOnError`` in your tool code where possible as it can greatly improve; readability. .. _err_cantfail:. Using cantFail to simplify safe callsites; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Some functions may only fail for a subset of their inputs, so calls using known; safe inputs can be assumed to succeed. The cantFail functions encapsulate this by wrapping an assertion that their; argument is a success value and, in the case of Expected<T>, unwrapping the; T value:. .. code-block:: c++. Error onlyFailsForSomeXValues(int X);; Expected<int> onlyFailsForSomeXValues2(int ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:31451,message,message,31451,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['message'],['message']
Integrability,"lly, we use ``cat`` to build a message that explains the change. Regarding the; name ``cat`` -- we'll discuss it in more detail below, but suffice it to say that; it can also take multiple arguments and concatenate their results. Note that the result of ``makeRule`` is a value of type; ``clang::transformer::RewriteRule``, but most users don't need to care about the; details of this type. Example: renaming a function; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Now, let's extend this example to a *transformation*; specifically, the second; example above:. .. code-block:: c++. makeRule(declRefExpr(to(functionDecl(hasName(""MkX"")))),; 	 changeTo(cat(""MakeX"")),; 	 cat(""MkX has been renamed MakeX""));. In this example, the pattern (``declRefExpr(...)``) identifies any *reference* to; the function ``MkX``, rather than the declaration itself, as in our previous; example. Our edit (``changeTo(...)``) says to *change* the code matched by the; pattern *to* the text ""MakeX"". Finally, we use ``cat`` again to build a message; that explains the change. Here are some example changes that this rule would make:. +--------------------------+----------------------------+; | Original | Result |; +==========================+============================+; | ``X x = MkX(3);`` | ``X x = MakeX(3);`` |; +--------------------------+----------------------------+; | ``CallFactory(MkX, 3);`` | ``CallFactory(MakeX, 3);`` |; +--------------------------+----------------------------+; | ``auto f = MkX;`` | ``auto f = MakeX;`` |; +--------------------------+----------------------------+. Example: method to function; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Next, let's write a rule to replace a method call with a (free) function call,; applied to the original method call's target object. Specifically, ""change; ``s.size()`` to ``Size(s)``, where ``s`` is a ``string``."" We start with a simpler; change that ignores the type of ``s``. That is, it will modify *any* method call; where the method is named ""size"":. .. code-block:: c++. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:4973,message,message,4973,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,1,['message'],['message']
Integrability,"load barrier is a bit of code executed immediately after the; machine load instruction, but before any use of the value loaded.; Depending on the collector, such a barrier may be needed for all; loads, merely loads of a particular type (in the original source; language), or none at all. #. Analogously, a store barrier is a code fragment that runs; immediately before the machine store instruction, but after the; computation of the value stored. The most common use of a store; barrier is to update a 'card table' in a generational garbage; collector. #. A safepoint is a location at which pointers visible to the compiled; code (i.e. currently in registers or on the stack) are allowed to; change. After the safepoint completes, the actual pointer value; may differ, but the 'object' (as seen by the source language); pointed to will not. Note that the term 'safepoint' is somewhat overloaded. It refers to; both the location at which the machine state is parsable and the; coordination protocol involved in bring application threads to a; point at which the collector can safely use that information. The; term ""statepoint"" as used in this document refers exclusively to the; former. This document focuses on the last item - compiler support for; safepoints in generated code. We will assume that an outside; mechanism has decided where to place safepoints. From our; perspective, all safepoints will be function calls. To support; relocation of objects directly reachable from values in compiled code,; the collector must be able to:. #. identify every copy of a pointer (including copies introduced by; the compiler itself) at the safepoint,; #. identify which object each pointer relates to, and; #. potentially update each of those copies. This document describes the mechanism by which an LLVM based compiler; can provide this information to a language runtime/collector, and; ensure that all pointers can be read and updated if desired. Abstract Machine Model; ^^^^^^^^^^^^^^^^^^^^^^^. At a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:3569,protocol,protocol,3569,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['protocol'],['protocol']
Integrability,"lobal ptr null; @glbi = global i32 0. define ptr @f(ptr %a, ptr %b, ptr %c, ptr %d, ptr %e) {; store ptr %a, ptr @glb ; %a is captured by this call. store ptr %b, ptr @glb2 ; %b isn't captured because the stored value is overwritten by the store below; store ptr null, ptr @glb2. store ptr %c, ptr @glb3; call void @g() ; If @g makes a copy of %c that outlives this call (@f), %c is captured; store ptr null, ptr @glb3. %i = ptrtoint ptr %d to i64; %j = trunc i64 %i to i32; store i32 %j, ptr @glbi ; %d is captured. ret ptr %e ; %e is captured; }. 2. The call stores any bit of the pointer carrying information into a place,; and the stored bits can be safely read from the place by another thread via; synchronization. .. code-block:: llvm. @lock = global i1 true. define void @f(ptr %a) {; store ptr %a, ptr* @glb; store atomic i1 false, ptr @lock release ; %a is captured because another thread can safely read @glb; store ptr null, ptr @glb; ret void; }. 3. The call's behavior depends on any bit of the pointer carrying information. .. code-block:: llvm. @glb = global i8 0. define void @f(ptr %a) {; %c = icmp eq ptr %a, @glb; br i1 %c, label %BB_EXIT, label %BB_CONTINUE ; escapes %a; BB_EXIT:; call void @exit(); unreachable; BB_CONTINUE:; ret void; }. 4. The pointer is used in a volatile access as its address. .. _volatile:. Volatile Memory Accesses; ------------------------. Certain memory accesses, such as :ref:`load <i_load>`'s,; :ref:`store <i_store>`'s, and :ref:`llvm.memcpy <int_memcpy>`'s may be; marked ``volatile``. The optimizers must not change the number of; volatile operations or change their order of execution relative to other; volatile operations. The optimizers *may* change the order of volatile; operations relative to non-volatile operations. This is not Java's; ""volatile"" and has no cross-thread synchronization behavior. A volatile load or store may have additional target-specific semantics.; Any volatile operation can have side effects, and any volatile ope",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:145424,depend,depends,145424,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['depends']
Integrability,"lock:: c++. true:; union foo; {; int x;; }. false:; union foo {; int x;; }. * ``bool AfterExternBlock`` Wrap extern blocks. .. code-block:: c++. true:; extern ""C""; {; int foo();; }. false:; extern ""C"" {; int foo();; }. * ``bool BeforeCatch`` Wrap before ``catch``. .. code-block:: c++. true:; try {; foo();; }; catch () {; }. false:; try {; foo();; } catch () {; }. * ``bool BeforeElse`` Wrap before ``else``. .. code-block:: c++. true:; if (foo()) {; }; else {; }. false:; if (foo()) {; } else {; }. * ``bool BeforeLambdaBody`` Wrap lambda block. .. code-block:: c++. true:; connect(; [](); {; foo();; bar();; });. false:; connect([]() {; foo();; bar();; });. * ``bool BeforeWhile`` Wrap before ``while``. .. code-block:: c++. true:; do {; foo();; }; while (1);. false:; do {; foo();; } while (1);. * ``bool IndentBraces`` Indent the wrapped braces themselves. * ``bool SplitEmptyFunction`` If ``false``, empty function body can be put on a single line.; This option is used only if the opening brace of the function has; already been wrapped, i.e. the ``AfterFunction`` brace wrapping mode is; set, and the function could/should not be put on a single line (as per; ``AllowShortFunctionsOnASingleLine`` and constructor formatting; options). .. code-block:: c++. false: true:; int f() vs. int f(); {} {; }. * ``bool SplitEmptyRecord`` If ``false``, empty record (e.g. class, struct or union) body; can be put on a single line. This option is used only if the opening; brace of the record has already been wrapped, i.e. the ``AfterClass``; (for classes) brace wrapping mode is set. .. code-block:: c++. false: true:; class Foo vs. class Foo; {} {; }. * ``bool SplitEmptyNamespace`` If ``false``, empty namespace body can be put on a single line.; This option is used only if the opening brace of the namespace has; already been wrapped, i.e. the ``AfterNamespace`` brace wrapping mode is; set. .. code-block:: c++. false: true:; namespace Foo vs. namespace Foo; {} {; }. .. _BracedInitializerIndentWid",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:41860,wrap,wrapped,41860,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['wrap'],['wrapped']
Integrability,"logic is; defined by *test suites*. TEST SUITES; ~~~~~~~~~~~. As described in :ref:`test-discovery`, tests are always located inside a *test; suite*. Test suites serve to define the format of the tests they contain, the; logic for finding those tests, and any additional information to run the tests. :program:`lit` identifies test suites as directories containing ``lit.cfg`` or; ``lit.site.cfg`` files (see also :option:`--config-prefix`). Test suites are; initially discovered by recursively searching up the directory hierarchy for; all the input files passed on the command line. You can use; :option:`--show-suites` to display the discovered test suites at startup. Once a test suite is discovered, its config file is loaded. Config files; themselves are Python modules which will be executed. When the config file is; executed, two important global variables are predefined:. **lit_config**. The global **lit** configuration object (a *LitConfig* instance), which defines; the builtin test formats, global configuration parameters, and other helper; routines for implementing test configurations. **config**. This is the config object (a *TestingConfig* instance) for the test suite,; which the config file is expected to populate. The following variables are also; available on the *config* object, some of which must be set by the config and; others are optional or predefined:. **name** *[required]* The name of the test suite, for use in reports and; diagnostics. **test_format** *[required]* The test format object which will be used to; discover and run tests in the test suite. Generally this will be a builtin test; format available from the *lit.formats* module. **test_source_root** The filesystem path to the test suite root. For out-of-dir; builds this is the directory that will be scanned for tests. **test_exec_root** For out-of-dir builds, the path to the test suite root inside; the object directory. This is where tests will be run and temporary output files; placed. **enviro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:15167,rout,routines,15167,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['rout'],['routines']
Integrability,"long side the core Clang libraries as; examples and test cases of fundamental functionality. However, most of; the tools are developed in a side repository to provide easy separation; from the core libraries. We intentionally do not support public; libraries in the side repository, as we want to carefully review and; find good APIs for libraries as they are lifted out of a few tools and; into the core Clang library set. Regardless of which repository Clang Tools' code resides in, the; development process and practices for all Clang Tools are exactly those; of Clang itself. They are entirely within the Clang *project*,; regardless of the version control scheme. Core Clang Tools; ================. The core set of Clang tools that are within the main repository are; tools that very specifically complement, and allow use and testing of; *Clang* specific functionality. ``clang-check``; ---------------. :doc:`ClangCheck` combines the LibTooling framework for running a; Clang tool with the basic Clang diagnostics by syntax checking specific files; in a fast, command line interface. It can also accept flags to re-display the; diagnostics in different formats with different flags, suitable for use driving; an IDE or editor. Furthermore, it can be used in fixit-mode to directly apply; fixit-hints offered by clang. See :doc:`HowToSetupToolingForLLVM` for; instructions on how to setup and used `clang-check`. ``clang-format``; ----------------. Clang-format is both a :doc:`library <LibFormat>` and a :doc:`stand-alone tool; <ClangFormat>` with the goal of automatically reformatting C++ sources files; according to configurable style guides. To do so, clang-format uses Clang's; ``Lexer`` to transform an input file into a token stream and then changes all; the whitespace around those tokens. The goal is for clang-format to serve both; as a user tool (ideally with powerful IDE integrations) and as part of other; refactoring tools, e.g. to do a reformatting of all the lines changed dur",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst:2875,interface,interface,2875,interpreter/llvm-project/clang/docs/ClangTools.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst,1,['interface'],['interface']
Integrability,"loop (15 mins) after client disconnectionsAvoid potential deadlocks when trying to remove a node from a clusterCorrect matching of incoming connection with previously dropped connectionCorrect export of cluster identificationCorrectly propagate information about files that could not be stagedPrevent endsess deadlock when parallel streams stall due to large WAN RTTFix infinite wait for primary login that will never; happen if you are a manager without a meta-managerPrevent annoying (but not deadly) infinite loop should a; server go offline that is subject to a locate request display.Client sideBetter handling of errno, especially for parallel streamsAllow the client to cycle through all the remaining valid security protocols in the list of protocols returned by the serverMake the readahead strategy more conservativeFix a rare race condition happening when destroying instances with outstanding open requestsEnforce cache coherency in the case of reads+writes in the same fileCorrectly guess the filesize of a file opened for writing in sync modeMake server host name check more flexible for GSI authenticationFix some relevant issues with cache handling on the client, including a rare but fatal bug in; determining the cache holes list and the end of a cache lookupMore complete detection of async read errorsGeneralFix problem in handling the return code; of X509_REQ_verify; in XrdCryptosslX509Req.ccAvoid SEGV when doing an lsd admin command with; authenticated xrootd clientsClose race conditions that allowed a supervisor/manager; to subscribe without declaring a data port. Initialize nostage state in; XrdCmsState to prevent erroneous state declaration during; initialization.Fix a problem with the subject name of proxies of level; > 1; this was creating a failure when a Globus application was; trying to use the proxy certificateFix a problem with cache refreshing in XrdSutCache; affecting automatic reloading of password filesFor now, turn off IPV6 processing as it seems to cr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/doc/v524/index.html:2051,protocol,protocols,2051,net/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/doc/v524/index.html,4,['protocol'],['protocols']
Integrability,"low exception propagation; through multiple levels of callbacks, while retaining the option to handle; the outstanding exception as needed in either language.; To preserve an exception across the language boundaries, it must derive from; ``std::exception``.; If preserving the exception (or its type) is not possible, generic exceptions; are used to propagate the exception: ``Exception`` in Python or; ``CPyCppyy::PyException`` in C++. In the most common case of an instance of a C++ exception class derived from; ``std::exception`` that is thrown from a compiled library and which is; copyable, the exception can be caught and handled like any other bound C++; object (or with ``Exception`` on the Python and ``std::exception`` on the; C++ side).; If the exception is not copyable, but derived from ``std::exception``, the; result of its ``what()`` reported with an instance of Python's ``Exception``.; In all other cases, including exceptions thrown from interpreted code (due to; limitations of the Clang JIT), the exception will turn into an instance of; ``Exception`` with a generic message. The standard C++ exceptions are explicitly not mapped onto standard Python; exceptions, since other than a few simple cases, the mapping is too crude to; be useful as the typical usage in each standard library is too different.; Thus, for example, a thrown ``std::runtime_error`` instance will become a; ``cppyy.gbl.std.runtime_error`` instance on the Python side (with Python's; ``Exception`` as its base class), not a ``RuntimeError`` instance. The C++ code used for the examples below can be found; :doc:`here <cppyy_features_header>`, and it is assumed that that code is; loaded at the start of any session.; Download it, save it under the name ``features.h``, and load it:. .. code-block:: python. >>> import cppyy; >>> cppyy.include('features.h'); >>>. In addition, the examples require the ``throw`` to be in compiled code.; Save the following and build it into a shared library ``libfeatures.so",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/exceptions.rst:1249,message,message,1249,bindings/pyroot/cppyy/cppyy/doc/source/exceptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/exceptions.rst,1,['message'],['message']
Integrability,"low-mono-bisecting>`. Workflow Before/After; =====================. This section goes through a few examples of workflows, intended to illustrate; how end-users or developers would interact with the repository for; various use-cases. .. _workflow-checkout-commit:. Checkout/Clone a Single Project, with Commit Access; ---------------------------------------------------. Currently; ^^^^^^^^^. ::. # direct SVN checkout; svn co https://user@llvm.org/svn/llvm-project/llvm/trunk llvm; # or using the read-only Git view, with git-svn; git clone https://llvm.org/git/llvm.git; cd llvm; git svn init https://llvm.org/svn/llvm-project/llvm/trunk --username=<username>; git config svn-remote.svn.fetch :refs/remotes/origin/main; git svn rebase -l # -l avoids fetching ahead of the git mirror. Commits are performed using `svn commit` or with the sequence `git commit` and; `git svn dcommit`. .. _workflow-multicheckout-nocommit:. Monorepo Variant; ^^^^^^^^^^^^^^^^. With the monorepo variant, there are a few options, depending on your; constraints. First, you could just clone the full repository:. git clone https://github.com/llvm/llvm-project.git. At this point you have every sub-project (llvm, clang, lld, lldb, ...), which; :ref:`doesn't imply you have to build all of them <build_single_project>`. You; can still build only compiler-rt for instance. In this way it's not different; from someone who would check out all the projects with SVN today. If you want to avoid checking out all the sources, you can hide the other; directories using a Git sparse checkout::. git config core.sparseCheckout true; echo /compiler-rt > .git/info/sparse-checkout; git read-tree -mu HEAD. The data for all sub-projects is still in your `.git` directory, but in your; checkout, you only see `compiler-rt`.; Before you push, you'll need to fetch and rebase (`git pull --rebase`) as; usual. Note that when you fetch you'll likely pull in changes to sub-projects you don't; care about. If you are using sparse checkout",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:13517,depend,depending,13517,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['depend'],['depending']
Integrability,ls/multiplex; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex/tests; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex/tests/custom_data_storage; - `2`; - `1`; - `1`; - :part:`50%`; * - openmp/tools/multiplex/tests/print; - `2`; - `2`; - `0`; - :good:`100%`; * - polly/include/polly; - `25`; - `25`; - `0`; - :good:`100%`; * - polly/include/polly/CodeGen; - `14`; - `14`; - `0`; - :good:`100%`; * - polly/include/polly/Support; - `12`; - `12`; - `0`; - :good:`100%`; * - polly/lib/Analysis; - `9`; - `9`; - `0`; - :good:`100%`; * - polly/lib/CodeGen; - `15`; - `15`; - `0`; - :good:`100%`; * - polly/lib/Exchange; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/lib/External/isl; - `68`; - `1`; - `67`; - :part:`1%`; * - polly/lib/External/isl/imath; - `6`; - `1`; - `5`; - :part:`16%`; * - polly/lib/External/isl/imath_wrap; - `4`; - `0`; - `4`; - :none:`0%`; * - polly/lib/External/isl/include/isl; - `59`; - `9`; - `50`; - :part:`15%`; * - polly/lib/External/isl/interface; - `8`; - `1`; - `7`; - :part:`12%`; * - polly/lib/External/pet/include; - `1`; - `0`; - `1`; - :none:`0%`; * - polly/lib/External/ppcg; - `17`; - `0`; - `17`; - :none:`0%`; * - polly/lib/Plugin; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/lib/Support; - `11`; - `11`; - `0`; - :good:`100%`; * - polly/lib/Transform; - `15`; - `15`; - `0`; - :good:`100%`; * - polly/tools/GPURuntime; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/DeLICM; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/Flatten; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/Isl; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/ScheduleOptimizer; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/ScopPassManager; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/Support; - `1`; - `1`; - `0`; - :good:`100%`; * - pstl/include/pstl/internal; - `23`; - `16`; - `7`; - :part:`69%`; * - pstl/include/pstl/internal/omp; - `11`; - `8`; - `3`; - :part:`72%`; * - third-party/ben,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:124487,interface,interface,124487,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,1,['interface'],['interface']
Integrability,"ls; set(LIB_NAMES -Wl,--version-script,${LLVM_LIBRARY_DIR}/tools/llvm-shlib/simple_version_script.map ${LIB_NAMES}); endif(); if (NOT MINGW AND NOT LLVM_LINKER_IS_SOLARISLD_ILLUMOS); # Optimize function calls for default visibility definitions to avoid PLT and; # reduce dynamic relocations.; # Note: for -fno-pic default, the address of a function may be different from; # inside and outside libLLVM.so.; target_link_options(LLVM PRIVATE LINKER:-Bsymbolic-functions); endif(); endif(). target_link_libraries(LLVM PRIVATE ${LIB_NAMES}). if(LLVM_ENABLE_THREADS AND NOT HAVE_CXX_ATOMICS64_WITHOUT_LIB); target_link_libraries(LLVM PUBLIC atomic); endif(). if (APPLE); set_property(TARGET LLVM APPEND_STRING PROPERTY; LINK_FLAGS; "" -compatibility_version 1 -current_version ${LLVM_VERSION_MAJOR}.${LLVM_VERSION_MINOR}.${LLVM_VERSION_PATCH}""); endif(). if(TARGET libLLVMExports); add_dependencies(LLVM libLLVMExports); endif(); endif(). if(LLVM_BUILD_LLVM_C_DYLIB AND NOT MSVC); if(NOT APPLE); message(FATAL_ERROR ""Generating libLLVM-c is only supported on Darwin""); endif(). if(NOT LLVM_BUILD_LLVM_DYLIB); message(FATAL_ERROR ""Generating libLLVM-c requires LLVM_BUILD_LLVM_C_DYLIB on Darwin""); endif(). # To get the export list for a single llvm library:; # nm ${LIB_PATH} | awk ""/T _LLVM/ { print $3 }"" | sort -u | sed -e ""s/^_//g"" > ${LIB_PATH}.exports. set(LLVM_EXPORTED_SYMBOL_FILE ${LLVM_BINARY_DIR}/libllvm-c.exports). set(LIB_DIR ${LLVM_LIBRARY_DIR}); set(LIB_NAME ${LIB_DIR}/${CMAKE_SHARED_LIBRARY_PREFIX}LLVM); set(LIB_PATH ${LIB_NAME}${CMAKE_SHARED_LIBRARY_SUFFIX}); set(LIB_EXPORTS_PATH ${LIB_NAME}.exports); list(APPEND LLVM_DYLIB_REQUIRED_EXPORTS ${LIB_EXPORTS_PATH}). add_custom_command(OUTPUT ${LLVM_EXPORTED_SYMBOL_FILE}; COMMAND nm ${LIB_PATH} | awk ""/T _LLVM/ || /T LLVM/ { print $3 }"" | sort -u | sed -e ""s/^_//g"" > ${LLVM_EXPORTED_SYMBOL_FILE}; WORKING_DIRECTORY ${LIB_DIR}; DEPENDS LLVM; COMMENT ""Generating Export list for LLVM...""; VERBATIM ). add_custom_target(libLLVMCExports DEPE",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-shlib/CMakeLists.txt:3157,message,message,3157,interpreter/llvm-project/llvm/tools/llvm-shlib/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-shlib/CMakeLists.txt,2,['message'],['message']
Integrability,"ltin_vc'. ## TMVA Libraries. * New `DataLoader` class that allows flexibility in variable and dataset selection. ; * New Deep Neural Network. Three different versions are available, which can be selected with the 'Architecture' option. See also the tutorial`tmva/TMVAClassification.C` for using the new DNN.; * `Architecture=STANDARD` to select the earlier version.; * `Architecture=CPU` to select the newer version for CPU, but designed also for GPU and optimized for speed and with multi-class support. ; * `Architecture=GPU` to select the newer GPU version. Requires configuration of ROOT with CUDA or OpenCL enabled. ; * Support for Cross Validation (see tutorial `tmva/TMVACrossValidation` as an example).; * Support for Hyper-Parameter tuning for BDT and SVM methods.; * New Variable Importance algorithm independent of the MVA method.; * New Loss Function class for regression.; * Improvements in the SVM method: new kernel functions.; * New `ROCCurve` class. ; * New interface to Keras (PyKeras) available in the PyMVA library.; * Support for Jupyter notebooks; * Support for all the functionality available in GUI: preprocessing, variable correlations, classifier output.; * New classifier visualization for BDT, ANN and DNN.; * Interactive training for all methods. ## 2D Graphics Libraries. * In `TColor::SetPalette`, make sure the high quality palettes are defined; only once taking care of transparency. Also `CreateGradientColorTable` has been; simplified.; * New fast constructor for `TColor` avoiding to call `gROOT->GetColor()`. The; normal constructor generated a big slow down when creating a Palette with; `CreateGradientColorTable`.; * In `CreateGradientColorTable` we do not need anymore to compute the highest; color index.; * In `TGraphPainter`, when graphs are painted with lines, they are split into; chunks of length `fgMaxPointsPerLine`. This allows to paint line with an ""infinite""; number of points. In some case this ""chunks painting"" technic may create artefacts; at th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:13467,interface,interface,13467,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,1,['interface'],['interface']
Integrability,"ltiple primitive data are; operated in parallel using a single instruction (SIMD). A vector type; requires a size (number of elements), an underlying primitive data type,; and a scalable property to represent vectors where the exact hardware; vector length is unknown at compile time. Vector types are considered; :ref:`first class <t_firstclass>`. :Memory Layout:. In general vector elements are laid out in memory in the same way as; :ref:`array types <t_array>`. Such an analogy works fine as long as the vector; elements are byte sized. However, when the elements of the vector aren't byte; sized it gets a bit more complicated. One way to describe the layout is by; describing what happens when a vector such as <N x iM> is bitcasted to an; integer type with N*M bits, and then following the rules for storing such an; integer to memory. A bitcast from a vector type to a scalar integer type will see the elements; being packed together (without padding). The order in which elements are; inserted in the integer depends on endianness. For little endian element zero; is put in the least significant bits of the integer, and for big endian; element zero is put in the most significant bits. Using a vector such as ``<i4 1, i4 2, i4 3, i4 5>`` as an example, together; with the analogy that we can replace a vector store by a bitcast followed by; an integer store, we get this for big endian:. .. code-block:: llvm. %val = bitcast <4 x i4> <i4 1, i4 2, i4 3, i4 5> to i16. ; Bitcasting from a vector to an integral type can be seen as; ; concatenating the values:; ; %val now has the hexadecimal value 0x1235. store i16 %val, ptr %ptr. ; In memory the content will be (8-bit addressing):; ;; ; [%ptr + 0]: 00010010 (0x12); ; [%ptr + 1]: 00110101 (0x35). The same example for little endian:. .. code-block:: llvm. %val = bitcast <4 x i4> <i4 1, i4 2, i4 3, i4 5> to i16. ; Bitcasting from a vector to an integral type can be seen as; ; concatenating the values:; ; %val now has the hexadecimal val",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:175438,depend,depends,175438,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['depends']
Integrability,"luation and another function object implementing `double operator() (const double *, int icoord)`; for the partial derivatives. The function dimension is required when constructing the functor. #### Special case: Wrapping TF1 objects in Parametric Function interfaces. In many cases, the user works with the `TF1` class. The mathematical library in ROOT provides some solutions to wrap these into the interfaces needed by other methods.; If the desired interface to wrap is one-dimensional, the class to use is `ROOT::Math::WrappedTF1`.; The default constructor takes a `TF1` reference as an argument, that will be wrapped with the interfaces of a `ROOT::Math::IParametricGradFunctionOneDim`.; Example:; ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedTF1.h"". int main(); {. TF1 f(""Sin Function"", ""sin(x)+y"",0,3);. ROOT::Math::WrappedTF1 wf1(f);. cout << f(1) << endl;; cout << wf1(1) << endl;. return 0;; }; ```. For a TF1 defining a multidimensional function or in case we need to wrap in a multi-dimensional function interface, the class to use is `ROOT::Math::WrappedMultiTF1`.; Following the usual procedure, setting the `TF1` though the constructor, will wrap it into a `ROOT::Math::IParametricGradFunctionMultiDim`.; Example:. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedMultiTF1.h"". int main(); {. TF2 f(""Sin Function"", ""sin(x) + y"",0,3,0,2);. ROOT::Math::WrappedMultiTF1 wf1(f);. double x[] = {1,2};. cout << f(x) << endl;; cout << wf1(x) << endl;. return 0;; }; ```. ## Numerical Integration. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image.; `ROOT::Math::VirtualIntegrator` defines the most basic functionality while the specific behaviours for one or multiple dimensions are implemented in; `ROOT::Math::VirtualIntegratorOneDim` and `ROOT::Math::VirtualIntegratorMultiDim`.; These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:47741,wrap,wrap,47741,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,2,"['interface', 'wrap']","['interface', 'wrap']"
Integrability,"lue simply indicates that an operation; **is** natively supported. ``Legal`` represents the default condition, so it; is rarely used. In ``SparcISelLowering.cpp``, the action for ``CTPOP`` (an; operation to count the bits set in an integer) is natively supported only for; SPARC v9. The following code enables the ``Expand`` conversion technique for; non-v9 SPARC implementations. .. code-block:: c++. setOperationAction(ISD::CTPOP, MVT::i32, Expand);; ...; if (TM.getSubtarget<SparcSubtarget>().isV9()); setOperationAction(ISD::CTPOP, MVT::i32, Legal);. Calling Conventions; -------------------. To support target-specific calling conventions, ``XXXGenCallingConv.td`` uses; interfaces (such as ``CCIfType`` and ``CCAssignToReg``) that are defined in; ``lib/Target/TargetCallingConv.td``. TableGen can take the target descriptor; file ``XXXGenCallingConv.td`` and generate the header file; ``XXXGenCallingConv.inc``, which is typically included in; ``XXXISelLowering.cpp``. You can use the interfaces in; ``TargetCallingConv.td`` to specify:. * The order of parameter allocation. * Where parameters and return values are placed (that is, on the stack or in; registers). * Which registers may be used. * Whether the caller or callee unwinds the stack. The following example demonstrates the use of the ``CCIfType`` and; ``CCAssignToReg`` interfaces. If the ``CCIfType`` predicate is true (that is,; if the current argument is of type ``f32`` or ``f64``), then the action is; performed. In this case, the ``CCAssignToReg`` action assigns the argument; value to the first available register: either ``R0`` or ``R1``. .. code-block:: text. CCIfType<[f32,f64], CCAssignToReg<[R0, R1]>>. ``SparcCallingConv.td`` contains definitions for a target-specific return-value; calling convention (``RetCC_Sparc32``) and a basic 32-bit C calling convention; (``CC_Sparc32``). The definition of ``RetCC_Sparc32`` (shown below) indicates; which registers are used for specified scalar return types. A single-precisio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:62038,interface,interfaces,62038,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['interface'],['interfaces']
Integrability,"lues; except as guaranteed by ``__strong`` object invariants or +1 transfer; conventions. For example, if an object is provably double-retained; and double-released, ARC may eliminate the inner retain and release;; it does not need to guard against code which performs an unbalanced; release followed by a ""balancing"" retain. .. _arc.optimization.liveness:. Object liveness; ---------------. ARC may not allow a retainable object ``X`` to be deallocated at a; time ``T`` in a computation history if:. * ``X`` is the value stored in a ``__strong`` object ``S`` with; :ref:`precise lifetime semantics <arc.optimization.precise>`, or. * ``X`` is the value stored in a ``__strong`` object ``S`` with; imprecise lifetime semantics and, at some point after ``T`` but; before the next store to ``S``, the computation history features a; load from ``S`` and in some way depends on the value loaded, or. * ``X`` is a value described as being released at the end of the; current full-expression and, at some point after ``T`` but before; the end of the full-expression, the computation history depends; on that value. .. admonition:: Rationale. The intent of the second rule is to say that objects held in normal; ``__strong`` local variables may be released as soon as the value in; the variable is no longer being used: either the variable stops; being used completely or a new value is stored in the variable. The intent of the third rule is to say that return values may be; released after they've been used. A computation history depends on a pointer value ``P`` if it:. * performs a pointer comparison with ``P``,; * loads from ``P``,; * stores to ``P``,; * depends on a pointer value ``Q`` derived via pointer arithmetic; from ``P`` (including an instance-variable or field access), or; * depends on a pointer value ``Q`` loaded from ``P``. Dependency applies only to values derived directly or indirectly from; a particular expression result and does not occur merely because a; separate pointer value d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:79391,depend,depends,79391,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['depend'],['depends']
Integrability,"lustrates the type introspection mechanism provided by the interpreter.; * - `Introducing Cling, a C++ Interpreter Based on Clang/LLVM <https://www.youtube.com/watch?v=f9Xfh8pv3Fs>`_; - *Axel Naumann* 2012 Googletechtalks; - Axel Naumann (CERN) discusses Cling’s most relevant features: abstract syntax tree (AST) production, wrapped functions, global initialization of a function, delay expression evaluation at runtime, and dynamic scopes.; * - `Creating Cling, an interactive interpreter interface <https://www.youtube.com/watch?v=BjmGOMJWeAo>`_; - *Axel Naumann* 2010 LLVM Developers’ meeting; - This presentation introduces Cling, an ahead-of-time compiler that extends C++ for ease of use as an interpreter.; . ; .. list-table:: Demos, tutorials, Cling’s ecosystem:; :widths: 25 25 50; :header-rows: 1. * - Link; - Info ; - Description; * - `Cling integration | CLion <https://www.jetbrains.com/help/clion/cling-integration.html#install-cling>`_; - 2022.2 Version; - CLion uses Cling to integrate the `Quick Documentation <https://www.jetbrains.com/help/clion/2022.2/viewing-inline-documentation.html>`_ popup by allowing you to view the value of the expressions evaluated at compile time.; * - `Interactive C++ for Data Science <https://www.youtube.com/watch?v=23E0S3miWB0&t=2716s>`_; - *Vassil Vassilev* 2021 CppCon (The C++ Conference); - In this video, the author discusses how Cling enables interactive C++ for Data Science projects. ; * - `Cling -- Beyond Just Interpreting C++ <https://blog.llvm.org/posts/2021-03-25-cling-beyond-just-interpreting-cpp/>`_; - *Vassil Vassilev* 2021 The LLVM Project Blog; - This blog page discusses how Cling enables template Instantiation on demand, language interoperability on demand, interpreter/compiler as a service, plugins extension.; * - `TinySpec-Cling <https://github.com/nwoeanhinnogaehr/tinyspec-cling>`_; - Noah Weninger 2020; - A tiny C++ live-coded overlap-add (re)synthesizer for Linux, which uses Cling to add REPL-like functionality for",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/references.rst:2105,integrat,integrate,2105,interpreter/cling/docs/chapters/references.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/references.rst,1,['integrat'],['integrate']
Integrability,"lving the data; analysis challenges of high-energy physics. There are two key words in; this definition, object oriented and framework. First, we explain what; we mean by a framework and then why it is an object-oriented; framework. ### What Is a Framework?. Programming inside a framework is a little like living in a city.; Plumbing, electricity, telephone, and transportation are services; provided by the city. In your house, you have interfaces to the; services such as light switches, electrical outlets, and telephones.; The details, for example, the routing algorithm of the phone switching; system, are transparent to you as the user. You do not care; you are; only interested in using the phone to communicate with your; collaborators to solve your domain specific problems. Programming outside of a framework may be compared to living in the; country. In order to have transportation and water, you will have to; build a road and dig a well. To have services like telephone and; electricity you will need to route the wires to your home. In; addition, you cannot build some things yourself. For example, you; cannot build a commercial airport on your patch of land. From a global; perspective, it would make no sense for everyone to build their; own airport. You see you will be very busy building the infrastructure; (or framework) before you can use the phone to communicate with your; collaborators and have a drink of water at the same time. In software; engineering, it is much the same way. In a framework, the basic; utilities and services, such as I/O and graphics, are provided. In; addition, ROOT being a HEP analysis framework, it provides a large; selection of HEP specific utilities such as histograms and fitting.; The drawback of a framework is that you are constrained to it, as you; are constraint to use the routing algorithm provided by your telephone; service. You also have to learn the framework interfaces, which in; this analogy is the same as learning how to use a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:5618,rout,route,5618,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['rout'],['route']
Integrability,"lvm::ConstantInt::get(llvm::Type::getInt32Ty(getLLVMContext()), 2)};. This formatting scheme also makes it particularly easy to get predictable,; consistent, and automatic formatting with tools like `Clang Format`_. .. _Clang Format: https://clang.llvm.org/docs/ClangFormat.html. Language and Compiler Issues; ----------------------------. Treat Compiler Warnings Like Errors; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Compiler warnings are often useful and help improve the code. Those that are; not useful, can be often suppressed with a small code change. For example, an; assignment in the ``if`` condition is often a typo:. .. code-block:: c++. if (V = getValue()) {; ...; }. Several compilers will print a warning for the code above. It can be suppressed; by adding parentheses:. .. code-block:: c++. if ((V = getValue())) {; ...; }. Write Portable Code; ^^^^^^^^^^^^^^^^^^^. In almost all cases, it is possible to write completely portable code. When; you need to rely on non-portable code, put it behind a well-defined and; well-documented interface. Do not use RTTI or Exceptions; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In an effort to reduce code and executable size, LLVM does not use exceptions; or RTTI (`runtime type information; <https://en.wikipedia.org/wiki/Run-time_type_information>`_, for example,; ``dynamic_cast<>``). That said, LLVM does make extensive use of a hand-rolled form of RTTI that use; templates like :ref:`isa\<>, cast\<>, and dyn_cast\<> <isa>`.; This form of RTTI is opt-in and can be; :doc:`added to any class <HowToSetUpLLVMStyleRTTI>`. Prefer C++-style casts; ^^^^^^^^^^^^^^^^^^^^^^. When casting, use ``static_cast``, ``reinterpret_cast``, and ``const_cast``,; rather than C-style casts. There are two exceptions to this:. * When casting to ``void`` to suppress warnings about unused variables (as an; alternative to ``[[maybe_unused]]``). Prefer C-style casts in this instance. * When casting between integral types (including enums that are not strongly-; typed), functi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:22180,interface,interface,22180,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['interface'],['interface']
Integrability,"ly 3 sessions. Additional requests are queued; and run as soon as one of the running; sessions goes idle. The current policy is FIFO, so that there is a; rotation among queued; sessions. In the case of load-based worker assignment, the max number; of running; queries is determined dynamically.; Add support for repeat functionality in the xrd.worker; directive. To avoid repeating the same line N times; one can just add; 'repeat=N'; in the line; for; example;            ;     xpd.worker worker; proofwrks:2093 repeat=4; will define 4 workers on port 2093 of machine 'proofwrks'.; Add support for port specification via the directive; 'xpd.port'; Enable variable; substitution in 'xpd.' directives using the standard; Scalla mechanism described in; http://xrootd.slac.stanford.edu/doc/dev/Syntax_config.htm .; Build also a binary named 'xproofd' which runs; a xrootd; daemon with only the XrdProofdProtocol (i.e. no data serving).; This simplifies setups when data serving is not needed and also allows; to better disantagle problems related to one specific protocol. The new; binary accepts the same arguments as 'xrootd' and parses the same; directives form the same configuration file, with the exception of; 'xpd.protocol xproofd libXrdProofd.so' which should now be dropped. AN; alternative port can be specified via the new 'xpd.port' directive (see; above).; Add support for 'MasterOnly' mode in starting a PROOF; session. This avoids starting the workers when one wants just to browse; the datasets or retrieve results. To start a session in 'MasterOnly'; mode enter ""masteronly""; as second argument to TProof::Open, e.g.;  ;          root[]; TProof *p = TProof::Open(""<masterurl>"", ""masteronly""); Add full support for placeholders; <uid>,; <gid>, <group> and <homedir>; for the directives specified via 'xpd.putenv'; Add the configuration directive 'proofservparents' to; allow specifying a different list of parent names for the 'proofserv'; tasks. This is needed to avoid untimely killing",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html:1712,protocol,protocol,1712,proof/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html,2,['protocol'],['protocol']
Integrability,"ly allows it via; the ``lib/Support`` interface. Use Standard C Headers; ----------------------. The **standard** C headers (the ones beginning with ""c"") are allowed to be; exposed through the ``lib/Support`` interface. These headers and the things they; declare are considered to be platform agnostic. LLVM source files may include; them directly or obtain their inclusion through ``lib/Support`` interfaces. Use Standard C++ Headers; ------------------------. The **standard** C++ headers from the standard C++ library and standard; template library may be exposed through the ``lib/Support`` interface. These; headers and the things they declare are considered to be platform agnostic.; LLVM source files may include them or obtain their inclusion through; ``lib/Support`` interfaces. High Level Interface; --------------------. The entry points specified in the interface of ``lib/Support`` must be aimed at; completing some reasonably high level task needed by LLVM. We do not want to; simply wrap each operating system call. It would be preferable to wrap several; operating system calls that are always used in conjunction with one another by; LLVM. For example, consider what is needed to execute a program, wait for it to; complete, and return its result code. On Unix, this involves the following; operating system calls: ``getenv``, ``fork``, ``execve``, and ``wait``. The; correct thing for ``lib/Support`` to provide is a function, say; ``ExecuteProgramAndWait``, that implements the functionality completely. what; we don't want is wrappers for the operating system calls involved. There must **not** be a one-to-one relationship between operating system; calls and the Support library's interface. Any such interface function will be; suspicious. No Unused Functionality; -----------------------. There must be no functionality specified in the interface of ``lib/Support``; that isn't actually used by LLVM. We're not writing a general purpose operating; system wrapper here, just enou",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:4106,wrap,wrap,4106,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['wrap'],['wrap']
Integrability,"ly described by a frame on the stack.; In the case of C++ exceptions, the exception object is allocated in stack memory; and its address is passed to ``__CxxThrowException``. General purpose structured; exceptions (SEH) are more analogous to Linux signals, and they are dispatched by; userspace DLLs provided with Windows. Each frame on the stack has an assigned EH; personality routine, which decides what actions to take to handle the exception.; There are a few major personalities for C and C++ code: the C++ personality; (``__CxxFrameHandler3``) and the SEH personalities (``_except_handler3``,; ``_except_handler4``, and ``__C_specific_handler``). All of them implement; cleanups by calling back into a ""funclet"" contained in the parent function. Funclets, in this context, are regions of the parent function that can be called; as though they were a function pointer with a very special calling convention.; The frame pointer of the parent frame is passed into the funclet either using; the standard EBP register or as the first parameter register, depending on the; architecture. The funclet implements the EH action by accessing local variables; in memory through the frame pointer, and returning some appropriate value,; continuing the EH process. No variables live in to or out of the funclet can be; allocated in registers. The C++ personality also uses funclets to contain the code for catch blocks; (i.e. all user code between the braces in ``catch (Type obj) { ... }``). The; runtime must use funclets for catch bodies because the C++ exception object is; allocated in a child stack frame of the function handling the exception. If the; runtime rewound the stack back to frame of the catch, the memory holding the; exception would be overwritten quickly by subsequent function calls. The use of; funclets also allows ``__CxxFrameHandler3`` to implement rethrow without; resorting to TLS. Instead, the runtime throws a special exception, and then uses; SEH (``__try / __except``) to res",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst:22350,depend,depending,22350,interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,1,['depend'],['depending']
Integrability,"ly equivalent,; - function types and all their parameters have structurally equivalent types,; - record types and all their fields in order of their definition have the same; identifier names and structurally equivalent types,; - variable or function declarations and they have the same identifier name and; their types are structurally equivalent. In C, two types are structurally equivalent if they are *compatible types*. For; a formal definition of *compatible types*, please refer to 6.2.7/1 in the C11; standard. However, there is no definition for *compatible types* in the C++; standard. Still, we extend the definition of structural equivalency to; templates and their instantiations similarly: besides checking the previously; mentioned properties, we have to check for equivalent template; parameters/arguments, etc. The structural equivalent check can be and is used independently from the; ASTImporter, e.g. the ``clang::Sema`` class uses it also. The equivalence of nodes may depend on the equivalency of other pairs of nodes.; Thus, the check is implemented as a parallel graph traversal. We traverse; through the nodes of both graphs at the same time. The actual implementation is; similar to breadth-first-search. Let's say we start the traverse with the <A,B>; pair of nodes. Whenever the traversal reaches a pair <X,Y> then the following; statements are true:. - A and X are nodes from the same ASTContext.; - B and Y are nodes from the same ASTContext.; - A and B may or may not be from the same ASTContext.; - if A == X and B == Y (pointer equivalency) then (there is a cycle during the; traverse). - A and B are structurally equivalent if and only if. - All dependent nodes on the path from <A,B> to <X,Y> are structurally; equivalent. When we compare two classes or enums and one of them is incomplete or has; unloaded external lexical declarations then we cannot descend to compare their; contained declarations. So in these cases they are considered equal if they; have the s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:92956,depend,depend,92956,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['depend'],['depend']
Integrability,"ly if buffered writing is turned off.; The parallel writer assumes exclusive access to the underlying file during all operations on the writer (e.g. construction and destruction) and all operations on any created fill context (e.g. `Fill()` and `FlushCluster()`).; Notable exceptions are `FlushColumns()` and `FillNoFlush()` which are guaranteed to never access the underlying `TFile` during parallel writing (which is always buffered). A `TFile` does not take ownership of any `RNTuple` objects. When reading data, RNTuple uses the `RMiniFile` and `RRawFile` classes to open a given storage path and find the `RNTuple` anchor.; When creating a `RNTupleReader` from an existing anchor object, RNTuple uses `RRawFile` only for files of dynamic type `TFile`, `TDavixFile`, and `TNetXNGFile`.; In either case, the `RRawFile` owns its own file descriptor and does not interfere with `TFile` objects concurrently reading the file.; For anchors from files of other dynamic type, including all other `TFile` subclasses, the file is wrapped in a `RRawFileTFile` and access is shared. On-Disk Encoding; ----------------. ### Writing Case; The following steps are taken to write RNTuple data to disk:. 1. On creation of the RNTupleWriter, the header is written to disk; 2. Upon `RNTupleWriter::Fill()`, the RField<T> class _serializes_ the object into its column representation.; To this end, it uses the `RColumn` class to append elements to the columns page buffer (`RPage`); 3. When a page buffer is full (cf. tuning.md), it is sent to the page sink for writing it to disk.; Note that page boundaries do _not_ need to align with entry boundaries,; e.g. information from a single entry can span multiple pages.; 1. The page is _packed_:; depending on the type of the page, a light encoding is applied to facilitate compression, e.g., byte splitting (`RColumnElement`).; Big-endian / little-endian conversion takes place here.; 2. The packed page is _compressed_ according to the user-provided compression set",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:19065,wrap,wrapped,19065,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['wrap'],['wrapped']
Integrability,"ly shortly before termination to ; insure closing of files and sockets before the unload of any library.; New collection 'ClosedObjects' holding pointers to TFile or TSocket that; have been closed but not deleted it. In the case of TSocket, they are added only; if they are closed by the CloseFiles.; Add a Close member function to TProofMgr since it is added to the list of socket.; Migrate the closing of files from various to a single place (T*System::Exit).; Fill in the implementation of TROOT::FindObjectAnyFile.; Mark TROOT as TObject::kInvalidObject as soon as its destructor starts,; in order to be able to veto some action later on (like autoloading). TSystem. Better handle the cases where the information in the rootmap file is (almost) empty. ; Avoid infinite loop if one of the dependent library is missing. Meta. Add new fast accessors to Merge routines (See the I/O package for more details.; Improve error message in case a schema evolution rule can not be loaded when the library is loaded; (from the generic 'it conflicts with one of the other rules' to 'the target member ... is unknown'.; Add the ability to explicitly forbid (or allow) the splitting of a class; (TClass::SetSplit ) so that user can inforce the use of a custom streamer in all possible split cases.; Improve the performance of TProcessUUID::AddUUID by reintroducing the THashList.; This significanly improve the performance of reading file with very large number of ; directories (A file with 100,000 directories was traversed in more than 8 minutes; and is now traversed in 15s) without noticeable affecting small files. TFolder. Several enhancement and clarification to TFolder::FindFullPathName. TStyle. Add the fill color attribute (SetLegendFillColor() and the font; attribute (SetLegendFont(). A new TStyle called ""Modern"" has been implemented. It can be set with:. gROOT->SetStyle(""Modern"");; ; It has very little decoration. It was made looking at the default styles; usually used by the experiments.; ; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v530/index.html:1529,message,message,1529,core/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v530/index.html,2,['message'],['message']
Integrability,"ly. - ``FindSymbolOccurrencesRefactoringRule`` produces a ""partial"" refactoring; result: a set of occurrences that refer to a particular symbol. This type; of rule is typically used to implement an interactive renaming action that; allows users to specify which occurrences should be renamed during the; refactoring. Subclasses that choose to implement this rule have to implement; the ``findSymbolOccurrences`` member function. The following set of quick checks might help if you are unsure about the type; of rule you should use:. #. If you would like to transform the source in one translation unit and if; you don't need any cross-TU information, then the; ``SourceChangeRefactoringRule`` should work for you. #. If you would like to implement a rename-like operation with potential; interactive components, then ``FindSymbolOccurrencesRefactoringRule`` might; work for you. How to Create a Rule; ^^^^^^^^^^^^^^^^^^^^. Once you determine which type of rule is suitable for your needs you can; implement the refactoring by subclassing the rule and implementing its; interface. The subclass should have a constructor that takes the inputs that; are needed to perform the refactoring. For example, if you want to implement a; rule that simply deletes a selection, you should create a subclass of; ``SourceChangeRefactoringRule`` with a constructor that accepts the selection; range:. .. code-block:: c++. class DeleteSelectedRange final : public SourceChangeRefactoringRule {; public:; DeleteSelection(SourceRange Selection) : Selection(Selection) {}. Expected<AtomicChanges>; createSourceReplacements(RefactoringRuleContext &Context) override {; AtomicChange Replacement(Context.getSources(), Selection.getBegin());; Replacement.replace(Context.getSource,; CharSourceRange::getCharRange(Selection), """");; return { Replacement };; }; private:; SourceRange Selection;; };. The rule's subclass can then be added to the list of refactoring action's; rules for a particular action using the ``createRefac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:5148,interface,interface,5148,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst,1,['interface'],['interface']
Integrability,"ly. When a compilation is successful (there are no errors), the driver; checks the bit and emits an ""unused argument"" warning for any arguments; which were never accessed. This is conservative (the argument may not; have been used to do what the user wanted) but still catches the most; obvious cases. Relation to GCC Driver Concepts; -------------------------------. For those familiar with the gcc driver, this section provides a brief; overview of how things from the gcc driver map to the clang driver. - **Driver Driver**. The driver driver is fully integrated into the clang driver. The; driver simply constructs additional Actions to bind the architecture; during the *Pipeline* phase. The tool chain specific argument; translation is responsible for handling ``-Xarch_``. The one caveat is that this approach requires ``-Xarch_`` not be used; to alter the compilation itself (for example, one cannot provide; ``-S`` as an ``-Xarch_`` argument). The driver attempts to reject; such invocations, and overall there isn't a good reason to abuse; ``-Xarch_`` to that end in practice. The upside is that the clang driver is more efficient and does little; extra work to support universal builds. It also provides better error; reporting and UI consistency. - **Specs**. The clang driver has no direct correspondent for ""specs"". The; majority of the functionality that is embedded in specs is in the; Tool specific argument translation routines. The parts of specs which; control the compilation pipeline are generally part of the *Pipeline*; stage. - **Toolchains**. The gcc driver has no direct understanding of tool chains. Each gcc; binary roughly corresponds to the information which is embedded; inside a single ToolChain. The clang driver is intended to be portable and support complex; compilation environments. All platform and tool chain specific code; should be protected behind either abstract or well defined interfaces; (such as whether the platform supports use as a driver driver).; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:16175,rout,routines,16175,interpreter/llvm-project/clang/docs/DriverInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst,2,"['interface', 'rout']","['interfaces', 'routines']"
Integrability,"lymorphic containers that can contain; different types of elements. For this release of the ROOT system, elements; to be placed in collections must be instances of classes.; These may be classes defined by you or provided by ROOT. Collection elements; must be instances of classes descending from ; TObject. The dependence of collections on TObject may disappear; in the future when all C++ compilers used with the ROOT system fully; support templates. In the mean time, knowing the; role TObject plays in collections can be helpful. In general you don't need to worry about TObject. Many ROOT; classes have TObject as an ancestor. In fact, collections themselves; are descendants of TObject. This makes it possible for collections to; contain other collections (subcollections) in a tree structure. Such trees; are used in the ROOT system to implement components of the graphics system; (graphics pads containing pads), geometries (detectors in detectors), etc. The basic protocol TObject defines for collection elements is shown below:. IsEqual(); Compare(); IsSortable(); Hash(). How to use and override these member functions is shown in the; example program. Types of Collections. The ROOT system implements the following type of collections:; arrays, lists, sorted lists, B-trees, hashtables and maps.; The figure below shows the inheritance hierarchy for the primary; collection classes. Ordered Collections (Sequences). Sequences are collections that are externally ordered because they; maintain internal elements according to the order in which they; were added. The following sequence collections are available:. TList; THashList; TOrdCollection; TObjArray; TClonesArray. Both a TObjArray as well as a TOrdCollection can be sorted; using their Sort() member function (assuming the stored items are; sortable). Sorted Collections. Sorted collections are ordered by an internal (automatic) sorting mechanism.; The following sorted collections are available:. TSortedList; TBtree. Unordered C",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/doc/Understanding_Collections.html:1539,protocol,protocol,1539,core/cont/doc/Understanding_Collections.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/doc/Understanding_Collections.html,2,['protocol'],['protocol']
Integrability,"m LLVM_ENABLE_PROJECTS above.; set(LLVM_DEFAULT_RUNTIMES ""libcxx;libcxxabi;libunwind""); set(LLVM_SUPPORTED_RUNTIMES ""libc;libunwind;libcxxabi;pstl;libcxx;compiler-rt;openmp;llvm-libgcc""); set(LLVM_ENABLE_RUNTIMES """" CACHE STRING; ""Semicolon-separated list of runtimes to build, or \""all\"" (${LLVM_DEFAULT_RUNTIMES}). Supported runtimes are ${LLVM_SUPPORTED_RUNTIMES}.""); if(LLVM_ENABLE_RUNTIMES STREQUAL ""all""); set(LLVM_ENABLE_RUNTIMES ${LLVM_DEFAULT_RUNTIMES}); endif(); foreach(proj IN LISTS LLVM_ENABLE_RUNTIMES); if (NOT ""${proj}"" IN_LIST LLVM_SUPPORTED_RUNTIMES); message(FATAL_ERROR ""Runtime \""${proj}\"" is not a supported runtime. Supported runtimes are: ${LLVM_SUPPORTED_RUNTIMES}""); endif(); endforeach(). if (""libc"" IN_LIST LLVM_ENABLE_RUNTIMES); # To build the libc runtime, we need to be able to build few libc build; # tools from the ""libc"" project. So, we add it to the list of enabled; # projects.; if (NOT ""libc"" IN_LIST LLVM_ENABLE_PROJECTS); message(STATUS ""Enabling libc project to build libc build tools""); list(APPEND LLVM_ENABLE_PROJECTS ""libc""); endif(); endif(). # LLVM_ENABLE_PROJECTS_USED is `ON` if the user has ever used the; # `LLVM_ENABLE_PROJECTS` CMake cache variable. This exists for; # several reasons:; #; # * As an indicator that the `LLVM_ENABLE_PROJECTS` list is now the single; # source of truth for which projects to build. This means we will ignore user; # supplied `LLVM_TOOL_<project>_BUILD` CMake cache variables and overwrite; # them.; #; # * The case where the user previously had `LLVM_ENABLE_PROJECTS` set to a; # non-empty list but now the user wishes to disable building all other projects; # by setting `LLVM_ENABLE_PROJECTS` to an empty string. In that case we still; # need to set the `LLVM_TOOL_${upper_proj}_BUILD` variables so that we disable; # building all the projects that were previously enabled.; set(LLVM_ENABLE_PROJECTS_USED OFF CACHE BOOL """"); mark_as_advanced(LLVM_ENABLE_PROJECTS_USED). if (LLVM_ENABLE_PROJECTS_USED OR NOT LLVM_ENA",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:7714,message,message,7714,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['message'],['message']
Integrability,"m and level for; compression. Int_t GetCompressionAlgorithm() const;; Int_t GetCompressionLevel() const;; Int_t GetCompressionSettings() const;. If the compression level is set to 0, then no compression will be; done. All of the currently supported algorithms allow the level to be; set to any value from 1 to 9. The higher the level, the larger the; compression factors will be (smaller compressed data size). The; tradeoff is that for higher levels more CPU time is used for; compression and possibly more memory. The ZLIB algorithm takes less; CPU time during compression than the LZMA algorithm, but the LZMA; algorithm usually delivers higher compression factors. The header file core/zip/inc/Compression.h declares the function; ""CompressionSettings"" and the enumeration for the algorithms.; Currently the following selections can be made for the algorithm:; kZLIB (1), kLZMA (2), kOldCompressionAlgo (3), and kUseGlobalSetting; (0). The last option refers to an older interface used to control the; algorithm that is maintained for backward compatibility. The following; function is defined in core/zip/inc/Bits.h and it set the global; variable. R__SetZipMode(int algorithm);. If the algorithm is set to kUseGlobalSetting (0), the global variable; controls the algorithm for compression operations. This is the; default and the default value for the global variable is kZLIB. gDirectory; gDirectory is now a thread local!. The value of gDirectory and gFile are now all accessed via a static function of their respective class. The access is made transparent via a CPP macro. Note: Whenever a thread has an associated TThread object, the value of gDirectory is now thread local, i.e. all modifications direct or indirect of gDirectory will not be seen by the other thread. In particular this means that several I/O operations (including TDirectory::Write) are thread safe (as long as all the required TClass and TStreamerInfo has been previously setup).; Note: This model does not support shari",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v532/index.html:2503,interface,interface,2503,io/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v532/index.html,2,['interface'],['interface']
Integrability,"m is uniquely defined. For example, given three observables ; x, y and z, one can define a parameterized named range 'R' of x in terms of y and of y in terms of z; and ask to calculate the three dimensional integral of any function or p.d.f in terms of (x,y,z); over that range 'R' and it will be calculated correctly, taking recursive range dependencies into; account. A definition of a range 'R' on the other hand where the bounds of x depend on y and; the bounds of y depend on x is not allowed, and an error message will be printed to complain about; the ambiguity of the problem definition. Integrals over non-rectangular regions are created the; same way as integrals over rectangular regions using the RooAbsReal::createIntegral() function, the; chosen mode of operation depends on the shape of the requestion integration range. Note that in general integration over non (hyper)rectangular regions will be more computationally; intensive as only a subset of the observables can be integrated analytically (all of those that do not; have parameterized ranges plus those that have parameterized ranges but are not involved in the; parameterization of others (e.g. x and y in the example above). Running integrals and Cumulative distribution functions. It is now possible to create running integrals from any RooAbsReal function and; to create cumulative distribution functions from any RooAbsPdf using the following; methods:. // Create int[xlo,x] f(x') dx' from f(x); RooAbsReal* runInt = func.createRunningIntegral(x) ;. // Create int[xlo,x] f(x') dx' from p.d.f f(x) normalized over x; RooAbsReal* cdf = pdf.createCdf(x) ;. // Create int[xlo,x] f(x',y) dx' from p.d.f f(x,y) normalized over (x,y); RooAbsReal* cdf = pdf.createCdf(x,y) ;. ; As with the similarly styled function createIntegral running integrals and c.d.f. can be created; over any number of observables, e.g createCdf(RooArgSet(x,y,z)) will create a three-dimensional; cumulative distribution function. C.d.f and running integr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html:4744,integrat,integration,4744,roofit/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html,4,['integrat'],"['integrated', 'integration']"
Integrability,"m of CPU time. More detailed information on the new mathematical functions can be found in this presentation from M. Slawinska at a ROOT team meeting. define the functions as template functions instead of having the same re-definition for all the various basic types. This is done for TMath::Mean,TMath::GeomMean, TMath::Median, TMath::KOrdStat; Use STL to implement the following algorithms:; ; TMath::Sort is re-implemented using std::sort.; TMath::BinarySearch is re-implemented using the STL algorithm std::lower_bound. The STL algorithms have been found for these cases to be perform better in term of CPU time. For some other algorithms like TMath::LocMin, TMath::LocMax or TMath::Permute the original implementation is faster than STL and has been maintained.; ; Add a generic iterator interface, similar to the STL algorithm interface, to the following TMath functions:; MinElement, MaxElement, LocMin, LocMax, Mean, GeomMean, RMS,; BinarySearch. The iterator interface for sort is called; TMath::SortItr to avoid a compilation ambiguity. For example,; for finding the mean of a std::vector<double> v, one simply needs to call TMath::Mean(v.begin(), v.end() ) .; ; Various changes have been applied to the mathematical functions to remove duplications in the implementation with the special and statistical functions defined in ROOT::Math. The functions which have been changed and thus they can return a sightly different result than before are:; ; TMath::Erf and TMath::Erfc call ROOT::Math::erf and ROOT::math::erfc which are implemented using the Cephes algorithms, which is accurate at the required double precision level.; TMath::Gamma(z) is implemented with ROOT::Math::tgamma, which again uses Cephes.; The incomplete gamma function, TMath::Gamma(a,x) it is implemented using ROOT::Math::inc_gamma based on a corresponding Cephes function.; TMath::Prob (the upper chi2 probability) is implemented also using ROOT::Math::chisquared_cdf_c which uses ROOT::Math::inc_gamma_c based on a c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:2325,interface,interface,2325,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,2,['interface'],['interface']
Integrability,"m processing within the preprocessor. If the; attribute is meant to be used by Clang, it should; set the namespace to ``""clang""``. Note that this; spelling is not used for declaration attributes.; ================== =========================================================. The C++ standard specifies that “any [non-standard attribute] that is not; recognized by the implementation is ignored” (``[dcl.attr.grammar]``).; The rule for C is similar. This makes ``CXX11`` and ``C23`` spellings; unsuitable for attributes that affect the type system, that change the; binary interface of the code, or that have other similar semantic meaning. ``RegularKeyword`` provides an alternative way of spelling such attributes.; It reuses the production rules for standard attributes, but it applies them; to plain keywords rather than to ``[[…]]`` sequences. Compilers that don't; recognize the keyword are likely to report an error of some kind. For example, the ``ArmStreaming`` function type attribute affects; both the type system and the binary interface of the function.; It cannot therefore be spelled ``[[arm::streaming]]``, since compilers; that don't understand ``arm::streaming`` would ignore it and miscompile; the code. ``ArmStreaming`` is instead spelled ``__arm_streaming``, but it; can appear wherever a hypothetical ``[[arm::streaming]]`` could appear. Subjects; ~~~~~~~~; Attributes appertain to one or more subjects. If the attribute attempts to; attach to a subject that is not in the subject list, a diagnostic is issued; automatically. Whether the diagnostic is a warning or an error depends on how; the attribute's ``SubjectList`` is defined, but the default behavior is to warn.; The diagnostics displayed to the user are automatically determined based on the; subjects in the list, but a custom diagnostic parameter can also be specified in; the ``SubjectList``. The diagnostics generated for subject list violations are; calculated automatically or specified by the subject list itself",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:132060,interface,interface,132060,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['interface'],['interface']
Integrability,"m, consider whether; there is some refinement of an abstract base class which is a semantically; meaningful type on an interface boundary. If anything more refined than the; root abstract interface is meaningless to talk about as a partial extension of; the semantic model, then your use case likely fits better with polymorphism and; you should avoid using virtual dispatch. However, there may be some exigent; circumstances that require one technique or the other to be used. If you do need to introduce a type hierarchy, we prefer to use explicitly; closed type hierarchies with manual tagged dispatch and/or RTTI rather than the; open inheritance model and virtual dispatch that is more common in C++ code.; This is because LLVM rarely encourages library consumers to extend its core; types, and leverages the closed and tag-dispatched nature of its hierarchies to; generate significantly more efficient code. We have also found that a large; amount of our usage of type hierarchies fits better with tag-based pattern; matching rather than dynamic dispatch across a common interface. Within LLVM we; have built custom helpers to facilitate this design. See this document's; section on :ref:`isa and dyn_cast <isa>` and our :doc:`detailed document; <HowToSetUpLLVMStyleRTTI>` which describes how you can implement this; pattern for use with the LLVM helpers. .. _abi_breaking_checks:. ABI Breaking Checks; -------------------. Checks and asserts that alter the LLVM C++ ABI are predicated on the; preprocessor symbol `LLVM_ENABLE_ABI_BREAKING_CHECKS` -- LLVM; libraries built with `LLVM_ENABLE_ABI_BREAKING_CHECKS` are not ABI; compatible LLVM libraries built without it defined. By default,; turning on assertions also turns on `LLVM_ENABLE_ABI_BREAKING_CHECKS`; so a default +Asserts build is not ABI compatible with a; default -Asserts build. Clients that want ABI compatibility; between +Asserts and -Asserts builds should use the CMake build system; to set `LLVM_ENABLE_ABI_BREAKING_CHECKS` i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:132882,interface,interface,132882,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['interface'],['interface']
Integrability,"m. Status; ======. The original authors of libFuzzer have stopped active work on it and switched; to working on another fuzzing engine, Centipede_. LibFuzzer is still fully; supported in that important bugs will get fixed. However, please do not expect; major new features or code reviews, other than for bug fixes. Versions; ========. LibFuzzer requires a matching version of Clang. Getting Started; ===============. .. contents::; :local:; :depth: 1. Fuzz Target; -----------. The first step in using libFuzzer on a library is to implement a; *fuzz target* -- a function that accepts an array of bytes and; does something interesting with these bytes using the API under test.; Like this:. .. code-block:: c++. // fuzz_target.cc; extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {; DoSomethingInterestingWithMyAPI(Data, Size);; return 0; // Values other than 0 and -1 are reserved for future use.; }. Note that this fuzz target does not depend on libFuzzer in any way; and so it is possible and even desirable to use it with other fuzzing engines; e.g. AFL_ and/or Radamsa_. Some important things to remember about fuzz targets:. * The fuzzing engine will execute the fuzz target many times with different inputs in the same process.; * It must tolerate any kind of input (empty, huge, malformed, etc).; * It must not `exit()` on any input.; * It may use threads but ideally all threads should be joined at the end of the function.; * It must be as deterministic as possible. Non-determinism (e.g. random decisions not based on the input bytes) will make fuzzing inefficient.; * It must be fast. Try avoiding cubic or greater complexity, logging, or excessive memory consumption.; * Ideally, it should not modify any global state (although that's not strict).; * Usually, the narrower the target the better. E.g. if your target can parse several data formats, split it into several targets, one per format. Fuzzer Usage; ------------. Recent versions of Clang (starting from ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:1713,depend,depend,1713,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['depend'],['depend']
Integrability,"mFreeContent(attrList, outData);; // warn: deallocator doesn't match the allocator; }. osx.cocoa.AtSync; (ObjC); Check for nil pointers used as mutexes for @synchronized. void test(id x) {; if (!x); @synchronized(x) {} // warn: nil value used as mutex; }. void test() {; id y;; @synchronized(y) {} // warn: uninitialized value used as mutex; }. osx.cocoa.ClassRelease; (ObjC); Check for sending retain, release, or ; autorelease directly to a class. @interface MyClass : NSObject; @end. void test(void) {; [MyClass release]; // warn; }. osx.cocoa.Dealloc; (ObjC); Warn about Objective-C classes that lack a correct implementation; of -dealloc. @interface MyObject : NSObject {; id _myproperty;; }; @end. @implementation MyObject // warn: lacks 'dealloc'; @end. @interface MyObject : NSObject {}; @property(assign) id myproperty;; @end. @implementation MyObject // warn: does not send 'dealloc' to super; - (void)dealloc {; self.myproperty = 0;; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(retain) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var was retained but wasn't released; - (void)dealloc {; [super dealloc];; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(assign) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var wasn't retained but was released; - (void)dealloc {; [_myproperty release];; [super dealloc];; }; @end. osx.cocoa.IncompatibleMethodTypes; (ObjC); Check for an incompatible type signature when overriding an Objective-C method. @interface MyClass1 : NSObject; - (int)foo;; @end. @implementation MyClass1; - (int)foo { return 1; }; @end. @interface MyClass2 : MyClass1; - (float)foo;; @end. @implementation MyClass2; - (float)foo { return 1.0; } // warn; @end. osx.cocoa.MissingSuperCall; (ObjC); Warn about Objective-C methods that lack a necessary call to super. (Note: The; compiler now has a warning for methods annotate",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:15477,interface,interface,15477,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,2,['interface'],['interface']
Integrability,"macro(print_list my_list); foreach(var IN LISTS my_list); message(""${var}""); endforeach(); endmacro(). set(my_list a b c d); set(my_list_of_numbers 1 2 3 4); print_list(my_list_of_numbers); # prints:; # a; # b; # c; # d. Generally speaking this issue is uncommon because it requires using; non-dereferenced variables with names that overlap in the parent scope, but it; is important to be aware of because it can lead to subtle bugs. LLVM Project Wrappers; =====================. LLVM projects provide lots of wrappers around critical CMake built-in commands.; We use these wrappers to provide consistent behaviors across LLVM components; and to reduce code duplication. We generally (but not always) follow the convention that commands prefaced with; ``llvm_`` are intended to be used only as building blocks for other commands.; Wrapper commands that are intended for direct use are generally named following; with the project in the middle of the command name (i.e. ``add_llvm_executable``; is the wrapper for ``add_executable``). The LLVM ``add_*`` wrapper functions are; all defined in ``AddLLVM.cmake`` which is installed as part of the LLVM; distribution. It can be included and used by any LLVM sub-project that requires; LLVM. .. note::. Not all LLVM projects require LLVM for all use cases. For example compiler-rt; can be built without LLVM, and the compiler-rt sanitizer libraries are used; with GCC. Useful Built-in Commands; ========================. CMake has a bunch of useful built-in commands. This document isn't going to; go into details about them because The CMake project has excellent; documentation. To highlight a few useful functions see:. * `add_custom_command <https://cmake.org/cmake/help/v3.4/command/add_custom_command.html>`_; * `add_custom_target <https://cmake.org/cmake/help/v3.4/command/add_custom_target.html>`_; * `file <https://cmake.org/cmake/help/v3.4/command/file.html>`_; * `list <https://cmake.org/cmake/help/v3.4/command/list.html>`_; * `math <https://cma",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst:13652,wrap,wrapper,13652,interpreter/llvm-project/llvm/docs/CMakePrimer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst,1,['wrap'],['wrapper']
Integrability,"macro.C', e.g. '#include ""thisheader.h""' .; Import the dataset stager daemon 'afdsmgrd' into ROOT; this is used; to manage data staging based on the dataset information (see; http://code.google.com/p/afdsmgrd/ for more info). The daemon is; located under $ROOTSYS/proof/afdsmgrd .; New PROOF bench suite, a framework to run CPU and IO benchmarks with; default selectors/data or with user-provided ones. The code is located; under proof/proofbench.; Add the possibility to access the files on the workers via the same; port used by PROOF. This is useful for cases when it is not possible to; start a file server daemon on a different port (because, for eample, of; a firewall or just inconvenience) and workers do not share a file; system. Internally this works by forking a 'rootd' after identifying a; file request and trasferring the connection to it. The client side is a; TNetFile and it is triggered by the protocol ""rootd://"" (the just; implemented etc/plugins/TFile/P120_TNetFile.C includes this; protocol).; Add support for log file truncation. Truncation is disabled by; default. Enabling is controlled by the rootrc variable.           ; ProofServ.LogFileMaxSize  ; {<bytes>|<kilobytes>K|<megabytes>M|<gigabytes>G}.  indicating the max number of bytes. The number can be followed by; a {K,M,G} to indicate KBytes, MBytes or GBytes, respectively.; Add new derivation of TList (TProofOutputList) to be used on the; PROOF client to filter out PROOF internal objects when displaying or; printing the list. By default objects was names start with 'PROOF_' are; not shown. The presence of a non empty missing file list is; notified.; In the PROOF monitoring to: send additional information about memory; usage during the query, the name and size (# of files) of the dataset; processed (if any); add possibility to send the information to multiple; monitoring collectors.; Add support for block activation/deactivation of workers.; Add possibility to start the proofserv with 'system()' instead of;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v530/index.html:1625,protocol,protocol,1625,proof/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v530/index.html,2,['protocol'],['protocol']
Integrability,"made to work::. $ conda create -n WORK; $ conda activate WORK; (WORK) $ conda install python; (WORK) $ conda install -c conda-forge compilers; (WORK) [current compiler] $ python -m pip install cppyy. C++ standard with pip; ---------------------. The C++20 standard is the default on all systems as of release 3.0.1 (both; PyPI and conda-forge); it is C++17 for older releases.; When installing from PyPI using ``pip``, you can control the standard; selection by setting the ``STDCXX`` envar to '20', '17', or '14' (for Linux,; the backend does not need to be recompiled) for the 3.x releases; '17', '14',; or '11' for the 2.x releases.; Note that the build will automatically lower your choice if the compiler used; does not support a newer standard. Install from source; -------------------; .. _installation_from_source:. To build an existing release from source, tell ``pip`` to not download any; binary wheels.; Build-time only dependencies are ``cmake`` (for general build), ``python``; (obviously, but also for LLVM), and a modern C++ compiler (one that supports; at least C++14).; Use the envar ``STDCXX`` to control the C++ standard version; ``MAKE`` to; change the ``make`` command, ``MAKE_NPROCS`` to control the maximum number of; parallel jobs allowed, and ``VERBOSE=1`` to see full build/compile commands.; Example (using ``--verbose`` to see ``pip`` progress)::. $ STDCXX=17 MAKE_NPROCS=32 pip install --verbose cppyy --no-binary=cppyy-cling. Compilation of the backend, which contains a customized version of; Clang/LLVM, can take a long time, so by default the setup script will use all; cores (x2 if hyperthreading is enabled).; Once built, however, the wheel of ``cppyy-cling`` is reused by pip for all; versions of CPython and for PyPy, thus the long compilation is needed only; once for all different versions of Python on the same machine. See the :ref:`section on repos <building_from_source>` for more; details/options. PyPy; ----. PyPy 5.7 and 5.8 have a built-in module ``cpp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/installation.rst:5502,depend,dependencies,5502,bindings/pyroot/cppyy/cppyy/doc/source/installation.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/installation.rst,1,['depend'],['dependencies']
Integrability,"make; ```. This configures and builds ROOT using `/usr/lib/libpthread.so` as the; `Pthread` library, and defines `R__THREAD`. This enables the thread specific treatment of *`gPad`*, and creates; `$ROOTSYS/lib/libThread.so.`. Note: The parameter linuxdeb2 has to be replaced with the appropriate; ROOT keyword for your platform. ### Classes. **`TThread`** class implements threads . The platform dependent; implementation is in the **`TThreadImp`** class and its descendant; classes (e.g. **`TPosixThread`** ). **`TMutex`** class implements `mutex` locks. A mutex is a mutually; exclusive lock. The platform dependent implementation is in the; **`TMutexImp`** class and its descendant classes (e.g.; **`TPosixMutex`**). **`TCondition`** class implements a condition variable. Use a condition; variable to signal threads. The platform dependent implementation is in; the **`TConditionImp`** and **`TPosixCondition`** classes . **`TSemaphore`** class implements a counting semaphore. Use a semaphore; to synchronize threads. The platform dependent implementation is in the; **`TMutexImp`** and **`TConditionImp`** classes. ### TThread for Pedestrians. To run a thread in ROOT, follow these steps:. 1. Initialization. Add these lines to your `rootlogon.C`:. ``` {.cpp}; {; ...; // The next line may be unnecessary on some platforms; gSystem->Load(""/usr/lib/libpthread.so"");; gSystem->Load(""$ROOTSYS/lib/libThread.so"");; ...; }; ```. This loads the library with the **`TThread`** class and the `pthread`; specific implementation file for `Posix` threads. 2. Coding. Define a function (e.g. `void* UserFun(void* UserArgs))` that should run; as a thread. The code for the examples is at the web site of the authors; (Jörn Adamczewski, Marc Hemberger). After downloading the code from this; site, you can follow the example below:. <http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html>. 3. Loading. Start an interactive ROOT session. Load the shared library:. ``` {.cpp}; root[] gSystem->Load(""mhs",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:4202,synchroniz,synchronize,4202,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['synchroniz'],['synchronize']
Integrability,"mand line constructed by; the Clang driver or from clients performing custom initialization. The data; structure is split into logical units used by different parts of the compiler,; for example ``PreprocessorOptions``, ``LanguageOptions`` or ``CodeGenOptions``. Command Line Interface; ----------------------. The command line interface of the Clang ``-cc1`` frontend is defined alongside; the driver options in ``clang/Driver/Options.td``. The information making up an; option definition includes its prefix and name (for example ``-std=``), form and; position of the option value, help text, aliases and more. Each option may; belong to a certain group and can be marked with zero or more flags. Options; accepted by the ``-cc1`` frontend are marked with the ``CC1Option`` flag. Command Line Parsing; --------------------. Option definitions are processed by the ``-gen-opt-parser-defs`` tablegen; backend during early stages of the build. Options are then used for querying an; instance ``llvm::opt::ArgList``, a wrapper around the command line arguments.; This is done in the Clang driver to construct individual jobs based on the; driver arguments and also in the ``CompilerInvocation::CreateFromArgs`` function; that parses the ``-cc1`` frontend arguments. Command Line Generation; -----------------------. Any valid ``CompilerInvocation`` created from a ``-cc1`` command line can be; also serialized back into semantically equivalent command line in a; deterministic manner. This enables features such as implicitly discovered,; explicitly built modules. ..; TODO: Create and link corresponding section in Modules.rst. Adding new Command Line Option; ------------------------------. When adding a new command line option, the first place of interest is the header; file declaring the corresponding options class (e.g. ``CodeGenOptions.h`` for; command line option that affects the code generation). Create new member; variable for the option value:. .. code-block:: diff. class CodeGenOptions ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:27747,wrap,wrapper,27747,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['wrap'],['wrapper']
Integrability,"mantics:; """""""""""""""""""". The '``llvm.va_end``' intrinsic works just like the ``va_end`` macro; available in C. In a target-dependent way, it destroys the ``va_list``; element to which the argument points. Calls to; :ref:`llvm.va_start <int_va_start>` and; :ref:`llvm.va_copy <int_va_copy>` must be matched exactly with calls to; ``llvm.va_end``. .. _int_va_copy:. '``llvm.va_copy``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.va_copy(ptr <destarglist>, ptr <srcarglist>). Overview:; """""""""""""""""". The '``llvm.va_copy``' intrinsic copies the current argument position; from the source argument list to the destination argument list. Arguments:; """""""""""""""""""". The first argument is a pointer to a ``va_list`` element to initialize.; The second argument is a pointer to a ``va_list`` element to copy from. Semantics:; """""""""""""""""""". The '``llvm.va_copy``' intrinsic works just like the ``va_copy`` macro; available in C. In a target-dependent way, it copies the source; ``va_list`` element into the destination ``va_list`` element. This; intrinsic is necessary because the `` llvm.va_start`` intrinsic may be; arbitrarily complex and require, for example, memory allocation. Accurate Garbage Collection Intrinsics; --------------------------------------. LLVM's support for `Accurate Garbage Collection <GarbageCollection.html>`_; (GC) requires the frontend to generate code containing appropriate intrinsic; calls and select an appropriate GC strategy which knows how to lower these; intrinsics in a manner which is appropriate for the target collector. These intrinsics allow identification of :ref:`GC roots on the; stack <int_gcroot>`, as well as garbage collector implementations that; require :ref:`read <int_gcread>` and :ref:`write <int_gcwrite>` barriers.; Frontends for type-safe garbage collected languages should generate; these intrinsics to make use of the LLVM garbage collectors. For more; details, see `Garbage Collection with LLVM <GarbageCollection.html>`_.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:495204,depend,dependent,495204,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['dependent']
Integrability,"mapped into a different one depending on; the current instruction set. Instruction Aliases; ^^^^^^^^^^^^^^^^^^^. The most general phase of alias processing occurs while matching is happening:; it provides new forms for the matcher to match along with a specific instruction; to generate. An instruction alias has two parts: the string to match and the; instruction to generate. For example:. ::. def : InstAlias<""movsx $src, $dst"", (MOVSX16rr8W GR16:$dst, GR8 :$src)>;; def : InstAlias<""movsx $src, $dst"", (MOVSX16rm8W GR16:$dst, i8mem:$src)>;; def : InstAlias<""movsx $src, $dst"", (MOVSX32rr8 GR32:$dst, GR8 :$src)>;; def : InstAlias<""movsx $src, $dst"", (MOVSX32rr16 GR32:$dst, GR16 :$src)>;; def : InstAlias<""movsx $src, $dst"", (MOVSX64rr8 GR64:$dst, GR8 :$src)>;; def : InstAlias<""movsx $src, $dst"", (MOVSX64rr16 GR64:$dst, GR16 :$src)>;; def : InstAlias<""movsx $src, $dst"", (MOVSX64rr32 GR64:$dst, GR32 :$src)>;. This shows a powerful example of the instruction aliases, matching the same; mnemonic in multiple different ways depending on what operands are present in; the assembly. The result of instruction aliases can include operands in a; different order than the destination instruction, and can use an input multiple; times, for example:. ::. def : InstAlias<""clrb $reg"", (XOR8rr GR8 :$reg, GR8 :$reg)>;; def : InstAlias<""clrw $reg"", (XOR16rr GR16:$reg, GR16:$reg)>;; def : InstAlias<""clrl $reg"", (XOR32rr GR32:$reg, GR32:$reg)>;; def : InstAlias<""clrq $reg"", (XOR64rr GR64:$reg, GR64:$reg)>;. This example also shows that tied operands are only listed once. In the X86; backend, XOR8rr has two input GR8's and one output GR8 (where an input is tied; to the output). InstAliases take a flattened operand list without duplicates; for tied operands. The result of an instruction alias can also use immediates; and fixed physical registers which are added as simple immediate operands in the; result, for example:. ::. // Fixed Immediate operand.; def : InstAlias<""aad"", (AAD8i8 10)>;. // Fixe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:84302,depend,depending,84302,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['depend'],['depending']
Integrability,"marks-section=<bool>``. The section is named:. * ``__LLVM,__remarks`` (MachO). C API; =====. LLVM provides a library that can be used to parse remarks through a shared; library named ``libRemarks``. The typical usage through the C API is like the following:. .. code-block:: c. LLVMRemarkParserRef Parser = LLVMRemarkParserCreateYAML(Buf, Size);; LLVMRemarkEntryRef Remark = NULL;; while ((Remark = LLVMRemarkParserGetNext(Parser))) {; // use Remark; LLVMRemarkEntryDispose(Remark); // Release memory.; }; bool HasError = LLVMRemarkParserHasError(Parser);; LLVMRemarkParserDispose(Parser);. Remark streamers; ================. The ``RemarkStreamer`` interface is used to unify the serialization; capabilities of remarks across all the components that can generate remarks. All remark serialization should go through the main remark streamer, the; ``llvm::remarks::RemarkStreamer`` set up in the ``LLVMContext``. The interface; takes remark objects converted to ``llvm::remarks::Remark``, and takes care of; serializing it to the requested format, using the requested type of metadata,; etc. Typically, a specialized remark streamer will hold a reference to the one set; up in the ``LLVMContext``, and will operate on its own type of diagnostics. For example, LLVM IR passes will emit ``llvm::DiagnosticInfoOptimization*``; that get converted to ``llvm::remarks::Remark`` objects. Then, clang could set; up its own specialized remark streamer that takes ``clang::Diagnostic``; objects. This can allow various components of the frontend to emit remarks; using the same techniques as the LLVM remarks. This gives us the following advantages:. * Composition: during the compilation pipeline, multiple components can set up; their specialized remark streamers that all emit remarks through the same; main streamer.; * Re-using the remark infrastructure in ``lib/Remarks``.; * Using the same file and format for the remark emitters created throughout the; compilation. at the cost of an extra layer of abstr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst:17240,interface,interface,17240,interpreter/llvm-project/llvm/docs/Remarks.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst,1,['interface'],['interface']
Integrability,"match the given name to the current; calling convention. If the name identifies the current calling convention,; then a specified action is invoked. In the following example (in; ``X86CallingConv.td``), if the ``Fast`` calling convention is in use, then; ``RetCC_X86_32_Fast`` is invoked. If the ``SSECall`` calling convention is in; use, then ``RetCC_X86_32_SSE`` is invoked. .. code-block:: text. def RetCC_X86_32 : CallingConv<[; CCIfCC<""CallingConv::Fast"", CCDelegateTo<RetCC_X86_32_Fast>>,; CCIfCC<""CallingConv::X86_SSECall"", CCDelegateTo<RetCC_X86_32_SSE>>,; CCDelegateTo<RetCC_X86_32_C>; ]>;. ``CCAssignToRegAndStack`` is the same as ``CCAssignToReg``, but also allocates; a stack slot, when some register is used. Basically, it works like:; ``CCIf<CCAssignToReg<regList>, CCAssignToStack<size, align>>``. .. code-block:: text. class CCAssignToRegAndStack<list<Register> regList, int size, int align>; : CCAssignToReg<regList> {; int Size = size;; int Align = align;; }. Other calling convention interfaces include:. * ``CCIf <predicate, action>`` --- If the predicate matches, apply the action. * ``CCIfInReg <action>`` --- If the argument is marked with the ""``inreg``""; attribute, then apply the action. * ``CCIfNest <action>`` --- If the argument is marked with the ""``nest``""; attribute, then apply the action. * ``CCIfNotVarArg <action>`` --- If the current function does not take a; variable number of arguments, apply the action. * ``CCAssignToRegWithShadow <registerList, shadowList>`` --- similar to; ``CCAssignToReg``, but with a shadow list of registers. * ``CCPassByVal <size, align>`` --- Assign value to a stack slot with the; minimum specified size and alignment. * ``CCPromoteToType <type>`` --- Promote the current value to the specified; type. * ``CallingConv <[actions]>`` --- Define each calling convention that is; supported. Assembly Printer; ================. During the code emission stage, the code generator may utilize an LLVM pass to; produce assembly output. To d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:65670,interface,interfaces,65670,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['interface'],['interfaces']
Integrability,"math``. * ``-ffp-contract=fast``. Note: ``-ffast-math`` causes ``crtfastmath.o`` to be linked with code. See; :ref:`crtfastmath.o` for more details. .. option:: -fno-fast-math. Disable fast-math mode. This options disables unsafe floating-point; optimizations by preventing the compiler from making any transformations that; could affect the results. This option implies:. * ``-fhonor-infinities``. * ``-fhonor-nans``. * ``-fno-approx-func``. * ``-fno-finite-math-only``. * ``-fno-associative-math``. * ``-fno-reciprocal-math``. * ``-fsigned-zeros``. * ``-ffp-contract=on``. Also, this option resets following options to their target-dependent defaults. * ``-f[no-]math-errno``; * ``-fdenormal-fp-math=<value>``. There is ambiguity about how ``-ffp-contract``, ``-ffast-math``,; and ``-fno-fast-math`` behave when combined. To keep the value of; ``-ffp-contract`` consistent, we define this set of rules:. * ``-ffast-math`` sets ``ffp-contract`` to ``fast``. * ``-fno-fast-math`` sets ``-ffp-contract`` to ``on`` (``fast`` for CUDA and; HIP). * If ``-ffast-math`` and ``-ffp-contract`` are both seen, but; ``-ffast-math`` is not followed by ``-fno-fast-math``, ``ffp-contract``; will be given the value of whichever option was last seen. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has been seen at least; once, the ``ffp-contract`` will get the value of the last seen value of; ``-ffp-contract``. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has not been seen, the; ``-ffp-contract`` setting is determined by the default value of; ``-ffp-contract``. Note: ``-fno-fast-math`` implies ``-fdenormal-fp-math=ieee``.; ``-fno-fast-math`` causes ``crtfastmath.o`` to not be linked with code. .. option:: -fdenormal-fp-math=<value>. Select which denormal numbers the code is permitted to require. Valid values are:. * ``ieee`` - IEEE 754 denormal numbers; * ``preserve-sign`` - the sign of a flushed-to-zero number is preserved in the sign of 0; * ``positive-zero`` - denormals are flushe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:53879,contract,contract,53879,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['contract'],['contract']
Integrability,"matic uses of volatile; P1152R4; Clang 10. [[nodiscard(""with reason"")]]; P1301R4; Clang 9. using enum; P1099R5; Clang 13. Class template argument deduction for aggregates; P1816R0; Clang 17. ; P2082R1. Class template argument deduction for alias templates; P1814R0; No. Permit conversions to arrays of unknown bound; P0388R4; Clang 14. constinit; P1143R2; Clang 10. Pseudo-destructors end object lifetimes; P0593R6 (DR); Clang 11. More implicit moves; P1825R0 (DR); Clang 13. (11): Prior to Clang 8, this feature is not enabled by; -std=c++20, but can be enabled with -fchar8_t. C++17 implementation status; Clang 5 and later implement all the features of the; ISO C++ 2017 standard.; By default, Clang 16 or later builds C++ code according to the C++17 standard.; You can use Clang in C++17 mode with the -std=c++17 option; (use -std=c++1z in Clang 4 and earlier). List of features and minimum Clang version with support. Language Feature; C++17 Proposal; Available in Clang?. static_assert with no message; N3928; Clang 3.5. Disabling trigraph expansion by default; N4086; Clang 3.5. typename in a template template parameter; N4051; Clang 3.5. New auto rules for direct-list-initialization; N3922; Clang 3.8 (8). Fold expressions; N4295; Clang 3.6. ; P0036R0; Clang 3.9. u8 character literals; N4267; Clang 3.6. Nested namespace definition; N4230; Clang 3.6. Attributes for namespaces and enumerators; N4266; Clang 3.6. Allow constant evaluation for all non-type template arguments; N4268; Clang 3.6. Remove deprecated register storage class; P0001R1; Clang 3.8. Remove deprecated bool increment; P0002R1; Clang 3.8. Make exception specifications part of the type system; P0012R1; Clang 4. __has_include in preprocessor conditionals; P0061R1; Yes. [[fallthrough]] attribute; P0188R1; Clang 3.9. [[nodiscard]] attribute; P0189R1; Clang 3.9. ; P1771R1 (DR); Clang 9. [[maybe_unused]] attribute; P0212R1; Clang 3.9. Aggregate initialization of classes with base classes; P0017R1; Clang 3.9. constexpr ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:10013,message,message,10013,interpreter/llvm-project/clang/www/cxx_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html,2,['message'],['message']
Integrability,"mba_ext``, after which further use is transparent and the same; as when otherwise using ``cppyy`` in Python.; Example:. .. code-block:: python. >>> import numba; >>> import cppyy; >>> import cppyy.numba_ext # enables numba to work with cppyy; >>> import math; >>> @numba.jit(nopython=True); ... def cpp_sqrt(x):; ... return cppyy.gbl.sqrt(x) # direct use, no extra setup required; >>> print(""Sqrt of 4: "", cpp_sqrt(4.0)); Sqrt of 4: 2.0; >>> print(""Sqrt of Pi: "", cpp_sqrt(math.pi)); Sqrt of Pi: 1.7724538509055159. - **Overload selection**: C++ overloads provide different implementations; for different argument types (not to be confused with Numba overloads,; which provide different implementations for the same argument types).; Unfortunately, mapping of Python types to C++ types is often not exact,; so a ""best match"" is chosen, similarly to what ``cppyy`` normally does.; However, the latter, being dynamic, is more flexible.; For example, best-match C++ integer type can be value dependent, whereas; in the Numba trace, it is by definition fixed at JIT time.; Example:. .. code-block:: python. >>> cppyy.cppdef(""""""; ... int mul(int x) { return x * 2; }; ... float mul(float x) { return x * 3; }; ... """"""); >>> @numba.jit(nopython=True); ... def oversel(a):; ... total = type(a[0])(0); ... for i in range(len(a)):; ... total += cppyy.gbl.mul(a[i]); ... return total. >>> a = np.array(range(10), dtype=np.float32); >>> print(""Array: "", a); Array: [0. 1. 2. 3. 4. 5. 6. 7. 8. 9.]; >>> print(""Overload selection output: "", oversel(a)); Overload selection output: 135.0; >>> a = np.array(range(10), dtype=np.int32); >>> print(""Array: "", a); Array: [0 1 2 3 4 5 6 7 8 9]; >>> print(""Overload selection output: "", oversel(a)); Overload selection output: 90. - **Template instantiation**: templates are instantiated as needed as part; of the overload selection.; The best match is done for the arguments provided at the point of first; use.; If those arguments vary based on program input, it may ma",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/numba.rst:4592,depend,dependent,4592,bindings/pyroot/cppyy/cppyy/doc/source/numba.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/numba.rst,1,['depend'],['dependent']
Integrability,mbiguous conversions; Not resolved. 1828; CD6; nested-name-specifier ambiguity; Unknown. 1829; CD6; Dependent unnamed types; Unknown. 1830; CD4; Repeated specifiers; Unknown. 1831; NAD; Explicitly vs implicitly deleted move constructors; Unknown. 1832; CD4; Casting to incomplete enumeration; Unknown. 1833; NAD; friend declarations naming implicitly-declared member functions; Unknown. 1834; CD4; Constant initialization binding a reference to an xvalue; Unknown. 1835; CD6; Dependent member lookup before <; Unknown. 1836; CD5; Use of class type being defined in trailing-return-type; Unknown. 1837; CD6; Use of this in friend and local class declarations; Clang 3.3. 1838; CD4; Definition via unqualified-id and using-declaration; Unknown. 1839; CD6; Lookup of block-scope extern declarations; Unknown. 1840; drafting; Non-deleted explicit specialization of deleted function template; Not resolved. 1841; CD6; < following template injected-class-name; Unknown. 1842; open; Unevaluated operands and “carries a dependency”; Not resolved. 1843; CD4; Bit-field in conditional operator with throw operand; Unknown. 1844; open; Defining “immediate context”; Not resolved. 1845; drafting; Point of instantiation of a variable template specialization; Not resolved. 1846; CD4; Declaring explicitly-defaulted implicitly-deleted functions; Unknown. 1847; CD4; Clarifying compatibility during partial ordering; Unknown. 1848; CD4; Parenthesized constructor and destructor declarators; Unknown. 1849; CD6; Variable templates and the ODR; Unknown. 1850; CD4; Differences between definition context and point of instantiation; Unknown. 1851; CD4; decltype(auto) in new-expressions; Unknown. 1852; CD4; Wording issues regarding decltype(auto); Unknown. 1853; dup; Defining “allocated storage”; Unknown. 1854; drafting; Disallowing use of implicitly-deleted functions; Not resolved. 1855; dup; Out-of-lifetime access to nonstatic data members; Unknown. 1856; open; Indirect nested classes of class templates; Not r,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:125112,depend,dependency,125112,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['depend'],['dependency']
Integrability,"me could figure out source file or function name to match; against the suppression.; * It is only possible to suppress recoverable checks. For the example above,; you can additionally pass; ``-fsanitize-recover=signed-integer-overflow,alignment,vptr``, although; most of UBSan checks are recoverable by default.; * Check groups (like ``undefined``) can't be used in suppressions file, only; fine-grained checks are supported. Supported Platforms; ===================. UndefinedBehaviorSanitizer is supported on the following operating systems:. * Android; * Linux; * NetBSD; * FreeBSD; * OpenBSD; * macOS; * Windows. The runtime library is relatively portable and platform independent. If the OS; you need is not listed above, UndefinedBehaviorSanitizer may already work for; it, or could be made to work with a minor porting effort. Current Status; ==============. UndefinedBehaviorSanitizer is available on selected platforms starting from LLVM; 3.3. The test suite is integrated into the CMake build and can be run with; ``check-ubsan`` command. Additional Configuration; ========================. UndefinedBehaviorSanitizer adds static check data for each check unless it is; in trap mode. This check data includes the full file name. The option; ``-fsanitize-undefined-strip-path-components=N`` can be used to trim this; information. If ``N`` is positive, file information emitted by; UndefinedBehaviorSanitizer will drop the first ``N`` components from the file; path. If ``N`` is negative, the last ``N`` components will be kept. Example; -------. For a file called ``/code/library/file.cpp``, here is what would be emitted:. * Default (No flag, or ``-fsanitize-undefined-strip-path-components=0``): ``/code/library/file.cpp``; * ``-fsanitize-undefined-strip-path-components=1``: ``code/library/file.cpp``; * ``-fsanitize-undefined-strip-path-components=2``: ``library/file.cpp``; * ``-fsanitize-undefined-strip-path-components=-1``: ``file.cpp``; * ``-fsanitize-undefined-strip-path-component",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:15978,integrat,integrated,15978,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,1,['integrat'],['integrated']
Integrability,"me library is relatively portable and platform independent. If the OS; you need is not listed above, UndefinedBehaviorSanitizer may already work for; it, or could be made to work with a minor porting effort. Current Status; ==============. UndefinedBehaviorSanitizer is available on selected platforms starting from LLVM; 3.3. The test suite is integrated into the CMake build and can be run with; ``check-ubsan`` command. Additional Configuration; ========================. UndefinedBehaviorSanitizer adds static check data for each check unless it is; in trap mode. This check data includes the full file name. The option; ``-fsanitize-undefined-strip-path-components=N`` can be used to trim this; information. If ``N`` is positive, file information emitted by; UndefinedBehaviorSanitizer will drop the first ``N`` components from the file; path. If ``N`` is negative, the last ``N`` components will be kept. Example; -------. For a file called ``/code/library/file.cpp``, here is what would be emitted:. * Default (No flag, or ``-fsanitize-undefined-strip-path-components=0``): ``/code/library/file.cpp``; * ``-fsanitize-undefined-strip-path-components=1``: ``code/library/file.cpp``; * ``-fsanitize-undefined-strip-path-components=2``: ``library/file.cpp``; * ``-fsanitize-undefined-strip-path-components=-1``: ``file.cpp``; * ``-fsanitize-undefined-strip-path-components=-2``: ``library/file.cpp``. More Information; ================. * From Oracle blog, including a discussion of error messages:; `Improving Application Security with UndefinedBehaviorSanitizer (UBSan) and GCC; <https://blogs.oracle.com/linux/improving-application-security-with-undefinedbehaviorsanitizer-ubsan-and-gcc>`_; * From LLVM project blog:; `What Every C Programmer Should Know About Undefined Behavior; <http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html>`_; * From John Regehr's *Embedded in Academia* blog:; `A Guide to Undefined Behavior in C and C++; <https://blog.regehr.org/archives/213>`_; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:17125,message,messages,17125,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,1,['message'],['messages']
Integrability,"me limits, cluster group summary encoding |; | Maximum number of pages per cluster per column | 4B | List frame limits |; | Maximum number of entries per cluster | 2^56 | Cluster summary encoding |; | Maximum string length (meta-data) | 4GB | String encoding |; | Maximum RBlob size | 128 PiB | 1GiB / 8B * 1GiB (with maxKeySize=1GiB, offsetSize=8B) |. ## Glossary. ### Anchor. The anchor is a data block that represents the entry point to an RNTuple.; The anchor is specific to the RNTuple container in which the RNTuple data are embedded (e.g., a ROOT file or an object store).; The anchor must provide the information to load the header and the footer **envelopes**. ### Cluster. A cluster is a set of **pages** that contain all the data belonging to an entry range.; The data set is partitioned in clusters.; A typical cluster size is tens to hundreds of megabytes. ### Column. A column is a storage backed vector of a number of **elements** of a simple type.; Column elements have a fixed bit-length that depends on the column type.; Some column types allow setting the bit lengths within specific limits (e.g. for floats with truncated mantissa). ### Envelope. An envelope is a data block with RNTuple meta-data, such as the header and the footer. ### Field. A field describes a serialized C++ type.; A field can have a hierarchy of subfields representing a composed C++ type (e.g., a vector of integers).; A field has zero, one, or multiple **columns** attached to it.; The columns contain the data related to the field but not to its subfields, which have their own columns. ### Frame. A frame is a byte range with metadata information in an **envelope**.; A frame starts with its size and thus can be extended in a forward-compatible way. ### Locator. A locator is a generalized way to identify a byte range in the RNTuple container.; For a file container, for instance, a locator consists of an offset and a size. ### Page. A page is segment of a column.; Columns are partitioned in pages.;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md:50592,depend,depends,50592,tree/ntuple/v7/doc/BinaryFormatSpecification.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md,1,['depend'],['depends']
Integrability,"me other cycle hierarchy ``T'``. This property allows compiler transforms to use the uniformity; analysis without being affected by DFS choices made in the underlying; cycle analysis. When two transforms use different instances of the; uniformity analysis for the same CFG, a ""divergent value"" result in; one analysis instance cannot contradict a ""uniform value"" result in; the other. Generic transforms such as SimplifyCFG, CSE, and loop transforms; commonly change the program in ways that change the maximal; converged-with relations. This also means that a value that was; previously uniform can become divergent after such a transform.; Uniformity has to be recomputed after such transforms. Divergent Branch inside a Cycle; -------------------------------. .. figure:: convergence-divergent-inside.png; :name: convergence-divergent-inside. The above figure shows a divergent branch ``Q`` inside an irreducible; cyclic region. When two threads diverge at ``Q``, the convergence of; dynamic instances within the cyclic region depends on the cycle; hierarchy chosen:. 1. In an implementation that detects a single cycle ``C`` with header; ``P``, convergence inside the cycle is determined by ``P``. 2. In an implementation that detects two nested cycles with headers; ``R`` and ``S``, convergence inside those cycles is determined by; their respective headers. .. _convergence-diverged-entry:. A conservative approach would be to simply report all nodes inside; irreducible cycles as having divergent outputs. But it is desirable to; recognize m-converged nodes in the CFG in order to maximize; uniformity. This section describes one such pattern of nodes derived; from *closed paths*, which are a property of the CFG and do not depend; on the cycle hierarchy. **Diverged Entry Criterion:**. The dynamic instances of all the nodes in a closed path ``P`` are; m-converged only if for every divergent branch ``B`` and its; join node ``J`` that lie on ``P``, there is no entry to ``P`` which; lies on ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst:21202,depend,depends,21202,interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,1,['depend'],['depends']
Integrability,"me we build will be very slow - Clang + LLVM is a lot of; code. But incremental builds are fast: ninja will only rebuild the parts; that have changed. When it finally finishes you should have a working; clang binary. Try running:. .. code:: console. $ bin/clang --version. There's also a target for building and running all the clang tests:. .. code:: console. $ ninja check-clang. This is a common pattern in LLVM: check-llvm is all the checks for core,; other projects have targets like check-lldb. Making changes; ==============. Edit; ----. We need to find the file containing the error message. .. code:: console. $ git grep ""all paths through this function"" ..; ../clang/include/clang/Basic/DiagnosticSemaKinds.td: ""all paths through this function will call itself"">,. The string that appears in DiagnosticSemaKinds.td is the one that is; printed by Clang. \*.td files define tables - in this case it's a list; of warnings and errors clang can emit and their messages. Let's update; the message in your favorite editor:. .. code:: console. $ vi ../clang/include/clang/Basic/DiagnosticSemaKinds.td. Find the message (it should be under; ``warn_infinite_recursive_function``). Change the message to ""in order to; understand recursion, you must first understand recursion"". Test again; ----------. To verify our change, we can build clang and manually check that it; works. .. code:: console. $ ninja clang; $ bin/clang -Wall ~/test.cc; /path/test.cc:1:124: warning: in order to understand recursion, you must; first understand recursion [-Winfinite-recursion]. We should also run the tests to make sure we didn't break something. .. code:: console. $ ninja check-clang. Notice that it is much faster to build this time, but the tests take; just as long to run. Ninja doesn't know which tests might be affected,; so it runs them all. .. code:: console. ********************; Testing Time: 408.84s; ********************; Failing Tests (1):; Clang :: SemaCXX/warn-infinite-recursion.cpp. Well, that ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst:5786,message,message,5786,interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,1,['message'],['message']
Integrability,"me()`. ## Core Libraries. - See ""Build, Configuration and Testing Infrastructure"" below for changes in the directory structure.; - libCling now exports only a minimal set of symbols.; - Add support for std::array_view also for C++11 builds. The implementation has been modified to work before C++14.; - Added TCollection::Notify to allow notifying more than one object.; ```{.cpp}; TList formulas;; // Add several TTreeFormula to the list;; chain.SetNotify(&formulas);; ```; - For classes that need the `ClassDef` support, `ClassDefInline(ClassName, Version)` now provides it without the need for a dictionary source: all members injected by this `ClassDef` flavor are generated by the interpreter. ### `TObjString` to `TString`. `TObjString::GetString()` now returns a `const TString&` to the `TString` inside the `TObjString`, instead of copying it.; This is to prevent very common misunderstanding of the interface. In several cases, the misunderstanding of the interface caused invalid memory accesses to the already destructed; temporary `TString` returned by `GetString()`, e.g. `objStr->GetString().Data()`. This will be fixed automatically by the; new return type. In rare cases, the caller expected `GetString()` to return a (non-const) reference to the embedded `TString`, e.g.; `objString->GetString().ReplaceAll(""a"", ""b""); // WRONG!` This will now fail to compile, instead of not doing what the author of the; code expected. Please fix that code by using the `TObjString::String()` interface, which returns a non-const `TString&`:; `objString->String().ReplaceAll(""a"", ""b"");`. In extremely rare cases, this change breaks a valid use where the temporary `TString` was modified and then captured in a new `TString`; object before the destruction of the temporary: `TString str = objStr->GetString().ReplaceAll(""a"", ""b"");`. In these rare cases,; please use the new function `CopyString()` which clearly indicates that it involves a temporary. ## Histogram Libraries. - New class `THnChain` w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md:3225,interface,interface,3225,README/ReleaseNotes/v610/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md,1,['interface'],['interface']
Integrability,"me; **`TCondition`** `MyCondition`, at `MyCondition.Broadcast()` all; threads waiting for `MyCondition` are activated at once. In some tests of `MyCondition` using an internal mutex, `Broadcast()`; activated only one thread (probably depending whether `MyCondition` had; been signaled before). - `MyCondition.TimedWait(secs,nanosecs)` waits for `MyCondition` until; the *absolute* time in seconds and nanoseconds since beginning of; the epoch (January, 1st, 1970) is reached; to use relative timeouts; ‘‘delta'', it is required to calculate the absolute time at the; beginning of waiting ‘‘now''; for example:. ``` {.cpp}; Ulong_t now,then,delta; // seconds; TDatime myTime; // root daytime class; myTime.Set(); // myTime set to ""now""; now=myTime.Convert(); // to seconds since 1970; ```. - Return value wait of `MyCondition.TimedWait` should be 0, if; `MyCondition.Signal()` was received, and should be nonzero, if; timeout was reached. The conditions example shows how three threaded functions are; synchronized using **`TCondition`**: a ROOT script `condstart.C` starts; the threads, which are defined in a shared library; (`conditions.cxx, conditions.h`). #### Xlib Connections. Usually `Xlib` is not thread safe. This means that calls to the X could; fail, when it receives X-messages from different threads. The actual; result depends strongly on which version of `Xlib` has been installed on; your system. The only thing we can do here within ROOT is calling a; special function `XInitThreads() `(which is part of the `Xlib`), which; should (!) prepare the `Xlib` for the usage with threads. To avoid further problems within ROOT some redefinition of the; ***`gPad`*** pointer was done (that's the main reason for the; recompilation). When a thread creates a **`TCanvas`**, this object is; actually created in the main thread; this should be transparent to the; user. Actions on the canvas are controlled via a function, which returns; a pointer to either thread specific data (TSD) or the mai",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:9794,synchroniz,synchronized,9794,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['synchroniz'],['synchronized']
Integrability,me_splitcoll_arrayview dataframe_splitcoll_arrayview.cxx LIBRARIES ROOTDataFrame); target_include_directories(dataframe_splitcoll_arrayview PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}); ROOT_GENERATE_DICTIONARY(TwoFloatsDict ${CMAKE_CURRENT_SOURCE_DIR}/TwoFloats.h MODULE dataframe_splitcoll_arrayview LINKDEF TwoFloatsLinkDef.h OPTIONS -inlineInputHeader DEPENDENCIES RIO). ROOT_ADD_GTEST(dataframe_redefine dataframe_redefine.cxx LIBRARIES ROOTDataFrame); ROOT_ADD_GTEST(dataframe_definepersample dataframe_definepersample.cxx LIBRARIES ROOTDataFrame). if(NOT MSVC OR win_broken_tests); ROOT_ADD_GTEST(dataframe_simple dataframe_simple.cxx LIBRARIES ROOTDataFrame GenVector); target_include_directories(dataframe_simple PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}); ROOT_GENERATE_DICTIONARY(DataFrameSimpleDict ${CMAKE_CURRENT_SOURCE_DIR}/MaxSlotHelper.h ${CMAKE_CURRENT_SOURCE_DIR}/SimpleFiller.h MODULE dataframe_simple; LINKDEF DataFrameSimpleLinkDef.h OPTIONS -inlineInputHeader DEPENDENCIES ROOTDataFrame Hist); endif(); ROOT_ADD_GTEST(dataframe_vecops dataframe_vecops.cxx LIBRARIES ROOTDataFrame); ROOT_ADD_GTEST(dataframe_helpers dataframe_helpers.cxx LIBRARIES ROOTDataFrame); if(MSVC); set_source_files_properties(dataframe_helpers.cxx PROPERTIES COMPILE_FLAGS /bigobj); set_source_files_properties(dataframe_cache.cxx PROPERTIES COMPILE_FLAGS /bigobj); endif(). if(NOT (MSVC OR (APPLE AND CMAKE_SYSTEM_PROCESSOR MATCHES arm64)) OR win_broken_tests OR M1_BROKEN_TESTS); ROOT_ADD_GTEST(dataframe_snapshot dataframe_snapshot.cxx LIBRARIES ROOTDataFrame); endif(). ROOT_ADD_GTEST(dataframe_datasetspec dataframe_datasetspec.cxx LIBRARIES ROOTDataFrame); if(builtin_nlohmannjson); target_include_directories(dataframe_datasetspec PRIVATE ${CMAKE_SOURCE_DIR}/builtins); else(); target_link_libraries(dataframe_datasetspec nlohmann_json::nlohmann_json); endif(). ROOT_ADD_GTEST(dataframe_display dataframe_display.cxx LIBRARIES ROOTDataFrame); ROOT_ADD_GTEST(dataframe_ranges dataframe_ranges.cxx LIBRARIES ROOT,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/CMakeLists.txt:2485,DEPEND,DEPENDENCIES,2485,tree/dataframe/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/CMakeLists.txt,1,['DEPEND'],['DEPENDENCIES']
Integrability,"me`` attribute to indicate that; it should be considered to be an object with precise lifetime semantics. .. admonition:: Rationale. Nonetheless, it is sometimes useful to be able to force an object to be; released at a precise time, even if that object does not appear to be used.; This is likely to be uncommon enough that the syntactic weight of explicitly; requesting these semantics will not be burdensome, and may even make the code; clearer. .. _arc.misc:. Miscellaneous; =============. .. _arc.misc.special_methods:. Special methods; ---------------. .. _arc.misc.special_methods.retain:. Memory management methods; ^^^^^^^^^^^^^^^^^^^^^^^^^. A program is ill-formed if it contains a method definition, message send, or; ``@selector`` expression for any of the following selectors:. * ``autorelease``; * ``release``; * ``retain``; * ``retainCount``. .. admonition:: Rationale. ``retainCount`` is banned because ARC robs it of consistent semantics. The; others were banned after weighing three options for how to deal with message; sends:. **Honoring** them would work out very poorly if a programmer naively or; accidentally tried to incorporate code written for manual retain/release code; into an ARC program. At best, such code would do twice as much work as; necessary; quite frequently, however, ARC and the explicit code would both; try to balance the same retain, leading to crashes. The cost is losing the; ability to perform ""unrooted"" retains, i.e. retains not logically; corresponding to a strong reference in the object graph. **Ignoring** them would badly violate user expectations about their code.; While it *would* make it easier to develop code simultaneously for ARC and; non-ARC, there is very little reason to do so except for certain library; developers. ARC and non-ARC translation units share an execution model and; can seamlessly interoperate. Within a translation unit, a developer who; faithfully maintains their code in non-ARC mode is suffering all the; restrictio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:85494,message,message,85494,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['message'],['message']
Integrability,"med objects. .. _arc.misc.autoreleasepool:. ``@autoreleasepool``; --------------------. To simplify the use of autorelease pools, and to bring them under the control; of the compiler, a new kind of statement is available in Objective-C. It is; written ``@autoreleasepool`` followed by a *compound-statement*, i.e. by a new; scope delimited by curly braces. Upon entry to this block, the current state; of the autorelease pool is captured. When the block is exited normally,; whether by fallthrough or directed control flow (such as ``return`` or; ``break``), the autorelease pool is restored to the saved state, releasing all; the objects in it. When the block is exited with an exception, the pool is not; drained. ``@autoreleasepool`` may be used in non-ARC translation units, with equivalent; semantics. A program is ill-formed if it refers to the ``NSAutoreleasePool`` class. .. admonition:: Rationale. Autorelease pools are clearly important for the compiler to reason about, but; it is far too much to expect the compiler to accurately reason about control; dependencies between two calls. It is also very easy to accidentally forget; to drain an autorelease pool when using the manual API, and this can; significantly inflate the process's high-water-mark. The introduction of a; new scope is unfortunate but basically required for sane interaction with the; rest of the language. Not draining the pool during an unwind is apparently; required by the Objective-C exceptions implementation. .. _arc.misc.externally_retained:. Externally-Retained Variables; -----------------------------. In some situations, variables with strong ownership are considered; externally-retained by the implementation. This means that the variable is; retained elsewhere, and therefore the implementation can elide retaining and; releasing its value. Such a variable is implicitly ``const`` for safety. In; contrast with ``__unsafe_unretained``, an externally-retained variable still; behaves as a strong variable o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:91482,depend,dependencies,91482,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['depend'],['dependencies']
Integrability,"memory. The instruction can also; be used to calculate a vector of such addresses. Arguments:; """""""""""""""""""". The first argument is always a type used as the basis for the calculations.; The second argument is always a pointer or a vector of pointers, and is the; base address to start from. The remaining arguments are indices; that indicate which of the elements of the aggregate object are indexed.; The interpretation of each index is dependent on the type being indexed; into. The first index always indexes the pointer value given as the; second argument, the second index indexes a value of the type pointed to; (not necessarily the value directly pointed to, since the first index; can be non-zero), etc. The first type indexed into must be a pointer; value, subsequent types can be arrays, vectors, and structs. Note that; subsequent types being indexed into can never be pointers, since that; would require loading the pointer before continuing calculation. The type of each index argument depends on the type it is indexing into.; When indexing into a (optionally packed) structure, only ``i32`` integer; **constants** are allowed (when using a vector of indices they must all; be the **same** ``i32`` integer constant). When indexing into an array,; pointer or vector, integers of any width are allowed, and they are not; required to be constant. These integers are treated as signed values; where relevant. For example, let's consider a C code fragment and how it gets compiled; to LLVM:. .. code-block:: c. struct RT {; char A;; int B[10][20];; char C;; };; struct ST {; int X;; double Y;; struct RT Z;; };. int *foo(struct ST *s) {; return &s[1].Z.B[5][13];; }. The LLVM code generated by Clang is approximately:. .. code-block:: llvm. %struct.RT = type { i8, [10 x [20 x i32]], i8 }; %struct.ST = type { i32, double, %struct.RT }. define ptr @foo(ptr %s) {; entry:; %arrayidx = getelementptr inbounds %struct.ST, ptr %s, i64 1, i32 2, i32 1, i64 5, i64 13; ret ptr %arrayidx; }. Semantics",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:433906,depend,depends,433906,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['depends']
Integrability,"ment ""axisg"" and ""haxisg"" to draw axes with grids; 7. Support TH1 marker, text and line drawing superimposed with ""haxis""; 8. Support `TBox`, `TLatex`, `TLine`, `TMarker` drawing on ""frame"", support drawing on swapped axes; 9. `TProfile` and `TProfile2D` projections https://github.com/root-project/root/issues/15851; 10. Draw total histogram from TEfficiency when draw option starts with 'b'; 11. Let redraw TEfficiency, THStack and TMultiGraph with different draw options via hist context menu; 12. Support 'pads' draw options for TMultiGraph, support context menu for it; 13. Let drop object on sub-pads; 14. Properly loads ES6 modules for web canvas; 15. Improve performance of TH3/RH3 drawing by using THREE.InstancedMesh; 16. Implement batch mode with '&batch' URL parameter to create SVG/PNG images with default GUI; 17. Adjust node.js implementation to produce identical output with normal browser; 18. Create necessary infrastructure for testing with 'puppeteer'; 19. Support inject of ES6 modules via '&inject=path.mjs'; 20. Using importmap for 'jsroot' in all major HTML files and in demos; 21. Implement `settings.CutAxisLabels` flag to remove labels which may exceed graphical range; 22. Let disable usage of TAxis custom labels via context menu; 23. Let configure default draw options via context menu, they can be preserved in the local storage; 24. Let save canvas as JSON file from context menu, object as JSON from inspector; 25. Upgrade three.js r162 -> r168, use r162 only in node.js because of ""gl"" module; 26. Create unified svg2pdf/jspdf ES6 modules, integrate in jsroot builds; 27. Let create multipage PDF document - in TWebCanvas batch mode; 28. Let add external links via `#url[link]{label}` syntax - including jsPDF support; 29. Support TAttMarker style with line width bigger than 1; 30. Internals - upgrade to eslint 9; 31. Internals - do not select pad (aka gPad) for objects drawing, always use assigned pad painter; 32. Fix - properly save zoomed ranges in drawingJSON",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:1333,inject,inject,1333,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,2,['inject'],['inject']
Integrability,"ment *elem,; Double_t weight);; void TGeoMixture::DefineElement(Int_t iel, Int_t z, Int_t natoms);; ~~~. or:. ~~~{.cpp}; void AddElement(TGeoMaterial* mat, Double_t weight);; void AddElement(TGeoElement* elem, Double_t weight);; void AddElement(TGeoElement* elem, Int_t natoms);; void AddElement(Double_t a, Double_t z, Double_t weight); ~~~. - `iel:` index of the element` [0,nel-1]`; - `a` and `z:` the atomic mass and charge; - `weight:` proportion by mass of the elements; - `natoms`: number of atoms of the element in the molecule making the; mixture. The radiation length is automatically computed when all elements are; defined. Since tracking MC provide several other ways to create; materials/mixtures, the materials classes are likely to evolve as the; interfaces to these engines are being developed. Generally in the; process of tracking material properties are not enough and more specific; media properties have to be defined. These highly depend on the MC; performing tracking and sometimes allow the definition of different; media properties (e.g. energy or range cuts) for the same material. \anchor GM00b; ### Radionuclides. A new class TGeoElementRN was introduced in this version to; provide support for radioactive nuclides and their decays. A database of; 3162 radionuclides can be loaded on demand via the table of elements; (TGeoElementTable class). One can make then materials/mixtures; based on these radionuclides and use them in a geometry. ~~~{.cpp}; root[] TGeoManager *geom = new TGeoManager(""geom"",""radionuclides"");; root[] TGeoElementTable *table = geom->GetElementTable();; root[] TGeoElementRN *c14 = table->GetElementRN(14,6); // A,Z; root[] c14->Print();; 6-C-014 ENDF=60140; A=14; Z=6; Iso=0; Level=0[MeV]; Dmass=3.0199[MeV];; Hlife=1.81e+11[s] J/P=0+; Abund=0; Htox=5.8e-10; Itox=5.8e-10; Stat=0; Decay modes:; BetaMinus Diso: 0 BR: 100.000% Qval: 0.1565; ~~~. One can make materials or mixtures from radionuclides:. ~~~{.cpp}; root[] TGeoMaterial *mat = new TGe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/materials.md:4758,depend,depend,4758,geom/geom/doc/materials.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/materials.md,1,['depend'],['depend']
Integrability,"mental, ; bottom-up [[3]] adoption of the modules feature. Modules in Clang are designed; to work for C, C++, ObjectiveC, ObjectiveC++ and Swift. Users can enable the; modules feature without modifications in header files. The LLVM compiler allows; users to specify module interfaces in dedicated file, called *module maps files*.; A module map file expresses the mapping between a module file and a collection; of header files. If the compiler finds such file in the include paths it; automatically generates, imports and uses module files. The module map files can; be mounted using the compiler's virtual file system overlay mechanism to; non-writable production library installations. In practice, a non-invasive *modularization* can be done easily by introducing; a module map file. ```cpp; // A.h ; int pow2(int x) {; return x * x;; }; ```; ```cpp; // B.cpp; #include ""A.h"" // clang rewires this to import A.; int main() {; return pow2(42);; }; ```. ```cpp; // A.h module interface, aka module map file; module A {; header ""A.h""; export * // clang exports the contents of A.h as part of module A.; }; ```. A.h defines *pow2*, the module map file instructs clang to create *A.pcm* and; import it in B.cpp. In a number of cases the module map files can be automatically generated if the; build system knows about the list of header files in every package. . ### Header parsing in ROOT. ```cpp; // A.h; #include <string>; #include <vector>; template <class T, class U = int> struct AStruct {; void doIt() { /*...*/ }; std::string Name; ; std::vector<U> Collection;; // ...; };. template<class T, class U = AStruct<T>>; inline void freeFunction() { /* ... */ }; inline void do(unsigned N = 1) { /* ... */ }. ``` ; The associated with libA header files form libA's full descriptor. A.h,; potentially only part of the descriptor of libA, expands to more than 26000; lines of code. ```cpp; // Main.cpp; #include ""A.h""; int main() {; do();; return 0;; }. ```; Main.cpp, reuses code from libA by includin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:3333,interface,interface,3333,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,1,['interface'],['interface']
Integrability,"mentioned in this array will be sorted last, in; stable order. Comments between attributes will leave the attributes; untouched. .. warning::. Using this option could lead to incorrect code formatting due to; clang-format's lack of complete semantic information. As such, extra; care should be taken to review code changes made by this option. .. code-block:: yaml. ObjCPropertyAttributeOrder: [; class, direct,; atomic, nonatomic,; assign, retain, strong, copy, weak, unsafe_unretained,; readonly, readwrite, getter, setter,; nullable, nonnull, null_resettable, null_unspecified; ]. .. _ObjCSpaceAfterProperty:. **ObjCSpaceAfterProperty** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <ObjCSpaceAfterProperty>`; Add a space after ``@property`` in Objective-C, i.e. use; ``@property (readonly)`` instead of ``@property(readonly)``. .. _ObjCSpaceBeforeProtocolList:. **ObjCSpaceBeforeProtocolList** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <ObjCSpaceBeforeProtocolList>`; Add a space in front of an Objective-C protocol list, i.e. use; ``Foo <Protocol>`` instead of ``Foo<Protocol>``. .. _PPIndentWidth:. **PPIndentWidth** (``Integer``) :versionbadge:`clang-format 13` :ref:`¶ <PPIndentWidth>`; The number of columns to use for indentation of preprocessor statements.; When set to -1 (default) ``IndentWidth`` is used also for preprocessor; statements. .. code-block:: c++. PPIndentWidth: 1. #ifdef __linux__; # define FOO; #else; # define BAR; #endif. .. _PackConstructorInitializers:. **PackConstructorInitializers** (``PackConstructorInitializersStyle``) :versionbadge:`clang-format 14` :ref:`¶ <PackConstructorInitializers>`; The pack constructor initializers style to use. Possible values:. * ``PCIS_Never`` (in configuration: ``Never``); Always put each constructor initializer on its own line. .. code-block:: c++. Constructor(); : a(),; b(). * ``PCIS_BinPack`` (in configuration: ``BinPack``); Bin-pack constructor initializers. .. code-block:: c++. Constructor(); : aaaa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:91496,protocol,protocol,91496,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['protocol'],['protocol']
Integrability,"ments for public APIs into the; header file. Documentation comments for private APIs can go to the; implementation file. In any case, implementation files can include additional; comments (not necessarily in Doxygen markup) to explain implementation details; as needed. Don't duplicate function or class name at the beginning of the comment.; For humans it is obvious which function or class is being documented;; automatic documentation processing tools are smart enough to bind the comment; to the correct declaration. Avoid:. .. code-block:: c++. // Example.h:. // example - Does something important.; void example();. // Example.cpp:. // example - Does something important.; void example() { ... }. Preferred:. .. code-block:: c++. // Example.h:. /// Does something important.; void example();. // Example.cpp:. /// Builds a B-tree in order to do foo. See paper by...; void example() { ... }. Error and Warning Messages; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Clear diagnostic messages are important to help users identify and fix issues in; their inputs. Use succinct but correct English prose that gives the user the; context needed to understand what went wrong. Also, to match error message; styles commonly produced by other tools, start the first sentence with a; lower-case letter, and finish the last sentence without a period, if it would; end in one otherwise. Sentences which end with different punctuation, such as; ""did you forget ';'?"", should still do so. For example this is a good error message:. .. code-block:: none. error: file.o: section header 3 is corrupt. Size is 10 when it should be 20. This is a bad message, since it does not provide useful information and uses the; wrong style:. .. code-block:: none. error: file.o: Corrupt section header. As with other coding standards, individual projects, such as the Clang Static; Analyzer, may have preexisting styles that do not conform to this. If a; different formatting scheme is used consistently throughout the project, use; that st",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:14040,message,messages,14040,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['message'],['messages']
Integrability,"merations. **Output**: Enums, globals, local tables for sub-target information. **Usage**: Populates ``<Target>Subtarget`` and; ``MCTargetDesc/<Target>MCTargetDesc`` files (both headers and source). Intrinsic; ---------. **Purpose**: Generate (target) intrinsic information. OptParserDefs; -------------. **Purpose**: Print enum values for a class. SearchableTables; ----------------. **Purpose**: Generate custom searchable tables. **Output**: Enums, global tables, and lookup helper functions. **Usage**: This backend allows generating free-form, target-specific tables; from TableGen records. The ARM and AArch64 targets use this backend to generate; tables of system registers; the AMDGPU target uses it to generate meta-data; about complex image and memory buffer instructions. See `SearchableTables Reference`_ for a detailed description. CTags; -----. **Purpose**: This tablegen backend emits an index of definitions in ctags(1); format. A helper script, utils/TableGen/tdtags, provides an easier-to-use; interface; run 'tdtags -H' for documentation. X86EVEX2VEX; -----------. **Purpose**: This X86 specific tablegen backend emits tables that map EVEX; encoded instructions to their VEX encoded identical instruction. Clang BackEnds; ==============. ClangAttrClasses; ----------------. **Purpose**: Creates Attrs.inc, which contains semantic attribute class; declarations for any attribute in ``Attr.td`` that has not set ``ASTNode = 0``.; This file is included as part of ``Attr.h``. ClangAttrParserStringSwitches; -----------------------------. **Purpose**: Creates AttrParserStringSwitches.inc, which contains; StringSwitch::Case statements for parser-related string switches. Each switch; is given its own macro (such as ``CLANG_ATTR_ARG_CONTEXT_LIST``, or; ``CLANG_ATTR_IDENTIFIER_ARG_LIST``), which is expected to be defined before; including AttrParserStringSwitches.inc, and undefined after. ClangAttrImpl; -------------. **Purpose**: Creates AttrImpl.inc, which contains semantic attri",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst:8795,interface,interface,8795,interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst,1,['interface'],['interface']
Integrability,"meter dimensions; in addition to the automatically determined set of observables.; as well. Also a complete new line of classes with similar functionality has been added inheriting from RooAbsReal.; These are RooAbsCachedReal,RooAbsSelfCachedReal and RooCachedReal. A newly; added class RooHistFunc presents these shapes and is capable of handling negative entries. New PDF error handling structure. New infrastructure has been put into place to propagate and process p.d.f evaluation errors during fitting.; Previously evaluation errors were marked with a zero p.d.f value and propagated as a special condition; in RooAddPdf, RooProdPdf etc to result in a zero top-level p.d.f value that was caught by the RooFit minuit; interface as a special condition. Summary information on the value of the parameters and the observables; was printed for the first 10 occurrences of such conditions. . Now, each p.d.f component that generates an error; in its evaluation logs the error into a separate facility during fitting and the RooFit minuit interface; polls this error logging facility for problems. This allows much more detailed and accurate warning messages; during the minimization phase. The level of verbosity of this new error facility can be controlled with; a new . PrintEvalErrors(Int_t code). argument to fitTo(). . With code of -1, no errors are printed at all.; With a; code of zero, one line is printed for each p.d.f component with problems summarizing the number of times; problems occurred during the likelihood evaluation. . [#0] WARNING:Minization -- RooFitGlue: Minimized function has error status. ; Returning maximum FCN so far (-1e+30) to force MIGRAD to back out of this region. Error log follows; Parameter values: m=-7.397; RooGaussian::gx[ x=x mean=m sigma=sx ] has 3 errors. A code greater than zero will generate even more detail and; print the details of each evaluation error as provided by the p.d.f (zero value, not-a-number, normalization zero etc..); and show the obser",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html:15651,interface,interface,15651,roofit/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html,2,['interface'],['interface']
Integrability,"meters. A function can also return an object to a caller by a means of an out parameter; (a pointer-to-OSObject-pointer is passed, and a callee writes a pointer to an; object into an argument).; Currently the analyzer does not track unannotated out; parameters by default, but with annotations we distinguish four separate cases:. 1. Non-retained out parameters, identified using; LIBKERN_RETURNS_NOT_RETAINED applied to parameters, e.g.:. void getterViaOutParam(LIBKERN_RETURNS_NOT_RETAINED OSObject **obj). Such functions write a non-retained object into an out parameter, and the; caller has no further obligations.; 2. Retained out parameters,; identified using LIBKERN_RETURNS_RETAINED:. void getterViaOutParam(LIBKERN_RETURNS_NOT_RETAINED OSObject **obj). In such cases a retained object is written into an out parameter, which the caller has then to release in order to avoid a leak. These two cases are simple - but in practice a functions returning an out-parameter usually also return a return code, and then an out parameter may or may not be written, which conditionally depends on the exit code, e.g.:. bool maybeCreateObject(LIBKERN_RETURNS_RETAINED OSObject **obj);. For such functions, the usual semantics is that an object is written into on ""success"", and not written into on ""failure"".; For LIBKERN_RETURNS_RETAINED we assume the following definition of; success:; For functions returning OSReturn or IOReturn; (any typedef to kern_return_t) success is defined as having an output of zero (kIOReturnSuccess is zero).; For all others, success is non-zero (e.g. non-nullptr for pointers); 3. Retained out parameters on zero return; The annotation LIBKERN_RETURNS_RETAINED_ON_ZERO states; that a retained object is written into if and only if the function returns a zero value:. bool OSUnserializeXML(void *data, LIBKERN_RETURNS_RETAINED_ON_ZERO OSString **errString);. Then the caller has to release an object if the function has returned zero.; 4. Retained out parameters on non-zero",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:18330,depend,depends,18330,interpreter/llvm-project/clang/www/analyzer/annotations.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html,2,['depend'],['depends']
Integrability,method UpperLimit returns to the user the upper limit value. The HypoTestInverter implements various option for performing the scan. HypoTestInverter::RunFixedScan will scan using a fixed grid the parameter of interest. HypoTestInverter::RunAutoScan will perform an automatic scan to find optimally the curve and it will stop when the desired precision is obtained.; The confidence level value at a given point can also be done via HypoTestInverter::RunOnePoint.; The class can scan the CLs+b values (default) or alternatively CLs (if the; method HypoTestInverter::UseCLs has been called).; The estimated error due to the MC toys statistics from the HybridCalculator is propagated into the limits obtained from the HypoTestResult; A new tutorial rs801_HypoTestInverter.C has been added in the tutorials/roostats directory to show the usage of this class. New class BayesianCalculator. New class for calculating Bayesian interval using numerical integration. It implements the IntervalCalculator interface and returns as result a SimpleInterval. . The BayesianCalculator::GetInterval() method returns a SimpleInterval which contains the lower and upper value of the bayesian interval obtained from the posterior probability for the given confidence level.; The class return also the posterior pdf (BayesianCalculator::GetPosteriorPdf()) obtained from integrating (marginalizing) on the nuisance parameters.; It works currently only for one-dimensional problems by relying on RooFit for performing analytical or numerical integration.; A plot of the posterior and the desired interval can be obtained using BayesianCalculator::GetPosteriorPlot().; A new tutorial rs701_BayesianCalculator.C has been added in the tutorials/roostats directory to show the usage of this class. MCMCCalculator. Add possibility to specify the prior function in the constructor of the class to have a signature similar to the BayesianCalculator class. When no prior is specified it is assumed is part of the global model (pdf),MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html:16059,interface,interface,16059,roofit/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html,2,['interface'],['interface']
Integrability,"me} ${component}); list(APPEND ${name}_extra_targets ${component}-${name}); endforeach(). foreach(target IN LISTS SUB_INSTALL_TARGETS); set(${target}-${name} ${target}); set(${target}-${name}-stripped ${target}-stripped); list(APPEND ${name}_extra_targets ${target}-${name} ${target}-${name}-stripped); endforeach(). foreach(component ${LLVM_RUNTIME_DISTRIBUTION_COMPONENTS}); if(NOT component IN_LIST SUB_COMPONENTS); set(${component}-${name} ${component}); set(install-${component}-${name} install-${component}); set(install-${component}-${name}-stripped install-${component}-stripped); list(APPEND ${name}_extra_targets ${component}-${name} install-${component}-${name} install-${component}-${name}-stripped); endif(); endforeach(). if(LLVM_INCLUDE_TESTS); set_property(GLOBAL APPEND PROPERTY LLVM_ALL_LIT_TESTSUITES ""@${LLVM_BINARY_DIR}/runtimes/runtimes-${name}-bins/lit.tests""); set(runtimes-test-depends-${name} runtimes-test-depends); set(check-runtimes-${name} check-runtimes); list(APPEND ${name}_test_targets runtimes-test-depends-${name} check-runtimes-${name}); list(APPEND test_targets ${${name}_test_targets}). set(component_check_targets); foreach(component IN LISTS LLVM_RUNTIME_DISTRIBUTION_COMPONENTS); if(NOT ""check-${component}"" IN_LIST SUB_CHECK_TARGETS); list(APPEND component_check_targets ""check-${component}""); endif(); endforeach(). foreach(target IN LISTS SUB_CHECK_TARGETS component_check_targets); set(${target}-${name} ${target}); list(APPEND ${name}_test_targets ${target}-${name}); list(APPEND test_targets ${target}-${name}); endforeach(); set(test_targets ""${test_targets}"" PARENT_SCOPE); endif(). set(${name}_extra_args ${ARG_CMAKE_ARGS}); string(REPLACE "";"" ""|"" LLVM_ENABLE_RUNTIMES_PASSTHROUGH ""${LLVM_ENABLE_RUNTIMES}""); list(APPEND ${name}_extra_args -DLLVM_ENABLE_RUNTIMES=${LLVM_ENABLE_RUNTIMES_PASSTHROUGH}); list(APPEND ${name}_extra_args -DLLVM_USE_LINKER=${LLVM_USE_LINKER}). get_cmake_property(variable_names VARIABLES); foreach(extra_name IN ITEMS ${ARG",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/runtimes/CMakeLists.txt:11555,depend,depends,11555,interpreter/llvm-project/llvm/runtimes/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/runtimes/CMakeLists.txt,3,['depend'],['depends']
Integrability,"milar to how; MCJIT is commonly used). However ORC also provides built-in support for lazy; compilation via lazy-reexports (see :ref:`Laziness`). **Support for Custom Compilers and Program Representations**; Clients can supply custom compilers for each symbol that they define in their; JIT session. ORC will run the user-supplied compiler when the a definition of; a symbol is needed. ORC is actually fully language agnostic: LLVM IR is not; treated specially, and is supported via the same wrapper mechanism (the; ``MaterializationUnit`` class) that is used for custom compilers. **Concurrent JIT'd code** and **Concurrent Compilation**; JIT'd code may be executed in multiple threads, may spawn new threads, and may; re-enter the ORC (e.g. to request lazy compilation) concurrently from multiple; threads. Compilers launched my ORC can run concurrently (provided the client; sets up an appropriate dispatcher). Built-in dependency tracking ensures that; ORC does not release pointers to JIT'd code or data until all dependencies; have also been JIT'd and they are safe to call or use. **Removable Code**; Resources for JIT'd program representations. **Orthogonality** and **Composability**; Each of the features above can be used independently. It is possible to put; ORC components together to make a non-lazy, in-process, single threaded JIT; or a lazy, out-of-process, concurrent JIT, or anything in between. LLJIT and LLLazyJIT; ===================. ORC provides two basic JIT classes off-the-shelf. These are useful both as; examples of how to assemble ORC components to make a JIT, and as replacements; for earlier LLVM JIT APIs (e.g. MCJIT). The LLJIT class uses an IRCompileLayer and RTDyldObjectLinkingLayer to support; compilation of LLVM IR and linking of relocatable object files. All operations; are performed eagerly on symbol lookup (i.e. a symbol's definition is compiled; as soon as you attempt to look up its address). LLJIT is a suitable replacement; for MCJIT in most cases (no",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:3064,depend,dependency,3064,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,2,['depend'],"['dependencies', 'dependency']"
Integrability,"mirroring our current SVN; repository.; 3. Add the required bots to implement the commit emails, as well as the; umbrella repository update (if the multirepo is selected) or the read-only; Git views for the sub-projects (if the monorepo is selected). Step #2 : Git Move; ------------------. 4. Update the buildbots to pick up updates and commits from the GitHub; repository. Not all bots have to migrate at this point, but it'll help; provide infrastructure testing.; 5. Update Phabricator to pick up commits from the GitHub repository.; 6. LNT and llvmlab have to be updated: they rely on unique monotonically; increasing integer across branch [MatthewsRevNum]_.; 7. Instruct downstream integrators to pick up commits from the GitHub; repository.; 8. Review and prepare an update for the LLVM documentation. Until this point nothing has changed for developers, it will just; boil down to a lot of work for buildbot and other infrastructure; owners. The migration will pause here until all dependencies have cleared, and all; problems have been solved. Step #3: Write Access Move; --------------------------. 9. Collect developers' GitHub account information, and add them to the project.; 10. Switch the SVN repository to read-only and allow pushes to the GitHub repository.; 11. Update the documentation.; 12. Mirror Git to SVN. Step #4 : Post Move; -------------------. 13. Archive the SVN repository.; 14. Update links on the LLVM website pointing to viewvc/klaus/phab etc. to; point to GitHub instead. GitHub Repository Description; =============================. Monorepo; ----------------. The LLVM git repository hosted at https://github.com/llvm/llvm-project contains all; sub-projects in a single source tree. It is often referred to as a monorepo and; mimics an export of the current SVN repository, with each sub-project having its; own top-level directory. Not all sub-projects are used for building toolchains.; For example, www/ and test-suite/ are not part of the monorepo. Putting all",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:7821,depend,dependencies,7821,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['depend'],['dependencies']
Integrability,"mization package.; These new version provides basically all the functionality present in the old Fortran version,; with almost equivalent numerical accuracy and computational performances.; Furthermore, it contains new functionality, like the possibility to set single side parameter limits or; the FUMILI algorithm, which is an optimized method for least square and log likelihood minimizations.; The package has been originally developed by M. Winkler and F. James.; More information on the new C++ version can be found on the; MINUIT Web Site. Minuit2, originally developed in the SEAL project, is now distributed within %ROOT.; The API has been then changed in this new version to follow the %ROOT coding convention (function names starting with capital letters) and the classes have been moved inside the namespace ROOT::Minuit2.; In addition, the %ROOT distribution contains classes needed to integrate Minuit2 in the %ROOT framework. A new class has been introduced, ROOT::Minuit2::Minuit2Minimizer, which implements the interface; ROOT::Math::Minimizer. Within %ROOT, it can be instantiates also using the %ROOT plug-in manager. This class provides a convenient entry point for using Minuit2. An example of using this interface is; the %ROOT tutorial tutorials/fit/NumericalMinimization.C or; the Minuit2 test program testMinimize.cxx. A standalone version of Minuit2 (independent of %ROOT) can be downloaded from here. It does not contain the %ROOT interface and it is therefore totally independent of external packages and can be simply build using the configure script and then make. Example tests are provided in the directory test/MnSim and test/MnTutorial and they can be built with the make check command. The Minuit2 User Guide provides all the information needed for using directly (without add-on packages like %ROOT) Minuit2. References. F. James, Fortran MINUIT Reference Manual (html);; F. James and M. Winkler, C++ MINUIT User's Guide (html and; pdf);; F. James, Minuit Tutorial ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/doc/Minuit2.html:1200,interface,interface,1200,math/minuit2/doc/Minuit2.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/doc/Minuit2.html,2,['interface'],['interface']
Integrability,mmediate substatement. - Fixed an issue that a benign assertion might hit when instantiating a pack expansion; inside a lambda. (`#61460 <https://github.com/llvm/llvm-project/issues/61460>`_); - Fix crash during instantiation of some class template specializations within class; templates. Fixes (`#70375 <https://github.com/llvm/llvm-project/issues/70375>`_); - Fix crash during code generation of C++ coroutine initial suspend when the return; type of await_resume is not trivially destructible.; Fixes (`#63803 <https://github.com/llvm/llvm-project/issues/63803>`_); - ``__is_trivially_relocatable`` no longer returns true for non-object types; such as references and functions.; Fixes (`#67498 <https://github.com/llvm/llvm-project/issues/67498>`_); - Fix crash when the object used as a ``static_assert`` message has ``size`` or ``data`` members; which are not member functions.; - Support UDLs in ``static_assert`` message.; - Fixed false positive error emitted by clang when performing qualified name; lookup and the current class instantiation has dependent bases.; Fixes (`#13826 <https://github.com/llvm/llvm-project/issues/13826>`_); - Fix a ``clang-17`` regression where a templated friend with constraints is not; properly applied when its parameters reference an enclosing non-template class.; Fixes (`#71595 <https://github.com/llvm/llvm-project/issues/71595>`_); - Fix the name of the ifunc symbol emitted for multiversion functions declared with the; ``target_clones`` attribute. This addresses a linker error that would otherwise occur; when these functions are referenced from other TUs.; - Fixes compile error that double colon operator cannot resolve macro with parentheses.; Fixes (`#64467 <https://github.com/llvm/llvm-project/issues/64467>`_); - Clang's ``-Wchar-subscripts`` no longer warns on chars whose values are known non-negative constants.; Fixes (`#18763 <https://github.com/llvm/llvm-project/issues/18763>`_); - Fix crash due to incorrectly allowing conversion functi,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:41386,depend,dependent,41386,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['depend'],['dependent']
Integrability,"mment; that should be included at the top of every output file. A call to it is; included in the skeleton backend file ``TableGenBackendSkeleton.cpp``. Printing Error Messages; =======================. TableGen records are often derived from multiple classes and also often; defined through a sequence of multiclasses. Because of this, it can be; difficult for backends to report clear error messages with accurate source; file locations. To make error reporting easier, five error reporting; functions are provided, each with four overloads. * ``PrintWarning`` prints a message tagged as a warning. * ``PrintError`` prints a message tagged as an error. * ``PrintFatalError`` prints a message tagged as an error and then terminates. * ``PrintNote`` prints a note. It is often used after one of the previous; functions to provide more information. * ``PrintFatalNote`` prints a note and then terminates. Each of these five functions is overloaded four times. * ``PrintError(const Twine &Msg)``:; Prints the message with no source file location. * ``PrintError(ArrayRef<SMLoc> ErrorLoc, const Twine &Msg)``:; Prints the message followed by the specified source line,; along with a pointer to the item in error. The array of; source file locations is typically taken from a ``Record`` instance. * ``PrintError(const Record *Rec, const Twine &Msg)``:; Prints the message followed by the source line associated with the; specified record (see `Record`_). * ``PrintError(const RecordVal *RecVal, const Twine &Msg)``:; Prints the message followed by the source line associated with the; specified record field (see `RecordVal`_). Using these functions, the goal is to produce the most specific error report; possible. Debugging Tools; ===============. TableGen provides some tools to aid in debugging backends. The ``PrintRecords`` Backend; ----------------------------. The TableGen command option ``--print-records`` invokes a simple backend; that prints all the classes and records defined in the source ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst:24364,message,message,24364,interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,1,['message'],['message']
Integrability,"model. .. code-block:: c. int g;. void foo(int *__counted_by(count) p, size_t count) {; count++; // may violate the invariant of __counted_by; count--; // may violate the invariant of __counted_by if count was 0.; count = g; // may violate the invariant of __counted_by; // depending on the value of `g`.; }. The requirement to annotate all pointers with explicit bounds information could; present a significant adoption burden. To tackle this issue, the model; incorporates the concept of a ""wide pointer"" (a.k.a. fat pointer) – a larger; pointer that carries bounds information alongside the pointer value. Utilizing; wide pointers can potentially reduce the adoption burden, as it contains bounds; information internally and eliminates the need for explicit bounds annotations.; However, wide pointers differ from standard C pointers in their data layout,; which may result in incompatibilities with the application binary interface; (ABI). Breaking the ABI complicates interoperability with external code that has; not adopted the same programming model. ``-fbounds-safety`` harmonizes the wide pointer and the bounds annotation; approaches to reduce the adoption burden while maintaining the ABI. In this; model, local variables of pointer type are implicitly treated as wide pointers,; allowing them to carry bounds information without requiring explicit bounds; annotations. Please note that this approach doesn't apply to function parameters; which are considered ABI-visible. As local variables are typically hidden from; the ABI, this approach has a marginal impact on it. In addition,; ``-fbounds-safety`` employs compile-time restrictions to prevent implicit wide; pointers from silently breaking the ABI (see `ABI implications of default bounds; annotations`_). Pointers associated with any other variables, including function; parameters, are treated as single object pointers (i.e., ``__single``), ensuring; that they always have the tightest bounds by default and offering a strong; bo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:5664,interoperab,interoperability,5664,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['interoperab'],['interoperability']
Integrability,"mon-lisp. (load ""<path-to-clang>/tools/clang-format/clang-format.el""); (global-set-key [C-M-tab] 'clang-format-region). This binds the function `clang-format-region` to C-M-tab, which then formats the; current line or selected region. BBEdit Integration; ==================. :program:`clang-format` cannot be used as a text filter with BBEdit, but works; well via a script. The AppleScript to do this integration can be found at; `clang/tools/clang-format/clang-format-bbedit.applescript`; place a copy in; `~/Library/Application Support/BBEdit/Scripts`, and edit the path within it to; point to your local copy of :program:`clang-format`. With this integration you can select the script from the Script menu and; :program:`clang-format` will format the selection. Note that you can rename the; menu item by renaming the script, and can assign the menu item a keyboard; shortcut in the BBEdit preferences, under Menus & Shortcuts. CLion Integration; =================. :program:`clang-format` is integrated into `CLion <https://www.jetbrains; .com/clion/>`_ as an alternative code formatter. CLion turns it on; automatically when there is a ``.clang-format`` file under the project root.; Code style rules are applied as you type, including indentation,; auto-completion, code generation, and refactorings. :program:`clang-format` can also be enabled without a ``.clang-format`` file.; In this case, CLion prompts you to create one based on the current IDE settings; or the default LLVM style. Visual Studio Integration; =========================. Download the latest Visual Studio extension from the `alpha build site; <https://llvm.org/builds/>`_. The default key-binding is Ctrl-R,Ctrl-F. Visual Studio Code Integration; ==============================. Get the latest Visual Studio Code extension from the `Visual Studio Marketplace <https://marketplace.visualstudio.com/items?itemName=xaver.clang-format>`_. The default key-binding is Alt-Shift-F. Git integration; ===============. The script `cl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst:9215,integrat,integrated,9215,interpreter/llvm-project/clang/docs/ClangFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst,1,['integrat'],['integrated']
Integrability,"mory; checking and interface for shared memory (optional). - `libPhysics` contains the legacy physics classes (TLorentzVector,; etc.). - `libPostscript` is the PostScript interface. - `libProof` is the parallel ROOT Facility classes. - `libPython` provides the interface to Python. - \*`libRFIO` is the interface to CERN RFIO remote I/O system. - \*`libRGL` is the interface to OpenGL. - `libReflex` is the runtime type database library used by Cling. - `libRint` is the interactive interface to ROOT (provides command; prompt). - `libRIO` provides the functionality to write and read objects to; and from ROOT files. - `libRooFit` is the RooFit fitting framework. - `libRuby` is the interface to Ruby. - `libSpectrum` provides functionality for spectral analysis. - \*`libThread` is the interface to TThread classes. - `libTMVA` contains the multivariate analysis toolkit. - `libTree` is the TTree object container system. - `libTreePlayer` is the TTree drawing classes. - `libTreeViewer` is the graphical TTree query interface. #### Library Dependencies. ![ROOT libraries dependencies](pictures/03000005.png). The libraries are designed and organized to minimize dependencies,; such that you can load just enough code for the task at hand rather; than having to load all libraries or one monolithic chunk. The core; library (`libCore.so`) contains the essentials; it is a part of all; ROOT applications. In the Figure 1-2 you see that libCore.so is made; up of base classes, container classes, meta information classes,; operating system specific classes, and the ZIP algorithm used for; compression of the ROOT files. The Cling library (`libCling.so`) is also needed in all ROOT; applications, and even by `libCore`. A; program referencing only **`TObject`** only needs `libCore`;; `libCling` will be opened automatically. To add the ability to read and write; ROOT objects one also has to load `libRIO`. As one would expect, none of that; depends on graphics or the GUI. Library dependencies have",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:15928,interface,interface,15928,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['interface'],['interface']
Integrability,"most calls and prevents constant-folding when the result is not exactly representable. .. option:: -ffp-model=<value>. Specify floating point behavior. ``-ffp-model`` is an umbrella; option that encompasses functionality provided by other, single; purpose, floating point options. Valid values are: ``precise``, ``strict``,; and ``fast``.; Details:. * ``precise`` Disables optimizations that are not value-safe on; floating-point data, although FP contraction (FMA) is enabled; (``-ffp-contract=on``). This is the default behavior. This value resets; ``-fmath-errno`` to its target-dependent default.; * ``strict`` Enables ``-frounding-math`` and; ``-ffp-exception-behavior=strict``, and disables contractions (FMA). All; of the ``-ffast-math`` enablements are disabled. Enables; ``STDC FENV_ACCESS``: by default ``FENV_ACCESS`` is disabled. This option; setting behaves as though ``#pragma STDC FENV_ACCESS ON`` appeared at the; top of the source file.; * ``fast`` Behaves identically to specifying both ``-ffast-math`` and; ``ffp-contract=fast``. Note: If your command line specifies multiple instances; of the ``-ffp-model`` option, or if your command line option specifies; ``-ffp-model`` and later on the command line selects a floating point; option that has the effect of negating part of the ``ffp-model`` that; has been selected, then the compiler will issue a diagnostic warning; that the override has occurred. .. option:: -ffp-exception-behavior=<value>. Specify the floating-point exception behavior. Valid values are: ``ignore``, ``maytrap``, and ``strict``.; The default value is ``ignore``. Details:. * ``ignore`` The compiler assumes that the exception status flags will not be read and that floating point exceptions will be masked.; * ``maytrap`` The compiler avoids transformations that may raise exceptions that would not have been raised by the original code. Constant folding performed by the compiler is exempt from this option.; * ``strict`` The compiler ensures that all tran",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:63019,contract,contract,63019,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['contract'],['contract']
Integrability,"move(M), Ctx)));; }. Expected<ExecutorSymbolDef> lookup(StringRef Name) {; return ES.lookup({&ES.getMainJITDylib()}, Mangle(Name.str()));; }. Now we come to the first of our JIT API methods: addModule. This method is; responsible for adding IR to the JIT and making it available for execution. In; this initial implementation of our JIT we will make our modules ""available for; execution"" by adding them to the CompileLayer, which will it turn store the; Module in the main JITDylib. This process will create new symbol table entries; in the JITDylib for each definition in the module, and will defer compilation of; the module until any of its definitions is looked up. Note that this is not lazy; compilation: just referencing a definition, even if it is never used, will be; enough to trigger compilation. In later chapters we will teach our JIT to defer; compilation of functions until they're actually called. To add our Module we; must first wrap it in a ThreadSafeModule instance, which manages the lifetime of; the Module's LLVMContext (our Ctx member) in a thread-friendly way. In our; example, all modules will share the Ctx member, which will exist for the; duration of the JIT. Once we switch to concurrent compilation in later chapters; we will use a new context per module. Our last method is ``lookup``, which allows us to look up addresses for; function and variable definitions added to the JIT based on their symbol names.; As noted above, lookup will implicitly trigger compilation for any symbol; that has not already been compiled. Our lookup method calls through to; `ExecutionSession::lookup`, passing in a list of dylibs to search (in our case; just the main dylib), and the symbol name to search for, with a twist: We have; to *mangle* the name of the symbol we're searching for first. The ORC JIT; components use mangled symbols internally the same way a static compiler and; linker would, rather than using plain IR symbol names. This allows JIT'd code; to interoperate eas",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst:11049,wrap,wrap,11049,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,1,['wrap'],['wrap']
Integrability,"mpatible with Visual; C++ exceptions and general purpose Windows exception handling. Because the C++; exception object lives in stack memory, LLVM cannot provide a custom personality; function that uses landingpads. Similarly, SEH does not provide any mechanism; to rethrow an exception or continue unwinding. Therefore, LLVM must use the IR; constructs described later in this document to implement compatible exception; handling. SEH filter expressions; -----------------------. The SEH personality functions also use funclets to implement filter expressions,; which allow executing arbitrary user code to decide which exceptions to catch.; Filter expressions should not be confused with the ``filter`` clause of the LLVM; ``landingpad`` instruction. Typically filter expressions are used to determine; if the exception came from a particular DLL or code region, or if code faulted; while accessing a particular memory address range. LLVM does not currently have; IR to represent filter expressions because it is difficult to represent their; control dependencies. Filter expressions run during the first phase of EH,; before cleanups run, making it very difficult to build a faithful control flow; graph. For now, the new EH instructions cannot represent SEH filter; expressions, and frontends must outline them ahead of time. Local variables of; the parent function can be escaped and accessed using the ``llvm.localescape``; and ``llvm.localrecover`` intrinsics. New exception handling instructions; ------------------------------------. The primary design goal of the new EH instructions is to support funclet; generation while preserving information about the CFG so that SSA formation; still works. As a secondary goal, they are designed to be generic across MSVC; and Itanium C++ exceptions. They make very few assumptions about the data; required by the personality, so long as it uses the familiar core EH actions:; catch, cleanup, and terminate. However, the new instructions are hard to m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst:24460,depend,dependencies,24460,interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,1,['depend'],['dependencies']
Integrability,"mport declaration have no impact on the API provided by ``std.io``, because the module itself was compiled as a separate, standalone module. Additionally, any linker flags required to use the ``std.io`` module will automatically be provided when the module is imported [#]_; This semantic import model addresses many of the problems of the preprocessor inclusion model:. * **Compile-time scalability**: The ``std.io`` module is only compiled once, and importing the module into a translation unit is a constant-time operation (independent of module system). Thus, the API of each software library is only parsed once, reducing the *M x N* compilation problem to an *M + N* problem. * **Fragility**: Each module is parsed as a standalone entity, so it has a consistent preprocessor environment. This completely eliminates the need for ``__underscored`` names and similarly defensive tricks. Moreover, the current preprocessor definitions when an import declaration is encountered are ignored, so one software library can not affect how another software library is compiled, eliminating include-order dependencies. * **Tool confusion**: Modules describe the API of software libraries, and tools can reason about and present a module as a representation of that API. Because modules can only be built standalone, tools can rely on the module definition to ensure that they get the complete API for the library. Moreover, modules can specify which languages they work with, so, e.g., one can not accidentally attempt to load a C++ module into a C program. Problems modules do not solve; -----------------------------; Many programming languages have a module or package system, and because of the variety of features provided by these languages it is important to define what modules do *not* do. In particular, all of the following are considered out-of-scope for modules:. * **Rewrite the world's code**: It is not realistic to require applications or software libraries to make drastic or non-backward-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:5683,depend,dependencies,5683,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['depend'],['dependencies']
Integrability,"mproved algorithm for TPacketizerUnit to fix issue with non; homogeneous machines.; Improve the way the information about log files is saved in case of; failures. The log paths for these failing now should be now correctly; saved and accessible via TProofLog.; Improve merging of histograms. Just use TH1::Add whne the axis are; equal; much faster than TH1::Merge. Fixes; ; In TDataSetManagerFile::NotifyUpdate fix handling of the case when; the global list file does not exist yet (new dataset directory). Fixes; error messages during editing dataset operations.; Fix issue with machine names consistency when working on a local; machine ('localhost' or 'localhost.localdomain' are mapped to; gSystem->HostName()); solves possible matching problems in the; packetizer.; In TProofServ, fill the ""grand total"" message with more blanks, so; that no remnants of the previous message are visible on the screen.; In the autoconf/bonjour interface, fix issue preventing the correct; port (the protocol one, which may be different from the application; default) being used when registering the service. . In TProofPlayer::AddQueryResult, fix a bug affecting the order in; whihc query results are registered when the start time is within 1; second.; Fix worker name in TSlaveLite.; Fix problem with enabling packages with option 'notOnClient' in; PROOF-Lite .; Make sure the log file is flushed at the end of startup to avoid; spurious log messages on next commands .; In CreateSession(), fix an issue with the validity check for existing; sessions .; In TProofLite: fix problem with passing the 'varexp' and 'selection'; strings for processing, preventing correct usage of the operators '|'; and '||' in TTreeFormula.; In the TProofOutputFile constructor, remove the 'localroot' prefix; only if present in the path. Fixes possible truncation problems; occuring when the paths are not under the localroot scope.; In TXSocket and TXSlave: fix problem with the way collection over a; socket just marked as 'bad'",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v530/index.html:5811,interface,interface,5811,proof/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v530/index.html,4,"['interface', 'protocol']","['interface', 'protocol']"
Integrability,"mpting to; open the file will produce an error. However, ``lib/Support`` should not simply; throw that error if it occurs because its a soft error. The problem is that the; interface function, ``OpenFileForWriting`` is too low level. It should be; ``OpenOrCreateFileForWriting``. In the case of the soft ""doesn't exist"" error,; this function would just create it and then open it for writing. This design principle needs to be maintained in ``lib/Support`` because it; avoids the propagation of soft error handling throughout the rest of LLVM.; Hard errors will generally just cause a termination for an LLVM tool so don't; be bashful about throwing them. Rules of thumb:. #. Don't throw soft errors, only hard errors. #. If you're tempted to throw a soft error, re-think the interface. #. Handle internally the most common normal/good/soft error conditions; so the rest of LLVM doesn't have to. No throw Specifications; -----------------------. None of the ``lib/Support`` interface functions may be declared with C++; ``throw()`` specifications on them. This requirement makes sure that the; compiler does not insert additional exception handling code into the interface; functions. This is a performance consideration: ``lib/Support`` functions are; at the bottom of many call chains and as such can be frequently called. We; need them to be as efficient as possible. However, no routines in the system; library should actually throw exceptions. Code Organization; -----------------. Implementations of the Support Library interface are separated by their general; class of operating system. Currently only Unix and Win32 classes are defined; but more could be added for other operating system classifications. To; distinguish which implementation to compile, the code in ``lib/Support`` uses; the ``LLVM_ON_UNIX`` and ``_WIN32`` ``#defines``. Each source file in; ``lib/Support``, after implementing the generic (operating system independent); functionality needs to include the correct implement",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:9394,interface,interface,9394,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['interface'],['interface']
Integrability,mpty base classes; Unknown. 1562; C++14; Non-static data member initializers and union ctor-initializer; Unknown. 1563; CD3; List-initialization and overloaded function disambiguation; Yes. 1564; NAD; Template argument deduction from an initializer list; Unknown. 1565; NAD; Copy elision and lifetime of initializer_list underlying array; Unknown. 1566; NAD; Should new std::initializer_list<T> be ill-formed?; Unknown. 1567; C++14; Inheriting constructors and copy/move constructors; Unknown. 1568; dup; Temporary lifetime extension with intervening cast; Unknown. 1569; C++14; Deducing a function parameter pack before ellipsis; Unknown. 1570; C++14; Address of subobject as non-type template argument; Unknown. 1571; CD4; cv-qualification for indirect reference binding via conversion function; Unknown. 1572; CD4; Incorrect example for rvalue reference binding via conversion function; Unknown. 1573; CD4; Inherited constructor characteristics; Clang 3.9. 1574; NAD; Explicitly-defaulted constexpr functions in wrapper templates; Unknown. 1575; C++14; Incorrect definition of “strict pointer safety”; Unknown. 1576; C++14; Discarded-value volatile xvalues; Unknown. 1577; NAD; Unnecessary restrictions on partial specializations; Unknown. 1578; NAD; Value-initialization of aggregates; Unknown. 1579; C++14; Return by converting move constructor; Clang 3.9. 1580; drafting; Default arguments in explicit instantiations; Not resolved. 1581; CD5; When are constexpr member functions defined?; Unknown. 1582; drafting; Template default arguments and deduction failure; Not resolved. 1583; C++14; Incorrect example of unspecified behavior; Unknown. 1584; drafting; Deducing function types from cv-qualified types; Not resolved. 1585; NAD; Value category of member access of rvalue reference member; Unknown. 1586; NAD; Naming a destructor via decltype; Unknown. 1587; C++14; constexpr initialization and nested anonymous unions; Unknown. 1588; CD3; Deducing cv-qualified auto; Unknown. 1589; CD4; Ambi,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:106201,wrap,wrapper,106201,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['wrap'],['wrapper']
Integrability,"mselves well to source selection and/or have to; query ASTs for some particular nodes. We assume basic knowledge about the Clang AST. See the :doc:`Introduction; to the Clang AST <IntroductionToTheClangAST>` if you want to learn more; about how the AST is structured. .. FIXME: create new refactoring action tutorial and link to the tutorial. Introduction; ------------. Clang's refactoring engine defines a set refactoring actions that implement; a number of different source transformations. The ``clang-refactor``; command-line tool can be used to perform these refactorings. Certain; refactorings are also available in other clients like text editors and IDEs. A refactoring action is a class that defines a list of related refactoring; operations (rules). These rules are grouped under a common umbrella - a single; ``clang-refactor`` command. In addition to rules, the refactoring action; provides the action's command name and description to ``clang-refactor``.; Each action must implement the ``RefactoringAction`` interface. Here's an; outline of a ``local-rename`` action:. .. code-block:: c++. class LocalRename final : public RefactoringAction {; public:; StringRef getCommand() const override { return ""local-rename""; }. StringRef getDescription() const override {; return ""Finds and renames symbols in code with no indexer support"";; }. RefactoringActionRules createActionRules() const override {; ...; }; };. Refactoring Action Rules; ------------------------. An individual refactoring action is responsible for creating the set of; grouped refactoring action rules that represent one refactoring operation.; Although the rules in one action may have a number of different implementations,; they should strive to produce a similar result. It should be easy for users to; identify which refactoring action produced the result regardless of which; refactoring action rule was used. The distinction between actions and rules enables the creation of actions; that define a set of different",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:1683,interface,interface,1683,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst,1,['interface'],['interface']
Integrability,"mulative distribution; function (lower tail integral of the probability density function),; while those with the *`quantile_c`* extension calculate the inverse of; the complement of the cumulative distribution (upper tail integral). All; the inverse distributions are in the MathMore library and are defined in; the header file `Math/ProbFuncInv.h`. The following picture illustrates the available statistical functions; (PDF, CDF and quantiles) in the case of the normal distribution. ![PDF, CDF and quantiles in the case of the normal distribution](pictures/03000128.png). ## Numerical Algorithms. ROOT provides C++ classes implementing numerical algorithms to solve a wide set of problem, like:. * Evaluation of function derivatives.; * Evaluation of integrals.; * Finding the roots of a function; * Finding the minimum/maximum of a function. In order to use these algorithm the user needs to provide a function.; ROOT provides a common way of specifying them via some interfaces. ## ROOT::Math Function interfaces. To get a consistency in the mathematical methods within ROOT, there exists a set of interfaces to define the basic behaviour of a mathematical function.; In order to use the classes presented in this chapter, the mathematical functions defined by the user must inherit from any of the classes seen in the figure:. ![ROOT::Math Function interface structure](pictures/function-hierarchy.png). ### One-dimensional Function Interfaces. These interfaces are used for numerical algorithms operating only on one-dimensional functions and cannot be applied to multi-dimensional functions.; For this case the users needs to define a function object which evaluates in one dimension, and the object will have to derivate from the following:. * `ROOT::Math::IBaseFunctionOneDim`: This class is the most basic function. Provides a method to evaluate the function given a value (simple double) by implementing; `double operator() (const double )`. The user class defined only needs to reimplemen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:34753,interface,interfaces,34753,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['interface'],['interfaces']
Integrability,"multilib variant; # to be a match.; Flags: [--target=thumbv7m-none-eabi, -mfpu=fpv4-sp-d16]. # The second section of the file is a list of regular expressions that are; # used to map from flags generated from command line options to custom flags.; # This is optional.; # Each regular expression must match a whole flag string.; # Flags in the ""Flags"" list will be added if any flag generated from command; # line options matches the regular expression.; Mappings:. # Set a ""--target=thumbv7m-none-eabi"" flag if the regular expression matches; # any of the flags generated from the command line options.; # Match is a POSIX extended regular expression string.; - Match: --target=thumbv([7-9]|[1-9][0-9]+).*; # Flags is a list of one or more strings.; Flags: [--target=thumbv7m-none-eabi]. Design principles; =================. Stable interface; ----------------. ``multilib.yaml`` and ``-print-multi-flags-experimental`` are new; interfaces to Clang. In order for them to be usable over time and across LLVM; versions their interfaces should be stable.; The new multilib system will be considered experimental in LLVM 17, but in; LLVM 18 it will be stable. In particular this is important to which multilib; selection flags Clang generates from command line options. Once a flag is; generated by a released version of Clang it may be used in ``multilib.yaml``; files that exist independently of the LLVM release cycle, and therefore; ceasing to generate the flag would be a breaking change and should be; avoided. However, an exception is the normalization of ``-march``.; ``-march`` for Arm architectures contains a list of enabled and disabled; extensions and this list is likely to grow. Therefore ``-march`` flags are; unstable. Incomplete interface; --------------------. The new multilib system does multilib selection based on only a limited set of; command line options, and limits which flags can be used for multilib; selection. This is in order to avoid committing to too large an interface",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:9466,interface,interfaces,9466,interpreter/llvm-project/clang/docs/Multilib.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst,1,['interface'],['interfaces']
Integrability,"mum set of member functions; that all iterators must support. These include:. - `Next`; `Returns the next member of the collection or 0 if no more members.`. - `Reset` `Resets the iterator so that ` `Next`; ` returns the first object.`. ## A Collectable Class. By default, all objects of **`TObject`** derived classes can be stored; in ROOT containers. However, the **`TObject`** class provides some; member functions that allow you to tune the behavior of objects in; containers. For example, by default two objects are considered equal if; their pointers point to the same address. This might be too strict for; some classes where equality is already achieved if some or all of the; data members are equal. By overriding the following **`TObject`** member; functions, you can change the behavior of objects in collections:. - `IsEqual()`is used by the `FindObject() `collection method. By; default, `IsEqual()` compares the two object pointers. - `Compare()`returns -1, 0 or 1 depending if the object is smaller,; equal or larger than the other object. By default, a **`TObject`**; has not a valid `Compare()` method. - `IsSortable() `returns true if the class is sort able (i.e. if it; has a valid `Compare(`) method). By default, a **`TObject`** is not; sort able. - `Hash() `returns a hash value. It needs to be implemented if an; object has to be stored in a collection using a hashing technique,; like **`THashTable`**, **`THashList`** and **`TMap`**. By default,; `Hash(`) returns the address of the object. It is essential to; choose a good hash function. The example below shows how to use and override these member functions. ``` {.cpp}; class TObjNum : public TObject {; private:; Int_t num; // TObjNum is a simple container for an integer.; public:; TObjNum(Int_t i = 0) : num(i) { }; ~TObjNum() { }; void SetNum(Int_t i) { num = i; }; Int_t GetNum() const { return num; }; void Print(Option_t *) const; { printf(""num = %dn"", num); }; Bool_t IsEqual(TObject *obj) const; { return num == ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:9026,depend,depending,9026,documentation/users-guide/CollectionClasses.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md,1,['depend'],['depending']
Integrability,"my vector) # the old syntax would not work here!; ```. The old pythonization with the `__getattr__` syntax still works, but emits a deprecation warning and will be removed from ROOT 6.34. ### Removal of Python 2 support. ROOT does no longer support Python 2. The minimum Python version necessary to use ROOT in a Python application is 3.8.; As a consequence, any reference to Python 2 in ROOT code was removed and certain configuration options are no longer; usable, e.g. * `root-config --python2-version`; * cmake -Dpyroot-python2. The cmake build system now looks for the standard `Python3` package and previously custom Python-related cmake variables; are now just the ones automatically produced by cmake (see https://cmake.org/cmake/help/latest/module/FindPython.html). ### More usage of the public cppyy API. Many implementation details of the ROOT pythonizations were moved from C++ functions to pure Python bindings using the; public cppyy API. This helps in the integration with the tool but also improves code efficiency and memory usage. ## Class Reference Guide. - Define missing doxygen groups.; - Fix a few typos in the `THStack` documentation.; - Small fixes in the `THistPainter` documentation.; - Improve the `TColor` documentation: use modern C++ in the examples.; - Make sure the python examples do not generate wrong namespaces in the documentation.; - The dataframe tutorials json spec files were not displayed properly. Moreover there was; no direct correspondence between the code source and the json file. Those files do not; have any doc in them. With a direct link to the GitHub source file the dependency between source; code and json is now more obvious.; - Document how to remove shadow of `TPave`, as it was not evident (only explanations were hidden here and there in the forum).; - Improve the `SetFillColorAlpha` documentation.; - Simplify some graphics examples: arrow.C, crown.C, diamond.C and ellipse.C.; - Fix a typo in the documentation of `TGraph::SetHighlight`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:23194,integrat,integration,23194,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['integrat'],['integration']
Integrability,"n *id*. Stream *id* is an integer in the range from 0 to 3. Numeric values may be specified as positive :ref:`integer numbers<amdgpu_synid_integer_number>`; or :ref:`absolute expressions<amdgpu_synid_absolute_expression>`. Each message type supports specific operations:. ====================== ========== ============================== ============ ==========; Message name Message Id Supported Operations Operation Id Stream Id; ====================== ========== ============================== ============ ==========; MSG_INTERRUPT 1 \- \- \-; MSG_GS 2 GS_OP_CUT 1 Optional; \ GS_OP_EMIT 2 Optional; \ GS_OP_EMIT_CUT 3 Optional; MSG_GS_DONE 3 GS_OP_NOP 0 \-; \ GS_OP_CUT 1 Optional; \ GS_OP_EMIT 2 Optional; \ GS_OP_EMIT_CUT 3 Optional; MSG_SAVEWAVE 4 \- \- \-; MSG_STALL_WAVE_GEN 5 \- \- \-; MSG_HALT_WAVES 6 \- \- \-; MSG_ORDERED_PS_DONE 7 \- \- \-; MSG_EARLY_PRIM_DEALLOC 8 \- \- \-; MSG_GS_ALLOC_REQ 9 \- \- \-; MSG_GET_DOORBELL 10 \- \- \-; MSG_SYSMSG 15 SYSMSG_OP_ECC_ERR_INTERRUPT 1 \-; \ SYSMSG_OP_REG_RD 2 \-; \ SYSMSG_OP_TTRACE_PC 4 \-; ====================== ========== ============================== ============ ==========. *Sendmsg* arguments are validated depending on how *type* value is specified:. * If message *type* is specified by name, arguments values must satisfy limitations detailed in the table above.; * If message *type* is specified as a number, each argument must not exceed the corresponding value range (see the first table). Examples:. .. parsed-literal::. // numeric message code; msg = 0x10; s_sendmsg 0x12; s_sendmsg msg + 2. // sendmsg with strict arguments validation; s_sendmsg sendmsg(MSG_INTERRUPT); s_sendmsg sendmsg(MSG_GS, GS_OP_EMIT); s_sendmsg sendmsg(MSG_GS, 2); s_sendmsg sendmsg(MSG_GS_DONE, GS_OP_EMIT_CUT, 1); s_sendmsg sendmsg(MSG_SYSMSG, SYSMSG_OP_TTRACE_PC); s_sendmsg sendmsg(MSG_GET_DOORBELL). // sendmsg with validation of value range only; msg = 2; op = 3; stream = 1; s_sendmsg sendmsg(msg, op, stream); s_sendmsg sendmsg(2, GS_OP_CUT); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_msg.rst:2738,depend,depending,2738,interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_msg.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_msg.rst,12,"['depend', 'message']","['depending', 'message']"
Integrability,"n 5.16, 5.18 and version 5.20 in addition to these notes. Bindings - packages related to the interplay with other programming languages (Python, Ruby); Cint - the C++ interpreter; Core - the basic ROOT functionality; Geometry - building, representing and drawing geometrical objects; 2D Graphics - ROOT's two dimensional graphics interface; 3D Graphics - ROOT's three dimensional graphics interface; Graphical User Interface - from basic GUI elements to ROOT's own, complete dialogs; Histograming - counting values, spectra, and drawing them; HTML - the documentation generator; Input/Ouput - storing and reading data; Mathemathics - everything one can use to calculate: minimizers, matrixes, FFT, and much more; Miscellaneous - things that didn't make it into the other groups: table ; Monte Carlo - monte carlo and physics simulation interfaces; Networking - network-related parts, e.g. protocols and authentication interfaces; PROOF - parallel ROOT facility; RooFit - a fitting library; SQL - database interfaces; TMVA - multivariate analysis tools; Trees - ROOT's unique container class and related utilities. Binaries for all supported platforms are available at:. http://root.cern.ch/root/Version521.html; Versions for AFS have also been updated. See the list of supported; platforms:; http://root.cern.ch/Welcome.html. For more information, see:. http://root.cern.ch; The following people have contributed to this new version:; Ilka Antcheva,; Jean-Fran�ois Bastien, ; Bertrand Bellenot,; Rene Brun,; Philippe Canal,; Olivier Couet,; Kyle Cranmer,; Valeri Fine,; Leo Franco, ; Gerri Ganis,; Andrei Gheata,; Mihaela Gheata,; David Gonzalez Maline, ; Andreas Hoecker, ; Jan Iwaszkiewicz, ; Lukasz Janyst, ; Anna Kreshuk, ; Wim Lavrijsen,; Josef Leydold,; Sergei Linev,; Anar Manafov, ; Diego Marcos-Segura, ; Lorenzo Moneta,; Axel Naumann,; Eddy Offermann, ; Timur Pocheptsov,; Fons Rademakers,; Paul Russo, ; Gregory Schott,; Stefan Schmitt,; Alja Tadel, ; Matevz Tadel, ; Wouter Verkerke, ; Had",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/doc/v522/index.html:1113,protocol,protocols,1113,doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/doc/v522/index.html,6,"['interface', 'protocol']","['interfaces', 'protocols']"
Integrability,"n Level; Parallelism). In the dot-product example, there are anti-dependencies introduced by; instructions from different iterations. However, those dependencies can be; removed at register renaming stage (at the cost of allocating register aliases,; and therefore consuming physical registers). Table *Average Wait times* helps diagnose performance issues that are caused by; the presence of long latency instructions and potentially long data dependencies; which may limit the ILP. Last row, ``<total>``, shows a global average over all; instructions measured. Note that :program:`llvm-mca`, by default, assumes at; least 1cy between the dispatch event and the issue event. When the performance is limited by data dependencies and/or long latency; instructions, the number of cycles spent while in the *ready* state is expected; to be very small when compared with the total number of cycles spent in the; scheduler's queue. The difference between the two counters is a good indicator; of how large of an impact data dependencies had on the execution of the; instructions. When performance is mostly limited by the lack of hardware; resources, the delta between the two counters is small. However, the number of; cycles spent in the queue tends to be larger (i.e., more than 1-3cy),; especially when compared to other low latency instructions. Bottleneck Analysis; ^^^^^^^^^^^^^^^^^^^; The ``-bottleneck-analysis`` command line option enables the analysis of; performance bottlenecks. This analysis is potentially expensive. It attempts to correlate increases in; backend pressure (caused by pipeline resource pressure and data dependencies) to; dynamic dispatch stalls. Below is an example of ``-bottleneck-analysis`` output generated by; :program:`llvm-mca` for 500 iterations of the dot-product example on btver2. .. code-block:: none. Cycles with backend pressure increase [ 48.07% ]; Throughput Bottlenecks:; Resource Pressure [ 47.77% ]; - JFPA [ 47.77% ]; - JFPU0 [ 47.77% ]; Data Dependenci",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst:26163,depend,dependencies,26163,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,1,['depend'],['dependencies']
Integrability,"n ORCv1 and ORCv2; to be aware of:. 1. ORCv2 fully adopts the JIT-as-linker model that began with MCJIT. Modules; (and other program representations, e.g. Object Files) are no longer added; directly to JIT classes or layers. Instead, they are added to ``JITDylib``; instances *by* layers. The ``JITDylib`` determines *where* the definitions; reside, the layers determine *how* the definitions will be compiled.; Linkage relationships between ``JITDylibs`` determine how inter-module; references are resolved, and symbol resolvers are no longer used. See the; section `Design Overview`_ for more details. Unless multiple JITDylibs are needed to model linkage relationships, ORCv1; clients should place all code in a single JITDylib.; MCJIT clients should use LLJIT (see `LLJIT and LLLazyJIT`_), and can place; code in LLJIT's default created main JITDylib (See; ``LLJIT::getMainJITDylib()``). 2. All JIT stacks now need an ``ExecutionSession`` instance. ExecutionSession; manages the string pool, error reporting, synchronization, and symbol; lookup. 3. ORCv2 uses uniqued strings (``SymbolStringPtr`` instances) rather than; string values in order to reduce memory overhead and improve lookup; performance. See the subsection `How to manage symbol strings`_. 4. IR layers require ThreadSafeModule instances, rather than; std::unique_ptr<Module>s. ThreadSafeModule is a wrapper that ensures that; Modules that use the same LLVMContext are not accessed concurrently.; See `How to use ThreadSafeModule and ThreadSafeContext`_. 5. Symbol lookup is no longer handled by layers. Instead, there is a; ``lookup`` method on JITDylib that takes a list of JITDylibs to scan. .. code-block:: c++. ExecutionSession ES;; JITDylib &JD1 = ...;; JITDylib &JD2 = ...;. auto Sym = ES.lookup({&JD1, &JD2}, ES.intern(""_main""));. 6. The removeModule/removeObject methods are replaced by; ``ResourceTracker::remove``.; See the subsection `How to remove code`_. For code examples and suggestions of how to use the ORCv2 APIs,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:20931,synchroniz,synchronization,20931,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['synchroniz'],['synchronization']
Integrability,"n a file; - `rootls`: to list the content of a rootfile; - `rootmkdir`: to create a directory in a rootfile; - `rootmv`: to move content across files; - `rootprint`: to plot content (histograms, graphs) of files; - `rootrm`: to remove content from files; These utilities took inspiration from the well known *nix commands and all offer the `-h` switch which provides documentation for all options available and example invocation lines. ### TBufferFile. We updated TBuffer::Expand to properly shrink the buffer when requested, hence reducing memory usage in some cases. ### I/O New functionalities. We added support for template parameter packs in class name involved in the I/O. ## TTree Libraries. ### Improvement of handling of default number of entries. A new const expression value: `TTree::kMaxEntries` has been introduced to; express the largest possible entry number in a `TTree`. This is used in; two main cases:. - as the default value for the requested number of entries a routine should be; applied to; for example this is used for `TTree::Draw` and `TTree::Process`.; Previously the default was only 1 billions entries, causing those routines to; end early in case of very large trees. - as the default value for the number of entries returned by TChain::GetEntriesFast.; The previous value was kBigNumber (set to 1234567890) and internally (but somewhat; inconsistently, see [ROOT-6885]) a larger value was used (named theBigNumber). Now; `TTree::kMaxEntries` is used throughout TChain. `TChain::kBigNumber` is deprecated and its value has been changed to be equal; to `TTree::kMaxEntries`. ### MakeSelector. `TTree::MakeSelector` has been update to generate a code skeleton based on the `TTreeReader` rather than the old style relying on numeric data members replacements for the user objects. The main advantage is the lifting of the problem related to the fact that the old style was using fixed size array to represent variable size collection. `TTree::MakeSelector` takes an option ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:8778,rout,routine,8778,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['rout'],['routine']
Integrability,"n arbitrary value,; we are allowed to assume that it could be zero. Since a divide by zero; has *undefined behavior*, we are allowed to assume that the operation; does not execute at all. This allows us to delete the divide and all; code after it. Because the undefined operation ""can't happen"", the; optimizer can assume that it occurs in dead code. .. code-block:: text. a: store undef -> %X; b: store %X -> undef; Safe:; a: <deleted> (if the stored value in %X is provably not poison); b: unreachable. A store *of* an undefined value can be assumed to not have any effect;; we can assume that the value is overwritten with bits that happen to; match what was already there. This argument is only valid if the stored value; is provably not ``poison``. However, a store *to* an undefined; location could clobber arbitrary memory, therefore, it has undefined; behavior. Branching on an undefined value is undefined behavior.; This explains optimizations that depend on branch conditions to construct; predicates, such as Correlated Value Propagation and Global Value Numbering.; In case of switch instruction, the branch condition should be frozen, otherwise; it is undefined behavior. .. code-block:: llvm. Unsafe:; br undef, BB1, BB2 ; UB. %X = and i32 undef, 255; switch %X, label %ret [ .. ] ; UB. store undef, ptr %ptr; %X = load ptr %ptr ; %X is undef; switch i8 %X, label %ret [ .. ] ; UB. Safe:; %X = or i8 undef, 255 ; always 255; switch i8 %X, label %ret [ .. ] ; Well-defined. %X = freeze i1 undef; br %X, BB1, BB2 ; Well-defined (non-deterministic jump). .. _poisonvalues:. Poison Values; -------------. A poison value is a result of an erroneous operation.; In order to facilitate speculative execution, many instructions do not; invoke immediate undefined behavior when provided with illegal operands,; and return a poison value instead.; The string '``poison``' can be used anywhere a constant is expected, and; operations such as :ref:`add <i_add>` with the ``nsw`` flag can produce; a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:196081,depend,depend,196081,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['depend']
Integrability,"n be specified. ### MnMigrad(const FCNBase&, const MnUserParameterState&, const MnStrategy&) ###. Constructor from a full state (parameters + covariance) as starting; input plus the desired strategy. ### operator() ###. [api:migradop] MnMigrad::operator()(unsigned int maxfcn, double; tolerance) causes minimization of the $\mbox{FCN}$ and returns the; result in form of a FunctionMinimum. The optional argument; $\mbox{maxfcn}$ specifies the (approximate) maximum number of; function calls after which the calculation will be stopped even if it; has not yet converged. The optional argument $\mbox{tolerance}$; specifies the required tolerance on the function value at the minimum.; The default $\mbox{tolerance}$ value is $0.1$, and the minimization; will stop when the estimated vertical distance to the minimum; ($\mbox{EDM}$) is less than; $0.001*$$\mbox{tolerance}$$*$$\mbox{up}$ (see [howto:errordef]). ### Parameter interaction ###. MnMigrad retains the result after each minimization; (MnUserParameterStae, see [api:state]) and forwards the interface. ### VariableMetricMinimizer() ###. The VariableMetricMinimizer is instantiated using default constructor. ### minimize(const FCNBase&, ...) ###. The VariableMetricMinimizer provides several overloaded methods minimize; with return value FunctionMinimum. Together with the user; $\mbox{FCN}$ (either an implementation of FCNBase or; FCNGradientBase) the user has to give as input the parameters with; starting values in one of the defined formats (std::vector$<$double$>$,; MnUserParameters or MnUserParameterState). ## MnMinimize and CombinedMinimizer ##. [api:minimize]. Causes minimization of the function by the method of; $\mbox{MIGRAD}$, as does the MnMigrad class, but switches to the; $\mbox{SIMPLEX}$ method if $\mbox{MIGRAD}$ fails to converge.; Constructor arguments, methods arguments and names of methods are the; same as for MnMigrad or MnSimplex and VariableMetricMinimizer or; SimplexMinimizer. ## MnMinos ##. [api:minos] Ca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:44081,interface,interface,44081,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['interface'],['interface']
Integrability,"n can not be read with older release of ROOT. Support for LZ4 was however back-ported to the patch branches of previous releases and the following tags (and later release in the same patch series) can read ROOT files written with LZ4 compression:. * v5.34/38; * v6.08/06 [not yet released]; * v6.10/08; * v6.12/02. ## Removed interfaces. ## Core Libraries; - Optimize away redundant deserialization of template specializations. This reduces the memory footprint for hsimple by around 30% while improving the runtime performance for various cases by around 15%.; - When ROOT is signaled with a SIGUSR2 (i.e. on Linux and MacOS X) it will now print a backtrace.; - Move RStringView.h to ROOT/RStringView.hxx and always include ROOT/RStringView.hxx instead of RStringView.h for backward compatibility; - In `TClingCallFunc`, support r-value reference parameters. This paves the way for the corresponding support in PyROOT (implemented now in the latest Cppyy).; - Included the new TSequentialExecutor in ROOT, sharing the interfaces of TExecutor.This should improve code economy when providing a fallback for TThreadExecutor/TProcessExecutor. ### Thread safety; - Resolved several race conditions, dead-locks, performance and order of initialization/destruction issues still lingering because of or despite the new read-write lock mechanism. ## Interpreter. - Enabled use of multi-threaded code from the interpreter.; - Previouslyl multi-threaded code could be run from the interpreter as long as the call starting the threada was the same code that initialized the ROOT global lock, any other uses, including attempting to run the same code a second time in the same session would lead to a dead lock (if any other thread attempted to take on the ROOT lock).; - The interpreter now suspend the ROOT lock (which is taken to protect the interpreter global state) during user code execution. ## I/O Libraries; - LZ4 (with compression level 4) is now the default compression algorithm for new ROOT files (L",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md:2401,interface,interfaces,2401,README/ReleaseNotes/v614/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md,1,['interface'],['interfaces']
Integrability,"n case of a linear least square model, or by using Minuit, Minuit2 or GSL minimization methods provided by the MathMore library. Functions for filling the new ROOT::Fit::BinData classes with all the histogram and graph types have been added in the histogram library (libHist) and graph library:; ; ROOT::Fit::FillData( BinData & , const TH1 *, TF1 * ) for histograms (in libHist); ROOT::Fit::FillData( BinData & , const TGraph2D *, TF1 * ) for 2D graphs (in libHist); ROOT::Fit::FillData( BinData & , const TGraph *, TF1 * ) for all 1D graphs (in libGraf); ROOT::Fit::FillData( BinData & , const TMultiGraph *, TF1 * ) for multi-graphs (in libGraf); . MathCore Numerical Algorithms. Classes implementing numerical methods which can be used by all the other ROOT library have been added in MathCore. These originate mainly from methods present previously in the implementation of the TF1 class. Now they can be used also outside this class. In addition, in order to have a common entry point, interfaces classes for these numerical algorithms have been; included.; These interfaces are as well implemented by classes using the GSL library and located in the MathMore library. The library can be loaded automatically using the ROOT plug-in manager.; In detail, the new classes containing implementations present previously in TF1 are:. ; GaussIntegrator and GaussLegendreIntegrator for numerical integration of one-dimensional functions. The first class uses Gaussian 8 and 16 point quadrature approximation, it provides the translation of the CERNLIB algorithm; DGAUSS by Sigfried Kolbig, and it is used by the TF1::Integral method. The second one uses the Gauss Legendre quadrature formula. It is used by the TF1::IntegralFast method.; These classes implement both the same virtual interface as the adaptive integration methods provided by the MathMore library. They can all be created and used easily via the common class ROOT::Math::IntegratorOneDim providing the interfaces for numerical integratio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:6301,interface,interfaces,6301,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,2,['interface'],['interfaces']
Integrability,n conversions; Clang 4. 1513; drafting; initializer_list deduction failure; Not resolved. 1514; C++14; Ambiguity between enumeration definition and zero-length bit-field; Clang 11. 1515; CD3; Modulo 2n arithmetic for implicitly-unsigned types; Unknown. 1516; CD3; Definition of “virtual function call”; Unknown. 1517; drafting; Unclear/missing description of behavior during construction/destruction; Not resolved. 1518; CD4; Explicit default constructors and copy-list-initialization; Clang 4. 1519; NAD; Conflicting default and variadic constructors; Unknown. 1520; NAD; Alias template specialization vs pack expansion; Unknown. 1521; drafting; T{expr} with reference types; Not resolved. 1522; CD3; Access checking for initializer_list array initialization; Unknown. 1523; CD5; Point of declaration in range-based for; Unknown. 1524; drafting; Incompletely-defined class template base; Not resolved. 1525; NAD; Array bound inference in temporary array; Unknown. 1526; dup; Dependent-class lookup in the current instantiation; Unknown. 1527; CD3; Assignment from braced-init-list; Unknown. 1528; CD3; Repeated cv-qualifiers in declarators; Unknown. 1529; drafting; Nomenclature for variable vs reference non-static data member; Not resolved. 1530; drafting; Member access in out-of-lifetime objects; Not resolved. 1531; CD3; Definition of “access” (verb); Unknown. 1532; CD3; Explicit instantiation and member templates; Unknown. 1533; CD3; Function pack expansion for member initialization; Unknown. 1534; dup; cv-qualification of prvalue of type “array of class”; Unknown. 1535; CD3; typeid in core constant expressions; Unknown. 1536; drafting; Overload resolution with temporary from initializer list; Not resolved. 1537; CD3; Optional compile-time evaluation of constant expressions; Unknown. 1538; CD3; C-style cast in braced-init-list assignment; Unknown. 1539; CD3; Definition of “character type”; Unknown. 1540; NAD; Use of address constants in constant expressions; Unknown. 1541; CD3; cv ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:102686,Depend,Dependent-class,102686,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Depend'],['Dependent-class']
Integrability,"n idea of a; coroutine reaching the end. From the compiler perspective, it is an optimization; opportunity for reducing number of resume points (and therefore switch cases) in; the resume function. The following is an example of a function that keeps resuming the coroutine; until the final suspend point is reached after which point the coroutine is; destroyed:. .. code-block:: llvm. define i32 @main() {; entry:; %hdl = call ptr @f(i32 4); br label %while; while:; call void @llvm.coro.resume(ptr %hdl); %done = call i1 @llvm.coro.done(ptr %hdl); br i1 %done, label %end, label %while; end:; call void @llvm.coro.destroy(ptr %hdl); ret i32 0; }. Usually, final suspend point is a frontend injected suspend point that does not; correspond to any explicitly authored suspend point of the high level language.; For example, for a Python generator that has only one suspend point:. .. code-block:: python. def coroutine(n):; for i in range(n):; yield i. Python frontend would inject two more suspend points, so that the actual code; looks like this:. .. code-block:: c. void* coroutine(int n) {; int current_value;; <designate current_value to be coroutine promise>; <SUSPEND> // injected suspend point, so that the coroutine starts suspended; for (int i = 0; i < n; ++i) {; current_value = i; <SUSPEND>; // corresponds to ""yield i""; }; <SUSPEND final=true> // injected final suspend point; }. and python iterator `__next__` would look like:. .. code-block:: c++. int __next__(void* hdl) {; coro.resume(hdl);; if (coro.done(hdl)) throw StopIteration();; return *(int*)coro.promise(hdl, 4, false);; }. Intrinsics; ==========. Coroutine Manipulation Intrinsics; ---------------------------------. Intrinsics described in this section are used to manipulate an existing; coroutine. They can be used in any function which happen to have a pointer; to a `coroutine frame`_ or a pointer to a `coroutine promise`_. .. _coro.destroy:. 'llvm.coro.destroy' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:26073,inject,inject,26073,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['inject'],['inject']
Integrability,"n is a hot spot of the program; execution. The function will be optimized more aggressively and will be; placed into special subsection of the text section to improving locality. When profile feedback is enabled, this attribute has the precedence over; the profile information. By marking a function ``hot``, users can work; around the cases where the training input does not have good coverage; on all the hot functions.; ``inlinehint``; This attribute indicates that the source code contained a hint that; inlining this function is desirable (such as the ""inline"" keyword in; C/C++). It is just a hint; it imposes no requirements on the; inliner.; ``jumptable``; This attribute indicates that the function should be added to a; jump-instruction table at code-generation time, and that all address-taken; references to this function should be replaced with a reference to the; appropriate jump-instruction-table function pointer. Note that this creates; a new pointer for the original function, which means that code that depends; on function-pointer identity can break. So, any function annotated with; ``jumptable`` must also be ``unnamed_addr``.; ``memory(...)``; This attribute specifies the possible memory effects of the call-site or; function. It allows specifying the possible access kinds (``none``,; ``read``, ``write``, or ``readwrite``) for the possible memory location; kinds (``argmem``, ``inaccessiblemem``, as well as a default). It is best; understood by example:. - ``memory(none)``: Does not access any memory.; - ``memory(read)``: May read (but not write) any memory.; - ``memory(write)``: May write (but not read) any memory.; - ``memory(readwrite)``: May read or write any memory.; - ``memory(argmem: read)``: May only read argument memory.; - ``memory(argmem: read, inaccessiblemem: write)``: May only read argument; memory and only write inaccessible memory.; - ``memory(read, argmem: readwrite)``: May read any memory (default mode); and additionally write argument memory.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:84539,depend,depends,84539,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['depends']
Integrability,"n of POD classes?; N/A. 511; open; POD-structs with template assignment operators; Not resolved. 512; NAD; Union members with user-declared non-default constructors; Yes. 513; CD1; Non-class “most-derived” objects; N/A. 514; CD1; Is the initializer for a namespace member in the scope of the namespace?; Yes. 515; CD1; Non-dependent references to base class members; Superseded by 1017. 516; CD1; Use of signed in bit-field declarations; N/A. 517; CD1; Partial specialization following explicit instantiation; No. 518; CD1; Trailing comma following enumerator-list; Yes (C++11 onwards). 519; CD1; Null pointer preservation in void* conversions; Yes. 520; CD1; Old-style casts between incomplete class types; N/A. 521; CD1; Requirements for exceptions thrown by allocation functions; No. 522; CD1; Array-to-pointer decay in template argument deduction; Yes. 523; open; Can a one-past-the-end pointer be invalidated by deleting an adjacent object?; Not resolved. 524; CD1; Can function-notation calls to operator functions be dependent?; Yes. 525; CD1; Missing * in example; Yes. 526; CD1; Confusing aspects in the specification of non-deduced contexts; Yes. 527; CD2; Problems with linkage of types; N/A. 528; NAD; Why are incomplete class types not allowed with typeid?; Unknown. 529; drafting; Use of template<> with “explicitly-specialized” class templates; Not resolved. 530; CD1; Nontype template arguments in constant expressions; Yes. 531; C++11; Defining members of explicit specializations; Partial. 532; C++11; Member/nonmember operator template partial ordering; Clang 3.5. 533; NAD; Special treatment for C-style header names; N/A. 534; CD1; template-names and operator-function-ids; Clang 2.9. 535; CD3; Copy construction without a copy constructor; Yes. 536; CD6; Problems in the description of id-expressions; N/A. 537; CD1; Definition of “signature”; N/A. 538; CD1; Definition and usage; of structure, POD-struct, POD-union,; and POD class; N/A. 539; CD3; Constraints on type-specifier",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:35992,depend,dependent,35992,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['depend'],['dependent']
Integrability,"n of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. . UseNTrainEvents No 0 − deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees. NNodesMax No 0 − deprecated: Use MaxDepth instead to limit the tree size. Configuration options for MVA method :. Configuration options reference for MVA method: Boost. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). Boost_Num No 100 − Number of times the classifier is boosted. Boost_MonitorMethod No True − Write monitoring histograms for each boosted classifier. Boost_DetailedMonitoring No False − Produce histograms for detailed boost-wise monitoring. Boost_Type No AdaBoost AdaBoost, Bagging, HighEdgeGauss, HighEdgeCoPara Boosting type for the classifiers. Boost_BaggedSampleFraction No 0.6 − Relative size of bagged event sample to original size of the data sample (used whenever bagging is used). Boost_MethodWeightType No ByError ByError, Average, ByROC, ByOverlap, LastMethod How to set the final weight of the boosted classifiers. Boost_RecalculateMVACut No True − Recalculate the classifier MVA Signallike cut at every boost iteration. Boos",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:16312,message,message,16312,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,2,['message'],['message']
Integrability,"n of the; previous algorithm; ROOT::Math::GSLMultiRootFinder::kNewton with name ""Newton"": Newton method ; ROOT::Math::GSLMultiRootFinder::kGNewton with name ""GNewton"": modified Newton method . The algorithms without derivatives (see also the GSL; documentation ); are the followings:; ; ROOT::Math::GSLMultiRootFinder::kHybridS with name ""HybridS"": same as HybridSJ but using; finate difference approximation for the derivatives; ROOT::Math::GSLMultiRootFinder::kHybrid with name ""Hybrid"": unscaled version of the; previous algorithm; ROOT::Math::GSLMultiRootFinder::kDNewton with name ""DNewton"": discrete Newton algorithm ; ROOT::Math::GSLMultiRootFinder::kBroyden with name ""Broyden"": Broyden algorithm . Minuit2. Improve Printing of information and Error messages. Use the class ROOT::Minuit2::MnPrint to store a; static print level, which can be set by using the static function MnPrint::SetLevel(int ). Add new information messages in the VariableMetricBuilder (i.e. Migrad), to print some messages; during the minimization.The new printing level is now also controlled by the Minuit2Minimizer class. ; Print now in the messages the parameter names instead of the parameter indices.; fix the update of the number of function calls in Minuit2 after calling Hess after Migrad. The number is now not; reset in MnHesse; Fix a problem, when, after calling Hesse ,the edm was correct to values below the required tolerance.; Now do not flag these cases as failed minimizations but as good ones.; Correct tolerance by 2E-3 instead 2E-4 to ve conistent with what is done in F77 Minuit or TMinuit; Avoid when using the CombinedMinimumBuilder (i.e. the Minimize algorithm) to call two times; ModularFunctionMinimize::Minimum. Since this last function correct the tolerance by the Up value, a; double correction was applied in this case. ; Implement the methods Minuit2Minimizer::GetHessianMatrix(double * mat) and; Minuit2Minimizer::GetCovMatrix(double * mat).; For retrieving the Hessian, a new method ha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v530/index.html:4933,message,messages,4933,math/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v530/index.html,2,['message'],['messages']
Integrability,"n the desired precision is obtained.; The confidence level value at a given point can also be done via HypoTestInverter::RunOnePoint.; The class can scan the CLs+b values (default) or alternatively CLs (if the; method HypoTestInverter::UseCLs has been called).; The estimated error due to the MC toys statistics from the HybridCalculator is propagated into the limits obtained from the HypoTestResult; A new tutorial rs801_HypoTestInverter.C has been added in the tutorials/roostats directory to show the usage of this class. New class BayesianCalculator. New class for calculating Bayesian interval using numerical integration. It implements the IntervalCalculator interface and returns as result a SimpleInterval. . The BayesianCalculator::GetInterval() method returns a SimpleInterval which contains the lower and upper value of the bayesian interval obtained from the posterior probability for the given confidence level.; The class return also the posterior pdf (BayesianCalculator::GetPosteriorPdf()) obtained from integrating (marginalizing) on the nuisance parameters.; It works currently only for one-dimensional problems by relying on RooFit for performing analytical or numerical integration.; A plot of the posterior and the desired interval can be obtained using BayesianCalculator::GetPosteriorPlot().; A new tutorial rs701_BayesianCalculator.C has been added in the tutorials/roostats directory to show the usage of this class. MCMCCalculator. Add possibility to specify the prior function in the constructor of the class to have a signature similar to the BayesianCalculator class. When no prior is specified it is assumed is part of the global model (pdf) passed to the class. Improvements and Bug fixes. Various improvements and fixes have been applied also to all the calculator classes. Internally now the RooArgSet objects are used by value instead of a pointer.; All the calculator have a consistent way for being constructed, either by passing pdf pointers and the set defining ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html:16414,integrat,integrating,16414,roofit/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html,2,['integrat'],['integrating']
Integrability,"n the hot region into the; trace cache. Then we instrument that code. The process is similar for; generating the final optimized trace; we copy the same basic blocks; because we might need to put in fixup code for exit BBs. LLVM basic blocks are not typically used in the Reoptimizer except; for the mapping information. We are restricted to using single instructions to branch between the; original code, trace, and instrumented code. So we have to keep the; code copies in memory near the original code (they can't be far enough; away that a single pc-relative branch would not work.) Malloc() or; data region space is too far away. this impacts the design of the ; trace cache. We use a dummy function that is full of a bunch of for loops which we; overwrite with trace-cache code. The trace manager keeps track of; whether or not we have enough space in the trace cache, etc. The trace insertion routine takes an original start address, a vector; of machine instructions representing the trace, index of branches and; their corresponding absolute targets, and index of calls and their; corresponding absolute targets. The trace insertion routine is responsible for inserting branches from; the beginning of the original code to the beginning of the optimized; trace. This is because at some point the trace cache may run out of; space and it may have to evict a trace, at which point the branch to; the trace would also have to be removed. It uses a round-robin; replacement policy; we have found that this is almost as good as LRU; and better than random (especially because of problems fitting the new; trace in.). We cannot deal with discontiguous trace cache areas. The trace cache; is supposed to be cache-line-aligned, but it is not page-aligned. We generate instrumentation traces and optimized traces into separate; trace caches. We keep the instrumented code around because you don't; want to delete a trace when you still might have to return to it; (i.e., return from an llvm_first_tri",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2003-06-25-Reoptimizer1.txt:4941,rout,routine,4941,interpreter/llvm-project/llvm/docs/HistoricalNotes/2003-06-25-Reoptimizer1.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2003-06-25-Reoptimizer1.txt,1,['rout'],['routine']
Integrability,"n the source file and not; specified on the command line using ``-include-pch``. Relocatable PCH Files; ^^^^^^^^^^^^^^^^^^^^^. It is sometimes necessary to build a precompiled header from headers; that are not yet in their final, installed locations. For example, one; might build a precompiled header within the build tree that is then; meant to be installed alongside the headers. Clang permits the creation; of ""relocatable"" precompiled headers, which are built with a given path; (into the build directory) and can later be used from an installed; location. To build a relocatable precompiled header, place your headers into a; subdirectory whose structure mimics the installed location. For example,; if you want to build a precompiled header for the header ``mylib.h``; that will be installed into ``/usr/include``, create a subdirectory; ``build/usr/include`` and place the header ``mylib.h`` into that; subdirectory. If ``mylib.h`` depends on other headers, then they can be; stored within ``build/usr/include`` in a way that mimics the installed; location. Building a relocatable precompiled header requires two additional; arguments. First, pass the ``--relocatable-pch`` flag to indicate that; the resulting PCH file should be relocatable. Second, pass; ``-isysroot /path/to/build``, which makes all includes for your library; relative to the build directory. For example:. .. code-block:: console. # clang -x c-header --relocatable-pch -isysroot /path/to/build /path/to/build/mylib.h mylib.h.pch. When loading the relocatable PCH file, the various headers used in the; PCH file are found from the system header root. For example, ``mylib.h``; can be found in ``/usr/include/mylib.h``. If the headers are installed; in some other system root, the ``-isysroot`` option can be used provide; a different system root from which the headers will be based. For; example, ``-isysroot /Developer/SDKs/MacOSX10.4u.sdk`` will look for; ``mylib.h`` in ``/Developer/SDKs/MacOSX10.4u.sdk/usr/include/myl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:48686,depend,depends,48686,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['depend'],['depends']
Integrability,"n the stack. The heap object will live until the; delete operator is applied to it. There is no FORTRAN parallel to a heap object; variables either come; or go as control passes in and out of a function or subroutine, or,; like a COMMON block variables, live for the lifetime of the program.; However, most people in HEP who use FORTRAN will have experience of a; memory manager and the act of creating a bank is a good equivalent of; a heap object. For those who know systems like ZEBRA, it will come as; a relief to learn that objects do not move, C++ does not garbage; collect, so there is never a danger that a pointer to an object; becomes invalid for that reason. However, having created an object,; it is the user's responsibility to ensure that it is deleted when no; longer needed, or to pass that responsibility onto to some other; object. Failing to do that will result in a memory leak, one of the; most common and most hard-to-find C++ bugs. To send a message to an object via a pointer to it, you need to use; the ""`->`"" operator e.g.:. ``` {.cpp}; root[] my_objptr->Solve();; ```. Although we chose to call our pointer `my_objptr`, to emphasize that; it is a pointer, heap objects are so common in an object-oriented; program that pointer names rarely reflect the fact - you have to be; careful that you know if you are dealing with an object or its; pointer! Fortunately, the compiler won't tolerate an attempt to do; something like:. ``` {.cpp}; root[] my_objptr.Solve();; ```. As we have seen, heap objects; have to be accessed via pointers, whereas stack objects can be; accessed directly. They can also be accessed via pointers:. ``` {.cpp}; root[] Quad stack_quad(1.,2.,-3.);; root[] Quad *stack_ptr = &stack_quad;; root[] stack_ptr->Solve();; ```. Here we have a `Quad` pointer that has been initialized with the; address of a stack object. Be very careful if you take the address of; stack objects. As we shall see soon, they are deleted automatically,; which could leave you w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:11007,message,message,11007,documentation/users-guide/ALittleC++.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md,1,['message'],['message']
Integrability,"n this style is virtually possible but; highly not recommended. #### The Structure of Composite Shapes. A composite shape can always be looked as the result of a Boolean; operation between only two shape components. All information identifying; these two components as well as their positions with respect to the; frame of the composite is represented by an object called Boolean node.; A composite shape has a pointer to such a Boolean node. Since the shape; components may also be composites, they will also contain binary Boolean; nodes branching out other two shapes in the hierarchy. Any such branch; ends-up when the final leaves are no longer composite shapes, but basic; primitives. The figure shows the composite shapes structure. ![The composite shapes structure](pictures/080001CA.png). Suppose that A, B, C and D represent basic shapes, we will illustrate; how the internal representation of few combinations look like. We do; this only for understanding how to create them in a proper way, since; the user interface for this purpose is in fact very simple. We will; ignore for the time being the positioning of components. The definition; of a composite shape takes an expression where the identifiers are shape; names. The expression is parsed and decomposed in 2 sub-expressions and; the top-level Boolean operator. 1. Union: `A+B+C`. Just to illustrate the Boolean expression parsing and the composite; shape structure, let's take a simple example. We will describe the union; of A, B and C. Both union operators are at the same level. Since:. `A+B+C = (A+B)+C = A+(B+C)`. The first` (+)` is taken as separator, hence the expression split in:; `A` and `(B+C)`. A Boolean node of type **`TGeoUnion`**`(""A"",""B+C"")` is; created. This tries to replace the 2 expressions by actual pointers to; corresponding shapes. The first expression (A) contains no operators; therefore is interpreted as representing a shape. The shape named ""A"" is; searched into the list of shapes handled by the man",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:44358,interface,interface,44358,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['interface'],['interface']
Integrability,"n type. * TLS -- Argument and return value labels are passed through TLS variables; ``__dfsan_arg_tls`` and ``__dfsan_retval_tls``. The main advantage of the TLS ABI is that it is more tolerant of ABI mismatches; (TLS storage is not shared with any other form of storage, whereas extra; arguments may be stored in registers which under the native ABI are not used; for parameter passing and thus could contain arbitrary values). On the other; hand the args ABI is more efficient and allows ABI mismatches to be more easily; identified by checking for nonzero labels in nominally unlabelled programs. Implementing the ABI list; -------------------------. The `ABI list <DataFlowSanitizer.html#abi-list>`_ provides a list of functions; which conform to the native ABI, each of which is callable from an instrumented; program. This is implemented by replacing each reference to a native ABI; function with a reference to a function which uses the instrumented ABI.; Such functions are automatically-generated wrappers for the native functions.; For example, given the ABI list example provided in the user manual, the; following wrappers will be generated under the args ABI:. .. code-block:: llvm. define linkonce_odr { i8*, i16 } @""dfsw$malloc""(i64 %0, i16 %1) {; entry:; %2 = call i8* @malloc(i64 %0); %3 = insertvalue { i8*, i16 } undef, i8* %2, 0; %4 = insertvalue { i8*, i16 } %3, i16 0, 1; ret { i8*, i16 } %4; }. define linkonce_odr { i32, i16 } @""dfsw$tolower""(i32 %0, i16 %1) {; entry:; %2 = call i32 @tolower(i32 %0); %3 = insertvalue { i32, i16 } undef, i32 %2, 0; %4 = insertvalue { i32, i16 } %3, i16 %1, 1; ret { i32, i16 } %4; }. define linkonce_odr { i8*, i16 } @""dfsw$memcpy""(i8* %0, i8* %1, i64 %2, i16 %3, i16 %4, i16 %5) {; entry:; %labelreturn = alloca i16; %6 = call i8* @__dfsw_memcpy(i8* %0, i8* %1, i64 %2, i16 %3, i16 %4, i16 %5, i16* %labelreturn); %7 = load i16* %labelreturn; %8 = insertvalue { i8*, i16 } undef, i8* %6, 0; %9 = insertvalue { i8*, i16 } %8, i16 %7, 1; ret {",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:11228,wrap,wrappers,11228,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,1,['wrap'],['wrappers']
Integrability,"n using boost::any_cast; >>> extract = boost.any_cast[std.vector[int]](val) # correct cast; >>> type(extract) is std.vector[int]; True; >>> extract += xrange(100); >>> len(extract); 100; >>> val.__assign__(std.move(extract)) # move forced; <cppyy.gbl.boost.any object at 0xf6a8a0>; >>> len(extract) # now empty (or invalid); 0; >>> extract = boost.any_cast[std.vector[int]](val); >>> list(extract); [0, 1, 2, 3, 4, 5, 6, ..., 97, 98, 99]; >>>. Of course, there is no reason to use Boost from Python (in fact, this example; calls out for :doc:`pythonizations <pythonizations>`), but it shows that; cppyy seamlessly supports many advanced C++ features. cppyy is available for both `CPython`_ (v2 and v3) and `PyPy`_, reaching; C++-like performance with the latter.; It makes judicious use of precompiled headers, dynamic loading, and lazy; instantiation, to support C++ programs consisting of millions of lines of; code and many thousands of classes.; cppyy minimizes dependencies to allow its use in distributed, heterogeneous,; development environments. .. _Cling: https://github.com/vgvassilev/cling; .. _tutorial: https://github.com/wlav/cppyy/blob/master/doc/tutorial/CppyyTutorial.ipynb; .. _`PyHPC'16 paper`: http://wlav.web.cern.ch/wlav/Cppyy_LavrijsenDutta_PyHPC16.pdf; .. _`CAAS presentation`: https://www.youtube.com/watch?v=stMD7VDWlVU; .. _`Jason Turner's`: https://www.youtube.com/watch?v=TL83P77vZ1k; .. _`Boost`: http://www.boost.org/; .. _`CPython`: http://python.org; .. _`PyPy`: http://pypy.org. .. only: not latex. Contents:. .. toctree::; :maxdepth: 1. changelog; license. .. toctree::; :caption: Getting Started; :maxdepth: 1. installation; starting; examples; bugs. .. toctree::; :caption: Features; :maxdepth: 1. toplevel; basic_types; strings; classes; functions; type_conversions; stl; exceptions; python; numba; cuda; lowlevel; misc; debugging. .. toctree::; :caption: Redistribution; :maxdepth: 1. pythonizations; utilities; cmake_interface. .. toctree::; :caption: Developer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/index.rst:4563,depend,dependencies,4563,bindings/pyroot/cppyy/cppyy/doc/source/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/index.rst,1,['depend'],['dependencies']
Integrability,"n you're; done with it. ### Use of Python Functions. It is possible to mix Python functions with ROOT and perform such; operations as plotting and fitting of histograms with them. In all; cases, the procedure consists of instantiating a ROOT **`TF1`**,; **`TF2`**, or **`TF3`** with the Python function and working with that; ROOT object. There are some memory issues, so it is for example not yet; possible to delete a **`TF1`** instance and then create another one with; the same name. In addition, the Python function, once used for; instantiating the **`TF1`**, is never deleted. Instead of a Python function, you can also use callable instances (e.g.,; an instance of a class that has implemented the `__call__` member; function). The signature of the Python callable should provide for one; or two arrays. The first array, which must always be present, shall; contain the `x`, `y`, `z`, and t values for the call. The second array,; which is optional and its size depends on the number given to the; **`TF1`** constructor, contains the values that parameterize the; function. For more details, see the **`TF1`** documentation and the; examples below. #### Plotting Python Function. This is an example of a parameter less Python function that is plotted; on a default canvas:. ``` {.cpp}; from ROOT import TF1, TCanvas. def identity( x ):; return x[0]. # create an identity function; f = TF1('pyf1', identity, -1., 1.). # plot the function; c = TCanvas(); f.Draw(); ```. Because no number of parameters is given to the **`TF1`** constructor,; '`0`' (the default) is assumed. This way, the '`identity'` function need; not handle a second argument, which would normally be used to pass the; function parameters. Note that the argument '`x`' is an array of size 4.; The following is an example of a parameterized Python callable instance; that is plotted on a default canvas:. ``` {.cpp}; from ROOT import TF1, TCanvas. class Linear:; def __call__( self, x, par ):; return par[0] + x[0]*par[1]. # c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:25847,depend,depends,25847,documentation/users-guide/PythonRuby.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md,1,['depend'],['depends']
Integrability,"n, like v = p*q + w. Due to the; expression template technique, no temporary objects are created in this operation.; * Construct a vector passing directly the elements. This is possible only for vector up to size 10.; * Constructor from an iterator copying the data referred by the iterator. It is possible; to specify the _begin_ and _end_ of the iterator or the _begin_ and the size. Note that; for the Vector the iterator is not generic and must be of type _T*,_ where T is the type; of the contained elements. Here are some examples on how to create a vector. In the following we assume that we are; using the namespace ROOT::Math. ~~~ {.cpp}; SVector<double,N> v; // create a vector of size N, v[i]=0; SVector<double,3> v(1,2,3); // create a vector of size 3, v[0]=1,v[1]=2,v[2]=3; double a[9] = {1,2,3,4,5,6,7,8,9}; // input data; SVector<double,9> v(a,9); // create a vector using the a[] data; ~~~. ### Accessing and Setting Methods. The single vector elements can be set or retrieved using the _operator[i]_ , _operator(i)_; or the iterator interface. Notice that the index starts from zero and not from one as in; FORTRAN. Also no check is performed on the passed index. Furthermore, all the matrix; elements can be set also by using the ROOT::SVector::SetElements function passing a generic; iterator. The elements can be accessed also by using the ROOT::Math::SVector::apply(i) function. ~~~ {.cpp}; v[0] = 1; // set the first element; v(1) = 2; // set the second element; *(v.begin()+3) = 3; // set the third element; // set vector elements from a std::vector<double>::iterator</double>; std::vector <double> w(3);; v.SetElements(w.begin(),w.end());. double x = m(i); // return the i-th element; x = m.apply(i); // return the i-th element; x = *(m.begin()+i); // return the i-th element; ~~~. In addition there are methods to place a sub-vector in a vector. If the size of the the; sub-vector is larger than the vector size a static assert ( a compilation error) is produced. ~~~ {.cpp}; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/doc/SVector.md:1515,interface,interface,1515,math/smatrix/doc/SVector.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/doc/SVector.md,1,['interface'],['interface']
Integrability,"n, such as; ""did you forget ';'?"", should still do so. For example this is a good error message:. .. code-block:: none. error: file.o: section header 3 is corrupt. Size is 10 when it should be 20. This is a bad message, since it does not provide useful information and uses the; wrong style:. .. code-block:: none. error: file.o: Corrupt section header. As with other coding standards, individual projects, such as the Clang Static; Analyzer, may have preexisting styles that do not conform to this. If a; different formatting scheme is used consistently throughout the project, use; that style instead. Otherwise, this standard applies to all LLVM tools,; including clang, clang-tidy, and so on. If the tool or project does not have existing functions to emit warnings or; errors, use the error and warning handlers provided in ``Support/WithColor.h``; to ensure they are printed in the appropriate style, rather than printing to; stderr directly. When using ``report_fatal_error``, follow the same standards for the message as; regular error messages. Assertion messages and ``llvm_unreachable`` calls do not; necessarily need to follow these same styles as they are automatically; formatted, and thus these guidelines may not be suitable. ``#include`` Style; ^^^^^^^^^^^^^^^^^^. Immediately after the `header file comment`_ (and include guards if working on a; header file), the `minimal list of #includes`_ required by the file should be; listed. We prefer these ``#include``\s to be listed in this order:. .. _Main Module Header:; .. _Local/Private Headers:. #. Main Module Header; #. Local/Private Headers; #. LLVM project/subproject headers (``clang/...``, ``lldb/...``, ``llvm/...``, etc); #. System ``#include``\s. and each category should be sorted lexicographically by the full path. The `Main Module Header`_ file applies to ``.cpp`` files which implement an; interface defined by a ``.h`` file. This ``#include`` should always be included; **first** regardless of where it lives on the fi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:15497,message,message,15497,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,2,['message'],"['message', 'messages']"
Integrability,"n, this stream is saved in the emitter class member; named ``OS``, although some ``run`` functions are simple and just use the; stream without saving it. The output can be produced by writing values; directly to the output stream, or by using the ``std::format()`` or; ``llvm::formatv()`` functions. .. code-block:: text. OS << ""#ifndef "" << NodeName << ""\n"";. OS << format(""0x%0*x, "", Digits, Value);. Instances of the following classes can be printed using the ``<<`` operator:; ``RecordKeeper``,; ``Record``,; ``RecTy``,; ``RecordVal``, and; ``Init``. The helper function ``emitSourceFileHeader()`` prints the header comment; that should be included at the top of every output file. A call to it is; included in the skeleton backend file ``TableGenBackendSkeleton.cpp``. Printing Error Messages; =======================. TableGen records are often derived from multiple classes and also often; defined through a sequence of multiclasses. Because of this, it can be; difficult for backends to report clear error messages with accurate source; file locations. To make error reporting easier, five error reporting; functions are provided, each with four overloads. * ``PrintWarning`` prints a message tagged as a warning. * ``PrintError`` prints a message tagged as an error. * ``PrintFatalError`` prints a message tagged as an error and then terminates. * ``PrintNote`` prints a note. It is often used after one of the previous; functions to provide more information. * ``PrintFatalNote`` prints a note and then terminates. Each of these five functions is overloaded four times. * ``PrintError(const Twine &Msg)``:; Prints the message with no source file location. * ``PrintError(ArrayRef<SMLoc> ErrorLoc, const Twine &Msg)``:; Prints the message followed by the specified source line,; along with a pointer to the item in error. The array of; source file locations is typically taken from a ``Record`` instance. * ``PrintError(const Record *Rec, const Twine &Msg)``:; Prints the message followed by",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst:23750,message,messages,23750,interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,1,['message'],['messages']
Integrability,"n-database P1689.json. And we will get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""Impl.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ]; },; {; ""primary-output"": ""M.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; },; {; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ]; },; {; ""primary-output"": ""User.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; },; {; ""logical-name"": ""third_party_module""; }; ]; },; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; },; {; ""primary-output"": ""interface_part.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; }; ],; ""version"": 1; }. See the P1689 paper for the meaning of the fields. And if the user want a finer-grained control for any reason, e.g., to scan the generated source files,; the user can choose to get the dependency information per file. For example:. .. code-block:: console. $ clang-scan-deps -format=p1689 -- <path-to-compiler-executable>/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o. And we'll get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part""; }; ]; }; ],; ""version"": 1; }. In this way, we can pass the single command line options after the ``--``.; Then clang-scan-deps will extract the necessary information from the options.; Note that we need to specify the path to the compiler executable instea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:35897,interface,interface,35897,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['interface'],['interface']
Integrability,"n-empty list but now the user wishes to disable building all other projects; # by setting `LLVM_ENABLE_PROJECTS` to an empty string. In that case we still; # need to set the `LLVM_TOOL_${upper_proj}_BUILD` variables so that we disable; # building all the projects that were previously enabled.; set(LLVM_ENABLE_PROJECTS_USED OFF CACHE BOOL """"); mark_as_advanced(LLVM_ENABLE_PROJECTS_USED). if (LLVM_ENABLE_PROJECTS_USED OR NOT LLVM_ENABLE_PROJECTS STREQUAL """"); set(LLVM_ENABLE_PROJECTS_USED ON CACHE BOOL """" FORCE); foreach(proj ${LLVM_KNOWN_PROJECTS} ${LLVM_EXTERNAL_PROJECTS}); string(TOUPPER ""${proj}"" upper_proj); string(REGEX REPLACE ""-"" ""_"" upper_proj ${upper_proj}); if (""${proj}"" IN_LIST LLVM_ENABLE_PROJECTS); message(STATUS ""${proj} project is enabled""); set(SHOULD_ENABLE_PROJECT TRUE); set(PROJ_DIR ""${CMAKE_CURRENT_SOURCE_DIR}/../${proj}""); if(NOT EXISTS ""${PROJ_DIR}"" OR NOT IS_DIRECTORY ""${PROJ_DIR}""); message(FATAL_ERROR ""LLVM_ENABLE_PROJECTS requests ${proj} but directory not found: ${PROJ_DIR}""); endif(); if( LLVM_EXTERNAL_${upper_proj}_SOURCE_DIR STREQUAL """" ); set(LLVM_EXTERNAL_${upper_proj}_SOURCE_DIR ""${CMAKE_CURRENT_SOURCE_DIR}/../${proj}"" CACHE PATH """" FORCE); else(); set(LLVM_EXTERNAL_${upper_proj}_SOURCE_DIR ""${CMAKE_CURRENT_SOURCE_DIR}/../${proj}"" CACHE PATH """"); endif(); elseif (""${proj}"" IN_LIST LLVM_EXTERNAL_PROJECTS); message(STATUS ""${proj} project is enabled""); set(SHOULD_ENABLE_PROJECT TRUE); else(); message(STATUS ""${proj} project is disabled""); set(SHOULD_ENABLE_PROJECT FALSE); endif(); # Force `LLVM_TOOL_${upper_proj}_BUILD` variables to have values that; # corresponds with `LLVM_ENABLE_PROJECTS`. This prevents the user setting; # `LLVM_TOOL_${upper_proj}_BUILD` variables externally. At some point; # we should deprecate allowing users to set these variables by turning them; # into normal CMake variables rather than cache variables.; set(LLVM_TOOL_${upper_proj}_BUILD; ${SHOULD_ENABLE_PROJECT}; CACHE; BOOL ""Whether to build ${upper_proj} as par",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:9237,message,message,9237,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['message'],['message']
Integrability,n-object prvalues and constant expressions; Unknown. 2130; CD4; Over-aligned types in new-expressions; Unknown. 2131; drafting; Ambiguity with opaque-enum-declaration; Not resolved. 2132; NAD; Deprecated default generated copy constructors; Unknown. 2133; CD5; Converting std::nullptr_t to bool; Unknown. 2134; NAD; Objectless references to non-static member functions; Unknown. 2135; NAD; mem-initializers for virtual bases of abstract classes; Unknown. 2136; NAD; Argument-dependent lookup and initializer lists; Unknown. 2137; CD4; List-initialization from object of same type; Unknown. 2138; NAD; Explicit member specialization vs implicit instantiation; Unknown. 2139; NAD; Floating-point requirements for integer representation; Unknown. 2140; CD4; Lvalue-to-rvalue conversion of std::nullptr_t; Clang 9. 2141; CD4; Ambiguity in new-expression with elaborated-type-specifier; Clang 17. 2142; NAD; Missing definition of associated classes and namespaces; Unknown. 2143; C++17; Value-dependency via injected-class-name; Unknown. 2144; drafting; Function/variable declaration ambiguity; Not resolved. 2145; CD4; Parenthesized declarator in function definition; Unknown. 2146; CD4; Scalar object vs memory location in definition of “unsequenced”; Unknown. 2147; CD4; Initializer-list arguments and pack deduction; Unknown. 2148; drafting; Thread storage duration and order of initialization; Not resolved. 2149; drafting; Brace elision and array length deduction; Not resolved. 2150; CD3; Initializer list array lifetime; Unknown. 2151; CD4; Exception object is not created; Unknown. 2152; NAD; Can an alternative token be used as a ud-suffix?; Unknown. 2153; CD4; pure-specifier in friend declaration; Unknown. 2154; CD4; Ambiguity of pure-specifier; Unknown. 2155; C++17; Defining classes and enumerations via using-declarations; Unknown. 2156; CD4; Definition of enumeration declared by using-declaration; Unknown. 2157; CD4; Further disambiguation of enumeration elaborated-type-specifier; Clan,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:145959,depend,dependency,145959,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,4,"['depend', 'inject']","['dependency', 'injected-class-name']"
Integrability,"n; ===============. There is an integration for :program:`vim` which lets you run the; :program:`clang-format` standalone tool on your current buffer, optionally; selecting regions to reformat. The integration has the form of a `python`-file; which can be found under `clang/tools/clang-format/clang-format.py`. This can be integrated by adding the following to your `.vimrc`:. .. code-block:: vim. if has('python'); map <C-K> :pyf <path-to-this-file>/clang-format.py<cr>; imap <C-K> <c-o>:pyf <path-to-this-file>/clang-format.py<cr>; elseif has('python3'); map <C-K> :py3f <path-to-this-file>/clang-format.py<cr>; imap <C-K> <c-o>:py3f <path-to-this-file>/clang-format.py<cr>; endif. The first line enables :program:`clang-format` for NORMAL and VISUAL mode, the; second line adds support for INSERT mode. Change ""C-K"" to another binding if; you need :program:`clang-format` on a different key (C-K stands for Ctrl+k). With this integration you can press the bound key and clang-format will; format the current line in NORMAL and INSERT mode or the selected region in; VISUAL mode. The line or region is extended to the next bigger syntactic; entity. It operates on the current, potentially unsaved buffer and does not create; or save any files. To revert a formatting, just undo. An alternative option is to format changes when saving a file and thus to; have a zero-effort integration into the coding workflow. To do this, add this to; your `.vimrc`:. .. code-block:: vim. function! Formatonsave(); let l:formatdiff = 1; pyf <path-to-this-file>/clang-format.py; endfunction; autocmd BufWritePre *.h,*.cc,*.cpp call Formatonsave(). Emacs Integration; =================. Similar to the integration for :program:`vim`, there is an integration for; :program:`emacs`. It can be found at `clang/tools/clang-format/clang-format.el`; and used by adding this to your `.emacs`:. .. code-block:: common-lisp. (load ""<path-to-clang>/tools/clang-format/clang-format.el""); (global-set-key [C-M-tab] 'clang-format",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst:7258,integrat,integration,7258,interpreter/llvm-project/clang/docs/ClangFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst,1,['integrat'],['integration']
Integrability,"n; Omitted typedef declarator; Not resolved. 158; CD1; Aliasing and qualification conversions; Yes. 159; TC1; Namespace qualification in declarators; Clang 3.5. 160; CD1; Missing std:: qualification; N/A. 161; TC1; Access to protected nested type; Clang 3.1. 162; CD1; (&C::f)() with nonstatic members; No. 163; TC1; Description of subaggregate initializer; N/A. 164; TC1; Overlap between Koenig and normal lookup; Yes. 165; NAD; Definitions of friends and block-scope externs; No. 166; TC1; Friend declarations of template-ids; Clang 2.9. 167; NAD; Deprecating static functions; Superseded by 1012. 168; NAD; C linkage for static member functions; No. 169; NAD; template-ids in using-declarations; Yes. 170; DRWP; Pointer-to-member conversions; Unknown. 171; TC1; Global namespace scope; Clang 3.4. 172; CD1; Unsigned int as underlying type of enum; Yes. 173; TC1; Constraints on execution character set; Yes. 174; NAD; Undeprecating global static; Superseded by 1012. 175; CD1; Class name injection and base name access; Clang 2.8. 176; TC1; Name injection and templates; Clang 3.1. 177; CD1; Lvalues vs rvalues in copy-initialization; Yes. 178; TC1; More on value-initialization; Yes. 179; TC1; Function pointers and subtraction; Yes. 180; CD1; typename and elaborated types; Clang 2.8. 181; TC1; Errors in template template-parameter example; Yes. 182; NAD; Access checking on explicit specializations; Clang 14. 183; TC1; typename in explicit specializations; Superseded by 382. 184; CD1; Default arguments in template template-parameters; Yes. 185; TC1; ""Named"" temporaries and copy elision; Unknown. 186; open; Name hiding and template template-parameters; Not resolved. 187; TC1; Scope of template parameter names; Superseded by 481. 188; TC1; Comma operator and rvalue conversion; Yes. 189; drafting; Definition of operator and punctuator; Not resolved. 190; TC1; Layout-compatible POD-struct types; Unknown. 191; CD6; Name lookup does not handle complex nesting; Yes. 192; NAD; Name lookup ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:11726,inject,injection,11726,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['inject'],['injection']
Integrability,n; Unknown. 2017; CD4; Flowing off end is not equivalent to no-expression return; Unknown. 2018; dup; Qualification conversion vs reference binding; Unknown. 2019; CD4; Member references omitted from description of storage duration; Unknown. 2020; CD5; Inadequate description of odr-use of implicitly-invoked functions; Unknown. 2021; dup; Function template redeclaration via alias template; Unknown. 2022; CD4; Copy elision in constant expressions; Unknown. 2023; drafting; Composite reference result type of conditional operator; Not resolved. 2024; CD4; Dependent types and unexpanded parameter packs; Unknown. 2025; dup; Declaration matching via alias templates; Unknown. 2026; CD4; Zero-initialization and constexpr; Clang 11. 2027; CD4; Unclear requirements for multiple alignas specifiers; Unknown. 2028; drafting; Converting constructors in rvalue reference initialization; Not resolved. 2029; dup; Abstract class return type in decltype operand; Unknown. 2030; NAD; Access of injected-class-name with template arguments; Unknown. 2031; CD4; Missing incompatibility for &&; Unknown. 2032; CD4; Default template-arguments of variable templates; Unknown. 2033; CD4; Redundant restriction on partial specialization argument; Unknown. 2034; NAD; Deprecating uncaught_exception(); Unknown. 2035; CD3; Multi-section example is confusing; Unknown. 2036; NAD; Refactoring parameters-and-qualifiers; Unknown. 2037; drafting; Alias templates and template declaration matching; Not resolved. 2038; CD4; Document C++14 incompatibility of new braced deduction rule; Unknown. 2039; CD4; Constant conversions to bool; Unknown. 2040; CD4; trailing-return-type no longer ambiguous; Unknown. 2041; CD4; Namespace for explicit class template specialization; Unknown. 2042; drafting; Exceptions and deallocation functions; Not resolved. 2043; drafting; Generalized template arguments and array-to-pointer decay; Not resolved. 2044; CD4; decltype(auto) and void; Unknown. 2045; CD5; “Identical” template parameter ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:138023,inject,injected-class-name,138023,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['inject'],['injected-class-name']
Integrability,"nal the strategy; level in MnStrategy can be specified. ### MnSimplex(const FCNBase&, const MnUserParameters&,\; unsigned int) ###. Constructor for high level parameters interface. Optional the strategy; level in MnStrategy can be specified. ### MnSimplex(const FCNBase&, const MnUserParameterState&,\; const MnStrategy&) ###. Constructor from a full state (parameters + covariance) as starting; input plus the desired strategy. ### operator() ###. MnSimplex::operator()(unsigned int maxfcn, double tolerance) causes; minimization of the $\mbox{FCN}$ and returns the result in form of a; FunctionMinimum. Minimization terminates either when the function has; been called (approximately) $\mbox{maxfcn}$ times, or when the; estimated vertical distance to minimum ($\mbox{EDM}$) is less than; $\mbox{tolerance*up}$. The default value of $\mbox{tolerance}$; is $\mbox{0.1}$. (see [howto:errordef]). ### Parameter interaction ###. MnSimplex retains the result after each minimization; (MnUserParameterStae, see [api:state]) and forwards the interface for; parameter interaction. ### SimplexMinimizer() ###. The SimplexMinimizer() is instantiated using default constructor. ### minimize(const FCNBase&, ...) ###. The SimplexMinimizer provides several overloaded methods minimize with; return value FunctionMinimum. Together with the user $\mbox{FCN}$; (either an implementation of FCNBase or FCNGradientBase) the user has to; give as input the parameters with starting values in one of the defined; formats (std::vector$<$double$>$, MnUserParameters or; MnUserParameterState). ## MnStrategy ##. [api:strategy] Sets the strategy to be used in calculating first and; second derivatives and in certain minimization methods. In general, low; values of $\mbox{level}$ mean fewer function calls and high values; mean more reliable minimization. Currently allowed values are 0 (low), 1; (default), and 2 (high). ### MnStrategy() ###. Default constructor, sets all settings according to; $\mbox{level}$$ = 1.$. ##",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:50362,interface,interface,50362,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['interface'],['interface']
Integrability,"nals; =========================. .. contents::; :local:. Introduction; ============. This document describes the Clang driver. The purpose of this document; is to describe both the motivation and design goals for the driver, as; well as details of the internal implementation. Features and Goals; ==================. The Clang driver is intended to be a production quality compiler driver; providing access to the Clang compiler and tools, with a command line; interface which is compatible with the gcc driver. Although the driver is part of and driven by the Clang project, it is; logically a separate tool which shares many of the same goals as Clang:. .. contents:: Features; :local:. GCC Compatibility; -----------------. The number one goal of the driver is to ease the adoption of Clang by; allowing users to drop Clang into a build system which was designed to; call GCC. Although this makes the driver much more complicated than; might otherwise be necessary, we decided that being very compatible with; the gcc command line interface was worth it in order to allow users to; quickly test clang on their projects. Flexible; --------. The driver was designed to be flexible and easily accommodate new uses; as we grow the clang and LLVM infrastructure. As one example, the driver; can easily support the introduction of tools which have an integrated; assembler; something we hope to add to LLVM in the future. Similarly, most of the driver functionality is kept in a library which; can be used to build other tools which want to implement or accept a gcc; like interface. Low Overhead; ------------. The driver should have as little overhead as possible. In practice, we; found that the gcc driver by itself incurred a small but meaningful; overhead when compiling many small files. The driver doesn't do much; work compared to a compilation, but we have tried to keep it as; efficient as possible by following a few simple principles:. - Avoid memory allocation and string copying when possi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:1082,interface,interface,1082,interpreter/llvm-project/clang/docs/DriverInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst,1,['interface'],['interface']
Integrability,"name can include printf qualifier to code pad number. Also allows to store all pads in single PDF; or single ROOT file. Significantly improves performance when creating many image files using web graphics. - Introduce `TCanvas::UpdateAsync` method. In case of web-based canvas triggers update of the canvas on the client side,; but does not wait that real update is completed. Avoids blocking of caller thread.; Have to be used if called from other web-based widget to avoid logical dead-locks.; In case of normal canvas just canvas->Update() is performed. - The Delaunay triangles (used by TGraph2D) were computed by the external package `triangle.c`; included in the ROOT distribution. This package had several issues:; - It was not maintained anymore.; - Its license was not compatible with LGPL; This code is now replaced by the [CDT package](https://github.com/artem-ogre/CDT) which is; properly maintained and has a license (MLP) compatible with LGPL. It will appear in 6.03.02. ## Machine Learning integration. - ROOT now offers functionality to extract batches of events out of a dataset for use in common ML training workflows. For example, one can generate PyTorch tensors from a TTree. The functionality is available through the `RBatchGenerator` class and can be seamlessly integrated in user code, for example:; ```python; # Returns two generators that return training and validation batches as PyTorch tensors.; gen_train, gen_validation = ROOT.TMVA.Experimental.CreatePyTorchGenerators(; tree_name, file_name, batch_size, chunk_size, target=target, validation_split=0.3); ```; The functionality is also available for TensorFlow datasets and Python generators of numpy arrays. See more in the `RBatchGenerator*` tutorials under the TMVA folder. ## 3D Graphics Libraries. ## Geometry Libraries. ## Database Libraries. ## Networking Libraries. ## GUI Libraries. ## Montecarlo Libraries. ## PROOF Libraries. ## Language Bindings. ## JavaScript ROOT. - The default `TCanvas` and `TBrowser` i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md:20672,integrat,integration,20672,README/ReleaseNotes/v630/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md,1,['integrat'],['integration']
Integrability,"nce; All classes along with their derived and base classes are shown in the; Class Hierarchy.; The documentation for each class also shows the inheritance diagram.; The class hierarchy is meant to give an overview of available classes; and their relations. Modules; What they are; Classes are grouped into modules. For ROOT, this is done on a per-directory basis:; each module corresponds to a sub-directory. In other cases one module might represent; one library. Either way, modules are meant to combine similar or related classes,; allowing users to find classes close by context. If you need some functionality that; you cannot find in a class you know, you might want to check for classes in the same; module - maybe one of them does what you need. List of Modules; Modules are listed ontop of the Class Index and as part; of the Library Dependencies Chart. Modules' Library Dependencies; Each module is assumed to be part of a library. The dependencies of libraries are; not only relevant for linking, but often reflect also the contextual dependencies.; The dependencies of all modules are shown in the; Library Dependencies Chart. Class Reference; Pages like the one for TH2 are; class references. They document the use and functionality of a class. Sections; Each class reference page has a class documentation, which documents what the class; can be used for, and gives hints on how to use it. This allows you to figure out; whether a certain class is appropriate for what you try to do. The page then lists; all available members; they define a class's functionality and its interaction with; your code. The next item is a tabbed set of charts, which allow you to study the; class's inheritance diagram, what members get inherited from where, and which members; are re-implemented, which files get indirectly included by including the class's; header, and which libraries this class depends on. The remainder of the page contains; the functions' documentation. And there is a little tool b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/etc/html/HELP.html:1900,depend,dependencies,1900,etc/html/HELP.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/etc/html/HELP.html,4,['depend'],['dependencies']
Integrability,"nced collection of functions and; C++ classes for numerical computing. This is an extension of the; functionality provided by the `MathCore` library.; The `MathMore` library is implemented wrapping in C++ the GNU Scientific Library (GSL).; The current set, provided in; the `ROOT::Math` namespace; include:. - Special mathematical functions (like Bessel functions, Legendre polynomials, etc.. ). - Additional mathematical functions used in statistics such as probability density; functions, cumulative distributions functions and their inverse which are not in `MathCore` but present in; the `GSL` library. - Numerical algorithms for one dimensional functions based on; implementation of the GNU Scientific Library (GSL):. - Numerical integration classes implementing the interface **`ROOT::Math::Integrator`**; which is based on the Adaptive integration algorithms of QUADPACK. - Numerical differentiation via **`ROOT::Math::GSLDerivator`**. - Root finder implementing the **`ROOT::Math::RootFinder`** interface, using different; solver algorithms from GSL. - one-dimensional Minimization implementing the interface**`ROOT::Math::IMinimizer1D`**. - Interpolation via **`ROOT::Math::Interpolation`**. All the GSL; interpolation types are supported. - Function approximation based on Chebyshev polynomials via the class; **`ROOT::Math::Chebyshev`**. - Random number generators and distributions based on GSL using the `ROOT::Math::Random<Engine_type>` class. - Polynomial evaluation and root solvers. The mathematical functions are implemented as a set of free functions in; the namespace **`ROOT::Math`**. The naming used for the special; functions is the same proposed for the C++ standard (see C++ standard; extension [proposal document](proposal document)).The `MathMore` library; is implemented wrapping in C++ the GNU Scientific Library ( <GSL>).; Building `MathMore` requires a version of GSL larger or equal 1.8. The; source code of `MathMore` is distributed under the GNU General Public; Lice",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:4102,interface,interface,4102,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['interface'],['interface']
Integrability,"nces to operands must account for that. .. code-block:: c++. int foo(int x) {; // %0 and %1 both refer to x; // %l2 refers to err; asm goto(""# %0 %1 %l2"" : ""+r""(x) : : : err);; return x;; err:; return -1;; }. This was changed to match GCC in clang-13; for better portability, symbolic; references can be used instead of numeric references. .. code-block:: c++. int foo(int x) {; asm goto(""# %[x] %l[err]"" : [x]""+r""(x) : : : err);; return x;; err:; return -1;; }. Objective-C Features; ====================. Related result types; --------------------. According to Cocoa conventions, Objective-C methods with certain names; (""``init``"", ""``alloc``"", etc.) always return objects that are an instance of; the receiving class's type. Such methods are said to have a ""related result; type"", meaning that a message send to one of these methods will have the same; static type as an instance of the receiver class. For example, given the; following classes:. .. code-block:: objc. @interface NSObject; + (id)alloc;; - (id)init;; @end. @interface NSArray : NSObject; @end. and this common initialization pattern. .. code-block:: objc. NSArray *array = [[NSArray alloc] init];. the type of the expression ``[NSArray alloc]`` is ``NSArray*`` because; ``alloc`` implicitly has a related result type. Similarly, the type of the; expression ``[[NSArray alloc] init]`` is ``NSArray*``, since ``init`` has a; related result type and its receiver is known to have the type ``NSArray *``.; If neither ``alloc`` nor ``init`` had a related result type, the expressions; would have had type ``id``, as declared in the method signature. A method with a related result type can be declared by using the type; ``instancetype`` as its result type. ``instancetype`` is a contextual keyword; that is only permitted in the result type of an Objective-C method, e.g. .. code-block:: objc. @interface A; + (instancetype)constructAnA;; @end. The related result type can also be inferred for some methods. To determine; whether a m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:68564,interface,interface,68564,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['interface'],['interface']
Integrability,"nchanging source does not; require serialization of the runs according to the build dependency; graph. Supported Systems; =================. Clang has the ability to generate compilation database fragments via; ``-MJ argument <clang -MJ\<arg>>``. You can concatenate those; fragments together between ``[`` and ``]`` to create a compilation database. Currently `CMake <https://cmake.org>`_ (since 2.8.5) supports generation; of compilation databases for Unix Makefile builds (Ninja builds in the; works) with the option ``CMAKE_EXPORT_COMPILE_COMMANDS``. For projects on Linux, there is an alternative to intercept compiler; calls with a tool called `Bear <https://github.com/rizsotto/Bear>`_. `Bazel <https://bazel.build>`_ can export a compilation database via; `this extractor extension; <https://github.com/hedronvision/bazel-compile-commands-extractor>`_.; Bazel is otherwise resistant to Bear and other compiler-intercept; techniques. Clang's tooling interface supports reading compilation databases; see; the :doc:`LibTooling documentation <LibTooling>`. libclang and its; python bindings also support this (since clang 3.2); see; `CXCompilationDatabase.h </doxygen/group__COMPILATIONDB.html>`_. Format; ======. A compilation database is a JSON file, which consist of an array of; ""command objects"", where each command object specifies one way a; translation unit is compiled in the project. Each command object contains the translation unit's main file, the; working directory of the compile run and the actual compile command. Example:. ::. [; { ""directory"": ""/home/user/llvm/build"",; ""arguments"": [""/usr/bin/clang++"", ""-Irelative"", ""-DSOMEDEF=With spaces, quotes and \\-es."", ""-c"", ""-o"", ""file.o"", ""file.cc""],; ""file"": ""file.cc"" },. { ""directory"": ""/home/user/llvm/build"",; ""command"": ""/usr/bin/clang++ -Irelative -DSOMEDEF=\""With spaces, quotes and \\-es.\"" -c -o file.o file.cc"",; ""file"": ""file2.cc"" },. ...; ]. The contracts for each field in the command object are:. - **directory:** The",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst:2078,interface,interface,2078,interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst,1,['interface'],['interface']
Integrability,"nclude ""GaussDataGen.h""; #include ""Minuit/FunctionMinimum.h""; #include ""Minuit/MnUserParameterState.h""; #include ""Minuit/MinimumPrint.h""; #include ""Minuit/MnMigrad.h""; #include ""Minuit/MnMinos.h""; #include ""Minuit/MnContours.h""; #include ""Minuit/MnPlot.h"". #include <iostream>. int main() {. // generate the data (100 data points); GaussDataGen gdg(100);. std::vector<double> pos = gdg.positions();; std::vector<double> meas = gdg.measurements();; std::vector<double> var = gdg.variances();. // create FCN function; GaussFcn theFCN(meas, pos, var);. // create initial starting values for parameters; double x = 0.;; double x2 = 0.;; double norm = 0.;; double dx = pos[1]-pos[0];; double area = 0.;; for(unsigned int i = 0; i < meas.size(); i++) {; norm += meas[i];; x += (meas[i]*pos[i]);; x2 += (meas[i]*pos[i]*pos[i]);; area += dx*meas[i];; }; double mean = x/norm;; double rms2 = x2/norm - mean*mean;; double rms = rms2 > 0. ? sqrt(rms2) : 1.;. {; // demonstrate minimal required interface for minimization; // create Minuit parameters without names. // starting values for parameters; std::vector<double> init_par;; init_par.push_back(mean);; init_par.push_back(rms);; init_par.push_back(area);. // starting values for initial uncertainties; std::vector<double> init_err;; init_err.push_back(0.1);; init_err.push_back(0.1);; init_err.push_back(0.1);. // create minimizer (default constructor); VariableMetricMinimizer theMinimizer;. // minimize; FunctionMinimum min =; theMinimizer.minimize(theFCN, init_par, init_err);. // output; std::cout<<""minimum: ""<<min<<std::endl;; }. {; // demonstrate standard minimization using MIGRAD; // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create MIGRAD minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // output; std::cout<<""minimum: ""<<min<<std::endl;; }. {; // demonstrate full interaction with parameters ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:78830,interface,interface,78830,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['interface'],['interface']
Integrability,"nctionality and dependent on external libraries like the GNU Scientific Library ([GSL](http://www.gnu.org/software/gsl/)). It complements the MathCore library by providing a more complete sets of special mathematical functions and implementations of the numerical algorithms interfaces defined in MathCore using GSL. - **Minimization and Fitting Libraries**; Libraries required for numerical minimization and fitting. The minimization libraries include the numerical methods for solving the fitting problem by finding minimum of multi-dimensional; function. The current common interface for minimization is the class ROOT::Math::Minimizer and implemented by derived classes in the minimization and fitting libraries. The fitting in %ROOT is; organized in fitting classes present in MathCore in the (ROOT::Fit namespace) for providing the fitting functionality and the use the minimization libraries via the common interface (ROOT::Math::Minimizer). In detail the minimization libraries, implementing all the new and old minimization interface, include:. - \ref MinuitOld ""Minuit"": library providing via a class TMinuit an implementation of the popular MINUIT minimization package. In addition the library contains also an implementation of the linear fitter (class TLinearFitter), for solving linear least square fits.; - \ref Minuit2Page ""Minuit2"": new object-oriented implementation of MINUIT, with the same minimization algorithms (such as Migrad or Simplex). In addition it provides a new implementation of the Fumili algorithm, a specialized method for finding the minimum of a standard least square or likelihood functions.; - **Fumili**: library providing the implementation of the original Fumili fitting algorithm (class TFumili). - **Linear algebra**. Two libraries are contained in %ROOT for describing linear algebra matrices and vector classes:. - Matrix: general matrix package providing matrix classes (TMatrixD and TMatrixF) and vector classes (TVectorD and TVectorF) and the complete ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/index.md:1755,interface,interface,1755,math/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/index.md,1,['interface'],['interface']
Integrability,"nctionality provided by the `MathCore` library.; The `MathMore` library is implemented wrapping in C++ the GNU Scientific Library (GSL).; The current set, provided in; the `ROOT::Math` namespace; include:. - Special mathematical functions (like Bessel functions, Legendre polynomials, etc.. ). - Additional mathematical functions used in statistics such as probability density; functions, cumulative distributions functions and their inverse which are not in `MathCore` but present in; the `GSL` library. - Numerical algorithms for one dimensional functions based on; implementation of the GNU Scientific Library (GSL):. - Numerical integration classes implementing the interface **`ROOT::Math::Integrator`**; which is based on the Adaptive integration algorithms of QUADPACK. - Numerical differentiation via **`ROOT::Math::GSLDerivator`**. - Root finder implementing the **`ROOT::Math::RootFinder`** interface, using different; solver algorithms from GSL. - one-dimensional Minimization implementing the interface**`ROOT::Math::IMinimizer1D`**. - Interpolation via **`ROOT::Math::Interpolation`**. All the GSL; interpolation types are supported. - Function approximation based on Chebyshev polynomials via the class; **`ROOT::Math::Chebyshev`**. - Random number generators and distributions based on GSL using the `ROOT::Math::Random<Engine_type>` class. - Polynomial evaluation and root solvers. The mathematical functions are implemented as a set of free functions in; the namespace **`ROOT::Math`**. The naming used for the special; functions is the same proposed for the C++ standard (see C++ standard; extension [proposal document](proposal document)).The `MathMore` library; is implemented wrapping in C++ the GNU Scientific Library ( <GSL>).; Building `MathMore` requires a version of GSL larger or equal 1.8. The; source code of `MathMore` is distributed under the GNU General Public; License. `MathMore` (and its ROOT Cling dictionary) can be built within ROOT; whenever a GSL library is fou",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:4206,interface,interface,4206,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['interface'],['interface']
Integrability,"ncy of this interface, a similar method RooAbsReal::createChi2(); has been added to construct chi-squared functions of a dataset and a function or p.d.f. Along the same lines, it is recommended to use RooAbsReal::createProfile() rather; than constructing a RooProfileLL object directly as the former will efficiently; recast a profile of a profile into a single profile object. Multivariate Gaussian modeling of parameters estimates from a fit; You can now construct a multivariate Gaussian p.d.f on the parameters of a model that; represents the result of a fit, from any RooFitResult object. RooAbsPdf* paramPdf = fitresult->createHessePdf(RooArgSet(a,b)) ;. The returned object is an instance of the newly added class RooMultiVarGaussian, that can; model correlated Gaussian distributions in an arbitrary number of dimensions, given a; vector of mean values and a covariance matrix. Class RooMultivarGaussian implements analytical; integration as well as analytical partial integrals over the first 31 dimensions (if you have; that many) and implements in effect internal generation strategy for its observables. A new tutorial macro rf608_fitresultaspdf.C has been added to illustrate the use MV Gaussians constructed from a RooFitResult; Improved functionality of RooFFTConvPdf; The FFT convolution operator p.d.f. class RooFFTConvPdf has been substantially upgraded; for improved performance has several new options. For the overflow buffering, which aims to reduce cylical spillover from the FFT convolution,; a choice of three algorithms is now provided:. Extend the p.d.f. somewhat beyond its original domain (the new default); Fill the buffer 50/50 with the value of the p.d.f at the upper/lower bound of the convolution observable (the previous default); Mirror the p.d.f. over the boundary. The new default algorithm provides a more sensible result for p.d.f.s with significant; spillover issues, provided that the p.d.f. can be continuated beyond its original domain.; Convolution in non",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:10629,integrat,integration,10629,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,2,['integrat'],['integration']
Integrability,"nd `TTree` has an appropriate `TTreeIndex`. ## Histogram Libraries. ## Math Libraries. ## RooFit Libraries. ### RooWorkspace::Import() for Python; `RooWorkspace.import()` cannot be used in Python, since it is a reserved keyword. Users therefore had to resort; to; getattr(workspace, 'import')(...); Now,; workspace.Import(...); has been defined for the new PyROOT, which makes calling the function easier. ### Modernised category classes; RooFit's categories were modernised. Previously, the class RooCatType was used to store category states. It stores; two members, an integer for the category index, and up to 256 characters for a category name. Now, such states are; stored only using an integer, and category names can have arbitrary length. This will use 4 instead of 288 bytes; per category entry in a dataset, and make computations that rely on category states faster. The interface to define or manipulate category states was also updated. Since categories are mappings from state names; to state index, this is now reflected in the interface. Among others, this is now possible:; | ROOT 6.22 | Before (still supported) |; |------------------------------------------------|----------------------------------------------------------------|; | `RooCategory cat(""cat"", ""Lepton flavour"");` | `RooCategory cat(""cat"", ""Lepton flavour"");` |; | `cat[""electron""] = 1;` | `cat.defineType(""electron"", 1);` |; | `cat[""muon""] = 2;` | `cat.defineType(""muon"", 2);` |. See also [Category reference guide](https://root.cern.ch/doc/master/classRooCategory.html). ### Type-safe proxies for RooFit objects; RooFit's proxy classes have been modernised. The class `RooTemplateProxy` allows for access to other RooFit objects; similarly to a smart pointer. In older versions of RooFit, the objects held by *e.g.* `RooRealProxy` had to be; accessed like this:; RooAbsArg* absArg = realProxy.absArg();; RooAbsPdf* pdf = dynamic_cast<RooAbsPdf*>(absArg);; assert(pdf); // This *should* work, but the proxy doesn't hav",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md:3557,interface,interface,3557,README/ReleaseNotes/v622/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md,1,['interface'],['interface']
Integrability,"nd `double Derivative(const double *, int icoord)` for the partial derivatives.; * From an object implementing any member function like `Foo::XXX(const double *)` for the function evaluation and any member function like `Foo::XXX(const double *, int icoord)` for the partial derivatives.; * From an function object implementing `double operator()( const double * )` for the function evaluation and another function object implementing `double operator() (const double *, int icoord)`; for the partial derivatives. The function dimension is required when constructing the functor. #### Special case: Wrapping TF1 objects in Parametric Function interfaces. In many cases, the user works with the `TF1` class. The mathematical library in ROOT provides some solutions to wrap these into the interfaces needed by other methods.; If the desired interface to wrap is one-dimensional, the class to use is `ROOT::Math::WrappedTF1`.; The default constructor takes a `TF1` reference as an argument, that will be wrapped with the interfaces of a `ROOT::Math::IParametricGradFunctionOneDim`.; Example:; ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedTF1.h"". int main(); {. TF1 f(""Sin Function"", ""sin(x)+y"",0,3);. ROOT::Math::WrappedTF1 wf1(f);. cout << f(1) << endl;; cout << wf1(1) << endl;. return 0;; }; ```. For a TF1 defining a multidimensional function or in case we need to wrap in a multi-dimensional function interface, the class to use is `ROOT::Math::WrappedMultiTF1`.; Following the usual procedure, setting the `TF1` though the constructor, will wrap it into a `ROOT::Math::IParametricGradFunctionMultiDim`.; Example:. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedMultiTF1.h"". int main(); {. TF2 f(""Sin Function"", ""sin(x) + y"",0,3,0,2);. ROOT::Math::WrappedMultiTF1 wf1(f);. double x[] = {1,2};. cout << f(x) << endl;; cout << wf1(x) << endl;. return 0;; }; ```. ## Numerical Integration. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy sho",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:47370,wrap,wrapped,47370,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,2,"['interface', 'wrap']","['interfaces', 'wrapped']"
Integrability,"nd below. If the user is using the static CRT (``/MT``), then different runtimes are used; to produce DLLs and EXEs. To link a DLL, pass; ``clang_rt.asan_dll_thunk-x86_64.lib``. To link an EXE, pass; ``-wholearchive:clang_rt.asan-x86_64.lib``. Windows System Headers and Library Lookup; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. clang-cl uses a set of different approaches to locate the right system libraries; to link against when building code. The Windows environment uses libraries from; three distinct sources:. 1. Windows SDK; 2. UCRT (Universal C Runtime); 3. Visual C++ Tools (VCRuntime). The Windows SDK provides the import libraries and headers required to build; programs against the Windows system packages. Underlying the Windows SDK is the; UCRT, the universal C runtime. This difference is best illustrated by the various headers that one would find; in the different categories. The WinSDK would contain headers such as; `WinSock2.h` which is part of the Windows API surface, providing the Windows; socketing interfaces for networking. UCRT provides the C library headers,; including e.g. `stdio.h`. Finally, the Visual C++ tools provides the underlying; Visual C++ Runtime headers such as `stdint.h` or `crtdefs.h`. There are various controls that allow the user control over where clang-cl will; locate these headers. The default behaviour for the Windows SDK and UCRT is as; follows:. 1. Consult the command line. Anything the user specifies is always given precedence. The following; extensions are part of the clang-cl toolset:. - `/winsysroot:`. The `/winsysroot:` is used as an equivalent to `-sysroot` on Unix; environments. It allows the control of an alternate location to be treated; as a system root. When specified, it will be used as the root where the; `Windows Kits` is located. - `/winsdkversion:`; - `/winsdkdir:`. If `/winsysroot:` is not specified, the `/winsdkdir:` argument is consulted; as a location to identify where the Windows SDK is located. Contrary to; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:193581,interface,interfaces,193581,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['interface'],['interfaces']
Integrability,"nd direction \f$\vec{n}\f$ with respect to the world; reference frame. The direction \f$\vec{n}\f$ must be a unit vector having as; components the director cosines. The full classification of a given; state will provide the following information: the deepest physical node; containing the position vector, the distance to the closest boundary; along the direction vector, the next physical node after propagating the; current point with this distance and the safety distance to the nearest; boundary. This information allows the propagation of particles inside a; detector geometry by taking into account both geometrical and physical; constraints. We will hereby describe the user interface of `TGeo` to access; tracking functionality. This allows either developing a tracker for; simple navigation within a given geometry, either interfacing to an; external tracking engine such as GEANT. Note that the abstract interface; for external trackers can be found in `$ROOTSYS/vmc` folder and it can; be used to run GEANT3, GEANT4 and FLUKA-based simulations (\*) by using; directly a geometry described with %ROOT. The interface methods related to tracking are incorporated into; TGeoManager class and implemented in the navigator class; TGeoNavigator. In order to be able to start tracking, one has to; define the initial state providing the starting point \f$\vec{r_0}\f$; and direction \f$\vec{n_0}\f$ .; There are several ways of doing that. \anchor GP02a; ### TGeoNavigator Class. One geometry may have several independent navigators to query to; localize points or compute distances. The geometry manager holds a list; of active navigators accessible via:. ~~~{.cpp}; TObjArray *navigators = gGeoManager->GetListOfNavigators();; ~~~. Upon closing the geometry a default navigator is provided as first one; in this list, but one may add its own via:. ~~~{.cpp}; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:62338,interface,interface,62338,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['interface'],['interface']
Integrability,"nd earlier). List of features and minimum Clang version with support. Language Feature; C11 Proposal; Available in Clang?. A finer-grained specification for sequencing; N1252; Unknown. Clarification of expressions; N1282; Unknown. Extending the lifetime of temporary objects (factored approach); N1285; Unknown. Requiring signed char to have no padding bits; N1310; Unknown. Initializing static or external variables; N1311; Yes. Conversion between pointers and floating types; N1316; Yes. Adding TR 19769 to the C Standard Library; N1326; Clang 3.3. Static assertions; N1330; Yes. Parallel memory sequencing model proposal; N1349; Unknown. Analyzability (#1, #4 - conditionally normative); N1350; Unknown. FLT_EVAL_METHOD issues (first change only); N1353; Unknown. _Bool bit-fields; N1356; Yes. Technical corrigendum for C1X; N1359; Unknown. Benign typedef redefinition; N1360; Clang 3.1. Thread-local storage; N1364; Clang 3.3. Constant expressions; N1365; Unknown. Contractions and expression evaluation methods; N1367; Unknown. FLT_EVAL_METHOD and return; N1382; Unknown. Floating-point to int/_Bool conversions; N1391; Yes. Analyzability (along the lines); N1394; Unknown. Wide function returns (alternate proposal); N1396; Unknown. Alignment. N1397; Clang 3.2. N1447; Clang 3.2. Anonymous member-structures and unions (modulo ""name lookup""); N1406; Yes. Completeness of types; N1439; Yes. Generic macro facility; N1441; Yes. Dependency ordering for C memory model; N1444; Unknown. Subsetting the standard; N1460; Yes. Assumed types in F.9.2; N1468; Unknown. Supporting the 'noreturn' property in C1x; N1478; Clang 3.3. Updates to C++ memory model based on formalization; N1480; Unknown. Explicit initializers for atomics; N1482; Unknown. Atomics proposal (minus ternary op); N1485; Yes. UTF-8 string literals; N1488; Clang 3.3. Optimizing away infinite loops; N1509; Yes. Conditional normative status for Annex G; N1514; Unknown. Creation of complex value; N1464; Unknown. Recommendations for ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html:5151,Contract,Contractions,5151,interpreter/llvm-project/clang/www/c_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html,1,['Contract'],['Contractions']
Integrability,"nd floating types; N1316; Yes. Adding TR 19769 to the C Standard Library; N1326; Clang 3.3. Static assertions; N1330; Yes. Parallel memory sequencing model proposal; N1349; Unknown. Analyzability (#1, #4 - conditionally normative); N1350; Unknown. FLT_EVAL_METHOD issues (first change only); N1353; Unknown. _Bool bit-fields; N1356; Yes. Technical corrigendum for C1X; N1359; Unknown. Benign typedef redefinition; N1360; Clang 3.1. Thread-local storage; N1364; Clang 3.3. Constant expressions; N1365; Unknown. Contractions and expression evaluation methods; N1367; Unknown. FLT_EVAL_METHOD and return; N1382; Unknown. Floating-point to int/_Bool conversions; N1391; Yes. Analyzability (along the lines); N1394; Unknown. Wide function returns (alternate proposal); N1396; Unknown. Alignment. N1397; Clang 3.2. N1447; Clang 3.2. Anonymous member-structures and unions (modulo ""name lookup""); N1406; Yes. Completeness of types; N1439; Yes. Generic macro facility; N1441; Yes. Dependency ordering for C memory model; N1444; Unknown. Subsetting the standard; N1460; Yes. Assumed types in F.9.2; N1468; Unknown. Supporting the 'noreturn' property in C1x; N1478; Clang 3.3. Updates to C++ memory model based on formalization; N1480; Unknown. Explicit initializers for atomics; N1482; Unknown. Atomics proposal (minus ternary op); N1485; Yes. UTF-8 string literals; N1488; Clang 3.3. Optimizing away infinite loops; N1509; Yes. Conditional normative status for Annex G; N1514; Unknown. Creation of complex value; N1464; Unknown. Recommendations for extended identifier characters for C and C++; N1518; Unknown. Atomic C1x/C++0x compatibility refinements (1st part only); N1526; Yes. Atomic bitfields implementation defined; N1530; Yes. Small fix for the effect of alignment on struct/union type compatibility; N1532; Yes. Synthesis re _Atomic; N1537; Unknown. Clarification for wide evaluation; N1531; Unknown. C17 implementation status; There are no major changes in this edition, only technical corrections",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html:5614,Depend,Dependency,5614,interpreter/llvm-project/clang/www/c_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html,1,['Depend'],['Dependency']
Integrability,"nd is designed to; support a wide range of implementations and clients (but currently all clients; are assumed to be flow-insensitive). In addition to simple alias analysis; information, this class exposes Mod/Ref information from those implementations; which can provide it, allowing for powerful analyses and transformations to work; well together. This document contains information necessary to successfully implement this; interface, use it, and to test both sides. It also explains some of the finer; points about what exactly results mean. ``AliasAnalysis`` Class Overview; ================================. The `AliasAnalysis <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__; class defines the interface that the various alias analysis implementations; should support. This class exports two important enums: ``AliasResult`` and; ``ModRefResult`` which represent the result of an alias query or a mod/ref; query, respectively. The ``AliasAnalysis`` interface exposes information about memory, represented in; several different ways. In particular, memory objects are represented as a; starting address and size, and function calls are represented as the actual; ``call`` or ``invoke`` instructions that performs the call. The; ``AliasAnalysis`` interface also exposes some helper methods which allow you to; get mod/ref information for arbitrary instructions. All ``AliasAnalysis`` interfaces require that in queries involving multiple; values, values which are not :ref:`constants <constants>` are all; defined within the same function. Representation of Pointers; --------------------------. Most importantly, the ``AliasAnalysis`` class provides several methods which are; used to query whether or not two memory objects alias, whether function calls; can modify or read a memory object, etc. For all of these queries, memory; objects are represented as a pair of their starting address (a symbolic LLVM; ``Value*``) and a static size. Representing memory objects as a startin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:2110,interface,interface,2110,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['interface'],['interface']
Integrability,"nd leave out the x-points, the diagram will look like this:. ## 3D Graphics Libraries. ## Geometry Libraries. - Support with web geometry viewer image production in batch mode. Just do:; ```; ROOT::Experimental::RGeomViewer viewer(geom);; viewer.SaveImage(""rootgeom.jpeg"", 800, 600);; ```; This runs normal WebGL rendering in headless web browser (Chrome or Firefox) and; creates png or jpeg image out of it. ## Database Libraries. ## Networking Libraries. ### THttpServer. - upgrade civetweb code to version 1.15, supports SSL version 3.0; - resolve problem with symbolic links usage on Windows; - let disable/enable directory files listing via THttpServer (default is off); - enable usage of unix sockets, used by `rootssh` script for tunnel to remote session. ## GUI Libraries. - Provide web-based TTree viewer, integrated with RBrowser; - Support Edge browser on Windows for all kinds of web widgets; - Provide `rootssh` shell script to simplify use of web-based widgets on remote nodes:; ```; [localnode] rootssh user@remotenode; [remotenode] root --web -e 'new TBrowser'; ```; Script automatically configures ssh tunnel between local and remote nodes, one the remote node; unix socket with strict 0700 mode is used. When ROOT running on remote node wants to display; new web widget, script will automatically start web browser on local node with appropriate URL,; accessing widget via configured ssh tunnel. ## Montecarlo Libraries. ## PROOF Libraries. ## Language Bindings. ## JavaScript ROOT. - Major JSROOT upgrade to version 7, using ES6 modules and classes. ## Tutorials. - Several new tutorials have been added in both C++ and Python in the `tutorial/tmva` directory.; Tutorials like `TMVA_Higgs_Classification.py` shows the new pythonizations available in TMVA and; new `TMVA_SOFIE_...` tutorials show th eusage of SOFIE in both C++ or Python. ## Class Reference Guide. ## Build, Configuration and Testing Infrastructure. - Building external applications that use ROOT oftentimes fail if ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:32140,integrat,integrated,32140,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['integrat'],['integrated']
Integrability,"nd nested tuple) is the experimental evolution of TTree columnar data storage. RNTuple introduces; new interfaces that aim to be more robust. In particular, the new interfaces are type-safe through the use of; templates, and the ownership is well-defined through the use of smart pointers. For instance. tree->Branch(""px"", &Category, ""px/F"");. becomes. auto px = model->MakeField<float>(""px"");; // px is std::shared_ptr<float>. The physical layout changes slightly from big endian to little endian so that it matches the in-memory layout on; most modern architectures. Combined with a clear separation of offset/index data and payload data for collections,; uncompressed RNTuple data can be directly mapped to memory without further copies. Goals; -----. RNTuple shall investigate improvements of the TTree I/O in the following ways. 1. More speed; * Improve mapping to vectorized and parallel hardware; * For types known at compile / JIT time: generate optimized code; * Optimized for simple types (float, int, and vectors of them); * Better memory control: work with a fixed budget of pre-defined I/O buffers; * Naturally thread-safe and asynchronous interfaces. 2. More robust interfaces; * Compile-time type safety by default; * Decomposition into layers: logical layer, primitives layer, storage layer; * Separation of data model and live data; * Self-contained I/O code to support creation of a standalone I/O library. Concepts; --------. At the **logical layer**, the user defines a data model using the RNTupleModel class.; The data model is a collection of serializable C++ types with associated names, similar to branches in a TTree.; The data model can contain (nested) collections, e.g., a type can be `std::vector<std::vector<float>>`. Each serializable type is represented by a **field**, concretely by a templated version of RField,; e.g. `RField<double>`. A field can generate or adopt an associated **value**, which represents a memory location; storing a value of the given C++ type",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/README.md:1219,interface,interfaces,1219,tree/ntuple/v7/doc/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/README.md,1,['interface'],['interfaces']
Integrability,"nd stored** -- if necessary, the; target can select a ``G_LOAD``/``G_STORE`` of each gvreg operand. As opposed to SelectionDAG, there are no legalization phases. In particular,; 'type' and 'operation' legalization are not separate. Legalization is iterative, and all state is contained in GMIR. To maintain the; validity of the intermediate code, instructions are introduced:. * ``G_MERGE_VALUES`` --- concatenate multiple registers of the same; size into a single wider register. * ``G_UNMERGE_VALUES`` --- extract multiple registers of the same size; from a single wider register. * ``G_EXTRACT`` --- extract a simple register (as contiguous sequences of bits); from a single wider register. As they are expected to be temporary byproducts of the legalization process,; they are combined at the end of the :ref:`milegalizer` pass.; If any remain, they are expected to always be selectable, using loads and stores; if necessary. The legality of an instruction may only depend on the instruction itself and; must not depend on any context in which the instruction is used. However, after; deciding that an instruction is not legal, using the context of the instruction; to decide how to legalize the instruction is permitted. As an example, if we; have a ``G_FOO`` instruction of the form::. %1:_(s32) = G_CONSTANT i32 1; %2:_(s32) = G_FOO %0:_(s32), %1:_(s32). it's impossible to say that G_FOO is legal iff %1 is a ``G_CONSTANT`` with; value ``1``. However, the following::. %2:_(s32) = G_FOO %0:_(s32), i32 1. can say that it's legal iff operand 2 is an immediate with value ``1`` because; that information is entirely contained within the single instruction. .. _api-legalizerinfo:. API: LegalizerInfo; ^^^^^^^^^^^^^^^^^^. The recommended [#legalizer-legacy-footnote]_ API looks like this::. getActionDefinitionsBuilder({G_ADD, G_SUB, G_MUL, G_AND, G_OR, G_XOR, G_SHL}); .legalFor({s32, s64, v2s32, v4s32, v2s64}); .clampScalar(0, s32, s64); .widenScalarToNextPow2(0); .clampNumElements(0, v2s32, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/Legalizer.rst:1418,depend,depend,1418,interpreter/llvm-project/llvm/docs/GlobalISel/Legalizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/Legalizer.rst,2,['depend'],['depend']
Integrability,"nd will be removed as part of the; opaque pointer transition::. LLVMBuildLoad -> LLVMBuildLoad2; LLVMBuildCall -> LLVMBuildCall2; LLVMBuildInvoke -> LLVMBuildInvoke2; LLVMBuildGEP -> LLVMBuildGEP2; LLVMBuildInBoundsGEP -> LLVMBuildInBoundsGEP2; LLVMBuildStructGEP -> LLVMBuildStructGEP2; LLVMBuildPtrDiff -> LLVMBuildPtrDiff2; LLVMConstGEP -> LLVMConstGEP2; LLVMConstInBoundsGEP -> LLVMConstInBoundsGEP2; LLVMAddAlias -> LLVMAddAlias2. Additionally, it will no longer be possible to call ``LLVMGetElementType()``; on a pointer type. It is possible to control whether opaque pointers are used (if you want to; override the default) using ``LLVMContext::setOpaquePointers``. Temporarily disabling opaque pointers; =====================================. In LLVM 15, opaque pointers are enabled by default, but it it still possible to; use typed pointers using a number of opt-in flags. For users of the clang driver interface, it is possible to temporarily restore; the old default using the ``-DCLANG_ENABLE_OPAQUE_POINTERS=OFF`` cmake option,; or by passing ``-Xclang -no-opaque-pointers`` to a single clang invocation. For users of the clang cc1 interface, ``-no-opaque-pointers`` can be passed.; Note that the ``CLANG_ENABLE_OPAQUE_POINTERS`` cmake option has no effect on; the cc1 interface. Usage for LTO can be disabled by passing ``-Wl,-plugin-opt=no-opaque-pointers``; to the clang driver. For users of LLVM as a library, opaque pointers can be disabled by calling; ``setOpaquePointers(false)`` on the ``LLVMContext``. For users of LLVM tools like opt, opaque pointers can be disabled by passing; ``-opaque-pointers=0``. Version Support; ===============. **LLVM 14:** Supports all necessary APIs for migrating to opaque pointers and deprecates/removes incompatible APIs. However, using opaque pointers in the optimization pipeline is **not** fully supported. This release can be used to make out-of-tree code compatible with opaque pointers, but opaque pointers should **not** be enabled in pro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OpaquePointers.rst:10943,interface,interface,10943,interpreter/llvm-project/llvm/docs/OpaquePointers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OpaquePointers.rst,1,['interface'],['interface']
Integrability,"nd, the ``--hip-link`` flag instructs Clang to link the HIP runtime library. However,; the use of this flag is unnecessary if a HIP input file is already present in your program. For convenience, Clang also supports compiling and linking in a single step:. .. code-block:: shell. clang++ --offload-arch=gfx906 -xhip sample.cpp -o sample. In the above commands, ``gfx906`` is the GPU architecture that the code is being compiled for. The supported GPU; architectures can be found in the `AMDGPU Processor Table <https://llvm.org/docs/AMDGPUUsage.html#processors>`_.; Alternatively, you can use the ``amdgpu-arch`` tool that comes with Clang to list the GPU architecture on your system:. .. code-block:: shell. amdgpu-arch. You can use ``--offload-arch=native`` to automatically detect the GPU architectures on your system:. .. code-block:: shell. clang++ --offload-arch=native -xhip sample.cpp -o sample. Path Setting for Dependencies; =============================. Compiling a HIP program depends on the HIP runtime and device library. The paths to the HIP runtime and device libraries; can be specified either using compiler options or environment variables. The paths can also be set through the ROCm path; if they follow the ROCm installation directory structure. Order of Precedence for HIP Path; --------------------------------. 1. ``--hip-path`` compiler option; 2. ``HIP_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). Order of Precedence for Device Library Path; -------------------------------------------. 1. ``--hip-device-lib-path`` compiler option; 2. ``HIP_DEVICE_LIB_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm ins",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst:3660,depend,depends,3660,interpreter/llvm-project/clang/docs/HIPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst,1,['depend'],['depends']
Integrability,"nd-color: #C0C0C0; text-align: center; }; .unknown:before { content: ""?"" }; .no { background-color: #C11B17 }; .no:before { content: ""N"" }; .partial { background-color: #F88017 }; .yes { background-color: #0F0; }; .yes:before { content: ""Y"" }; .na { background-color: #6666FF; }; .na:before { content: ""N/A"" }; </style>. .. contents::; :local:. .. warning::; This is a work in progress. Introduction; ============. The LLVM target-independent code generator is a framework that provides a suite; of reusable components for translating the LLVM internal representation to the; machine code for a specified target---either in assembly form (suitable for a; static compiler) or in binary machine code format (usable for a JIT; compiler). The LLVM target-independent code generator consists of six main; components:. 1. `Abstract target description`_ interfaces which capture important properties; about various aspects of the machine, independently of how they will be used.; These interfaces are defined in ``include/llvm/Target/``. 2. Classes used to represent the `code being generated`_ for a target. These; classes are intended to be abstract enough to represent the machine code for; *any* target machine. These classes are defined in; ``include/llvm/CodeGen/``. At this level, concepts like ""constant pool; entries"" and ""jump tables"" are explicitly exposed. 3. Classes and algorithms used to represent code at the object file level, the; `MC Layer`_. These classes represent assembly level constructs like labels,; sections, and instructions. At this level, concepts like ""constant pool; entries"" and ""jump tables"" don't exist. 4. `Target-independent algorithms`_ used to implement various phases of native; code generation (register allocation, scheduling, stack frame representation,; etc). This code lives in ``lib/CodeGen/``. 5. `Implementations of the abstract target description interfaces`_ for; particular targets. These machine descriptions make use of the components; provided by LLVM, a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:1194,interface,interfaces,1194,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['interface'],['interfaces']
Integrability,"ndif(). set_property(TARGET Core APPEND PROPERTY DICT_HEADERS TUnixSystem.h); target_sources(Core PRIVATE src/TUnixSystem.cxx); target_include_directories(Core PRIVATE inc ../clib/res). if (CMAKE_SYSTEM_NAME MATCHES FreeBSD); target_link_libraries(Core PRIVATE execinfo util); endif(). CHECK_CXX_SOURCE_COMPILES(""#include <stdlib.h>; int main() { char buf[32]; arc4random_buf(buf, 32); return 0;}"" found_arc4). if(found_arc4); message(STATUS ""Found arc4random_buf in stdlib.h""); target_compile_definitions(Core PRIVATE R__ARC4_STDLIB); else(); set(OLD_CMAKE_REQUIRED_INCLUDES ${CMAKE_REQUIRED_INCLUDES}); set(OLD_CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES}); if(DEFINED LIBBSDROOT); set(CMAKE_REQUIRED_INCLUDES ${LIBBSDROOT}/include); set(CMAKE_REQUIRED_LIBRARIES ${LIBBSDROOT}/lib/libbsd.so); endif(); CHECK_CXX_SOURCE_COMPILES(""#include <bsd/stdlib.h>; int main() { char buf[32]; arc4random_buf(buf, 32); return 0;}"" found_arc4_bsd); set(CMAKE_REQUIRED_INCLUDES ${OLD_CMAKE_REQUIRED_INCLUDES}); set(CMAKE_REQUIRED_LIBRARIES ${OLD_CMAKE_REQUIRED_LIBRARIES}); if(found_arc4_bsd); message(STATUS ""Found arc4random_buf in bsd/stdlib.h""); target_compile_definitions(Core PRIVATE R__ARC4_BSDLIB); if(DEFINED LIBBSDROOT); target_include_directories(Core PRIVATE ${LIBBSDROOT}/include); target_link_libraries(Core PRIVATE ${LIBBSDROOT}/lib/libbsd.so); endif(); else(); CHECK_CXX_SOURCE_COMPILES(""#include <sys/random.h>; int main() { char buf[32]; int res = getrandom(buf, 32, GRND_NONBLOCK); return 0;}"" found_getrandom); if(found_getrandom); message(STATUS ""Found getrandom in sys/random.h""); target_compile_definitions(Core PRIVATE R__GETRANDOM_CLIB); else(); CHECK_CXX_SOURCE_RUNS(""; #include <fstream>. int main() {; std::ifstream urandom{\""/dev/urandom\""};; if (!urandom) {; // This will make the CMake command fail; return 1;; }; ; constexpr int len{32};; char buf[len];; for (int n = 0; n < len; n++) buf[n] = 0;; urandom.read(buf, len);; ; int nmatch = 0;; for (int n = 0; n < len; n++); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/unix/CMakeLists.txt:1524,message,message,1524,core/unix/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/unix/CMakeLists.txt,1,['message'],['message']
Integrability,"ndif()``. Loops; -----. The most common form of the CMake ``foreach`` block is:. .. code-block:: cmake. foreach(var ...); message(""do stuff""); endforeach(). The variable argument portion of the ``foreach`` block can contain dereferenced; lists, values to iterate, or a mix of both:. .. code-block:: cmake. foreach(var foo bar baz); message(${var}); endforeach(); # prints:; # foo; # bar; # baz. set(my_list 1 2 3); foreach(var ${my_list}); message(${var}); endforeach(); # prints:; # 1; # 2; # 3. foreach(var ${my_list} out_of_bounds); message(${var}); endforeach(); # prints:; # 1; # 2; # 3; # out_of_bounds. There is also a more modern CMake foreach syntax. The code below is equivalent; to the code above:. .. code-block:: cmake. foreach(var IN ITEMS foo bar baz); message(${var}); endforeach(); # prints:; # foo; # bar; # baz. set(my_list 1 2 3); foreach(var IN LISTS my_list); message(${var}); endforeach(); # prints:; # 1; # 2; # 3. foreach(var IN LISTS my_list ITEMS out_of_bounds); message(${var}); endforeach(); # prints:; # 1; # 2; # 3; # out_of_bounds. Similar to the conditional statements, these generally behave how you would; expect, and they do not have their own scope. CMake also supports ``while`` loops, although they are not widely used in LLVM. Modules, Functions and Macros; =============================. Modules; -------. Modules are CMake's vehicle for enabling code reuse. CMake modules are just; CMake script files. They can contain code to execute on include as well as; definitions for commands. In CMake macros and functions are universally referred to as commands, and they; are the primary method of defining code that can be called multiple times. In LLVM we have several CMake modules that are included as part of our; distribution for developers who don't build our project from source. Those; modules are the fundamental pieces needed to build LLVM-based projects with; CMake. We also rely on modules as a way of organizing the build system's; functionality for ma",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst:9176,message,message,9176,interpreter/llvm-project/llvm/docs/CMakePrimer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst,1,['message'],['message']
Integrability,"ndl;; cout << f2(x) << endl;; cout << f3(x) << endl;. return 0;; }; ```. #### Wrapping Multi-dimensional Gradient Functions. The class `ROOT::Math::GradFunctor` is used to wrap in a very C++ callable object to make gradient functions. It can be constructed in three different way:; * From an object implementing both `double operator()( const double * )` for the function evaluation and `double Derivative(const double *, int icoord)` for the partial derivatives.; * From an object implementing any member function like `Foo::XXX(const double *)` for the function evaluation and any member function like `Foo::XXX(const double *, int icoord)` for the partial derivatives.; * From an function object implementing `double operator()( const double * )` for the function evaluation and another function object implementing `double operator() (const double *, int icoord)`; for the partial derivatives. The function dimension is required when constructing the functor. #### Special case: Wrapping TF1 objects in Parametric Function interfaces. In many cases, the user works with the `TF1` class. The mathematical library in ROOT provides some solutions to wrap these into the interfaces needed by other methods.; If the desired interface to wrap is one-dimensional, the class to use is `ROOT::Math::WrappedTF1`.; The default constructor takes a `TF1` reference as an argument, that will be wrapped with the interfaces of a `ROOT::Math::IParametricGradFunctionOneDim`.; Example:; ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedTF1.h"". int main(); {. TF1 f(""Sin Function"", ""sin(x)+y"",0,3);. ROOT::Math::WrappedTF1 wf1(f);. cout << f(1) << endl;; cout << wf1(1) << endl;. return 0;; }; ```. For a TF1 defining a multidimensional function or in case we need to wrap in a multi-dimensional function interface, the class to use is `ROOT::Math::WrappedMultiTF1`.; Following the usual procedure, setting the `TF1` though the constructor, will wrap it into a `ROOT::Math::IParametricGradFunctionMultiDim`.; Exam",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:47012,interface,interfaces,47012,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['interface'],['interfaces']
Integrability,"ndles; ---------------. Operand bundles are tagged sets of SSA values that can be associated; with certain LLVM instructions (currently only ``call`` s and; ``invoke`` s). In a way they are like metadata, but dropping them is; incorrect and will change program semantics. Syntax::. operand bundle set ::= '[' operand bundle (, operand bundle )* ']'; operand bundle ::= tag '(' [ bundle operand ] (, bundle operand )* ')'; bundle operand ::= SSA value; tag ::= string constant. Operand bundles are **not** part of a function's signature, and a; given function may be called from multiple places with different kinds; of operand bundles. This reflects the fact that the operand bundles; are conceptually a part of the ``call`` (or ``invoke``), not the; callee being dispatched to. Operand bundles are a generic mechanism intended to support; runtime-introspection-like functionality for managed languages. While; the exact semantics of an operand bundle depend on the bundle tag,; there are certain limitations to how much the presence of an operand; bundle can influence the semantics of a program. These restrictions; are described as the semantics of an ""unknown"" operand bundle. As; long as the behavior of an operand bundle is describable within these; restrictions, LLVM does not need to have special knowledge of the; operand bundle to not miscompile programs containing it. - The bundle operands for an unknown operand bundle escape in unknown; ways before control is transferred to the callee or invokee.; - Calls and invokes with operand bundles have unknown read / write; effect on the heap on entry and exit (even if the call target specifies; a ``memory`` attribute), unless they're overridden with; callsite specific attributes.; - An operand bundle at a call site cannot change the implementation; of the called function. Inter-procedural optimizations work as; usual as long as they take into account the first two properties. More specific types of operand bundles are described below.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:117845,depend,depend,117845,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['depend']
Integrability,"ndom numbers |; | | |; | `Double_t PoissonD(Double_t mean)` | |; +-------------------------------------------+--------------------------------+; | `Int_t Binomial(Int_t ntot,Double_t prob | Binomial Random numbers |; | )` | |; +-------------------------------------------+--------------------------------+; | `Circle(Double_t &x,Double_t &y,Double_t | Generate a random 2D point |; | r)` | `(x,y)` in |; | | |; | | a circle of radius `r` |; +-------------------------------------------+--------------------------------+; | `Sphere(Double_t &x,Double_t &y,` | Generate a random 3D point |; | | `(x,y,z)` in |; | ` Double_t &z,Double_t r)` | |; | | a sphere of radius `r` |; +-------------------------------------------+--------------------------------+; | `Rannor(Double_t &a,Double_t &b)` | Generate a pair of Gaussian |; | | random |; | | |; | | numbers with `mu=0` and |; | | `sigma=1` |; +-------------------------------------------+--------------------------------+. ### UNURAN. An interface to a new package, UNU.RAN, (Universal Non Uniform Random; number generator for generating non-uniform pseudo-random numbers) was; introduced in ROOT v5.16. UNU.RAN is an ANSI C library licensed under GPL. It contains universal; (also called automatic or black-box) algorithms that can generate random; numbers from large classes of continuous (in one or multi-dimensions),; discrete distributions, empirical distributions (like histograms) and; also from practically all standard distributions. An extensive online; documentation is available at the UNU.RAN Web Site; <http://statmath.wu-wien.ac.at/unuran/>. The ROOT class **`TUnuran`** is used to interface the UNURAN package. It; can be used as following:. - With the UNU.RAN native, string API for pre-defined distributions; (see UNU.RAN documentation for the allowed string values at; <http://statistik.wu-wien.ac.at/unuran/doc/unuran.html> ):. ``` {.cpp}; TUnuran unr;; // initialize unuran to generate normal random numbers using; // a ""arou"" meth",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:18284,interface,interface,18284,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['interface'],['interface']
Integrability,"nds are respected. The second sense of being out of bounds is computing an address that's beyond; the actual underlying allocated object. With the ``inbounds`` keyword, the result value of the GEP is ``poison`` if the; address is outside the actual underlying allocated object and not the address; one-past-the-end. Without the ``inbounds`` keyword, there are no restrictions on computing; out-of-bounds addresses. Obviously, performing a load or a store requires an; address of allocated and sufficiently aligned memory. But the GEP itself is only; concerned with computing addresses. Can array indices be negative?; ------------------------------. Yes. This is basically a special case of array indices being out of bounds. Can I compare two values computed with GEPs?; --------------------------------------------. Yes. If both addresses are within the same allocated object, or; one-past-the-end, you'll get the comparison result you expect. If either is; outside of it, integer arithmetic wrapping may occur, so the comparison may not; be meaningful. Can I do GEP with a different pointer type than the type of the underlying object?; ----------------------------------------------------------------------------------. Yes. There are no restrictions on bitcasting a pointer value to an arbitrary; pointer type. The types in a GEP serve only to define the parameters for the; underlying integer computation. They need not correspond with the actual type of; the underlying object. Furthermore, loads and stores don't have to use the same types as the type of; the underlying object. Types in this context serve only to specify memory size; and alignment. Beyond that there are merely a hint to the optimizer indicating; how the value will likely be used. Can I cast an object's address to integer and add it to null?; -------------------------------------------------------------. You can compute an address that way, but if you use GEP to do the add, you can't; use that pointer to actually acce",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst:14601,wrap,wrapping,14601,interpreter/llvm-project/llvm/docs/GetElementPtr.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst,1,['wrap'],['wrapping']
Integrability,"ne Brun, CERN/SFT,\; Philippe Canal, FNAL,\; David Clark, ANL (SULI),\; Olivier Couet, CERN/SFT,\; Gerri Ganis, CERN/SFT,\; Andrei Gheata, CERN/SFT,\; Enrico Guiraud, CERN/SFT,\; Raphael Isemann, Chalmers Univ. of Tech.,\; Sergey Linev, GSI,\; Timur Pocheptsov, CERN/SFT,\; Pere Mato, CERN/SFT,\; Lorenzo Moneta, CERN/SFT,\; Axel Naumann, CERN/SFT,\; Simon Pfreundschuh,\; Danilo Piparo, CERN/SFT,\; Fons Rademakers, CERN/SFT,\; Enric Tejedor Saavedra, CERN/SFT,\; Oksana Shadura, UNL,\; Arthur Tsang, CERN/SFT, \; Peter van Gemmeren, ANL,\; Vassil Vassilev, Princeton Univ./CMS,\; Xavier Valls Pla, CERN/UJI, \; Wouter Verkerke, NIKHEF/Atlas, RooFit,\; Stefan Wunsch, KIT,\; Omar Zapata. ## General News. This release now supports building with C++17 enabled using either libstdc++ or; libc++. This requires Clang >= 5.0, or GCC >= 7.3.0. At the date of this; release, GCC 7.2.0 still does not provide full support to compile ROOT with C++17. ## Removed interfaces. The following interfaces have been removed, after deprecation in v6.10. - Remove the deprecated `TSelectorCint.h` and `TSelectorCint.cxx`.; - Remove the deprecated `Riosfwd.h` and `Rtypeinfo.h`.; - `TTreeReader::SetLastEntry()` was replaced by `TTreeReader::SetEntriesRange()`. ## Core Libraries. - Added support for XCode 9 and MacOS High Sierra.; - When invoking root with the ""-t"" argument, ROOT enables thread-safety and,; if configured, implicit multithreading within ROOT.; - `NULL` is not defined by `Rtypes.h` anymore. Instead, its definition is expected to be; provided by `Rtype.h`'s `#include` of `stddef.h`.; - ROOT now supports dictionaries, autoload and autoparse for classes with template parameter packs.; - std::make_unique has been backported; - If a class overloads TObject::Hash, this derived class should also add; ```; ROOT::CallRecursiveRemoveIfNeeded(*this); ```; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this; type of object, the transversal of THashList and THashTable container",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:1371,interface,interfaces,1371,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,1,['interface'],['interfaces']
Integrability,"ne could imagine a module ``std`` covering the C standard library. Each of the C standard library headers (``<stdio.h>``, ``<stdlib.h>``, ``<math.h>``, etc.) would contribute to the ``std`` module, by placing their respective APIs into the corresponding submodule (``std.io``, ``std.lib``, ``std.math``, etc.). Having a list of the headers that are part of the ``std`` module allows the compiler to build the ``std`` module as a standalone entity, and having the mapping from header names to (sub)modules allows the automatic translation of ``#include`` directives to module imports. Module maps are specified as separate files (each named ``module.modulemap``) alongside the headers they describe, which allows them to be added to existing software libraries without having to change the library headers themselves (in most cases [#]_). The actual `Module map language`_ is described in a later section. .. note::. To actually see any benefits from modules, one first has to introduce module maps for the underlying C standard library and the libraries and headers on which it depends. The section `Modularizing a Platform`_ describes the steps one must take to write these module maps. One can use module maps without modules to check the integrity of the use of header files. To do this, use the ``-fimplicit-module-maps`` option instead of the ``-fmodules`` option, or use ``-fmodule-map-file=`` option to explicitly specify the module map files to load. Compilation model; -----------------; The binary representation of modules is automatically generated by the compiler on an as-needed basis. When a module is imported (e.g., by an ``#include`` of one of the module's headers), the compiler will spawn a second instance of itself [#]_, with a fresh preprocessing context [#]_, to parse just the headers in that module. The resulting Abstract Syntax Tree (AST) is then persisted into the binary representation of the module that is then loaded into translation unit where the module import was e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:12722,depend,depends,12722,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['depend'],['depends']
Integrability,"ne running on a different machine or architecture) that communicates; with the JIT via RPC. **LLVM IR compilation**; ORC provides off the shelf components (IRCompileLayer, SimpleCompiler,; ConcurrentIRCompiler) that make it easy to add LLVM IR to a JIT'd process. **Eager and lazy compilation**; By default, ORC will compile symbols as soon as they are looked up in the JIT; session object (``ExecutionSession``). Compiling eagerly by default makes it; easy to use ORC as an in-memory compiler for an existing JIT (similar to how; MCJIT is commonly used). However ORC also provides built-in support for lazy; compilation via lazy-reexports (see :ref:`Laziness`). **Support for Custom Compilers and Program Representations**; Clients can supply custom compilers for each symbol that they define in their; JIT session. ORC will run the user-supplied compiler when the a definition of; a symbol is needed. ORC is actually fully language agnostic: LLVM IR is not; treated specially, and is supported via the same wrapper mechanism (the; ``MaterializationUnit`` class) that is used for custom compilers. **Concurrent JIT'd code** and **Concurrent Compilation**; JIT'd code may be executed in multiple threads, may spawn new threads, and may; re-enter the ORC (e.g. to request lazy compilation) concurrently from multiple; threads. Compilers launched my ORC can run concurrently (provided the client; sets up an appropriate dispatcher). Built-in dependency tracking ensures that; ORC does not release pointers to JIT'd code or data until all dependencies; have also been JIT'd and they are safe to call or use. **Removable Code**; Resources for JIT'd program representations. **Orthogonality** and **Composability**; Each of the features above can be used independently. It is possible to put; ORC components together to make a non-lazy, in-process, single threaded JIT; or a lazy, out-of-process, concurrent JIT, or anything in between. LLJIT and LLLazyJIT; ===================. ORC provides two basic JIT",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:2633,wrap,wrapper,2633,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['wrap'],['wrapper']
Integrability,"ne specified; by the user when supplying the starting values for minimization. The starting values must be specified by the user, either via an; std::vector$<$double$>$ or the MnUserParameters (see [api:parameters]); supplied as input to the M minimizers such as VariableMetricMinimizer or; MnMigrad (see [api:migrad]). Later values are determined by M as it; searches for the minimum or performs whatever analysis is requested by; the user. ### FCNBase::up() ###. [howto:errordef] Returns the value of $\mbox{up}$ (default value; $= 1.$), defining parameter errors. M defines parameter errors as the; change in parameter value required to change the function value by; $\mbox{up}$. Normally, for chisquared fits $\mbox{up = 1}$, and; for negative log likelihood, $\mbox{up = 0.5}$. ### $\mbox{FCN}$ function with gradient ###. By default first derivatives are calculated numerically by M . In case; the user wants to supply their own gradient calculator (e.g. analytical; derivatives), they need to implement the FCNGradientBase interface. ![](figures/fcngradientbase.png). The size of the output vector is the same as of the input one. The same; is true for the position of the elements (first derivative of the; function with respect to the $n_\mathrm{th}$ variable has index $n$ in; the output vector). ## M parameters ##. Interaction with the parameters of the function are essential both for M; and the user. Different interfaces are provided, depending on the level; of interaction. ### Minimal required interface ###. Starting values of parameters and uncertainties can be provided to M by; the user via std::vector$<$double$>$ vector containers. Any interaction; with the parameters before minimization (fix, release, limits, etc.) is; not possible then. Optionally if the user wants to provide starting values for the; covariance, they have to provide the values in a std::vector$<$double$>$; vector container stored in upper triangular packed storage format (see; [api:covariance]). ### Mn",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:29960,interface,interface,29960,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['interface'],['interface']
Integrability,"necessary. The main difference is that; ``-fmodule-file=<path/to/BMI>`` will load the BMI eagerly, whereas; ``-fmodule-file=<module-name>=<path/to/BMI>`` will only load the BMI lazily, which is similar; with ``-fprebuilt-module-path``. The option ``-fmodule-file=<path/to/BMI>`` for named modules is deprecated; and is planning to be removed in future versions. In case all ``-fprebuilt-module-path=<path/to/directory>``, ``-fmodule-file=<path/to/BMI>`` and; ``-fmodule-file=<module-name>=<path/to/BMI>`` exist, the ``-fmodule-file=<path/to/BMI>`` option; takes highest precedence and ``-fmodule-file=<module-name>=<path/to/BMI>`` will take the second; highest precedence. We need to specify all the dependent (directly and indirectly) BMIs.; See https://github.com/llvm/llvm-project/issues/62707 for detail. When we compile a ``module implementation unit``, we must specify the BMI of the corresponding; ``primary module interface unit``.; Since the language specification says a module implementation unit implicitly imports; the primary module interface unit. [module.unit]p8. A module-declaration that contains neither an export-keyword nor a module-partition implicitly; imports the primary module interface unit of the module as if by a module-import-declaration. All of the 3 options ``-fprebuilt-module-path=<path/to/directory>``, ``-fmodule-file=<path/to/BMI>``; and ``-fmodule-file=<module-name>=<path/to/BMI>`` may occur multiple times.; For example, the command line to compile ``M.cppm`` in; the above example could be rewritten into:. .. code-block:: console. $ clang++ -std=c++20 M.cppm --precompile -fmodule-file=M:interface_part=M-interface_part.pcm -fmodule-file=M:impl_part=M-impl_part.pcm -o M.pcm. When there are multiple ``-fmodule-file=<module-name>=`` options for the same; ``<module-name>``, the last ``-fmodule-file=<module-name>=`` will override the previous; ``-fmodule-file=<module-name>=`` options. ``-fprebuilt-module-path`` is more convenient and ``-fmodule-file`` is f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:12758,interface,interface,12758,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['interface'],['interface']
Integrability,ned macro expressions in constant expressions and in; local structs.; - Correctly parse non-ascii identifiers that appear immediately after a line splicing; (`#65156 <https://github.com/llvm/llvm-project/issues/65156>`_); - Clang no longer considers the loss of ``__unaligned`` qualifier from objects as; an invalid conversion during method function overload resolution.; - Fix lack of comparison of declRefExpr in ASTStructuralEquivalence; (`#66047 <https://github.com/llvm/llvm-project/issues/66047>`_); - Fix parser crash when dealing with ill-formed objective C++ header code. Fixes; (`#64836 <https://github.com/llvm/llvm-project/issues/64836>`_); - Fix crash in implicit conversions from initialize list to arrays of unknown; bound for C++20. Fixes; (`#62945 <https://github.com/llvm/llvm-project/issues/62945>`_); - Clang now allows an ``_Atomic`` qualified integer in a switch statement. Fixes; (`#65557 <https://github.com/llvm/llvm-project/issues/65557>`_); - Fixes crash when trying to obtain the common sugared type of; `decltype(instantiation-dependent-expr)`.; Fixes (`#67603 <https://github.com/llvm/llvm-project/issues/67603>`_); - Fixes a crash caused by a multidimensional array being captured by a lambda; (`#67722 <https://github.com/llvm/llvm-project/issues/67722>`_).; - Fixes a crash when instantiating a lambda with requires clause.; (`#64462 <https://github.com/llvm/llvm-project/issues/64462>`_); - Fixes a regression where the ``UserDefinedLiteral`` was not properly preserved; while evaluating consteval functions. (`#63898 <https://github.com/llvm/llvm-project/issues/63898>`_).; - Fix a crash when evaluating value-dependent structured binding; variables at compile time.; Fixes (`#67690 <https://github.com/llvm/llvm-project/issues/67690>`_); - Fixes a ``clang-17`` regression where ``LLVM_UNREACHABLE_OPTIMIZE=OFF``; cannot be used with ``Release`` mode builds. (`#68237 <https://github.com/llvm/llvm-project/issues/68237>`_).; - Fix crash in evaluating ``constexpr`` v,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:36702,depend,dependent-expr,36702,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['depend'],['dependent-expr']
Integrability,"ned multiple times in different modules,; it is also possible for there to be multiple definitions of (for instance); a ``CXXRecordDecl``, all of which describe a definition of the same class.; In such a case, only one of those ""definitions"" is considered by Clang to be; the definition of the class, and the others are treated as non-defining; declarations that happen to also contain member declarations. Corresponding; members in each definition of such multiply-defined classes are identified; either by redeclaration chains (if the members are ``Redeclarable``); or by simply a pointer to the canonical declaration (if the declarations; are not ``Redeclarable`` -- in that case, a ``Mergeable`` base class is used; instead). Error Handling; --------------. Clang produces an AST even when the code contains errors. Clang won't generate; and optimize code for it, but it's used as parsing continues to detect further; errors in the input. Clang-based tools also depend on such ASTs, and IDEs in; particular benefit from a high-quality AST for broken code. In presence of errors, clang uses a few error-recovery strategies to present the; broken code in the AST:. - correcting errors: in cases where clang is confident about the fix, it; provides a FixIt attaching to the error diagnostic and emits a corrected AST; (reflecting the written code with FixIts applied). The advantage of that is to; provide more accurate subsequent diagnostics. Typo correction is a typical; example.; - representing invalid node: the invalid node is preserved in the AST in some; form, e.g. when the ""declaration"" part of the declaration contains semantic; errors, the Decl node is marked as invalid.; - dropping invalid node: this often happens for errors that we don’t have; graceful recovery. Prior to Recovery AST, a mismatched-argument function call; expression was dropped though a CallExpr was created for semantic analysis. With these strategies, clang surfaces better diagnostics, and provides AST; consumers",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:84535,depend,depend,84535,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['depend'],['depend']
Integrability,"need the header file. If you are simply returning a class instance from a; prototyped function or method, you don't need it. In fact, for most cases, you; simply don't need the definition of a class. And not ``#include``\ing speeds up; compilation. It is easy to try to go too overboard on this recommendation, however. You; **must** include all of the header files that you are using --- you can include; them either directly or indirectly through another header file. To make sure; that you don't accidentally forget to include a header file in your module; header, make sure to include your module header **first** in the implementation; file (as mentioned above). This way there won't be any hidden dependencies that; you'll find out about later. Keep ""Internal"" Headers Private; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Many modules have a complex implementation that causes them to use more than one; implementation (``.cpp``) file. It is often tempting to put the internal; communication interface (helper classes, extra functions, etc) in the public; module header file. Don't do this!. If you really need to do something like this, put a private header file in the; same directory as the source files, and include it locally. This ensures that; your private interface remains private and undisturbed by outsiders. .. note::. It's okay to put extra implementation methods in a public class itself. Just; make them private (or protected) and all is well. Use Namespace Qualifiers to Implement Previously Declared Functions; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When providing an out of line implementation of a function in a source file, do; not open namespace blocks in the source file. Instead, use namespace qualifiers; to help ensure that your definition matches an existing declaration. Do this:. .. code-block:: c++. // Foo.h; namespace llvm {; int foo(const char *s);; }. // Foo.cpp; #include ""Foo.h""; using namespace llvm;; int llvm::foo(const char *s) {; // ..",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:33282,interface,interface,33282,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['interface'],['interface']
Integrability,"nents that allow an easy way; to develop cross-platform GUI applications with a Windows look and feel. The main widgets are:. - Simple widgets: labels, icons, push buttons, either with text or; pixmaps, check buttons, radio buttons, menu bars and popup menus,; scroll bars, list boxes, combo boxes, group frames, text entry; widgets, tab widgets, progress bars, sliders, tool tips. - Complex widgets: shutter, toolbar, status bar, list view, list tree. - Common dialogs: File Open/Save, File Properties, Font Selection,; Color Selection, About. - The widgets are shown in frames:. - frame, composite frame, main frame, transient frame, group frame. - Arranged by layout managers:. - horizontal layout, vertical layout, row layout, list layout, tile; layout, matrix layout. Using a combination of layout hints:. - left, right, center x, center y, top, bottom, expand x, expand y,; fixed offsets. Event handling by signals/slots and messaging (as opposed to callbacks):. - in response to actions widgets send messages and emit signals. - associated frames process these messages or the slot methods; connected to the signals are executed. ## TVirtualX. The GUI classes interface to the platform dependent low level graphics; system via the semi-abstract graphics base class **`TVirtualX`**.; Currently concrete implementations exist for X11 and Win32 (MacOS X is; fully supported via Apple's X11 implementation). Thanks to this single; graphics interface, porting the ROOT GUI to a new platform requires only; the implementation of **`TVirtualX`**. ![](pictures/02000201.jpg). ## A Simple Example. We will start with a simple example that builds a small application; containing a canvas and two buttons: Draw and Exit. Its functionality; will be very simple: every time you click on Draw button, the graphics; of the function `sin(x)/x` will be drawn in randomly chosen interval in; the canvas window, if you click on Exit - you close the application.; This example shows the basic concepts for almost a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:2129,message,messages,2129,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['message'],['messages']
Integrability,"nerated by the compiler on an as-needed basis. When a module is imported (e.g., by an ``#include`` of one of the module's headers), the compiler will spawn a second instance of itself [#]_, with a fresh preprocessing context [#]_, to parse just the headers in that module. The resulting Abstract Syntax Tree (AST) is then persisted into the binary representation of the module that is then loaded into translation unit where the module import was encountered. The binary representation of modules is persisted in the *module cache*. Imports of a module will first query the module cache and, if a binary representation of the required module is already available, will load that representation directly. Thus, a module's headers will only be parsed once per language configuration, rather than once per translation unit that uses the module. Modules maintain references to each of the headers that were part of the module build. If any of those headers changes, or if any of the modules on which a module depends change, then the module will be (automatically) recompiled. The process should never require any user intervention. Command-line parameters; -----------------------; ``-fmodules``; Enable the modules feature. ``-fbuiltin-module-map``; Load the Clang builtins module map file. (Equivalent to ``-fmodule-map-file=<resource dir>/include/module.modulemap``). ``-fimplicit-module-maps``; Enable implicit search for module map files named ``module.modulemap`` and similar. This option is implied by ``-fmodules``. If this is disabled with ``-fno-implicit-module-maps``, module map files will only be loaded if they are explicitly specified via ``-fmodule-map-file`` or transitively used by another module map file. ``-fmodules-cache-path=<directory>``; Specify the path to the modules cache. If not provided, Clang will select a system-appropriate default. ``-fno-autolink``; Disable automatic linking against the libraries associated with imported modules. ``-fmodules-ignore-macro=macroname`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:14202,depend,depends,14202,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['depend'],['depends']
Integrability,"nes are necessary for the bins to be well defined; ; std::pair binEdges = fBins->GetBinEdges(b);; . Example 4: perform queries on bin b information; ; Double_t density = GetBinDensity(b);; Double_t volume = GetBinVolume(b);; Double_t* center = GetBinCenter(b);; . The tutorial math/kdTreeBinning.C is an example on; how to use this class. New statistical functions ROOT::Math::landau_quantile (inverse of landau cumulative distribution); translated from RANLAN and; ROOT::Math::landau_quantile_c.; ; New statistical functions; ROOT::Math::negative_binomial_pdf and the cumulative distributions; ROOT::Math::negative_binomial_cdf and ROOT::Math::negative_binomial_cdf_c.; ; New special functions: sine and cosine integral, translated by; B. List from CERNLIB:; ROOT::Math::sinint and ROOT::Math::cosint. New classes ROOT::Math::IOptions and; ROOT::Math::GenAlgoOptions for dealing in general with the; options for the numerical algorithm. The first one is the interface; for the second and defines the setting and retrieval of generic pair; of (name,value) options.; They are used for defining possible extra; options for the minimizer, integration and sampler options.; ; Integration classes:; ; Fix a bug in the templated method setting the integrand; function; Use now IntegrationOneDim::kADAPTIVESINGULAR as default method for the 1D; integration; Add the method IntegrationOneDim::kLEGENDRE based on; the GaussLegendreIntegrator class. ; Implement also for the GaussIntegrator and; GaussLegendreIntegrator the undefined and semi-undefined integral; using a function transformation as it is done in the GSLIntegrator; Fix a bug in IntegratorOneDim::SetAbsTolerance; New class ROOT::Math::IntegratorOptions which can be passed to; all integrator allowing the user to give options to the class and in; particular default value. Via the support for extra options (with; the class ROOT::Math::IOptions generic (string,value); options can be used in the base class to define specific options for; the im",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v528/index.html:4986,interface,interface,4986,math/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v528/index.html,2,['interface'],['interface']
Integrability,"nformation collected during the linker's normal symbol resolution phase.; In the above example, the optimizer can not remove ``foo2()`` without the; linker's input because it is externally visible. This in turn prohibits the; optimizer from removing ``foo3()``. **Use separate tool to collect symbol information from all object files.**; In this model, a new, separate, tool or library replicates the linker's; capability to collect information for link time optimization. Not only is; this code duplication difficult to justify, but it also has several other; disadvantages. For example, the linking semantics and the features provided; by the linker on various platform are not unique. This means, this new tool; needs to support all such features and platforms in one super tool or a; separate tool per platform is required. This increases maintenance cost for; link time optimizer significantly, which is not necessary. This approach; also requires staying synchronized with linker developments on various; platforms, which is not the main focus of the link time optimizer. Finally,; this approach increases end user's build time due to the duplication of work; done by this separate tool and the linker itself. Multi-phase communication between ``libLTO`` and linker; =======================================================. The linker collects information about symbol definitions and uses in various; link objects which is more accurate than any information collected by other; tools during typical build cycles. The linker collects this information by; looking at the definitions and uses of symbols in native .o files and using; symbol visibility information. The linker also uses user-supplied information,; such as a list of exported symbols. LLVM optimizer collects control flow; information, data flow information and knows much more about program structure; from the optimizer's point of view. Our goal is to take advantage of tight; integration between the linker and the optimizer by ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LinkTimeOptimization.rst:4341,synchroniz,synchronized,4341,interpreter/llvm-project/llvm/docs/LinkTimeOptimization.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LinkTimeOptimization.rst,1,['synchroniz'],['synchronized']
Integrability,"ng -fsyntax-only t.c; t.c:7:39: error: invalid operands to binary expression ('int' and 'struct A'); return y + func(y ? ((SomeA.X + 40) + SomeA) / 42 + SomeA.X : SomeA.X);; ~~~~~~~~~~~~~~ ^ ~~~~~. Here you can see that you don't even need to see the original source code to; understand what is wrong based on the Clang error: Because Clang prints a; caret, you know exactly which plus it is complaining about. The range; information highlights the left and right side of the plus which makes it; immediately obvious what the compiler is talking about, which is very useful for; cases involving precedence issues and many other situations.; Clang diagnostics are very polished and have many features. For more; information and examples, please see the Expressive; Diagnostics page. GCC Compatibility. GCC is currently the defacto-standard open source compiler today, and it; routinely compiles a huge volume of code. GCC supports a huge number of; extensions and features (many of which are undocumented) and a lot of; code and header files depend on these features in order to build.; While it would be nice to be able to ignore these extensions and focus on; implementing the language standards to the letter, pragmatics force us to; support the GCC extensions that see the most use. Many users just want their; code to compile, they don't care to argue about whether it is pedantically C99; or not.; As mentioned above, all; extensions are explicitly recognized as such and marked with extension; diagnostics, which can be mapped to warnings, errors, or just ignored. Utility and Applications. Library Based Architecture. A major design concept for clang is its use of a library-based; architecture. In this design, various parts of the front-end can be cleanly; divided into separate libraries which can then be mixed up for different needs; and uses. In addition, the library-based approach encourages good interfaces; and makes it easier for new developers to get involved (because they only ne",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:3267,depend,depend,3267,interpreter/llvm-project/clang/www/features.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html,2,['depend'],['depend']
Integrability,"ng 3.1. User-defined literals; N2765; Clang 3.1. Standard Layout Types; N2342; Clang 3.0. Defaulted functions; N2346; Clang 3.0. ; P1286R2 (DR); Clang 9. Deleted functions; N2346; Clang 2.9. Extended friend declarations; N1791; Clang 2.9. Extending sizeof; N2253; DR850; Clang 3.1. Inline namespaces; N2535; Clang 2.9. Unrestricted unions; N2544; Clang 3.1. Local and unnamed types as template arguments; N2657; Clang 2.9. Range-based for; N2930; Clang 3.0. P0962R1 (DR); Clang 8. Explicit virtual overrides; N2928; N3206; N3272; Clang 3.0. Minimal support for garbage collection and reachability-based leak detection; N2670; N/A (2). Allowing move constructors to throw [noexcept]; N3050; Clang 3.0. Defining move special member functions; N3053; Clang 3.0. Concurrency. Sequence points; N2239; Clang 3.3. Atomic operations; N2427; Clang 3.1. Strong Compare and Exchange; N2748; Clang 3.1 (3). Bidirectional Fences; N2752; Clang 3.1. Memory model; N2429; Clang 3.2. Data-dependency ordering: atomics and memory model; N2664; Clang 3.2 (4). Propagating exceptions; N2179; Clang 2.9. Allow atomics use in signal handlers; N2547; Clang 3.1. Thread-local storage; N2659; Clang 3.3 (5). Dynamic initialization and destruction with concurrency; N2660; Clang 2.9. C99 Features in C++11. __func__ predefined identifier; N2340; Clang 2.9. C99 preprocessor; N1653; Clang 2.9. long long; N1811; Clang 2.9. Extended integral types; N1988; N/A (6). (1): The [[carries_dependency]] attribute; has no effect.; (2): No compiler changes are required for an implementation; such as Clang that does not provide garbage collection.; (3): All compare-exchange operations are emitted as; strong compare-exchanges.; (4): memory_order_consume is lowered to; memory_order_acquire.; (5): thread_local support; requires a C++ runtime library providing __cxa_thread_atexit, such; as libc++abi 3.6 or later,; or libsupc++ 4.8 or later.; (6): No compiler changes are required for an implementation; such as Clang that does not pr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:17721,depend,dependency,17721,interpreter/llvm-project/clang/www/cxx_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html,2,['depend'],['dependency']
Integrability,ng an Objective-C method. @interface MyClass1 : NSObject; - (int)foo;; @end. @implementation MyClass1; - (int)foo { return 1; }; @end. @interface MyClass2 : MyClass1; - (float)foo;; @end. @implementation MyClass2; - (float)foo { return 1.0; } // warn; @end. osx.cocoa.MissingSuperCall; (ObjC); Warn about Objective-C methods that lack a necessary call to super. (Note: The; compiler now has a warning for methods annotated with objc_requires_super; attribute. The checker exists to check methods in the Cocoa frameworks; that haven't yet adopted this attribute.). @interface Test : UIViewController; @end; @implementation test; - (void)viewDidLoad {} // warn; @end. osx.cocoa.NSAutoreleasePool; (ObjC); Warn for suboptimal uses of NSAutoreleasePool in Objective-C; GC mode (-fobjc-gc compiler option). void test() {; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; [pool release]; // warn; }. osx.cocoa.NSError; (ObjC); Check usage of NSError** parameters. @interface A : NSObject; - (void)foo:(NSError **)error;; @end. @implementation A; - (void)foo:(NSError **)error {; // warn: method accepting NSError** should have a non-void; // return value; }; @end. @interface A : NSObject; - (BOOL)foo:(NSError **)error;; @end. @implementation A; - (BOOL)foo:(NSError **)error {; *error = 0; // warn: potential null dereference; return 0;; }; @end. osx.cocoa.NilArg; (ObjC); Check for prohibited nil arguments in specific Objective-C method calls:; - caseInsensitiveCompare:; - compare:; - compare:options:; - compare:options:range:; - compare:options:range:locale:; - componentsSeparatedByCharactersInSet:; - initWithFormat:. NSComparisonResult test(NSString *s) {; NSString *aString = nil;; return [s caseInsensitiveCompare:aString];; // warn: argument to 'NSString' method; // 'caseInsensitiveCompare:' cannot be nil; }. osx.cocoa.ObjCGenerics; (ObjC); Check for type errors when using Objective-C generics. NSMutableArray *names = [NSMutableArray array];; NSMutableArray *birthDates = names;,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:17072,interface,interface,17072,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,2,['interface'],['interface']
Integrability,"ng constant-term precalculation optimization in roofit likelihoods as these are now; also stored in vectors rather than trees. The faster access speed of vectors make that the constant; term optimization inside likelihoods results in a larger speed increase. This is particulatly noticeable in pdfs with; many constant expressions from pdfs that were moderately fast to begin with (e.g. RooHistPdf).; The second advantages allows new types of algorithmic likelihood optimization in RooFit detailed below. New algorithmic optimization in the caching of pdfs. So far - in the likelihood - two classes of; objects are identified: those that change with every event (i.e. the pdf) and those that change; only with the parameters (typically pdf normalization integrals). Pdfs are always recalculated; for every event, whereas integrals are only evaluated when needed. The exception to the first type are pdfs; that only depend on constant parameters (or no parameters) - these are identified at the beginning, and precalculated once ; to avoid recalculating an expression with the same outcome for every iteration of the likelihood calculation. For composite pdfs a further optimization has been included: for a M(x,a,b) = f*F(x,a)+(1-f)G(x,b) ; it is e.g. not needed to recalculate G(x,b) if only parameter a has changed w.r.t to the previous likelihood; calculation. This optimization is now implemented by extending the value caching originally designed; for constant terms to be usable for non-constant terms, with a check executed at the beginning of each; likelihood evaluation if selected columns need to be updated because parameters have changed. The speed gain; of this optimization depends much on the structure of the pdf: in models with many free parameters most of the; likelihood evaluations are executed when MINUIT calculates numerical likelihood derivatives which vary ; one parameter at a time and the speedup is potentially larger. In models with few free parameters the; effect will be",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v532/index.html:2089,depend,depend,2089,roofit/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v532/index.html,2,['depend'],['depend']
Integrability,"ng directives look for unordered log entries for two tasks in a; parallel program, such as the OpenMP runtime:. .. code-block:: text. // CHECK-DAG: [[THREAD_ID:[0-9]+]]: task_begin; // CHECK-DAG: [[THREAD_ID]]: task_end; //; // CHECK-DAG: [[THREAD_ID:[0-9]+]]: task_begin; // CHECK-DAG: [[THREAD_ID]]: task_end. The second pair of directives is guaranteed not to match the same log entries; as the first pair even though the patterns are identical and even if the text; of the log entries is identical because the thread ID manages to be reused. The ""CHECK-LABEL:"" directive; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Sometimes in a file containing multiple tests divided into logical blocks, one; or more ``CHECK:`` directives may inadvertently succeed by matching lines in a; later block. While an error will usually eventually be generated, the check; flagged as causing the error may not actually bear any relationship to the; actual source of the problem. In order to produce better error messages in these cases, the ""``CHECK-LABEL:``""; directive can be used. It is treated identically to a normal ``CHECK``; directive except that FileCheck makes an additional assumption that a line; matched by the directive cannot also be matched by any other check present in; ``match-filename``; this is intended to be used for lines containing labels or; other unique identifiers. Conceptually, the presence of ``CHECK-LABEL`` divides; the input stream into separate blocks, each of which is processed independently,; preventing a ``CHECK:`` directive in one block matching a line in another block.; If ``--enable-var-scope`` is in effect, all local variables are cleared at the; beginning of the block. For example,. .. code-block:: llvm. define %struct.C* @C_ctor_base(%struct.C* %this, i32 %x) {; entry:; ; CHECK-LABEL: C_ctor_base:; ; CHECK: mov [[SAVETHIS:r[0-9]+]], r0; ; CHECK: bl A_ctor_base; ; CHECK: mov r0, [[SAVETHIS]]; %0 = bitcast %struct.C* %this to %struct.A*; %call = tail call %struct.A* @A_ctor_base",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:21722,message,messages,21722,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['message'],['messages']
Integrability,"ng eager execution on macos; list(APPEND pyveto tmva/keras/RegressionKeras.py); list(APPEND pyveto tmva/keras/ApplicationRegressionKeras.py); list(APPEND pyveto tmva/keras/MultiClassKeras.py); endif(). if (PY_KERAS_FOUND); set (tmva-TMVA_SOFIE_RDataFrame-py-depends tutorial-tmva-TMVA_SOFIE_Keras_HiggsModel); endif(). if(NOT PY_TORCH_FOUND); file(GLOB tmva_veto_py RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} tmva/pytorch/*.py); list(APPEND pyveto ${tmva_veto_py}); endif(); # disable PyTorch model file used by TMVA_CNN_Classification.C; list(APPEND pyveto tmva/PyTorch_Generate_CNN_Model.py). if(NOT ROOT_geom_FOUND); list(APPEND pyveto pyroot/geometry.py); endif(). # Now glob all vetos for pyroot; file(GLOB pyveto RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} ${pyveto}). list(LENGTH pytutorials nTotal); # Apply global .C/.py veto from above:; list(REMOVE_ITEM pytutorials ${tutorials_veto}); list(REMOVE_ITEM pytutorials ${pyveto}); list(LENGTH pytutorials nAfterVeto). message(STATUS ""${nAfterVeto}/${nTotal} python tutorials have been activated.""). #---Python tutorials dependencies--------------------------------------; set(pyroot-ntuple1-depends tutorial-pyroot-hsimple-py); set(pyroot-h1ReadAndDraw-depends tutorial-pyroot-hsimple-py); set(pyroot-benchmarks-depends tutorial-pyroot-hsimple-py; tutorial-pyroot-fit1-py; tutorial-pyroot-na49view-py; tutorial-pyroot-h1ReadAndDraw-py; tutorial-pyroot-ntuple1-py); set(pyroot-fit1-depends tutorial-hist-fillrandom-py); set(pyroot-na49view-depends tutorial-pyroot-geometry-py); set(roofit-rf503_wspaceread-depends tutorial-roofit-rf502_wspacewrite-py); set(roofit-rf618_mixture_models-depends tutorial-dataframe-df106_HiggsToFourLeptons-py). # Avoid a race condition: make sure Python tutorial is run after C++ tutorial; set(roofit-rf104_classfactory-depends tutorial-roofit-rf104_classfactory); set(roofit-rf512_wsfactory_oper-depends tutorial-roofit-rf512_wsfactory_oper); set (tmva-TMVA_Higgs_Classification-depends tutorial-tmva-TMVA_Higgs_Classificatio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt:30702,message,message,30702,tutorials/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt,1,['message'],['message']
Integrability,"ng on; different CUs accessing different L0s), can be reordered relative to each; other. A ``s_waitcnt vmcnt(0) & vscnt(0)`` is required to ensure; synchronization between vector memory operations of different wavefronts. It; ensures a previous vector memory operation has completed before executing a; subsequent vector memory or LDS operation and so can be used to meet the; requirements of acquire, release and sequential consistency.; * The L1 caches use an L2 cache shared by all SAs on the same agent.; * The L2 cache has independent channels to service disjoint ranges of virtual; addresses.; * Each L1 quadrant of a single SA accesses a different L2 channel. Each L1; quadrant has a separate request queue per L2 channel. Therefore, the vector; and scalar memory operations performed by wavefronts executing in different; work-groups (which may be executing on different SAs) of an agent can be; reordered relative to each other. A ``s_waitcnt vmcnt(0) & vscnt(0)`` is; required to ensure synchronization between vector memory operations of; different SAs. It ensures a previous vector memory operation has completed; before executing a subsequent vector memory and so can be used to meet the; requirements of acquire, release and sequential consistency.; * The L2 cache can be kept coherent with other agents on some targets, or ranges; of virtual addresses can be set up to bypass it to ensure system coherence.; * On GFX10.3 and GFX11 a memory attached last level (MALL) cache exists for GPU memory.; The MALL cache is fully coherent with GPU memory and has no impact on system; coherence. All agents (GPU and CPU) access GPU memory through the MALL cache. Scalar memory operations are only used to access memory that is proven to not; change during the execution of the kernel dispatch. This includes constant; address space and global address space for program scope ``const`` variables.; Therefore, the kernel machine code does not have to maintain the scalar cache to; ensure it is cohe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:339294,synchroniz,synchronization,339294,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['synchroniz'],['synchronization']
Integrability,"ng rendered into. It also is much better optimized for; sessions where the user is forwarding X11 windows through an `ssh` connection. For the most part, the COL2 and COLZ2 options are a drop in replacement to the COL; and COLZ options. There is one major difference and that concerns the treatment of; bins with zero content. The COL2 and COLZ2 options color these bins the color of zero. This has been implemented by Jeromy Tompkins <Tompkins@nscl.msu.edu>. ## Geometry Libraries; A new module geom/vecgeom was introduced to give transparent access to VecGeom ; solid primitives. VecGeom is a high performance geometry package (link) providing ; SIMD vectorization for the CPU-intensive geometry algorithms used for geometry; navigation. The module creates a new library libConverterVG.so depending on the; VecGeom main library and loaded using the ROOT plug-in mechanism. The main functionality provided by the new vecgeom module is to make a conversion ; in memory of all the shapes in a loaded TGeo geometry into a special adapter; shape TGeoVGShape, redirecting all navigation calls to the corresponding VecGeom ; solid. The library loading and geometry conversion can be done with a single call ; `TVirtualGeoConverter::Instance()->ConvertGeometry()`; . After the conversion is done, all existing TGeo functionality is available as for; a native geometry, only that most of the converted solids provide better navigation ; performance, despite the overhead introduced by the new adapter shape. Prerequisites: installation of VecGeom. ; The installation instructions are available at <http://geant.web.cern.ch/content/installation>; Due to the fact that VecGeom provides for the moment static libraries ; and depends on ROOT, is is advised to compile first ROOT without VecGeom support, ; then compile VecGeom against this ROOT version, then re-configure ROOT to enable ; VecGeom and Vc support, using the flags -Dvc=ON -Dvecgeom=on; ; This has been implemented by Mihaela Gheata <Mihaela.Gheat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:23592,adapter,adapter,23592,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,1,['adapter'],['adapter']
Integrability,"ng so would allow dependency to outlive the; full-expression which produced the original value. For example, the; address of an instance variable could be written to some global; location and then freely accessed during the lifetime of the local,; or a function could return an inner pointer of an object and store; it to a local. These cases would be potentially impossible to; reason about and so would basically prevent any optimizations based; on imprecise lifetime. There are also uncommon enough to make it; reasonable to require the precise-lifetime annotation if someone; really wants to rely on them. Dependency does propagate through return values of pointer type.; The compelling source of need for this rule is a property accessor; which returns an un-autoreleased result; the calling function must; have the chance to operate on the value, e.g. to retain it, before; ARC releases the original pointer. Note again, however, that; dependence does not survive a store, so ARC does not guarantee the; continued validity of the return value past the end of the; full-expression. .. _arc.optimization.object_lifetime:. No object lifetime extension; ----------------------------. If, in the formal computation history of the program, an object ``X``; has been deallocated by the time of an observable side-effect, then; ARC must cause ``X`` to be deallocated by no later than the occurrence; of that side-effect, except as influenced by the re-ordering of the; destruction of objects. .. admonition:: Rationale. This rule is intended to prohibit ARC from observably extending the; lifetime of a retainable object, other than as specified in this; document. Together with the rule limiting the transformation of; releases, this rule requires ARC to eliminate retains and release; only in pairs. ARC's power to reorder the destruction of objects is critical to its; ability to do any optimization, for essentially the same reason that; it must retain the power to decrease the lifetime of an obje",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:82244,depend,dependence,82244,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['depend'],['dependence']
Integrability,"ng the ``-fxray-instrumentation-bundle=`` flag. For example if you only wanted to; instrument function entry and custom points you could specify:. ::. clang -fxray-instrument -fxray-instrumentation-bundle=function-entry,custom ... This will omit the other sled types entirely, reducing the binary size. You can also; instrument just a sampled subset of functions using instrumentation groups.; For example, to instrument only a quarter of available functions invoke:. ::. clang -fxray-instrument -fxray-function-groups=4. A subset will be chosen arbitrarily based on a hash of the function name. To sample a; different subset you can specify ``-fxray-selected-function-group=`` with a group number; in the range of 0 to ``xray-function-groups`` - 1. Together these options could be used; to produce multiple binaries with different instrumented subsets. If all you need is; runtime control over which functions are being traced at any given time it is better; to selectively patch and unpatch the individual functions you need using the XRay; Runtime Library's ``__xray_patch_function()`` method. Future Work; ===========. There are a number of ongoing efforts for expanding the toolset building around; the XRay instrumentation system. Trace Analysis Tools; --------------------. - Work is in progress to integrate with or develop tools to visualize findings; from an XRay trace. Particularly, the ``stack`` tool is being expanded to; output formats that allow graphing and exploring the duration of time in each; call stack.; - With a large instrumented binary, the size of generated XRay traces can; quickly become unwieldy. We are working on integrating pruning techniques and; heuristics for the analysis tools to sift through the traces and surface only; relevant information. More Platforms; --------------. We're looking forward to contributions to port XRay to more architectures and; operating systems. .. References... .. _`XRay whitepaper`: http://research.google.com/pubs/pub45287.html. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRay.rst:14443,integrat,integrate,14443,interpreter/llvm-project/llvm/docs/XRay.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRay.rst,2,['integrat'],"['integrate', 'integrating']"
Integrability,"ng traversal of class hierarchy of the; selected object, executed from method **`TGedEditor::SetModel()`**.; When a new object of a different class is selected, the unneeded; GED-frames are cached in memory for potential reuse. The frames are; deleted automatically when the editor is closed. Note: A deep cleanup is assumed for all frames put into the editor. This; implies:. - do not share the layout-hints among GUI components;. - do not delete child widgets in the destructor as this is done; automatically. #### Using Several Tabs. Sometimes you might need to use several tabs to organize properly your; class-editor. Each editor tab is a resource shared among all the; class-editors. Tabs must be created from the constructor of your; editor-class by using the method:. ``` {.cpp}; TGVerticalFrame* TGedFrame::CreateEditorTabSubFrame(const Text_t *name),; ```. It returns a pointer to a new tab container frame ready for use in your; class. If you need to hide/show this frame depending on the object's; status, you should store it in a data member. See for examples:; **`TH1Editor`**, **`TH2Editor`**. #### Base-Class Editors Control. Full control over base-class editors can be achieved by re-implementing; virtual method void `TGedFrame::ActivateBaseClassEditors(TClass` `*cl)`.; It is called during each compound editor rebuild and the default; implementation simply offers all base-classes to the publishing; mechanism. To prevent inclusion of a base-class into the compound editor, call:. ``` {.cpp}; void TGedEditor::ExcludeClassEditor(TClass* class, Bool_t recurse); ```. Pointer to the compound GED-editor is available in **`TGedFrame`**‘s; data-member:. ``` {.cpp}; TGedEditor *fGedEditor; ```. Ordering of base-class editor frames follows the order of the classes in; the class hierarchy. This order can be changed by modifying the value of; **`TGedFrame`**'s data member `Int_t fPriority`. The default value is; 50; smaller values move the frame towards to the top. This priority; sh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/doc/index.md:5509,depend,depending,5509,gui/ged/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/doc/index.md,1,['depend'],['depending']
Integrability,"nged, the compiler will produce a; warning (under the control of ``-Wconfig-macros``). **Example:** A logging library might provide different API (e.g., in the form of different definitions for a logging macro) based on the ``NDEBUG`` macro setting:. .. parsed-literal::. module MyLogger {; umbrella header ""MyLogger.h""; config_macros [exhaustive] NDEBUG; }. Conflict declarations; ~~~~~~~~~~~~~~~~~~~~~; A *conflict-declaration* describes a case where the presence of two different modules in the same translation unit is likely to cause a problem. For example, two modules may provide similar-but-incompatible functionality. .. parsed-literal::. *conflict-declaration*:; ``conflict`` *module-id* ',' *string-literal*. The *module-id* of the *conflict-declaration* specifies the module with which the enclosing module conflicts. The specified module shall not have been imported in the translation unit when the enclosing module is imported. The *string-literal* provides a message to be provided as part of the compiler diagnostic when two modules conflict. .. note::. Clang emits a warning (under the control of ``-Wmodule-conflict``); when a module conflict is discovered. **Example:**. .. parsed-literal::. module Conflicts {; explicit module A {; header ""conflict_a.h""; conflict B, ""we just don't like B""; }. module B {; header ""conflict_b.h""; }; }. Attributes; ----------; Attributes are used in a number of places in the grammar to describe specific behavior of other declarations. The format of attributes is fairly simple. .. parsed-literal::. *attributes*:; *attribute* *attributes*:sub:`opt`. *attribute*:; '[' *identifier* ']'. Any *identifier* can be used as an attribute, and each declaration specifies what attributes can be applied to it. Private Module Map Files; ------------------------; Module map files are typically named ``module.modulemap`` and live; either alongside the headers they describe or in a parent directory of; the headers they describe. These module maps typicall",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:48818,message,message,48818,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['message'],['message']
Integrability,"ngianmorph_8C.html) / [.py](https://root.cern/doc/v626/rf711__lagrangianmorph_8py.html)) and for a multi-parameter case ([rf712_lagrangianmorphfit.C](https://root.cern/doc/v626/rf712__lagrangianmorphfit_8C.html) / [.py](https://root.cern/doc/v626/rf712__lagrangianmorphfit_8py.html)). A `RooLagrangianMorphFunc` can also be created with the `RooWorkspace::factory` interface, showcased in [rf512_wsfactory_oper.C](https://root.cern/doc/v626/rf512__wsfactory__oper_8C.html) / [.py](https://root.cern/doc/master/rf512__wsfactory__oper_8py.html). ### Exporting and importing `RooWorkspace` to and from JSON and YML. The new component `RooFitHS3` implements serialization and; deserialization of `RooWorkspace` objects to and from JSON and YML.; The main class providing this functionality is; [RooJSONFactoryWSTool](https://root.cern/doc/v626/classRooJSONFactoryWSTool.html).; For now, this functionality is not feature complete with respect to; all available functions and pdfs available in `RooFit`, but provides; an interface that is easily extensible by users, which is documented; in the corresponding; [README](https://github.com/root-project/root/blob/master/roofit/hs3/README.md). It; is hoped that, though user contributions, a sufficiently comprehensive; library of serializers and deserializers will emerge over time. For more details, consult the tutorial [rf515_hfJSON](https://root.cern/doc/v626/rf515__hfJSON_8py.html). ### Creating RooFit datasets from RDataFrame; RooFit now contains two RDataFrame action helpers, `RooDataSetHelper` and `RooDataHistHelper`, which allow for creating RooFit datasets by booking an action:; ```c++; RooRealVar x(""x"", ""x"", -5., 5.);; RooRealVar y(""y"", ""y"", -50., 50.);; auto myDataSet = rdataframe.Book<double, double>(; RooDataSetHelper{""dataset"", // Name (directly forwarded to RooDataSet::RooDataSet()); ""Title of dataset"", // Title ( ~ "" ~ ); RooArgSet(x, y) }, // Variables to create in dataset; {""x"", ""y""} // Column names from RDataFrame; );; ```; Fo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:25636,interface,interface,25636,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['interface'],['interface']
Integrability,"nging to one of the following types:. - Freely variable: allowed to take on any value. - Variable with double sided limits: allowed to vary only between two; limits specified by the user. - Variable with single sided limits: allowed to vary only between one; upper or one lower limit specified by the user and unlimited to the; other side. - Fixed: originally defined as variable, but now taking on only the; value the parameter had at the moment it was fixed, or a value later; assigned by the user. - Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are; free and unbound. The user, in their $\mbox{FCN}$, must of course be able to ""see"" all; types of defined parameters, and they therefore have access to what we call; the *external parameter list*, that is, the parameters as he defined; them. On the other hand, the internal M minimizing routines only want to; ""see"" variable parameters without limits, and so they have access only; to the *internal parameter list* which is created from the external list; by the following transformation:. - Squeeze out all parameters that are not variable. - Transform all variable parameters with limits, so that the; transformed parameter can vary without limits. (See the next section; for details concerning this transformation.) Because this; transformation is non-linear, it is recommended to avoid putting; limits on parameters where they are not needed. As an example, suppose that the user has defined the following; parameters:. - Parameter 0, constant. - Parameter 1, freely variable. - Parameter 2, variable with limits. - Parameter 3, constant. - Parameter 4, freely variable. Then the internal parameter list would be as follows:. - Internal parameter 0 = external parameter 1. - Internal parameter 1 = external parameter 2, transformed; appropriately. - Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external para",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:6025,rout,routines,6025,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['rout'],['routines']
Integrability,"ngs; ================. In order to achieve a balance between performance and necessary guarantees,; there are six levels of atomicity. They are listed in order of strength; each; level includes all the guarantees of the previous level except for; Acquire/Release. (See also `LangRef Ordering <LangRef.html#ordering>`_.). .. _NotAtomic:. NotAtomic; ---------. NotAtomic is the obvious, a load or store which is not atomic. (This isn't; really a level of atomicity, but is listed here for comparison.) This is; essentially a regular load or store. If there is a race on a given memory; location, loads from that location return undef. Relevant standard; This is intended to match shared variables in C/C++, and to be used in any; other context where memory access is necessary, and a race is impossible. (The; precise definition is in `LangRef Memory Model <LangRef.html#memmodel>`_.). Notes for frontends; The rule is essentially that all memory accessed with basic loads and stores; by multiple threads should be protected by a lock or other synchronization;; otherwise, you are likely to run into undefined behavior. If your frontend is; for a ""safe"" language like Java, use Unordered to load and store any shared; variable. Note that NotAtomic volatile loads and stores are not properly; atomic; do not try to use them as a substitute. (Per the C/C++ standards,; volatile does provide some limited guarantees around asynchronous signals, but; atomics are generally a better solution.). Notes for optimizers; Introducing loads to shared variables along a codepath where they would not; otherwise exist is allowed; introducing stores to shared variables is not. See; `Optimization outside atomic`_. Notes for code generation; The one interesting restriction here is that it is not allowed to write to; bytes outside of the bytes relevant to a store. This is mostly relevant to; unaligned stores: it is not allowed in general to convert an unaligned store; into two aligned stores of the same width as",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst:6661,synchroniz,synchronization,6661,interpreter/llvm-project/llvm/docs/Atomics.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst,1,['synchroniz'],['synchronization']
Integrability,"nit`` method attempts to use the previous value; of ``self`` after the completion of a delegate init call. It is conventional,; but not required, for an ``init`` method to return ``self``. It is undefined behavior for a program to cause two or more calls to ``init``; methods on the same object, except that each ``init`` method invocation may; perform at most one delegate init call. .. _arc.family.semantics.result_type:. Related result types; ^^^^^^^^^^^^^^^^^^^^. Certain methods are candidates to have :arc-term:`related result types`:. * class methods in the ``alloc`` and ``new`` method families; * instance methods in the ``init`` family; * the instance method ``self``; * outside of ARC, the instance methods ``retain`` and ``autorelease``. If the formal result type of such a method is ``id`` or protocol-qualified; ``id``, or a type equal to the declaring class or a superclass, then it is said; to have a related result type. In this case, when invoked in an explicit; message send, it is assumed to return a type related to the type of the; receiver:. * if it is a class method, and the receiver is a class name ``T``, the message; send expression has type ``T*``; otherwise; * if it is an instance method, and the receiver has type ``T``, the message; send expression has type ``T``; otherwise; * the message send expression has the normal result type of the method. This is a new rule of the Objective-C language and applies outside of ARC. .. admonition:: Rationale. ARC's automatic code emission is more prone than most code to signature; errors, i.e. errors where a call was emitted against one method signature,; but the implementing method has an incompatible signature. Having more; precise type information helps drastically lower this risk, as well as; catching a number of latent bugs. .. _arc.optimization:. Optimization; ============. Within this section, the word :arc-term:`function` will be used to; refer to any structured unit of code, be it a C function, an; Objective-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:74637,message,message,74637,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['message'],['message']
Integrability,"nitialized. In this case; the argument is not initialized in the function so the temporary is still; uninitialized when it is copied back to the argument expression. This is; undefined behavior in HLSL, and any use of the argument after the call is a use; of an undefined value which may be illegal in the target (DXIL programs with; used or potentially used ``undef`` or ``poison`` values fail validation). Clang Implementation; ====================. .. note::. The implementation described here is a proposal. It has not yet been fully; implemented, so the current state of Clang's sources may not reflect this; design. A prototype implementation was built on DXC which is Clang-3.7 based.; The prototype can be found; `here <https://github.com/microsoft/DirectXShaderCompiler/pull/5249>`_. A lot; of the changes in the prototype implementation are restoring Clang-3.7 code; that was previously modified to its original state. The implementation in clang depends on two new AST nodes and minor extensions to; Clang's existing support for Objective-C write-back arguments. The goal of this; design is to capture the semantic details of HLSL function calls in the AST, and; minimize the amount of magic that needs to occur during IR generation. The two new AST nodes are ``HLSLArrayTemporaryExpr`` and ``HLSLOutParamExpr``,; which respectively represent the temporaries used for passing arrays by value; and the temporaries created for function outputs. Array Temporaries; -----------------. The ``HLSLArrayTemporaryExpr`` represents temporary values for input; constant-sized array arguments. This applies for all constant-sized array; arguments regardless of whether or not the parameter is constant-sized or; unsized. .. code-block:: c++. void SizedArray(float a[4]);; void UnsizedArray(float a[]);. void main() {; float arr[4] = {1, 1, 1, 1};; SizedArray(arr);; UnsizedArray(arr);; }. In the example above, the following AST is generated for the call to; ``SizedArray``:. .. code-block:: text. Cal",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/FunctionCalls.rst:5797,depend,depends,5797,interpreter/llvm-project/clang/docs/HLSL/FunctionCalls.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/FunctionCalls.rst,1,['depend'],['depends']
Integrability,"nitizer. It's experimental, so expect problems. For example, when building with gcc,; manipulations in global variables in llvm will abort the build. Such checks can be disabled using environment variables. Check the address; sanitizer documentation or the link below for details. In clang, which allows to blacklist functions, the build will continue. See [core/sanitizer](https://github.com/root-project/root/tree/master/core/sanitizer) for information. ### Optimization of ROOT header files. Many (but intentionally not all) unused includes were removed from ROOT header files. For instance, `#include ""TObjString.h""` and; `#include ""ThreadLocalStorage.h""` were removed from `TClass.h`. Or `#include ""TDatime.h""` was removed from; `TDirectory.h` header file . Or `#include ""TDatime.h""` was removed from `TFile.h`.; This change may cause errors during compilation of ROOT-based code. To fix it, provide missing the includes; where they are really required.; This improves compile times and reduces code inter-dependency; see https://github.com/include-what-you-use/include-what-you-use/blob/master/docs/WhyIWYU.md for a good overview of the motivation. Even more includes will be ""hidden"" when ROOT configured with `-Ddev=ON` build option.; In that case ROOT uses `#ifdef R__LESS_INCLUDES` to replace unused includes by class forward declarations.; Such `dev` builds can be used to verify that ROOT-based code really includes all necessary ROOT headers. ## RDataFrame. - Starting from this version, when `RSnapshotOptions.fMode` is `""UPDATE""` (i.e. the output file is opened in ""UPDATE""; mode), Snapshot will refuse to write out a TTree if one with the same name is already present in the output file.; Users can set the new flag `RSnapshotOption::fOverwriteIfExists` to `true` to force the deletion of the TTree that is; already present and the writing of a new TTree with the same name. See; [ROOT-10573](https://sft.its.cern.ch/jira/browse/ROOT-10573) for more details.; - RDataFrame changed its",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md:8736,depend,dependency,8736,README/ReleaseNotes/v622/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md,1,['depend'],['dependency']
Integrability,"nized(y) {} // warn: uninitialized value used as mutex; }. .. _osx-cocoa-AutoreleaseWrite:. osx.cocoa.AutoreleaseWrite; """"""""""""""""""""""""""""""""""""""""""""""""""""; Warn about potentially crashing writes to autoreleasing objects from different autoreleasing pools in Objective-C. .. _osx-cocoa-ClassRelease:. osx.cocoa.ClassRelease (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for sending 'retain', 'release', or 'autorelease' directly to a Class. .. code-block:: objc. @interface MyClass : NSObject; @end. void test(void) {; [MyClass release]; // warn; }. .. _osx-cocoa-Dealloc:. osx.cocoa.Dealloc (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C classes that lack a correct implementation of -dealloc. .. literalinclude:: checkers/dealloc_example.m; :language: objc. .. _osx-cocoa-IncompatibleMethodTypes:. osx.cocoa.IncompatibleMethodTypes (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C method signatures with type incompatibilities. .. code-block:: objc. @interface MyClass1 : NSObject; - (int)foo;; @end. @implementation MyClass1; - (int)foo { return 1; }; @end. @interface MyClass2 : MyClass1; - (float)foo;; @end. @implementation MyClass2; - (float)foo { return 1.0; } // warn; @end. .. _osx-cocoa-Loops:. osx.cocoa.Loops; """"""""""""""""""""""""""""""; Improved modeling of loops using Cocoa collection types. .. _osx-cocoa-MissingSuperCall:. osx.cocoa.MissingSuperCall (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C methods that lack a necessary call to super. .. code-block:: objc. @interface Test : UIViewController; @end; @implementation test; - (void)viewDidLoad {} // warn; @end. .. _osx-cocoa-NSAutoreleasePool:. osx.cocoa.NSAutoreleasePool (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn for suboptimal uses of NSAutoreleasePool in Objective-C GC mode. .. code-block:: objc. void test() {; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; [pool release]; // warn; }. .. _osx-cocoa-NSError:. osx.cocoa.NSError (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""; Check u",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:37268,interface,interface,37268,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['interface'],['interface']
Integrability,"nker developments on various; platforms, which is not the main focus of the link time optimizer. Finally,; this approach increases end user's build time due to the duplication of work; done by this separate tool and the linker itself. Multi-phase communication between ``libLTO`` and linker; =======================================================. The linker collects information about symbol definitions and uses in various; link objects which is more accurate than any information collected by other; tools during typical build cycles. The linker collects this information by; looking at the definitions and uses of symbols in native .o files and using; symbol visibility information. The linker also uses user-supplied information,; such as a list of exported symbols. LLVM optimizer collects control flow; information, data flow information and knows much more about program structure; from the optimizer's point of view. Our goal is to take advantage of tight; integration between the linker and the optimizer by sharing this information; during various linking phases. Phase 1 : Read LLVM Bitcode Files; ---------------------------------. The linker first reads all object files in natural order and collects symbol; information. This includes native object files as well as LLVM bitcode files.; To minimize the cost to the linker in the case that all .o files are native; object files, the linker only calls ``lto_module_create()`` when a supplied; object file is found to not be a native object file. If ``lto_module_create()``; returns that the file is an LLVM bitcode file, the linker then iterates over the; module using ``lto_module_get_symbol_name()`` and; ``lto_module_get_symbol_attribute()`` to get all symbols defined and referenced.; This information is added to the linker's global symbol table. The lto* functions are all implemented in a shared object libLTO. This allows; the LLVM LTO code to be updated independently of the linker tool. On platforms; that support it, the share",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LinkTimeOptimization.rst:5328,integrat,integration,5328,interpreter/llvm-project/llvm/docs/LinkTimeOptimization.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LinkTimeOptimization.rst,1,['integrat'],['integration']
Integrability,"nline. Theoretically, multiple header files can also be used and then mashed; together. > Directory path: [roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h](https://github.com/root-project/root/blob/master/roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h). ### Step 2. Override RooAbsArg::translate(). **translate() Example 1:** Continuing our RooPoisson example:. To translate the `RooPoisson` class, create a translate function and in it; include a call to the updated function. ``` {.cpp}; void RooPoisson::translate(RooFit::Detail::RooFit::Detail::CodeSquashContext &ctx) const; {; std::string xName = ctx.getResult(x);; if (!_noRounding); xName = ""std::floor("" + xName + "")"";; ctx.addResult(this, ctx.buildCall(""RooFit::Detail::MathFuncs::poissonEvaluate"", xName, mean));; }; ```. Here we can see that the name of the variable `x` (remember that ""x"" is a; member of RooPoisson) is retrieved and stored in the `xName` variable. Next,; there's an `if` condition that does an operation on `x` (may or may not round; it to the nearest integer, depending on the condition). The important part is where the `RooPoisson::addResult()` function helps add; the result of evaluating the Poisson function to the context (`ctx`). It uses; the `RooPoisson::buildCall()` method to construct a function call to the fully; qualified name of `MathFuncs::poissonEvaluate` (which now resides in the; `MathFuncs` file), with arguments `xName` and `mean`. Essentially, the `RooPoisson::translate()` function constructs a function call; to evaluate the Poisson function using 'x' and 'mean' variables, and adds the; result to the context. Helper Functions:. - `getResult()` helps lookup the result of a child node (the string that the; child node previously saved in a variable using the `addResult()` function). - `addResult()` It may include a function call, an expression, or something; more complicated. For a specific class, it will add whatever is represented on; the right-hand side to the result of that class, w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:12776,depend,depending,12776,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['depend'],['depending']
Integrability,"nmentForAnnotatedFunctions:. alpha.osx.cocoa.DirectIvarAssignmentForAnnotatedFunctions (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for direct assignments to instance variables in; the methods annotated with ``objc_no_direct_instance_variable_assignment``. .. code-block:: objc. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) fAnnotated __attribute__((; annotate(""objc_no_direct_instance_variable_assignment"")));; - (void) fNotAnnotated;; @end. @implementation MyClass; - (void) fAnnotated {; _A = 0; // warn; }; - (void) fNotAnnotated {; _A = 0; // no warn; }; @end. .. _alpha-osx-cocoa-InstanceVariableInvalidation:. alpha.osx.cocoa.InstanceVariableInvalidation (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that the invalidatable instance variables are; invalidated in the methods annotated with objc_instance_variable_invalidator. .. code-block:: objc. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interface SubclassInvalidationImpObj : InvalidationImpObj {; InvalidationImpObj *var;; }; - (void)invalidate;; @end. @implementation SubclassInvalidationImpObj; - (void) invalidate {}; @end; // warn: var needs to be invalidated or set to nil. .. _alpha-osx-cocoa-MissingInvalidationMethod:. alpha.osx.cocoa.MissingInvalidationMethod (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that the invalidation methods are present in classes that contain invalidatable instance variables. .. code-block:: objc. @protocol Invalidation <NSObject>; - (void)invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface NeedInvalidation : NSObject <Invalidation>; @end. @interface MissingInvalidationMethodDecl : NSObject {; NeedInvalidation *Var; // warn; }; @end. @implementation MissingInvalidationMethodDecl; @end. .. _alpha-osx-c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:58391,protocol,protocol,58391,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['protocol'],['protocol']
Integrability,"nned() has been implemented; that samples binned datasets (RooDataHist) from any; p.d.f. RooDataHist* data = pdf.generateBinned(x,10000) ;. This binned generation interface samples the p.d.f. at each bin; center and applies a Poisson fluctuation to each sampled value.; The binning of the returned RooDataHist is controlled by the default; binning associated with the observables generated. To set the number; of bins in x to 200, do e.g. x.setBins(200) prior to the call; to generateBinned(). The binned dataset generation method does not (yet) support the concept of; prototype datasets. New minimizer interface to Minuit2, GSLMinimizer etc... A new minimizer interface, RooMinimizer has been added (contribution; from Alfio Lazarro). The new minimizer is similar in functionality to; the existing class RooMinuit, but supports the new ROOT abstract; minimizer interface and supports multiple minimizer packages and algorithms; through that interface. The present interface of RooMinimizer is identical to that of RooMinuit; with two extensions. The setMinimizer(const char*) method allows to choose between ""minuit"" and ""minuit2""); as implementation for migrad(),hesse(),minos() etc...; The minimizer(const char* package, const char* alg) provides a completely generic interface; to all minimizers, where package is the package (minuit,GSLminimizer) and alg is the algorithm (migrad) to be used. By default, RooMinuit is still used when RooAbsPdf::fitTo() is called, but can be overridden with; a Minimizer() named argument. // Minimization with MINUIT/MIGRAD through RooMinuit; pdf->fitTo(data) ;. // Minimization with MINUIT/MIGRAD through RooMinimizer; pdf->fitTo(data,Minimizer(""minuit"")) ;. // Minimization with MINUIT2/MIGRAD through RooMinimizer; pdf->fitTo(data,Minimizer(""minuit2"")) ;. // Minimization with GSLMultiMin/conjugatefr through RooMinimizer; pdf->fitTo(data,Minimizer(""GSLMultiMin"",""conjugatefr"")) ;. Note that installation of GSL and the ROOT MathMore package is needed to acc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:3405,interface,interface,3405,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,2,['interface'],['interface']
Integrability,"nning); list(APPEND labels longtest); endif(); if(${t} IN_LIST multithreaded); list(APPEND labels multithreaded); # If this is not a TMVA tutorial, we want to limit the size of the thread; # pool in case the tutorial invokes ROOT::EnableImplicitMT(), which by; # default creates a thread pool of the size of the total number of cores.; if(${t} IN_LIST multithreaded_all_cores); set(createThreadPool ""-e \""ROOT::EnableImplicitMT(${NProcessors})\""""); endif(); else(); unset(createThreadPool); endif(). if(${t} IN_LIST need_network); list(APPEND labels needs_network); endif(). # These tests on ARM64 need much more than 20 minutes - increase the timeout; if(ROOT_ARCHITECTURE MATCHES arm64 OR ROOT_ARCHITECTURE MATCHES ppc64); set(thisTestTimeout 3000) # 50m; else(); set(thisTestTimeout 1200) # 20m; endif(). ROOT_ADD_TEST(tutorial-${tname}; COMMAND ${ROOT_root_CMD} -b -l -q ${createThreadPool} ${CMAKE_CURRENT_SOURCE_DIR}/${t}${${tname}-aclic}; PASSRC ${rc} FAILREGEX ""Error in <"" "": error:"" ""segmentation violation"" ""FROM HESSE STATUS=FAILED"" ""warning: Failed to call""; LABELS ${labels}; DEPENDS tutorial-hsimple ${${tname}-depends}; ENVIRONMENT ${TUTORIAL_ENV}; TIMEOUT ${thisTestTimeout}). if(${t} IN_LIST multithreaded); # Makes sure that this doesn't run in parallel with other multithreaded tutorials, and that cmake doesn't start too; # many other tests. That we use 4 processors is actually a lie, because IMT takes whatever it finds.; # However, even this poor indication of MT behaviour is a good hint for cmake to reduce congestion.; set_tests_properties(tutorial-${tname} PROPERTIES RESOURCE_LOCK multithreaded PROCESSORS ${NProcessors}); endif(); endforeach(). #---Loop over all MPI tutorials and define the corresponding test---------; foreach(t ${mpi_tutorials}); list(FIND returncode_1 ${t} index); if(index EQUAL -1); set(rc 0); else(); set(rc 255); endif(); string(REPLACE "".C"" """" tname ${t}); string(REPLACE ""/"" ""-"" tname ${tname}). # These tests on ARM64 need much more than 20 m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt:24571,depend,depends,24571,tutorials/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt,1,['depend'],['depends']
Integrability,"nnotation on the types named; inside ``typeof``, e.g., ``typeof(int *__bidi_indexable)``, which evaluates to; ``int *__bidi_indexable``. Default pointer types in ``sizeof()``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When ``sizeof()`` takes a type name, the compiler doesn't apply an implicit; bounds annotation on the named pointer types. This means if a bounds annotation; is not specified, the evaluated pointer type is treated identically to a plain C; pointer type. Therefore, ``sizeof(int*)`` remains the same with or without; ``-fbounds-safety``. That said, programmers can explicitly add attribute to the; types, e.g., ``sizeof(int *__bidi_indexable)``, in which case the sizeof; evaluates to the size of type ``int *__bidi_indexable`` (the value equivalent to; ``3 * sizeof(int*)``). When ``sizeof()`` takes an expression, i.e., ``sizeof(expr``, it behaves as; ``sizeof(typeof(expr))``, except that ``sizeof(expr)`` does not report an error; with ``expr`` that has a type with an external bounds annotation dependent on; another declaration, whereas ``typeof()`` on the same expression would be an; error as described in :ref:`Default pointer types in typeof`.; The following example describes this behavior. .. code-block:: c. void foo(int *__counted_by(size) p, size_t size) {; // sizeof(p) == sizeof(int *__counted_by(size)) == sizeof(int *); // typeof(p): error; };. Default pointer types in ``alignof()``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``alignof()`` only takes a type name as the argument and it doesn't take an; expression. Similar to ``sizeof()`` and ``typeof``, the compiler doesn't apply; an implicit bounds annotation on the pointer types named inside ``alignof()``.; Therefore, ``alignof(T *)`` remains the same with or without; ``-fbounds-safety``, evaluating into the alignment of the raw pointer ``T *``.; The programmers can explicitly add a bounds annotation to the types, e.g.,; ``alignof(int *__bidi_indexable)``, which returns the alignment of ``int; *__bidi_indexa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:28821,depend,dependent,28821,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['depend'],['dependent']
Integrability,"node.; It is also possible to combine some atomic nodes that have a simple; def-use dependency between them into larger nodes that contain multiple-; instructions. As described in [1]_ the DDG uses graph abstraction to group nodes; that are part of a strongly connected component of the graph; into special nodes called pi-blocks. pi-blocks represent cycles of data; dependency that prevent reordering transformations. Since any strongly; connected component of the graph is a maximal subgraph of all the nodes; that form a cycle, pi-blocks are at most one level deep. In other words,; no pi-blocks are nested inside another pi-block, resulting in a; hierarchical representation that is at most one level deep. For example, consider the following:. .. code-block:: c++. for (int i = 1; i < n; i++) {; b[i] = c[i] + b[i-1];; }. This code contains a statement that has a loop carried dependence on; itself creating a cycle in the DDG. The figure below illustrates; how the cycle of dependency is carried through multiple def-use relations; and a memory access dependency. .. image:: cycle.png. The DDG corresponding to this example would have a pi-block that contains; all the nodes participating in the cycle, as shown below:. .. image:: cycle_pi.png. Program Dependence Graph; ========================. The Program Dependence Graph (or PDG) has a similar structure as the; DDG, but it is capable of representing both data dependencies and; control-flow dependencies between program elements such as; instructions, groups of instructions, basic blocks or groups of; basic blocks. High-Level Design; =================. The DDG and the PDG are both directed graphs and they extend the; ``DirectedGraph`` class. Each implementation extends its corresponding; node and edge types resulting in the inheritance relationship depicted; in the UML diagram below:. .. image:: uml_nodes_and_edges.png. Graph Construction; ------------------. The graph build algorithm considers dependencies between elements of; a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst:1807,depend,dependency,1807,interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,2,['depend'],['dependency']
Integrability,"non-split mode.; In non-split mode, the full event must be read in memory. The times; reported in the table correspond to complete I/O operations necessary to; deal with **machine independent binary files**. On **Linux**, this also; includes byte-swapping operations. The ROOT file allows for direct; access to any event in the file and direct access to any part of an; event when split=1. Note also that the uncompressed file generated with split=0 is 48.7; Mbytes and only 47.17 Mbytes for the option split=1. The difference in; size is due to the object identification mechanism overhead when the; event is written to a single buffer. This overhead does not exist in; split mode because the branch buffers are optimized for homogeneous data; types. You can run the test programs on your architecture. The program; `Event` will report the write performance. You can measure the read; performance by executing the scripts `eventa` and `eventb`. The; performance depends not only of the processor type, but also of the disk; devices (local, NFS, AFS, etc.). ## Chains; \index{tree!chains}. A **`TChain`** object is a list of ROOT files containing the same tree.; As an example, assume we have three files called; `file1.root, file2.root, file3.root`. Each file contains one tree called; ""`T`"". We can create a chain with the following statements:. ``` {.cpp}; TChain chain(""T""); // name of the tree is the argument; chain.Add(""file1.root"");; chain.Add(""file2.root"");; chain.Add(""file3.root"");; ```. The name of the **`TChain`** will be the same as the name of the tree;; in this case it will be `""T"". Note that two `objects can have the same; name as long as they are not histograms in the same directory, because; there, the histogram names are used to build a hash table. The class; **`TChain`** is derived from the class **`TTree`**. For example, to; generate a histogram corresponding to the attribute ""`x`"" in tree ""`T`""; by processing sequentially the three files of this chain, we can use the;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:140054,depend,depends,140054,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['depend'],['depends']
Integrability,"none). Overview:; """""""""""""""""". The ``llvm.donothing`` intrinsic doesn't perform any operation. It's one of only; three intrinsics (besides ``llvm.experimental.patchpoint`` and; ``llvm.experimental.gc.statepoint``) that can be called with an invoke; instruction. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". This intrinsic does nothing, and it's removed by optimizers and ignored; by codegen. '``llvm.experimental.deoptimize``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare type @llvm.experimental.deoptimize(...) [ ""deopt""(...) ]. Overview:; """""""""""""""""". This intrinsic, together with :ref:`deoptimization operand bundles; <deopt_opbundles>`, allow frontends to express transfer of control and; frame-local state from the currently executing (typically more specialized,; hence faster) version of a function into another (typically more generic, hence; slower) version. In languages with a fully integrated managed runtime like Java and JavaScript; this intrinsic can be used to implement ""uncommon trap"" or ""side exit"" like; functionality. In unmanaged languages like C and C++, this intrinsic can be; used to represent the slow paths of specialized functions. Arguments:; """""""""""""""""""". The intrinsic takes an arbitrary number of arguments, whose meaning is; decided by the :ref:`lowering strategy<deoptimize_lowering>`. Semantics:; """""""""""""""""""". The ``@llvm.experimental.deoptimize`` intrinsic executes an attached; deoptimization continuation (denoted using a :ref:`deoptimization; operand bundle <deopt_opbundles>`) and returns the value returned by; the deoptimization continuation. Defining the semantic properties of; the continuation itself is out of scope of the language reference --; as far as LLVM is concerned, the deoptimization continuation can; invoke arbitrary side effects, including reading from and writing to; the entire heap. Deoptimization continuations expressed using ``""deopt""`` operand bundles always; continue execution to the end ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:942525,integrat,integrated,942525,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['integrat'],['integrated']
Integrability,"noreCase | BasicRegex"". Matcher<ObjCMessageExpr>numSelectorArgsunsigned N; Matches when the selector has the specified number of arguments. matcher = objCMessageExpr(numSelectorArgs(0));; matches self.bodyView in the code below. matcher = objCMessageExpr(numSelectorArgs(2));; matches the invocation of ""loadHTMLString:baseURL:"" but not that; of self.bodyView; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMethodDecl>isClassMethod; Returns true when the Objective-C method declaration is a class method. Example; matcher = objcMethodDecl(isClassMethod()); matches; @interface I + (void)foo; @end; but not; @interface I - (void)bar; @end. Matcher<ObjCMethodDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<ObjCMethodDecl>isInstanceMethod; Returns true when the Objective-C method declaration is an instance method. Example; matcher = objcMethodDecl(isInstanceMethod()); matches; @interface I - (void)bar; @end; but not; @interface I + (void)foo; @end. Matcher<ParmVarDecl>hasDefaultArgument; Matches a declaration that has default arguments. Example matches y (matcher = parmVarDecl(hasDefaultArgument())); void x(int val) {}; void y(int val = 0) {}. Deprecated. Use hasInitializer() instead to be able to; match on the contents of the default argument. For example:. void x(int val = 7) {}; void y(int val = 42) {}; parmVarDecl(hasInitializer(integerLiteral(equals(42)))); matches the parameter of y. A matcher such as; parmVarDecl(hasInitializer(anything())); is equivalent to parmVarDecl(hasDefaultArgument()). Match",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:109284,interface,interface,109284,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,4,['interface'],['interface']
Integrability,"normal()"",""method=arou"");; //......; // sample distributions N times (generate N random numbers); for (int i = 0; i &lt; N; ++i); double x = unr.Sample();. ~~~. - Using a distribution object. We have then the following cases depending on the dimension and the distribution object. - For 1D distribution the class **TUnuranContDist** must be used.; - A **TUnuranContDist** object can be created from a function; providing the pdf (probability density function) and optionally one providing the derivative of the pdf.; - If the derivative is not provided and the generation method requires it, then it is estimated numerically.; - The user can optionally provide the; - cdf (cumulative distribution function) via the **TUnuranContDist::SetCdf** function,; - the mode via **TUnuranContDist::SetMode**,; - the domain via **TUnuranContDist::SetDomain** for generating numbers in a restricted region,; - the area below the pdf via **TUnuranContDist::SetPdfArea**. Some of this information is required depending on the chosen UNURAN generation method. ~~~~{.cpp}; //1D case: create a distribution from two TF1 object pointers pdfFunc; TUnuranContDist dist( pdfFunc);; //initialize unuran passing the distribution and a string defining the method; unr.Init(dist, ""method=hinv"");; // sample distribution N times (generate N random numbers); for (int i = 0; i &lt; N; ++i); double x = unr.Sample();; ~~~~. - For multi-dimensional distribution the class **TUnuranMultiContDist** must be used.; In this case only the multi-dimensional pdf is required. ~~~~{.cpp}; //Multi-Dim case from a TF1 (or TF2 or TF3) object describing a multi-dimensional function; TUnuranMultiContDist dist( pdfFuncMulti);; // the recommended method for multi-dimensional function is ""hitro""; unr.Init(dist, ""method=hitro"");; // sample distribution N times (generate N random numbers); double x[NDIM];; for (int i = 0; i &lt; N; ++i); unr.SampleMulti(x);; ~~~~. - For discrete distribution the class **TUnuranDiscrDist** must be used.; Th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/unuran/doc/index.md:2160,depend,depending,2160,math/unuran/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/unuran/doc/index.md,1,['depend'],['depending']
Integrability,"not coherent. However, scalar; operations are used in a restricted way so do not impact the memory model. See; :ref:`amdgpu-amdhsa-memory-spaces`.; * The vector and scalar memory L0 caches use an L1 cache shared by all WGPs on; the same SA. Therefore, no special action is required for coherence between; the wavefronts of a single work-group. However, a ``buffer_gl1_inv`` is; required for coherence between wavefronts executing in different work-groups; as they may be executing on different SAs that access different L1s.; * The L1 caches have independent quadrants to service disjoint ranges of virtual; addresses.; * Each L0 cache has a separate request queue per L1 quadrant. Therefore, the; vector and scalar memory operations performed by different wavefronts, whether; executing in the same or different work-groups (which may be executing on; different CUs accessing different L0s), can be reordered relative to each; other. A ``s_waitcnt vmcnt(0) & vscnt(0)`` is required to ensure; synchronization between vector memory operations of different wavefronts. It; ensures a previous vector memory operation has completed before executing a; subsequent vector memory or LDS operation and so can be used to meet the; requirements of acquire, release and sequential consistency.; * The L1 caches use an L2 cache shared by all SAs on the same agent.; * The L2 cache has independent channels to service disjoint ranges of virtual; addresses.; * Each L1 quadrant of a single SA accesses a different L2 channel. Each L1; quadrant has a separate request queue per L2 channel. Therefore, the vector; and scalar memory operations performed by wavefronts executing in different; work-groups (which may be executing on different SAs) of an agent can be; reordered relative to each other. A ``s_waitcnt vmcnt(0) & vscnt(0)`` is; required to ensure synchronization between vector memory operations of; different SAs. It ensures a previous vector memory operation has completed; before executing a subsequent",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:338445,synchroniz,synchronization,338445,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['synchroniz'],['synchronization']
Integrability,"now be performed through the same style of interface as likelihood fits,; through the newly added method RooAbsReal::chi2FitTo(const RooDataHist&,...). Functions that can be fitted with chi-squared minimization are any RooAbsReal based function; as well as RooAbsPdf based p.d.f.s. In case of non-extended p.d.f.s the probability density; calculated by the p.d.f. is multiplied with the number of events in the histogram to adjust; the scale of the function. In case of extended p.d.f.s, the adjustment is made with the expected; number of events, rather than the observed number of events. Tutorial macro rf602_chi2fit.C has been updated to use this new interface. Chi-squared fits to X-Y datasets now possible; In addition to the ability to perform chi-squared fits to histograms it is now also possible; to perform chi-squared fits to unbinned datasets containing a series of X and Y values; with associated errors on Y and optionally on X. These 'X-Y' chi-squared fits are interfaced through newly added method; RooAbsReal::chi2FitTo(const RooDataSet&,...). By default the event weight is; interpreted as the 'Y' value, but an YVar() argument can designate any other; dataset column as Y value. If X errors are defined, one can choose to integrate the fitted; function over the range of the X errors, rather than taking the central value by adding; an Integrate(true) argument to chi2FitTo(); Two new arguments, StoreError(const RooArgSet&) and StoreAsymError(const RooArgSet&); have been added to the RooDataSet constructor to simplify the process of storing the errors; of X and Y variables along with their values in a dataset. The newly added tutorial macro rf609_xychi2fit.C illustrates the use of all this; new functionality. Uniform interface for creation of (profile likelihoods) and chi-squared from p.d.f.s; It is now recommended to use the method RooAbsPdf::createNLL(RooAbsData&,...) to; create a likelihood from a p.d.f and a dataset rather than constructing a RooNLLVar; object dire",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:8464,interface,interfaced,8464,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,2,['interface'],['interfaced']
Integrability,nown. 2252; DR; Enumeration list-initialization from the same type; Unknown. 2253; CD5; Unnamed bit-fields and zero-initialization; Unknown. 2254; CD5; Standard-layout classes and bit-fields; Unknown. 2255; CD5; Instantiated static data member templates; Unknown. 2256; CD5; Lifetime of trivially-destructible objects; Unknown. 2257; CD5; Lifetime extension of references vs exceptions; Unknown. 2258; open; Storage deallocation during period of destruction; Not resolved. 2259; C++17; Unclear context describing ambiguity; Unknown. 2260; CD5; Explicit specializations of deleted member functions; Unknown. 2261; extension; Explicit instantiation of in-class friend definition; Extension. 2262; C++17; Attributes for asm-definition; Unknown. 2263; drafting; Default argument instantiation for friends; Not resolved. 2264; drafting; Memberwise copying with indeterminate value; Not resolved. 2265; drafting; Delayed pack expansion and member redeclarations; Not resolved. 2266; CD5; Has dependent type vs is type-dependent; Unknown. 2267; CD5; Copy-initialization of temporary in reference direct-initialization; No. 2268; C++17; Unions with mutable members in constant expressions revisited; Unknown. 2269; dup; Additional recursive references in aggregate DMIs; Unknown. 2270; NAD; Non-inline functions and explicit instantiation declarations; Unknown. 2271; C++17; Aliasing this; Unknown. 2272; C++17; Implicit initialization of aggregate members of reference type; Unknown. 2273; CD5; Inheriting constructors vs implicit default constructor; Unknown. 2274; NAD; Generic lambda capture vs constexpr if; Unknown. 2275; drafting; Type-dependence of function template; Not resolved. 2276; C++17; Dependent noexcept and function type-dependence; Unknown. 2277; CD5; Ambiguity inheriting constructors with default arguments; Unknown. 2278; CD5; Copy elision in constant expressions reconsidered; Unknown. 2279; NAD; Multiple attribute-specifiers in one attribute-list; Unknown. 2280; C++20; Matching a us,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:154423,depend,dependent,154423,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,4,['depend'],['dependent']
Integrability,"ns &Opts,; SmallVectorImpl<const char *> &Args,; CompilerInvocation::StringAllocator SA /*...*/) {; // ... + for (const std::string &PassPlugin : Opts.PassPlugins); + GenerateArg(Args, OPT_fpass_plugin_EQ, PassPlugin, SA);; }. Finally, you can specify the argument on the command line:; ``clang -fpass-plugin=a -fpass-plugin=b`` and use the new member variable as; desired. .. code-block:: diff. void EmitAssemblyHelper::EmitAssemblyWithNewPassManager(/*...*/) {; // ...; + for (auto &PluginFN : CodeGenOpts.PassPlugins); + if (auto PassPlugin = PassPlugin::Load(PluginFN)); + PassPlugin->registerPassBuilderCallbacks(PB);; }. .. _OptionMarshalling:. Option Marshalling Infrastructure; ---------------------------------. The option marshalling infrastructure automates the parsing of the Clang; ``-cc1`` frontend command line arguments into ``CompilerInvocation`` and their; generation from ``CompilerInvocation``. The system replaces lots of repetitive; C++ code with simple, declarative tablegen annotations and it's being used for; the majority of the ``-cc1`` command line interface. This section provides an; overview of the system. **Note:** The marshalling infrastructure is not intended for driver-only; options. Only options of the ``-cc1`` frontend need to be marshalled to/from; ``CompilerInvocation`` instance. To read and modify contents of ``CompilerInvocation``, the marshalling system; uses key paths, which are declared in two steps. First, a tablegen definition; for the ``CompilerInvocation`` member is created by inheriting from; ``KeyPathAndMacro``:. .. code-block:: text. // Options.td. class LangOpts<string field> : KeyPathAndMacro<""LangOpts->"", field, ""LANG_""> {}; // CompilerInvocation member ^^^^^^^^^^; // OPTION_WITH_MARSHALLING prefix ^^^^^. The first argument to the parent class is the beginning of the key path that; references the ``CompilerInvocation`` member. This argument ends with ``->`` if; the member is a pointer type or with ``.`` if it's a value type. The c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:34391,interface,interface,34391,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['interface'],['interface']
Integrability,"ns `SetObjectFit/GetObjectFit` can be used inside the; `FCN` function to set/get a referenced object instead of using; global variables. - By default `fGraphicsMode` is true. When calling the `Minuit`; functions such as `mncont`, `mnscan`, or any `Minuit` command; invoking `mnplot`, `TMinuit::mnplot()` produces a **`TGraph`**; object pointed by `fPlot`. One can retrieve this object with; **`TMinuit`**`::GetPlot().` For example:. ``` {.cpp}; h->Fit(""gaus"");; gMinuit->Command(""SCAn 1"");; TGraph *gr = (TGraph*)gMinuit->GetPlot();; gr->SetMarkerStyle(21);; gr->Draw(""alp"");; ```. - To set `Minuit` in no graphics mode, call. ``` {.cpp}; gMinuit->SetGraphicsMode(kFALSE);; ```. ### Basic Concepts of Minuit. The `Minuit` package acts on a multi parameter FORTRAN function to; which one must give the generic name `FCN`. In the ROOT; implementation, the function `FCN` is defined via the `Minuit`; `SetFCN` member function when an histogram fitting is invoked. The; value of `FCN` will in general depend on one or more variable; parameters. ### The Transformation of Limited Parameters. For variable parameters with limits, `Minuit` uses the following; transformation:. `Pint = arcsin(2((Pext-a)/(b-a))-1) `. `Pext = a+((b-a)/(2))(sinPint+1)`. so that the internal value `Pint` can take on any value, while the; external value Pext can take on values only between the lower limit a; and the ext upper limit b. Since the transformation is necessarily; non-linear, it would transform a nice linear problem into a nasty; non-linear one, which is the reason why limits should be avoided if; not necessary. In addition, the transformation does require some; computer time, so it slows down the computation a little bit, and more; importantly, it introduces additional numerical inaccuracy into the; problem in addition to what is introduced in the numerical calculation; of the FCN value. The effects of non-linearity and numerical round off; both become more important as the external value gets closer t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:55342,depend,depend,55342,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['depend'],['depend']
Integrability,"ns can be added or subtracted. ~~~{.cpp}; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);; ~~~. - Rotations (TGeoRotation class) represent a pure rotation. Data; members are `Double_t fRotationMatrix[3*3]`. Rotations can be; defined either by Euler angles, either, by GEANT3 angles:. ~~~{.cpp}; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi,theta,psi); // all angles in degrees; ~~~. This represents the composition of: first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with `psi` about the new Z axis. ~~~{.cpp}; r1->SetAngles(th1,phi1,th2,phi2,th3,phi3); ~~~. This is a rotation defined in GEANT3 style. Theta and phi are the; spherical angles of each axis of the rotated coordinate system with; respect to the initial one. This construction allows definition of; malformed rotations, e.g. not orthogonal. A check is performed and an; error message is issued in this case. Specific utilities: determinant, inverse. - Scale transformations (TGeoScale class) - represent a scaled; shrinking/enlargement, possibly different on all axes. Data members:; `Double_t fScale[3]`. Not implemented yet.; - Combined transformations - represent a rotation followed by a; translation. Data members:; `Double_t fTranslation[3]`, `TGeoRotation *fRotation`. ~~~{.cpp}; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;; ...; TGeoCombiTrans *c1 = new TGeoCombiTrans(trans,rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot); ~~~. - General transformations: (TGeoHMatrix class) represent; combined transformations in any order.; - Identity transformation: (TGeoIdentity class) is a generic; identity transformation represented by a singleton class object; `gGeoIdentity`. \anchor GP01d; ### Ownership of Geometry Objects. The class TGeoManager class contains the entire API needed for; building and tracking ge",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:58806,message,message,58806,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['message'],['message']
Integrability,"ns inside signal; handlers, as this is prone to deadlock. Tainted values used in conditional; expressions inside signal handlers will instead be aggregated via bitwise; or, and can be accessed using; ``dfsan_label dfsan_get_labels_in_signal_conditional();``. * ``-dfsan-track-origins`` -- Controls how to track origins. When its value is; 0, the runtime does not track origins. When its value is 1, the runtime tracks; origins at memory store operations. When its value is 2, the runtime tracks; origins at memory load and store operations. Its default value is 0. * ``-dfsan-instrument-with-call-threshold`` -- If a function being instrumented; requires more than this number of origin stores, use callbacks instead of; inline checks (-1 means never use callbacks). Its default value is 3500. Environment Variables; ---------------------. * ``warn_unimplemented`` -- Whether to warn on unimplemented functions. Its; default value is false.; * ``strict_data_dependencies`` -- Whether to propagate labels only when there is; explicit obvious data dependency (e.g., when comparing strings, ignore the fact; that the output of the comparison might be implicit data-dependent on the; content of the strings). This applies only to functions with ``custom`` category; in ABI list. Its default value is true.; * ``origin_history_size`` -- The limit of origin chain length. Non-positive values; mean unlimited. Its default value is 16.; * ``origin_history_per_stack_limit`` -- The limit of origin node's references count.; Non-positive values mean unlimited. Its default value is 20000.; * ``store_context_size`` -- The depth limit of origin tracking stack traces. Its; default value is 20.; * ``zero_in_malloc`` -- Whether to zero shadow space of new allocated memory. Its; default value is true.; * ``zero_in_free`` --- Whether to zero shadow space of deallocated memory. Its; default value is true. Example; =======. DataFlowSanitizer supports up to 8 labels, to achieve low CPU and code; size overhead. B",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:9798,depend,dependency,9798,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,1,['depend'],['dependency']
Integrability,"ns of concepts explained in the forthcoming edition on RooFit Users Manual.; All macros are extensively documented and each is fully functional standalone. The accompanying update; of the Manual is expected mid-September. ; ; BASIC FUNCTIONALITY. rf101_basics.C - Fitting, plotting, toy data generation on one-dimensional p.d.f ; rf102_dataimport.C - Importing data from ROOT TTrees and THx histograms; rf103_interprfuncs.C - Interpreted functions and p.d.f.s; rf104_classfactory.C - The class factory for functions and p.d.f.s; rf105_funcbinding.C - Demonstration of binding ROOT Math functions as RooFit functions and pdfs; rf106_plotdecoration.C - Adding boxes with parameters, statistics to RooPlots.; rf107_plotstyles.C - Demonstration of various plotting styles of data, functions; rf108_plotbinning.C - Plotting unbinned data with alternate and variable binnings; rf109_chi2residpull.C - Calculating chi^2 from histograms and curves in RooPlots,; rf110_normintegration.C - Examples on normalization & integration of p.d.f.s, construction of cumulative distribution functions.; rf111_numintconfig.C - Configuration and customization of how numeric (partial) integrals. ; ADDITION AND CONVOLUTION. rf201_composite.C - Composite p.d.f with signal and background component; rf202_extendedmlfit.C - Setting up an extended maximum likelihood fit; rf203_ranges.C - Fitting and plotting in sub ranges; rf204_extrangefit.C - Extended maximum likelihood fit with alternate range definition; rf205_compplot.C - Options for plotting components of composite p.d.f.s.; rf206_treevistools.C - Tools for visualization of RooAbsArg expression trees; rf207_comptools.C - Tools and utilities for manipulation of composite objects; rf208_convolution.C - One-dimensional numeric convolution; rf209_anaconv.C - Decay function p.d.fs with optional B physics. ; MULTIDIMENSIONAL MODELS. rf301_composition.C - Multi-dimensional p.d.f.s through composition, e.g. substituting a p.d.f parameter with a function that depen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html:1224,integrat,integration,1224,roofit/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html,2,['integrat'],['integration']
Integrability,"ns that both have the; ``llvm.access.group`` metadata to the access group ``g1``, respectively; ``g2`` (which might be identical). If a loop contains both access groups; in its ``llvm.loop.parallel_accesses`` metadata, then the compiler can; assume that there is no dependency between ``m1`` and ``m2`` carried by; this loop. Instructions that belong to multiple access groups are; considered having this property if at least one of the access groups; matches the ``llvm.loop.parallel_accesses`` list. If all memory-accessing instructions in a loop have; ``llvm.access.group`` metadata that each refer to one of the access; groups of a loop's ``llvm.loop.parallel_accesses`` metadata, then the; loop has no loop carried memory dependences and is considered to be a; parallel loop. Note that if not all memory access instructions belong to an access; group referred to by ``llvm.loop.parallel_accesses``, then the loop must; not be considered trivially parallel. Additional; memory dependence analysis is required to make that determination. As a fail; safe mechanism, this causes loops that were originally parallel to be considered; sequential (if optimization passes that are unaware of the parallel semantics; insert new memory instructions into the loop body). Example of a loop that is considered parallel due to its correct use of; both ``llvm.access.group`` and ``llvm.loop.parallel_accesses``; metadata types. .. code-block:: llvm. for.body:; ...; %val0 = load i32, ptr %arrayidx, !llvm.access.group !1; ...; store i32 %val0, ptr %arrayidx1, !llvm.access.group !1; ...; br i1 %exitcond, label %for.end, label %for.body, !llvm.loop !0. for.end:; ...; !0 = distinct !{!0, !{!""llvm.loop.parallel_accesses"", !1}}; !1 = distinct !{}. It is also possible to have nested parallel loops:. .. code-block:: llvm. outer.for.body:; ...; %val1 = load i32, ptr %arrayidx3, !llvm.access.group !4; ...; br label %inner.for.body. inner.for.body:; ...; %val0 = load i32, ptr %arrayidx1, !llvm.access.group !3; .",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:312711,depend,dependence,312711,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['dependence']
Integrability,"ns to run. In LLVM, execution resumes at a ``landingpad``; instruction, which produces register values provided by the runtime. If a; function is only cleaning up allocated resources, the function is responsible; for calling ``_Unwind_Resume`` to transition to the next most recently active; frame after it is finished cleaning up. Eventually, the frame responsible for; handling the exception calls ``__cxa_end_catch`` to destroy the exception,; release its memory, and resume normal control flow. The Windows EH model does not use these successive register context resets.; Instead, the active exception is typically described by a frame on the stack.; In the case of C++ exceptions, the exception object is allocated in stack memory; and its address is passed to ``__CxxThrowException``. General purpose structured; exceptions (SEH) are more analogous to Linux signals, and they are dispatched by; userspace DLLs provided with Windows. Each frame on the stack has an assigned EH; personality routine, which decides what actions to take to handle the exception.; There are a few major personalities for C and C++ code: the C++ personality; (``__CxxFrameHandler3``) and the SEH personalities (``_except_handler3``,; ``_except_handler4``, and ``__C_specific_handler``). All of them implement; cleanups by calling back into a ""funclet"" contained in the parent function. Funclets, in this context, are regions of the parent function that can be called; as though they were a function pointer with a very special calling convention.; The frame pointer of the parent frame is passed into the funclet either using; the standard EBP register or as the first parameter register, depending on the; architecture. The funclet implements the EH action by accessing local variables; in memory through the frame pointer, and returning some appropriate value,; continuing the EH process. No variables live in to or out of the funclet can be; allocated in registers. The C++ personality also uses funclets to contain",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst:21673,rout,routine,21673,interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,1,['rout'],['routine']
Integrability,"ns:range:locale:; - componentsSeparatedByCharactersInSet:; - initWithFormat:. NSComparisonResult test(NSString *s) {; NSString *aString = nil;; return [s caseInsensitiveCompare:aString];; // warn: argument to 'NSString' method; // 'caseInsensitiveCompare:' cannot be nil; }. osx.cocoa.ObjCGenerics; (ObjC); Check for type errors when using Objective-C generics. NSMutableArray *names = [NSMutableArray array];; NSMutableArray *birthDates = names;. // Warning: Conversion from value of type 'NSDate *'; // to incompatible type 'NSString *'; [birthDates addObject: [NSDate date]];. osx.cocoa.RetainCount; (ObjC); Check for leaks and violations of the Cocoa Memory Management rules. void test() {; NSString *s = [[NSString alloc] init]; // warn; }. CFStringRef test(char *bytes) {; return CFStringCreateWithCStringNoCopy(; 0, bytes, NSNEXTSTEPStringEncoding, 0); // warn; }. osx.cocoa.SelfInit; (ObjC); Check that self is properly initialized inside an initializer; method. @interface MyObj : NSObject {; id x;; }; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; x = 0; // warn: instance variable used while 'self' is not; // initialized; return 0;; }; @end. @interface MyObj : NSObject; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; return self; // warn: returning uninitialized 'self'; }; @end. osx.cocoa.SuperDealloc; (ObjC); Warn about improper use of '[super dealloc]' in Objective-C. @interface SuperDeallocThenReleaseIvarClass : NSObject {; NSObject *_ivar;; }; @end. @implementation SuperDeallocThenReleaseIvarClass; - (void)dealloc {; [super dealloc];; [_ivar release]; // warn; }; @end. osx.cocoa.UnusedIvars; (ObjC); Warn about private ivars that are never used. @interface MyObj : NSObject {; @private; id x; // warn; }; @end. @implementation MyObj; @end. osx.cocoa.VariadicMethodTypes; (ObjC); Check for passing non-Objective-C types to variadic collection initialization; methods that expect only Objective-C types. void test() {; [NSSet set",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:18628,interface,interface,18628,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,2,['interface'],['interface']
Integrability,"nsition path for developers compiling LLVM, because the; error can be turned into a warning using a CMake flag. This is an important; step: LLVM still doesn't have code which requires the new toolchains, but it; soon will. If you compile LLVM but don't read the forums, we should; tell you!. * Ensure that at least one LLVM release has had this soft-error. Not all; developers compile LLVM top-of-tree. These release-bound developers should; also be told about upcoming changes. * Turn the soft-error into a hard-error after said LLVM release has branched. * Update the :doc:`coding standards<CodingStandards>` to allow the new; features we've explicitly approved in the RFC. * Start using the new features in LLVM's codebase. Here's a `sample RFC; <https://discourse.llvm.org/t/rfc-migrating-past-c-11/50943>`_ and the; `corresponding change <https://reviews.llvm.org/D57264>`_. .. _ci-usage:. Working with the CI system; --------------------------. The main continuous integration (CI) tool for the LLVM project is the; `LLVM Buildbot <https://lab.llvm.org/buildbot/>`_. It uses different *builders*; to cover a wide variety of sub-projects and configurations. The builds are; executed on different *workers*. Builders and workers are configured and; provided by community members. The Buildbot tracks the commits on the main branch and the release branches.; This means that patches are built and tested after they are merged to the these; branches (aka post-merge testing). This also means it's okay to break the build; occasionally, as it's unreasonable to expect contributors to build and test; their patch with every possible configuration. *If your commit broke the build:*. * Fix the build as soon as possible as this might block other contributors or; downstream users.; * If you need more time to analyze and fix the bug, please revert your change to; unblock others. *If someone else broke the build and this blocks your work*. * Comment on the code review in `GitHub <https://github.com/",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:35897,integrat,integration,35897,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['integrat'],['integration']
Integrability,"nsity:. ``` {.cpp}; TGeoMixture(const char *name,Int_t nel,Double_t rho);; ```. Elements have to be further defined one by one:. ``` {.cpp}; void TGeoMixture::DefineElement(Int_t iel,Double_t a,Double_t z,; Double_t weigth);; void TGeoMixture::DefineElement(Int_t iel, TGeoElement *elem,; Double_t weight);; void TGeoMixture::DefineElement(Int_t iel, Int_t z, Int_t natoms);; ```. or:. ``` {.cpp}; void AddElement(TGeoMaterial* mat, Double_t weight);; void AddElement(TGeoElement* elem, Double_t weight);; void AddElement(TGeoElement* elem, Int_t natoms);; void AddElement(Double_t a, Double_t z, Double_t weight); ```. - `iel:` index of the element` [0,nel-1]`; - `a` and `z:` the atomic mass and charge; - `weight:` proportion by mass of the elements; - `natoms`: number of atoms of the element in the molecule making the; mixture. The radiation length is automatically computed when all elements are; defined. Since tracking MC provide several other ways to create; materials/mixtures, the materials classes are likely to evolve as the; interfaces to these engines are being developed. Generally in the; process of tracking material properties are not enough and more specific; media properties have to be defined. These highly depend on the MC; performing tracking and sometimes allow the definition of different; media properties (e.g. energy or range cuts) for the same material. ### Radionuclides. A new class **`TGeoElementRN`** was introduced in this version to; provide support for radioactive nuclides and their decays. A database of; 3162 radionuclides can be loaded on demand via the table of elements; (**`TGeoElementTable`** class). One can make then materials/mixtures; based on these radionuclides and use them in a geometry. ``` {.cpp}; root[] TGeoManager *geom = new TGeoManager(""geom"",""radionuclides"");; root[] TGeoElementTable *table = geom->GetElementTable();; root[] TGeoElementRN *c14 = table->GetElementRN(14,6); // A,Z; root[] c14->Print();; 6-C-014 ENDF=60140; A=14; Z=6; I",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:17131,interface,interfaces,17131,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['interface'],['interfaces']
Integrability,"nst ArchiveIterator &LHS,; const ArchiveIterator &RHS);. // operator++/operator-- replaced with fallible increment / decrement:; Error inc() {; if (!A.childValid(ChildIdx + 1)); return make_error<BadArchiveMember>(...);; ++ChildIdx;; return Error::success();; }. Error dec() { ... }; };. Instances of this kind of fallible iterator interface are then wrapped with the; fallible_iterator utility which provides ``operator++`` and ``operator--``,; returning any errors via a reference passed in to the wrapper at construction; time. The fallible_iterator wrapper takes care of (a) jumping to the end of the; range on error, and (b) marking the error as checked whenever an iterator is; compared to ``end`` and found to be inequal (in particular: this marks the; error as checked throughout the body of a range-based for loop), enabling early; exit from the loop without redundant error checking. Instances of the fallible iterator interface (e.g. FallibleChildIterator above); are wrapped using the ``make_fallible_itr`` and ``make_fallible_end``; functions. E.g.:. .. code-block:: c++. class Archive {; public:; using child_iterator = fallible_iterator<FallibleChildIterator>;. child_iterator child_begin(Error &Err) {; return make_fallible_itr(FallibleChildIterator(*this, 0), Err);; }. child_iterator child_end() {; return make_fallible_end(FallibleChildIterator(*this, size()));; }. iterator_range<child_iterator> children(Error &Err) {; return make_range(child_begin(Err), child_end());; }; };. Using the fallible_iterator utility allows for both natural construction of; fallible iterators (using failing ``inc`` and ``dec`` operations) and; relatively natural use of c++ iterator/loop idioms. .. _function_apis:. More information on Error and its related utilities can be found in the; Error.h header file. Passing functions and other callable objects; --------------------------------------------. Sometimes you may want a function to be passed a callback object. In order to; support lambda ex",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:38972,wrap,wrapped,38972,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['wrap'],['wrapped']
Integrability,"nstance. tree->Branch(""px"", &Category, ""px/F"");. becomes. auto px = model->MakeField<float>(""px"");; // px is std::shared_ptr<float>. The physical layout changes slightly from big endian to little endian so that it matches the in-memory layout on; most modern architectures. Combined with a clear separation of offset/index data and payload data for collections,; uncompressed RNTuple data can be directly mapped to memory without further copies. Goals; -----. RNTuple shall investigate improvements of the TTree I/O in the following ways. 1. More speed; * Improve mapping to vectorized and parallel hardware; * For types known at compile / JIT time: generate optimized code; * Optimized for simple types (float, int, and vectors of them); * Better memory control: work with a fixed budget of pre-defined I/O buffers; * Naturally thread-safe and asynchronous interfaces. 2. More robust interfaces; * Compile-time type safety by default; * Decomposition into layers: logical layer, primitives layer, storage layer; * Separation of data model and live data; * Self-contained I/O code to support creation of a standalone I/O library. Concepts; --------. At the **logical layer**, the user defines a data model using the RNTupleModel class.; The data model is a collection of serializable C++ types with associated names, similar to branches in a TTree.; The data model can contain (nested) collections, e.g., a type can be `std::vector<std::vector<float>>`. Each serializable type is represented by a **field**, concretely by a templated version of RField,; e.g. `RField<double>`. A field can generate or adopt an associated **value**, which represents a memory location; storing a value of the given C++ type. These distinguished memory locations are the destinations and sources for the; deserialization and serialization. The (de-)serialization is a mapping from the C++ type to the more simple **column** type system. A column contains; an arbitrary number of fixed-sized elements of a well-defined se",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/README.md:1246,interface,interfaces,1246,tree/ntuple/v7/doc/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/README.md,1,['interface'],['interfaces']
Integrability,"nstances if they happen to import; to the very same ""to"" context. This is why we can use the importer specific; lookup only via the ``ASTImporterSharedState`` class. ExternalASTSource; ~~~~~~~~~~~~~~~~~. The ``ExternalASTSource`` is an abstract interface associated with the; ``ASTContext`` class. It provides the ability to read the declarations stored; within a declaration context either for iteration or for name lookup. A; declaration context with an external AST source may load its declarations; on-demand. This means that the list of declarations (represented as a linked; list, the head is ``DeclContext::FirstDecl``) could be empty. However, member; functions like ``DeclContext::lookup()`` may initiate a load. Usually, external sources are associated with precompiled headers. For example,; when we load a class from a PCH then the members are loaded only if we do want; to look up something in the class' context. In case of LLDB, an implementation of the ``ExternalASTSource`` interface is; attached to the AST context which is related to the parsed expression. This; implementation of the ``ExternalASTSource`` interface is realized with the help; of the ``ASTImporter`` class. This way, LLDB can reuse Clang's parsing; machinery while synthesizing the underlying AST from the debug data (e.g. from; DWARF). From the view of the ``ASTImporter`` this means both the ""to"" and the; ""from"" context may have declaration contexts with external lexical storage. If; a ``DeclContext`` in the ""to"" AST context has external lexical storage then we; must take extra attention to work only with the already loaded declarations!; Otherwise, we would end up with an uncontrolled import process. For instance,; if we used the regular ``DeclContext::lookup()`` to find the existing; declarations in the ""to"" context then the ``lookup()`` call itself would; initiate a new import while we are in the middle of importing a declaration!; (By the time we initiate the lookup we haven't registered yet that ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:107200,interface,interface,107200,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['interface'],['interface']
Integrability,"nstant`` location or in the constant; pool, referred to by ``ConstantIndex`` locations. At each callsite, a ""liveout"" register list is also recorded. These; are the registers that are live across the stackmap and therefore must; be saved by the runtime. This is an important optimization when the; patchpoint intrinsic is used with a calling convention that by default; preserves most registers as callee-save. Each entry in the liveout register list contains a DWARF register; number and size in bytes. The stackmap format deliberately omits; specific subregister information. Instead the runtime must interpret; this information conservatively. For example, if the stackmap reports; one byte at ``%rax``, then the value may be in either ``%al`` or; ``%ah``. It doesn't matter in practice, because the runtime will; simply save ``%rax``. However, if the stackmap reports 16 bytes at; ``%ymm0``, then the runtime can safely optimize by saving only; ``%xmm0``. The stack map format is a contract between an LLVM SVN revision and; the runtime. It is currently experimental and may change in the short; term, but minimizing the need to update the runtime is; important. Consequently, the stack map design is motivated by; simplicity and extensibility. Compactness of the representation is; secondary because the runtime is expected to parse the data; immediately after compiling a module and encode the information in its; own format. Since the runtime controls the allocation of sections, it; can reuse the same stack map space for multiple modules. Stackmap support is currently only implemented for 64-bit; platforms. However, a 32-bit implementation should be able to use the; same format with an insignificant amount of wasted space. .. _stackmap-section:. Stack Map Section; ^^^^^^^^^^^^^^^^^. A JIT compiler can easily access this section by providing its own; memory manager via the LLVM C API; ``LLVMCreateSimpleMCJITMemoryManager()``. When creating the memory; manager, the JIT provides a call",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst:15360,contract,contract,15360,interpreter/llvm-project/llvm/docs/StackMaps.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst,1,['contract'],['contract']
Integrability,"nstructions. '``llvm.loop.decrement.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. ::. declare i1 @llvm.loop.decrement.i32(i32); declare i1 @llvm.loop.decrement.i64(i64). Overview:; """""""""""""""""". The HardwareLoops pass allows the loop decrement value to be specified with an; option. It defaults to a loop decrement value of 1, but it can be an unsigned; integer value provided by this option. The '``llvm.loop.decrement.*``'; intrinsics decrement the loop iteration counter with this value, and return a; false predicate if the loop should exit, and true otherwise.; This is emitted if the loop counter is not updated via a ``PHI`` node, which; can also be controlled with an option. Arguments:; """""""""""""""""""". The integer argument is the loop decrement value used to decrement the loop; iteration counter. Semantics:; """""""""""""""""""". The '``llvm.loop.decrement.*``' intrinsics do a ``SUB`` of the loop iteration; counter with the given loop decrement value, and return false if the loop; should exit, this ``SUB`` is not allowed to wrap. The result is a condition; that is used by the conditional branch controlling the loop. Vector Reduction Intrinsics; ---------------------------. Horizontal reductions of vectors can be expressed using the following; intrinsics. Each one takes a vector operand as an input and applies its; respective operation across all elements of the vector, returning a single; scalar result of the same element type. .. _int_vector_reduce_add:. '``llvm.vector.reduce.add.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %a); declare i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %a). Overview:; """""""""""""""""". The '``llvm.vector.reduce.add.*``' intrinsics do an integer ``ADD``; reduction of a vector, returning the result as a scalar. The return type matches; the element-type of the vector input. Arguments:; """"""""""""""""""""; The argument to this i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:649945,wrap,wrap,649945,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['wrap'],['wrap']
Integrability,"nstructor and copy assignment operator. This change came; fairly late in the C++11 standardization process, so early; implementations of C++11 (including Clang before 3.0, GCC before 4.7,; and Visual Studio 2010) do not implement this rule, leading them to; accept this ill-formed code:. struct X {; X(X&&); // deletes implicit copy constructor:; // X(const X&) = delete;; };. void f(X x);; void g(X x) {; f(x); // error: X has a deleted copy constructor; }. This affects some early C++11 code, including Boost's popular shared_ptr; up to version 1.47.0. The fix for Boost's shared_ptr is; available here. Objective-C++ compatibility. Implicit downcasts. Due to a bug in its implementation, GCC allows implicit downcasts; of Objective-C pointers (from a base class to a derived class) when; calling functions. Such code is inherently unsafe, since the object; might not actually be an instance of the derived class, and is; rejected by Clang. For example, given this code:. @interface Base @end; @interface Derived : Base @end. void f(Derived *p);; void g(Base *p) {; f(p);; }. Clang produces the following error:. downcast.mm:6:3: error: no matching function for call to 'f'; f(p);; ^; downcast.mm:4:6: note: candidate function not viable: cannot convert from; superclass 'Base *' to subclass 'Derived *' for 1st argument; void f(Derived *p);; ^. If the downcast is actually correct (e.g., because the code has; already checked that the object has the appropriate type), add an; explicit cast:. f((Derived *)base);. Using class as a property name. In C and Objective-C, class is a normal identifier and; can be used to name fields, ivars, methods, and so on. In; C++, class is a keyword. For compatibility with existing; code, Clang permits class to be used as part of a method; selector in Objective-C++, but this does not extend to any other part; of the language. In particular, it is impossible to use property dot; syntax in Objective-C++ with the property name class, so; the following code wi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:22262,interface,interface,22262,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,4,['interface'],['interface']
Integrability,nstructors; Clang 3.0. 544; NAD; Base class lookup in explicit specialization; Yes. 545; open; User-defined conversions and built-in operator overload resolution; Not resolved. 546; C++11; Explicit instantiation of class template members; Yes. 547; C++11; Partial specialization on member function types; Clang 3.2. 548; dup; qualified-ids in declarations; Duplicate of 482. 549; drafting; Non-deducible parameters in partial specializations; Not resolved. 550; dup; Pointer to array of unknown bound in parameter declarations; Unknown. 551; CD1; When is inline permitted in an explicit instantiation?; Yes (C++11 onwards). 552; NAD; Use of typename in the type in a non-type parameter-declaration; Yes. 553; NAD; Problems with friend allocation and deallocation functions; Unknown. 554; CD6; Definition of “declarative region” and “scope”; N/A. 555; CD5; Pseudo-destructor name lookup; Unknown. 556; CD2; Conflicting requirements for acceptable aliasing; N/A. 557; CD1; Does argument-dependent lookup cause template instantiation?; Clang 3.1. 558; CD1; Excluded characters in universal character names; Clang 2.9. 559; CD1; Editing error in issue 382 resolution; Yes. 560; NAD; Use of the typename keyword in return types; Unknown. 561; CD2; Internal linkage functions in dependent name lookup; Yes. 562; CD6; qualified-ids in non-expression contexts; N/A. 563; CD6; Linkage specification for objects; Unknown. 564; CD2; Agreement of language linkage or linkage-specifications?; Yes. 565; CD3; Conflict rules for using-declarations naming function templates; Yes. 566; NAD; Conversion of negative floating point values to integer type; Yes. 567; NAD; Can size_t and ptrdiff_t be larger than long?; N/A. 568; CD1; Definition of POD is too strict; Clang 3.0 (C++11 onwards). 569; CD2; Spurious semicolons at namespace scope should be allowed; Yes (C++11 onwards). 570; CD2; Are references subject to the ODR?; Duplicate of 633. 571; CD2; References declared const; Unknown. 572; C++11; Standard convers,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:38192,depend,dependent,38192,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['depend'],['dependent']
Integrability,"nt and could use more; dedicated effort to complete the implementation.; Self-testing using clang: There are several neat ways to; improve the quality of clang by self-testing. Some examples:. Improve the reliability of AST printing and serialization by; ensuring that the AST produced by clang on an input doesn't change; when it is reparsed or unserialized. Improve parser reliability and error generation by automatically; or randomly changing the input checking that clang doesn't crash and; that it doesn't generate excessive errors for small input; changes. Manipulating the input at both the text and token levels is; likely to produce interesting test cases. Continue work on C++20, C++23, C++2c, and C23 support:; There are still several C++20 features to complete, and work has begun on; supporting the latest language standards. Please see the; C++ status report page to find out what is; missing.; StringRef'ize APIs: A thankless but incredibly useful project is; StringRef'izing (converting to use llvm::StringRef instead of const; char * or std::string) various clang interfaces. This generally; simplifies the code and makes it more efficient.; Configuration Manager: Clang/LLVM works on a large number of; architectures and operating systems and can cross-compile to a similarly large; number of configurations, but the pitfalls of choosing the command-line; options, making sure the right sub-architecture is chosen and that the correct; optional elements of your particular system can be a pain. A tool that would investigate hosts and targets, and store the configuration; in files that can later be used by Clang itself to avoid command-line options,; especially the ones regarding which target options to use, would greatly alleviate; this problem. A simple tool, with little or no dependency on LLVM itself, that; will investigate a target architecture by probing hardware, software, libraries; and compiling and executing code to identify all properties that would be relevant; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:5260,interface,interfaces,5260,interpreter/llvm-project/clang/www/OpenProjects.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html,2,['interface'],['interfaces']
Integrability,"nt changes, any other minor; changes. Avoid committing formatting- or whitespace-only changes outside of; code you plan to make subsequent changes to. Also, try to separate; formatting or whitespace changes from functional changes, either by; correcting the format first (ideally) or afterward. Such changes should be; highly localized and the commit message should clearly state that the commit; is not intended to change functionality, usually by stating it is; :ref:`NFC <nfc>`. #. You are allowed to commit patches without approval to those portions of LLVM; that you have contributed or maintain (i.e., have been assigned; responsibility for), with the proviso that such commits must not break the; build. This is a ""trust but verify"" policy, and commits of this nature are; reviewed after they are committed. #. Multiple violations of these policies or a single egregious violation may; cause commit access to be revoked. In any case, your changes are still subject to `code review`_ (either before or; after they are committed, depending on the nature of the change). You are; encouraged to review other peoples' patches as well, but you aren't required; to do so. .. _discuss the change/gather consensus:. Making a Major Change; ---------------------. When a developer begins a major new project with the aim of contributing it back; to LLVM, they should inform the community with a post to the `LLVM Discourse forums`_, to the extent; possible. The reason for this is to:. #. keep the community informed about future changes to LLVM,. #. avoid duplication of effort by preventing multiple parties working on the; same thing and not knowing about it, and. #. ensure that any technical issues around the proposed work are discussed and; resolved before any significant work is done. The design of LLVM is carefully controlled to ensure that all the pieces fit; together well and are as consistent as possible. If you plan to make a major; change to the way LLVM works or want to add a major new",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:25717,depend,depending,25717,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['depend'],['depending']
Integrability,"nt deduction; Unknown. 272; CD1; Explicit destructor invocation and qualified-ids; Yes. 273; CD1; POD classes and operator&(); Yes. 274; CD1; Cv-qualification and char-alias access to out-of-lifetime objects; N/A. 275; CD1; Explicit instantiation/specialization and using-directives; No. 276; CD1; Order of destruction of parameters and temporaries; N/A. 277; CD1; Zero-initialization of pointers; Clang 3.1. 278; NAD; External linkage and nameless entities; Unknown. 279; CD6; Correspondence of ""names for linkage purposes""; Unknown. 280; CD1; Access and surrogate call functions; Clang 2.9. 281; CD1; inline specifier in friend declarations; No. 282; open; Namespace for extended_type_info; Not resolved. 283; CD1; Template type-parameters are not syntactically type-names; Yes. 284; CD1; qualified-ids in class declarations; No. 285; NAD; Identifying a function template being specialized; Yes. 286; CD1; Incorrect example in partial specialization; Clang 2.8. 287; drafting; Order dependencies in template instantiation; Not resolved. 288; CD1; Misuse of ""static type"" in describing pointers; N/A. 289; CD1; Incomplete list of contexts requiring a complete type; Yes. 290; NAD; Should memcpy be allowed into a POD with a const member?; N/A. 291; CD1; Overload resolution needed when binding reference to class rvalue; Duplicate of 391. 292; CD3; Deallocation on exception in new before arguments evaluated; Unknown. 293; open; Syntax of explicit instantiation/specialization too permissive; Not resolved. 294; NAD; Can static_cast drop exception specifications?; No. 295; CD1; cv-qualifiers on function types; Clang 3.7. 296; CD1; Can conversion functions be static?; Yes. 297; NAD; Which template does an explicit specialization specialize?; Unknown. 298; CD1; T::x when T is cv-qualified; Clang 3.1. 299; CD1; Conversion on array bound expression in new; Clang 2.8 (C++11 onwards). 300; CD1; References to functions in template argument deduction; Yes. 301; CD1; Syntax for template-name; Clang ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:18892,depend,dependencies,18892,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['depend'],['dependencies']
Integrability,"nt for the array. Now this is not possible anymore and one must pass the same type. This is now consistent with other similar TMath functions. Now in the CINT dictionary contains also the instantiations for both cases of Long64_t and Int_t for the size (and index array) types.; . Fixed a bug in the ROOT::Math::landau_pdf function. Now it evaluates to the correct normalized distribution when the scale factor is different than 1.; TVirtualFitter: move TVirtualFitter from base to mathcore. Setting the minimizer parameters is done via the new class ROOT::Math::MinimizerOptions. Fixed also a bug in the TVirtualFitter destructor, which was preventing the deletion of the static instance and causing in same cases memory leaks.; ROOT::Math::MinimizerOptions: new class keeping the minimizer control parameters, minimizer name and algorithms. Static values of the parameter exist and can be set and retrieved via corresponding static methods.; Fitting Classes: improve in general all classes in view of using them in the histogram and graph fitting routines. Few bugs have been as well fixed (see the cvs log for details). The fitter class, ROOT::Fit::Fitter is used now to implement the fit functionality of the Hist library (i.e. TH1::Fit, TGraph::Fit/; ; The Fitter class has been changed to retain a pointer to the Minimizer and Objective function of the last fit. The objective function depends on a reference to the data and the model function, therefore the objective function pointer is valid as far the data and the model function are maintained alive.; ; The library provides the implementation of standard objective function like the Chi2 function, the Poisson likelihood function (for binned likelihood fits) and the loh likelihood function (for unbinned fits). These standard objective functions can be created with or without gradient functionality. In the first case the minimization will be performed using the gradient provided by the function. These functions can also be used in sp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v522/index.html:1589,rout,routines,1589,math/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v522/index.html,2,['rout'],['routines']
Integrability,"nt functionality, existing interfaces to the system; found in ``include/llvm/Support`` should be used. If an appropriate interface is; not available, it should be added to ``include/llvm/Support`` and implemented in; ``lib/Support`` for all supported platforms. Don't Expose System Headers; ---------------------------. The Support Library must shield LLVM from **all** system headers. To obtain; system level functionality, LLVM source must; ``#include ""llvm/Support/Thing.h""`` and nothing else. This means that; ``Thing.h`` cannot expose any system header files. This protects LLVM from; accidentally using system specific functionality and only allows it via; the ``lib/Support`` interface. Use Standard C Headers; ----------------------. The **standard** C headers (the ones beginning with ""c"") are allowed to be; exposed through the ``lib/Support`` interface. These headers and the things they; declare are considered to be platform agnostic. LLVM source files may include; them directly or obtain their inclusion through ``lib/Support`` interfaces. Use Standard C++ Headers; ------------------------. The **standard** C++ headers from the standard C++ library and standard; template library may be exposed through the ``lib/Support`` interface. These; headers and the things they declare are considered to be platform agnostic.; LLVM source files may include them or obtain their inclusion through; ``lib/Support`` interfaces. High Level Interface; --------------------. The entry points specified in the interface of ``lib/Support`` must be aimed at; completing some reasonably high level task needed by LLVM. We do not want to; simply wrap each operating system call. It would be preferable to wrap several; operating system calls that are always used in conjunction with one another by; LLVM. For example, consider what is needed to execute a program, wait for it to; complete, and return its result code. On Unix, this involves the following; operating system calls: ``getenv``, ``fork``, ``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:3506,interface,interfaces,3506,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['interface'],['interfaces']
Integrability,"nt mnemonics. This; phase is a simple and unconditionally remapping from one input mnemonic to one; output mnemonic. It isn't possible for this form of alias to look at the; operands at all, so the remapping must apply for all forms of a given mnemonic.; Mnemonic aliases are defined simply, for example X86 has:. ::. def : MnemonicAlias<""cbw"", ""cbtw"">;; def : MnemonicAlias<""smovq"", ""movsq"">;; def : MnemonicAlias<""fldcww"", ""fldcw"">;; def : MnemonicAlias<""fucompi"", ""fucomip"">;; def : MnemonicAlias<""ud2a"", ""ud2"">;. ... and many others. With a MnemonicAlias definition, the mnemonic is remapped; simply and directly. Though MnemonicAlias's can't look at any aspect of the; instruction (such as the operands) they can depend on global modes (the same; ones supported by the matcher), through a Requires clause:. ::. def : MnemonicAlias<""pushf"", ""pushfq"">, Requires<[In64BitMode]>;; def : MnemonicAlias<""pushf"", ""pushfl"">, Requires<[In32BitMode]>;. In this example, the mnemonic gets mapped into a different one depending on; the current instruction set. Instruction Aliases; ^^^^^^^^^^^^^^^^^^^. The most general phase of alias processing occurs while matching is happening:; it provides new forms for the matcher to match along with a specific instruction; to generate. An instruction alias has two parts: the string to match and the; instruction to generate. For example:. ::. def : InstAlias<""movsx $src, $dst"", (MOVSX16rr8W GR16:$dst, GR8 :$src)>;; def : InstAlias<""movsx $src, $dst"", (MOVSX16rm8W GR16:$dst, i8mem:$src)>;; def : InstAlias<""movsx $src, $dst"", (MOVSX32rr8 GR32:$dst, GR8 :$src)>;; def : InstAlias<""movsx $src, $dst"", (MOVSX32rr16 GR32:$dst, GR16 :$src)>;; def : InstAlias<""movsx $src, $dst"", (MOVSX64rr8 GR64:$dst, GR8 :$src)>;; def : InstAlias<""movsx $src, $dst"", (MOVSX64rr16 GR64:$dst, GR16 :$src)>;; def : InstAlias<""movsx $src, $dst"", (MOVSX64rr32 GR64:$dst, GR32 :$src)>;. This shows a powerful example of the instruction aliases, matching the same; mnemonic in multiple dif",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:83301,depend,depending,83301,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['depend'],['depending']
Integrability,nt of initialization of const variables; Unknown. 1922; CD4; Injected class template names and default arguments; Unknown. 1923; NAD; Lvalues of type void; Unknown. 1924; review; Definition of “literal” and kinds of literals; Not resolved. 1925; CD4; Bit-field prvalues; Unknown. 1926; CD4; Potential results of subscript operator; Unknown. 1927; dup; Lifetime of temporaries in init-captures; Unknown. 1928; NAD; Triviality of deleted special member functions; Unknown. 1929; CD4; template keyword following namespace nested-name-specifier; Unknown. 1930; CD4; init-declarator-list vs member-declarator-list; Unknown. 1931; CD5; Default-constructible and copy-assignable closure types; Unknown. 1932; CD4; Bit-field results of conditional operators; Unknown. 1933; NAD; Implementation limit for initializer-list elements; Unknown. 1934; NAD; Relaxing exception-specification compatibility requirements; Unknown. 1935; CD5; Reuse of placement arguments in deallocation; Unknown. 1936; CD6; Dependent qualified-ids; Unknown. 1937; CD5; Incomplete specification of function pointer from lambda; Unknown. 1938; CD5; Should hosted/freestanding be implementation-defined?; Unknown. 1939; open; Argument conversions to nondeduced parameter types revisited; Not resolved. 1940; CD4; static_assert in anonymous unions; Clang 3.5. 1941; CD4; SFINAE and inherited constructor default arguments; Clang 3.9. 1942; CD4; Incorrect reference to trailing-return-type; Unknown. 1943; CD5; Unspecified meaning of “bit”; Unknown. 1944; open; New C incompatibilities; Not resolved. 1945; open; Friend declarations naming members of class templates in non-templates; Not resolved. 1946; CD4; exception-specifications vs pointer dereference; Unknown. 1947; NAD; Digit separators following non-octal prefix; Clang 3.5. 1948; NAD; exception-specification of replacement global new; Clang 3.5. 1949; CD4; “sequenced after” instead of “sequenced before”; Unknown. 1950; NAD; Restructuring description of ranks of conversion seq,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:131463,Depend,Dependent,131463,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Depend'],['Dependent']
Integrability,"nt the abstract method `double DoDerivative(double x)`, leaving the rest of the class untouched. Example for implementing a gradient one-dimensional function:. ```{.cpp}; #include ""Math/IFunction.h"". class MyGradientFunction: public ROOT::Math::IGradientFunctionOneDim; {; public:; double DoEval(double x) const; {; return sin(x);; }. ROOT::Math::IBaseFunctionOneDim* Clone() const; {; return new MyGradientFunction();; }. double DoDerivative(double x) const; {; return -cos(x);; }. };; ```. ### Multi-dimensional Function Interfaces. The most generic case of a multidimensional function has similar approach. Some examples will be shown next. It is important to notice, that one dimensional functions can be also implemented through; the interfaces that will be presented here. Nevertheless, the user needs to implement those following the indications of the previous chapter, for algorithm working exclusivly on one-dimensional; functions. For algorithms working on both one-dimensional and multi-dimensional functions they should instead use this interface. * `ROOT::Math::IBaseFunctionMultiDim`: This interface provides the `double operator() (const double*)` that takes an array of doubles with all the values for the different dimensions. In this case,; the user has to provide the functionality for two different functions: `double DoEval(const double*)` and `unsigned int NDim()`. The first ones evaluates the function given the array that represents; the multiple variables. The second returns the number of dimensions of the function. Example of implementing a basic multi-dimensional function:. ```{.cpp}; #include ""Math/IFunction.h"". class MyFunction: public ROOT::Math::IBaseFunctionMultiDim; {; public:; double DoEval(const double* x) const; {; return x[0] + sin(x[1]);; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IBaseFunctionMultiDim* Clone() const; {; return new MyFunction();; }. };; ```. * `ROOT::Math::IGradientFunctionMultiDim`: This interface offers the same func",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:37733,interface,interface,37733,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['interface'],['interface']
Integrability,"nt to describe. The instance variables for an ARC-compiled class will be destroyed at some; point after control enters the ``dealloc`` method for the root class of the; class. The ordering of the destruction of instance variables is unspecified,; both within a single class and between subclasses and superclasses. .. admonition:: Rationale. The traditional, non-ARC pattern for destroying instance variables is to; destroy them immediately before calling ``[super dealloc]``. Unfortunately,; message sends from the superclass are quite capable of reaching methods in; the subclass, and those methods may well read or write to those instance; variables. Making such message sends from dealloc is generally discouraged,; since the subclass may well rely on other invariants that were broken during; ``dealloc``, but it's not so inescapably dangerous that we felt comfortable; calling it undefined behavior. Therefore we chose to delay destroying the; instance variables to a point at which message sends are clearly disallowed:; the point at which the root class's deallocation routines take over. In most code, the difference is not observable. It can, however, be observed; if an instance variable holds a strong reference to an object whose; deallocation will trigger a side-effect which must be carefully ordered with; respect to the destruction of the super class. Such code violates the design; principle that semantically important behavior should be explicit. A simple; fix is to clear the instance variable manually during ``dealloc``; a more; holistic solution is to move semantically important side-effects out of; ``dealloc`` and into a separate teardown phase which can rely on working with; well-formed objects. .. _arc.misc.autoreleasepool:. ``@autoreleasepool``; --------------------. To simplify the use of autorelease pools, and to bring them under the control; of the compiler, a new kind of statement is available in Objective-C. It is; written ``@autoreleasepool`` followed by a *c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:89695,message,message,89695,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,2,"['message', 'rout']","['message', 'routines']"
Integrability,"nt() method should allocate space for one; more element (using default constructor if element is a C++ object) and returns; a reference to that new allocated space. Flow Sequence; -------------; A YAML ""flow sequence"" is a sequence that when written to YAML it uses the; inline notation (e.g [ foo, bar ] ). To specify that a sequence type should; be written in YAML as a flow sequence, your SequenceTraits specialization should; add ""static const bool flow = true;"". For instance:. .. code-block:: c++. template <>; struct SequenceTraits<MyList> {; static size_t size(IO &io, MyList &list) { ... }; static MyListEl &element(IO &io, MyList &list, size_t index) { ... }. // The existence of this member causes YAML I/O to use a flow sequence; static const bool flow = true;; };. With the above, if you used MyList as the data type in your native data; structures, then when converted to YAML, a flow sequence of integers; will be used (e.g. [ 10, -3, 4 ]). Flow sequences are subject to line wrapping according to the Output object; configuration. Utility Macros; --------------; Since a common source of sequences is std::vector<>, YAML I/O provides macros:; LLVM_YAML_IS_SEQUENCE_VECTOR() and LLVM_YAML_IS_FLOW_SEQUENCE_VECTOR() which; can be used to easily specify SequenceTraits<> on a std::vector type. YAML; I/O does not partial specialize SequenceTraits on std::vector<> because that; would force all vectors to be sequences. An example use of the macros:. .. code-block:: c++. std::vector<MyType1>;; std::vector<MyType2>;; LLVM_YAML_IS_SEQUENCE_VECTOR(MyType1); LLVM_YAML_IS_FLOW_SEQUENCE_VECTOR(MyType2). Document List; =============. YAML allows you to define multiple ""documents"" in a single YAML file. Each; new document starts with a left aligned ""---"" token. The end of all documents; is denoted with a left aligned ""..."" token. Many users of YAML will never; have need for multiple documents. The top level node in their YAML schema; will be a mapping or sequence. For those cases, the f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst:26567,wrap,wrapping,26567,interpreter/llvm-project/llvm/docs/YamlIO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst,1,['wrap'],['wrapping']
Integrability,"nt; # before the just-built compiler can pass the configuration tests.; get_compiler_rt_path(compiler_rt_path); if(compiler_rt_path); if(NOT LLVM_BUILTIN_TARGETS); builtin_default_target(${compiler_rt_path}; DEPENDS clang-resource-headers); else(); if(""default"" IN_LIST LLVM_BUILTIN_TARGETS); builtin_default_target(${compiler_rt_path}; DEPENDS clang-resource-headers); list(REMOVE_ITEM LLVM_BUILTIN_TARGETS ""default""); else(); add_custom_target(builtins); add_custom_target(install-builtins); add_custom_target(install-builtins-stripped); endif(). foreach(target ${LLVM_BUILTIN_TARGETS}); check_apple_target(${target} builtin). builtin_register_target(${compiler_rt_path} ${target}; DEPENDS clang-resource-headers; CMAKE_ARGS -DLLVM_DEFAULT_TARGET_TRIPLE=${target}; EXTRA_ARGS TARGET_TRIPLE ${target}). add_dependencies(builtins builtins-${target}); add_dependencies(install-builtins install-builtins-${target}); add_dependencies(install-builtins-stripped install-builtins-${target}-stripped); endforeach(); endif(); set(builtins_dep builtins); # We don't need to depend on the builtins if we're building instrumented; # because the next stage will use the same compiler used to build this stage.; if(NOT LLVM_BUILD_INSTRUMENTED AND CLANG_ENABLE_BOOTSTRAP); add_dependencies(clang-bootstrap-deps builtins); endif(); endif(). function(_get_runtime_name name out_var); string(FIND ${name} ""lib"" idx); if(idx EQUAL 0 AND NOT ${name} STREQUAL ""libc""); string(SUBSTRING ${name} 3 -1 name); endif(); set(${out_var} ${name} PARENT_SCOPE); endfunction(). # Create a list with the names of all the runtime projects in all uppercase and; # with dashes turned to underscores. This gives us the CMake variable `prefixes`; # for all variables that will apply to runtimes.; foreach(entry ${runtimes}); get_filename_component(name ${entry} NAME); string(REPLACE ""-"" ""_"" canon_name ${name}); string(TOUPPER ${canon_name} canon_name); list(APPEND prefixes ${canon_name}); if (${canon_name} STREQUAL ""OPENMP""); list(A",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/runtimes/CMakeLists.txt:5842,depend,depend,5842,interpreter/llvm-project/llvm/runtimes/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/runtimes/CMakeLists.txt,1,['depend'],['depend']
Integrability,"nt`` attribute on a; call-site or a function and any explicit ``convergencectrl`` operand; bundle at a call-site. An optimizer may remove the ``convergent`` attribute and any explicit; ``convergencectrl`` operand bundle from a call-site if it can prove; that the execution of this call-site always results in a call to a; non-convergent function. An optimizer may remove the ``convergent`` attribute on a function if it can; prove that the function does not contain a call to; :ref:`llvm.experimental.convergence.entry; <llvm.experimental.convergence.entry>`, or any uncontrolled convergent; operations. Memory Model Non-Interaction; ============================. The fact that an operation is convergent has no effect on how it is treated for; memory model purposes. In particular, an operation that is ``convergent`` and; ``readnone`` does not introduce additional ordering constraints as far as the; memory model is concerned. There is no implied barrier, neither in the memory; barrier sense nor in the control barrier sense of synchronizing the execution; of threads. Informational note: Threads that execute converged dynamic instances do not; necessarily do so at the same time. Other Interactions; ==================. A function can be both ``convergent`` and; ``speculatable``, indicating that the function does not have undefined; behavior and has no effects besides calculating its result, but is still; affected by the set of threads executing this function. This typically; prevents speculation of calls to the function unless the constraint imposed; by ``convergent`` is further relaxed by some other means. Controlled Maximal Convergence; ==============================. The :ref:`converged-with relation <convergence-definition>` over dynamic; instances of each controlled convergent operation is completely defined by the; semantics of convergence tokens. But the implementation-defined convergence at a; call to :ref:`llvm.experimental.convergence.anchor; <llvm.experimental.converge",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:34558,synchroniz,synchronizing,34558,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['synchroniz'],['synchronizing']
Integrability,"ntation MyClass; - (void) foo {; _A = 0; // warn; }; @end. alpha.osx.cocoa.DirectIvarAssignmentForAnnotatedFunctions; (ObjC); Check for direct assignments to instance variables in the methods annotated; with objc_no_direct_instance_variable_assignment. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) fAnnotated __attribute__((; annotate(""objc_no_direct_instance_variable_assignment"")));; - (void) fNotAnnotated;; @end. @implementation MyClass; - (void) fAnnotated {; _A = 0; // warn; }; - (void) fNotAnnotated {; _A = 0; // no warn; }; @end. alpha.osx.cocoa.InstanceVariableInvalidation; (ObjC); Check that the invalidatable instance variables are invalidated in the methods; annotated with objc_instance_variable_invalidator. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interface SubclassInvalidationImpObj : InvalidationImpObj {; InvalidationImpObj *var;; }; - (void)invalidate;; @end. @implementation SubclassInvalidationImpObj; - (void) invalidate {}; @end; // warn: var needs to be invalidated or set to nil. alpha.osx.cocoa.MissingInvalidationMethod; (ObjC); Check that the invalidation methods are present in classes that contain; invalidatable instance variables. @protocol Invalidation <NSObject>; - (void)invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface NeedInvalidation : NSObject <Invalidation>; @end. @interface MissingInvalidationMethodDecl : NSObject {; NeedInvalidation *Var; // warn; }; @end. @implementation MissingInvalidationMethodDecl; @end. alpha.osx.cocoa.localizability.PluralMisuseChecker; (ObjC); Warns against using one vs. many plural pattern in code; when generating localized strings. NSString *reminderText =; NSLocalizedString(@""None"", @""Indicates no reminders"");; if (reminderCount == 1) {; // Warning: Plural cases are not supported across all lang",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:8340,interface,interface,8340,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,2,['interface'],['interface']
Integrability,"ntation relies on LLVM optimizations to; remove redundant run-time checks. Using this optimization strategy, if the; original source code already has bounds checks, the fewer additional checks; ``-fbounds-safety`` will introduce. The LLVM ``ConstraintElimination`` pass is; design to remove provable redundant checks (please check Florian Hahn’s; presentation in 2021 LLVM Dev Meeting and the implementation to learn more). In; the following example, ``-fbounds-safety`` implicitly adds the redundant bounds; checks that the optimizer can remove:. .. code-block:: c. void fill_array_with_indices(int *__counted_by(count) p, size_t count) {; for (size_t i = 0; i < count; ++i) {; // implicit bounds checks:; // if (p + i < p || p + i + 1 > p + count) trap();; p[i] = i;; }; }. ``ConstraintElimination`` collects the following facts and determines if the; bounds checks can be safely removed:. * Inside the for-loop, ``0 <= i < count``, hence ``1 <= i + 1 <= count``.; * Pointer arithmetic ``p + count`` in the if-condition doesn’t wrap.; * ``-fbounds-safety`` treats pointer arithmetic overflow as deterministically; two’s complement computation, not an undefined behavior. Therefore,; getelementptr does not typically have inbounds keyword. However, the compiler; does emit inbounds for ``p + count`` in this case because; ``__counted_by(count)`` has the invariant that p has at least as many as; elements as count. Using this information, ``ConstraintElimination`` is able; to determine ``p + count`` doesn’t wrap.; * Accordingly, ``p + i`` and ``p + i + 1`` also don’t wrap.; * Therefore, ``p <= p + i`` and ``p + i + 1 <= p + count``.; * The if-condition simplifies to false and becomes dead code that the subsequent; optimization passes can remove. ``OptRemarks`` can be utilized to provide insights into performance tuning. It; has the capability to report on checks that it cannot eliminate, possibly with; reasons, allowing programmers to adjust their code to unlock further; optimizations. De",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:7232,wrap,wrap,7232,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,1,['wrap'],['wrap']
Integrability,"ntee. A negative requirement uses the REQUIRES; attribute, in conjunction with the ``!`` operator, to indicate that a capability; should *not* be held. For example, using ``REQUIRES(!mu)`` instead of ``EXCLUDES(mu)`` will produce; the appropriate warnings:. .. code-block:: c++. class FooNeg {; Mutex mu;. void foo() REQUIRES(!mu) { // foo() now requires !mu.; mu.Lock();; bar();; baz();; mu.Unlock();; }. void bar() {; mu.Lock(); // WARNING! Missing REQUIRES(!mu).; // ...; mu.Unlock();; }. void baz() {; bif(); // WARNING! Missing REQUIRES(!mu).; }. void bif() REQUIRES(!mu);; };. Negative requirements are an experimental feature which is off by default,; because it will produce many warnings in existing code. It can be enabled; by passing ``-Wthread-safety-negative``. .. _faq:. Frequently Asked Questions; ==========================. (Q) Should I put attributes in the header file, or in the .cc/.cpp/.cxx file?. (A) Attributes are part of the formal interface of a function, and should; always go in the header, where they are visible to anything that includes; the header. Attributes in the .cpp file are not visible outside of the; immediate translation unit, which leads to false negatives and false positives. (Q) ""*Mutex is not locked on every path through here?*"" What does that mean?. (A) See :ref:`conditional_locks`, below. .. _limitations:. Known Limitations; =================. Lexical scope; -------------. Thread safety attributes contain ordinary C++ expressions, and thus follow; ordinary C++ scoping rules. In particular, this means that mutexes and other; capabilities must be declared before they can be used in an attribute.; Use-before-declaration is okay within a single class, because attributes are; parsed at the same time as method bodies. (C++ delays parsing of method bodies; until the end of the class.) However, use-before-declaration is not allowed; between classes, as illustrated below. .. code-block:: c++. class Foo;. class Bar {; void bar(Foo* f) REQUIRES(f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:18764,interface,interface,18764,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['interface'],['interface']
Integrability,"ntegral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::IntegratorMultiDim ig4(wf,ROOT::Math::IntegrationMultiDim::kMISER);; val = ig4.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. return status;; }; ```. #### Multi-dimensions Integration Algorithms. Here is the types, that can be specified as enumeration and the corresponding classes. | **Enumeration name**| **Integrator class** |; |------------------------------------ |-------------------------------|; | `ROOT::Math::IntegratorMultiDim::kADAPTIVE` | `ROOT::Math::AdaptiveIntegratorMultiDim` |; | `ROOT::Math::IntegratorMultiDim::kVEGAS` | `ROOT::Math:::GSLMCIntegrator` |; | `ROOT::Math::IntegratorMultiDim::kMISER` | `ROOT::Math:::GSLMCIntegrator` |; | `ROOT::Math::IntegratorMultiDim::kPLAIN` | `ROOT::Math:::GSLMCIntegrator` |. The control parameters for the integration algorithms can be specified using the; `ROOT::Math::IntegratorMultiDimOptions` class. Static methods are provided to change the default values.; It is possible to print the list of default control parameters using the `ROOT::Math::IntegratorMultiDimOptions::Print` function.; Example:; ```{.cpp}; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; ```; Depending on the algorithm, some of the control parameters might have no effect. #### `ROOT::Math::AdaptiveIntegratorMultiDim`. This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:60543,integrat,integration,60543,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['integrat'],['integration']
Integrability,"ntegrators will be migrated to; a MathCore implementation. Interface to TFoam adaptive MC sampler added; RooFit can now use the TFoam adaptive MC sampler for event generation of p.d.f.s that; do not have an internal generator. The TFoam generator adaptively subdivides the; observable space and is generally more efficient both warmup and generation than the original; RooAcceptReject algorithm. In its current interface in RooFit, TFoam cannot; handle problems yet with discrete observables or conditional observables. For those problems; the original RooAcceptReject generator is still used. The choice of MC sampling algorithm can be steered through class RooNumGenConfig, which; is similar in style and structure, to RooNumIntConfig which configures the choice of; numeric integration algorithm. A new tutorial macro rf902_numgenconfig.C has been added to $ROOTSYS/tutorials/roofit; to illustrate the use of the steering. A macro that demonstrates of the power of these newly interface numeric algorithms is provided at the; end of the RooFit section of the release notes. Optional persistent caching of numeric integrals; For p.d.f.s with numeric integrals that remain difficult or very time consuming,; a new persistent caching technique is now available that allows to precalculate; these integrals and store their values for future use. This technique works transparently; for any p.d.f. stored in a RooWorkspace. One can store numeric integral values for problems with zero, one or two floating parameters.; In the first case, the value is simply stored. In cases with one or two floating parameters; a grid (histogram) of integral values is stored, which are interpolated to return integral; values for each value of the parameters. A new tutorial macro rf903_numintcache.C has been added to $ROOTSYS/tutorials/roofit; to illustrate the use of this feature. Representation of function and p.d.f. derivatives; A new class has been added that can represent the derivative of any p.d.f or funct",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:6169,interface,interface,6169,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,2,['interface'],['interface']
Integrability,"nter otherwise.; ```c++; RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntegral(...) const override; {; std::unique_ptr<RooAbsReal> integral;; // Prepare a std::unique_ptr as the return value; ...; // Use the RooFit::makeOwningPtr<T>() helper to translate the; // std::unique_ptr to the actual return type (either std::unique_ptr<T> or T*).; return RooFit::makeOwningPtr<RooAbsReal>(std::move(integral));; }; ```. The biggest application of the memory-safe interfaces is to spot memory leaks; in RooFit-based frameworks. If you make sure that your framework compiles both; with and without `ROOFIT_MEMORY_SAFE_INTERFACES`, you can get rid of all memory; leaks related to RooFit user error! After making the necessary changes, you can; remove the marco definition again to keep backwards compatibility. Note that the memory-safe interfaces might become the default at some point, so; doing this **backwards-compatible migration early** is strongly encouraged and; appreciated. ### Removal of some memory-unsafe interfaces. * The final `bool takeOwnership` parameter of the **RooAddition** and; **RooStats::HistFactory::PiecewiseInterpolation** constructors was removed.; This is to avoid situations where ownership is not clear to the compiler.; Now, ownership of the input RooAbsArgs is never passed in the constructor. If; you want the pass input ownership to the created object, please use; `addOwnedComponents`. If you want to be extra safe, make sure the inputs are; in an owning collection and then `std::move` the collection, so that the; ownership is always clear. Example:; ```c++; RooArgList sumSet;; sumSet.add(*(new RooRealVar(""var1"", ""var1"", 1.0)));; sumSet.add(*(new RooRealVar(""var2"", ""var2"", 3.0)));; RooAddition addition{""addition"", ""addition"", sumSet, /*takeOwnership=*/true};; ```; should become:; ```c++; RooArgList sumSet;; sumSet.addOwned(std::make_unique<RooRealVar>(""var1"", ""var1"", 1.0));; sumSet.addOwned(std::make_unique<RooRealVar>(""var2"", ""var2"", 3.0));; RooAddition addi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:10640,interface,interfaces,10640,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['interface'],['interfaces']
Integrability,"nterface of ``lib/Support`` must be aimed at; completing some reasonably high level task needed by LLVM. We do not want to; simply wrap each operating system call. It would be preferable to wrap several; operating system calls that are always used in conjunction with one another by; LLVM. For example, consider what is needed to execute a program, wait for it to; complete, and return its result code. On Unix, this involves the following; operating system calls: ``getenv``, ``fork``, ``execve``, and ``wait``. The; correct thing for ``lib/Support`` to provide is a function, say; ``ExecuteProgramAndWait``, that implements the functionality completely. what; we don't want is wrappers for the operating system calls involved. There must **not** be a one-to-one relationship between operating system; calls and the Support library's interface. Any such interface function will be; suspicious. No Unused Functionality; -----------------------. There must be no functionality specified in the interface of ``lib/Support``; that isn't actually used by LLVM. We're not writing a general purpose operating; system wrapper here, just enough to satisfy LLVM's needs. And, LLVM doesn't; need much. This design goal aims to keep the ``lib/Support`` interface small and; understandable which should foster its actual use and adoption. No Duplicate Implementations; ----------------------------. The implementation of a function for a given platform must be written exactly; once. This implies that it must be possible to apply a function's; implementation to multiple operating systems if those operating systems can; share the same implementation. This rule applies to the set of operating; systems supported for a given class of operating system (e.g. Unix, Win32). No Virtual Methods; ------------------. The Support Library interfaces can be called quite frequently by LLVM. In order; to make those calls as efficient as possible, we discourage the use of virtual; methods. There is no need to use inheri",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:4968,interface,interface,4968,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['interface'],['interface']
Integrability,"nterface which provides the user with more functionality; such as interaction with parameters. The core of the minimization functionality and related tools (the kernel; of M ) should be clearly separated from the user, who is interfacing via; defined user interfaces (the API). ## Internal and external parameters ##. Each of the parameters to the $\mbox{FCN}$ is defined by the user as; belonging to one of the following types:. - Freely variable: allowed to take on any value. - Variable with double sided limits: allowed to vary only between two; limits specified by the user. - Variable with single sided limits: allowed to vary only between one; upper or one lower limit specified by the user and unlimited to the; other side. - Fixed: originally defined as variable, but now taking on only the; value the parameter had at the moment it was fixed, or a value later; assigned by the user. - Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are; free and unbound. The user, in their $\mbox{FCN}$, must of course be able to ""see"" all; types of defined parameters, and they therefore have access to what we call; the *external parameter list*, that is, the parameters as he defined; them. On the other hand, the internal M minimizing routines only want to; ""see"" variable parameters without limits, and so they have access only; to the *internal parameter list* which is created from the external list; by the following transformation:. - Squeeze out all parameters that are not variable. - Transform all variable parameters with limits, so that the; transformed parameter can vary without limits. (See the next section; for details concerning this transformation.) Because this; transformation is non-linear, it is recommended to avoid putting; limits on parameters where they are not needed. As an example, suppose that the user has defined the following; parameters:. - Parameter 0, constant. - Parameter 1, freely va",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:5699,interface,interface,5699,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['interface'],['interface']
Integrability,"ntics, and these types nest; strictly within each other. Good examples of this can be seen in the ``Value``; or ``Type`` type hierarchies. A second is the desire to dispatch dynamically across a collection of; polymorphic interface implementations. This latter use case can be modeled with; virtual dispatch and inheritance by defining an abstract interface base class; which all implementations derive from and override. However, this; implementation strategy forces an **""is-a""** relationship to exist that is not; actually meaningful. There is often not some nested hierarchy of useful; generalizations which code might interact with and move up and down. Instead,; there is a singular interface which is dispatched across a range of; implementations. The preferred implementation strategy for the second use case is that of; generic programming (sometimes called ""compile-time duck typing"" or ""static; polymorphism""). For example, a template over some type parameter ``T`` can be; instantiated across any particular implementation that conforms to the; interface or *concept*. A good example here is the highly generic properties of; any type which models a node in a directed graph. LLVM models these primarily; through templates and generic programming. Such templates include the; ``LoopInfoBase`` and ``DominatorTreeBase``. When this type of polymorphism; truly needs **dynamic** dispatch you can generalize it using a technique; called *concept-based polymorphism*. This pattern emulates the interfaces and; behaviors of templates using a very limited form of virtual dispatch for type; erasure inside its implementation. You can find examples of this technique in; the ``PassManager.h`` system, and there is a more detailed introduction to it; by Sean Parent in several of his talks and papers:. #. `Inheritance Is The Base Class of Evil; <http://channel9.msdn.com/Events/GoingNative/2013/Inheritance-Is-The-Base-Class-of-Evil>`_; - The GoingNative 2013 talk describing this technique, and p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:130316,interface,interface,130316,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['interface'],['interface']
Integrability,"ntly do the wrong thing.; If this is a new method or you control the callers, you can use; NSParameterAssert() (or the equivalent) to check the precondition and; remove the nil return. But if you don't control the callers and they rely on; this behavior, you should return mark the method _Nonnull and return; nil cast to _Nonnull anyway.; (Note that (4) doesn't apply in cases where the caller can't know they passed; bad parameters. For example,; +[NSData dataWithContentsOfFile:options:error:] will fail if the file; doesn't exist, but there's no way to check for that in advance. This means; you're really in (2).); If you're in (5), document it, then figure out if you're now in (2), (3), or; (4). :-); Q: How do I tell the analyzer that I am intentionally violating nullability?; In some cases, it may make sense for methods to intentionally violate; nullability. For example, your method may — for reasons of backward; compatibility — chose to return nil and log an error message in a method; with a non-null return type when the client violated a documented precondition; rather than check the precondition with NSAssert(). In these cases, you; can suppress the analyzer warning with a cast:. return (id _Nonnull)nil;. Note that this cast does not affect code generation. Q: The analyzer assumes that a loop body is never entered. How can I tell it that the loop body will be entered at least once?. In the contrived example above, the analyzer has detected that the body of; the loop is never entered for the case where length <= 0. In this; particular example, you may know that the loop will always be entered because; the input parameter length will be greater than zero in all calls to this; function. You can teach the analyzer facts about your code as well as document; it by using assertions. By adding assert(length > 0) in the beginning; of the function, you tell the analyzer that your code is never expecting a zero; or a negative value, so it won't need to test the correctness o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/faq.html:6884,message,message,6884,interpreter/llvm-project/clang/www/analyzer/faq.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/faq.html,2,['message'],['message']
Integrability,"nto subintervals, and on each; iteration the subinterval with the largest estimated error is bisected. It is possible to specify the integration rule as an extra enumeration parameter. The possible rules are; * `Integration::kGAUSS15` : 15 points Gauss-Konrod rule (value = 1); * `Integration::kGAUSS21` : 21 points Gauss-Konrod rule (value = 2); * `Integration::kGAUSS31` : 31 points Gauss-Konrod rule (value = 3); * `Integration::kGAUSS41` : 41 points Gauss-Konrod rule (value = 4); * `Integration::kGAUSS51` : 51 points Gauss-Konrod rule (value = 5); * `Integration::kGAUSS61` : 61 points Gauss-Konrod rule (value = 6); 	 The higher-order rules give better accuracy for smooth functions, while lower-order rules save time when the function contains local difficulties, such as discontinuities. If no integration rule; 	 is passed, the 31 points rule is used as default. * 	 `ROOT::Math::Integration::kADAPTIVESINGULAR`: based on `gsl_integration_qags`. It is an integration type which can be used in the case of the presence of singularities.It uses the; Gauss-Kronrod 21-point integration rule. This is the default algorithm. Note that when using the common `ROOT::Math::IntegratorOneDIm` class the enumeration type defining the algorithm must be defined in the namespace `ROOT::Math::IntegrationOneDim` (to distinguish from; the multi-dimensional case) and the rule enumeration (or its corresponding integer) can be passed in the constructor of the `ROOT::Math::IntegratorOneDIm`. ### Multi-dimensional Integration. The multi-dimensional integration algorithm should be applied to functions with dimension larger than one.; Adaptive multi-dimensional integration works for low function dimension, while MC integration can be applied to higher dimensions. #### Using `ROOT::Math::IntegratorMultiDim`. Here is a code example on how to use the `ROOT::Math::IntegratorOneDim` class; (note that the class is defined in the header file `Math/Integrator.h`). In this example we create; different instan",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:57599,integrat,integration,57599,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['integrat'],['integration']
Integrability,"ntry single exit regions in a function,; where a region is defined as any subgraph that is connected to the remaining; graph at only two spots. Furthermore, a hierarchical region tree is built. .. _passes-scalar-evolution:. ``scalar-evolution``: Scalar Evolution Analysis; -----------------------------------------------. The ``ScalarEvolution`` analysis can be used to analyze and categorize scalar; expressions in loops. It specializes in recognizing general induction; variables, representing them with the abstract and opaque ``SCEV`` class.; Given this analysis, trip counts of loops and other important properties can be; obtained. This analysis is primarily useful for induction variable substitution and; strength reduction. ``scev-aa``: ScalarEvolution-based Alias Analysis; -------------------------------------------------. Simple alias analysis implemented in terms of ``ScalarEvolution`` queries. This differs from traditional loop dependence analysis in that it tests for; dependencies within a single iteration of a loop, rather than dependencies; between different iterations. ``ScalarEvolution`` has a more complete understanding of pointer arithmetic; than ``BasicAliasAnalysis``' collection of ad-hoc analyses. ``stack-safety``: Stack Safety Analysis; ---------------------------------------. The ``StackSafety`` analysis can be used to determine if stack allocated; variables can be considered safe from memory access bugs. This analysis' primary purpose is to be used by sanitizers to avoid unnecessary; instrumentation of safe variables. Transform Passes; ================. This section describes the LLVM Transform Passes. ``adce``: Aggressive Dead Code Elimination; ------------------------------------------. ADCE aggressively tries to eliminate code. This pass is similar to :ref:`DCE; <passes-dce>` but it assumes that values are dead until proven otherwise. This; is similar to :ref:`SCCP <passes-sccp>`, except applied to the liveness of; values. ``always-inline``: Inline",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:11092,depend,dependence,11092,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,3,['depend'],"['dependence', 'dependencies']"
Integrability,"nts and argument-dependent lookup; Unknown. 1016; C++11; Overloadable declarations, function templates, and references; Unknown. 1017; C++11; Member access transformation in unevaluated operands; Unknown. 1018; C++11; Ambiguity between simple-declaration and attribute-declaration; Unknown. 1019; dup; Dependent simple-template-ids in base-specifiers and mem-initializers; Unknown. 1020; C++11; Implicitly-defined copy constructors and explicit base class constructors; Unknown. 1021; CD4; Definitions of namespace members; Unknown. 1022; C++11; Can an enumeration variable have values outside the values of the enumeration?; Unknown. 1023; dup; thread_local objects as non-type template arguments; Unknown. 1024; CD3; Limits on multicharacter literals; Unknown. 1025; C++11; Use of a reference as a non-type template argument; Unknown. 1026; NAD; Cv-qualified non-class rvalues; Unknown. 1027; review; Type consistency and reallocation of scalar types; Not resolved. 1028; CD6; Dependent names in non-defining declarations; Unknown. 1029; C++11; Type of a destructor call; Unknown. 1030; C++11; Evaluation order in initializer-lists used in aggregate initialization; Unknown. 1031; C++11; Optional elements in attributes; Unknown. 1032; C++11; Empty pack expansions; Unknown. 1033; C++11; Restrictions on alignment attributes; Unknown. 1034; C++11; Attributes for return statements in lambdas; Unknown. 1035; C++11; Omitted and required decl-specifiers; Unknown. 1036; C++11; Alignment attribute in an exception-declaration; Unknown. 1037; C++11; Requirements for operands of delete-expressions and deallocation functions; Unknown. 1038; DR; Overload resolution of &x.static_func; Unknown. 1039; dup; Coordinating C and C++ alignment specifications; Unknown. 1040; NAD; Memory model issues; Unknown. 1041; dup; alias-declarations as class members; Unknown. 1042; C++11; Attributes in alias-declarations; Clang 3.5. 1043; C++11; Qualified name lookup in the current instantiation; Unknown. 1044; C++1",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:67877,Depend,Dependent,67877,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Depend'],['Dependent']
Integrability,"nts to instance variables in; the methods annotated with ``objc_no_direct_instance_variable_assignment``. .. code-block:: objc. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) fAnnotated __attribute__((; annotate(""objc_no_direct_instance_variable_assignment"")));; - (void) fNotAnnotated;; @end. @implementation MyClass; - (void) fAnnotated {; _A = 0; // warn; }; - (void) fNotAnnotated {; _A = 0; // no warn; }; @end. .. _alpha-osx-cocoa-InstanceVariableInvalidation:. alpha.osx.cocoa.InstanceVariableInvalidation (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that the invalidatable instance variables are; invalidated in the methods annotated with objc_instance_variable_invalidator. .. code-block:: objc. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interface SubclassInvalidationImpObj : InvalidationImpObj {; InvalidationImpObj *var;; }; - (void)invalidate;; @end. @implementation SubclassInvalidationImpObj; - (void) invalidate {}; @end; // warn: var needs to be invalidated or set to nil. .. _alpha-osx-cocoa-MissingInvalidationMethod:. alpha.osx.cocoa.MissingInvalidationMethod (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that the invalidation methods are present in classes that contain invalidatable instance variables. .. code-block:: objc. @protocol Invalidation <NSObject>; - (void)invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface NeedInvalidation : NSObject <Invalidation>; @end. @interface MissingInvalidationMethodDecl : NSObject {; NeedInvalidation *Var; // warn; }; @end. @implementation MissingInvalidationMethodDecl; @end. .. _alpha-osx-cocoa-localizability-PluralMisuseChecker:. alpha.osx.cocoa.localizability.PluralMisuseChecker (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns against using one vs",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:58582,interface,interface,58582,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['interface'],['interface']
Integrability,"nts. * ``A build of LLVM/clang for the llvm-tools and llvm-config``; * ``A clang executable with support for the ARM target``; * ``compiler-rt sources``; * ``The qemu-arm user mode emulator``; * ``An arm-linux-gnueabihf sysroot``. In this example we will be using ninja. See https://compiler-rt.llvm.org/ for more information about the dependencies; on clang and LLVM. See https://llvm.org/docs/GettingStarted.html for information about obtaining; the source for LLVM and compiler-rt. Note that the getting started guide; places compiler-rt in the projects subdirectory, but this is not essential and; if you are using the BaremetalARM.cmake cache for v6-M, v7-M and v7-EM then; compiler-rt must be placed in the runtimes directory. ``qemu-arm`` should be available as a package for your Linux distribution. The most complicated of the prerequisites to satisfy is the arm-linux-gnueabihf; sysroot. In theory it is possible to use the Linux distributions multiarch; support to fulfill the dependencies for building but unfortunately due to; /usr/local/include being added some host includes are selected. The easiest way; to supply a sysroot is to download the arm-linux-gnueabihf toolchain. This can; be found at:; * https://developer.arm.com/open-source/gnu-toolchain/gnu-a/downloads for gcc 8 and above; * https://releases.linaro.org/components/toolchain/binaries/ for gcc 4.9 to 7.3. Building compiler-rt builtins for Arm; =====================================; We will be doing a standalone build of compiler-rt using the following cmake; options. * ``path/to/compiler-rt``; * ``-G Ninja``; * ``-DCMAKE_AR=/path/to/llvm-ar``; * ``-DCMAKE_ASM_COMPILER_TARGET=""arm-linux-gnueabihf""``; * ``-DCMAKE_ASM_FLAGS=""build-c-flags""``; * ``-DCMAKE_C_COMPILER=/path/to/clang``; * ``-DCMAKE_C_COMPILER_TARGET=""arm-linux-gnueabihf""``; * ``-DCMAKE_C_FLAGS=""build-c-flags""``; * ``-DCMAKE_EXE_LINKER_FLAGS=""-fuse-ld=lld""``; * ``-DCMAKE_NM=/path/to/llvm-nm``; * ``-DCMAKE_RANLIB=/path/to/llvm-ranlib``; * ``-DCOMPIL",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst:2026,depend,dependencies,2026,interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst,1,['depend'],['dependencies']
Integrability,"nuit Error Estimates. `Minuit` always carries around its own current estimates of the; parameter errors, which it will print out on request, no matter how; accurate they are at any given point in the execution. For example, at; initialization, these estimates are just the starting step sizes as; specified by the user. After a `HESSE` step, the errors are usually; quite accurate, unless there has been a problem. `Minuit`, when it; prints out error values, also gives some indication of how reliable it; thinks they are. For example, those marked `CURRENT GUESS ERROR` are; only working values not to be believed, and `APPROXIMATE ERROR` means; that they have been calculated but there is reason to believe that; they may not be accurate. If no mitigating adjective is given, then at least `Minuit` believes; the errors are accurate, although there is always a small chance that; `Minuit` has been fooled. Some visible signs that `Minuit` may have; been fooled:. - Warning messages produced during the minimization or error; analysis. - Failure to find new minimum. - Value of EDM too big (estimated Distance to Minimum). - Correlation coefficients exactly equal to zero, unless some; parameters are known to be uncorrelated with the others. - Correlation coefficients very close to one (greater than 0.99).; This indicates both an exceptionally difficult problem, and one; which has been badly parameterized so that individual errors are; not very meaningful because they are so highly correlated. - Parameter at limit. This condition, signaled by a `Minuit` warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ‘Getting the right parameter; errors with limits'. The best way to be absolutely sure of the errors is to use; ''independent'' calculations and compare them, or compare the; calculated errors with a picture of the function. Theoretically, the; covariance matrix for a ''physical'' function must be; positive-definite at the mi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:61464,message,messages,61464,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['message'],['messages']
Integrability,"nvalidation for free. As a metaphor, i'd probably compare it to body farms - the difference between; ghost member variables and metadata symbols seems to me like the difference; between body farms and evalCall. Both are nice to have, and body farms are very; pleasant to work with, even if not omnipotent. I think it's fine for a; FunctionDecl's body in a body farm to have a local variable, even if such; variable doesn't actually exist, even if it cannot be seen from outside the; function call. I'm not seeing immediate practical difference between ""it does; actually exist"" and ""it doesn't actually exist, just a handy abstraction"".; Similarly, i think it's fine if we have a ``CXXRecordDecl`` with; implementation-defined contents, and try to farm up a member variable as a handy; abstraction (we don't even need to know its name or offset, only that it's there; somewhere). **Artem:**. We've discussed it in person with Devin, and he provided more points to think; about:. * If the initializer list consists of non-POD data, constructors of list's; objects need to take the sub-region of the list's region as this-region In the; current (v2) version of this patch, these objects are constructed elsewhere and; then trivial-copied into the list's metadata pointer region, which may be; incorrect. This is our overall problem with C++ constructors, which manifests in; this case as well. Additionally, objects would need to be constructed in the; analyzer's core, which would not be able to predict that it needs to take a; checker-specific region as this-region, which makes it harder, though it might; be mitigated by sharing the checker state traits. * Because ""ghost variables"" are not material to the user, we need to somehow; make super sure that they don't make it into the diagnostic messages. So, because this needs further digging into overall C++ support and rises too; many questions, i'm delaying a better approach to this problem and will fall; back to the original trivial patch.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:17641,message,messages,17641,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,1,['message'],['messages']
Integrability,"nvas with embed geometry drawing; 4. Fix - upgrade rollup and import.meta polyfill. ## Changes in 7.7.3; 1. Fix - correctly handle in I/O empty std::map; 2. Fix - reading of small (<1KB) ROOT files; 3. Fix - race condition in zstd initialization #318; 4. Fix - deployment with zstd #317. ## Changes in 7.7.2; 1. Fix - hide empty title on the canvas; 2. Fix - properly handle zooming in THStack histogram; 3. Fix - always use 0 as minimum in THStack drawings; 4. Fix - always show all ticks for labeled axis; 5. Fix - draw TProfile2D bins content as text, not entries; 6. Fix - interactive zooming on log color palette; 7. Fix - keyboard handling while input dialog active; 8. Fix - legend entry with not configured fill attributes; 9. Fix - prevent that color palette exceed graphical range; 10. Fix - exponential log axis labels with kMoreLogLabels bit set. ## Changes in 7.7.1; 1. Fix - properly select TF1 range after zooming; 2. Fix - TH1 y-range selection; 3. Fix - add 'gl' and svg2pdf-related packages to dependencies in package.json. ## Changes in 7.7.0; 1. Let plot current time, file creation or modification time with `&optdate=[1,2,3]` URL parameters; 2. Let plot file name, full file name or item name with `&optfile=[1,2,3]` URL parameters; 3. Let define date and file name position with `&datex=0.03&datey=0.03` URL parameters; 4. Improve TRatioPlot axis and lines drawing; 5. Use localStorage to preserve custom settings and gStyle; 6. Let configure custom storage prefix with `&storage_prefix=name` URL #290; 7. Let customize URL for ""Show in new tab"" menu command; 8. Support both new and old TRatioPlot drawings; 10. Synchronize X/Y range selection with native ROOT; 11. Proper handle attributes from TH2Poly bins, support ""p"" for markers drawing; 12. Correctly scale size of axis ticks - take into account NDC axis length; 13. Set name and userData in geometry `build()` function #303; 14. Draw histogram title afterwards - place in front of stats box; 15. Upgrade three.js r158 -",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:3985,depend,dependencies,3985,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['depend'],['dependencies']
Integrability,"nvases are defined,; there is only one active at a time. One draws an object in the active; canvas by using the statement:. ``` {.cpp}; object.Draw(); ```. This instructs the object ""`object`"" to draw itself. If no canvas is; opened, a default one (named ""`c1`"") is created. In the next example,; the first statement defines a function and the second one draws it. A; default canvas is created since there was no opened one. You should; see the picture as shown in the next figure. ``` {.cpp}; root[] TF1 f1(""func1"",""sin(x)/x"",0,10); root[] f1.Draw(); <TCanvas::MakeDefCanvas>: created default TCanvas with name c1; ```. ![A canvas with drawing](pictures/0300000A.png). The following components comprise the canvas window:. - Menu bar - contains main menus for global operations with files,; print, clear canvas, inspect, etc. - Tool bar - has buttons for global and drawing operations; such as; arrow, ellipse, latex, pad, etc. - Canvas - an area to draw objects. - Status bar - displays descriptive messages about the selected; object. - Editor frame - responds dynamically and presents the user; interface according to the selected object in the canvas. ### Main Menus and Toolbar. At the top of the canvas window are File, Edit, View, Options,; Inspect, Classes and Help menus. #### File Menu. - *New Canvas*: creates a new canvas window in the current ROOT; session. - *Open...*: popup a dialog to open a file. - *Close Canvas*: close the canvas window. - *Save*: save the drawing of the current canvas in a format; selectable from the submenu. The current canvas name is used as a; file name for various formats such as PostScript, GIF, JPEG, C; macro file, root file. - *Save As...*: popup a dialog for saving the current canvas drawing; in a new filename. - *Print*: popup a dialog to print the current canvas drawing. - *Quit ROOT*: exit the ROOT session. ![](pictures/0300000B.png). #### Edit Menu. There is only one active menu entry in the Edit menu. The others menu; entries will be imple",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:7271,message,messages,7271,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['message'],['messages']
Integrability,"ny invalid constructs in class templates that Clang has; historically rejected. In order to parse widely distributed headers for; libraries such as the Active Template Library (ATL) and Windows Runtime Library; (WRL), some template rules have been relaxed or extended in Clang on Windows. The first major semantic difference is that MSVC appears to defer all parsing; an analysis of inline method bodies in class templates until instantiation; time. By default on Windows, Clang attempts to follow suit. This behavior is; controlled by the ``-fdelayed-template-parsing`` flag. While Clang delays; parsing of method bodies, it still parses the bodies *before* template argument; substitution, which is not what MSVC does. The following compatibility tweaks; are necessary to parse the template in those cases. MSVC allows some name lookup into dependent base classes. Even on other; platforms, this has been a `frequently asked question`_ for Clang users. A; dependent base class is a base class that depends on the value of a template; parameter. Clang cannot see any of the names inside dependent bases while it; is parsing your template, so the user is sometimes required to use the; ``typename`` keyword to assist the parser. On Windows, Clang attempts to; follow the normal lookup rules, but if lookup fails, it will assume that the; user intended to find the name in a dependent base. While parsing the; following program, Clang will recover as if the user had written the; commented-out code:. .. _frequently asked question:; https://clang.llvm.org/compatibility.html#dep_lookup. .. code-block:: c++. template <typename T>; struct Foo : T {; void f() {; /*typename*/ T::UnknownType x = /*this->*/unknownMember;; }; };. After recovery, Clang warns the user that this code is non-standard and issues; a hint suggesting how to fix the problem. As of this writing, Clang is able to compile a simple ATL hello world; application. There are still issues parsing WRL headers for modern Windows 8; apps",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst:5893,depend,dependent,5893,interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,2,['depend'],"['dependent', 'depends']"
Integrability,"ny nesting of cycles discovered by the implementation-defined; DFS, consider the smallest cycle C which contains P. For the sake; of contradiction, assume that D is in C. Then the header H of C; cannot be in P, since the header of a cycle cannot be dominated by; any other node in the cycle. Thus, P is in the set (C-H), and there; must be a smaller cycle C' in C which also contains P, but that; contradicts how we chose C. 3. If a closed path P contains nodes U1 and U2 but not their; dominators D1 and D2 respectively, then there exists a cycle C that; contains U1 and U2 but neither of D1 and D2. **Proof:** From the above properties, each D1 and D2 separately; dominate every node in P. There exists a cycle C1 (respectively,; C2) that contains P but not D1 (respectively, D2). Either C1 and C2; are the same cycle, or one of them is nested inside the other.; Hence there is always a cycle that contains U1 and U2 but neither; of D1 and D2. .. _cycle-closed-path-header:. 4. In any cycle hierarchy, the header ``H`` of the smallest cycle; ``C`` containing a closed path ``P`` itself lies on ``P``. **Proof:** If ``H`` is not in ``P``, then there is a smaller cycle; ``C'`` in the set ``C - H`` containing ``P``, thus contradicting; the claim that ``C`` is the smallest such cycle. .. _cycle-reducible-headers:. Reducible Cycle Headers; =======================. Although the cycle hierarchy depends on the DFS chosen, reducible; cycles satisfy the following invariant:. If a reducible cycle ``C`` with header ``H`` is discovered in any; DFS, then there exists a cycle ``C'`` in every DFS with header; ``H``, that contains ``C``. **Proof:** For a closed path ``P`` in ``C`` that passes through ``H``,; every cycle hierarchy has a smallest cycle ``C'`` containing ``P`` and; whose header is in ``P``. Since ``H`` is the only entry to ``P``,; ``H`` must be the header of ``C'``. Since headers uniquely define; cycles, ``C'`` contains every such closed path ``P``, and hence ``C'``; contains ``C``.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CycleTerminology.rst:7395,depend,depends,7395,interpreter/llvm-project/llvm/docs/CycleTerminology.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CycleTerminology.rst,1,['depend'],['depends']
Integrability,"ny work; (also see :ref:`loop-terminology-loop-rotate`), loop trip count is not; the best measure of a loop's number of iterations. For instance, the; number of header executions of the code below for a non-positive n; (before loop rotation) is 1, even though the loop body is not executed; at all. .. code-block:: C. for (int i = 0; i < n; ++i); body(i);. A better measure is the **backedge-taken count**, which is the number of; times any of the backedges is taken before the loop. It is one less than; the trip count for executions that enter the header. .. _loopinfo:. LoopInfo; ========. LoopInfo is the core analysis for obtaining information about loops.; There are few key implications of the definitions given above which; are important for working successfully with this interface. * LoopInfo does not contain information about non-loop cycles. As a; result, it is not suitable for any algorithm which requires complete; cycle detection for correctness. * LoopInfo provides an interface for enumerating all top level loops; (e.g. those not contained in any other loop). From there, you may; walk the tree of sub-loops rooted in that top level loop. * Loops which become statically unreachable during optimization *must*; be removed from LoopInfo. If this can not be done for some reason,; then the optimization is *required* to preserve the static; reachability of the loop. .. _loop-terminology-loop-simplify:. Loop Simplify Form; ==================. The Loop Simplify Form is a canonical form that makes; several analyses and transformations simpler and more effective.; It is ensured by the LoopSimplify; (:ref:`-loop-simplify <passes-loop-simplify>`) pass and is automatically; added by the pass managers when scheduling a LoopPass.; This pass is implemented in; `LoopSimplify.h <https://llvm.org/doxygen/LoopSimplify_8h_source.html>`_.; When it is successful, the loop has:. * A preheader.; * A single backedge (which implies that there is a single latch).; * Dedicated exits. That is,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst:9504,interface,interface,9504,interpreter/llvm-project/llvm/docs/LoopTerminology.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst,1,['interface'],['interface']
Integrability,"o (and update) the list of files in the file browser (left panel) when opening a ROOT file from the ""Open File"" menu. TGListView. Keyboard navigation is now fully working in the list view. TGMainFrame. Allow to save a snapshot of the GUI in a picture file. The supported formats are gif, jpg, png, tiff, and xpm. TGFileDialog. Allow to change directory by typing its name in the text entry field of the dialog. TProofProgressDialog. Added a speedometer widget (TGSpeedo) to display the processing rate; Added a check button to enable/disable smooth update of the speedometer (enabled by default). This could be useful in the case of slow displays (e.g. when using it via ssh); Several layout improvements. TRecorder. Improvements and consolidation of the cross-platform interoperability, allowing to record and replay sessions between different platforms with less side effects. NB: Using different OS/WM (Window Managers) and using different ROOT GUI settings (via e.g. system.rootrc) between recording and replaying may still produce a wrong behavior of the recorder.; New tutorial guitest_playback.C replaying a recorded session showing and validating the GUI (using guitest.C). GUI Builder; New features, new user interface; Several important features have been added to the builder, and its user interface has been redesigned.; Editing modes are now clearly distinguished with enabled and disabled layout mode. Possibility to enable automatic layout fasten the interface development, as the positioning doesn't have to be done manually anymore; Major changes in the user interface:. Added a list tree displaying the complete structure of the GUI; The name of every element of the GUI is now editable; New, more intuitive interface for padding and layout hints; Color settings option was added to the widget editor; Extended commands in the top menu (open project, save project...); Added important warning dialogs, such as ""Save project"" dialog when closing the window; Added several tool tips. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v526/index.html:1788,interface,interface,1788,gui/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v526/index.html,10,['interface'],['interface']
Integrability,"o TLS via the ``thread_local``; keyword, and often use the same underlying hardware, there are some fundamental; differences. The ``thread_local`` keyword applies to global variables and specifies that they; are to be allocated in thread-local memory. There are no type qualifiers; involved, and these variables can be pointed to with normal pointers and; accessed with normal loads and stores. The ``thread_local`` keyword is; target-independent at the LLVM IR level (though LLVM doesn't yet have; implementations of it for some configurations). Special address spaces, in contrast, apply to static types. Every load and store; has a particular address space in its address operand type, and this is what; determines which address space is accessed. LLVM ignores these special address; space qualifiers on global variables, and does not provide a way to directly; allocate storage in them. At the LLVM IR level, the behavior of these special; address spaces depends in part on the underlying OS or runtime environment, and; they are specific to x86 (and LLVM doesn't yet handle them correctly in some; cases). Some operating systems and runtime environments use (or may in the future use); the FS/GS-segment registers for various low-level purposes, so care should be; taken when considering them. Instruction naming; ^^^^^^^^^^^^^^^^^^. An instruction name consists of the base name, a default operand size, and a; character per operand with an optional special size. For example:. ::. ADD8rr -> add, 8-bit register, 8-bit register; IMUL16rmi -> imul, 16-bit register, 16-bit memory, 16-bit immediate; IMUL16rmi8 -> imul, 16-bit register, 16-bit memory, 8-bit immediate; MOVSX32rm16 -> movsx, 32-bit register, 16-bit memory. The PowerPC backend; -------------------. The PowerPC code generator lives in the lib/Target/PowerPC directory. The code; generation is retargetable to several variations or *subtargets* of the PowerPC; ISA; including ppc32, ppc64 and altivec. LLVM PowerPC ABI; ^^^^^^^^^^^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:93414,depend,depends,93414,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['depend'],['depends']
Integrability,"o ``cling`` is fine for interactive; work and smaller packages, but large scale applications benefit from; pre-compiling code, using the automatic class loader, and packaging; dependencies in so-called ""dictionaries."". A `dictionary` is a generated C++ source file containing references to the; header locations used when building (and any additional locations provided),; a set of forward declarations to reduce the need of loading header files, and; a few I/O helper functions.; The name ""dictionary"" is historic: before ``cling`` was used, it contained; the complete generated C++ reflection information, whereas now that is; derived at run-time from the header files.; It is still possible to fully embed header files rather than only storing; their names and search locations, to make the dictionary more self-contained. After generating the dictionary, it should be compiled into a shared library.; This provides additional dependency control: by linking it directly with any; further libraries needed, you can use standard mechanisms such as ``rpath``; to locate those library dependencies.; Alternatively, you can add the additional libraries to load to the mapping; files of the class loader (see below). .. note::. The JIT needs to resolve linker symbols in order to call them through; generated wrappers.; Thus, any classes, functions, and data that will be used in Python need; to be exported.; This is the default behavior on Mac and Linux, but not on Windows.; On that platform, use ``__declspec(dllexport)`` to explicitly export the; classes and function you expect to call.; CMake has simple `support for exporting all`_ C++ symbols. In tandem with any dictionary, a pre-compiled module (.pcm) file will be; generated.; C++ modules are still on track for inclusion in the C++20 standard and most; modern C++ compilers, ``clang`` among them, already have implementations.; The benefits for cppyy include faster bindings generation, lower memory; footprint, and isolation from preproces",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst:1733,depend,dependency,1733,bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,2,['depend'],"['dependencies', 'dependency']"
Integrability,"o be parsed. This fixes issue #78864.; Add function TBuffer::AutoExpand to centralize the automatic buffer extension policy. This enable the ability to tweak it later (for example instead of always doubling the size, increasing by only at most 2Mb or take hints from the number of entries already; in a TBasket).; Migrate the class TFileMerger from the proofplayer library to ROOT I/O library and update hadd to rely on; TFileMerger for everything but the command line argument parsing.; Fix support for schema evolution from:; TParameter<Int_t>* MyInt; //-> version 1to; TParameter<Int_t> MyInt; // version 2. The TZIPFile compressed archive reader now supports the Zip64 format for; archives and file members greater than 2 and 4 GB, respectively. MakeProject. Add support for the case when the requested project/files in path that in not under the current directory; Generate the code/dictonary only for pair type that do not already have a dictionary. Object Merging; We introduced a new explicit interface for providing merging; capability. If a class has a method with the name and; signature:. Long64_t Merge(TCollection *input, TFileMergeInfo*);. it will be used by a TFileMerger (and thus by PROOF) to merge one or more; other objects into the current object. Merge should; return a negative value if the merging failed. If this method does not exist, the TFileMerger will use; a method with the name and signature:. Long64_t Merge(TCollection *input);. TClass now provides a quick access to these merging; function via TClass::GetMerge. The wrapper function; is automatically created by rootcint and can be installed; via TClass::SetMerge. The wrapper function should have; the signature/type ROOT::MergeFunc_t:. Long64_t (*)(void *thisobj, TCollection *input, TFileMergeInfo*);. We added the new Merge function to TTree and THStack.; We also added the new Merge function to TQCommand as the; existing TQCommand::Merge does not have the right; semantic (in part because TQCommand is a colle",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v530/index.html:2605,interface,interface,2605,io/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v530/index.html,2,['interface'],['interface']
Integrability,"o be usable over time and across LLVM; versions their interfaces should be stable.; The new multilib system will be considered experimental in LLVM 17, but in; LLVM 18 it will be stable. In particular this is important to which multilib; selection flags Clang generates from command line options. Once a flag is; generated by a released version of Clang it may be used in ``multilib.yaml``; files that exist independently of the LLVM release cycle, and therefore; ceasing to generate the flag would be a breaking change and should be; avoided. However, an exception is the normalization of ``-march``.; ``-march`` for Arm architectures contains a list of enabled and disabled; extensions and this list is likely to grow. Therefore ``-march`` flags are; unstable. Incomplete interface; --------------------. The new multilib system does multilib selection based on only a limited set of; command line options, and limits which flags can be used for multilib; selection. This is in order to avoid committing to too large an interface.; Later LLVM versions can add support for multilib selection from more command; line options as needed. Extensible; ----------. It is likely that the configuration format will need to evolve in future to; adapt to new requirements.; Using a format like YAML that supports key-value pairs helps here as it's; trivial to add new keys alongside existing ones. Backwards compatibility; -----------------------. New versions of Clang should be able to use configuration written for earlier; Clang versions.; To avoid behaving in a way that may be subtly incorrect, Clang should be able; to detect if the configuration is too new and emit an error. Forwards compatibility; ----------------------. As an author of a multilib configuration, it should be possible to design the; configuration in such a way that it is likely to work well with future Clang; versions. For example, if a future version of Clang is likely to add support; for newer versions of an architecture and ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:10434,interface,interface,10434,interpreter/llvm-project/clang/docs/Multilib.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst,1,['interface'],['interface']
Integrability,"o be; represented using a '``$noreg``' named register, although the former syntax; is preferred. .. _machine-operands:. Machine Operands; ----------------. There are eighteen different kinds of machine operands, and all of them can be; serialized. Immediate Operands; ^^^^^^^^^^^^^^^^^^. The immediate machine operands are untyped, 64-bit signed integers. The; example below shows an instance of the X86 ``MOV32ri`` instruction that has an; immediate machine operand ``-42``:. .. code-block:: text. $eax = MOV32ri -42. An immediate operand is also used to represent a subregister index when the; machine instruction has one of the following opcodes:. - ``EXTRACT_SUBREG``. - ``INSERT_SUBREG``. - ``REG_SEQUENCE``. - ``SUBREG_TO_REG``. In case this is true, the Machine Operand is printed according to the target. For example:. In AArch64RegisterInfo.td:. .. code-block:: text. def sub_32 : SubRegIndex<32>;. If the third operand is an immediate with the value ``15`` (target-dependent; value), based on the instruction's opcode and the operand's index the operand; will be printed as ``%subreg.sub_32``:. .. code-block:: text. %1:gpr64 = SUBREG_TO_REG 0, %0, %subreg.sub_32. For integers > 64bit, we use a special machine operand, ``MO_CImmediate``,; which stores the immediate in a ``ConstantInt`` using an ``APInt`` (LLVM's; arbitrary precision integers). .. TODO: Describe the FPIMM immediate operands. .. _register-operands:. Register Operands; ^^^^^^^^^^^^^^^^^. The :ref:`register <registers>` primitive is used to represent the register; machine operands. The register operands can also have optional; :ref:`register flags <register-flags>`,; :ref:`a subregister index <subregister-indices>`,; and a reference to the tied register operand.; The full syntax of a register operand is shown below:. .. code-block:: text. [<flags>] <register> [ :<subregister-idx-name> ] [ (tied-def <tied-op>) ]. This example shows an instance of the X86 ``XOR32rr`` instruction that has; 5 register operands with ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst:14427,depend,dependent,14427,interpreter/llvm-project/llvm/docs/MIRLangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst,1,['depend'],['dependent']
Integrability,"o copy. It returns nothing. .. code-block:: c++. static __externref_t tableSrc[0];; static __externref_t tableDst[0];. // Copy nelem elements from [src, src + nelem - 1] in tableSrc to; // [dst, dst + nelem - 1] in tableDst; void copy(int dst, int src, int nelem) {; __builtin_wasm_table_copy(tableDst, tableSrc, dst, src, nelem);; }. Builtin Functions; =================. Clang supports a number of builtin library functions with the same syntax as; GCC, including things like ``__builtin_nan``, ``__builtin_constant_p``,; ``__builtin_choose_expr``, ``__builtin_types_compatible_p``,; ``__builtin_assume_aligned``, ``__sync_fetch_and_add``, etc. In addition to; the GCC builtins, Clang supports a number of builtins that GCC does not, which; are listed here. Please note that Clang does not and will not support all of the GCC builtins; for vector operations. Instead of using builtins, you should use the functions; defined in target-specific header files like ``<xmmintrin.h>``, which define; portable wrappers for these. Many of the Clang versions of these functions are; implemented directly in terms of :ref:`extended vector support; <langext-vectors>` instead of builtins, in order to reduce the number of; builtins that we need to implement. ``__builtin_alloca``; --------------------. ``__builtin_alloca`` is used to dynamically allocate memory on the stack. Memory; is automatically freed upon function termination. **Syntax**:. .. code-block:: c++. __builtin_alloca(size_t n). **Example of Use**:. .. code-block:: c++. void init(float* data, size_t nbelems);; void process(float* data, size_t nbelems);; int foo(size_t n) {; auto mem = (float*)__builtin_alloca(n * sizeof(float));; init(mem, n);; process(mem, n);; /* mem is automatically freed at this point */; }. **Description**:. ``__builtin_alloca`` is meant to be used to allocate a dynamic amount of memory; on the stack. This amount is subject to stack allocation limits. Query for this feature with ``__has_builtin(__builtin_alloc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:96597,wrap,wrappers,96597,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['wrap'],['wrappers']
Integrability,"o do this can; only start such queries from itself. Using alias analysis results; ============================. There are several different ways to use alias analysis results. In order of; preference, these are:. Using the ``MemoryDependenceAnalysis`` Pass; -------------------------------------------. The ``memdep`` pass uses alias analysis to provide high-level dependence; information about memory-using instructions. This will tell you which store; feeds into a load, for example. It uses caching and other techniques to be; efficient, and is used by Dead Store Elimination, GVN, and memcpy optimizations. .. _AliasSetTracker:. Using the ``AliasSetTracker`` class; -----------------------------------. Many transformations need information about alias **sets** that are active in; some scope, rather than information about pairwise aliasing. The; `AliasSetTracker <https://llvm.org/doxygen/classllvm_1_1AliasSetTracker.html>`__; class is used to efficiently build these Alias Sets from the pairwise alias; analysis information provided by the ``AliasAnalysis`` interface. First you initialize the AliasSetTracker by using the ""``add``"" methods to add; information about various potentially aliasing instructions in the scope you are; interested in. Once all of the alias sets are completed, your pass should; simply iterate through the constructed alias sets, using the ``AliasSetTracker``; ``begin()``/``end()`` methods. The ``AliasSet``\s formed by the ``AliasSetTracker`` are guaranteed to be; disjoint, calculate mod/ref information and volatility for the set, and keep; track of whether or not all of the pointers in the set are Must aliases. The; AliasSetTracker also makes sure that sets are properly folded due to call; instructions, and can provide a list of pointers in each set. As an example user of this, the `Loop Invariant Code Motion; <doxygen/structLICM.html>`_ pass uses ``AliasSetTracker``\s to calculate alias; sets for each loop nest. If an ``AliasSet`` in a loop is not mod",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:20272,interface,interface,20272,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['interface'],['interface']
Integrability,"o new and existing reviews, uploaded with `arc` or the web interface. * Upload the first review and note its patch number, either with the web interface; or `arc`.; * For each commit after that, add the following line to the commit message or patch; summary: ""Depends on D<num>"", where ""<num>"" is the patch number of the previous review.; This must be entirely on its own line, with a blank line before it.; For example::. [llvm] Example commit. Depends on D12345. * If you want a single review to have multiple parent reviews then; add more with ""and"", for example: ""Depends on D12344 and D12345"".; * Upload the commit with the web interface or `arc`; (``arc diff --verbatim`` to update an existing review).; * You will see a ""Stack"" tab in the ""Revision Contents"" section of the review; in the web interface, showing the parent review.; * Repeat these steps until you've uploaded or updated all the patches in; your series. When you push the patches, please remove the ""Depends on"" lines from the; commit messages, since they add noise and duplicate git's implicit ordering. One frequently used workflow for creating a series of patches using patch summaries; is based on git's rebasing. These steps assume that you have a series of commits that; you have not posted for review, but can be adapted to update existing reviews. * git interactive rebase back to the first commit you want to upload for review::. git rebase -i HEAD~<number of commits you have written>. * Mark all commits for editing by changing ""pick"" to ""edit"" in the instructions; git shows.; * Start the rebase (usually by writing and closing the instructions).; * For the first commit:. - Upload the current commit for a review (with ``arc diff`` or the web; interface). - Continue to the next commit with ``git rebase --continue``. * For the rest:. - Add the ""Depends on..."" line using ``git commit --amend``. - Upload for review. - Continue the rebase. * Once the rebase is complete, you've created your patch series. .. _finding",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:7546,message,messages,7546,interpreter/llvm-project/llvm/docs/Phabricator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst,1,['message'],['messages']
Integrability,"o provides a ``createStringError`` function to simplify; common usage of this class:. .. code-block:: c++. // These two lines of code are equivalent:; make_error<StringError>(""Bad executable"", errc::executable_format_error);; createStringError(errc::executable_format_error, ""Bad executable"");. If you're certain that the error you're building will never need to be converted; to a ``std::error_code`` you can use the ``inconvertibleErrorCode()`` function:. .. code-block:: c++. createStringError(inconvertibleErrorCode(), ""Bad executable"");. This should be done only after careful consideration. If any attempt is made to; convert this error to a ``std::error_code`` it will trigger immediate program; termination. Unless you are certain that your errors will not need; interoperability you should look for an existing ``std::error_code`` that you; can convert to, and even (as painful as it is) consider introducing a new one as; a stopgap measure. ``createStringError`` can take ``printf`` style format specifiers to provide a; formatted message:. .. code-block:: c++. createStringError(errc::executable_format_error,; ""Bad executable: %s"", FileName);. Interoperability with std::error_code and ErrorOr; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Many existing LLVM APIs use ``std::error_code`` and its partner ``ErrorOr<T>``; (which plays the same role as ``Expected<T>``, but wraps a ``std::error_code``; rather than an ``Error``). The infectious nature of error types means that an; attempt to change one of these functions to return ``Error`` or ``Expected<T>``; instead often results in an avalanche of changes to callers, callers of callers,; and so on. (The first such attempt, returning an ``Error`` from; MachOObjectFile's constructor, was abandoned after the diff reached 3000 lines,; impacted half a dozen libraries, and was still growing). To solve this problem, the ``Error``/``std::error_code`` interoperability requirement was; introduced. Two pairs of functions allow any `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:28080,message,message,28080,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['message'],['message']
Integrability,"o setup.py install. 2020-09-21: 1.8.3; -----------------. * Add initializer constructors for PODs and aggregates; * Use actual underlying type for enums, where possible; * Enum values remain instances of their type; * Expose enum underlying type name as ``__underlying`` and ``__ctype__``; * Strictly follow C++ enum scoping rules; * Same enum in transparent scope refers to same type; * More detailed enum ``repr()`` printing, where possible; * Fix for (extern) explicit template instantiations in namespaces; * Throw objects from an std::tuple a life line; * Global pythonizors now always run on all classes; * Simplified iteraton over STL-like containers defining ``begin()``/``end()``. 2020-09-08: 1.8.2; -----------------. * Add ``cppyy.set_debug()`` to enable debug output for fixing template errors; * Cover more partial template instantiation use cases; * Force template instantiation if necessary for type deduction (i.e. ``auto``). 2020-09-01: 1.8.1; -----------------. * Setup build dependencies with pyproject.toml; * Simplified flow of pointer types for callbacks and cross-derivation; * Pointer-comparing objects performs auto-cast as needed; * Add main dimension for ptr-ptr to builtin returns; * Transparant handling of ptr-ptr to instance returns; * Stricter handling of bool type in overload with int types; * Fix uint64_t template instantiation regression; * Do not filter out enum data for ``__dir__``; * Fix lookup of interpreter-only explicit instantiations; * Fix inconsistent naming of std types with char_traits; * Further hiding of upstream code/dependencies; * Extended documentation. 2020-07-12: 1.8.0; -----------------. * Support mixing of Python and C++ types in global operators; * Capture Cling error messages from cppdef and include in the Python exception; * Add a cppexec method to evalutate statements in Cling's global scope; * Support initialization of ``std::array<>`` from sequences; * Support C++17 style initialization of common STL containers; * Allow base ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst:11147,depend,dependencies,11147,bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,1,['depend'],['dependencies']
Integrability,"o the currently active window. The; objects/widgets receive the events and react to them according to the; application functionality. ![](pictures/0200020B.jpg). The signals/slot communication mechanism is an advanced object; communication concept; it largely replaces the concept of callback; functions to handle actions in GUI's. Signals and slots are just like; any object-oriented methods implemented in C++. The objects are the; instances of classes that don't know anything about each other. They; interact and allow method calls of other object's methods. The idea is; simple: any object can send out (emit) a signal in certain situations; saying that something happened. This is all it does to communicate and; it does not know whether anything is interested in this information. On; the other side there might be an object waiting for that signal and; ready to react to it. This object disposes of special instruments to; listen to the sent out signals. To have a communication we need a; message transmission between the objects. In this simple example we use; signals and slots. The code of the method **`TGButton::Clicked()`** is:. ``` {.cpp}; virtual void Clicked() { Emit(""Clicked()""); } // *SIGNAL*; ```. I.e. any button emits the signal `Clicked()` any time someone clicks on; it. As you can see this method is virtual and could be overridden if you; need to. In our simple example we call the `Connect()` method to connect; the `Clicked()` signal of Draw button with `MyMainFrame::DoDraw():`. ``` {.cpp}; draw->Connect(""Clicked()"",""MyMainFrame"",this,""DoDraw()"");; ```. In the same way we can connect to the signal `Clicked()` of the Exit; button with the system call `gApplication->Terminate(0).` We declare a; new slot `DoExit(),` implement it to invoke the termination call and; associate this slot with the signal `Clicked()` of the Exit button. The code of `example.C` can be changed as follows:. ``` {.cpp}; public:; ...; void DoExit(); // a new slot is added; }; void MyMainFram",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:41522,message,message,41522,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['message'],['message']
Integrability,"o use genreflex, call MakeProject with the ""genreflex"" option, for example:. file->MakeProject(libdir,""*"",""NEW+genreflex"");. To make sure the library created by MakeProject does not double delete an object,; tell the StreamerElement representing one of the pointers pointing to the object; to never delete the object. For example:. TClass::AddRule(""HepMC::GenVertex m_event attributes=NotOwner"");. MakeProject now implements a move constructor for each classes. For the implementation, we 'use' the 'copy constructor' until the C++ compilers properly support the official move constructor notation. Implementing a move constructor avoid having to delete and reconstruct resource during a std::vector resize and avoid the double delete induced by using the default copy constructor. MakeProject now adds dictionaries for auto_ptr. MakeProject no longer request the dictionary for std::pair instances that already have been loaded. Misc. TFile::Open now does variable expansion so that you can include the protocol in the variable (for example: export H1=""http://root.cern/files/h1""; ...; TFile::Open(""$H1/dstarmb.root"");; Added warning if the file does contain any StreamerInfo objects and was written with a different version of ROOT.; Implemented polymorphism for Emulated object (still not supporting polymorphism of Emulated Object inheriting from compiled class). See the Core/Meta section for details.; Add support for streaming auto_ptr when generating their dictionary via rootcint; Enable the use of the I/O customization rules on data members that are either a variable size array or a fixed size array. For example:. #pragma read sourceClass = ""ACache"" targetClass = ""ACache"" version = ""[8]"" \; source = ""Int_t *fArray; Int_t fN;"" \; target = ""fArray"" \; code = ""{ fArray = new Char_t[onfile.fN]; Char_t* gtc=fArray; Int_t* gti=onfile.fArray; \; for(Int_t i=0; i<onfile.fN; i++) *(gtc+i) = *(gti+i)+10; }""; #pragma read sourceClass = ""ACache"" targetClass = ""ACache"" version = ""[8]"" \; source",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v528/index.html:9243,protocol,protocol,9243,io/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v528/index.html,2,['protocol'],['protocol']
Integrability,"o verify that compiled code behaves as; expected. On basic C test cases this is relatively straightforward. Mocks for; more complicated languages (e.g. C++) are much trickier: Any code involving; classes tends to have a lot of non-trivial surface area (e.g. vtables) that; would require great care to mock. Tips for JITLink backend developers; -----------------------------------. #. Make liberal use of assert and ``llvm::Error``. Do *not* assume that the input; object is well formed: Return any errors produced by libObject (or your own; object parsing code) and validate as you construct. Think carefully about the; distinction between contract (which should be validated with asserts and; llvm_unreachable) and environmental errors (which should generate; ``llvm::Error`` instances). #. Don't assume you're linking in-process. Use libSupport's sized,; endian-specific types when reading/writing content in the ``LinkGraph``. As a ""minimum viable"" JITLink wrapper, the ``llvm-jitlink`` tool is an; invaluable resource for developers bringing in a new JITLink backend. A standard; workflow is to start by throwing an unsupported object at the tool and seeing; what error is returned, then fixing that (you can often make a reasonable guess; at what should be done based on existing code for other formats or; architectures). In debug builds of LLVM, the ``-debug-only=jitlink`` option dumps logs from the; JITLink library during the link process. These can be useful for spotting some bugs at; a glance. The ``-debug-only=llvm_jitlink`` option dumps logs from the ``llvm-jitlink``; tool, which can be useful for debugging both testcases (it is often less verbose than; ``-debug-only=jitlink``) and the tool itself. The ``-oop-executor`` and ``-oop-executor-connect`` options are helpful for testing; handling of cross-process and cross-architecture use cases. Roadmap; =======. JITLink is under active development. Work so far has focused on the MachO; implementation. In LLVM 12 there is limited ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:43501,wrap,wrapper,43501,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['wrap'],['wrapper']
Integrability,"o we must use a smarter parser. In the case of; the boolean parser, it allows no options (in which case it assigns the value of; true to the variable), or it allows the values ""``true``"" or ""``false``"" to be; specified, allowing any of the following inputs:. ::. compiler -f # No value, 'Force' == true; compiler -f=true # Value specified, 'Force' == true; compiler -f=TRUE # Value specified, 'Force' == true; compiler -f=FALSE # Value specified, 'Force' == false. ... you get the idea. The `bool parser`_ just turns the string values into; boolean values, and rejects things like '``compiler -f=foo``'. Similarly, the; `float`_, `double`_, and `int`_ parsers work like you would expect, using the; '``strtol``' and '``strtod``' C library calls to parse the string value into the; specified data type. With the declarations above, ""``compiler -help``"" emits this:. ::. USAGE: compiler [options] <input file>. OPTIONS:; -f - Enable binary output on terminals; -o - Override output filename; -quiet - Don't print informational messages; -help - display available options (-help-hidden for more). and ""``compiler -help-hidden``"" prints this:. ::. USAGE: compiler [options] <input file>. OPTIONS:; -f - Enable binary output on terminals; -o - Override output filename; -q - Don't print informational messages; -quiet - Don't print informational messages; -help - display available options (-help-hidden for more). This brief example has shown you how to use the '`cl::opt`_' class to parse; simple scalar command line arguments. In addition to simple scalar arguments,; the CommandLine library also provides primitives to support CommandLine option; `aliases`_, and `lists`_ of options. .. _aliases:. Argument Aliases; ----------------. So far, the example works well, except for the fact that we need to check the; quiet condition like this now:. .. code-block:: c++. ...; if (!Quiet && !Quiet2) printInformationalMessage(...);; ... ... which is a real pain! Instead of defining two values for the same; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:11088,message,messages,11088,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['message'],['messages']
Integrability,"o whats happen for TProof::Open("""").; Several; improvements in the handling of wild cards in the dataset manager; for; example, issuing a GetDataSet(...) on a dataset URI containign wild; cards will return a grand dataset sum of all the datasets matching the; URI.; Add options to get a list of all dataset registered names; from ScanDataSets (option kList; the result is a TMap of {TObjString,; TObjString} with the second TObjString empty).Improved version of the PQ2 scripts; the scripts now invoke a dedicated ROOT application (named pq2) available under $ROOTSYS/bin .Add; support for recursive reading of group config files via the 'include; sub-file' directive. This allows to have a common part and, for; example, customize differently the quotas.Fix an issue with TTreeFriends. New tutorial showing how to use friends in PROOF.Package; management: add support for arguments in the SETUP function: it is; possible now to pass a string or a list of objects. The; TProof::EnablePackage interface has been extended to support this.Optimize; the validation step in the case not all the entries are required. The; validation step is stopped as soon as the requested number of events is; reached. If the parameter ""PROOF_ValidateByFile"" is set to 1, the; number of files is exactly what needed; otherwise the number of files; may exceed the number of files needed by (Number_Of_Workers - 1) .; New directive 'xpd.datadir' to better control the user data directories and their permission settings. In TPacketizerUnit, add the possibility to exactly share the number of cycles between the workers.; See the parameter PROOF_PacketizerFixedNum.Implement; a timer to terminate idle sessions. The timeout value is controlled by; the variable ProofServ.IdleTimeout (value in seconds). This variable; can be set for all sessions in the xproofd config file via the 'xpd.putrc' directive.; Add the possibility to control the use of sub-mergers with; the ROOTrc variable Proof.SubMergers. It has the same mean",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html:5826,interface,interface,5826,proof/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html,2,['interface'],['interface']
Integrability,"o"" where TMVA tries to determine the most suitable analysis; type from the targets and classes the user has defined. Other; values are ""regression"", ""classification"" and ""multiclass"" for; the forthcoming multiclass classification.; Missing regression evaluation plots for training sample were; added. On Cut method:. Removed obsolete option ""FVerySmart"" from Cuts method. On MLP method:; ; Display of convergence information in the progress bar for MLP during training. Creation of animated gifs for MLP convergence monitoring (please; contact authors if you want to do this). On Datasets: . Checks are performed if events are unvoluntarily cut by using a; non-filled array entry (e.g. ""arr[4]"" is used, when the array; has not always at least 5 entries). A warning is given in that; case.; Bug fixes. Spectators and Targets could not be used with by-hand assignment of events.; Corrected types (training/testing) for assigning single events.; Changed message from FATAL to WARNING when the user requests more events for ; training or testing than available.; Fixed bug which caused TMVA to crash if the number of input variables exceeded ; the allowed maximum for generating scatter plots.; Prevent TMVA from crashing when running with an empty TTree or TChain.; A variable expression like ""Alt$(arr[3],0)"" can now be used; to give a default value for a variable if for some events the; array don't contain enough elements (e.g. in two jet events,; sometimes only one jet is found and thus, the array jetPt[] has; only one entry in that cases).; Plot ranges for scatter-plots showing the transformed events are now correct.; User defined training/testing-trees are now handled correctly.; Fix bug in correlation computation for regression.; Consistent use of variable labels (for the log output) and variable titles (in histograms).; Drawing of variable labels in network architecture display for regression mode has been added.; Bug fixes to Cuts which improves performance on datasets with many va",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v526/index.html:3010,message,message,3010,tmva/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v526/index.html,2,['message'],['message']
Integrability,"o; quickly test clang on their projects. Flexible; --------. The driver was designed to be flexible and easily accommodate new uses; as we grow the clang and LLVM infrastructure. As one example, the driver; can easily support the introduction of tools which have an integrated; assembler; something we hope to add to LLVM in the future. Similarly, most of the driver functionality is kept in a library which; can be used to build other tools which want to implement or accept a gcc; like interface. Low Overhead; ------------. The driver should have as little overhead as possible. In practice, we; found that the gcc driver by itself incurred a small but meaningful; overhead when compiling many small files. The driver doesn't do much; work compared to a compilation, but we have tried to keep it as; efficient as possible by following a few simple principles:. - Avoid memory allocation and string copying when possible.; - Don't parse arguments more than once.; - Provide a few simple interfaces for efficiently searching arguments. Simple; ------. Finally, the driver was designed to be ""as simple as possible"", given; the other goals. Notably, trying to be completely compatible with the; gcc driver adds a significant amount of complexity. However, the design; of the driver attempts to mitigate this complexity by dividing the; process into a number of independent stages instead of a single; monolithic task. Internal Design and Implementation; ==================================. .. contents::; :local:; :depth: 1. Internals Introduction; ----------------------. In order to satisfy the stated goals, the driver was designed to; completely subsume the functionality of the gcc executable; that is, the; driver should not need to delegate to gcc to perform subtasks. On; Darwin, this implies that the Clang driver also subsumes the gcc; driver-driver, which is used to implement support for building universal; images (binaries and object files). This also implies that the driver; should be",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:2119,interface,interfaces,2119,interpreter/llvm-project/clang/docs/DriverInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst,1,['interface'],['interfaces']
Integrability,"oAbsArg have RooAbsReal as an; intermediate base class, which is the base class for all RooAbsArg that; represent real-valued nodes in the computation graph.; As such RooFit objects are so prevalent in practice, the names RooAbsArg and; RooAbsReal are used interchangeably in this guide. Users take these classes to build a computational graph that represents the; PDF (also called ""model"") that they want to use for fitting the data.; The user then passes his final PDF and a RooAbsData object to the; RooAbsPdf::fitTo() method, which implicitly creates a negative-log likelihood; (NLL) that RooFit minimizes for parameter estimation.; The NLL object, internally created by RooAbsPdf::createNLL(), is a RooAbsArg; itself.; In technical terms, it's another larger computation graph that encompasses the; computation graph representing the PDF. To enable source code transformation AD for RooFit NLLs with Clad, RooFit has a; routine that can traverse a computation graph made of RooAbsArg objects and; transform it to much simpler C++ code that mathematically represents the same; computation, but without any overhead that is hard to digest by the AD tool. On a high level, this *code generation* is implemented as follows:. 1. The computation graph is visited recursively by a; RooFit::Detail::CodeSquashContext object, via the virtual; RooAbsArg::translate() function that implements the translation of a; given RooFit class to minimal C++ code. This is an example of the visitor; pattern. 2. The generated code is processed by a RooFuncWrapper object, which takes care; of just-in-time compiling it with the ROOT interpreter, generating the; gradient code with Clad, and compiling that as well. 3. Since the RooFuncWrapper is implementing a RooAbsArg itself, it can now be; used as a drop-in replacement for the RooAbsArg that was the top node of the; original computation graph, with the added benefit that it can be queried for; the gradient. In summary, the important ingredient to enable AD i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:4112,rout,routine,4112,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['rout'],['routine']
Integrability,"oa.InstanceVariableInvalidation; (ObjC); Check that the invalidatable instance variables are invalidated in the methods; annotated with objc_instance_variable_invalidator. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interface SubclassInvalidationImpObj : InvalidationImpObj {; InvalidationImpObj *var;; }; - (void)invalidate;; @end. @implementation SubclassInvalidationImpObj; - (void) invalidate {}; @end; // warn: var needs to be invalidated or set to nil. alpha.osx.cocoa.MissingInvalidationMethod; (ObjC); Check that the invalidation methods are present in classes that contain; invalidatable instance variables. @protocol Invalidation <NSObject>; - (void)invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface NeedInvalidation : NSObject <Invalidation>; @end. @interface MissingInvalidationMethodDecl : NSObject {; NeedInvalidation *Var; // warn; }; @end. @implementation MissingInvalidationMethodDecl; @end. alpha.osx.cocoa.localizability.PluralMisuseChecker; (ObjC); Warns against using one vs. many plural pattern in code; when generating localized strings. NSString *reminderText =; NSLocalizedString(@""None"", @""Indicates no reminders"");; if (reminderCount == 1) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; NSLocalizedString(@""1 Reminder"", @""Indicates single reminder"");; } else if (reminderCount >= 2) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; [NSString stringWithFormat:; NSLocalizedString(@""%@ Reminders"", @""Indicates multiple reminders""),; reminderCount];; }. Security Alpha Checkers. Name, DescriptionExample. alpha.security.ArrayBound; (C); Warn about buffer overflows (older checker). void test() {; char *s = """";; char c = s[1]; // warn; }",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:8930,interface,interface,8930,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,2,['interface'],['interface']
Integrability,"oad i32, ptr %ptr ; yields i32:val = i32 3. .. _i_fence:. '``fence``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. fence [syncscope(""<target-scope>"")] <ordering> ; yields void. Overview:; """""""""""""""""". The '``fence``' instruction is used to introduce happens-before edges; between operations. Arguments:; """""""""""""""""""". '``fence``' instructions take an :ref:`ordering <ordering>` argument which; defines what *synchronizes-with* edges they add. They can only be given; ``acquire``, ``release``, ``acq_rel``, and ``seq_cst`` orderings. Semantics:; """""""""""""""""""". A fence A which has (at least) ``release`` ordering semantics; *synchronizes with* a fence B with (at least) ``acquire`` ordering; semantics if and only if there exist atomic operations X and Y, both; operating on some atomic object M, such that A is sequenced before X, X; modifies M (either directly or through some side effect of a sequence; headed by X), Y is sequenced before B, and Y observes M. This provides a; *happens-before* dependency between A and B. Rather than an explicit; ``fence``, one (but not both) of the atomic operations X or Y might; provide a ``release`` or ``acquire`` (resp.) ordering constraint and; still *synchronize-with* the explicit ``fence`` and establish the; *happens-before* edge. A ``fence`` which has ``seq_cst`` ordering, in addition to having both; ``acquire`` and ``release`` semantics specified above, participates in; the global program order of other ``seq_cst`` operations and/or; fences. Furthermore, the global ordering created by a ``seq_cst``; fence must be compatible with the individual total orders of; ``monotonic`` (or stronger) memory accesses occurring before and after; such a fence. The exact semantics of this interaction are somewhat; complicated, see the C++ standard's `[atomics.order]; <https://wg21.link/atomics.order>`_ section for more details. A ``fence`` instruction can also take an optional; "":ref:`syncscope <syncscope>`"" argument. Example:; """""""""""""""". .. code-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:424373,depend,dependency,424373,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['dependency']
Integrability,"oading dictionaries is fine if this is hidden under the hood of; a Python package and thus transparently done on ``import``.; Otherwise, the automatic class loader is more convenient, as it allows direct; use without having to manually find and load dictionaries (assuming these are; locatable by the dynamic loader). The class loader utilizes so-called rootmap files, which by convention should; live alongside the dictionary shared library (and C++ module file).; These are simple text files, which map C++ entities (such as classes) to the; dictionaries and other libraries that need to be loaded for their use. With ``genreflex``, the mapping file can be automatically created with; ``--rootmap-lib=MyClassDict``, where ""MyClassDict"" is the name of the shared; library (without the extension) build from the dictionary file.; With ``rootcling``, create the same mapping file with; ``-rmf MyClassDict.rootmap -rml MyClassDict``.; It is necessary to provide the final library name explicitly, since it is; only in the separate linking step where these names are fixed and those names; may not match the default choice. With the mapping file in place, the above example can be rerun without; explicit loading of the dictionary:. .. code-block:: python. >>> import cppyy; >>> from cppyy.gbl import MyClass; >>> MyClass(42).get_int(); 42; >>>. .. _cppyy-generator:. Bindings collection; -------------------. ``cppyy-generator`` is a clang-based utility program which takes a set of C++; header files and generates a JSON output file describing the objects found in; them.; This output is intended to support more convenient access to a set of; cppyy-supported bindings::. $ cppyy-generator --help; usage: cppyy-generator [-h] [-v] [--flags FLAGS] [--libclang LIBCLANG]; output sources [sources ...]; ... This utility is mainly used as part of the; :doc:`CMake interface <cmake_interface>`. .. _`support for exporting all`: https://cmake.org/cmake/help/latest/prop_tgt/WINDOWS_EXPORT_ALL_SYMBOLS.html; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst:10052,interface,interface,10052,bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,1,['interface'],['interface']
Integrability,"oads/sites/11/2018/01/Intel-Analysis-of-Speculative-Execution-Side-Channels.pdf).; On AMD systems `lfence` is currently a no-op, but can be made; dispatch-serializing by setting an MSR, and thus preclude misspeculation of the; code path ([mitigation G-2 +; V1-1](https://developer.amd.com/wp-content/resources/Managing-Speculation-on-AMD-Processors.pdf)). However, this relies on finding and enumerating all possible points in code; which could be attacked to leak information. While in some cases static; analysis is effective at doing this at scale, in many cases it still relies on; human judgement to evaluate whether code might be vulnerable. Especially for; software systems which receive less detailed scrutiny but remain sensitive to; these attacks, this seems like an impractical security model. We need an; automatic and systematic mitigation strategy. ### Automatic `lfence` on Conditional Edges. A natural way to scale up the existing hand-coded mitigations is simply to; inject an `lfence` instruction into both the target and fallthrough; destinations of every conditional branch. This ensures that no predicate or; bounds check can be bypassed speculatively. However, the performance overhead; of this approach is, simply put, catastrophic. Yet it remains the only truly; ""secure by default"" approach known prior to this effort and serves as the; baseline for performance. One attempt to address the performance overhead of this and make it more; realistic to deploy is [MSVC's /Qspectre; switch](https://blogs.msdn.microsoft.com/vcblog/2018/01/15/spectre-mitigations-in-msvc/).; Their technique is to use static analysis within the compiler to only insert; `lfence` instructions into conditional edges at risk of attack. However,; [initial](https://arstechnica.com/gadgets/2018/02/microsofts-compiler-level-spectre-fix-shows-how-hard-this-problem-will-be-to-solve/); [analysis](https://www.paulkocher.com/doc/MicrosoftCompilerSpectreMitigation.html); has shown that this approach is in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:45181,inject,inject,45181,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['inject'],['inject']
Integrability,"objc. @interface A; + (instancetype)constructAnA;; @end. The related result type can also be inferred for some methods. To determine; whether a method has an inferred related result type, the first word in the; camel-case selector (e.g., ""``init``"" in ""``initWithObjects``"") is considered,; and the method will have a related result type if its return type is compatible; with the type of its class and if:. * the first word is ""``alloc``"" or ""``new``"", and the method is a class method,; or. * the first word is ""``autorelease``"", ""``init``"", ""``retain``"", or ""``self``"",; and the method is an instance method. If a method with a related result type is overridden by a subclass method, the; subclass method must also return a type that is compatible with the subclass; type. For example:. .. code-block:: objc. @interface NSString : NSObject; - (NSUnrelated *)init; // incorrect usage: NSUnrelated is not NSString or a superclass of NSString; @end. Related result types only affect the type of a message send or property access; via the given method. In all other respects, a method with a related result; type is treated the same way as method that returns ``id``. Use ``__has_feature(objc_instancetype)`` to determine whether the; ``instancetype`` contextual keyword is available. Automatic reference counting; ----------------------------. Clang provides support for :doc:`automated reference counting; <AutomaticReferenceCounting>` in Objective-C, which eliminates the need; for manual ``retain``/``release``/``autorelease`` message sends. There are three; feature macros associated with automatic reference counting:; ``__has_feature(objc_arc)`` indicates the availability of automated reference; counting in general, while ``__has_feature(objc_arc_weak)`` indicates that; automated reference counting also includes support for ``__weak`` pointers to; Objective-C objects. ``__has_feature(objc_arc_fields)`` indicates that C structs; are allowed to have fields that are pointers to Objective-C ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:70441,message,message,70441,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['message'],['message']
Integrability,"oblems (especially for C++), and perhaps an assistant mode to help write module maps for you. Where To Learn More About Modules; =================================; The Clang source code provides additional information about modules:. ``clang/lib/Headers/module.modulemap``; Module map for Clang's compiler-specific header files. ``clang/test/Modules/``; Tests specifically related to modules functionality. ``clang/include/clang/Basic/Module.h``; The ``Module`` class in this header describes a module, and is used throughout the compiler to implement modules. ``clang/include/clang/Lex/ModuleMap.h``; The ``ModuleMap`` class in this header describes the full module map, consisting of all of the module map files that have been parsed, and providing facilities for looking up module maps and mapping between modules and headers (in both directions). PCHInternals_; Information about the serialized AST format used for precompiled headers and modules. The actual implementation is in the ``clangSerialization`` library. .. [#] Automatic linking against the libraries of modules requires specific linker support, which is not widely available. .. [#] There are certain anti-patterns that occur in headers, particularly system headers, that cause problems for modules. The section `Modularizing a Platform`_ describes some of them. .. [#] The second instance is actually a new thread within the current process, not a separate process. However, the original compiler instance is blocked on the execution of this thread. .. [#] The preprocessing context in which the modules are parsed is actually dependent on the command-line options provided to the compiler, including the language dialect and any ``-D`` options. However, the compiled modules for different command-line options are kept distinct, and any preprocessor directives that occur within the translation unit are ignored. See the section on the `Configuration macros declaration`_ for more information. .. _PCHInternals: PCHInternals.html; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:58569,depend,dependent,58569,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['depend'],['dependent']
Integrability,"ocal; approximation when it is otherwise enabled for the translation unit; with the ``-freciprocal-math`` flag or other fast-math options. The; pragma can take two values: ``on`` and ``off``. .. code-block:: c++. float f(float x, float y); {; // Enable floating point reciprocal approximation; #pragma clang fp reciprocal(on); return x / y;; }. ``#pragma clang fp contract`` specifies whether the compiler should; contract a multiply and an addition (or subtraction) into a fused FMA; operation when supported by the target. The pragma can take three values: ``on``, ``fast`` and ``off``. The ``on``; option is identical to using ``#pragma STDC FP_CONTRACT(ON)`` and it allows; fusion as specified the language standard. The ``fast`` option allows fusion; in cases when the language standard does not make this possible (e.g. across; statements in C). .. code-block:: c++. for(...) {; #pragma clang fp contract(fast); a = b[i] * c[i];; d[i] += a;; }. The pragma can also be used with ``off`` which turns FP contraction off for a; section of the code. This can be useful when fast contraction is otherwise; enabled for the translation unit with the ``-ffp-contract=fast-honor-pragmas`` flag.; Note that ``-ffp-contract=fast`` will override pragmas to fuse multiply and; addition across statements regardless of any controlling pragmas. ``#pragma clang fp exceptions`` specifies floating point exception behavior. It; may take one of the values: ``ignore``, ``maytrap`` or ``strict``. Meaning of; these values is same as for `constrained floating point intrinsics <http://llvm.org/docs/LangRef.html#constrained-floating-point-intrinsics>`_. .. code-block:: c++. {; // Preserve floating point exceptions; #pragma clang fp exceptions(strict); z = x + y;; if (fetestexcept(FE_OVERFLOW)); ...; }. A ``#pragma clang fp`` pragma may contain any number of options:. .. code-block:: c++. void func(float *dest, float a, float b) {; #pragma clang fp exceptions(maytrap) contract(fast) reassociate(on); ...; }. `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:171959,contract,contraction,171959,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['contract'],['contraction']
Integrability,"ock content into allocated working memory (following the; target layout) and applies fixups. Graph blocks are updated to point at; the fixed up content. #. Run post-fixup passes. These passes are called on the graph after fixups have been applied and; blocks updated to point to the fixed up content. Post-fixup passes can inspect blocks contents to see the exact bytes that; will be copied to the assigned target addresses. #. Finalize memory asynchronously. Calls the ``JITLinkMemoryManager`` to copy working memory to the executor; process and apply the requested permissions. #. Phase 3. #. Notify the context that the graph has been emitted. Calls ``JITLinkContext::notifyFinalized`` and hands off the; ``JITLinkMemoryManager::FinalizedAlloc`` object for this graph's memory; allocation. This allows the context to track/hold memory allocations and; react to the newly emitted definitions. In ORC this is used to update the; ``ExecutionSession`` instance's dependence graph, which may result in; these symbols (and possibly others) becoming *Ready* if all of their; dependencies have also been emitted. .. _passes:. Passes; ------. JITLink passes are ``std::function<Error(LinkGraph&)>`` instances. They are free; to inspect and modify the given ``LinkGraph`` subject to the constraints of; whatever phase they are running in (see :ref:`generic_link_algorithm`). If a; pass returns ``Error::success()`` then linking continues. If a pass returns; a failure value then linking is stopped and the ``JITLinkContext`` is notified; that the link failed. Passes may be used by both JITLink backends (e.g. MachO/x86-64 implements GOT; and PLT construction as a pass), and external clients like; ``ObjectLinkingLayer::Plugin``. In combination with the open ``LinkGraph`` API, JITLink passes enable the; implementation of powerful new features. For example:. * Relaxation optimizations -- A pre-fixup pass can inspect GOT accesses and PLT; calls and identify situations where the addresses of the entry tar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:22625,depend,dependence,22625,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,2,['depend'],"['dependence', 'dependencies']"
Integrability,"ocoa.MissingSuperCall (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C methods that lack a necessary call to super. .. code-block:: objc. @interface Test : UIViewController; @end; @implementation test; - (void)viewDidLoad {} // warn; @end. .. _osx-cocoa-NSAutoreleasePool:. osx.cocoa.NSAutoreleasePool (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn for suboptimal uses of NSAutoreleasePool in Objective-C GC mode. .. code-block:: objc. void test() {; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; [pool release]; // warn; }. .. _osx-cocoa-NSError:. osx.cocoa.NSError (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""; Check usage of NSError parameters. .. code-block:: objc. @interface A : NSObject; - (void)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error;; @end. @implementation A; - (void)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error {; // warn: method accepting NSError"""""""""""""""""""""""""""""""""""""""""""""""" should have a non-void; // return value; }; @end. @interface A : NSObject; - (BOOL)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error;; @end. @implementation A; - (BOOL)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error {; *error = 0; // warn: potential null dereference; return 0;; }; @end. .. _osx-cocoa-NilArg:. osx.cocoa.NilArg (ObjC); """"""""""""""""""""""""""""""""""""""""""""""; Check for prohibited nil arguments to ObjC method calls. - caseInsensitiveCompare:; - compare:; - compare:options:; - compare:options:range:; - compare:options:range:locale:; - componentsSeparatedByCharactersInSet:; - initWithFormat:. .. code-block:: objc. NSComparisonResult test(NSString *s) {; NSString *aString = nil;; return [s caseInsensitiveCompare:aString];; // warn: argument to 'NSString' method; // 'caseInsensitiveCompare:' cannot be nil; }. .. _osx-cocoa-NonNilReturnValue:. osx.cocoa.NonNilReturnValue; """"""""""""""""""""""""""""""""""""""""""""""""""""""; Models the APIs that are guaranteed to return a non-nil value. .. _osx-cocoa-ObjCGenerics:. osx.cocoa.ObjCGenerics (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for type errors when using Objectiv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:38610,interface,interface,38610,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['interface'],['interface']
Integrability,"od also assumes that the uncertainty on the; parameters can modeled by a multi-variate Gaussian distribution. A complete example is provided in a new tutorial macro rf610_visualerror.C,; the output of which is shown below. It is also possible to visualize partial errors (from a subset of the parameters),; as shown above. Binned dataset generation. A new method RooAbsPdf::generateBinned() has been implemented; that samples binned datasets (RooDataHist) from any; p.d.f. RooDataHist* data = pdf.generateBinned(x,10000) ;. This binned generation interface samples the p.d.f. at each bin; center and applies a Poisson fluctuation to each sampled value.; The binning of the returned RooDataHist is controlled by the default; binning associated with the observables generated. To set the number; of bins in x to 200, do e.g. x.setBins(200) prior to the call; to generateBinned(). The binned dataset generation method does not (yet) support the concept of; prototype datasets. New minimizer interface to Minuit2, GSLMinimizer etc... A new minimizer interface, RooMinimizer has been added (contribution; from Alfio Lazarro). The new minimizer is similar in functionality to; the existing class RooMinuit, but supports the new ROOT abstract; minimizer interface and supports multiple minimizer packages and algorithms; through that interface. The present interface of RooMinimizer is identical to that of RooMinuit; with two extensions. The setMinimizer(const char*) method allows to choose between ""minuit"" and ""minuit2""); as implementation for migrad(),hesse(),minos() etc...; The minimizer(const char* package, const char* alg) provides a completely generic interface; to all minimizers, where package is the package (minuit,GSLminimizer) and alg is the algorithm (migrad) to be used. By default, RooMinuit is still used when RooAbsPdf::fitTo() is called, but can be overridden with; a Minimizer() named argument. // Minimization with MINUIT/MIGRAD through RooMinuit; pdf->fitTo(data) ;. // Minimizatio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:3043,interface,interface,3043,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,2,['interface'],['interface']
Integrability,"od part is: it will not send mail to; llvm-commit mailing list, patch reviewers, and all other subscribers, buildbot; will also run on every patch update:. ::. arc diff --draft HEAD~. If you later update your commit message, you need to add the `--verbatim`; option to have `arc` update the description on Phabricator:. ::. arc diff --edit --verbatim. .. _phabricator-request-review-web:. Requesting a review via the web interface; -----------------------------------------. The tool to create and review patches in Phabricator is called; *Differential*. Note that you can upload patches created through git, but using `arc` on the; command line (see previous section) is preferred: it adds more metadata to; Phabricator which are useful for the pre-merge testing system and for; propagating attribution on commits when someone else has to push it for you. To make reviews easier, please always include **as much context as; possible** with your diff! Don't worry, Phabricator; will automatically send a diff with a smaller context in the review; email, but having the full file in the web interface will help the; reviewer understand your code. To get a full diff, use one of the following commands (or just use Arcanist; to upload your patch):. * ``git show HEAD -U999999 > mypatch.patch``; * ``git diff -U999999 @{u} > mypatch.patch``; * ``git diff HEAD~1 -U999999 > mypatch.patch``. Before uploading your patch, please make sure it is formatted properly, as; described in :ref:`How to Submit a Patch <format patches>`. To upload a new patch:. * Click *Differential*.; * Click *+ Create Diff*.; * Paste the text diff or browse to the patch file. Leave this first Repository; field blank. (We'll fill in the Repository later, when sending the review.); Click *Create Diff*.; * Leave the drop down on *Create a new Revision...* and click *Continue*.; * Enter a descriptive title and summary. The title and summary are usually; in the form of a :ref:`commit message <commit messages>`.; * Add reviewer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:3163,interface,interface,3163,interpreter/llvm-project/llvm/docs/Phabricator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst,1,['interface'],['interface']
Integrability,od.C - Simple uncorrelated multi-dimensional p.d.f.s; rf305_condcorrprod.C - Multi-dimensional p.d.f.s with conditional p.d.fs in product; rf306_condpereventerrors.C - Complete example with use of conditional p.d.f. with per-event errors; rf307_fullpereventerrors.C -Complete example with use of full p.d.f. with per-event errors; rf308_normintegration2d.C - Examples on normalization of p.d.f.s in more than one dimension; rf309_ndimplot.C - Making 2 and 3 dimensional plots of p.d.f.s and datasets; rf310_sliceplot.C -Projecting p.d.f and data slices in discrete observables; rf311_rangeplot.C -Projecting p.d.f and data ranges in continuous observables; rf312_multirangefit.C - Performing fits in multiple (disjoint) ranges in one or more dimensions; rf313_paramranges.C - Working with parameterized ranges to define non-rectangular regions; rf314_paramfitrange.C - Working with parameterized ranges in a fit.; rf315_projectpdf.C - Marginizalization of multi-dimensional p.d.f.s through integration; rf316_llratioplot.C - Using the likelihood ratio technique to construct a signal enhanced 1-D projection of a multi-dimensional p.d.f.; ; DATA AND CATEGORIES. rf401_importttreethx.C -Overview of advanced option for importing data from ROOT TTree and THx histograms; rf402_datahandling.C - Tools for manipulation of (un)binned datasets; rf403_weightedevts.C - Using weights in unbinned datasets; rf404_categories.C - Working with RooCategory objects to describe discrete variables; rf405_realtocatfuncs.C - Demonstration of real-->discrete mapping functions; rf406_cattocatfuncs.C - Demonstration of discrete-->discrete (invertable) functions; rf407_latextables.C - Latex printing of lists and sets of RooArgSets; ; ORGANIZATION AND SIMULTANEOUS FITS. rf501_simultaneouspdf.C - Using simultaneous p.d.f.s to describe simultaneous fits to multiple datasets; rf502_wspacewrite.C - Creating and writing a workspace; rf503_wspaceread.C - Reading and using a workspace; rf504_simwstool.C - Using RooSimWS,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html:3393,integrat,integration,3393,roofit/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html,2,['integrat'],['integration']
Integrability,"ode when using them. ## The Signals of ROOT. The list of default signals handled by ROOT is:. ``` {.cpp}; kSigChildkSigPipe; kSigBuskSigAlarm; kSigSegmentationViolationkSigUrgent; kSigIllegalInstructionkSigFloatingException; kSigSystemkSigWindowChanged; ```. The signals ***`kSigFloatingException`***,; ***`kSigSegmentationViolation`***, ***`kSigIllegalInstruction`***, and; ***`kSigBus`*** cause the printing of the ***`*** Break *** `*** message; and make a long jump back to the ROOT prompt. No other custom; **`TSignalHandler`** can be added to these signals. The ***`kSigAlarm`*** signal handles asynchronous timers. The; ***`kSigWindowChanged`*** signal handles the resizing of the terminal; window. The other signals have no other behavior then that to call any; registered **`TSignalHandler`*****`::Notify()`***. When building in interactive application the use of the **`TRint`**; object handles the `kSigInterrupt` signal. It causes the printing of the; message: ***`*** Break *** keyboard interrupt `***and makes a long jump; back to the ROOT command prompt. If no **`TRint`** object is created,; there will be no `kSigInterrupt` handling. All signals can be reset to; their default UNIX behavior via the call of; **`TSytem`**`::ResetSignal()`. All signals can be ignored via; `TSytem::IgnoreSignal()`. The **`TSytem::IgnoreInterrupt()`** is a method; to toggle the handling of the interrupt signal. Typically it is called; to prevent a `SIGINT` to interrupt some important call (like writing to; a ROOT file). If **`TRint`** is used and the default ROOT interrupt handler is not; desired, you should use `GetSignalHandler()` of **`TApplication`** to; get the interrupt handler and to remove it by `RemoveSignalHandler()`of; **`TSystem`** . ## Glossary. The following glossary is adapted from the description of the Rogue Wave; `Threads.h`++ package. A **`process`** is a program that is loaded into memory and prepared for; execution. Each process has a private address space. Processes be",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:18743,message,message,18743,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['message'],['message']
Integrability,"odeAs<VarDecl>(""incVarName"");; const VarDecl *CondVar = Result.Nodes.getNodeAs<VarDecl>(""condVarName"");; const VarDecl *InitVar = Result.Nodes.getNodeAs<VarDecl>(""initVarName"");. if (!areSameVariable(IncVar, CondVar) || !areSameVariable(IncVar, InitVar)); return;; llvm::outs() << ""Potential array-based loop discovered.\n"";; }. Clang associates a ``VarDecl`` with each variable to represent the variable's; declaration. Since the ""canonical"" form of each declaration is unique by; address, all we need to do is make sure neither ``ValueDecl`` (base class of; ``VarDecl``) is ``NULL`` and compare the canonical Decls. .. code-block:: c++. static bool areSameVariable(const ValueDecl *First, const ValueDecl *Second) {; return First && Second &&; First->getCanonicalDecl() == Second->getCanonicalDecl();; }. If execution reaches the end of ``LoopPrinter::run()``, we know that the; loop shell looks like. .. code-block:: c++. for (int i= 0; i < expr(); ++i) { ... }. For now, we will just print a message explaining that we found a loop.; The next section will deal with recursively traversing the AST to; discover all changes needed. As a side note, it's not as trivial to test if two expressions are the same,; though Clang has already done the hard work for us by providing a way to; canonicalize expressions:. .. code-block:: c++. static bool areSameExpr(ASTContext *Context, const Expr *First,; const Expr *Second) {; if (!First || !Second); return false;; llvm::FoldingSetNodeID FirstID, SecondID;; First->Profile(FirstID, *Context, true);; Second->Profile(SecondID, *Context, true);; return FirstID == SecondID;; }. This code relies on the comparison between two; ``llvm::FoldingSetNodeIDs``. As the documentation for; ``Stmt::Profile()`` indicates, the ``Profile()`` member function builds; a description of a node in the AST, based on its properties, along with; those of its children. ``FoldingSetNodeID`` then serves as a hash we can; use to compare expressions. We will need ``areSameExpr``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:18562,message,message,18562,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,1,['message'],['message']
Integrability,"ods out of the family based on the exact relationship; between the return type and the declaring class would be much too subtle; and fragile. Therefore we identify a small number of legitimate-seeming; return types and call everything else an error. This serves the secondary; purpose of encouraging programmers not to accidentally give methods names; in the ``init`` family. Note that a method with an ``init``-family selector which returns a; non-Objective-C type (e.g. ``void``) is perfectly well-formed; it simply; isn't in the ``init`` family. A program is ill-formed if a method's declarations, implementations, and; overrides do not all have the same method family. .. _arc.family.attribute:. Explicit method family control; ------------------------------. A method may be annotated with the ``objc_method_family`` attribute to; precisely control which method family it belongs to. If a method in an; ``@implementation`` does not have this attribute, but there is a method; declared in the corresponding ``@interface`` that does, then the attribute is; copied to the declaration in the ``@implementation``. The attribute is; available outside of ARC, and may be tested for with the preprocessor query; ``__has_attribute(objc_method_family)``. The attribute is spelled; ``__attribute__((objc_method_family(`` *family* ``)))``. If *family* is; ``none``, the method has no family, even if it would otherwise be considered to; have one based on its selector and type. Otherwise, *family* must be one of; ``alloc``, ``copy``, ``init``, ``mutableCopy``, or ``new``, in which case the; method is considered to belong to the corresponding family regardless of its; selector. It is an error if a method that is explicitly added to a family in; this way does not meet the requirements of the family other than the selector; naming convention. .. admonition:: Rationale. The rules codified in this document describe the standard conventions of; Objective-C. However, as these conventions have not heretofo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:70361,interface,interface,70361,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['interface'],['interface']
Integrability,"odule Header:; .. _Local/Private Headers:. #. Main Module Header; #. Local/Private Headers; #. LLVM project/subproject headers (``clang/...``, ``lldb/...``, ``llvm/...``, etc); #. System ``#include``\s. and each category should be sorted lexicographically by the full path. The `Main Module Header`_ file applies to ``.cpp`` files which implement an; interface defined by a ``.h`` file. This ``#include`` should always be included; **first** regardless of where it lives on the file system. By including a; header file first in the ``.cpp`` files that implement the interfaces, we ensure; that the header does not have any hidden dependencies which are not explicitly; ``#include``\d in the header, but should be. It is also a form of documentation; in the ``.cpp`` file to indicate where the interfaces it implements are defined. LLVM project and subproject headers should be grouped from most specific to least; specific, for the same reasons described above. For example, LLDB depends on; both clang and LLVM, and clang depends on LLVM. So an LLDB source file should; include ``lldb`` headers first, followed by ``clang`` headers, followed by; ``llvm`` headers, to reduce the possibility (for example) of an LLDB header; accidentally picking up a missing include due to the previous inclusion of that; header in the main source file or some earlier header file. clang should; similarly include its own headers before including llvm headers. This rule; applies to all LLVM subprojects. .. _fit into 80 columns:. Source Code Width; ^^^^^^^^^^^^^^^^^. Write your code to fit within 80 columns. There must be some limit to the width of the code in; order to allow developers to have multiple files side-by-side in; windows on a modest display. If you are going to pick a width limit, it is; somewhat arbitrary but you might as well pick something standard. Going with 90; columns (for example) instead of 80 columns wouldn't add any significant value; and would be detrimental to printing out code. Al",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:16980,depend,depends,16980,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,2,['depend'],['depends']
Integrability,"oes something important.; void example() { ... }. Preferred:. .. code-block:: c++. // Example.h:. /// Does something important.; void example();. // Example.cpp:. /// Builds a B-tree in order to do foo. See paper by...; void example() { ... }. Error and Warning Messages; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Clear diagnostic messages are important to help users identify and fix issues in; their inputs. Use succinct but correct English prose that gives the user the; context needed to understand what went wrong. Also, to match error message; styles commonly produced by other tools, start the first sentence with a; lower-case letter, and finish the last sentence without a period, if it would; end in one otherwise. Sentences which end with different punctuation, such as; ""did you forget ';'?"", should still do so. For example this is a good error message:. .. code-block:: none. error: file.o: section header 3 is corrupt. Size is 10 when it should be 20. This is a bad message, since it does not provide useful information and uses the; wrong style:. .. code-block:: none. error: file.o: Corrupt section header. As with other coding standards, individual projects, such as the Clang Static; Analyzer, may have preexisting styles that do not conform to this. If a; different formatting scheme is used consistently throughout the project, use; that style instead. Otherwise, this standard applies to all LLVM tools,; including clang, clang-tidy, and so on. If the tool or project does not have existing functions to emit warnings or; errors, use the error and warning handlers provided in ``Support/WithColor.h``; to ensure they are printed in the appropriate style, rather than printing to; stderr directly. When using ``report_fatal_error``, follow the same standards for the message as; regular error messages. Assertion messages and ``llvm_unreachable`` calls do not; necessarily need to follow these same styles as they are automatically; formatted, and thus these guidelines may not be suitable. ``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:14690,message,message,14690,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['message'],['message']
Integrability,"of GC modes. It now; means the ARC-style qualifier in all non-GC modes and is no longer; allowed if not enabled by either ``-fobjc-arc`` or ``-fobjc-weak``.; It is expected that ``-fobjc-weak`` will eventually be enabled by default; in all non-GC Objective-C modes. .. _objc-fixed-enum:. Enumerations with a fixed underlying type; -----------------------------------------. Clang provides support for C++11 enumerations with a fixed underlying type; within Objective-C. For example, one can write an enumeration type as:. .. code-block:: c++. typedef enum : unsigned char { Red, Green, Blue } Color;. This specifies that the underlying type, which is used to store the enumeration; value, is ``unsigned char``. Use ``__has_feature(objc_fixed_enum)`` to determine whether support for fixed; underlying types is available in Objective-C. Interoperability with C++11 lambdas; -----------------------------------. Clang provides interoperability between C++11 lambdas and blocks-based APIs, by; permitting a lambda to be implicitly converted to a block pointer with the; corresponding signature. For example, consider an API such as ``NSArray``'s; array-sorting method:. .. code-block:: objc. - (NSArray *)sortedArrayUsingComparator:(NSComparator)cmptr;. ``NSComparator`` is simply a typedef for the block pointer ``NSComparisonResult; (^)(id, id)``, and parameters of this type are generally provided with block; literals as arguments. However, one can also use a C++11 lambda so long as it; provides the same signature (in this case, accepting two parameters of type; ``id`` and returning an ``NSComparisonResult``):. .. code-block:: objc. NSArray *array = @[@""string 1"", @""string 21"", @""string 12"", @""String 11"",; @""String 02""];; const NSStringCompareOptions comparisonOptions; = NSCaseInsensitiveSearch | NSNumericSearch |; NSWidthInsensitiveSearch | NSForcedOrderingSearch;; NSLocale *currentLocale = [NSLocale currentLocale];; NSArray *sorted; = [array sortedArrayUsingComparator:[=](id s1, id s2) ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:74422,interoperab,interoperability,74422,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['interoperab'],['interoperability']
Integrability,"of Modules; Modules are listed ontop of the Class Index and as part; of the Library Dependencies Chart. Modules' Library Dependencies; Each module is assumed to be part of a library. The dependencies of libraries are; not only relevant for linking, but often reflect also the contextual dependencies.; The dependencies of all modules are shown in the; Library Dependencies Chart. Class Reference; Pages like the one for TH2 are; class references. They document the use and functionality of a class. Sections; Each class reference page has a class documentation, which documents what the class; can be used for, and gives hints on how to use it. This allows you to figure out; whether a certain class is appropriate for what you try to do. The page then lists; all available members; they define a class's functionality and its interaction with; your code. The next item is a tabbed set of charts, which allow you to study the; class's inheritance diagram, what members get inherited from where, and which members; are re-implemented, which files get indirectly included by including the class's; header, and which libraries this class depends on. The remainder of the page contains; the functions' documentation. And there is a little tool box floating around, which; gives you some display options and a link to this help page. We will now go through all these parts in detail. Link Box; On the top of the page you can find a list of links. The first line contains the current; ""location"", giving the home page, the module name, and the class name.; The second line links to generic pages, like ROOT's home page, the; Class Index, and the Class Hierarchy.; The last line allows you to jump to the sections of the current page and a colored; version of the class's header and source file. Info Box; There is a little info box, usually floating on the right side of the page; (update your browser if it's not). It shows the name of the class you are currently; looking at, which library you have to lin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/etc/html/HELP.html:2848,depend,depends,2848,etc/html/HELP.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/etc/html/HELP.html,2,['depend'],['depends']
Integrability,"of TDF actions during the event loop.; This mechanism is meant to be used to inspect partial results of the analysis or print useful debug information.; For example, both in single- and multi-thread event loops, one can draw a result histogram and update the canvas every 100 entries like this:; ```c++; auto h = tdf.Histo1D(""x"");; TCanvas c(""c"",""x hist"");; h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); h_.Draw(); c.Update(); });; ```; See the tutorials for more examples.; - Add `Sum`, an action that sums all values of a column for the processed entries; - The new TDataSource interface allows developers to pipe any kind of columnar data format into TDataFrame. Two example data sources have been provided: the TRootDS and the TTrivialDS. The former allows to read via the novel data source mechanism ROOT data, while the latter is a simple generator, created for testing and didactic purposes. It is therefore now possible to interface *any* kind of dataset/data format to ROOT as long as an adaptor which implements the pure virtual methods of the TDataSource interface can be written in C++.; - TDF can now read CSV files through a specialized TDataSource. Just create the TDF with `MakeCsvDataFrame(""f.csv"")`. Just create the TDF with MakeCsvDataFrame(""f.csv""). The data types of the CSV columns are automatically inferred. You can also specify if you want to use a different delimiter or if your file does not have headers.; - Users can now configure Snapshot to use different file open modes (""RECREATE"" or ""UPDATE""), compression level, compression algorithm, TTree split-level and autoflush settings; - Users can now access multi-threading slot and entry number as pre-defined columns ""tdfslot_"" and ""tdfentry_"". Especially useful for pyROOT users.; - Users can now specify filters and definitions as strings containing multiple C++ expressions, e.g. ""static int a = 0; return ++a"". Especially useful for pyROOT users.; - Histograms can be initialised by *models*, which allow to create ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:12779,interface,interface,12779,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,2,['interface'],['interface']
Integrability,"of ``source`` implies that no implicit attribute is added. Without the; attribute the replaceable global new and delete operators behave normally; (like other functions) with respect to visibility attributes, pragmas and; options (e.g ``--fvisibility=``).; * Full register names can be used when printing assembly via ``-mregnames``.; This option now matches the one used by GCC. .. _target_os_detail:. * ``-fdefine-target-os-macros`` and its complement; ``-fno-define-target-os-macros``. Enables or disables the Clang extension to; provide built-in definitions of a list of ``TARGET_OS_*`` macros based on the; target triple. The extension is enabled by default for Darwin (Apple platform) targets. Deprecated Compiler Flags; -------------------------. Modified Compiler Flags; -----------------------. * ``-Woverriding-t-option`` is renamed to ``-Woverriding-option``.; * ``-Winterrupt-service-routine`` is renamed to ``-Wexcessive-regsave`` as a generalization; * ``-frewrite-includes`` now guards the original #include directives with; ``__CLANG_REWRITTEN_INCLUDES``, and ``__CLANG_REWRITTEN_SYSTEM_INCLUDES`` as; appropriate.; * Introducing a new default calling convention for ``-fdefault-calling-conv``:; ``rtdcall``. This new default CC only works for M68k and will use the new; ``m68k_rtdcc`` CC on every functions that are not variadic. The ``-mrtd``; driver/frontend flag has the same effect when targeting M68k.; * ``-fvisibility-global-new-delete-hidden`` is now a deprecated spelling of; ``-fvisibility-global-new-delete=force-hidden`` (``-fvisibility-global-new-delete=``; is new in this release).; * ``-fprofile-update`` is enabled for ``-fprofile-generate``. Removed Compiler Flags; -------------------------. * ``-enable-trivial-auto-var-init-zero-knowing-it-will-be-removed-from-clang`` has been removed.; It has not been needed to enable ``-ftrivial-auto-var-init=zero`` since Clang 16. Attribute Changes in Clang; --------------------------; - On X86, a warning is now emitted if",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:18289,rout,routine,18289,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['rout'],['routine']
Integrability,"of a given; state will provide the following information: the deepest physical node; containing the position vector, the distance to the closest boundary; along the direction vector, the next physical node after propagating the; current point with this distance and the safety distance to the nearest; boundary. This information allows the propagation of particles inside a; detector geometry by taking into account both geometrical and physical; constraints. We will hereby describe the user interface of **`TGeo`** to access; tracking functionality. This allows either developing a tracker for; simple navigation within a given geometry, either interfacing to an; external tracking engine such as GEANT. Note that the abstract interface; for external trackers can be found in `$ROOTSYS/vmc` folder and it can; be used to run GEANT3, GEANT4 and FLUKA-based simulations (\*) by using; directly a geometry described with ROOT. The interface methods related to tracking are incorporated into; **`TGeoManager`** class and implemented in the navigator class; **`TGeoNavigator`**. In order to be able to start tracking, one has to; define the initial state providing the starting point $\vec{r_0}$; and direction $\vec{n_0}$ .; There are several ways of doing that. ### TGeoNavigator Class. One geometry may have several independent navigators to query to; localize points or compute distances. The geometry manager holds a list; of active navigators accessible via:. ``` {.cpp}; TObjArray *navigators = gGeoManager->GetListOfNavigators();; ```. Upon closing the geometry a default navigator is provided as first one; in this list, but one may add its own via:. ``` {.cpp}; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; ```. A navigator holds several var",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:102165,interface,interface,102165,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['interface'],['interface']
Integrability,"of a special value. This value; represents the inline assembler as a template string (containing the; instructions to emit), a list of operand constraints (stored as a string), a; flag that indicates whether or not the inline asm expression has side effects,; and a flag indicating whether the function containing the asm needs to align its; stack conservatively. The template string supports argument substitution of the operands using ""``$``""; followed by a number, to indicate substitution of the given register/memory; location, as specified by the constraint string. ""``${NUM:MODIFIER}``"" may also; be used, where ``MODIFIER`` is a target-specific annotation for how to print the; operand (See :ref:`inline-asm-modifiers`). A literal ""``$``"" may be included by using ""``$$``"" in the template. To include; other special characters into the output, the usual ""``\XX``"" escapes may be; used, just as in other strings. Note that after template substitution, the; resulting assembly string is parsed by LLVM's integrated assembler unless it is; disabled -- even when emitting a ``.s`` file -- and thus must contain assembly; syntax known to LLVM. LLVM also supports a few more substitutions useful for writing inline assembly:. - ``${:uid}``: Expands to a decimal integer unique to this inline assembly blob.; This substitution is useful when declaring a local label. Many standard; compiler optimizations, such as inlining, may duplicate an inline asm blob.; Adding a blob-unique identifier ensures that the two labels will not conflict; during assembly. This is used to implement `GCC's %= special format; string <https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html>`_.; - ``${:comment}``: Expands to the comment character of the current target's; assembly dialect. This is usually ``#``, but many targets use other strings,; such as ``;``, ``//``, or ``!``.; - ``${:private}``: Expands to the assembler private label prefix. Labels with; this prefix will not appear in the symbol table of the ass",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:206788,integrat,integrated,206788,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['integrat'],['integrated']
Integrability,"of certain convenience build system targets, such as the various; ``install-*`` and ``check-*`` targets, since IDEs don't always deal well with; a large number of targets. This is usually autodetected, but it can be; configured manually to explicitly control the generation of those targets. **LLVM_ENABLE_LIBCXX**:BOOL; If the host compiler and linker supports the stdlib flag, -stdlib=libc++ is; passed to invocations of both so that the project is built using libc++; instead of stdlibc++. Defaults to OFF. **LLVM_ENABLE_LLVM_LIBC**: BOOL; If the LLVM libc overlay is installed in a location where the host linker; can access it, all built executables will be linked against the LLVM libc; overlay before linking against the system libc. Defaults to OFF. **LLVM_ENABLE_LIBPFM**:BOOL; Enable building with libpfm to support hardware counter measurements in LLVM; tools.; Defaults to ON. **LLVM_ENABLE_LLD**:BOOL; This option is equivalent to `-DLLVM_USE_LINKER=lld`, except during a 2-stage; build where a dependency is added from the first stage to the second ensuring; that lld is built before stage2 begins. **LLVM_ENABLE_LTO**:STRING; Add ``-flto`` or ``-flto=`` flags to the compile and link command; lines, enabling link-time optimization. Possible values are ``Off``,; ``On``, ``Thin`` and ``Full``. Defaults to OFF. **LLVM_ENABLE_MODULES**:BOOL; Compile with `Clang Header Modules; <https://clang.llvm.org/docs/Modules.html>`_. **LLVM_ENABLE_PEDANTIC**:BOOL; Enable pedantic mode. This disables compiler-specific extensions, if; possible. Defaults to ON. **LLVM_ENABLE_PIC**:BOOL; Add the ``-fPIC`` flag to the compiler command-line, if the compiler supports; this flag. Some systems, like Windows, do not need this flag. Defaults to ON. **LLVM_ENABLE_PROJECTS**:STRING; Semicolon-separated list of projects to build, or *all* for building all; (clang, lldb, lld, polly, etc) projects. This flag assumes that projects; are checked out side-by-side and not nested, i.e. clang needs to be in;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:23208,depend,dependency,23208,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['depend'],['dependency']
Integrability,of in-class friend definition; Extension. 2262; C++17; Attributes for asm-definition; Unknown. 2263; drafting; Default argument instantiation for friends; Not resolved. 2264; drafting; Memberwise copying with indeterminate value; Not resolved. 2265; drafting; Delayed pack expansion and member redeclarations; Not resolved. 2266; CD5; Has dependent type vs is type-dependent; Unknown. 2267; CD5; Copy-initialization of temporary in reference direct-initialization; No. 2268; C++17; Unions with mutable members in constant expressions revisited; Unknown. 2269; dup; Additional recursive references in aggregate DMIs; Unknown. 2270; NAD; Non-inline functions and explicit instantiation declarations; Unknown. 2271; C++17; Aliasing this; Unknown. 2272; C++17; Implicit initialization of aggregate members of reference type; Unknown. 2273; CD5; Inheriting constructors vs implicit default constructor; Unknown. 2274; NAD; Generic lambda capture vs constexpr if; Unknown. 2275; drafting; Type-dependence of function template; Not resolved. 2276; C++17; Dependent noexcept and function type-dependence; Unknown. 2277; CD5; Ambiguity inheriting constructors with default arguments; Unknown. 2278; CD5; Copy elision in constant expressions reconsidered; Unknown. 2279; NAD; Multiple attribute-specifiers in one attribute-list; Unknown. 2280; C++20; Matching a usual deallocation function with placement new; Unknown. 2281; drafting; Consistency of aligned operator delete replacement; Not resolved. 2282; C++20; Consistency with mismatched aligned/non-over-aligned allocation/deallocation functions; Unknown. 2283; drafting; Missing complete type requirements; Not resolved. 2284; open; Sequencing of braced-init-list arguments; Not resolved. 2285; CD5; Issues with structured bindings; Unknown. 2286; NAD; Assignment evaluation order; Unknown. 2287; CD5; Pointer-interconvertibility in non-standard-layout unions; Unknown. 2288; NAD; Contradictory optionality in simple-declaration; Unknown. 2289; CD5; Uniq,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:155072,depend,dependence,155072,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['depend'],['dependence']
Integrability,"of increasing; complexity and completeness):. - *""Interpretation of the Errors on Parameters"",* see Part 3 of this; write-up. - *""Determining the Statistical Significance of Experimental; Results""*@bib-MIN81. - *""Statistical Methods in Experimental Physics""*@bib-EADIE. ### The reliability of M error estimates ###. M always carries around its own current estimates of the parameter; errors, which it will print out on request, no matter how accurate they; are at any given point in the execution. For example, at initialization,; these estimates are just the starting step sizes as specified by the; user. After a $\mbox{MIGRAD}$ or $\mbox{HESSE}$ step, the errors; are usually quite accurate, unless there has been a problem. If no; mitigating adjective is given in the printout of the errors, then at; least M believes the errors are accurate, although there is always a; small chance that M has been fooled. Some visible signs that M may have; been fooled are:. - Warning messages produced during the minimization or error analysis. - Failure to find new minimum. - Value of $\mbox{EDM}$ too big. For a ""normal"" minimization,; after $\mbox{MIGRAD}$, the value of $\mbox{EDM}$ is usually; more than three orders of magnitude smaller than $\mbox{up}$,; unless a looser tolerance has been specified. - Correlation coefficients exactly equal to zero, unless some; parameters are known to be uncorrelated with the others. - Correlation coefficients very close to one (greater than 0.99).\; This indicates both an exceptionally difficult problem, and one; which has been badly parametrized so that individual errors are not; very meaningful because they are so highly correlated. - Parameter at limit. This condition, signalled by a M warning; message, may make both the function minimum and parameter errors; unreliable. See section [answer:right-errors], *Getting the right; parameter errors with limits*. The best way to be absolutely sure of the errors, is to use; ""independent"" calculations and com",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:69362,message,messages,69362,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['message'],['messages']
Integrability,"of parameters `P`.; More information about the different `ROOT::Math` function interfaces is available in the Mathematical Library chapter. An end-user can convert a **`TF1`** object in a `ROOT::Math::IParametricFunctionMultiDim`, using the wrapper class `ROOT::Math::WrapperMultiTF1`:. ``` {.cpp}; TF1 * f1 = new TF1(""f1"",""gaus"");; ROOT::Math::WrappedMultiTF1 fitFunction(f1, f1->GetNdim() );; ROOT::Fit::Fitter fitter;; fitter.SetFunction( fitFunction, false);; ```. When creating the wrapper, the parameter values stored in **`TF1`** will be copied in the `ROOT::Math::WrappedMultiTF1` object.; The function object representing the model function is given to the `ROOT::Fitter` class using the `Fitter::SetFunction` method. The user has also the possibility to provide a function object, which implements the derivatives of the function with respect; to the parameters.; This information might be useful for some types of fits. In this case he needs to provide the function object as a class deriving from the; `ROOT::Math::IParametricGradFunctionMultiDim` interface.; Note that the wrapper class `ROOT::Math::WrappedMultiTF1` implements also the gradient interface, using internally `TF1::GradientPar`,; which is based on numerical differentiation, apart for the case of linear functions (i.e. when `TF1::IsLinear()` is `true`).; The parameter derivatives of the model function can be useful to some minimization algorithms, such as Fumili.; However, in general is better to leave the minimization algorithm (e.g. Minuit) to compute the needed derivatives using its own customised; numerical differentiation algorithm.; In order to not provide to the fitter the parameter derivatives, we explicitly passed in `Fitter::SetFunction` a `false` value. ### Fit Configuration. The configuration of the fit is done via the `ROOT::Fit::FitConfig` class and its contained `ROOT::Fit::ParameterSettings` class.; These are the possible allowed fit configurations:. - setting the initial values of the parame",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:37533,interface,interface,37533,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['interface'],['interface']
Integrability,"of the receiver class. For example, given the; following classes:. .. code-block:: objc. @interface NSObject; + (id)alloc;; - (id)init;; @end. @interface NSArray : NSObject; @end. and this common initialization pattern. .. code-block:: objc. NSArray *array = [[NSArray alloc] init];. the type of the expression ``[NSArray alloc]`` is ``NSArray*`` because; ``alloc`` implicitly has a related result type. Similarly, the type of the; expression ``[[NSArray alloc] init]`` is ``NSArray*``, since ``init`` has a; related result type and its receiver is known to have the type ``NSArray *``.; If neither ``alloc`` nor ``init`` had a related result type, the expressions; would have had type ``id``, as declared in the method signature. A method with a related result type can be declared by using the type; ``instancetype`` as its result type. ``instancetype`` is a contextual keyword; that is only permitted in the result type of an Objective-C method, e.g. .. code-block:: objc. @interface A; + (instancetype)constructAnA;; @end. The related result type can also be inferred for some methods. To determine; whether a method has an inferred related result type, the first word in the; camel-case selector (e.g., ""``init``"" in ""``initWithObjects``"") is considered,; and the method will have a related result type if its return type is compatible; with the type of its class and if:. * the first word is ""``alloc``"" or ""``new``"", and the method is a class method,; or. * the first word is ""``autorelease``"", ""``init``"", ""``retain``"", or ""``self``"",; and the method is an instance method. If a method with a related result type is overridden by a subclass method, the; subclass method must also return a type that is compatible with the subclass; type. For example:. .. code-block:: objc. @interface NSString : NSObject; - (NSUnrelated *)init; // incorrect usage: NSUnrelated is not NSString or a superclass of NSString; @end. Related result types only affect the type of a message send or property access; v",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:69451,interface,interface,69451,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['interface'],['interface']
Integrability,"of thumb is to provide interface functions that **can't** fail, except when; faced with hard errors. For a trivial example, suppose we wanted to add an ""``OpenFileForWriting``""; function. For many operating systems, if the file doesn't exist, attempting to; open the file will produce an error. However, ``lib/Support`` should not simply; throw that error if it occurs because its a soft error. The problem is that the; interface function, ``OpenFileForWriting`` is too low level. It should be; ``OpenOrCreateFileForWriting``. In the case of the soft ""doesn't exist"" error,; this function would just create it and then open it for writing. This design principle needs to be maintained in ``lib/Support`` because it; avoids the propagation of soft error handling throughout the rest of LLVM.; Hard errors will generally just cause a termination for an LLVM tool so don't; be bashful about throwing them. Rules of thumb:. #. Don't throw soft errors, only hard errors. #. If you're tempted to throw a soft error, re-think the interface. #. Handle internally the most common normal/good/soft error conditions; so the rest of LLVM doesn't have to. No throw Specifications; -----------------------. None of the ``lib/Support`` interface functions may be declared with C++; ``throw()`` specifications on them. This requirement makes sure that the; compiler does not insert additional exception handling code into the interface; functions. This is a performance consideration: ``lib/Support`` functions are; at the bottom of many call chains and as such can be frequently called. We; need them to be as efficient as possible. However, no routines in the system; library should actually throw exceptions. Code Organization; -----------------. Implementations of the Support Library interface are separated by their general; class of operating system. Currently only Unix and Win32 classes are defined; but more could be added for other operating system classifications. To; distinguish which implementation to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:9196,interface,interface,9196,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['interface'],['interface']
Integrability,"of; libraries to documentation URLs. If it finds it, it will create a link; to the documentation at that URL for all occurrences of a given class; name. One can set the URL `../mylib/` for a library name `MyLib` by; setting `Root.Html.MyLib:` `../mylib/` or by calling; `THtml::SetLibURL(""MyLib"", ""../mylib/"")`. Occurrences of class `MyClass`; of `MyLib` will now be referenced as `../mylib/MyClass.html`. ### Search Engine. **`THtml`** can invoke external search engines. The ROOT reference guide; sets `Root.Html.Search` to <http://www.google.com/search?q=%s+site%3A%u>.; Calling **`THtml::SetSearchStemURL()`** will set the same. If this URL stem is; set, `THtml` will create search fields in the index pages. It will; send the words entered in these search fields as %s in the URL; %u will; be replaced by the current document's path, allowing a site- and; directory-specific search. ### ViewCVS. Most code is managed in a version control system like CVS. ViewCVS is a; WWW reader interface to the versioning control system that allows e.g.; tracking a file's changes. **`THtml`** will reference these pages; automatically if the `.rootrc` variable `Root.Html.ViewCVS` is set to; the URL stem of the ViewCVS. installation. Alternatively, one can call; THtml::SetViewCVS(). ### Wiki Pages. In some contexts it might be desirable to let users comment on classes,; e.g. for suggestions of use or alternatives, details of behavior, and; cross references to other relevant classes. A successful example of this; is the PHP.net documentation with its user annotations. **`THtml`** can; include a link to a class's Wiki page by setting the Wiki base URL via; `Root.Html.WikiURL` or **`THtml`**`::SetWikiURL()`. ## Tutorial. You can run the tutorial `htmlex.C` to see how **`THtml`** converts a; script to HTML and how it creates the corresponding class reference:. ``` {.cpp}; root[] .x $(ROOTSYS)/tutorials/htmlex.C+; ```. Have a look at the HTML version of the macro in; `htmldoc/htmlex.C.html `(which ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md:11031,interface,interface,11031,documentation/users-guide/HTMLDoc.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md,1,['interface'],['interface']
Integrability,"ofConfig.h; RooStats/ProposalFunction.h; RooStats/ProposalHelper.h; RooStats/RatioOfProfiledLikelihoodsTestStat.h; RooStats/RooStatsUtils.h; RooStats/SamplingDistPlot.h; RooStats/SamplingDistribution.h; RooStats/SequentialProposal.h; RooStats/SimpleInterval.h; RooStats/SimpleLikelihoodRatioTestStat.h; RooStats/SPlot.h; RooStats/TestStatistic.h; RooStats/TestStatSampler.h; RooStats/ToyMCImportanceSampler.h; RooStats/ToyMCSampler.h; RooStats/ToyMCStudy.h; RooStats/UniformProposal.h; RooStats/UpperLimitMCSModule.h; SOURCES; src/AsymptoticCalculator.cxx; src/BayesianCalculator.cxx; src/BernsteinCorrection.cxx; src/ConfidenceBelt.cxx; src/DetailedOutputAggregator.cxx; src/FeldmanCousins.cxx; src/FrequentistCalculator.cxx; src/Heaviside.cxx; src/HLFactory.cxx; src/HybridCalculator.cxx; src/HybridPlot.cxx; src/HybridResult.cxx; src/HypoTestCalculatorGeneric.cxx; src/HypoTestInverter.cxx; src/HypoTestInverterPlot.cxx; src/HypoTestInverterResult.cxx; src/HypoTestPlot.cxx; src/HypoTestResult.cxx; src/LikelihoodInterval.cxx; src/LikelihoodIntervalPlot.cxx; src/MarkovChain.cxx; src/MCMCCalculator.cxx; src/MCMCInterval.cxx; src/MCMCIntervalPlot.cxx; src/MetropolisHastings.cxx; src/NeymanConstruction.cxx; src/NumberCountingPdfFactory.cxx; src/NumberCountingUtils.cxx; src/PdfProposal.cxx; src/PointSetInterval.cxx; src/ProfileInspector.cxx; src/ProfileLikelihoodCalculator.cxx; src/ProfileLikelihoodTestStat.cxx; src/ProposalHelper.cxx; src/RatioOfProfiledLikelihoodsTestStat.cxx; src/RooStatsUtils.cxx; src/SamplingDistPlot.cxx; src/SamplingDistribution.cxx; src/SequentialProposal.cxx; src/SimpleInterval.cxx; src/SimpleLikelihoodRatioTestStat.cxx; src/SPlot.cxx; src/ToyMCImportanceSampler.cxx; src/ToyMCSampler.cxx; src/ToyMCStudy.cxx; src/UniformProposal.cxx; src/UpperLimitMCSModule.cxx; DICTIONARY_OPTIONS; ""-writeEmptyRootPCM""; DEPENDENCIES; Core; RooFit; RooFitCore; Tree; RIO; Hist; Matrix; MathCore; Minuit; Foam; Graf; Gpad; ${EXTRA_DICT_OPTS}; ). ROOT_ADD_TEST_SUBDIRECTORY(test); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/CMakeLists.txt:3733,DEPEND,DEPENDENCIES,3733,roofit/roostats/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/CMakeLists.txt,1,['DEPEND'],['DEPENDENCIES']
Integrability,"oftware engineering practice dictates that mutexes should be private; members, because the locking mechanism used by a thread-safe class is part of; its internal implementation. However, private mutexes can sometimes leak into; the public interface of a class.; Thread safety attributes follow normal C++ access restrictions, so if ``mu``; is a private member of ``c``, then it is an error to write ``c.mu`` in an; attribute. One workaround is to (ab)use the ``RETURN_CAPABILITY`` attribute to provide a; public *name* for a private mutex, without actually exposing the underlying; mutex. For example:. .. code-block:: c++. class MyClass {; private:; Mutex mu;. public:; // For thread safety analysis only. Does not need to be defined.; Mutex* getMu() RETURN_CAPABILITY(mu);. void doSomething() REQUIRES(mu);; };. void doSomethingTwice(MyClass& c) REQUIRES(c.getMu()) {; // The analysis thinks that c.getMu() == c.mu; c.doSomething();; c.doSomething();; }. In the above example, ``doSomethingTwice()`` is an external routine that; requires ``c.mu`` to be locked, which cannot be declared directly because ``mu``; is private. This pattern is discouraged because it; violates encapsulation, but it is sometimes necessary, especially when adding; annotations to an existing code base. The workaround is to define ``getMu()``; as a fake getter method, which is provided only for the benefit of thread; safety analysis. .. _conditional_locks:. No conditionally held locks.; ----------------------------. The analysis must be able to determine whether a lock is held, or not held, at; every program point. Thus, sections of code where a lock *might be held* will; generate spurious warnings (false positives). For example:. .. code-block:: c++. void foo() {; bool b = needsToLock();; if (b) mu.Lock();; ... // Warning! Mutex 'mu' is not held on every path through here.; if (b) mu.Unlock();; }. No checking inside constructors and destructors.; ------------------------------------------------. The analysi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:20928,rout,routine,20928,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['rout'],['routine']
Integrability,"ogonal:. ``` {.cpp}; const TMatrixD haar = THaarMatrixD(order);; TVectorD colj(1<<order);; TVectorD coll(1<<order);; for (Int_t j = haar.GetColLwb(); j <= haar.GetColUpb(); j++) {; colj = TMatrixDColumn_const(haar,j);; Assert(TMath::Abs(colj*colj-1.0) <= 1.0e-15);. for (Int_t l = j+1; l <= haar.GetColUpb(); l++) {; coll = TMatrixDColumn_const(haar,l);; Assert(TMath::Abs(colj*coll) <= 1.0e-15);; }; }; ```. Multiplying part of a matrix with another part of that matrix (they can overlap). ``` {.cpp}; TMatrixDSub(m,1,3,1,3) *= m.GetSub(5,7,5,7);; ```. ## Matrix Decompositions. The linear algebra package offers several classes to assist in matrix; decompositions. Each of the decomposition methods performs a set of; matrix transformations to facilitate solving a system of linear; equations, the formation of inverses as well as the estimation of; determinants and condition numbers. More specifically the classes; **`TDecompLU`**, **`TDecompBK`**, **`TDecompChol`**, **`TDecompQRH`** and; **`TDecompSVD`** give a simple and consistent interface to the LU,; Bunch-Kaufman, Cholesky, QR and SVD decompositions. All of these classes; are derived from the base class **`TDecompBase`** of which the important; methods are listed in next table:. +-----------------------------------------------------+--------------------------------------+; | Method | Action |; +-----------------------------------------------------+--------------------------------------+; | `Bool_t Decompose()` | perform the matrix decomposition |; +-----------------------------------------------------+--------------------------------------+; | `Double_t Condition()` | calculate ||*A*||1 ||*A*-1||1, |; | | see ""Condition number"" |; +-----------------------------------------------------+--------------------------------------+; | `void Det(Double_t &d1,Double_t &d2)` | the determinant is `d1` $2^{d_{2}}$. |; | | Expressing the determinant this |; | | way makes under/over-flow very |; | | unlikely |; +----------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:33828,interface,interface,33828,documentation/users-guide/LinearAlgebra.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md,1,['interface'],['interface']
Integrability,"ogram to cause two or more calls to ``init``; methods on the same object, except that each ``init`` method invocation may; perform at most one delegate init call. .. _arc.family.semantics.result_type:. Related result types; ^^^^^^^^^^^^^^^^^^^^. Certain methods are candidates to have :arc-term:`related result types`:. * class methods in the ``alloc`` and ``new`` method families; * instance methods in the ``init`` family; * the instance method ``self``; * outside of ARC, the instance methods ``retain`` and ``autorelease``. If the formal result type of such a method is ``id`` or protocol-qualified; ``id``, or a type equal to the declaring class or a superclass, then it is said; to have a related result type. In this case, when invoked in an explicit; message send, it is assumed to return a type related to the type of the; receiver:. * if it is a class method, and the receiver is a class name ``T``, the message; send expression has type ``T*``; otherwise; * if it is an instance method, and the receiver has type ``T``, the message; send expression has type ``T``; otherwise; * the message send expression has the normal result type of the method. This is a new rule of the Objective-C language and applies outside of ARC. .. admonition:: Rationale. ARC's automatic code emission is more prone than most code to signature; errors, i.e. errors where a call was emitted against one method signature,; but the implementing method has an incompatible signature. Having more; precise type information helps drastically lower this risk, as well as; catching a number of latent bugs. .. _arc.optimization:. Optimization; ============. Within this section, the word :arc-term:`function` will be used to; refer to any structured unit of code, be it a C function, an; Objective-C method, or a block. This specification describes ARC as performing specific ``retain`` and; ``release`` operations on retainable object pointers at specific; points during the execution of a program. These operations ma",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:74792,message,message,74792,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,3,['message'],['message']
Integrability,"ograms it is now also possible; to perform chi-squared fits to unbinned datasets containing a series of X and Y values; with associated errors on Y and optionally on X. These 'X-Y' chi-squared fits are interfaced through newly added method; RooAbsReal::chi2FitTo(const RooDataSet&,...). By default the event weight is; interpreted as the 'Y' value, but an YVar() argument can designate any other; dataset column as Y value. If X errors are defined, one can choose to integrate the fitted; function over the range of the X errors, rather than taking the central value by adding; an Integrate(true) argument to chi2FitTo(); Two new arguments, StoreError(const RooArgSet&) and StoreAsymError(const RooArgSet&); have been added to the RooDataSet constructor to simplify the process of storing the errors; of X and Y variables along with their values in a dataset. The newly added tutorial macro rf609_xychi2fit.C illustrates the use of all this; new functionality. Uniform interface for creation of (profile likelihoods) and chi-squared from p.d.f.s; It is now recommended to use the method RooAbsPdf::createNLL(RooAbsData&,...) to; create a likelihood from a p.d.f and a dataset rather than constructing a RooNLLVar; object directly. This is because part of the likelihood construction functionality such a using; multiple Range()s, or the inclusion for constraint terms are only available through; createNLL(). To promote the consistency of this interface, a similar method RooAbsReal::createChi2(); has been added to construct chi-squared functions of a dataset and a function or p.d.f. Along the same lines, it is recommended to use RooAbsReal::createProfile() rather; than constructing a RooProfileLL object directly as the former will efficiently; recast a profile of a profile into a single profile object. Multivariate Gaussian modeling of parameters estimates from a fit; You can now construct a multivariate Gaussian p.d.f on the parameters of a model that; represents the result of a fit, from",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:9231,interface,interface,9231,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,2,['interface'],['interface']
Integrability,"ogx/logy, reset existing user ranges in pad; - avoid too deep calling stack when drawing many graphs or histos (#154); - correctly (re)draw tooltips on canvas with many subpads. ## Code Examples. - New graphics tutorial AtlasExample.C illustrating the ATLAS style.; - New TLazyDS tutorial added tdf015_LazyDataSource.C.; - Show how to inspect a `TCutFlowReport` object. ## Class Reference Guide. - Replace low resolution images with bigger ones more suited for modern screens. ## Build System and Configuration. - ROOT can now be built against an externally built llvm and clang (llvm can be used unpatched, clang still require ROOT specific patches). The options are builtin_llvm and builtin_clang both defaulting to ON.; - Update RConfigure.h with R__HAS__VDT if the package is found/builtin; - CMake exported targets now have the `INTERFACE_INCLUDE_DIRECTORIES` property set ([ROOT-8062](https://sft.its.cern.ch/jira/browse/ROOT-8062)).; - The `-fPIC` compile flag is no longer propagated to dependent projects via `CMAKE_CXX_FLAGS` ([ROOT-9212](https://sft.its.cern.ch/jira/browse/ROOT-9212)).; - Several builtins have updated versions:; - OpenSSL was updated from 1.0.2d to 1.0.2.o (latest lts release, [ROOT-9359](https://sft.its.cern.ch/jira/browse/ROOT-9359)); - Davix was updated from 0.6.4 to 0.6.7 (support for OpenSSL 1.1, [ROOT-9353](https://sft.its.cern.ch/jira/browse/ROOT-9353)); - Vdt has been updated from 0.3.9 to 0.4.1 (includes new atan function); - XRootd has been updated from 4.6.1 to 4.8.2 (for GCC 8.x support); - Builtin TBB can now be used on Windows; - xxHash and LZ4 have been separated so that a system version of LZ4 can be used even if it does not include xxHash headers ([ROOT-9099](https://sft.its.cern.ch/jira/browse/ROOT-9099)); - In addition, several updates have been made to fix minor build system issues, such as not checking for external packages if their builtin is turned off, or checking for packages even when the respective option is disabled ([ROOT-880",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md:18139,depend,dependent,18139,README/ReleaseNotes/v614/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md,1,['depend'],['dependent']
Integrability,"ointer to an object to a C routine) in the abstract; machine model. At the moment, the best idea on how to approach this; involves an intrinsic or opaque function which hides the connection between; the reference value and the raw pointer. The problem is that having a; ptrtoint or inttoptr cast (which is common for such use cases) breaks the; rules used for inferring base pointers for arbitrary references when; lowering out of the abstract model to the explicit physical model. Note; that a frontend which lowers directly to the physical model doesn't have; any problems here. Objects on the Stack; ^^^^^^^^^^^^^^^^^^^^. As noted above, the explicit lowering supports objects allocated on the; stack provided the collector can find a heap map given the stack address. The missing pieces are a) integration with rewriting (RS4GC) from the; abstract machine model and b) support for optionally decomposing on stack; objects so as not to require heap maps for them. The later is required; for ease of integration with some collectors. Lowering Quality and Representation Overhead; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The current statepoint lowering is known to be somewhat poor. In the very; long term, we'd like to integrate statepoints with the register allocator;; in the near term this is unlikely to happen. We've found the quality of; lowering to be relatively unimportant as hot-statepoints are almost always; inliner bugs. Concerns have been raised that the statepoint representation results in a; large amount of IR being produced for some examples and that this; contributes to higher than expected memory usage and compile times. There's; no immediate plans to make changes due to this, but alternate models may be; explored in the future. Relocations Along Exceptional Edges; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Relocations along exceptional paths are currently broken in ToT. In; particular, there is current no way to represent a rethrow on a path which; also has relocations",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:35228,integrat,integration,35228,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['integrat'],['integration']
Integrability,"ointeraliasing>` section for more; information. If the ``inbounds`` keyword is present, the result value of a; ``getelementptr`` with any non-zero indices is a; :ref:`poison value <poisonvalues>` if one of the following rules is violated:. * The base pointer has an *in bounds* address of an allocated object, which; means that it points into an allocated object, or to its end. Note that the; object does not have to be live anymore; being in-bounds of a deallocated; object is sufficient.; * If the type of an index is larger than the pointer index type, the; truncation to the pointer index type preserves the signed value.; * The multiplication of an index by the type size does not wrap the pointer; index type in a signed sense (``nsw``).; * The successive addition of each offset (without adding the base address) does; not wrap the pointer index type in a signed sense (``nsw``).; * The successive addition of the current address, interpreted as an unsigned; number, and each offset, interpreted as a signed number, does not wrap the; unsigned address space and remains *in bounds* of the allocated object.; As a corollary, if the added offset is non-negative, the addition does not; wrap in an unsigned sense (``nuw``).; * In cases where the base is a vector of pointers, the ``inbounds`` keyword; applies to each of the computations element-wise. Note that ``getelementptr`` with all-zero indices is always considered to be; ``inbounds``, even if the base pointer does not point to an allocated object.; As a corollary, the only pointer in bounds of the null pointer in the default; address space is the null pointer itself. These rules are based on the assumption that no allocated object may cross; the unsigned address space boundary, and no allocated object may be larger; than half the pointer index type space. If the ``inrange`` keyword is present before any index, loading from or; storing to any pointer derived from the ``getelementptr`` has undefined; behavior if the load or stor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:438063,wrap,wrap,438063,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['wrap'],['wrap']
Integrability,"oject is in ‘incubation status’ and is not included in LLVM releases (see; suggested wording below).; * Must be proposed through the LLVM RFC process, and have its addition; approved by the LLVM community - this ultimately mediates the resolution of; the ""should"" concerns above. That said, the project need not have any code to get started, and need not have; an established community at all! Furthermore, incubating projects may pass; through transient states that violate the ""Should"" guidelines above, or would; otherwise make them unsuitable for direct inclusion in the monorepo (e.g.; dependencies that have not yet been factored appropriately, leveraging; experimental components or APIs that are not yet upstream, etc). When approved, the llvm-admin group can grant the new project:; * A new repository in the LLVM Github Organization - but not the LLVM monorepo.; * New mailing list, discourse forum, and/or discord chat hosted with other LLVM; forums.; * Other infrastructure integration can be discussed on a case-by-case basis. Graduation to the mono-repo would follow existing processes and standards for; becoming a first-class part of the monorepo. Similarly, an incubating project; may be eventually retired, but no process has been established for that yet. If; and when this comes up, please start an RFC discussion on the `LLVM Discourse forums`_. This process is very new - please expect the details to change, it is always; safe to ask on the `LLVM Discourse forums`_ about this. Suggested disclaimer for the project README and the main project web page:. ::. This project is participating in the LLVM Incubator process: as such, it is; not part of any official LLVM release. While incubation status is not; necessarily a reflection of the completeness or stability of the code, it; does indicate that the project is not yet endorsed as a component of LLVM. .. _copyright-license-patents:. Copyright, License, and Patents; ===============================. .. note::. This section",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:49626,integrat,integration,49626,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['integrat'],['integration']
Integrability,"oject to advance; compilers, languages, tools, runtimes, etc.; * Must conform to the license, patent, and code of conduct policies laid out; in this developer policy document.; * Must have a documented charter and development plan, e.g. in the form of a; README file, mission statement, and/or manifesto.; * Should conform to coding standards, incremental development process, and; other expectations.; * Should have a sense of the community that it hopes to eventually foster, and; there should be interest from members with different affiliations /; organizations.; * Should have a feasible path to eventually graduate as a dedicated top-level; or sub-project within the `LLVM monorepo; <https://github.com/llvm/llvm-project>`_.; * Should include a notice (e.g. in the project README or web page) that the; project is in ‘incubation status’ and is not included in LLVM releases (see; suggested wording below).; * Must be proposed through the LLVM RFC process, and have its addition; approved by the LLVM community - this ultimately mediates the resolution of; the ""should"" concerns above. That said, the project need not have any code to get started, and need not have; an established community at all! Furthermore, incubating projects may pass; through transient states that violate the ""Should"" guidelines above, or would; otherwise make them unsuitable for direct inclusion in the monorepo (e.g.; dependencies that have not yet been factored appropriately, leveraging; experimental components or APIs that are not yet upstream, etc). When approved, the llvm-admin group can grant the new project:; * A new repository in the LLVM Github Organization - but not the LLVM monorepo.; * New mailing list, discourse forum, and/or discord chat hosted with other LLVM; forums.; * Other infrastructure integration can be discussed on a case-by-case basis. Graduation to the mono-repo would follow existing processes and standards for; becoming a first-class part of the monorepo. Similarly, an incubating p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:48863,mediat,mediates,48863,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['mediat'],['mediates']
Integrability,"ol can enter the coroutine:. 1. the ramp function that is initially invoked, which takes arbitrary; arguments and returns a pointer to the coroutine object;. 2. a coroutine resume function that is invoked when the coroutine is resumed,; which takes a pointer to the coroutine object and returns `void`;. 3. a coroutine destroy function that is invoked when the coroutine is; destroyed, which takes a pointer to the coroutine object and returns; `void`. Because the resume and destroy functions are shared across all suspend; points, suspend points must store the index of the active suspend in; the coroutine object, and the resume/destroy functions must switch over; that index to get back to the correct point. Hence the name of this; lowering. Pointers to the resume and destroy functions are stored in the coroutine; object at known offsets which are fixed for all coroutines. A completed; coroutine is represented with a null resume function. There is a somewhat complex protocol of intrinsics for allocating and; deallocating the coroutine object. It is complex in order to allow the; allocation to be elided due to inlining. This protocol is discussed; in further detail below. The frontend may generate code to call the coroutine function directly;; this will become a call to the ramp function and will return a pointer; to the coroutine object. The frontend should always resume or destroy; the coroutine using the corresponding intrinsics. Returned-Continuation Lowering; ------------------------------. In returned-continuation lowering, signaled by the use of; `llvm.coro.id.retcon` or `llvm.coro.id.retcon.once`, some aspects of; the ABI must be handled more explicitly by the frontend. In this lowering, every suspend point takes a list of ""yielded values""; which are returned back to the caller along with a function pointer,; called the continuation function. The coroutine is resumed by simply; calling this continuation function pointer. The original coroutine; is divided into the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:4794,protocol,protocol,4794,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['protocol'],['protocol']
Integrability,"ol displays low-level format-specific information; about one or more object files. If ``input`` is ""``-``"", :program:`llvm-readelf` reads from standard; input. Otherwise, it will read from the specified ``filenames``. OPTIONS; -------. .. option:: --all, -a. Equivalent to specifying all the main display options relevant to the file; format. .. option:: --addrsig. Display the address-significance table. .. option:: --arch-specific, -A. Display architecture-specific information, e.g. the ARM attributes section on ARM. .. option:: --bb-addr-map. Display the contents of the basic block address map section(s), which contain the; address of each function, along with the relative offset of each basic block. .. option:: --decompress, -z. Dump decompressed section content when used with ``-x`` or ``-p``.; If the section(s) are not compressed, they are displayed as is. .. option:: --demangle, -C. Display demangled symbol names in the output. .. option:: --dependent-libraries. Display the dependent libraries section. .. option:: --dyn-relocations. Display the dynamic relocation entries. .. option:: --dyn-symbols, --dyn-syms. Display the dynamic symbol table. .. option:: --dynamic-table, --dynamic, -d. Display the dynamic table. .. option:: --cg-profile. Display the callgraph profile section. .. option:: --histogram, -I. Display a bucket list histogram for dynamic symbol hash tables. .. option:: --elf-linker-options. Display the linker options section. .. option:: --elf-output-style=<value>. Format ELF information in the specified style. Valid options are ``LLVM``,; ``GNU``, and ``JSON``. ``LLVM`` output is an expanded and structured format.; ``GNU`` (the default) output mimics the equivalent GNU :program:`readelf`; output. ``JSON`` is JSON formatted output intended for machine consumption. .. option:: --extra-sym-info. Display extra information (section name) when showing symbols. .. option:: --section-groups, -g. Display section groups. .. option:: --expand-relocs. When used w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-readelf.rst:1236,depend,dependent,1236,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-readelf.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-readelf.rst,1,['depend'],['dependent']
Integrability,"ol. **Number Of Constants**. The total number of constants (of any type) defined in the Constant Pool. **Number Of Basic Blocks**. The total number of basic blocks defined in all functions in the bitcode file. **Number Of Instructions**. The total number of instructions defined in all functions in the bitcode file. **Number Of Long Instructions**. The total number of long instructions defined in all functions in the bitcode; file. Long instructions are those taking greater than 4 bytes. Typically long; instructions are GetElementPtr with several indices, PHI nodes, and calls to; functions with large numbers of arguments. **Number Of Operands**. The total number of operands used in all instructions in the bitcode file. **Number Of Compaction Tables**. The total number of compaction tables in all functions in the bitcode file. **Number Of Symbol Tables**. The total number of symbol tables in all functions in the bitcode file. **Number Of Dependent Libs**. The total number of dependent libraries found in the bitcode file. **Total Instruction Size**. The total size of the instructions in all functions in the bitcode file. **Average Instruction Size**. The average number of bytes per instruction across all functions in the bitcode; file. This value is computed by dividing Total Instruction Size by Number Of; Instructions. **Maximum Type Slot Number**. The maximum value used for a type's slot number. Larger slot number values take; more bytes to encode. **Maximum Value Slot Number**. The maximum value used for a value's slot number. Larger slot number values take; more bytes to encode. **Bytes Per Value**. The average size of a Value definition (of any type). This is computed by; dividing File Size by the total number of values of any type. **Bytes Per Global**. The average size of a global definition (constants and global variables). **Bytes Per Function**. The average number of bytes per function definition. This is computed by; dividing Function Bytes by Number Of Funct",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-bcanalyzer.rst:4513,depend,dependent,4513,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-bcanalyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-bcanalyzer.rst,1,['depend'],['dependent']
Integrability,"olFields = [];. // Values for the fields/attributes listed in 'ColFields' corresponding to; // the key instruction. This is the instruction that will be transformed; // using this relation model.; list<string> KeyCol = [];. // List of values for the fields/attributes listed in 'ColFields', one for; // each column in the relation table. These are the instructions a key; // instruction will be transformed into.; list<list<string> > ValueCols = [];; }. Sample Example; --------------. Let's say that we want to have a function; ``int getPredOpcode(uint16_t Opcode, enum PredSense inPredSense)`` which; takes a non-predicated instruction and returns its predicated true or false form; depending on some input flag, ``inPredSense``. The first step in the process is; to define a relationship model that relates predicated instructions to their; non-predicated form by assigning appropriate values to the ``InstrMapping``; fields. For this relationship, non-predicated instructions are treated as key; instruction since they are the one used to query the interface function. .. code-block:: text. def getPredOpcode : InstrMapping {; // Choose a FilterClass that is used as a base class for all the; // instructions modeling this relationship. This is done to reduce the; // search space only to these set of instructions.; let FilterClass = ""PredRel"";. // Instructions with same values for all the fields in RowFields form a; // row in the resulting relation table.; // For example, if we want to relate 'ADD' (non-predicated) with 'Add_pt'; // (predicated true) and 'Add_pf' (predicated false), then all 3; // instructions need to have same value for BaseOpcode field. It can be any; // unique value (Ex: XYZ) and should not be shared with any other; // instruction not related to 'add'.; let RowFields = [""BaseOpcode""];. // List of attributes that can be used to define key and column instructions; // for a relation. Key instruction is passed as an argument; // to the function used for querying rel",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUseInstrMappings.rst:3080,interface,interface,3080,interpreter/llvm-project/llvm/docs/HowToUseInstrMappings.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUseInstrMappings.rst,1,['interface'],['interface']
Integrability,"oling interface supports reading compilation databases; see; the :doc:`LibTooling documentation <LibTooling>`. libclang and its; python bindings also support this (since clang 3.2); see; `CXCompilationDatabase.h </doxygen/group__COMPILATIONDB.html>`_. Format; ======. A compilation database is a JSON file, which consist of an array of; ""command objects"", where each command object specifies one way a; translation unit is compiled in the project. Each command object contains the translation unit's main file, the; working directory of the compile run and the actual compile command. Example:. ::. [; { ""directory"": ""/home/user/llvm/build"",; ""arguments"": [""/usr/bin/clang++"", ""-Irelative"", ""-DSOMEDEF=With spaces, quotes and \\-es."", ""-c"", ""-o"", ""file.o"", ""file.cc""],; ""file"": ""file.cc"" },. { ""directory"": ""/home/user/llvm/build"",; ""command"": ""/usr/bin/clang++ -Irelative -DSOMEDEF=\""With spaces, quotes and \\-es.\"" -c -o file.o file.cc"",; ""file"": ""file2.cc"" },. ...; ]. The contracts for each field in the command object are:. - **directory:** The working directory of the compilation. All paths; specified in the **command** or **file** fields must be either; absolute or relative to this directory.; - **file:** The main translation unit source processed by this; compilation step. This is used by tools as the key into the; compilation database. There can be multiple command objects for the; same file, for example if the same source file is compiled with; different configurations.; - **arguments:** The compile command argv as list of strings.; This should run the compilation step for the translation unit ``file``.; ``arguments[0]`` should be the executable name, such as ``clang++``.; Arguments should not be escaped, but ready to pass to ``execvp()``.; - **command:** The compile command as a single shell-escaped string.; Arguments may be shell quoted and escaped following platform conventions,; with '``""``' and '``\``' being the only special characters. Shell expansion; is not suppor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst:3049,contract,contracts,3049,interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst,1,['contract'],['contracts']
Integrability,"ollowing one.; Some minimizers (e.g. *Minuit*) contain several algorithms that the user can; choose. Others are based on a single algorithm (e.g. *Fumili*). - **`Minuit`** (library *libMinuit*). Old version of Minuit, based on the `TMinuit` class. The list of possible algorithms are:; - *`Migrad`* (default one); 	 - *`Simplex`*; - *`Minimize`* (it is a combination of Migrad and Simplex); - *`MigradImproved`*; 	 - *`Scan`*; 	 - *`Seek`*. - **`Minuit2`** (library *libMinuit2*). New C++ version of Minuit. The list of possible algorithm is :; - *`Migrad`* (default); - *`Simplex`*; 	 - *`Minimize`*; 	 - *`Scan`*; 	 - *`Fumili`* . This is the same algorithm of `TFumili`, but implemented in the Minuit2 library. - **`Fumili`**. Implement a dedicated minimization algorithm for least-square and likelihood fits. It has requirements on the type of method function to be used.; No specific algorithm exists. - **`GSLMultiMin`** (library *libMathMore*). Minimizer based on the Multidimensional Minimization routines of the Gnu Scientific Library (GSL). The list of available algorithms is; 	- *`BFGS2`* (default) : second version of the vector Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm;; 	- *`BFGS`* : old version of the vector Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm;; 	- *`ConjugateFR`* : Fletcher-Reeves conjugate gradient algorithm;; 	- *`ConjugatePR`* : Polak-Ribiere conjugate gradient algorithm;; 	- *`SteepestDescent`*: steepest descent algorithm;. - **`GSLMultiFit`** (library *libMathMore*). Minimizer based on the Non-Linear Least-Square routines of GSL. This minimizer can be used only for least-square fits. - **`GSLSimAn`** (library *libMathMore*). Minimizer based on simulated annealing. - **`Genetic`** (library *libGenetic*). Genetic minimizer based on an algorithm implemented in the *TMVA* package. Each minimizer can be configured using the `ROOT::Math::MinimizerOptions` class. The list of possible option that can be set are:. * *Minimizer type* (`MinimizerOption",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:41832,rout,routines,41832,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['rout'],['routines']
Integrability,"ols/clang-format` and can be used; to format C/C++/Java/JavaScript/JSON/Objective-C/Protobuf/C# code. .. START_FORMAT_HELP. .. code-block:: console. $ clang-format --help; OVERVIEW: A tool to format C/C++/Java/JavaScript/JSON/Objective-C/Protobuf/C# code. If no arguments are specified, it formats the code from standard input; and writes the result to the standard output.; If <file>s are given, it reformats the files. If -i is specified; together with <file>s, the files are edited in-place. Otherwise, the; result is written to the standard output. USAGE: clang-format [options] [@<file>] [<file> ...]. OPTIONS:. Clang-format options:. --Werror - If set, changes formatting warnings to errors; --Wno-error=<value> - If set don't error out on the specified warning type.; =unknown - If set, unknown format options are only warned about.; This can be used to enable formatting, even if the; configuration contains unknown (newer) options.; Use with caution, as this might lead to dramatically; differing format depending on an option being; supported or not.; --assume-filename=<string> - Set filename used to determine the language and to find; .clang-format file.; Only used when reading from stdin.; If this is not passed, the .clang-format file is searched; relative to the current working directory when reading stdin.; Unrecognized filenames are treated as C++.; supported:; CSharp: .cs; Java: .java; JavaScript: .mjs .js .ts; Json: .json; Objective-C: .m .mm; Proto: .proto .protodevel; TableGen: .td; TextProto: .textpb .pb.txt .textproto .asciipb; Verilog: .sv .svh .v .vh; --cursor=<uint> - The position of the cursor when invoking; clang-format from an editor integration; --dry-run - If set, do not actually make the formatting changes; --dump-config - Dump configuration options to stdout and exit.; Can be used with -style option.; --fallback-style=<string> - The name of the predefined style used as a; fallback in case clang-format is invoked with; -style=file, but can not find the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst:1320,depend,depending,1320,interpreter/llvm-project/clang/docs/ClangFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst,1,['depend'],['depending']
Integrability,"om a Script. You may want to execute a script conditionally inside another script.; To do it you need to call the interpreter and you can do that with; `TROOT::ProcessLine()`. The example; `$ROOTSYS/tutorials/tree/cernstaff.C` calls a script to build the root; file if it does not exist:. ``` {.cpp}; void cernstaff() {; if (gSystem->AccessPathName(""cernstaff.root"")) {; gROOT->ProcessLine("".x cernbuild.C"");; }; ```. `ProcessLine` takes a parameter, which is a pointer to an `int` or to; a `TInterpreter::EErrorCode` to let you access the interpreter error; code after an attempt to interpret. This will contain the error; as defined in `enum TInterpreter::EErrorCode` with `TInterpreter::kSuccess` being; the value for a successful execution. ### Executing a Script From the Invocation. Instead if starting ROOT and running a script on the prompt you can also pass; it to ROOT in its invocation:. ```; $ root -l -b 'myCode.C(""some String"", 12)'; ```. The exact kind of quoting depends on your shell; the one shown here works for; bash-like shells. ROOT can evaluate any expression as part of the invocation; another version of; the previous example can be spelled like this:. ```; $ root -l -b -e 'gROOT->ProcessLine("".x myCode.C(\""some String\"", 12)"");'; ```. ## C++ Extensions To Ease Scripting. In the next example, we demonstrate three of the most important; extensions ROOT and Cling make to C++. Start ROOT in the directory; `$ROOTSYS/tutorials` (make sure to have first run `.x hsimple.C`):. ``` {.cpp}; root [0] f = new TFile(""hsimple.root""); (class TFile *) 0x4045e690; root [1] f->ls(); TFile** hsimple.root; TFile* hsimple.root; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py ps px; KEY: THProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; root [2] hpx->Draw(); Warning in <MakeDefCanvas>: creating a default canvas with name c1; root [3] .q; ```. The `root [0]` command shows the first extension; the declaration of `f`; may be omitted as a s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:10125,depend,depends,10125,documentation/users-guide/Cling.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md,1,['depend'],['depends']
Integrability,"om cppyy.gbl import Concrete; >>> c = Concrete(); >>> c.__python_owns__ # True: object created in Python; True; >>>. * ``__creates__``: a flag that every C++ overload carries and determines; whether the return value is owned by C++ or Python: if ``True``, Python owns; the return value, otherwise C++. * ``__set_lifeline__``: a flag that every C++ overload carries and determines; whether the return value should place a back-reference on ``self``, to; prevent the latter from going out of scope before the return value does.; The default is ``False``, but will be automatically set at run-time if a; return value's address is a C++ object pointing into the memory of ``this``,; or if ``self`` is a by-value return. * ``__release_gil__``: a flag that every C++ overload carries and determines; whether the Global Interpreter Lock (GIL) should be released during the C++; call to allow multi-threading.; The default is ``False``. * ``__useffi__``: a flag that every C++ overload carries and determines; whether generated wrappers or direct foreign functions should be used.; This is for PyPy only; the flag has no effect on CPython. * ``__sig2exc__``: a flag that every C++ overload carries and determines; whether C++ signals (such as SIGABRT) should be converted into Python; exceptions. * ``__cpp_name__``: a string that every C++ bound class carries and contains; the actual C++ name (as opposed to ``__name__`` which has the Python name).; This can be useful for template instantiations, documentation, etc. * ``__cpp_template__``: a back-reference to the template used to instantiate; a templated class.; This variable only exists if the class was dynamically instantiated from; Python at least once. `STL algorithms`; ----------------. It is usually easier to use a Python equivalent or code up the effect of an; STL algorithm directly, but when operating on a large container, calling an; STL algorithm may offer better performance.; It is important to note that all STL algorithms are templat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/misc.rst:2230,wrap,wrappers,2230,bindings/pyroot/cppyy/cppyy/doc/source/misc.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/misc.rst,1,['wrap'],['wrappers']
Integrability,"om iteration #1) does not have to wait in the; scheduler's queue for the operands to become available. By the time vmulps is; dispatched, operands are already available, and pipeline JFPU1 is ready to; serve another instruction. So the instruction can be immediately issued on the; JFPU1 pipeline. That is demonstrated by the fact that the instruction only; spent 1cy in the scheduler's queue. There is a gap of 5 cycles between the write-back stage and the retire event.; That is because instructions must retire in program order, so [1,0] has to wait; for [0,2] to be retired first (i.e., it has to wait until cycle 10). In the example, all instructions are in a RAW (Read After Write) dependency; chain. Register %xmm2 written by vmulps is immediately used by the first; vhaddps, and register %xmm3 written by the first vhaddps is used by the second; vhaddps. Long data dependencies negatively impact the ILP (Instruction Level; Parallelism). In the dot-product example, there are anti-dependencies introduced by; instructions from different iterations. However, those dependencies can be; removed at register renaming stage (at the cost of allocating register aliases,; and therefore consuming physical registers). Table *Average Wait times* helps diagnose performance issues that are caused by; the presence of long latency instructions and potentially long data dependencies; which may limit the ILP. Last row, ``<total>``, shows a global average over all; instructions measured. Note that :program:`llvm-mca`, by default, assumes at; least 1cy between the dispatch event and the issue event. When the performance is limited by data dependencies and/or long latency; instructions, the number of cycles spent while in the *ready* state is expected; to be very small when compared with the total number of cycles spent in the; scheduler's queue. The difference between the two counters is a good indicator; of how large of an impact data dependencies had on the execution of the; instructions. Whe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst:25210,depend,dependencies,25210,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,1,['depend'],['dependencies']
Integrability,"om_target(clang-bootstrap-deps DEPENDS clang). if(NOT CLANG_STAGE); set(CLANG_STAGE stage1); endif(). string(REGEX MATCH ""stage([0-9]*)"" MATCHED_STAGE ""${CLANG_STAGE}""); if(MATCHED_STAGE); if(NOT LLVM_BUILD_INSTRUMENTED); math(EXPR STAGE_NUM ""${CMAKE_MATCH_1} + 1""); set(NEXT_CLANG_STAGE stage${STAGE_NUM}); else(); set(NEXT_CLANG_STAGE stage${CMAKE_MATCH_1}); endif(); else(); set(NEXT_CLANG_STAGE bootstrap); endif(). if(BOOTSTRAP_LLVM_BUILD_INSTRUMENTED); set(NEXT_CLANG_STAGE ${NEXT_CLANG_STAGE}-instrumented); endif(); message(STATUS ""Setting next clang stage to: ${NEXT_CLANG_STAGE}""). set(STAMP_DIR ${CMAKE_CURRENT_BINARY_DIR}/${NEXT_CLANG_STAGE}-stamps/); set(BINARY_DIR ${CMAKE_CURRENT_BINARY_DIR}/${NEXT_CLANG_STAGE}-bins/). if(BOOTSTRAP_LLVM_ENABLE_LLD); # adding lld to clang-bootstrap-deps without having it enabled in; # LLVM_ENABLE_PROJECTS just generates a cryptic error message.; if (NOT ""lld"" IN_LIST LLVM_ENABLE_PROJECTS); message(FATAL_ERROR ""LLD is enabled in the bootstrap build, but lld is not in LLVM_ENABLE_PROJECTS""); endif(); add_dependencies(clang-bootstrap-deps lld); endif(). if (WIN32); # Build llvm-rc and llvm-mt which are needed by the Windows build.; add_dependencies(clang-bootstrap-deps llvm-rc); if(LLVM_ENABLE_LIBXML2); add_dependencies(clang-bootstrap-deps llvm-mt); endif(); endif(). # If the next stage is LTO we need to depend on LTO and possibly lld or LLVMgold; if(BOOTSTRAP_LLVM_ENABLE_LTO OR LLVM_ENABLE_LTO AND NOT LLVM_BUILD_INSTRUMENTED); if(APPLE); add_dependencies(clang-bootstrap-deps LTO); # on Darwin we need to set DARWIN_LTO_LIBRARY so that -flto will work; # using the just-built compiler, and we need to override DYLD_LIBRARY_PATH; # so that the host object file tools will use the just-built libLTO.; # However if System Integrity Protection is enabled the DYLD variables; # will be scrubbed from the environment of any base system commands. This; # includes /bin/sh, which ninja uses when executing build commands. To; # work around the en",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:21054,message,message,21054,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,1,['message'],['message']
Integrability,"omatically connect your submits to your Phabricator user in; the `Code Repository Browser`_. Requesting a review via the command line; ----------------------------------------. Phabricator has a tool called *Arcanist* to upload patches from; the command line. To get you set up, follow the; `Arcanist Quick Start`_ instructions. You can learn more about how to use arc to interact with; Phabricator in the `Arcanist User Guide`_.; The basic way of creating a revision for the current commit in your local; repository is to run:. ::. arc diff HEAD~. Sometime you may want to create a draft revision to show the proof of concept; or for experimental purposes, In that case you can use the `--draft` option. It; will create a new draft revision. The good part is: it will not send mail to; llvm-commit mailing list, patch reviewers, and all other subscribers, buildbot; will also run on every patch update:. ::. arc diff --draft HEAD~. If you later update your commit message, you need to add the `--verbatim`; option to have `arc` update the description on Phabricator:. ::. arc diff --edit --verbatim. .. _phabricator-request-review-web:. Requesting a review via the web interface; -----------------------------------------. The tool to create and review patches in Phabricator is called; *Differential*. Note that you can upload patches created through git, but using `arc` on the; command line (see previous section) is preferred: it adds more metadata to; Phabricator which are useful for the pre-merge testing system and for; propagating attribution on commits when someone else has to push it for you. To make reviews easier, please always include **as much context as; possible** with your diff! Don't worry, Phabricator; will automatically send a diff with a smaller context in the review; email, but having the full file in the web interface will help the; reviewer understand your code. To get a full diff, use one of the following commands (or just use Arcanist; to upload your patch):. * ``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:2289,message,message,2289,interpreter/llvm-project/llvm/docs/Phabricator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst,1,['message'],['message']
Integrability,"ome MSVC tools other than cl.exe; set(CMAKE_C_COMPILER_LAUNCHER ${CCACHE_PROGRAM}); set(CMAKE_CXX_COMPILER_LAUNCHER ${CCACHE_PROGRAM}); endif(); else(); message(FATAL_ERROR ""Unable to find the program ccache. Set LLVM_CCACHE_BUILD to OFF""); endif(); endif(). set(LLVM_EXTERNAL_PROJECT_BUILD_TOOL_ARGS """" CACHE STRING; ""Optional arguments for the native tool used in CMake --build invocations for external projects.""); mark_as_advanced(LLVM_EXTERNAL_PROJECT_BUILD_TOOL_ARGS). option(LLVM_DEPENDENCY_DEBUGGING ""Dependency debugging mode to verify correctly expressed library dependencies (Darwin only)"" OFF). # Some features of the LLVM build may be disallowed when dependency debugging is; # enabled. In particular you cannot use ccache because we want to force compile; # operations to always happen.; if(LLVM_DEPENDENCY_DEBUGGING); if(NOT CMAKE_HOST_APPLE); message(FATAL_ERROR ""Dependency debugging is only currently supported on Darwin hosts.""); endif(); if(LLVM_CCACHE_BUILD); message(FATAL_ERROR ""Cannot enable dependency debugging while using ccache.""); endif(); endif(). option(LLVM_ENABLE_DAGISEL_COV ""Debug: Prints tablegen patterns that were used for selecting"" OFF); option(LLVM_ENABLE_GISEL_COV ""Enable collection of GlobalISel rule coverage"" OFF); if(LLVM_ENABLE_GISEL_COV); set(LLVM_GISEL_COV_PREFIX ""${CMAKE_BINARY_DIR}/gisel-coverage-"" CACHE STRING ""Provide a filename prefix to collect the GlobalISel rule coverage""); endif(). # Add path for custom modules; list(INSERT CMAKE_MODULE_PATH 0; ""${CMAKE_CURRENT_SOURCE_DIR}/cmake""; ""${CMAKE_CURRENT_SOURCE_DIR}/cmake/modules""; ""${LLVM_COMMON_CMAKE_UTILS}/Modules""; ). # Generate a CompilationDatabase (compile_commands.json file) for our build,; # for use by clang_complete, YouCompleteMe, etc.; set(CMAKE_EXPORT_COMPILE_COMMANDS 1). option(LLVM_INSTALL_BINUTILS_SYMLINKS; ""Install symlinks from the binutils tool names to the corresponding LLVM tools."" OFF). option(LLVM_INSTALL_CCTOOLS_SYMLINKS; ""Install symlinks from the cctools tool ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:12568,message,message,12568,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,2,"['depend', 'message']","['dependency', 'message']"
Integrability,"ome ancestor in the inheritance hierarchy. The argument should; *never* be a derived class or the class itself: the template machinery; for ``isa<>`` already handles this case and optimizes it.; #. For each class in the hierarchy that has no children, implement a; ``classof`` that checks only against its ``Kind``.; #. For each class in the hierarchy that has children, implement a; ``classof`` that checks a range of the first child's ``Kind`` and the; last child's ``Kind``. RTTI for Open Class Hierarchies; ===============================. Sometimes it is not possible to know all types in a hierarchy ahead of time.; For example, in the shapes hierarchy described above the authors may have; wanted their code to work for user defined shapes too. To support use cases; that require open hierarchies LLVM provides the ``RTTIRoot`` and; ``RTTIExtends`` utilities. The ``RTTIRoot`` class describes an interface for performing RTTI checks. The; ``RTTIExtends`` class template provides an implementation of this interface; for classes derived from ``RTTIRoot``. ``RTTIExtends`` uses the ""`Curiously; Recurring Template Idiom`_"", taking the class being defined as its first; template argument and the parent class as the second argument. Any class that; uses ``RTTIExtends`` must define a ``static char ID`` member, the address of; which will be used to identify the type. This open-hierarchy RTTI support should only be used if your use case requires; it. Otherwise the standard LLVM RTTI system should be preferred. .. _`Curiously Recurring Template Idiom`:; https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern. E.g. .. code-block:: c++. class Shape : public RTTIExtends<Shape, RTTIRoot> {; public:; static char ID;; virtual double computeArea() = 0;; };. class Square : public RTTIExtends<Square, Shape> {; double SideLength;; public:; static char ID;. Square(double S) : SideLength(S) {}; double computeArea() override;; };. class Circle : public RTTIExtends<Circle, Shape> {; double",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst:13374,interface,interface,13374,interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst,1,['interface'],['interface']
Integrability,"omeone has to; commit the change for you (with attribution). It is sufficient to add; a comment to the approved review indicating you cannot commit the patch; yourself. If you have commit access, there are multiple workflows to commit the; change. Whichever method you follow it is recommended that your commit message; ends with the line:. ::. Differential Revision: <URL>. where ``<URL>`` is the URL for the code review, starting with; ``https://reviews.llvm.org/``. This allows people reading the version history to see the review for; context. This also allows Phabricator to detect the commit, close the; review, and add a link from the review to the commit. Note that if you use the Arcanist tool the ``Differential Revision`` line will; be added automatically. If you don't want to use Arcanist, you can add the; ``Differential Revision`` line (as the last line) to the commit message; yourself. Using the Arcanist tool can simplify the process of committing reviewed code as; it will retrieve reviewers, the ``Differential Revision``, etc from the review; and place it in the commit message. You may also commit an accepted change; directly using ``git push``, per the section in the :ref:`getting started; guide <commit_from_git>`. Note that if you commit the change without using Arcanist and forget to add the; ``Differential Revision`` line to your commit message then it is recommended; that you close the review manually. In the web UI, under ""Leap Into Action"" put; the git revision number in the Comment, set the Action to ""Close Revision"" and; click Submit. Note the review must have been Accepted first. Committing someone's change from Phabricator; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. On a clean Git repository on an up to date ``main`` branch run the; following (where ``<Revision>`` is the Phabricator review number):. ::. arc patch D<Revision>. This will create a new branch called ``arcpatch-D<Revision>`` based on the; current ``main`` and will create a commit corres",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:14422,message,message,14422,interpreter/llvm-project/llvm/docs/Phabricator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst,1,['message'],['message']
Integrability,"omically) loaded and stored back on entry to the function. This implies that it's possible to introduce spurious stores on entry to; the function without introducing traps or data races. This does not; necessarily hold throughout the whole function, as the pointer may escape; to a different thread during the execution of the function. See also the; :ref:`atomic optimization guide <Optimization outside atomic>`. The ""other attributes"" that imply dereferenceability are; ``dereferenceable_or_null`` (if the pointer is non-null) and the; ``sret``, ``byval``, ``byref``, ``inalloca``, ``preallocated`` family of; attributes. Note that not all of these combinations are useful, e.g.; ``byval`` arguments are known to be writable even without this attribute. The ``writable`` attribute cannot be combined with ``readnone``,; ``readonly`` or a ``memory`` attribute that does not contain; ``argmem: write``. ``dead_on_unwind``; At a high level, this attribute indicates that the pointer argument is dead; if the call unwinds, in the sense that the caller will not depend on the; contents of the memory. Stores that would only be visible on the unwind; path can be elided. More precisely, the behavior is as-if any memory written through the; pointer during the execution of the function is overwritten with a poison; value on unwind. This includes memory written by the implicit write implied; by the ``writable`` attribute. The caller is allowed to access the affected; memory, but all loads that are not preceded by a store will return poison. This attribute cannot be applied to return values. .. _gc:. Garbage Collector Strategy Names; --------------------------------. Each function may specify a garbage collector strategy name, which is simply a; string:. .. code-block:: llvm. define void @f() gc ""name"" { ... }. The supported values of *name* includes those :ref:`built in to LLVM; <builtin-gc-strategies>` and any provided by loaded plugins. Specifying a GC; strategy will cause the compiler to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:71199,depend,depend,71199,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['depend']
Integrability,"ommits that violate these quality standards (e.g. are very broken) may be; reverted. This is necessary when the change blocks other developers from making; progress. The developer is welcome to re-commit the change after the problem has; been fixed. .. _commit messages:. Commit messages; ---------------. Although we don't enforce the format of commit messages, we prefer that; you follow these guidelines to help review, search in logs, email formatting; and so on. These guidelines are very similar to rules used by other open source; projects. Most importantly, the contents of the message should be carefully written to; convey the rationale of the change (without delving too much in detail). It; also should avoid being vague or overly specific. For example, ""bits were not; set right"" will leave the reviewer wondering about which bits, and why they; weren't right, while ""Correctly set overflow bits in TargetInfo"" conveys almost; all there is to the change. Below are some guidelines about the format of the message itself:. * Separate the commit message into title and body separated by a blank line. * If you're not the original author, ensure the 'Author' property of the commit is; set to the original author and the 'Committer' property is set to yourself.; You can use a command similar to; ``git commit --amend --author=""John Doe <jdoe@llvm.org>""`` to correct the; author property if it is incorrect. See `Attribution of Changes`_ for more; information including the method we used for attribution before the project; migrated to git. In the rare situation where there are multiple authors, please use the `git; tag 'Co-authored-by:' to list the additional authors; <https://github.blog/2018-01-29-commit-together-with-co-authors/>`_. * The title should be concise. Because all commits are emailed to the list with; the first line as the subject, long titles are frowned upon. Short titles; also look better in `git log`. * When the changes are restricted to a specific part of the co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:15554,message,message,15554,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['message'],['message']
Integrability,"ompiler-rt;cross-project-tests;libc;libclc;lld;lldb;mlir;openmp;polly;pstl""); # The flang project is not yet part of ""all"" projects (see C++ requirements); set(LLVM_EXTRA_PROJECTS ""flang""); # List of all known projects in the mono repo; set(LLVM_KNOWN_PROJECTS ""${LLVM_ALL_PROJECTS};${LLVM_EXTRA_PROJECTS}""); set(LLVM_ENABLE_PROJECTS """" CACHE STRING; ""Semicolon-separated list of projects to build (${LLVM_KNOWN_PROJECTS}), or \""all\"".""); # Make sure expansion happens first to not handle ""all"" in rest of the checks.; if( LLVM_ENABLE_PROJECTS STREQUAL ""all"" ); set( LLVM_ENABLE_PROJECTS ${LLVM_ALL_PROJECTS}); endif(); foreach(proj ${LLVM_ENABLE_PROJECTS}); if (NOT proj STREQUAL ""llvm"" AND NOT ""${proj}"" IN_LIST LLVM_KNOWN_PROJECTS); MESSAGE(FATAL_ERROR ""${proj} isn't a known project: ${LLVM_KNOWN_PROJECTS}. Did you mean to enable it as a runtime in LLVM_ENABLE_RUNTIMES?""); endif(); endforeach(). if (""flang"" IN_LIST LLVM_ENABLE_PROJECTS); if (NOT ""mlir"" IN_LIST LLVM_ENABLE_PROJECTS); message(STATUS ""Enabling MLIR as a dependency to flang""); list(APPEND LLVM_ENABLE_PROJECTS ""mlir""); endif(). if (NOT ""clang"" IN_LIST LLVM_ENABLE_PROJECTS); message(FATAL_ERROR ""Clang is not enabled, but is required for the Flang driver""); endif(); endif(). # Select the runtimes to build; #; # As we migrate runtimes to using the bootstrapping build, the set of default runtimes; # should grow as we remove those runtimes from LLVM_ENABLE_PROJECTS above.; set(LLVM_DEFAULT_RUNTIMES ""libcxx;libcxxabi;libunwind""); set(LLVM_SUPPORTED_RUNTIMES ""libc;libunwind;libcxxabi;pstl;libcxx;compiler-rt;openmp;llvm-libgcc""); set(LLVM_ENABLE_RUNTIMES """" CACHE STRING; ""Semicolon-separated list of runtimes to build, or \""all\"" (${LLVM_DEFAULT_RUNTIMES}). Supported runtimes are ${LLVM_SUPPORTED_RUNTIMES}.""); if(LLVM_ENABLE_RUNTIMES STREQUAL ""all""); set(LLVM_ENABLE_RUNTIMES ${LLVM_DEFAULT_RUNTIMES}); endif(); foreach(proj IN LISTS LLVM_ENABLE_RUNTIMES); if (NOT ""${proj}"" IN_LIST LLVM_SUPPORTED_RUNTIMES); message(FATAL_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:6328,message,message,6328,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,2,"['depend', 'message']","['dependency', 'message']"
Integrability,"on 5.32/00 has been released on November 29, 2011.; In case you are upgrading from an old version, please read the releases notes; of version 5.26, 5,28 and version 5.30 in addition to these notes. The release of version 5.34 is scheduled for May 30, 2012. Bindings - packages related to the interplay with other programming languages (Python, Ruby); Cint - the C++ interpreter; Core - the basic ROOT functionality; Geometry - building, representing and drawing geometrical objects; 2D Graphics - ROOT's two dimensional graphics interface; 3D Graphics - ROOT's three dimensional graphics interface; Graphical User Interface - from basic GUI elements to ROOT's own, complete dialogs; Histograming - counting values, spectra, and drawing them; HTML - the documentation generator; Input/Ouput - storing and reading data; Mathemathics - everything one can use to calculate: minimizers, matrixes, FFT, and much more; Miscellaneous - things that didn't make it into the other groups: table ; Monte Carlo - monte carlo and physics simulation interfaces; Networking - network-related parts, e.g. protocols and authentication interfaces; PROOF - parallel ROOT facility; RooFit - a fitting library; RooStats - a collection of statistical tools ; SQL - database interfaces; TMVA - multivariate analysis tools; Trees - ROOT's unique container class and related utilities; Tutorials - ROOT's Tutorials. For more information, see:. http://root.cern.ch; The following people have contributed to this new version:; Bertrand Bellenot, CERN/SFT,; Rene Brun, CERN/SFT,; Philippe Canal, FNAL,; Olivier Couet, CERN/SFT,; Kyle Cranmer, NYU, RooStats,; Gerri Ganis, CERN/SFT,; Andrei Gheata, CERN/Alice,; Wim Lavrijsen, LBNL, PyRoot,; Lorenzo Moneta, CERN/SFT,; Axel Naumann, CERN/SFT,; Fons Rademakers, CERN/SFT,; Paul Russo, FNAL, ; Joerg Stelzer, DESY/Atlas, TMVA, ; Alja Tadel, UCSD/CMS, Eve, ; Matevz Tadel, UCSD/CMS, Eve, ; Eckhard von Toerne, University Bonn, ATLAS, TMVA, ; Wouter Verkerke, NIKHEF/Atlas, RooFit, ; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/doc/v534/index.html:1271,protocol,protocols,1271,doc/v534/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/doc/v534/index.html,6,"['interface', 'protocol']","['interfaces', 'protocols']"
Integrability,on MyClass2; - (float)foo { return 1.0; } // warn; @end. osx.cocoa.MissingSuperCall; (ObjC); Warn about Objective-C methods that lack a necessary call to super. (Note: The; compiler now has a warning for methods annotated with objc_requires_super; attribute. The checker exists to check methods in the Cocoa frameworks; that haven't yet adopted this attribute.). @interface Test : UIViewController; @end; @implementation test; - (void)viewDidLoad {} // warn; @end. osx.cocoa.NSAutoreleasePool; (ObjC); Warn for suboptimal uses of NSAutoreleasePool in Objective-C; GC mode (-fobjc-gc compiler option). void test() {; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; [pool release]; // warn; }. osx.cocoa.NSError; (ObjC); Check usage of NSError** parameters. @interface A : NSObject; - (void)foo:(NSError **)error;; @end. @implementation A; - (void)foo:(NSError **)error {; // warn: method accepting NSError** should have a non-void; // return value; }; @end. @interface A : NSObject; - (BOOL)foo:(NSError **)error;; @end. @implementation A; - (BOOL)foo:(NSError **)error {; *error = 0; // warn: potential null dereference; return 0;; }; @end. osx.cocoa.NilArg; (ObjC); Check for prohibited nil arguments in specific Objective-C method calls:; - caseInsensitiveCompare:; - compare:; - compare:options:; - compare:options:range:; - compare:options:range:locale:; - componentsSeparatedByCharactersInSet:; - initWithFormat:. NSComparisonResult test(NSString *s) {; NSString *aString = nil;; return [s caseInsensitiveCompare:aString];; // warn: argument to 'NSString' method; // 'caseInsensitiveCompare:' cannot be nil; }. osx.cocoa.ObjCGenerics; (ObjC); Check for type errors when using Objective-C generics. NSMutableArray *names = [NSMutableArray array];; NSMutableArray *birthDates = names;. // Warning: Conversion from value of type 'NSDate *'; // to incompatible type 'NSString *'; [birthDates addObject: [NSDate date]];. osx.cocoa.RetainCount; (ObjC); Check for leaks and violations of th,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:17273,interface,interface,17273,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,2,['interface'],['interface']
Integrability,"on Pygments' horrible `llvm` lexer. It just totally gives up; on highlighting this due to the first line. ::. ready> ^D; ; ModuleID = 'my cool jit'. define double @0() {; entry:; %addtmp = fadd double 4.000000e+00, 5.000000e+00; ret double %addtmp; }. define double @foo(double %a, double %b) {; entry:; %multmp = fmul double %a, %a; %multmp1 = fmul double 2.000000e+00, %a; %multmp2 = fmul double %multmp1, %b; %addtmp = fadd double %multmp, %multmp2; %multmp3 = fmul double %b, %b; %addtmp4 = fadd double %addtmp, %multmp3; ret double %addtmp4; }. define double @bar(double %a) {; entry:; %calltmp = call double @foo(double %a, double 4.000000e+00); %calltmp1 = call double @bar(double 3.133700e+04); %addtmp = fadd double %calltmp, %calltmp1; ret double %addtmp; }. declare double @cos(double). define double @1() {; entry:; %calltmp = call double @cos(double 1.234000e+00); ret double %calltmp; }. When you quit the current demo (by sending an EOF via CTRL+D on Linux; or CTRL+Z and ENTER on Windows), it dumps out the IR for the entire; module generated. Here you can see the big picture with all the; functions referencing each other. This wraps up the third chapter of the Kaleidoscope tutorial. Up next,; we'll describe how to `add JIT codegen and optimizer; support <LangImpl04.html>`_ to this so we can actually start running; code!. Full Code Listing; =================. Here is the complete code listing for our running example, enhanced with; the LLVM code generator. Because this uses the LLVM libraries, we need; to link them in. To do this, we use the; `llvm-config <https://llvm.org/cmds/llvm-config.html>`_ tool to inform; our makefile/command line about which options to use:. .. code-block:: bash. # Compile; clang++ -g -O3 toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core` -o toy; # Run; ./toy. Here is the code:. .. literalinclude:: ../../../examples/Kaleidoscope/Chapter3/toy.cpp; :language: c++. `Next: Adding JIT and Optimizer Support <LangImpl04.html>`_. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:20855,wrap,wraps,20855,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['wrap'],['wraps']
Integrability,"on and opening our packs, we will obviously find out some empty ones,; otherwise, something is very wrong... We will call these leaves (by; analogy with a tree structure). On the other hand, any volume is a small world by itself - what we need; to do is to take it out and to ignore all the rest since it is a; self-contained object. In fact, the modeller can act like this,; considering a given volume as temporary MARS, but we will describe this; feature later on. Let us focus on the biggest pack - it is mandatory to; define one. Consider the simplest geometry that is made of a single box.; Here is an example on how to build it:. \anchor GP00a; ### Example 1: Creating the World. We first need to load the geometry library. This is not needed if one; does ""make map"" in root folder. ~~~{.cpp}; root[] gSystem->Load(""libGeom"");; ~~~. Second, we have to create an instance of the geometry manager class.; This takes care of all the modeller components, performing several tasks; to insure geometry validity and containing the user interface for; building and interacting with the geometry. After its creation, the; geometry manager class can be accessed with the global; `gGeoManager`:. ~~~{.cpp}; root[] new TGeoManager(""world"", ""the simplest geometry"");; ~~~. We want to create a single volume in our geometry, but since any volume; needs to have an associated medium, we will create a dummy one. You can; safely ignore the following lines for the time being, since materials; and media will be explained in detail later on. ~~~{.cpp}; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; ~~~. We can finally make our volume having a box shape. Note that the world; volume does not need to be a box - it can be any other shape. Generally,; boxes and tubes are the most recommendable shapes for this purpose due; to their fast navigation algorithms. ~~~{.cpp}; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,10.,10.);",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:5256,interface,interface,5256,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['interface'],['interface']
Integrability,"on case) do not incur the overhead in PyPy's JIT-ed traces that is; otherwise unavoidable for multiple virtual inheritance.; As another example, consider that the C++ standard does not allow modifying; a ``std::vector`` while looping over it, whereas Python has no such; restriction, complicating loops.; Thus, cppyy has specialized ``std::vector`` iteration for both PyPy and; CPython, easily outperforming looping over an equivalent numpy array. In CPython, the performance of `non-overloaded` function calls depends; greatly on the Python interpreter's internal specializations; and Python3; has many specializations specific to basic extension modules (C function; pointer calls), gaining a performance boost of more than 30% over Python2.; Only since Python3.8 is there also better support for closure objects (vector; calls) as cppyy uses, to short-cut through the interpreter's own overhead. As a practical consideration, whether a binder performs well on code that you; care about, depends `entirely` on whether it has the relevant specializations; for your most performance-sensitive use cases.; The only way to know for sure is to write a test application and measure, but; a binder that provides more specializations, or makes it easy to add your; own, is more likely to deliver. `Manual v.s. automatic`; -----------------------. Python is, today, one of the most popular programming languages and has a; rich and mature eco-system around it.; But when the project that became cppyy started in the field of High Energy; Physics (HEP), Python usage was non-existent there.; As a Python user to work in this predominantly C++ environment, you had to; bring your own bindings, thus automatic was the only way to go.; Binders such as SWIG, SIP (or even boost.python with Pyste) all had the fatal; assumption that you were providing Python bindings to your `own` C++ code,; and that you were thus able to modify those (many) areas of the C++ codes; that their parsers could not handle.; The `CIN",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst:4216,depend,depends,4216,bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,1,['depend'],['depends']
Integrability,"on is not exposed. This prevents inadvertent use of system; specific functionality. For example, the ``stat`` system call is notorious for having variations in the; data it provides. ``lib/Support`` must not declare ``stat`` nor allow it to be; declared. Instead it should provide its own interface to discovering; information about files and directories. Those interfaces may be implemented in; terms of ``stat`` but that is strictly an implementation detail. The interface; provided by the Support Library must be implemented on all platforms (even; those without ``stat``). No Exposed Data; ---------------. Any data defined by system libraries (i.e. not defined by ``lib/Support``) must; not be exposed through the ``lib/Support`` interface, even if the header file; for that function is not exposed. As with functions, this prevents inadvertent; use of data that might not exist on all platforms. Minimize Soft Errors; --------------------. Operating system interfaces will generally provide error results for every; little thing that could go wrong. In almost all cases, you can divide these; error results into two groups: normal/good/soft and abnormal/bad/hard. That is,; some of the errors are simply information like ""file not found"", ""insufficient; privileges"", etc. while other errors are much harder like ""out of space"", ""bad; disk sector"", or ""system call interrupted"". We'll call the first group ""*soft*""; errors and the second group ""*hard*"" errors. ``lib/Support`` must always attempt to minimize soft errors. This is a design; requirement because the minimization of soft errors can affect the granularity; and the nature of the interface. In general, if you find that you're wanting to; throw soft errors, you must review the granularity of the interface because it; is likely you're trying to implement something that is too low level. The rule; of thumb is to provide interface functions that **can't** fail, except when; faced with hard errors. For a trivial example, suppose we",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:7270,interface,interfaces,7270,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['interface'],['interfaces']
Integrability,"on of fit including covariance matrix; r->Write(); // store the result in a file; ```. ## The Minimization packages. As explained before various minimization packages can be used when fitting in ROOT.; We have seen before how to configure the `Fitter` class to use different minimization packages; and different minimization options.; When using the `Fit` method the minimization package (and its options) can be selected using the; static methods of the `ROOT::Math::MinimizerOptions` class.; For example to select `Minuit2` instead of `Minuit` for fitting an histogram do:. ``` {.cpp}; ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""Minuit2"");; // fit the histogram histo with the gaussian pre-defined function; histo->Fit(""gaus"");; ```. In the following we will give some brief description of the minimization packages.; The packages all implement the `ROOT::Math::Minimizer` interface which can be use for; finding the minimum of a multi-dimensional function.; The interface is documented in the Mathematical Library Chapter. In addition packages like Minuit or Minuit2 provide their own interfaces. ## MINUIT (Old TMInuit Version). This package was originally written in FORTRAN by Fred James and part; of `PACKLIB` (patch D506). It has been converted to a C++ class by; René Brun. The current implementation in C++ is a straightforward; conversion of the original FORTRAN version. The main changes are:. - The variables in the various `Minuit` labeled common blocks have; been changed to the **`TMinuit`** class data members. - The internal arrays with a maximum dimension depending on the; maximum number of parameters are now data members' arrays with a; dynamic dimension such that one can fit very large problems by; simply initializing the **`TMinuit`** constructor with the maximum; number of parameters. - The include file `Minuit.h` has been commented as much as possible; using existing comments in the code or the printed documentation. - The original `Minuit` subroutines are now",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:52821,interface,interface,52821,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['interface'],['interface']
Integrability,"on provides basically; all the functionality present in the old Fortran version, with almost equivalent; numerical accuracy and computational performances. Furthermore, it contains new; functionality, like the possibility to set single side parameter limits or the; FUMILI algorithm, which is an optimized method for least square and log likelihood; minimizations. The package has been originally developed by M. Winkler and F. James.; More information on the new C++ version can be found on the; [MINUIT Web Site](http://www.cern.ch/minuit). Minuit2, originally developed in the SEAL project, is now distributed within %ROOT.; The API has been then changed in this new version to follow the %ROOT coding convention; (function names starting with capital letters) and the classes have been moved inside; the namespace _ROOT::Minuit2_. In addition, the %ROOT distribution contains classes; needed to integrate Minuit2 in the %ROOT framework. A new class has been introduced, ROOT::Minuit2::Minuit2Minimizer, which implements; the interface ROOT::Math::Minimizer. Within %ROOT, it can be instantiates also using; the %ROOT plug-in manager. This class provides a convenient entry point for using Minuit2\.; An example of using this interface is the %ROOT tutorial _tutorials/fit/NumericalMinimization.C_; or the Minuit2 test program; [<tt>testMinimize.cxx</tt>](https://github.com/cxx-hep/root-cern/blob/master/math/minuit2/test/testMinimize.cxx). A standalone version of Minuit2 (independent of %ROOT) can be easily built and installed using `CMake`. See this [`README`](https://github.com/root-project/root/blob/master/math/minuit2/README.md) for the instructions on how to get the sources, building and installing a stand-alone Minuit2. The [Minuit2 User Guide](https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html); provides all the information needed for using directly (without add-on packages like %ROOT) Minuit2. ## References. 1. F. James, _Fortran MINUIT Reference Manual_ ([html](https:/",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/doc/Minuit2.md:1197,interface,interface,1197,math/minuit2/doc/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/doc/Minuit2.md,1,['interface'],['interface']
Integrability,"on to these notes. Bindings - packages related to the interplay with other programming languages (Python, Ruby); Cint - the C++ interpreter; Core - the basic ROOT functionality; Geometry - building, representing and drawing geometrical objects; 2D Graphics - ROOT's two dimensional graphics interface; 3D Graphics - ROOT's three dimensional graphics interface; Graphical User Interface - from basic GUI elements to ROOT's own, complete dialogs; Histograming - counting values, spectra, and drawing them; HTML - the documentation generator; Input/Ouput - storing and reading data; Mathemathics - everything one can use to calculate: minimizers, matrixes, FFT, and much more; Miscellaneous - things that didn't make it into the other groups: table ; Monte Carlo - monte carlo and physics simulation interfaces; Networking - network-related parts, e.g. protocols and authentication interfaces; PROOF - parallel ROOT facility; RooFit - a fitting library; RooStats - a collection of statistical tools ; SQL - database interfaces; TMVA - multivariate analysis tools; Trees - ROOT's unique container class and related utilities; Tutorials - ROOT's Tutorials. Binaries for all supported platforms are available at:. https://root.cern/releases/release-52800/. For more information, see:. http://root.cern.ch; The following people have contributed to this new version:; Alberto Annovi, INFN, TH1, ; Kevin Belasco, Princeton University, RooStats,; Bertrand Bellenot, CERN/SFT,; Rene Brun, CERN/SFT,; Philippe Canal, FNAL,; Olivier Couet, CERN/SFT,; Kyle Cranmer, NYU, RooStats,; Jason Detwiler, LBL, TClonesArray, ; Valeri Fine, BNL/STAR,; Fabrizio Furano, CERN/IT, ; Gerri Ganis, CERN/SFT,; Andrei Gheata, CERN/Alice,; Oleksandr Grebenyuk, GSI, TLatex, TPostScript, ; Christian Gumpert, CERN and University Dresden, TEfficiency ; Bill Heintzelman, UPENN, TTree, ; Andreas Hoecker, CERN/Atlas, TMVA, ; Pierre Juillot, IN2P3, PostScript, ; Folkert Koetsveld, Nijmegen, RooFit, ; Alex Koutsman, Nikhef, RooFit, ; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/doc/v528/index.html:1229,protocol,protocols,1229,doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/doc/v528/index.html,6,"['interface', 'protocol']","['interfaces', 'protocols']"
Integrability,"on value <poisonvalues>` if one of the following rules is violated:. * The base pointer has an *in bounds* address of an allocated object, which; means that it points into an allocated object, or to its end. Note that the; object does not have to be live anymore; being in-bounds of a deallocated; object is sufficient.; * If the type of an index is larger than the pointer index type, the; truncation to the pointer index type preserves the signed value.; * The multiplication of an index by the type size does not wrap the pointer; index type in a signed sense (``nsw``).; * The successive addition of each offset (without adding the base address) does; not wrap the pointer index type in a signed sense (``nsw``).; * The successive addition of the current address, interpreted as an unsigned; number, and each offset, interpreted as a signed number, does not wrap the; unsigned address space and remains *in bounds* of the allocated object.; As a corollary, if the added offset is non-negative, the addition does not; wrap in an unsigned sense (``nuw``).; * In cases where the base is a vector of pointers, the ``inbounds`` keyword; applies to each of the computations element-wise. Note that ``getelementptr`` with all-zero indices is always considered to be; ``inbounds``, even if the base pointer does not point to an allocated object.; As a corollary, the only pointer in bounds of the null pointer in the default; address space is the null pointer itself. These rules are based on the assumption that no allocated object may cross; the unsigned address space boundary, and no allocated object may be larger; than half the pointer index type space. If the ``inrange`` keyword is present before any index, loading from or; storing to any pointer derived from the ``getelementptr`` has undefined; behavior if the load or store would access memory outside of the bounds of; the element selected by the index marked as ``inrange``. The result of a; pointer comparison or ``ptrtoint`` (including ``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:438222,wrap,wrap,438222,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['wrap'],['wrap']
Integrability,"on, one could enable monitoring flag in the browser - then objects view will be regularly updated. ## Accessing file system. THttpServer provides partial access to the files from file system.; First of all, JSROOT scripts and files can be accessed via ""jsrootsys/"" path like ""http://localhost:8080/jsrootsys/modules/core.mjs"".; Files from ROOT install directory can be get via ""rootsys/"" path like ""http://localhost:8080/rootsys/icons/about.xpm"".; Also files from current directory where ROOT is running can be accessed via ""currentdir/"" path like ""http://localhost:8080/currentdir/file.txt"". If necessary, one can add custom path as well, using [THttpServer::AddLocation](https://root.cern/doc/master/classTHttpServer.html#a5322c3bbfddb8eb6849297d83ccaf87f) method:. ```cpp; serv->AddLocation(""mydir/"", ""/home/user/specials"");; ```. Then files from that directory could be addressed via URL like ""http://localhost:8080/mydir/myfile.root"". ## Command interface. THttpServer class provide simple interface to invoke command from web browser.; One just register command like:. ```cpp; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"");; ```. Element with name `DoSomething` will appear in the web browser and can be clicked.; It will result in `gROOT->ProcessLineSync(""SomeFunction()"")` call. One could configure argument(s) for the command.; For that one should use `%arg1`, `%arg2` and so on identifiers. Like:. ```cpp; serv->RegisterCommand(""/DoSomething"", ""SomeFunction(%arg1%,%arg2%)"");; ```. User will be requested to enter arguments values, when command element clicked in the browser.; Example of the command which executes arbitrary string in application via ProcessLine looks like:. ```cpp; serv->RegisterCommand(""/Process"", ""%arg1%"");; ```. When registering command, one could specify icon name which will be displayed with the command. ```cpp; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"", ""rootsys/icons/ed_execute.png"");; ```. In example usage of images from `$ROOTSYS/icon",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:4941,interface,interface,4941,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['interface'],['interface']
Integrability,"on, please; open a GitHub issue about this, as such a performance regression is considered; a bug. ### Asymptotically correct uncertainties for extended unbinned likelihood fits. Added correct treatment of extended term in asymptotically correct method for uncertainty determination in the presence of weights.; This improvement will allow for extended unbinned maximum likelihood fits to use the asymptotically correct method when using the `RooFit::AsymptoticError()` command argument in [RooAbsPdf::fitTo()](https://root.cern.ch/doc/master/classRooAbsPdf.html#ab0721374836c343a710f5ff92a326ff5).; See also this [writeup on extended weighted fits](https://root.cern/files/extended_weighted_fits.pdf) that is also linked from the reference guide.; The [pull request](https://github.com/root-project/root/pull/14751) that introduced this feature might also be a good reference. ### Compile your code with memory safe interfaces. If you define the `ROOFIT_MEMORY_SAFE_INTERFACES` preprocessor macro, the; RooFit interface changes in a way such that memory leaks are avoided. The most prominent effect of this change is that many functions that used to; return an owning pointer (e.g., a pointer to an object that you need to; manually `delete`) are then returning a `std::unique_pt` for automatic memory; management. For example this code would not compile anymore, because there is the risk that; the caller forgets to `delete params`:; ```c++; RooArgSet * params = pdf.getParameters(nullptr);; ```; If you wrap such return values in a `std::unique_ptr`, then your code will; compile both with and without memory safe interfaces:; ```c++; std::unique_ptr<RooArgSet> params{pdf.getParameters(nullptr)};; ```. Also some `virtual` RooFit functions like [RooAbsReal::createIntegral()](https://root.cern.ch/doc/master/classRooAbsReal.html#aff4be07dd6a131721daeeccf6359aea9); are returning a different type conditional on `ROOFIT_MEMORY_SAFE_INTERFACES`.; If you are overriding such a function, you need to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:8510,interface,interface,8510,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['interface'],['interface']
Integrability,"on. Given; void x(int, int, int) { int y; x(1, y, 42); }; callExpr(hasAnyArgument(declRefExpr())); matches x(1, y, 42); with hasAnyArgument(...); matching y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end; void foo(I *i) { [i f:12]; }; objcMessageExpr(hasAnyArgument(integerLiteral(equals(12)))); matches [i f:12]. Matcher<ObjCMessageExpr>hasArgumentunsigned N, Matcher<Expr> InnerMatcher; Matches the n'th argument of a call expression or a constructor; call expression. Example matches y in x(y); (matcher = callExpr(hasArgument(0, declRefExpr()))); void x(int) { int y; x(y); }. Matcher<ObjCMessageExpr>hasReceiverMatcher<Expr> InnerMatcher; Matches if the Objective-C message is sent to an instance,; and the inner matcher matches on that instance. For example the method call in; NSString *x = @""hello"";; [x containsString:@""h""];; is matched by; objcMessageExpr(hasReceiver(declRefExpr(to(varDecl(hasName(""x"")))))). Matcher<ObjCMessageExpr>hasReceiverTypeMatcher<QualType> InnerMatcher; Matches on the receiver of an ObjectiveC Message expression. Example; matcher = objCMessageExpr(hasReceiverType(asString(""UIWebView *"")));; matches the [webView ...] message invocation.; NSString *webViewJavaScript = ...; UIWebView *webView = ...; [webView stringByEvaluatingJavaScriptFromString:webViewJavascript];. Matcher<ObjCMethodDecl>hasAnyParameterMatcher<ParmVarDecl> InnerMatcher; Matches any parameter of a function or an ObjC method declaration or a; block. Does not match the 'this' parameter of a method. Given; class X { void f(int x, int y, int z) {} };; cxxMethodDecl(hasAnyParameter(hasName(""y""))); matches f(int x, int y, int z) {}; with hasAnyParameter(...); matching int y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end. the matcher objcMethodDecl(hasAnyParameter(hasName(""y""))); matches the declaration of method f with hasParameter; matching y. For blocks, given; b = ^(int y) { printf(""%d"", y) };. the matcher blockDecl(hasAnyParameter(hasName(""y""))); matc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:221867,Message,Message,221867,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Message'],['Message']
Integrability,"on.h""; ""${CMAKE_CURRENT_BINARY_DIR}/arm_fp16.h""; ). list(APPEND arm_only_generated_files; ""${CMAKE_CURRENT_BINARY_DIR}/arm_mve.h""; ""${CMAKE_CURRENT_BINARY_DIR}/arm_cde.h""; ). list(APPEND aarch64_only_generated_files; ""${CMAKE_CURRENT_BINARY_DIR}/arm_sve.h""; ""${CMAKE_CURRENT_BINARY_DIR}/arm_sme.h""; ""${CMAKE_CURRENT_BINARY_DIR}/arm_bf16.h""; ""${CMAKE_CURRENT_BINARY_DIR}/arm_vector_types.h""; ); endif(); if(RISCV IN_LIST LLVM_TARGETS_TO_BUILD); # Generate riscv_vector.h; clang_generate_header(-gen-riscv-vector-header riscv_vector.td riscv_vector.h); list(APPEND riscv_generated_files; ""${CMAKE_CURRENT_BINARY_DIR}/riscv_vector.h""; ); endif(). # Check if the generated headers are included in a target specific lists; # Currently, all generated headers are target specific.; set(all_target_specific_generated_files; ${arm_common_generated_files}; ${arm_only_generated_files}; ${aarch64_only_generated_files}; ${riscv_generated_files}); foreach( f ${generated_files} ); if (NOT ${f} IN_LIST all_target_specific_generated_files); message(WARNING ""${f} is a generated header but it is not included in any ""; ""target specific header lists! The resource-headers ""; ""distribtion target will be incorrect!""); endif(); endforeach( f ). function(add_header_target target_name file_list); add_custom_target(${target_name} DEPENDS ${file_list}); set_target_properties(${target_name} PROPERTIES; FOLDER ""Misc""; RUNTIME_OUTPUT_DIRECTORY ""${output_dir}""); endfunction(). # The catch-all clang-resource-headers target; add_custom_target(""clang-resource-headers"" ALL DEPENDS ${out_files}); set_target_properties(""clang-resource-headers"" PROPERTIES; FOLDER ""Misc""; RUNTIME_OUTPUT_DIRECTORY ""${output_dir}""); add_dependencies(""clang-resource-headers""; ""core-resource-headers""; ""arm-common-resource-headers""; ""arm-resource-headers""; ""aarch64-resource-headers""; ""cuda-resource-headers""; ""hexagon-resource-headers""; ""hip-resource-headers""; ""hlsl-resource-headers""; ""loongarch-resource-headers""; ""mips-resource-headers""; """,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/CMakeLists.txt:8916,message,message,8916,interpreter/llvm-project/clang/lib/Headers/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/CMakeLists.txt,1,['message'],['message']
Integrability,"on:: -register-info-debug. Make -gen-register-info dump register information for debugging. .. option:: -gen-searchable-tables. Generate generic searchable tables. See :doc:`TableGen BackEnds <../TableGen/BackEnds>`; for a detailed description. .. option:: -gen-subtarget. Generate subtarget enumerations. .. option:: -gen-x86-EVEX2VEX-tables. Generate X86 EVEX to VEX compress tables. .. option:: -gen-x86-fold-tables. Generate X86 fold tables. .. option:: -long-string-literals. When emitting large string tables, prefer string literals over; comma-separated char literals. This can be a readability and; compile-time performance win, but upsets some compilers. .. option:: -print-enums. Print enumeration values for a class. .. option:: -class=classname. Make -print-enums print the enumeration list for the specified class. .. option:: -print-sets. Print expanded sets for testing DAG exprs. mlir-tblgen Options; ~~~~~~~~~~~~~~~~~~~. .. option:: -gen-avail-interface-decls. Generate availability interface declarations. .. option:: -gen-avail-interface-defs. Generate op interface definitions. .. option:: -gen-dialect-doc. Generate dialect documentation. .. option:: -dialect. The dialect to generate. .. option:: -gen-directive-decl. Generate declarations for directives (OpenMP, etc.). .. option:: -gen-enum-decls. Generate enum utility declarations. .. option:: -gen-enum-defs. Generate enum utility definitions. .. option:: -gen-enum-from-llvmir-conversions. Generate conversions of EnumAttrs from LLVM IR. .. option:: -gen-enum-to-llvmir-conversions. Generate conversions of EnumAttrs to LLVM IR. .. option:: -gen-llvmir-conversions. Generate LLVM IR conversions. .. option:: -gen-llvmir-intrinsics. Generate LLVM IR intrinsics. .. option:: -llvmir-intrinsics-filter. Only keep the intrinsics with the specified substring in their record name. .. option:: -dialect-opclass-base. The base class for the ops in the dialect we are to emit. .. option:: -gen-op-decls. Generate operation declara",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/tblgen.rst:12936,interface,interface,12936,interpreter/llvm-project/llvm/docs/CommandGuide/tblgen.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/tblgen.rst,1,['interface'],['interface']
Integrability,"on; defaults to 0.; ``-only_ascii``; If 1, generate only ASCII (``isprint``+``isspace``) inputs. Defaults to 0.; ``-artifact_prefix``; Provide a prefix to use when saving fuzzing artifacts (crash, timeout, or; slow inputs) as ``$(artifact_prefix)file``. Defaults to empty.; ``-exact_artifact_path``; Ignored if empty (the default). If non-empty, write the single artifact on; failure (crash, timeout) as ``$(exact_artifact_path)``. This overrides; ``-artifact_prefix`` and will not use checksum in the file name. Do not use; the same path for several parallel processes.; ``-print_pcs``; If 1, print out newly covered PCs. Defaults to 0.; ``-print_final_stats``; If 1, print statistics at exit. Defaults to 0.; ``-detect_leaks``; If 1 (default) and if LeakSanitizer is enabled; try to detect memory leaks during fuzzing (i.e. not only at shut down).; ``-close_fd_mask``; Indicate output streams to close at startup. Be careful, this will; remove diagnostic output from target code (e.g. messages on assert failure). - 0 (default): close neither ``stdout`` nor ``stderr``; - 1 : close ``stdout``; - 2 : close ``stderr``; - 3 : close both ``stdout`` and ``stderr``. For the full list of flags run the fuzzer binary with ``-help=1``. Output; ======. During operation the fuzzer prints information to ``stderr``, for example::. INFO: Seed: 1523017872; INFO: Loaded 1 modules (16 guards): [0x744e60, 0x744ea0),; INFO: -max_len is not provided, using 64; INFO: A corpus is not provided, starting from an empty corpus; #0	READ units: 1; #1	INITED cov: 3 ft: 2 corp: 1/1b exec/s: 0 rss: 24Mb; #3811	NEW cov: 4 ft: 3 corp: 2/2b exec/s: 0 rss: 25Mb L: 1 MS: 5 ChangeBit-ChangeByte-ChangeBit-ShuffleBytes-ChangeByte-; #3827	NEW cov: 5 ft: 4 corp: 3/4b exec/s: 0 rss: 25Mb L: 2 MS: 1 CopyPart-; #3963	NEW cov: 6 ft: 5 corp: 4/6b exec/s: 0 rss: 25Mb L: 2 MS: 2 ShuffleBytes-ChangeBit-; #4167	NEW cov: 7 ft: 6 corp: 5/9b exec/s: 0 rss: 25Mb L: 3 MS: 1 InsertByte-; ... The early parts of the output include informat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:14343,message,messages,14343,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['message'],['messages']
Integrability,"on; grows with the cube of the number of fitted parameters. For example, the; fit of large number of parameters (2068) for data in Figure 5.8 using awmi; algorithm took about 12 hours (using 450 MHz PC). The calculation; using matrix inversion method is not realizable in any reasonable time. # TRANSFORMS. ## 1-DIMENSIONAL SPECTRA. Orthogonal transforms can be successfully used for the; processing of nuclear spectra. They can be used to remove high; frequency noise, to increase signal-to-background ratio as well as to; enhance low intensity components [14]. We have implemented also the; function for the calculation of the commonly used orthogonal transforms:. - Haar; - Walsh; - Cos; - Sin; - Fourier; - Hartley. Between these transform one can define so called generalized mixed; transforms that are also implemented in the transform function:. - Fourier-Haar; - Fourier-Walsh; - Walsh-Haar; - Cos-Walsh; - Cos-Haar; - Sin-Walsh; - Sin-Haar. The suitability of the application of appropriate transform depends on; the character of the data, i.e., on the shape of dominant components; contained in the data. The form of the transform function is as follows:. ```{.cpp}; char *Transform1(const float *source,; float *dest,; int size,; int type,; int direction,; int degree);; ```. This function transforms the source spectrum. The calling program; should fill in the input parameters. Transformed data are written into the dest spectrum. Function parameters:. - **`source`**: pointer to the vector of the source spectrum, its length should be equal to the `size` parameter except for inverse FOURIER, FOUR-WALSH, FOUR-HAAR transform. These need 2*`size` length to supply real and imaginary coefficients; - **`dest`**: pointer to the vector of the dest data, its length should be equal to the size parameter except for direct FOURIER, FOUR-WALSh, FOUR-HAAR. These need 2*`size` length to store real and imaginary coefficients; - **`size`**: basic length of the source and dest spectra; - **`type",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:58513,depend,depends,58513,documentation/spectrum/Spectrum.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md,1,['depend'],['depends']
Integrability,"onOneDim::kLEGENDRE based on; the GaussLegendreIntegrator class. ; Implement also for the GaussIntegrator and; GaussLegendreIntegrator the undefined and semi-undefined integral; using a function transformation as it is done in the GSLIntegrator; Fix a bug in IntegratorOneDim::SetAbsTolerance; New class ROOT::Math::IntegratorOptions which can be passed to; all integrator allowing the user to give options to the class and in; particular default value. Via the support for extra options (with; the class ROOT::Math::IOptions generic (string,value); options can be used in the base class to define specific options for; the implementations. For example for the MCIntegrator class,; specific options can now be passed to VEGAS or MISER.; . Improve the root finder and 1D minimization classes (BrentRootFinder; and BrentMinimizer1D) by fixing a bug in the Brent method (see rev. 32544); and adding possibility to pass the tolerance and max number of; iterations; Change also the interface classes,; ROOT::Math::RootFinder and; ROOT::Math::IMinimizer1D to have methods consistent with; the other numerical algorithm classes (e.g. return bool and not; int from RootFinder::Solve and add a; RootFinder::Status() function. In addition, use the same default; tolerance for all the root finder algorithms.; ; The class ROOT::Math::Data::Range returns in the method; GetRange the values -inf and +inf when no range; is set; ; Use in TRandom::SetSeed(int seed) a value of; seed=0 as default argument. This is the same now in all the; derived classes.; Add new methods in ROOT::Fit::FitResult to have a more; consistent and expressive API:FitResult::Parameter(index),; FitResult::ParError(index) and; FitResult::ParName(index).; The method FitResult::ParError should be used instead of; FitResult::Error in the derived TFitResult; class to avoid a conflict with TObject::Error; (see bug 67671).; ; Fix a bug in Tmath::AreEqualRel to take into account; the case when the two arguments may be null.; Improve imple",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v528/index.html:6379,interface,interface,6379,math/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v528/index.html,2,['interface'],['interface']
Integrability,"on`_ (v1), transpiling; Python code into C++ and interpreting the result with CINT.; In early 2003, I ported this code to boost.python v2, then recently released.; In practice, however, re-interpreting the transpiled code was unusably slow,; thus I modified the code to make direct use of CINT's internal reflection; system, gaining about 25x in performance.; I presented this work as `PyROOT` at the ROOT Users' Workshop in early 2004,; and, after removing the boost.python dependency by using the C-API directly; (gaining another factor 7 in speedup!), it was included in ROOT.; PyROOT was presented at the SciPy'06 conference, but was otherwise not; advocated outside of High Energy Physics (HEP). In 2010, the PyPy core developers and I held a `sprint at CERN`_ to use; `Reflex`, a standalone alternative to CINT's reflection of C++, to add; automatic C++ bindings, PyROOT-style, to `PyPy`_.; This is where the name ""cppyy"" originated.; Coined by Carl Friedrich Bolz, if you want to understand the meaning, just; pronounce it slowly: cpp-y-y. After the ROOT team replaced CINT with `Cling`_, PyROOT soon followed.; As part of Google's Summer of Code '16, Aditi Dutta moved PyPy/cppyy to Cling; as well, and packaged the code for use through `PyPI`_.; I continued this integration with the Python eco-system by forking PyROOT,; reducing its dependencies, and repackaging it as CPython/cppyy.; The combined result is the current cppyy project.; Mid 2018, version 1.0 was released. .. _`CERN`: https://cern.ch/; .. _`PyROOT`: https://root.cern.ch/root/htmldoc/guides/users-guide/ROOTUsersGuide.html#python-interface; .. _`CINT`: https://en.wikipedia.org/wiki/CINT; .. _`ROOT`: https://root.cern.ch; .. _`boost.python`: https://wiki.python.org/moin/boost.python/GettingStarted; .. _`sprint at CERN`: https://morepypy.blogspot.com/2010/07/cern-sprint-report-wrapping-c-libraries.html; .. _`PyPy`: https://www.pypy.org/; .. _`Cling`: https://github.com/vgvassilev/cling; .. _`PyPI`: https://pypi.org/; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/history.rst:1748,integrat,integration,1748,bindings/pyroot/cppyy/cppyy/doc/source/history.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/history.rst,4,"['depend', 'integrat', 'interface', 'wrap']","['dependencies', 'integration', 'interface', 'wrapping-c-libraries']"
Integrability,"on``\ s from the current ``Module``.; #. Add or remove global variables from the current ``Module``.; #. Maintain state across invocations of :ref:`runOnFunction; <writing-an-llvm-pass-runOnFunction>` (including global data). Implementing a ``FunctionPass`` is usually straightforward (See the :ref:`Hello; World <writing-an-llvm-pass-basiccode>` pass for example).; ``FunctionPass``\ es may override three virtual methods to do their work. All; of these methods should return ``true`` if they modified the program, or; ``false`` if they didn't. .. _writing-an-llvm-pass-doInitialization-mod:. The ``doInitialization(Module &)`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doInitialization(Module &M);. The ``doInitialization`` method is allowed to do most of the things that; ``FunctionPass``\ es are not allowed to do. They can add and remove functions,; get pointers to functions, etc. The ``doInitialization`` method is designed to; do simple initialization type of stuff that does not depend on the functions; being processed. The ``doInitialization`` method call is not scheduled to; overlap with any other pass executions (thus it should be very fast). A good example of how this method should be used is the `LowerAllocations; <https://llvm.org/doxygen/LowerAllocations_8cpp-source.html>`_ pass. This pass; converts ``malloc`` and ``free`` instructions into platform dependent; ``malloc()`` and ``free()`` function calls. It uses the ``doInitialization``; method to get a reference to the ``malloc`` and ``free`` functions that it; needs, adding prototypes to the module if necessary. .. _writing-an-llvm-pass-runOnFunction:. The ``runOnFunction`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool runOnFunction(Function &F) = 0;. The ``runOnFunction`` method must be implemented by your subclass to do the; transformation or analysis work of your pass. As usual, a ``true`` value; should be returned if the function is modified. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:18788,depend,depend,18788,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['depend'],['depend']
Integrability,"onal Details; ^^^^^^^^^^^^^^^^^^^. The code responsible for running the pre-merge flow can be found in the `external; repository <https://github.com/google/llvm-premerge-checks>`_. For enhancement; ideas and most bugs, please file an issue on said repository. For immediate; operational problems, the point of contact is; `Mikhail Goncharov <mailto:goncharo@google.com>`_. Background on the pre-merge infrastructure can be found in `this 2020 DevMeeting; talk <https://llvm.org/devmtg/2020-09/slides/Goncharov-Pre-merge_checks.pdf>`_. Committing a change; -------------------. Once a patch has been reviewed and approved on Phabricator it can then be; committed to trunk. If you do not have commit access, someone has to; commit the change for you (with attribution). It is sufficient to add; a comment to the approved review indicating you cannot commit the patch; yourself. If you have commit access, there are multiple workflows to commit the; change. Whichever method you follow it is recommended that your commit message; ends with the line:. ::. Differential Revision: <URL>. where ``<URL>`` is the URL for the code review, starting with; ``https://reviews.llvm.org/``. This allows people reading the version history to see the review for; context. This also allows Phabricator to detect the commit, close the; review, and add a link from the review to the commit. Note that if you use the Arcanist tool the ``Differential Revision`` line will; be added automatically. If you don't want to use Arcanist, you can add the; ``Differential Revision`` line (as the last line) to the commit message; yourself. Using the Arcanist tool can simplify the process of committing reviewed code as; it will retrieve reviewers, the ``Differential Revision``, etc from the review; and place it in the commit message. You may also commit an accepted change; directly using ``git push``, per the section in the :ref:`getting started; guide <commit_from_git>`. Note that if you commit the change without using Arca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:13642,message,message,13642,interpreter/llvm-project/llvm/docs/Phabricator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst,1,['message'],['message']
Integrability,"onal utilities to help with setup so that snippets can be benchmarked; properly. * `LLVM-EXEGESIS-DEFREG <register name>` - Adding this annotation to the text; assembly snippet to be benchmarked marks the register as requiring a definition.; A value will automatically be provided unless a second parameter, a hex value,; is passed in. This is done with the `LLVM-EXEGESIS-DEFREG <register name> <hex value>`; format. `<hex value>` is a bit pattern used to fill the register. If it is a; value smaller than the register, it is sign extended to match the size of the; register.; * `LLVM-EXEGESIS-LIVEIN <register name>` - This annotation allows specifying; registers that should keep their value upon starting the benchmark. Values; can be passed through registers from the benchmarking setup in some cases.; The registers and the values assigned to them that can be utilized in the; benchmarking script with a `LLVM-EXEGESIS-LIVEIN` are as follows:. * Scratch memory register - The specific register that this value is put in; is platform dependent (e.g., it is the RDI register on X86 Linux). Setting; this register as a live in ensures that a pointer to a block of memory (1MB); is placed within this register that can be used by the snippet.; * `LLVM-EXEGESIS-MEM-DEF <value name> <size> <value>` - This annotation allows; specifying memory definitions that can later be mapped into the execution; process of a snippet with the `LLVM-EXEGESIS-MEM-MAP` annotation. Each; value is named using the `<value name>` argument so that it can be referenced; later within a map annotation. The size is specified in a decimal number of; bytes and the value is given in hexadecimal. If the size of the value is less; than the specified size, the value will be repeated until it fills the entire; section of memory. Using this annotation requires using the subprocess execution; mode.; * `LLVM-EXEGESIS-MEM-MAP <value name> <address>` - This annotation allows for; mapping previously defined memory definitions ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst:2855,depend,dependent,2855,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,1,['depend'],['dependent']
Integrability,"onality while the specific behaviours for one or multiple dimensions are implemented in; `ROOT::Math::VirtualIntegratorOneDim` and `ROOT::Math::VirtualIntegratorMultiDim`.; These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set the integration tolerance.; These methods must be implemented in the concrete classes existing for the different integration algorithms.; The user cannot create directly these virtual integrator interfaces. He needs to create the; `ROOT::Math::IntegratorOneDim` class for integrating one-dimensional functions and `ROOT::Math::IntegratorMultiDim` for multi-dimensional functions.; Through the ROOT Plug-In Manager, the user can initialize `ROOT::Math::IntegratorOneDim` or `ROOT::Math::IntegratorMultiDim` with; any of the concrete integration classes without dealing with them directly.; These two classes provide the same interface as in `VirtualIntegratorOneDim` and `VirtualIntegratorMultiDim`, but with the possibility to choose in the constructor,; which method will be used to perform the integration. The method to set the function to be integrated, must be of the function interface type described before.; `ROOT::Math::IBaseFunctionOneDimFunction` is used for `ROOT::Math::IBaseFunctionMultiDim` and; The only difference between the `ROOT::Math::IntegratorOneDim` and `ROOT::Math::IntegratorMultiDim` resides; in the dimensionality of that function and some specific that will be seen afterwards for the one dimensional one. ![ROOT::Math Numerical Integrator classes](pictures/Integration.png). The rest of the classes shown above in the diagram are the specialized classes provided. Each one implements a different method that will be explained in detail. It is important; to notice that the two grayed classes (the one which name starts by GSL) are part of the *MathMore* library.; We will later show in more detail the differences between the implementations. ### Integration of One-di",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:49380,interface,interface,49380,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,2,"['integrat', 'interface']","['integration', 'interface']"
Integrability,"onding x values x1,x2 at which F1(x1)=F2(x2)=y. The value of the interpolated ; p.d.f fbar(x) is then calculated as fbar(alpha*x1+(1-alpha)*x2) = f1(x1)*f2(x2) / ( alpha*f2(x2) + ; (1-alpha)*f1(x1) ). Given that it is not easily possible to calculate the value of RooLinearMorph; at a given value of x, the value for all values of x are calculated in one by (through a scan over y); and stored in a cache. NB: The range of the interpolation parameter does not need to be [0,1], it can; be anything. New workspace tool RooSimWSTool. A new tool to clone and customize p.d.f.s into a RooSimultaneous p.d.f has been added. This new; tool succeeds the original RooSimPdfBuilder tool which had a similar functionality but; has a much cleaner interface, partly thanks to its use of the RooWorkspace class for both input; of prototype p.d.fs and output of built p.d.f.s. The simplest use case to to take a workspace p.d.f as prototype and 'split' a parameter of that p.d.f ; into two specialized parameters depending on a category in the dataset. ; For example, given a Gaussian p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'.; Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. . SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specia",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html:11905,depend,depending,11905,roofit/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html,2,['depend'],['depending']
Integrability,"onditions of a branch would; cause the constraints to be unsatisfiable, the branch is considered; infeasible and that path is not taken. This is how we get; path-sensitivity. We reduce exponential blow-up by caching nodes. If; a new node with the same state and program point as an existing node; would get generated, the path ""caches out"" and we simply reuse the; existing node. Thus the ExplodedGraph is not a DAG; it can contain; cycles as paths loop back onto each other and cache out. ProgramState and ExplodedNodes are basically immutable once created. Once; one creates a ProgramState, you need to create a new one to get a new; ProgramState. This immutability is key since the ExplodedGraph represents; the behavior of the analyzed program from the entry point. To; represent these efficiently, we use functional data structures (e.g.,; ImmutableMaps) which share data between instances. Finally, individual Checkers work by also manipulating the analysis; state. The analyzer engine talks to them via a visitor interface.; For example, the PreVisitCallExpr() method is called by ExprEngine; to tell the Checker that we are about to analyze a CallExpr, and the; checker is asked to check for any preconditions that might not be; satisfied. The checker can do nothing, or it can generate a new; ProgramState and ExplodedNode which contains updated checker state. If it; finds a bug, it can tell the BugReporter object about the bug,; providing it an ExplodedNode which is the last node in the path that; triggered the problem. = Notes about C++ =. Since now constructors are seen before the variable that is constructed; in the CFG, we create a temporary object as the destination region that; is constructed into. See ExprEngine::VisitCXXConstructExpr(). In ExprEngine::processCallExit(), we always bind the object region to the; evaluated CXXConstructExpr. Then in VisitDeclStmt(), we compute the; corresponding lazy compound value if the variable is not a reference, and; bind the variable r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/README.txt:3246,interface,interface,3246,interpreter/llvm-project/clang/lib/StaticAnalyzer/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/README.txt,1,['interface'],['interface']
Integrability,"onnected component of the graph is a maximal subgraph of all the nodes; that form a cycle, pi-blocks are at most one level deep. In other words,; no pi-blocks are nested inside another pi-block, resulting in a; hierarchical representation that is at most one level deep. For example, consider the following:. .. code-block:: c++. for (int i = 1; i < n; i++) {; b[i] = c[i] + b[i-1];; }. This code contains a statement that has a loop carried dependence on; itself creating a cycle in the DDG. The figure below illustrates; how the cycle of dependency is carried through multiple def-use relations; and a memory access dependency. .. image:: cycle.png. The DDG corresponding to this example would have a pi-block that contains; all the nodes participating in the cycle, as shown below:. .. image:: cycle_pi.png. Program Dependence Graph; ========================. The Program Dependence Graph (or PDG) has a similar structure as the; DDG, but it is capable of representing both data dependencies and; control-flow dependencies between program elements such as; instructions, groups of instructions, basic blocks or groups of; basic blocks. High-Level Design; =================. The DDG and the PDG are both directed graphs and they extend the; ``DirectedGraph`` class. Each implementation extends its corresponding; node and edge types resulting in the inheritance relationship depicted; in the UML diagram below:. .. image:: uml_nodes_and_edges.png. Graph Construction; ------------------. The graph build algorithm considers dependencies between elements of; a given set of instructions or basic blocks. Any dependencies coming; into or going out of instructions that do not belong to that range; are ignored. The steps in the build algorithm for the DDG are very; similar to the steps in the build algorithm for the PDG. As such,; one of the design goals is to reuse the build algorithm code to; allow creation of both DDG and PDG representations while allowing; the two implementations to define t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst:2249,depend,dependencies,2249,interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,2,['depend'],['dependencies']
Integrability,"ons -D_NO_CRT_STDIO_INLINE""``. Supply CRT definitions including stdio definitions that have been removed from the MS VS CRT.; We don't want the stdio functions declared inline as they will cause multiple definition; errors when the same symbols are pulled in from legacy_stdio_definitions.ib. * ``-DCMAKE_INSTALL_PREFIX=<install path>``. Where to install the library and headers. Building libunwind:; -------------------. * ``-DLIBUNWIND_ENABLE_SHARED=ON``; * ``-DLIBUNWIND_ENABLE_STATIC=OFF``. libunwind can be built as a DLL. It is not dependent on other projects. * ``-DLIBUNWIND_USE_COMPILER_RT=OFF``. We use the MS runtime. The CMake files will need to be edited to prevent them adding GNU specific libraries to the link line. Building libc++abi:; -------------------. * ``-DLIBCXXABI_ENABLE_SHARED=OFF``; * ``-DLIBCXXABI_ENABLE_STATIC=ON``; * ``-DLIBCXX_ENABLE_SHARED=ON'``; * ``-DLIBCXX_ENABLE_STATIC_ABI_LIBRARY=ON``. To break the symbol dependency between libc++abi and libc++ we; build libc++abi as a static library and then statically link it; into the libc++ DLL. This necessitates setting the CMake file; to ensure that the visibility macros (which expand to dllexport/import); are expanded as they will be needed when creating the final libc++; DLL later, see: https://reviews.llvm.org/D90021. * ``-DLIBCXXABI_LIBCXX_INCLUDES=<path to libcxx>/include``. Where to find the libc++ headers. Building libc++:; ----------------. * ``-DLIBCXX_ENABLE_SHARED=ON``; * ``-DLIBCXX_ENABLE_STATIC=OFF``. We build libc++ as a DLL and statically link libc++abi into it. * ``-DLIBCXX_INSTALL_HEADERS=ON``. Install the headers. * ``-DLIBCXX_USE_COMPILER_RT=OFF``. We use the MS runtime. * ``-DLIBCXX_HAS_WIN32_THREAD_API=ON``. Windows Itanium does not offer a POSIX-like layer over WIN32. * ``-DLIBCXX_ENABLE_STATIC_ABI_LIBRARY=ON``; * ``-DLIBCXX_CXX_ABI=libcxxabi``; * ``-DLIBCXX_CXX_ABI_INCLUDE_PATHS=<libcxxabi src path>/include``; * ``-DLIBCXX_CXX_ABI_LIBRARY_PATH=<libcxxabi build path>/lib``. Use ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToBuildWindowsItaniumPrograms.rst:5246,depend,dependency,5246,interpreter/llvm-project/llvm/docs/HowToBuildWindowsItaniumPrograms.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToBuildWindowsItaniumPrograms.rst,1,['depend'],['dependency']
Integrability,"ons Rademakers, CERN/SFT,\; Enric Tejedor Saavedra, CERN/SFT,\; Oksana Shadura, UNL,\; Ravi Kiran Selvam, GSOC, \; Manos, Stergiadis, GSOC, \; Matevz Tadel, UCSD/CMS,\; Yuka Takahashi, Princeton,\; Massimo Tumolo, Politecnico di Torino,\; Mohammad Uzair, CERN/SFT, \; Xavier Valls, CERN/SFT,\; Vassil Vassilev, Princeton/CMS,\; Wouter Verkerke, NIKHEF/Atlas,\; Stefan Wunsch, CERN/SFT. ## Deprecation and Removal. ### Ruby bindings. The ruby binding has been unmaintained for several years; it does not build with current ruby versions.; Given that this effectively meant that Ruby was dysfunctional and given that nobody (but package maintainers) has complained, we decided to remove it. ### Removal of previously deprecated or disabled packages. The packages `afs`, `chirp`, `glite`, `sapdb`, `srp` and `ios` have been removed from ROOT.; They were deprecated before, or never ported from configure, make to CMake. ### Remove GLUtesselator forward declaration from TVirtualX.h. It was never used in TVirtualX interfaces. If GLUtesselator forward declaration is required, use TGLUtil.h include instead. ## C++ Modules Technology Preview. ROOT has several features which interact with libraries and require implicit; header inclusion. This can be triggered by reading or writing data on disk,; or user actions at the prompt. Often, the headers are immutable and reparsing is; redundant. C++ Modules are designed to minimize the reparsing of the same; header content by providing an efficient on-disk representation of C++ Code. This is an experimental feature which can be enabled by compiling ROOT with; `-Druntime_cxxmodules=On`. You can read more about the current state of the; feature [here](../../README.CXXMODULES.md). ## Core Libraries. ### New command line flag ""--version"" for root. `root --version` now displays ROOT version and build info and quits:. ```; ROOT Version: 6.15/01; Built for linuxx8664gcc on Sep 20 2018, 11:04:35; From heads/master@v6-13-04-1273-gea3f4333a2; ```. ### Fish s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md:1806,interface,interfaces,1806,README/ReleaseNotes/v616/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md,1,['interface'],['interfaces']
Integrability,"ons in ``-ffast-math``; will cause ``__FAST_MATH__`` to no longer be set.; ``-ffast-math`` enables ``-fcx-limited-range``. This option implies:. * ``-fno-honor-infinities``. * ``-fno-honor-nans``. * ``-fapprox-func``. * ``-fno-math-errno``. * ``-ffinite-math-only``. * ``-fassociative-math``. * ``-freciprocal-math``. * ``-fno-signed-zeros``. * ``-fno-trapping-math``. * ``-fno-rounding-math``. * ``-ffp-contract=fast``. Note: ``-ffast-math`` causes ``crtfastmath.o`` to be linked with code. See; :ref:`crtfastmath.o` for more details. .. option:: -fno-fast-math. Disable fast-math mode. This options disables unsafe floating-point; optimizations by preventing the compiler from making any transformations that; could affect the results. This option implies:. * ``-fhonor-infinities``. * ``-fhonor-nans``. * ``-fno-approx-func``. * ``-fno-finite-math-only``. * ``-fno-associative-math``. * ``-fno-reciprocal-math``. * ``-fsigned-zeros``. * ``-ffp-contract=on``. Also, this option resets following options to their target-dependent defaults. * ``-f[no-]math-errno``; * ``-fdenormal-fp-math=<value>``. There is ambiguity about how ``-ffp-contract``, ``-ffast-math``,; and ``-fno-fast-math`` behave when combined. To keep the value of; ``-ffp-contract`` consistent, we define this set of rules:. * ``-ffast-math`` sets ``ffp-contract`` to ``fast``. * ``-fno-fast-math`` sets ``-ffp-contract`` to ``on`` (``fast`` for CUDA and; HIP). * If ``-ffast-math`` and ``-ffp-contract`` are both seen, but; ``-ffast-math`` is not followed by ``-fno-fast-math``, ``ffp-contract``; will be given the value of whichever option was last seen. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has been seen at least; once, the ``ffp-contract`` will get the value of the last seen value of; ``-ffp-contract``. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has not been seen, the; ``-ffp-contract`` setting is determined by the default value of; ``-ffp-contract``. Note: ``-fno-fast-math`` implies ``-fdenorma",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:53521,depend,dependent,53521,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['depend'],['dependent']
Integrability,"ons. This additionally causes a misspeculation to have an invalid stack; pointer and never be able to read the speculatively stored return address. See; the detailed discussion below. For variant #1.2, the attacker speculatively stores into the vtable or jump; table used to implement an indirect call or indirect jump. Because this is; speculative, this will often be possible even when these are stored in; read-only pages. For example:; ```; class FancyObject : public BaseObject {; public:; void DoSomething() override;; };; void f(unsigned long attacker_offset, unsigned long attacker_data) {; FancyObject object = getMyObject();; unsigned long *arr[4] = getFourDataPointers();; if (attacker_offset < 4) {; // We have bypassed the bounds check speculatively.; unsigned long *data = arr[attacker_offset];; // Now we have computed a pointer inside of `object`, the vptr.; *data = attacker_data;; // The vptr points to the virtual table and we speculatively clobber that.; g(object); // Hand the object to some other routine.; }; }; // In another file, we call a method on the object.; void g(BaseObject &object) {; object.DoSomething();; // This speculatively calls the address stored over the vtable.; }; ```. Mitigating this requires hardening loads from these locations, or mitigating; the indirect call or indirect jump. Any of these are sufficient to block the; call or jump from using a speculatively stored value that has been read back. For both of these, using retpolines would be equally sufficient. One possible; hybrid approach is to use retpolines for indirect call and jump, while relying; on SLH to mitigate returns. Another approach that is sufficient for both of these is to harden all of the; speculative stores. However, as most stores aren't interesting and don't; inherently leak data, this is expected to be prohibitively expensive given the; attack it is defending against. ## Implementation Details. There are a number of complex details impacting the implementation of thi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:13561,rout,routine,13561,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['rout'],['routine']
Integrability,"onships; between various program elements to help guide optimizations. The ideas; behind these graphs are described in papers [1]_ and [2]_. The implementation of these ideas in LLVM may be slightly different than; what is mentioned in the papers. These differences are documented in; the `implementation details <implementation-details_>`_. .. _DataDependenceGraph:. Data Dependence Graph; =====================; In its simplest form the Data Dependence Graph (or DDG) represents data; dependencies between individual instructions. Each node in such a graph; represents a single instruction and is referred to as an ""atomic"" node.; It is also possible to combine some atomic nodes that have a simple; def-use dependency between them into larger nodes that contain multiple-; instructions. As described in [1]_ the DDG uses graph abstraction to group nodes; that are part of a strongly connected component of the graph; into special nodes called pi-blocks. pi-blocks represent cycles of data; dependency that prevent reordering transformations. Since any strongly; connected component of the graph is a maximal subgraph of all the nodes; that form a cycle, pi-blocks are at most one level deep. In other words,; no pi-blocks are nested inside another pi-block, resulting in a; hierarchical representation that is at most one level deep. For example, consider the following:. .. code-block:: c++. for (int i = 1; i < n; i++) {; b[i] = c[i] + b[i-1];; }. This code contains a statement that has a loop carried dependence on; itself creating a cycle in the DDG. The figure below illustrates; how the cycle of dependency is carried through multiple def-use relations; and a memory access dependency. .. image:: cycle.png. The DDG corresponding to this example would have a pi-block that contains; all the nodes participating in the cycle, as shown below:. .. image:: cycle_pi.png. Program Dependence Graph; ========================. The Program Dependence Graph (or PDG) has a similar structure as the; D",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst:1194,depend,dependency,1194,interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,1,['depend'],['dependency']
Integrability,"onsole, or to extract and display additional; information like contour lines showing parameter correlations. As function fitting; is of prime importance in any kind of data analysis, this topic will again show up; later. If you are satisfied with your plot, you probably want to save it. Just; close all selector boxes you opened previously and select the menu item; `Save as...` from the menu line of the window. It will pop up a file; selector box to allow you to choose the format, file name and target; directory to store the image. There is one very noticeable feature here:; you can store a plot as a root macro! In this macro, you find the C++; representation of all methods and classes involved in generating the; plot. This is a valuable source of information for your own macros,; which you will hopefully write after having worked through this; tutorial. Using ROOT's interactive capabilities is useful for a first exploration; of possibilities. Other ROOT classes you will encounter in this tutorial; have such graphical interfaces. We will not comment further on this,; just be aware of the existence of ROOT's interactive features and use; them if you find them convenient. Some trial-and-error is certainly necessary; to find your way through the huge number of menus and parameter; settings. ## ROOT Beginners' FAQ ##. At this point of the guide, some basic questions could have already come; to your mind. We will try to clarify some of them with further; explanations in the following. ### ROOT type declarations for basic data types ###. In the official ROOT documentation, you find special data types; replacing the normal ones, e.g. `Double_t`, `Float_t` or `Int_t`; replacing the standard `double`, `float` or `int` types. Using the ROOT; types makes it easier to port code between platforms (64/32 bit) or; operating systems (windows/Linux), as these types are mapped to suitable; ones in the ROOT header files. If you want adaptive code of this type,; use the ROOT type declar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:16619,interface,interfaces,16619,documentation/primer/ROOT_as_calculator.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md,1,['interface'],['interfaces']
Integrability,"onsteval()); matches the if statement in ""void b()"", ""void c()"", ""void d()"". Matcher<FunctionDecl>isConstexpr; Matches constexpr variable and function declarations,; and if constexpr. Given:; constexpr int foo = 42;; constexpr int bar();; void baz() { if constexpr(1 > 0) {} }; varDecl(isConstexpr()); matches the declaration of foo.; functionDecl(isConstexpr()); matches the declaration of bar.; ifStmt(isConstexpr()); matches the if statement in baz. Matcher<FunctionDecl>isDefaulted; Matches defaulted function declarations. Given:; class A { ~A(); };; class B { ~B() = default; };; functionDecl(isDefaulted()); matches the declaration of ~B, but not ~A. Matcher<FunctionDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<FunctionDecl>isDeleted; Matches deleted function declarations. Given:; void Func();; void DeletedFunc() = delete;; functionDecl(isDeleted()); matches the declaration of DeletedFunc, but not Func. Matcher<FunctionDecl>isExplicitTemplateSpecialization; Matches explicit template specializations of function, class, or; static member variable template instantiations. Given; template<typename T> void A(T t) { }; template<> void A(int N) { }; functionDecl(isExplicitTemplateSpecialization()); matches the specialization A<int>(). Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<FunctionDecl>isExternC; Matches extern ""C"" function or variable declarations. Given:; extern ""C"" void f() {}; extern ""C"" { void g() {} }; void h() {}; extern ""C"" int x = 1;; extern ""C"" int y = 2;; int z",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:91792,interface,interface,91792,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,4,['interface'],['interface']
Integrability,"onsumer->HandleTopLevelDecl(DGR);. The synthesizer will then choose the relevant expression, based on its type. Communication between Compiled Code and Interpreted Code; --------------------------------------------------------. In Clang-Repl there is **interpreted code**, and this feature adds a 'value'; runtime that can talk to the **compiled code**. Following is an example where the compiled code interacts with the interpreter; code. The execution results of an expression are stored in the object 'V' of; type Value. This value is then printed, effectively helping the interpreter; use a value from the compiled code. .. code-block:: console. int Global = 42;; void setGlobal(int val) { Global = val; }; int getGlobal() { return Global; }; Interp.ParseAndExecute(“void setGlobal(int val);”);; Interp.ParseAndExecute(“int getGlobal();”);; Value V;; Interp.ParseAndExecute(“getGlobal()”, &V);; std::cout << V.getAs<int>() << “\n”; // Prints 42. **Note:** Above is an example of interoperability between the compiled code and; the interpreted code. Interoperability between languages (e.g., C++ and Python); works similarly. 2. Dump Captured Execution Results; ==================================. This feature helps create a temporary dump to display the value and type; (pretty print) of the desired data. This is a good way to interact with the; interpreter during interactive programming. How value printing is simplified (Automatic Printf); ---------------------------------------------------. The ``Automatic Printf`` feature makes it easy to display variable values during; program execution. Using the ``printf`` function repeatedly is not required.; This is achieved using an extension in the ``libclangInterpreter`` library. To automatically print the value of an expression, simply write the expression; in the global scope **without a semicolon**. .. graphviz::; :name: automaticprintf; :caption: Automatic PrintF; :alt: Shows how Automatic PrintF can be used; :align: center. digraph """,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:13506,interoperab,interoperability,13506,interpreter/llvm-project/clang/docs/ClangRepl.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst,1,['interoperab'],['interoperability']
Integrability,"ontaining nothing but the current column to TLeaf::ReadValue.; Separate concepts of number of input line (for communication with user) and number of good lines (as returned).; Fix windows files leaving '\n' in branch names when reading them from the file.; Add error message for TLeaf::ReadValue(), i.e. if ReadValue() is called on a derived class that doesn't implement it.; Updated and clarified the documentation. TEntryList. Add new methods to find the base location of files and to modify it.; This allows to relocate the entry-lists to be able to use them of a; system where the files have a different absolute path.; The most relevant new methods are:. TEntryList::Scan(const char *fn); Shows the root common paths for the files of the TEntryLists in 'fn'; TEntryList::Relocate(const char *fn, const char *newroot,; const char *oldroot = 0, const char *enlnm = 0); Relocates all paths starting with 'oldroot' to 'newroot' for the; entry-list 'enlnm' in file 'fn'. Remove 'protocol+server' from file tagging and matching, i.e. use; only filepath+anchor; in this way a list is valid even after re-staging; of the dataset files, which typically changes the end-point data servers.; Entry-lists created with the full path should still be matched correctly. Miscellaneous. Repaired the behavior of TTreeCache when the TTree has a dramatic dynamic range with a lots of very small entriesat the beginning and very large entries at the end, the size in bytes of the cluster for the later entries will be very large (because of the cluster size in entries is large!). TTreeCache::FillBuffer was always attempting to load complete clusters not matter the; size (even with the size was larger than 2GB!). This patch resolves the issue by limiting the amount of memory used to:. The requested size if more than one cluster fits in the cache.; Twice the requested size if at least one basket per branch fits in the cache.; Four time the requested size in the case where the cache can not even hold one bask",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v534/index.html:2404,protocol,protocol,2404,tree/doc/v534/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v534/index.html,2,['protocol'],['protocol']
Integrability,"ontains the raw object image.; Before the code can be executed, the code and data sections from this; image must be loaded into suitable memory, relocations must be applied and; memory permission and code cache invalidation (if required) must be completed. Object Loading; ==============. Once an object image has been obtained, either through code generation or; having been retrieved from an ObjectCache, it is passed to RuntimeDyld to; be loaded. The RuntimeDyld wrapper class examines the object to determine; its file format and creates an instance of either RuntimeDyldELF or; RuntimeDyldMachO (both of which derive from the RuntimeDyldImpl base; class) and calls the RuntimeDyldImpl::loadObject method to perform that; actual loading. .. image:: MCJIT-dyld-load.png. RuntimeDyldImpl::loadObject begins by creating an ObjectImage instance; from the ObjectBuffer it received. ObjectImage, which wraps the; ObjectFile class, is a helper class which parses the binary object image; and provides access to the information contained in the format-specific; headers, including section, symbol and relocation information. RuntimeDyldImpl::loadObject then iterates through the symbols in the; image. Information about common symbols is collected for later use. For; each function or data symbol, the associated section is loaded into memory; and the symbol is stored in a symbol table map data structure. When the; iteration is complete, a section is emitted for the common symbols. Next, RuntimeDyldImpl::loadObject iterates through the sections in the; object image and for each section iterates through the relocations for; that sections. For each relocation, it calls the format-specific; processRelocationRef method, which will examine the relocation and store; it in one of two data structures, a section-based relocation list map and; an external symbol relocation map. .. image:: MCJIT-load-object.png. When RuntimeDyldImpl::loadObject returns, all of the code and data; sections for the object",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MCJITDesignAndImplementation.rst:4130,wrap,wraps,4130,interpreter/llvm-project/llvm/docs/MCJITDesignAndImplementation.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MCJITDesignAndImplementation.rst,1,['wrap'],['wraps']
Integrability,"ontinuation of the statements in the next line. Lamdas:; =======. .. code-block:: text. clang-repl> #include <iostream>; clang-repl> using namespace std;; clang-repl> auto welcome = []() { std::cout << ""Welcome to REPL"" << std::endl;};; clang-repl> welcome();; Welcome to REPL. Using Dynamic Library:; ======================. .. code-block:: text. clang-repl> %lib print.so; clang-repl> #include""print.hpp""; clang-repl> print(9);; 9. **Generation of dynamic library**. .. code-block:: text. // print.cpp; #include <iostream>; #include ""print.hpp"". void print(int a); {; std::cout << a << std::endl;; }. // print.hpp; void print (int a);. // Commands; clang++-17 -c -o print.o print.cpp; clang-17 -shared print.o -o print.so. Comments:; =========. .. code-block:: text. clang-repl> // Comments in Clang-Repl; clang-repl> /* Comments in Clang-Repl */. Closure or Termination:; =======================. .. code-block:: text. clang-repl>%quit. Just like Clang, Clang-Repl can be integrated in existing applications as a library; (using the clangInterpreter library). This turns your C++ compiler into a service that; can incrementally consume and execute code. The **Compiler as A Service** (**CaaS**); concept helps support advanced use cases such as template instantiations on demand and; automatic language interoperability. It also helps static languages such as C/C++ become; apt for data science. Execution Results Handling in Clang-Repl; ========================================. Execution Results Handling features discussed below help extend the Clang-Repl; functionality by creating an interface between the execution results of a; program and the compiled program. 1. **Capture Execution Results**: This feature helps capture the execution results; of a program and bring them back to the compiled program. 2. **Dump Captured Execution Results**: This feature helps create a temporary dump; for Value Printing/Automatic Printf, that is, to display the value and type of; the captured data. 1. C",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:5214,integrat,integrated,5214,interpreter/llvm-project/clang/docs/ClangRepl.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst,1,['integrat'],['integrated']
Integrability,"onvergence.entry(); %delta = ...; %cc = icmp sgt i32 %delta, 0; br i1 %cc, label %then, label %else. then:; %total_gains = call i32 @subgroupAdd(i32 %delta) [ ""convergencectrl""(token %entry) ]; ...; br label %end. else:; %total_losses = call i32 @subgroupAdd(i32 %delta) [ ""convergencectrl""(token %entry) ]; ...; br label %end. end:; ...; }. The entry intrinsic behaves like in the previous example: assuming that; ``@example_kernel`` is an OpenCL kernel (as hinted at by the ""subgroup""; terminology), we expect it to communicate among all threads within the; ""subgroup"". This typically maps to a SIMD vector on GPU hardware. The calls to ``@subgroupAdd`` use the token produced by the entry intrinsic,; but they also have an additional control dependency. According to the rules; defined in this document, they only communicate among the subset of threads; that actually end up executing the respective (static) call site. Hoisting them would remove the control dependency and cause them to communicate; among the full set of threads that the entry intrinsic communicated with.; Again, hoisting is allowed if it can be proven that ``%cc`` is always uniform; among the relevant set of threads: in that case, the ``@subgroupAdd`` already; communicates among the full set of threads in the original program. Motivating Examples of Convergence Control; ==========================================. (This section is informative.). Unstructured control flow; -------------------------. Consider an example of how jump threading removes structure in a way that can; make semantics non-obvious without the convergence intrinsics described in this; document:. .. code-block:: llvm. void example_original() {; entry:; ...; br i1 %cond1, label %then1, label %mid. then1:; ...; %cond2 = ...; br label %mid. mid:; %flag = phi i1 [ true, %entry ], [ %cond2, %then1 ]; br i1 %flag, label %then2, label %end. then2:; ...; call void @subgroupControlBarrier(); ...; br label %end. end:; }. void example_jumpthreaded() {",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:8411,depend,dependency,8411,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['depend'],['dependency']
Integrability,"ool SplitEmptyFunction`` If ``false``, empty function body can be put on a single line.; This option is used only if the opening brace of the function has; already been wrapped, i.e. the ``AfterFunction`` brace wrapping mode is; set, and the function could/should not be put on a single line (as per; ``AllowShortFunctionsOnASingleLine`` and constructor formatting; options). .. code-block:: c++. false: true:; int f() vs. int f(); {} {; }. * ``bool SplitEmptyRecord`` If ``false``, empty record (e.g. class, struct or union) body; can be put on a single line. This option is used only if the opening; brace of the record has already been wrapped, i.e. the ``AfterClass``; (for classes) brace wrapping mode is set. .. code-block:: c++. false: true:; class Foo vs. class Foo; {} {; }. * ``bool SplitEmptyNamespace`` If ``false``, empty namespace body can be put on a single line.; This option is used only if the opening brace of the namespace has; already been wrapped, i.e. the ``AfterNamespace`` brace wrapping mode is; set. .. code-block:: c++. false: true:; namespace Foo vs. namespace Foo; {} {; }. .. _BracedInitializerIndentWidth:. **BracedInitializerIndentWidth** (``Unsigned``) :versionbadge:`clang-format 17` :ref:`¶ <BracedInitializerIndentWidth>`; The number of columns to use to indent the contents of braced init lists.; If unset, ``ContinuationIndentWidth`` is used. .. code-block:: c++. AlignAfterOpenBracket: AlwaysBreak; BracedInitializerIndentWidth: 2. void f() {; SomeClass c{; ""foo"",; ""bar"",; ""baz"",; };; auto s = SomeStruct{; .foo = ""foo"",; .bar = ""bar"",; .baz = ""baz"",; };; SomeArrayT a[3] = {; {; foo,; bar,; },; {; foo,; bar,; },; SomeArrayT{},; };; }. .. _BreakAdjacentStringLiterals:. **BreakAdjacentStringLiterals** (``Boolean``) :versionbadge:`clang-format 18` :ref:`¶ <BreakAdjacentStringLiterals>`; Break between adjacent string literals. .. code-block:: c++. true:; return ""Code""; ""\0\52\26\55\55\0""; ""x013""; ""\02\xBA"";; false:; return ""Code"" ""\0\52\26\55\55\0"" ""x013""",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:42695,wrap,wrapping,42695,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['wrap'],['wrapping']
Integrability,"ootIO avoid objects cloning when object referenced several times; - Treat special cases (collection, arrays) in one place.; This is major advantage, while any new classes should be implemented once.; - Object representation, produced by JSRootIO is similar to; objects, produced by TBufferJSON class. By this one can exchange; I/O engine and use same JavaSctript graphic for display.; - More clear functions to display different elements of the file.; In the future functions should be fully separated from I/O part; and organized in similar way as online part.; - Eliminate usage of gFile pointer in the I/O part.; - Provide TBufferJSON::JsonWriteMember method. It allows to stream any; selected data member of the class. Supported are: basic data types,; arrays of basic data types, TString, TArray classes. Also any object; as data member can be streamed.; - TRootSniffer do not creates sublevels for base classes; - When streaming data member, TBufferJSON produces array with all dimensions; only when fCompact==0. By default, THttpServer uses compact=1 for member; - Support both get.json and root.json requests, they have similar meaning. January 2014; - Make THttpServer::CreateEngine as factory method. One could; create http, fastcgi and dabc engines to access data from server.; Syntax allows to provide arbitrary arguments. Examples:; THttpServer* serv = new THttpServer();; serv->CreateEngine(""http:8080"");; serv->CreateEngine(""fastcgi:9000/none?top=MyApp"");; serv->CreateEngine(""dabc:1237?top=MyApp"");; serv->CreateEngine(""dabc:http:8090?top=MyApp"");; serv->CreateEngine(""dabc:fastcgi:9010?top=MyApp"");; - Many engines can be created at once.; - Provide TDabcEngine (in DABC framework).; - Support additional options for mongoose and fastcgi servers; - Port to ROOT 6 (adjust makefiles), keep Module.mk.ver5. December 2013; - Start of project; - Move ROOT-relevant functionality from DABC plugin; - Introduce THttpServer, THttpEngine and TRootSniffer classes; - Integrate JSRootIO code. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/README.txt:4965,Integrat,Integrate,4965,net/http/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/README.txt,1,['Integrat'],['Integrate']
Integrability,"operand registers are available and resource requirements are; met. Multiple instructions can be issued in one cycle according to the value of; the ``IssueWidth`` parameter in LLVM's scheduling model. Once issued, an instruction is moved to ``IssuedInst`` set until it is ready to; retire. :program:`llvm-mca` ensures that writes are committed in-order. However,; an instruction is allowed to commit writes and retire out-of-order if; ``RetireOOO`` property is true for at least one of its writes. Custom Behaviour; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Due to certain instructions not being expressed perfectly within their; scheduling model, :program:`llvm-mca` isn't always able to simulate them; perfectly. Modifying the scheduling model isn't always a viable; option though (maybe because the instruction is modeled incorrectly on; purpose or the instruction's behaviour is quite complex). The; CustomBehaviour class can be used in these cases to enforce proper; instruction modeling (often by customizing data dependencies and detecting; hazards that :program:`llvm-mca` has no way of knowing about). :program:`llvm-mca` comes with one generic and multiple target specific; CustomBehaviour classes. The generic class will be used if the ``-disable-cb``; flag is used or if a target specific CustomBehaviour class doesn't exist for; that target. (The generic class does nothing.) Currently, the CustomBehaviour; class is only a part of the in-order pipeline, but there are plans to add it; to the out-of-order pipeline in the future. CustomBehaviour's main method is `checkCustomHazard()` which uses the; current instruction and a list of all instructions still executing within; the pipeline to determine if the current instruction should be dispatched.; As output, the method returns an integer representing the number of cycles; that the current instruction must stall for (this can be an underestimate; if you don't know the exact number and a value of 0 represents no stall). If you'd like ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst:44376,depend,dependencies,44376,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,1,['depend'],['dependencies']
Integrability,"operand, the method; ``MachineOperand::isUse()`` informs if that register is being used by the; instruction. The method ``MachineOperand::isDef()`` informs if that registers is; being defined. We will call physical registers present in the LLVM bitcode before register; allocation *pre-colored registers*. Pre-colored registers are used in many; different situations, for instance, to pass parameters of functions calls, and; to store results of particular instructions. There are two types of pre-colored; registers: the ones *implicitly* defined, and those *explicitly*; defined. Explicitly defined registers are normal operands, and can be accessed; with ``MachineInstr::getOperand(int)::getReg()``. In order to check which; registers are implicitly defined by an instruction, use the; ``TargetInstrInfo::get(opcode)::ImplicitDefs``, where ``opcode`` is the opcode; of the target instruction. One important difference between explicit and; implicit physical registers is that the latter are defined statically for each; instruction, whereas the former may vary depending on the program being; compiled. For example, an instruction that represents a function call will; always implicitly define or use the same set of physical registers. To read the; registers implicitly used by an instruction, use; ``TargetInstrInfo::get(opcode)::ImplicitUses``. Pre-colored registers impose; constraints on any register allocation algorithm. The register allocator must; make sure that none of them are overwritten by the values of virtual registers; while still alive. Mapping virtual registers to physical registers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. There are two ways to map virtual registers to physical registers (or to memory; slots). The first way, that we will call *direct mapping*, is based on the use; of methods of the classes ``TargetRegisterInfo``, and ``MachineOperand``. The; second way, that we will call *indirect mapping*, relies on the ``VirtRegMap``; class in order to inser",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:63298,depend,depending,63298,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['depend'],['depending']
Integrability,"operation*. 0..7; 7:7 Must be 0. 0; 9:8 Optional *stream*. 0..3; 15:10 Unused. \-; ============ =============================== ===============. This operand may be specified as one of the following:. * An :ref:`integer_number<amdgpu_synid_integer_number>` or an :ref:`absolute_expression<amdgpu_synid_absolute_expression>`. The value must be in the range from 0 to 0xFFFF.; * A *sendmsg* value which is described below. ==================================== ====================================================; Sendmsg Value Syntax Description; ==================================== ====================================================; sendmsg(<*type*>) A message identified by its *type*.; sendmsg(<*type*>,<*op*>) A message identified by its *type* and *operation*.; sendmsg(<*type*>,<*op*>,<*stream*>) A message identified by its *type* and *operation*; with a stream *id*.; ==================================== ====================================================. *Type* may be specified using message *name* or message *id*. *Op* may be specified using operation *name* or operation *id*. Stream *id* is an integer in the range from 0 to 3. Numeric values may be specified as positive :ref:`integer numbers<amdgpu_synid_integer_number>`; or :ref:`absolute expressions<amdgpu_synid_absolute_expression>`. Each message type supports specific operations:. ====================== ========== ============================== ============ ==========; Message name Message Id Supported Operations Operation Id Stream Id; ====================== ========== ============================== ============ ==========; MSG_INTERRUPT 1 \- \- \-; MSG_HS_TESSFACTOR 2 \- \- \-; MSG_DEALLOC_VGPRS 3 \- \- \-; MSG_STALL_WAVE_GEN 5 \- \- \-; MSG_HALT_WAVES 6 \- \- \-; MSG_GS_ALLOC_REQ 9 \- \- \-; MSG_SYSMSG 15 SYSMSG_OP_ECC_ERR_INTERRUPT 1 \-; \ SYSMSG_OP_REG_RD 2 \-; \ SYSMSG_OP_TTRACE_PC 4 \-; ====================== ========== ============================== ============ ==========. *Sendmsg* arguments are val",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_msg_e37f7b.rst:1484,message,message,1484,interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_msg_e37f7b.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_msg_e37f7b.rst,2,['message'],['message']
Integrability,"operations, a major performance problem.; Fortunately for us, the LLVM optimizer has a highly-tuned optimization; pass named ""mem2reg"" that handles this case, promoting allocas like this; into SSA registers, inserting Phi nodes as appropriate. If you run this; example through the pass, for example, you'll get:. .. code-block:: bash. $ llvm-as < example.ll | opt -passes=mem2reg | llvm-dis; @G = weak global i32 0; @H = weak global i32 0. define i32 @test(i1 %Condition) {; entry:; br i1 %Condition, label %cond_true, label %cond_false. cond_true:; %X.0 = load i32, i32* @G; br label %cond_next. cond_false:; %X.1 = load i32, i32* @H; br label %cond_next. cond_next:; %X.01 = phi i32 [ %X.1, %cond_false ], [ %X.0, %cond_true ]; ret i32 %X.01; }. The mem2reg pass implements the standard ""iterated dominance frontier""; algorithm for constructing SSA form and has a number of optimizations; that speed up (very common) degenerate cases. The mem2reg optimization; pass is the answer to dealing with mutable variables, and we highly; recommend that you depend on it. Note that mem2reg only works on; variables in certain circumstances:. #. mem2reg is alloca-driven: it looks for allocas and if it can handle; them, it promotes them. It does not apply to global variables or heap; allocations.; #. mem2reg only looks for alloca instructions in the entry block of the; function. Being in the entry block guarantees that the alloca is only; executed once, which makes analysis simpler.; #. mem2reg only promotes allocas whose uses are direct loads and stores.; If the address of the stack object is passed to a function, or if any; funny pointer arithmetic is involved, the alloca will not be; promoted.; #. mem2reg only works on allocas of `first; class <../../LangRef.html#first-class-types>`_ values (such as pointers,; scalars and vectors), and only if the array size of the allocation is; 1 (or missing in the .ll file). mem2reg is not capable of promoting; structs or arrays to registers. Note that ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:7670,depend,depend,7670,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['depend'],['depend']
Integrability,"opt - LLVM optimizer; ====================. .. program:: opt. SYNOPSIS; --------. :program:`opt` [*options*] [*filename*]. DESCRIPTION; -----------. The :program:`opt` command is the modular LLVM optimizer and analyzer. It takes; LLVM source files as input, runs the specified optimizations or analyses on it,; and then outputs the optimized file. The optimizations available via; :program:`opt` depend upon what libraries were linked into it as well as any; additional libraries that have been loaded with the :option:`-load` option. Use; the :option:`-help` option to determine what optimizations you can use. If ``filename`` is omitted from the command line or is ""``-``"", :program:`opt`; reads its input from standard input. Inputs can be in either the LLVM assembly; language format (``.ll``) or the LLVM bitcode format (``.bc``). If an output filename is not specified with the :option:`-o` option,; :program:`opt` writes its output to the standard output. OPTIONS; -------. .. option:: -f. Enable binary output on terminals. Normally, :program:`opt` will refuse to; write raw bitcode output if the output stream is a terminal. With this option,; :program:`opt` will write raw bitcode regardless of the output device. .. option:: -help. Print a summary of command line options. .. option:: -o <filename>. Specify the output filename. .. option:: -S. Write output in LLVM intermediate language (instead of bitcode). .. option:: -{passname}. :program:`opt` provides the ability to run any of LLVM's optimization or; analysis passes in any order. The :option:`-help` option lists all the passes; available. The order in which the options occur on the command line are the; order in which they are executed (within pass constraints). .. option:: -strip-debug. This option causes opt to strip debug information from the module before; applying other optimizations. It is essentially the same as `-strip`; but it ensures that stripping of debug information is done first. .. option:: -verify-each. Thi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/opt.rst:396,depend,depend,396,interpreter/llvm-project/llvm/docs/CommandGuide/opt.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/opt.rst,1,['depend'],['depend']
Integrability,"option(BUILD_CLANG_FORMAT_VS_PLUGIN ""Build clang-format VS plugin"" OFF); if (BUILD_CLANG_FORMAT_VS_PLUGIN); add_custom_target(clang_format_exe_for_vsix; ${CMAKE_COMMAND} -E copy_if_different; ""${LLVM_TOOLS_BINARY_DIR}/clang-format.exe""; ""${CMAKE_CURRENT_SOURCE_DIR}/ClangFormat/clang-format.exe""; DEPENDS clang-format). # Build number added to Clang version to ensure that new VSIX can be upgraded; string(TIMESTAMP CLANG_FORMAT_VSIX_BUILD %y%m%d%H%M UTC). if (NOT CLANG_FORMAT_VS_VERSION); set(CLANG_FORMAT_VS_VERSION ""${LLVM_VERSION_MAJOR}.${LLVM_VERSION_MINOR}.${LLVM_VERSION_PATCH}.${CLANG_FORMAT_VSIX_BUILD}""); endif(). configure_file(""source.extension.vsixmanifest.in""; ""${CMAKE_CURRENT_SOURCE_DIR}/ClangFormat/source.extension.vsixmanifest""). find_program(NUGET_EXE nuget PATHS ${NUGET_EXE_DIR}); if (NOT NUGET_EXE); message(FATAL_ERROR ""Could not find nuget.exe. Download from https://www.nuget.org/nuget.exe""; "" and add parent directory to PATH or pass it via NUGET_EXE_DIR var.""); endif(). add_custom_target(clang_format_vsix ALL; COMMAND ${NUGET_EXE} restore ""${CMAKE_CURRENT_SOURCE_DIR}/ClangFormat.sln""; COMMAND devenv ""${CMAKE_CURRENT_SOURCE_DIR}/ClangFormat.sln"" /Build Release; DEPENDS clang_format_exe_for_vsix ""${CMAKE_CURRENT_SOURCE_DIR}/ClangFormat/source.extension.vsixmanifest""; COMMAND ${CMAKE_COMMAND} -E copy_if_different; ""${CMAKE_CURRENT_SOURCE_DIR}/ClangFormat/bin/Release/ClangFormat.vsix""; ""${LLVM_TOOLS_BINARY_DIR}/ClangFormat.vsix""; DEPENDS clang_format_exe_for_vsix); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/CMakeLists.txt:824,message,message,824,interpreter/llvm-project/clang/tools/clang-format-vs/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/CMakeLists.txt,1,['message'],['message']
Integrability,"option(LLVM_INCLUDE_DXIL_TESTS ""Include DXIL tests"" Off); mark_as_advanced(LLVM_INCLUDE_DXIL_TESTS). if (NOT LLVM_INCLUDE_DXIL_TESTS); return(); endif (). if (NOT ""DirectX"" IN_LIST LLVM_TARGETS_TO_BUILD); message(FATAL_ERROR ""Building dxil-dis tests is unsupported without the DirectX target""); endif (). if (CMAKE_HOST_UNIX); set(LLVM_LINK_OR_COPY create_symlink); else (); set(LLVM_LINK_OR_COPY copy); endif (). if (DXIL_DIS); add_custom_target(dxil-dis; COMMAND ${CMAKE_COMMAND} -E ${LLVM_LINK_OR_COPY} ""${DXIL_DIS}"" ""${LLVM_RUNTIME_OUTPUT_INTDIR}/dxil-dis${CMAKE_EXECUTABLE_SUFFIX}""); return(); endif (). include(ExternalProject). set(SOURCE_DIR ${CMAKE_CURRENT_BINARY_DIR}/DXC-src); set(BINARY_DIR ${CMAKE_CURRENT_BINARY_DIR}/DXC-bins); set(GIT_SETTINGS GIT_REPOSITORY https://github.com/microsoft/DirectXShaderCompiler.git). if (DXC_SOURCE_DIR); set(SOURCE_DIR ${DXC_SOURCE_DIR}); unset(GIT_SETTINGS); endif (). ExternalProject_Add(DXC; ${GIT_SETTINGS}; SOURCE_DIR ${SOURCE_DIR}; BINARY_DIR ${BINARY_DIR}; CMAKE_ARGS -C ${SOURCE_DIR}/cmake/caches/PredefinedParams.cmake -DLLVM_INCLUDE_TESTS=On; BUILD_COMMAND ${CMAKE_COMMAND} --build ${BINARY_DIR} --target llvm-dis; BUILD_BYPRODUCTS ${BINARY_DIR}/bin/llvm-dis; INSTALL_COMMAND """"; ). add_custom_target(dxil-dis; COMMAND ${CMAKE_COMMAND} -E ${LLVM_LINK_OR_COPY} ""${BINARY_DIR}/bin/llvm-dis${CMAKE_EXECUTABLE_SUFFIX}"" ""${LLVM_RUNTIME_OUTPUT_INTDIR}/dxil-dis${CMAKE_EXECUTABLE_SUFFIX}""; DEPENDS DXC; ); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dxil-dis/CMakeLists.txt:205,message,message,205,interpreter/llvm-project/llvm/tools/dxil-dis/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dxil-dis/CMakeLists.txt,3,"['DEPEND', 'message']","['DEPENDS', 'message']"
Integrability,"option(LLVM_INCLUDE_SPIRV_TOOLS_TESTS ""Include tests that use SPIRV-Tools"" Off); mark_as_advanced(LLVM_INCLUDE_SPIRV_TOOLS_TESTS). if (NOT LLVM_INCLUDE_SPIRV_TOOLS_TESTS); return(); endif (). if (NOT ""SPIRV"" IN_LIST LLVM_TARGETS_TO_BUILD); message(FATAL_ERROR ""Building SPIRV-Tools tests is unsupported without the SPIR-V target""); endif (). # SPIRV_DIS and SPIRV_VAL variables can be used to provide paths to existing; # spirv-dis and spirv-val binaries, respectively. Otherwise, build them from; # SPIRV-Tools source.; if (NOT SPIRV_DIS OR NOT SPIRV_VAL); include(ExternalProject). set(BINARY_DIR ${CMAKE_CURRENT_BINARY_DIR}/SPIRVTools-bin). ExternalProject_Add(SPIRVTools; GIT_REPOSITORY https://github.com/KhronosGroup/SPIRV-Tools.git; GIT_TAG main; BINARY_DIR ${BINARY_DIR}; BUILD_COMMAND ${CMAKE_COMMAND} --build ${BINARY_DIR} --target spirv-dis spirv-val; BUILD_BYPRODUCTS ${BINARY_DIR}/tools/spirv-dis ${BINARY_DIR}/tools/spirv-val; DOWNLOAD_COMMAND git clone https://github.com/KhronosGroup/SPIRV-Tools.git SPIRVTools &&; cd SPIRVTools &&; ${Python3_EXECUTABLE} utils/git-sync-deps; UPDATE_COMMAND git pull origin main &&; ${Python3_EXECUTABLE} utils/git-sync-deps; # Don't auto-update on every build.; UPDATE_DISCONNECTED 1; # Allow manual updating with an explicit SPIRVTools-update target.; STEP_TARGETS update; # Install handled below.; INSTALL_COMMAND """"; ); endif (). if (CMAKE_HOST_UNIX); set(LLVM_LINK_OR_COPY create_symlink); else (); set(LLVM_LINK_OR_COPY copy); endif (). # Link the provided or just built spirv-dis and spirv-val binaries.; if (SPIRV_DIS); add_custom_target(spirv-dis; COMMAND ${CMAKE_COMMAND} -E ${LLVM_LINK_OR_COPY} ""${SPIRV_DIS}"" ""${LLVM_RUNTIME_OUTPUT_INTDIR}/spirv-dis""); else (); add_custom_target(spirv-dis; COMMAND ${CMAKE_COMMAND} -E ${LLVM_LINK_OR_COPY} ""${BINARY_DIR}/tools/spirv-dis"" ""${LLVM_RUNTIME_OUTPUT_INTDIR}/spirv-dis""; DEPENDS SPIRVTools; ); endif (). if (SPIRV_VAL); add_custom_target(spirv-val; COMMAND ${CMAKE_COMMAND} -E ${LLVM_LINK_OR_COPY",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/spirv-tools/CMakeLists.txt:240,message,message,240,interpreter/llvm-project/llvm/tools/spirv-tools/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/spirv-tools/CMakeLists.txt,2,['message'],['message']
Integrability,"or it; 13. Let drop object on sub-pads; 14. Properly loads ES6 modules for web canvas; 15. Improve performance of TH3/RH3 drawing by using THREE.InstancedMesh; 16. Implement batch mode with '&batch' URL parameter to create SVG/PNG images with default GUI; 17. Adjust node.js implementation to produce identical output with normal browser; 18. Create necessary infrastructure for testing with 'puppeteer'; 19. Support inject of ES6 modules via '&inject=path.mjs'; 20. Using importmap for 'jsroot' in all major HTML files and in demos; 21. Implement `settings.CutAxisLabels` flag to remove labels which may exceed graphical range; 22. Let disable usage of TAxis custom labels via context menu; 23. Let configure default draw options via context menu, they can be preserved in the local storage; 24. Let save canvas as JSON file from context menu, object as JSON from inspector; 25. Upgrade three.js r162 -> r168, use r162 only in node.js because of ""gl"" module; 26. Create unified svg2pdf/jspdf ES6 modules, integrate in jsroot builds; 27. Let create multipage PDF document - in TWebCanvas batch mode; 28. Let add external links via `#url[link]{label}` syntax - including jsPDF support; 29. Support TAttMarker style with line width bigger than 1; 30. Internals - upgrade to eslint 9; 31. Internals - do not select pad (aka gPad) for objects drawing, always use assigned pad painter; 32. Fix - properly save zoomed ranges in drawingJSON(); 33. Fix - properly redraw TMultiGraph; 34. Fix - show empty bin in TProfile2D if it has entries #316; 35. Fix - unzooming on log scale was extending range forevever; 36. Fix - do not force style 8 for hist markers; 37. Fix - ensure minimal hist title height; 38. Fix - disable Bloom effects on Android TGeo displays; 39. Fix - handle reordering of fragments in multipart reply #319; 40. Fix - properly show non-zero entries #320; 41. Fix - display empty hist bin if fSumw2 not zero. ## Changes in 7.7.4; 1. Fix - TGraph Y range selection, do not cross 0; 2. Fix -",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:1922,integrat,integrate,1922,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['integrat'],['integrate']
Integrability,"or kBlue can be specified for markers, lines, arrows etc. The; complete summary of colours is represented by the ROOT ""[colour; wheel](https://root.cern.ch/doc/master/classTColor.html#C02)"". To know more; about the full story, refer to the online documentation of `TColor`. ROOT provides several [graphics; markers](https://root.cern.ch/doc/master/classTAttMarker.html#M2) types. Select; the most suited symbols for your plot among dots, triangles, crosses or; stars. An alternative set of names for the markers is available. ### Arrows and Lines. The macro line *55* shows how to define an arrow and draw it. The class; representing arrows is `TArrow`, which inherits from `TLine`. The; constructors of lines and arrows always contain the coordinates of the; endpoints. Arrows also foresee parameters to [specify; their](https://root.cern.ch/doc/master/classTArrow.html) shapes. Do not; underestimate the role of lines and arrows in your plots. Since each; plot should contain a message, it is convenient to stress it with; additional graphics primitives. ### Text. Also text plays a fundamental role in making the plots self-explanatory.; A possibility to add text in your plot is provided by the `TLatex`; class. The objects of this class are constructed with the coordinates of; the bottom-left corner of the text and a string which contains the text; itself. The real twist is that ordinary; [Latex mathematical symbols](https://root.cern.ch/doc/master/classTLatex.html#L5); are automatically interpreted, you just need to replace the ""\\"" by a ""\#"". If; [""\\"" is used as control character](https://root.cern.ch/doc/master/classTLatex.html#L14); , then the; [TMathText interface](https://root.cern.ch/doc/master/classTMathText.html); is invoked. It provides the plain TeX syntax and allow to access character's; set like Russian and Japanese. ## Interpretation and Compilation. As you observed, up to now we heavily exploited the capabilities of ROOT; for interpreting our code, more than compili",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:8089,message,message,8089,documentation/primer/your_first_ROOT_macro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md,1,['message'],['message']
Integrability,"or lanes:. * ``sN`` for scalars; * ``pN`` for pointers; * ``<N x sM>`` for vectors. ``LLT`` is intended to replace the usage of ``EVT`` in SelectionDAG. Here are some LLT examples and their ``EVT`` and ``Type`` equivalents:. ============= ========= ======================================; LLT EVT IR Type; ============= ========= ======================================; ``s1`` ``i1`` ``i1``; ``s8`` ``i8`` ``i8``; ``s32`` ``i32`` ``i32``; ``s32`` ``f32`` ``float``; ``s17`` ``i17`` ``i17``; ``s16`` N/A ``{i8, i8}`` [#abi-dependent]_; ``s32`` N/A ``[4 x i8]`` [#abi-dependent]_; ``p0`` ``iPTR`` ``i8*``, ``i32*``, ``%opaque*``; ``p2`` ``iPTR`` ``i8 addrspace(2)*``; ``<4 x s32>`` ``v4f32`` ``<4 x float>``; ``s64`` ``v1f64`` ``<1 x double>``; ``<3 x s32>`` ``v3i32`` ``<3 x i32>``; ============= ========= ======================================. Rationale: instructions already encode a specific interpretation of types; (e.g., ``add`` vs. ``fadd``, or ``sdiv`` vs. ``udiv``). Also encoding that; information in the type system requires introducing bitcast with no real; advantage for the selector. Pointer types are distinguished by address space. This matches IR, as opposed; to SelectionDAG where address space is an attribute on operations.; This representation better supports pointers having different sizes depending; on their addressspace. .. note::. .. caution::. Is this still true? I thought we'd removed the 1-element vector concept.; Hypothetically, it could be distinct from a scalar but I think we failed to; find a real occurrence. Currently, LLT requires at least 2 elements in vectors, but some targets have; the concept of a '1-element vector'. Representing them as their underlying; scalar type is a nice simplification. .. rubric:: Footnotes. .. [#abi-dependent] This mapping is ABI dependent. Here we've assumed no additional padding is required. Generic Opcode Reference; ------------------------. The Generic Opcodes that are available are described at :doc:`GenericOpcode`.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GMIR.rst:8489,depend,depending,8489,interpreter/llvm-project/llvm/docs/GlobalISel/GMIR.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GMIR.rst,3,['depend'],"['dependent', 'depending']"
Integrability,"or only a single line; of code, after which the diagnostics return to whatever state had previously; existed. .. code-block:: c. #if foo; #endif foo // warning: extra tokens at end of #endif directive. #pragma clang diagnostic push; #pragma clang diagnostic ignored ""-Wextra-tokens"". #if foo; #endif foo // no warning. #pragma clang diagnostic pop. The push and pop pragmas will save and restore the full diagnostic state; of the compiler, regardless of how it was set. That means that it is; possible to use push and pop around GCC compatible diagnostics and Clang; will push and pop them appropriately, while GCC will ignore the pushes; and pops as unknown pragmas. It should be noted that while Clang; supports the GCC pragma, Clang and GCC do not support the exact same set; of warnings, so even when using GCC compatible #pragmas there is no; guarantee that they will have identical behaviour on both compilers. In addition to controlling warnings and errors generated by the compiler, it is; possible to generate custom warning and error messages through the following; pragmas:. .. code-block:: c. // The following will produce warning messages; #pragma message ""some diagnostic message""; #pragma GCC warning ""TODO: replace deprecated feature"". // The following will produce an error message; #pragma GCC error ""Not supported"". These pragmas operate similarly to the ``#warning`` and ``#error`` preprocessor; directives, except that they may also be embedded into preprocessor macros via; the C99 ``_Pragma`` operator, for example:. .. code-block:: c. #define STR(X) #X; #define DEFER(M,...) M(__VA_ARGS__); #define CUSTOM_ERROR(X) _Pragma(STR(GCC error(X "" at line "" DEFER(STR,__LINE__)))). CUSTOM_ERROR(""Feature not available"");. Controlling Diagnostics in System Headers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Warnings are suppressed when they occur in system headers. By default,; an included file is treated as a system header if it is found in an; include path specified by ``-isyste",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:40643,message,messages,40643,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['message'],['messages']
Integrability,"or themselves would revert the change per these; guidelines, we encourage other contributors to do so as a courtesy to the; author. This is one of the major cases where our norms differ from others;; we generally consider reverting a normal part of development. We don't; expect contributors to be always available, and the assurance that a; problematic patch will be reverted and we can return to it at our next; opportunity enables this. What are the expectations around a revert?. * Use your best judgment. If you're uncertain, please start an email on; the commit thread asking for assistance. We aren't trying to enumerate; every case, but rather give a set of guidelines.; * You should be sure that reverting the change improves the stability of tip; of tree. Sometimes reverting one change in a series can worsen things; instead of improving them. We expect reasonable judgment to ensure that; the proper patch or set of patches is being reverted.; * The commit message for the reverting commit should explain why patch; is being reverted.; * It is customary to respond to the original commit email mentioning the; revert. This serves as both a notice to the original author that their; patch was reverted, and helps others following llvm-commits track context.; * Ideally, you should have a publicly reproducible test case ready to share.; Where possible, we encourage sharing of test cases in commit threads, or; in PRs. We encourage the reverter to minimize the test case and to prune; dependencies where practical. This even applies when reverting your own; patch; documenting the reasons for others who might be following along; is critical.; * It is not considered reasonable to revert without at least the promise to; provide a means for the patch author to debug the root issue. If a situation; arises where a public reproducer can not be shared for some reason (e.g.; requires hardware patch author doesn't have access to, sharp regression in; compile time of internal workload, etc.)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:21170,message,message,21170,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['message'],['message']
Integrability,"or()(const double * p)` where **`p`** is the parameter vectors. In this case one needs to pass the number of parameters,; the function object and optionally a vector of initial parameter values. Other optional parameter include the size of the data sets and a flag specifying if it is a chi2 (least-square fit).; In the last two parameters are given, the `chi2/ndf` can be computed after fitting the data.; ``` {.cpp}; template <class Function>; bool Fitter::SetFCN(unsigned int npar, Function & f,; const double * initialParameters = 0,; unsigned int dataSize=0, bool isChi2Fit = false); ```. * A function object implementing the `ROOT::Math::IBaseFunctionMultiDim` interface:; ``` {.cpp}; bool Fitter::SetFCN(const ROOT::Math::IBaseFunctionMultiDim & f,; const double * initialParameters = 0,; unsigned int dataSize=0, bool isChi2Fit = false); ```. * A function object implementing the `ROOT::Math::FitMethodFunction` interface. This is an interface class extending; the `ROOT::Math::IBaseFunctionMultiDim` with some extra functionality which can be used when fitting.; This extra functionality is required by dedicated fitting algorithms like *Fumili* or *GSLMultiFit*.; ``` {.cpp}; bool Fitter::SetFCN(const ROOT::Math::FitMethodFunction & f,; const double * initialParameters = 0, unsigned int dataSize=0); ```. * A old-Minuit like FCN interface (i.e. a free function with the signature `fcn(int &npar, double *gin, double &f, double *u, int flag)`.; ``` {.cpp}; typedef void(* MinuitFCN)(int &npar, double *gin, double &f, double *u, int flag); bool Fitter::SetFCN(MinuitFCN fcn, int npar,; const double * initialParameters = 0,; unsigned int dataSize=0, bool isChi2Fit = false); ```. ### Fit Result. The result of the fit is contained in the `ROOT::Fit::Result` object. A reference to the result object is obtained with the function; `Fitter::Result()`.; The `ROOT::Fit::FitResult` class provides an API for retrieving parameter values, errors, covariance and correlation matrix from the fit,;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:48801,interface,interface,48801,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['interface'],['interface']
Integrability,"or. > The RNTuple code uses the nomenclature from the [RNTuple format specification](https://github.com/root-project/root/blob/master/tree/ntuple/v7/doc/BinaryFormatSpecification.md) (e.g. ""field"", ""column"", ""anchor"", etc.). General Principles; ------------------. The RNTuple classes provide the functionality to read, write, and describe RNTuple datasets.; The core classes, such as `RNTupleReader` and `RNTupleWriter`, are part of the RNTuple library.; Additional tools, such as the `RNTupleImporter` and the `RNTupleInspector`, are part of the RNTupleUtils library,; which depends on the RNTuple library. The RNTuple classes are organized in layers:; the storage layer, the primitives layer, the logical layer and the event iteration layer.; Most classes in the storage layer and the primitives layer are in the `ROOT::Internal` namespace (non-public interfaces),; with the notable exception of the descriptor classes (`RNTupleDescriptor`, `RFieldDescriptor`, etc.).; Most classes in the upper layers provide public interfaces. | Layer | Description | Example of classes |; |------------|---------------------------------------------------------------------|-------------------------------------------------------------|; | Storage | Read and write pages (physical: file, object store; virtual: e.g. buffered) | RPage{Source,Sink}, RNTupleDescriptor, RClusterPool |; | Primitives | Storage-backed columns of simple types | RColumn, RColumnElement, RPage |; | Logical | Mapping of C++ types onto columns | RField, RNTupleModel, REntry |; | Iteration | Reading and writing events / properties | RNTuple{Reader,Writer}, RNTupleView, RNTupleDS (RDataFrame) |; | Tooling | Higher-level, RNTuple related utility classes | RNTupleMerger, RNTupleImporter, RNTupleInspector |. The RNTuple classes are, unless explicitly stated otherwise, conditionally thread safe. The read and write APIs provide templated, compile-time type-safe APIs,; APIs where the type at hand is passed as string and which are runtim",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:1192,interface,interfaces,1192,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['interface'],['interfaces']
Integrability,or/LorentzVector.h; Math/GenVector/Plane3D.h; Math/GenVector/Polar2Dfwd.h; Math/GenVector/Polar2D.h; Math/GenVector/Polar3Dfwd.h; Math/GenVector/Polar3D.h; Math/GenVector/PositionVector2Dfwd.h; Math/GenVector/PositionVector2D.h; Math/GenVector/PositionVector3Dfwd.h; Math/GenVector/PositionVector3D.h; Math/GenVector/PtEtaPhiE4Dfwd.h; Math/GenVector/PtEtaPhiE4D.h; Math/GenVector/PtEtaPhiM4Dfwd.h; Math/GenVector/PtEtaPhiM4D.h; Math/GenVector/PxPyPzE4Dfwd.h; Math/GenVector/PxPyPzE4D.h; Math/GenVector/PxPyPzM4Dfwd.h; Math/GenVector/PxPyPzM4D.h; Math/GenVector/Quaternionfwd.h; Math/GenVector/Quaternion.h; Math/GenVector/Rotation3Dfwd.h; Math/GenVector/Rotation3D.h; Math/GenVector/RotationXfwd.h; Math/GenVector/RotationX.h; Math/GenVector/RotationYfwd.h; Math/GenVector/RotationY.h; Math/GenVector/RotationZfwd.h; Math/GenVector/RotationZ.h; Math/GenVector/RotationZYXfwd.h; Math/GenVector/RotationZYX.h; Math/GenVector/Transform3D.h; Math/GenVector/Translation3D.h; Math/GenVector/VectorUtil.h; Math/LorentzRotation.h; Math/LorentzVector.h; Math/Plane3D.h; Math/Point2Dfwd.h; Math/Point2D.h; Math/Point3Dfwd.h; Math/Point3D.h; Math/Polar2D.h; Math/Polar3D.h; Math/PositionVector2D.h; Math/PositionVector3D.h; Math/PtEtaPhiE4D.h; Math/PtEtaPhiM4D.h; Math/PxPyPzE4D.h; Math/PxPyPzM4D.h; Math/Quaternion.h; Math/Rotation3D.h; Math/RotationX.h; Math/RotationY.h; Math/RotationZ.h; Math/RotationZYX.h; Math/Transform3D.h; Math/Translation3D.h; Math/Vector2Dfwd.h; Math/Vector2D.h; Math/Vector3Dfwd.h; Math/Vector3D.h; Math/Vector4Dfwd.h; Math/Vector4D.h; Math/VectorUtil.h; MODULE; GenVector; LINKDEF; Math/LinkDef_GenVector.h; OPTIONS; -writeEmptyRootPCM; DEPENDENCIES; Core; MathCore; ). ROOT_GENERATE_DICTIONARY(G__GenVector32; Math/Point2D.h; Math/Point3D.h; Math/Vector2D.h; Math/Vector3D.h; Math/Vector4D.h; MODULE; GenVector; MULTIDICT; LINKDEF; Math/LinkDef_GenVector32.h; OPTIONS; -writeEmptyRootPCM; DEPENDENCIES; Core; MathCore; ). ROOT_ADD_TEST_SUBDIRECTORY(test). ROOT_INSTALL_HEADERS(); ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/CMakeLists.txt:3899,DEPEND,DEPENDENCIES,3899,math/genvector/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/CMakeLists.txt,2,['DEPEND'],['DEPENDENCIES']
Integrability,"or_length>); declare <vscale x 4 x ptr> @llvm.vp.inttoptr.nxv4p0.nxv4i32 (<vscale x 4 x i32> <op>, <vscale x 4 x i1> <mask>, i32 <vector_length>); declare <256 x ptr> @llvm.vp.inttoptr.v256p0.v256i32 (<256 x i32> <op>, <256 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". The '``llvm.vp.inttoptr``' intrinsic converts its integer value to the point; return type. The operation has a mask and an explicit vector length parameter. Arguments:; """""""""""""""""""". The '``llvm.vp.inttoptr``' intrinsic takes a value to cast as its first operand; , which must be a vector of :ref:`integer <t_integer>` type, and a type to cast; it to return type, which must be a vector of pointers type.; The second operand is the vector mask. The return type, the value to cast, and; the vector mask have the same number of elements.; The third operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.inttoptr``' intrinsic converts ``value`` to return type by; applying either a zero extension or a truncation depending on the size of the; integer ``value``. If ``value`` is larger than the size of a pointer, then a; truncation is done. If ``value`` is smaller than the size of a pointer, then a; zero extension is done. If they are the same size, nothing is done (*no-op cast*).; The conversion is performed on lane positions below the explicit vector length; and where the vector mask is true. Masked-off lanes are ``poison``. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call <4 x ptr> @llvm.vp.inttoptr.v4p0i32.v4i32(<4 x i32> %a, <4 x i1> %mask, i32 %evl); ;; For all lanes below %evl, %r is lane-wise equivalent to %also.r. %t = inttoptr <4 x i32> %a to <4 x ptr>; %also.r = select <4 x i1> %mask, <4 x ptr> %t, <4 x ptr> poison. .. _int_vp_fcmp:. '``llvm.vp.fcmp.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare <16 x i1> @llvm.vp.fcmp.v16f32(<16 x float> <left_op>, <16 x float> <right_op>, metadata",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:816110,depend,depending,816110,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['depending']
Integrability,"or`**; which is based on the Adaptive integration algorithms of QUADPACK. - Numerical differentiation via **`ROOT::Math::GSLDerivator`**. - Root finder implementing the **`ROOT::Math::RootFinder`** interface, using different; solver algorithms from GSL. - one-dimensional Minimization implementing the interface**`ROOT::Math::IMinimizer1D`**. - Interpolation via **`ROOT::Math::Interpolation`**. All the GSL; interpolation types are supported. - Function approximation based on Chebyshev polynomials via the class; **`ROOT::Math::Chebyshev`**. - Random number generators and distributions based on GSL using the `ROOT::Math::Random<Engine_type>` class. - Polynomial evaluation and root solvers. The mathematical functions are implemented as a set of free functions in; the namespace **`ROOT::Math`**. The naming used for the special; functions is the same proposed for the C++ standard (see C++ standard; extension [proposal document](proposal document)).The `MathMore` library; is implemented wrapping in C++ the GNU Scientific Library ( <GSL>).; Building `MathMore` requires a version of GSL larger or equal 1.8. The; source code of `MathMore` is distributed under the GNU General Public; License. `MathMore` (and its ROOT Cling dictionary) can be built within ROOT; whenever a GSL library is found in the system. The GSL library and; header file location can be specified in the ROOT configure script, by; doing:. ```; ./configure --with-gsl-incdir=... --with-gsl-libdir=...; ```. `MathMore` can be built also a stand-alone library (without requiring; ROOT) downloding the tar file from the Web at this link. In this case; the library will not contain the dictionary information and therefore; cannot be used interactively. More information on the classes and functions present in `MathMore` is; available in the; [online reference documentation](online reference documentation). ## TMath. In the namespace, **`TMath`**, a collection of free functions is provided for the following functionality:. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:4898,wrap,wrapping,4898,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['wrap'],['wrapping']
Integrability,orability of [[noreturn]] during constant evaluation; Unknown. 2764; DR; Use of placeholders affecting name mangling; Unknown. 2765; open; Address comparisons between potentially non-unique objects during constant evaluation; Not resolved. 2766; open; Repeated evaluation of a string-literal may yield different objects; Not resolved. 2767; open; Non-defining declarations of anonymous unions; Not resolved. 2768; DR; Assignment to enumeration variable with a braced-init-list; Unknown. 2769; open; Substitution into template parameters and default template arguments should be interleaved; Not resolved. 2770; open; Trailing requires-clause can refer to function parameters before they are substituted into; Not resolved. 2771; open; Transformation for unqualified-ids in address operator; Not resolved. 2772; DR; Missing Annex C entry for linkage effects of linkage-specification; Unknown. 2773; open; Naming anonymous union members as class members; Not resolved. 2774; open; Value-dependence of requires-expressions; Not resolved. 2775; tentatively ready; Unclear argument type for copy of exception object; Unknown. 2776; open; Substitution failure and implementation limits; Not resolved. 2777; open; Type of id-expression denoting a template parameter object; Not resolved. 2778; open; Trivial destructor does not imply constant destruction; Not resolved. 2779; open; Restrictions on the ordinary literal encoding; Not resolved. 2780; DR; reinterpret_cast to reference to function types; Unknown. 2781; open; Unclear recursion in the one-definition rule; Not resolved. 2782; open; Treatment of closure types in the one-definition rule; Not resolved. 2783; DR; Handling of deduction guides in global-module-fragment; Unknown. 2784; open; Unclear definition of member-designator for offsetof; Not resolved. 2785; DR; Type-dependence of requires-expression; Unknown. 2786; open; Comparing pointers to complete objects; Not resolved. 2787; open; Kind of explicit object copy/move assignment functi,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:192246,depend,dependence,192246,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['depend'],['dependence']
Integrability,"ordDecl(hasName(""X""))))); and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(""X""))))); and U (matcher = typedefDecl(hasType(asString(""int""))); and friend class X (matcher = friendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; asString(""class X""))); class X {};; void y(X &x) { x; X z; }; typedef int U;; class Y { friend class X; };; class Z : public virtual X {};. Matcher<Expr>ignoringElidableConstructorCallast_matchers::Matcher<Expr> InnerMatcher; Matches expressions that match InnerMatcher that are possibly wrapped in an; elidable constructor and other corresponding bookkeeping nodes. In C++17, elidable copy constructors are no longer being generated in the; AST as it is not permitted by the standard. They are, however, part of the; AST in C++14 and earlier. So, a matcher must abstract over these differences; to work in all language modes. This matcher skips elidable constructor-call; AST nodes, `ExprWithCleanups` nodes wrapping elidable constructor-calls and; various implicit nodes inside the constructor calls, all of which will not; appear in the C++17 AST. Given. struct H {};; H G();; void f() {; H D = G();; }. ``varDecl(hasInitializer(ignoringElidableConstructorCall(callExpr())))``; matches ``H D = G()`` in C++11 through C++17 (and beyond). Matcher<Expr>ignoringImpCastsMatcher<Expr> InnerMatcher; Matches expressions that match InnerMatcher after any implicit casts; are stripped off. Parentheses and explicit casts are not discarded.; Given; int arr[5];; int a = 0;; char b = 0;; const int c = a;; int *d = arr;; long e = (long) 0l;; The matchers; varDecl(hasInitializer(ignoringImpCasts(integerLiteral()))); varDecl(hasInitializer(ignoringImpCasts(declRefExpr()))); would match the declarations for a, b, c, and d, but not e.; While; varDecl(hasInitializer(integerLiteral())); varDecl(hasInitializer(declRefExpr())); only match the declarations for a. Matcher<Expr>ignoringImplicitMatcher<Expr> InnerMatcher; Matches expressions that ma",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:195282,wrap,wrapping,195282,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['wrap'],['wrapping']
Integrability,"ore detail: rf509_wsinteractive.C.; writeToFile -- A new utility method RooWorkspace::writeToFile() has been added; to simplify the process of saving a workspace to file; Named sets and parameter snapshots -- It is now possible to define and retrieve; named RooArgSets of objects that live in the workspace through methods; defineSet() and set(). While named sets merely group objects logically, methods loadSnapshot and; saveSnapshot allow to make copies of the values, errors and 'constant' status of; sets of variable objects that live in the workspace. A newly added tutorial macro rf510_namedsets.C illustrates the functionality of both; of these features.; Improved printing of contents -- Many operator p.d.f. and function components now show; a more intuitive natural representation of their contents (these changes are mostly in the; respective p.d.f.s, but are most relevant in the context of a workspace). New object factory interface to workspace to facilitate script driven model definition; A object factory has been added to RooFit to simplify the process of creating p.d.f.; and function expressions consisting of multiple objects. The factory has two goals:; the first is to provide a back-end for higher level factories and tools to process; the creation of objects. The second is to provide a simple end-user language to; populate a RooWorkspace with function and p.d.f. objects. For the latter purpose the object creation language is executed through the factory() method; of a workspace object. RooWorkspace w(""w"") ;; RooAbsArg* arg = w.factory(""expression_goes_here"") ;. Basic Syntax; The rules at its simplest level are as follows. Expressions with square brackets create variables (discrete and continuous). ""m[-10,10]"" - Creates a RooRealVar named 'm' with range [-10,10]; ""m[5,-10,10]"" - Idem, but with initial value 5; ""m[5]"" - Creates a constant RooRealVar with name 'm' and value 5. ""tagCat[Lep,Kao,NT1,NT2]"" -- Creates a RooCategory with name tagCat and labeled states Le",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:18080,interface,interface,18080,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,2,['interface'],['interface']
Integrability,"ore_veto}; ${fftw3_veto}; ${opengl_veto}; ${gviz_veto}; ${r_veto}; ${runtime_cxxmodules_veto}; ${histfactory_veto}; ${tbb_veto}; ${imt_veto}; ${classic_veto}; ${geom_veto}; ${pythia_veto}; ${vecgeom_veto}; ${root7_veto}; ${xrootd_veto}; ${spectrum_veto}; ${dataframe_veto}; ${macm1_veto}; ${clad_veto}; ${proof_veto}; ). file(GLOB_RECURSE tutorials RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} *.C); if(webgui); file(GLOB_RECURSE tutorials_webcanv RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} webcanv/*.cxx); list(APPEND tutorials ${tutorials_webcanv}); endif(); if(root7 AND webgui); file(GLOB_RECURSE tutorials_v7 RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} v7/*.cxx); list(APPEND tutorials ${tutorials_v7}); file(GLOB_RECURSE tutorials_rcanvas RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} rcanvas/*.cxx); list(APPEND tutorials ${tutorials_rcanvas}); endif(); file(GLOB tutorials_veto RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} ${all_veto}). list(LENGTH tutorials nTotal); list(REMOVE_ITEM tutorials ${tutorials_veto}); list(LENGTH tutorials nAfterVeto); message(STATUS ""${nAfterVeto}/${nTotal} C++ tutorials have been activated.""). if(mpi); set (temp_list ${tutorials}); list(FILTER tutorials INCLUDE REGEX ""MPI""); set(mpi_tutorials ${tutorials}); set(tutorials ${temp_list}); list(REMOVE_ITEM tutorials ${mpi_tutorials}); endif(). #---Special return code------------------------------------------------; set(returncode_1 fit/fit2a.C; graphics/earth.C; graphics/pavetext.C; graphics/tmathtext.C graphics/tmathtext2.C; graphs/exclusiongraph.C; graphs/graphstruct.C; hist/ContourList.C; hist/hbars.C; hist/th2polyBoxes.C; hist/statsEditing.C; hist/cumulative.C; hist/hlabels1.C; hist/hlabels2.C; tree/h1analysis.C; math/chi2test.C; r/SimpleFitting.C); #---Dependencies------------------------------------------------------; set(unfold-testUnfold5d-depends tutorial-unfold-testUnfold5c); set(unfold-testUnfold5c-depends tutorial-unfold-testUnfold5b); set(unfold-testUnfold5b-depends tutorial-unfold-testUnfold5a); set(unfold-testUnfold7d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt:15939,message,message,15939,tutorials/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt,1,['message'],['message']
Integrability,"orithms (start with k, like kADAPTIVE for the integration type). This affects both MathCore and MathMore.; . In addition we use now the ROOT convention for all enumeration names defining the type of numerical algorithms. The names start with k, like kADAPTIVE for the integration type. This change affects both MathCore and MathMore and it breaks backward compatibility. MathCore Function interfaces; Mathcore provides as well interfaces for the evaluation of mathematical and parametric functions to be used in the numerical methods. This release contains the following changes:. The ROOT::Math::IParamFunction, ROOT::Math::IParamMultiFunction interfaces (used mainly for fitting) require now a pointer to the parameters (type const double *), when evaluating the function. The derived classes must implement now the const; method DoEvalPar (and not DoEval as before). In addition the method; operator()(const double * x, const double * p) is now const. This change makes the caching of parameter not hidden and the interface is now; thread-safe. ; A similar change in the ROOT::Math::IParamGradFunction, ROOT::Math::IParamMultiGradFunction interfaces, where the parameter values are now required for calculating the partial derivatives with respect to the parameters.; This changes the signature of the pure abstract method, DoParameterDerivative(const double *x, const double * p, , which takes also a pointer (type const double *) to the parameters.; In addition, these classes do not inherit anymore from the function gradient interface (ROOT::Math::IGradFunction and ROOT::Math::IMultiGradFunction). They define only the parameter gradient which is needed for fitting and not the coordinate gradient. A derived class, like ROOT::Math::Polynomial, implementing both functionality (coordinate and parameter gradient) inherits then from both interfaces.; . More detailed description of the current MathCore release can be found at this location. MathMore; This new release contains:. Modify and ren",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:9348,interface,interface,9348,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,2,['interface'],['interface']
Integrability,"orkspace - Add private expensive object cache to workspace; RooBinningCategory - New real-to-category function that maps values of input RooRealVar to categories with labels that correspond to bins of input RooRealVar. See rf405_realtocatfuncs.C for details . RooStats; This is a new package introduced in this version for statistical tools built on top of RooFit. It is a joint effort between the LHC experiments and the ROOT team (see the RooStats Wiki page).; ; This version contains the interfaces for performing the statistical calculations and dealing with the obtained results and concrete classes implementing the statistical methods.; ; All the classes and functions in RooStats are provided in the namespace RooStats.; ; RooStats interfaces. ConfInterval: interface for describing a confidence interval. ; IntervalCalculator: interface for a statistical tool producing confidence intervals (class ConfInterval).; HypoTestResult: interface for representing results of a hypothesis test; HypoTestCalculator: interface for a statistical tool performing an hypothesis test. ; CombinedCalculator: interface for a statistical tool which can produce both hypothesis test results and confidence intervals. ; RooStats concrete classes. The concrete classes describing statistical tools implementing the above interfaces are:; ; ProfileLikelihoodCalculator: it is an implementation of a CombinedCalculator using the profile likelihood ratio as a test statistics. After configuring the calculator, one only needs to ask GetHypoTest() (which will return a HypoTestResult pointer) or GetInterval() (which will return an ConfInterval pointer).; LikelihoodInterval: concrete implementation of a ConfInterval interface. It implements connected N-dimensional intervals based on the contour of a likelihood ratio. The boundary of the interval is equivalent to a MINUIT/MINOS contour about the maximum likelihood estimator. . HybridCalculator: hypothesis test calculator using a Bayesian-frequentist hybrid me",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html:10014,interface,interface,10014,roofit/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html,4,['interface'],['interface']
Integrability,"ormation. .. note::. ``-ds-aa`` is available in the optional ""poolalloc"" module. It is not part of; the LLVM core. The ``-scev-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^. The ``-scev-aa`` pass implements AliasAnalysis queries by translating them into; ScalarEvolution queries. This gives it a more complete understanding of; ``getelementptr`` instructions and loop induction variables than other alias; analyses have. Alias analysis driven transformations; -------------------------------------. LLVM includes several alias-analysis driven transformations which can be used; with any of the implementations above. The ``-adce`` pass; ^^^^^^^^^^^^^^^^^^. The ``-adce`` pass, which implements Aggressive Dead Code Elimination uses the; ``AliasAnalysis`` interface to delete calls to functions that do not have; side-effects and are not used. The ``-licm`` pass; ^^^^^^^^^^^^^^^^^^. The ``-licm`` pass implements various Loop Invariant Code Motion related; transformations. It uses the ``AliasAnalysis`` interface for several different; transformations:. * It uses mod/ref information to hoist or sink load instructions out of loops if; there are no instructions in the loop that modifies the memory loaded. * It uses mod/ref information to hoist function calls out of loops that do not; write to memory and are loop-invariant. * It uses alias information to promote memory objects that are loaded and stored; to in loops to live in a register instead. It can do this if there are no may; aliases to the loaded/stored memory location. The ``-argpromotion`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``-argpromotion`` pass promotes by-reference arguments to be passed in; by-value instead. In particular, if pointer arguments are only loaded from it; passes in the value loaded instead of the address to the function. This pass; uses alias information to make sure that the value loaded from the argument; pointer is not modified between the entry of the function and any load of the; pointer. The ``-gvn``, ``-memcpyop",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:27674,interface,interface,27674,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['interface'],['interface']
Integrability,"orrespondence between the code source and the json file. Those files do not; have any doc in them. With a direct link to the GitHub source file the dependency between source; code and json is now more obvious.; - Document how to remove shadow of `TPave`, as it was not evident (only explanations were hidden here and there in the forum).; - Improve the `SetFillColorAlpha` documentation.; - Simplify some graphics examples: arrow.C, crown.C, diamond.C and ellipse.C.; - Fix a typo in the documentation of `TGraph::SetHighlight` in `TGraph.cxx`.; - Change the marker style in the tutorial `df014_CSVDataSource`.; - Remove useless settings in the tutorial `scatter.C`.; - Fix the tutorial `h1analysisTreeReader.C`.; - Fix doxygen formatting in `TGNumberEntry.cxx`.; - Avoid the CDT documentation to appear in the reference guide.; - Remove last references to the old ROOT `drupal` website. ## Build, Configuration and Testing Infrastructure. Release v6.32.00 is the first one integrated and tested entirely through the new GitHub based build system. ## Bugs and Issues fixed in this release. More than 200 items were addressed for this release. The full list is:. * [[#15621](https://github.com/root-project/root/issues/15621)] - Buffer overflow in TBranch::Init; * [[#15610](https://github.com/root-project/root/issues/15610)] - Memory leak in TTree __getattr__ pythonization; * [[#15590](https://github.com/root-project/root/issues/15590)] - Infinite recursion in TFile::Open; * [[#15460](https://github.com/root-project/root/issues/15460)] - TEnum::GetEnum(""B"")->GetUnderlyingType() does not following typedefs; * [[#15413](https://github.com/root-project/root/issues/15413)] - Fails to build with cuDNN version 9; * [[#15406](https://github.com/root-project/root/issues/15406)] - `TEnum::GetEnum` does not seem to see 'through' using statements.; * [[#15399](https://github.com/root-project/root/issues/15399)] - Memory leak with jitted nodes if the execution is never triggered; * [[#15396](https:/",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:24670,integrat,integrated,24670,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['integrat'],['integrated']
Integrability,"ort PATH=$PATH:/Applications/CMake.app/Contents/bin/; ~~~; and. ~~~{.sh}; source ~/.profile; ~~~. Install needed R packages, open R and in the prompt type. ~~~{.sh}; install.packages(c('Rcpp','RInside')); ~~~; select a mirror and install. Install the next additional packages for R TMVA interface. ~~~{.sh}; install.packages(c('C50','RSNNS','e1071','xgboost')); ~~~. Download code from git repo. ~~~{.sh}; git clone http://root.cern.ch/git/root.git; ~~~. To compile ROOTR lets to create a compilation directory and to activate it use cmake -Dr=ON .. ~~~{.sh}; mkdir compile; cd compile; cmake -Dr=ON ..; make -j 5; ~~~. ### Compiling ROOTR on Gnu/Linux with CMake:; **NOTE:** Tested on Gnu/Linux Debian Jessie with gcc 4.9. **Prerequisities**; install; (For debian-based distros). ~~~{.sh}; apt-get install r-base r-base-dev; ~~~; Install needed R packages, open R and in the prompt type. ~~~{.sh}; install.packages(c('Rcpp','RInside')); ~~~; select a mirror and install. Install the next additional packages for R TMVA interface. ~~~{.sh}; install.packages(c('C50','RSNNS','e1071','xgboost')); ~~~. Download code from git repo. ~~~{.sh}; git clone http://root.cern.ch/git/root.git; ~~~. To compile ROOTR lets to create a compilation directory and to activate it use cmake -Dr=ON .. ~~~{.sh}; mkdir compile; cd compile; cmake -Dr=ON ..; make -j 5; ~~~. ## How does it work ?; There is a class called TRInterface which is located at the header TRInterface.h and uses the namespace `ROOT::R`, it is in charge; of making calls to R to give and obtain data. This class has a series of overcharged operators which ease the passing and obtaining of data; and code from R to C++ and vice versa. To create an object of this class the user must use the static methods `ROOT::R::TRInterface::Instance`; and `ROOT::R::TRInterface::InstancePtr` which return a reference object and a pointer object respectively. ~~~{.cxx}; #include<TRInterface.h>; ROOT::R::TRInterface &r=ROOT::R::TRInterface::Instance();; ~~~. #",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/r/doc/users-guide/ROOTR_Users_Guide.md:2751,interface,interface,2751,bindings/r/doc/users-guide/ROOTR_Users_Guide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/r/doc/users-guide/ROOTR_Users_Guide.md,1,['interface'],['interface']
Integrability,"ort for the option 'noaddr' which ; prevents the printing of the address of the object. This; is useful in particular in roottest. Use this in hadd; and TFileMerger. TROOT. New routine CloseFiles used automatically shortly before termination to ; insure closing of files and sockets before the unload of any library.; New collection 'ClosedObjects' holding pointers to TFile or TSocket that; have been closed but not deleted it. In the case of TSocket, they are added only; if they are closed by the CloseFiles.; Add a Close member function to TProofMgr since it is added to the list of socket.; Migrate the closing of files from various to a single place (T*System::Exit).; Fill in the implementation of TROOT::FindObjectAnyFile.; Mark TROOT as TObject::kInvalidObject as soon as its destructor starts,; in order to be able to veto some action later on (like autoloading). TSystem. Better handle the cases where the information in the rootmap file is (almost) empty. ; Avoid infinite loop if one of the dependent library is missing. Meta. Add new fast accessors to Merge routines (See the I/O package for more details.; Improve error message in case a schema evolution rule can not be loaded when the library is loaded; (from the generic 'it conflicts with one of the other rules' to 'the target member ... is unknown'.; Add the ability to explicitly forbid (or allow) the splitting of a class; (TClass::SetSplit ) so that user can inforce the use of a custom streamer in all possible split cases.; Improve the performance of TProcessUUID::AddUUID by reintroducing the THashList.; This significanly improve the performance of reading file with very large number of ; directories (A file with 100,000 directories was traversed in more than 8 minutes; and is now traversed in 15s) without noticeable affecting small files. TFolder. Several enhancement and clarification to TFolder::FindFullPathName. TStyle. Add the fill color attribute (SetLegendFillColor() and the font; attribute (SetLegendFont(). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v530/index.html:1398,depend,dependent,1398,core/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v530/index.html,2,['depend'],['dependent']
Integrability,"ort parallel builds, but not distributed; builds.; It is also possible to use scan-build to analyze specific; files:. $ scan-build gcc -c t1.c t2.c. This example causes the files t1.c and t2.c to be analyzed. For Windows Users; Windows users must have Perl installed to use scan-build.; scan-build.bat script allows you to launch scan-build in the same; way as it described in the Basic Usage section above. To invoke scan-build from; an arbitrary location, add the path to the folder containing scan-build.bat to; your PATH environment variable.; If you have unexpected compilation/make problems when running scan-build; with MinGW/MSYS the following information may be helpful:. If getting unexpected ""fatal error: no input files"" while; building with MSYS make from the Windows cmd, try one of these solutions:. Use MinGW mingw32-make instead of MSYS make and; exclude the path to MSYS from PATH to prevent mingw32-make from using; MSYS utils. MSYS utils are dependent on the MSYS runtime and they are not; intended for being run from the Windows cmd. Specifically, makefile commands; with backslashed quotes may be heavily corrupted when passed for execution.; Run make from the sh shell:. $ scan-build [scan-build options] sh -c ""make [make options]"". If getting ""Error : *** target pattern contains no `%'"" while; using GNU Make 3.81, try to use another version of make. Other Options; As mentioned above, extra options can be passed to scan-build. These; options prefix the build command. For example:. $ scan-build -k -V make; $ scan-build -k -V xcodebuild. Here is a subset of useful options:. OptionDescription; -oTarget directory for HTML report files. Subdirectories; will be created as needed to represent separate ""runs"" of the analyzer. If this; option is not specified, a directory is created in /tmp to store the; reports.; -h(or no arguments)Display all; scan-build options.; -k--keep-goingAdd a ""keep on; going"" option to the specified build command. This option currently supports",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html:3709,depend,dependent,3709,interpreter/llvm-project/clang/www/analyzer/scan-build.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html,2,['depend'],['dependent']
Integrability,"ort.; Classes are grouped in modules; these, too, are listed ontop of the list of classes. Inheritance; All classes along with their derived and base classes are shown in the; Class Hierarchy.; The documentation for each class also shows the inheritance diagram.; The class hierarchy is meant to give an overview of available classes; and their relations. Modules; What they are; Classes are grouped into modules. For ROOT, this is done on a per-directory basis:; each module corresponds to a sub-directory. In other cases one module might represent; one library. Either way, modules are meant to combine similar or related classes,; allowing users to find classes close by context. If you need some functionality that; you cannot find in a class you know, you might want to check for classes in the same; module - maybe one of them does what you need. List of Modules; Modules are listed ontop of the Class Index and as part; of the Library Dependencies Chart. Modules' Library Dependencies; Each module is assumed to be part of a library. The dependencies of libraries are; not only relevant for linking, but often reflect also the contextual dependencies.; The dependencies of all modules are shown in the; Library Dependencies Chart. Class Reference; Pages like the one for TH2 are; class references. They document the use and functionality of a class. Sections; Each class reference page has a class documentation, which documents what the class; can be used for, and gives hints on how to use it. This allows you to figure out; whether a certain class is appropriate for what you try to do. The page then lists; all available members; they define a class's functionality and its interaction with; your code. The next item is a tabbed set of charts, which allow you to study the; class's inheritance diagram, what members get inherited from where, and which members; are re-implemented, which files get indirectly included by including the class's; header, and which libraries this class depends ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/etc/html/HELP.html:1834,Depend,Dependencies,1834,etc/html/HELP.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/etc/html/HELP.html,1,['Depend'],['Dependencies']
Integrability,"ort; =============. .. caution::. This is an **experimental** feature, available starting with release; 2.4.0.; It is still incomplete (see listing below) and has only been tested on; Linux on x86_64. Numba `is a JIT compiler`_ for Python functions that can be statically typed; based on their input arguments.; Since C++ objects are always statically typed and already implemented at the; machine level, they can be dynamically integrated into the Numba type tracing; and lowering by exposing type details through C++ reflection at runtime. JIT-compiling traces of mixed Python/bound C++ code reduces, and in some; cases removes, the overhead of boxing/unboxing native data into their Python; proxies and vice versa.; It can also reduce or remove temporaries, especially for template; expressions.; Thus, there can be significant speedups for mixed code, beyond the Numba; compilation of Python code itself.; The current implementation integrates compiled C++ through function pointers,; object pointers, and pointer offsets, into the intermediate representation; (IR) as generated by Numba.; A future version may integrate Cling-generated IR directly into Numba IR (or; vice versa), e.g. if the C++ code is exposed from (precompiled) headers.; This would allow inlining of C++ code into Numba traces, for further; expected speedups. Why Numba?; ----------. The advertised premise of Numba is that it ""makes Python code fast.""; However, there is a much more compelling reason: Numba allows developers to; stay in their chosen ecosystem, be it Python or C++, in mixed environments,; without paying for their choice in lost performance.; For example, a Python developer using Numba does not need to rewrite a kernel; into C++ just to run performantly in a C++ framework.; Similarly, a C++ developer can use Numba to compile and create function; pointers to Python code for easy, performant, access.; This becomes even more compelling if the deployment target is a GPU, which; would otherwise certainly",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/numba.rst:959,integrat,integrates,959,bindings/pyroot/cppyy/cppyy/doc/source/numba.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/numba.rst,1,['integrat'],['integrates']
Integrability,"orted. There are two kinds of expressions:. * :ref:`Absolute<amdgpu_synid_absolute_expression>`.; * :ref:`Relocatable<amdgpu_synid_relocatable_expression>`. .. _amdgpu_synid_absolute_expression:. Absolute Expressions; --------------------. The value of an absolute expression does not change after program relocation.; Absolute expressions must not include unassigned and relocatable values; such as labels. Absolute expressions are evaluated to 64-bit integer values and converted to; :ref:`expected operand type<amdgpu_syn_instruction_type>`; as described :ref:`here<amdgpu_synid_int_conv>`. Examples:. .. parsed-literal::. x = -1; y = x + 10. .. _amdgpu_synid_relocatable_expression:. Relocatable Expressions; -----------------------. The value of a relocatable expression depends on program relocation. Note that use of relocatable expressions is limited to branch targets; and 32-bit integer operands. A relocatable expression is evaluated to a 64-bit integer value,; which depends on operand kind and; :ref:`relocation type<amdgpu-relocation-records>` of symbol(s); used in the expression. For example, if an instruction refers to a label,; this reference is evaluated to an offset from the address after; the instruction to the label address:. .. parsed-literal::. label:; v_add_co_u32_e32 v0, vcc, label, v1 // 'label' operand is evaluated to -4. Note that values of relocatable expressions are usually unknown; at assembly time; they are resolved later by a linker and converted to; :ref:`expected operand type<amdgpu_syn_instruction_type>`; as described :ref:`here<amdgpu_synid_rl_conv>`. Operands and Operations; -----------------------. Expressions are composed of 64-bit integer operands and operations.; Operands include :ref:`integer numbers<amdgpu_synid_integer_number>`; and :ref:`symbols<amdgpu_synid_symbol>`. Expressions may also use ""."" which is a reference; to the current PC (program counter). :ref:`Unary<amdgpu_synid_expression_un_op>` and; :ref:`binary<amdgpu_synid_expressio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUOperandSyntax.rst:29991,depend,depends,29991,interpreter/llvm-project/llvm/docs/AMDGPUOperandSyntax.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUOperandSyntax.rst,1,['depend'],['depends']
Integrability,"ory to keep ccached data""); set(LLVM_CCACHE_PARAMS ""CCACHE_CPP2=yes CCACHE_HASHDIR=yes""; CACHE STRING ""Parameters to pass through to ccache""). if(NOT CMAKE_SYSTEM_NAME MATCHES ""Windows""); set(CCACHE_PROGRAM ""${LLVM_CCACHE_PARAMS} ${CCACHE_PROGRAM}""); if (LLVM_CCACHE_MAXSIZE); set(CCACHE_PROGRAM ""CCACHE_MAXSIZE=${LLVM_CCACHE_MAXSIZE} ${CCACHE_PROGRAM}""); endif(); if (LLVM_CCACHE_DIR); set(CCACHE_PROGRAM ""CCACHE_DIR=${LLVM_CCACHE_DIR} ${CCACHE_PROGRAM}""); endif(); set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ${CCACHE_PROGRAM}); else(); if(LLVM_CCACHE_MAXSIZE OR LLVM_CCACHE_DIR OR; NOT LLVM_CCACHE_PARAMS MATCHES ""CCACHE_CPP2=yes CCACHE_HASHDIR=yes""); message(FATAL_ERROR ""Ccache configuration through CMake is not supported on Windows. Please use environment variables.""); endif(); # RULE_LAUNCH_COMPILE should work with Ninja but currently has issues; # with cmd.exe and some MSVC tools other than cl.exe; set(CMAKE_C_COMPILER_LAUNCHER ${CCACHE_PROGRAM}); set(CMAKE_CXX_COMPILER_LAUNCHER ${CCACHE_PROGRAM}); endif(); else(); message(FATAL_ERROR ""Unable to find the program ccache. Set LLVM_CCACHE_BUILD to OFF""); endif(); endif(). set(LLVM_EXTERNAL_PROJECT_BUILD_TOOL_ARGS """" CACHE STRING; ""Optional arguments for the native tool used in CMake --build invocations for external projects.""); mark_as_advanced(LLVM_EXTERNAL_PROJECT_BUILD_TOOL_ARGS). option(LLVM_DEPENDENCY_DEBUGGING ""Dependency debugging mode to verify correctly expressed library dependencies (Darwin only)"" OFF). # Some features of the LLVM build may be disallowed when dependency debugging is; # enabled. In particular you cannot use ccache because we want to force compile; # operations to always happen.; if(LLVM_DEPENDENCY_DEBUGGING); if(NOT CMAKE_HOST_APPLE); message(FATAL_ERROR ""Dependency debugging is only currently supported on Darwin hosts.""); endif(); if(LLVM_CCACHE_BUILD); message(FATAL_ERROR ""Cannot enable dependency debugging while using ccache.""); endif(); endif(). option(LLVM_ENABLE_DAGISEL_COV ""Debug: Pr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:11740,message,message,11740,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['message'],['message']
Integrability,"ose_helper)(struct __block_literal_10 *);; } __block_descriptor_10 = { 0, sizeof(struct __block_literal_10), __block_copy_10, __block_dispose_10 };. and the code would be:. .. code-block:: c++. {; FOO foo;; comp_ctor(&foo); // default constructor; struct __block_literal_10 _block_literal = {; &_NSConcreteStackBlock,; (1<<25)|(1<<26)|(1<<29), <uninitialized>,; __block_invoke_10,; &__block_descriptor_10,; };; comp_ctor(&_block_literal->foo, &foo); // const copy into stack version; struct __block_literal_10 &block = &_block_literal; // assign literal to block variable; block->invoke(block); // invoke block; comp_dtor(&_block_literal->foo); // destroy stack version of const block copy; comp_dtor(&foo); // destroy original version; }. C++ objects stored in ``__block`` storage start out on the stack in a; ``block_byref`` data structure as do other variables. Such objects (if not; ``const`` objects) must support a regular copy constructor. The ``block_byref``; data structure will have copy and destroy helper routines synthesized by the; compiler. The copy helper will have code created to perform the copy; constructor based on the initial stack ``block_byref`` data structure, and will; also set the (1<<26) bit in addition to the (1<<25) bit. The destroy helper; will have code to do the destructor on the object stored within the supplied; ``block_byref`` heap data structure. For example,. .. code-block:: c++. __block FOO blockStorageFoo;. requires the normal constructor for the embedded ``blockStorageFoo`` object:. .. code-block:: c++. FOO_ctor(& _block_byref_blockStorageFoo->blockStorageFoo);. and at scope termination the destructor:. .. code-block:: c++. FOO_dtor(& _block_byref_blockStorageFoo->blockStorageFoo);. Note that the forwarding indirection is *NOT* used. The compiler would need to generate (if used from a block literal) the following; copy/dispose helpers:. .. code-block:: c++. void _block_byref_obj_keep(struct _block_byref_blockStorageFoo *dst, struct _block_byre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:26211,rout,routines,26211,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['rout'],['routines']
Integrability,"osition techniques to adjust p.d.f building blocks; rf05_conditional.C - Construction of productions with conditional p.d.f.s; rf06_convolution.C - Convolution of p.d.fs f(x) (X) g(x); rf07_bphysics.C - B physics p.d.f.s with analytical convolution; rf08_intminuit.C - Interactive MINUIT demonstration; rf09_constraints.C - How to specify and use parameter constraints in fits; rf10_ranges.C - Working with sub ranges in observables in fitting and plotting; rf11_plotbinning.C - Variable and other non-uniform binnign specifications; rf12_mcstudy.C - Managing toy Monte Carlo studie; rf13_wspacewrite.C - Creating and persisting workspaces; rf14_wspaceread.C - Reading and using workspaces; rf15_simwstool.C - Automated tools for building of simulateneous p.d.f.s; rf16_normandint.C - Normalization, integration and cumulative distribution functions (1d); rf16_normandint2d.C - Normalization, integration and cumulative distribution functions (1d); ; Update of class documentation; ; The documentation in the code itself that is extracted by THtml to construct; the online class documentation has been updated for all classes. Now all classes; have (again) a short class description, as well as a (short) description of each member function; and most data members. An update to the users manual is foreseen shortly after the 5.20; release. RooWorkspace. A new feature has been added that allows to persist source code of RooFit classes that; are not in ROOT distribution inside a RooWorkspace to facilitate sharing; of custom code with others. To import code of custom classes call. RooWorkspace::importClassCode(). after importing the objects themselves into the workspace. For all classes; that are compiled with ACliC RooWorkspace can automatically find the source; code using the ROOT TClass interface. For custom classes that are compiled; externally and loaded into ROOT as shared library it might be necessary to; provide the location of the source files manually using the static RooWorkspace",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html:1246,integrat,integration,1246,roofit/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html,2,['integrat'],['integration']
Integrability,"osx.cocoa.Dealloc (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C classes that lack a correct implementation of -dealloc. .. literalinclude:: checkers/dealloc_example.m; :language: objc. .. _osx-cocoa-IncompatibleMethodTypes:. osx.cocoa.IncompatibleMethodTypes (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C method signatures with type incompatibilities. .. code-block:: objc. @interface MyClass1 : NSObject; - (int)foo;; @end. @implementation MyClass1; - (int)foo { return 1; }; @end. @interface MyClass2 : MyClass1; - (float)foo;; @end. @implementation MyClass2; - (float)foo { return 1.0; } // warn; @end. .. _osx-cocoa-Loops:. osx.cocoa.Loops; """"""""""""""""""""""""""""""; Improved modeling of loops using Cocoa collection types. .. _osx-cocoa-MissingSuperCall:. osx.cocoa.MissingSuperCall (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C methods that lack a necessary call to super. .. code-block:: objc. @interface Test : UIViewController; @end; @implementation test; - (void)viewDidLoad {} // warn; @end. .. _osx-cocoa-NSAutoreleasePool:. osx.cocoa.NSAutoreleasePool (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn for suboptimal uses of NSAutoreleasePool in Objective-C GC mode. .. code-block:: objc. void test() {; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; [pool release]; // warn; }. .. _osx-cocoa-NSError:. osx.cocoa.NSError (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""; Check usage of NSError parameters. .. code-block:: objc. @interface A : NSObject; - (void)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error;; @end. @implementation A; - (void)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error {; // warn: method accepting NSError"""""""""""""""""""""""""""""""""""""""""""""""" should have a non-void; // return value; }; @end. @interface A : NSObject; - (BOOL)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error;; @end. @implementation A; - (BOOL)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error {; *error = 0; // warn: potential null dereference; return 0;; }; @end. .. _osx-cocoa-NilA",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:37806,interface,interface,37806,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['interface'],['interface']
Integrability,"ot resolved. 420; CD1; postfixexpression->scalar_type_dtor() inconsistent; Clang 9. 421; CD1; Is rvalue.field an rvalue?; Yes. 422; NAD; Is a typedef redeclaration allowed with a template type that might be the same?; Yes. 423; NAD; Can a conversion be done on the left operand of a compound assignment?; Yes. 424; CD1; Wording problem with issue 56 resolution on redeclaring typedefs in class scope; Yes. 425; CD1; Set of candidates for overloaded built-in operator with float operand; Yes. 426; C++17; Identically-named variables, one internally and one externally linked, allowed?; Unknown. 427; CD1; static_cast ambiguity: conversion versus cast to derived; Yes. 428; CD1; Mention of expression with reference type; Yes. 429; CD1; Matching deallocation function chosen based on syntax or signature?; Clang 2.8 (C++11 onwards). 430; CD1; Ordering of expression evaluation in initializer list; Yes (C++11 onwards). 431; C++11; Defect in wording in 14.2; Yes. 432; CD1; Is injected class name visible in base class specifier list?; Clang 3.0. 433; CD1; Do elaborated type specifiers in templates inject into enclosing namespace scope?; Yes. 434; NAD; Unclear suppression of standard conversions while binding reference to lvalue; Superseded by 2352. 435; NAD; Change ""declararation or definition"" to ""declaration""; N/A. 436; CD1; Problem in example in 9.6 paragraph 4; Yes. 437; CD1; Is type of class allowed in member function exception specification?; Superseded by 1308. 438; CD2; Possible flaw in wording for multiple accesses to object between sequence points; Unknown. 439; CD1; Guarantees on casting pointer back to cv-qualified version of original type; Unknown. 440; NAD; Allow implicit pointer-to-member conversion on nontype template argument; Unknown. 441; CD1; Ordering of static reference initialization; Unknown. 442; CD1; Incorrect use of null pointer constant in description of delete operator; Superseded by 348. 443; CD1; Wording nit in description of lifetime of temporaries; N/A.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:29274,inject,injected,29274,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['inject'],['injected']
Integrability,"ot simply identifiers, in introduction; Duplicate of 485. 310; open; Can function templates differing only in parameter cv-qualifiers be overloaded?; Not resolved. 311; NAD; Using qualified name to reopen nested namespace; Clang 3.0. 312; CD3; “use” of invalid pointer value not defined; Duplicate of 616. 313; dup; Class with single conversion function to integral as array size in new; Duplicate of 299 (C++11 onwards). 314; C++17; template in base class specifier; No. 315; NAD; Is call of static member function through null pointer undefined?; N/A. 316; NAD; Injected-class-name of template used as template template parameter; Superseded by 1004. 317; CD1; Can a function be declared inline after it has been called?; Clang 3.5. 318; CD1; struct A::A should not name the constructor of A; Superseded by 1310. 319; CD1; Use of names without linkage in declaring entities with linkage; No. 320; CD1; Question on copy constructor elision example; Yes. 321; dup; Associated classes and namespaces for argument-dependent lookup; Duplicate of 557. 322; CD1; Deduction of reference conversions; Clang 2.8. 323; CD1; Where must export appear?; No. 324; CD1; Can ""&"" be applied to assignment to bit-field?; Clang 3.6. 325; drafting; When are default arguments parsed?; Not resolved. 326; CD1; Wording for definition of trivial constructor; Clang 3.1. 327; CD1; Use of ""structure"" without definition; Duplicate of 538. 328; CD1; Missing requirement that class member types be complete; Yes. 329; CD1; Evaluation of friends of templates; Clang 3.5. 330; CD4; Qualification conversions and pointers to arrays of pointers; Clang 7. 331; CD1; Allowed copy constructor signatures; Clang 11. 332; CD3; cv-qualified void parameter types; Duplicate of 577. 333; NAD; Ambiguous use of ""declaration"" in disambiguation section; Yes. 334; NAD; Is a comma-expression dependent if its first operand is?; Yes. 335; CD1; Allowing export on template members of nontemplate classes; No. 336; CD1; Explicit specialization ex",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:21404,depend,dependent,21404,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['depend'],['dependent']
Integrability,"ot[] THtml h; root[] h.Convert(""MyCode.C"", ""Look At My Code"", ""htmlout/"");; ```. This will create the file `htmlout/MyCode.C.html`. The HTML page will; have the title ""Look At My Code"". ## Special Documentation Elements: Directives. A common documentation problem is the inclusion of images. They are; usually generated externally, which poses problems with where to keep; the images, and how to keep them up to date. **`THtml`** solves this by; offering a few special documentation elements: macro and latex; directives. ### Latex Directive. Documentation surrounded by the keywords `BEGIN_LATEX / END_LATEX` will; be passed to ROOT Latex engine **`TLatex`**. The keywords can be written; with small or capital letters (case insensitive). The output will be; stored to an image file, which gets automatically included in the; documentation. ``` {.cpp}; // This function calculates BEGIN_LATEX; // F(x_{#frac{1}{2}}) = #prod(x < x_{#frac{1}{2}}) = #frac{1}{2}; // END_LATEX; ```. THtml will inject the following picture:. ![](pictures/0300022D.png). The image file name is generated from the formula and will be unique for; all the documentation. It is stored along-side the documentation, and it; will be automatically regenerated when the documentation is updated. The; handling of the Latex directive is done by the class; **`TDocLatexDirective`**. The `BEGIN_LATEX` keyword can take the following parameters:. - `fontsize`: sets the **`TLatex`** font size. The default value is 16. - `separator`: sets a list of characters for which a new column will; be started. This allows aligned, multi-line, multi-column layout,; which can be useful for e.g. mathematical derivations. It is unset; by default, meaning the Latex directive will only generate one; column. - `rseparator`: like separator, but a regular expression. Columns; start with a match of this regular expression. Only one of separator; or rseparator can be given. - `align`: defines the alignment of the columns. Note that the column; d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md:5981,inject,inject,5981,documentation/users-guide/HTMLDoc.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md,1,['inject'],['inject']
Integrability,"other hand sounds like a good idea, and the; > implementation seems fairly language-independent so it doesn't have the; > problems with malloc listed above. Okay, once we get the above stuff figured out, I'll put it all in the; spec. > About indirect call:; > Your option #2 sounded good to me. I'm not sure I understand your; > concern about an explicit 'icall' instruction?. I worry too much. :) The other alternative has been removed. 'icall' is; now up in the instruction list next to 'call'. > I believe tail calls are relatively easy to identify; do you know why; > .NET has a tailcall instruction?. Although I am just guessing, I believe it probably has to do with the fact; that they want languages like Haskell and lisp to be efficiently runnable; on their VM. Of course this means that the VM MUST implement tail calls; 'correctly', or else life will suck. :) I would put this into a future; feature bin, because it could be pretty handy... > A pair of important synchronization instr'ns to think about:; > load-linked; > store-conditional. What is 'load-linked'? I think that (at least for now) I should add these; to the 'possible extensions' section, because they are not immediately; needed... > Other classes of instructions that are valuable for pipeline; > performance:; > conditional-move ; > predicated instructions. Conditional move is effectly a special case of a predicated; instruction... and I think that all predicated instructions can possibly; be implemented later in LLVM. It would significantly change things, and; it doesn't seem to be very necessary right now. It would seem to; complicate flow control analysis a LOT in the virtual machine. I would; tend to prefer that a predicated architecture like IA64 convert from a; ""basic block"" representation to a predicated rep as part of it's dynamic; complication phase. Also, if a basic block contains ONLY a move, then; that can be trivally translated into a conditional move... > I agree that we need a static data space",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt:5865,synchroniz,synchronization,5865,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt,1,['synchroniz'],['synchronization']
Integrability,"ou want to store. Once the proper category of container is determined, you can fine tune the; memory use, constant factors, and cache behaviors of access by intelligently; picking a member of the category. Note that constant factors and cache behavior; can be a big deal. If you have a vector that usually only contains a few; elements (but could contain many), for example, it's much better to use; :ref:`SmallVector <dss_smallvector>` than :ref:`vector <dss_vector>`. Doing so; avoids (relatively) expensive malloc/free calls, which dwarf the cost of adding; the elements to the container. .. _ds_sequential:. Sequential Containers (std::vector, std::list, etc); ---------------------------------------------------. There are a variety of sequential containers available for you, based on your; needs. Pick the first in this section that will do what you want. .. _dss_arrayref:. llvm/ADT/ArrayRef.h; ^^^^^^^^^^^^^^^^^^^. The ``llvm::ArrayRef`` class is the preferred class to use in an interface that; accepts a sequential list of elements in memory and just reads from them. By; taking an ``ArrayRef``, the API can be passed a fixed size array, an; ``std::vector``, an ``llvm::SmallVector`` and anything else that is contiguous; in memory. .. _dss_fixedarrays:. Fixed Size Arrays; ^^^^^^^^^^^^^^^^^. Fixed size arrays are very simple and very fast. They are good if you know; exactly how many elements you have, or you have a (low) upper bound on how many; you have. .. _dss_heaparrays:. Heap Allocated Arrays; ^^^^^^^^^^^^^^^^^^^^^. Heap allocated arrays (``new[]`` + ``delete[]``) are also simple. They are good; if the number of elements is variable, if you know how many elements you will; need before the array is allocated, and if the array is usually large (if not,; consider a :ref:`SmallVector <dss_smallvector>`). The cost of a heap allocated; array is the cost of the new/delete (aka malloc/free). Also note that if you; are allocating an array of a type with a constructor, the constru",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:57796,interface,interface,57796,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['interface'],['interface']
Integrability,"ould be included in the ``SparcSubtarget.cpp``. The target-specific; implementation of the ``XXXSubtarget`` method should follow this pseudocode:. .. code-block:: c++. XXXSubtarget::XXXSubtarget(const Module &M, const std::string &FS) {; // Set the default features; // Determine default and user specified characteristics of the CPU; // Call ParseSubtargetFeatures(FS, CPU) to parse the features string; // Perform any additional operations; }. JIT Support; ===========. The implementation of a target machine optionally includes a Just-In-Time (JIT); code generator that emits machine code and auxiliary structures as binary; output that can be written directly to memory. To do this, implement JIT code; generation by performing the following steps:. * Write an ``XXXCodeEmitter.cpp`` file that contains a machine function pass; that transforms target-machine instructions into relocatable machine; code. * Write an ``XXXJITInfo.cpp`` file that implements the JIT interfaces for; target-specific code-generation activities, such as emitting machine code and; stubs. * Modify ``XXXTargetMachine`` so that it provides a ``TargetJITInfo`` object; through its ``getJITInfo`` method. There are several different approaches to writing the JIT support code. For; instance, TableGen and target descriptor files may be used for creating a JIT; code generator, but are not mandatory. For the Alpha and PowerPC target; machines, TableGen is used to generate ``XXXGenCodeEmitter.inc``, which; contains the binary coding of machine instructions and the; ``getBinaryCodeForInstr`` method to access those codes. Other JIT; implementations do not. Both ``XXXJITInfo.cpp`` and ``XXXCodeEmitter.cpp`` must include the; ``llvm/CodeGen/MachineCodeEmitter.h`` header file that defines the; ``MachineCodeEmitter`` class containing code for several callback functions; that write data (in bytes, words, strings, etc.) to the output stream. Machine Code Emitter; --------------------. In ``XXXCodeEmitter.cpp``, a target-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:75956,interface,interfaces,75956,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['interface'],['interfaces']
Integrability,"ound for geo drawing. ## Changes in 7.3.0; 1. Mark methods returning `Promise` as **async**; 2. Upgrade three.js to r146; 3. Fix several bugs in `csg.mjs`, improve geometry clipping; 4. Provide `settings.PreferSavedPoints` to exclude function evaluation when there are saved points; 5. Add more interactive features with `TWebCanvas`; 6. 3-dimensional `TTree::Draw()` now produces `TPolyMarker3D` by default; 7. Force MathJax rendering when `\` symbol is found (#243); 8. Support `TButton` class; 9. Remove `localfile` url option, only interactively one can open file selection dialog; 10. Fix - show correct bin index in `TH2` tooltips; 11. Fix - interactive move/resize on touch devices; 12. Fix - correctly handle axis zooming on lego plots; 13. Fix - histogram statistics calculation with negative bins; 14. Base version for ROOT 6.28 release. ## Changes in 7.2.1; 1. Fix - prevent glitch when enabling projection via context menu; 2. Fix - `multi.json` request parsing; 3. Fix - decoding of multipart message (#250); 4. Fix - use alpha channel for TColor when intended; 5. Backport `settings.PreferSavedPoints` only for `TF1`. ## Changes in 7.2.0; 1. Use TAxis attributes in lego plots - ticks/labels/title colors, sizes, offsets; 2. Correctly resize stats box when number of lines changes; 3. Support JSROOT usage with yarn and webpack; 4. Provide `FileProxy` class to let read ROOT files from arbitrary place; 5. Let 'hook' save file functionality to use alternative method to store image files; 6. Implement 'tabs' layout for objects display (#238); 7. Upgrade d3.js to version 7.6.1; 8. Fix - adjust pad margins when moving palette and frame. ## Changes in 7.1.1; 1. Fix - let modify node visibility bits via context menu; 2. Fix - menu position adjusting; 3. Fix - tree_draw.js example, export treeDraw function from main.mjs; 4. Fix - TH3 scatter plot with large number of bins converted to box2; 5. Fix - create geo css entries also when expand object in hierarchy (#240). ## Changes in 7.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:16398,message,message,16398,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['message'],['message']
Integrability,"our changes; git commit file.cpp -m ""Code Review adjustments"". # Format changes; git clang-format HEAD~. # Recommit if any formatting changes; git commit -a --amend. # Re-run tests and make sure nothing broke.; ninja check. # Push your changes to your fork branch, be mindful of; # your remotes here, if you don't remember what points to your; # fork, use git remote -v to see. Usually origin points to your; # fork and upstream to llvm/llvm-project; git push origin my_change. Before merging the PR, it is recommended that you rebase locally and re-run test; checks:. ::. # Add upstream as a remote (if you don't have it already); git remote add upstream https://github.com/llvm/llvm-project.git. # Make sure you have all the latest changes; git fetch upstream && git rebase -i upstream/main. # Make sure tests pass with latest changes and your change; ninja check. # Push the rebased changes to your fork.; git push origin my_change -f. Once your PR is approved, rebased, and tests are passing, click `Squash and; Merge` on your PR in the GitHub web interface. See more in-depth information about how to contribute in the following documentation:. * :doc:`Contributing`; * :doc:`MyFirstTypoFix`. Releases; ========. Backporting Fixes to the Release Branches; -----------------------------------------; You can use special comments on issues to make backport requests for the; release branches. This is done by making a comment containing one of the; following commands on any issue that has been added to one of the ""X.Y.Z Release""; milestones. ::. /cherry-pick <commit> <commit> <...>. This command takes one or more git commit hashes as arguments and will attempt; to cherry-pick the commit(s) to the release branch. If the commit(s) fail to; apply cleanly, then a comment with a link to the failing job will be added to; the issue. If the commit(s) do apply cleanly, then a pull request will; be created with the specified commits. ::. /branch <owner>/<repo>/<branch>. This command will create a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst:11933,interface,interface,11933,interpreter/llvm-project/llvm/docs/GitHub.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst,1,['interface'],['interface']
Integrability,"ourceLocations, SourceBuffer abstraction,; file system caching for input source files. This depends on; libsupport and libsystem. libast - Provides classes to represent the C AST, the C type system,; builtin functions, and various helpers for analyzing and; manipulating the AST (visitors, pretty printers, etc). This; library depends on libbasic. liblex - C/C++/ObjC lexing and preprocessing, identifier hash table,; pragma handling, tokens, and macros. This depends on libbasic. libparse - C (for now) parsing and local semantic analysis. This library; invokes coarse-grained 'Actions' provided by the client to do; stuff (e.g. libsema builds ASTs). This depends on liblex. libsema - Provides a set of parser actions to build a standardized AST; for programs. AST's are 'streamed' out a top-level declaration; at a time, allowing clients to use decl-at-a-time processing,; build up entire translation units, or even build 'whole; program' ASTs depending on how they use the APIs. This depends; on libast and libparse. librewrite - Fast, scalable rewriting of source code. This operates on; the raw syntactic text of source code, allowing a client; to insert and delete text in very large source files using; the same source location information embedded in ASTs. This; is intended to be a low-level API that is useful for; higher-level clients and libraries such as code refactoring. libanalysis - Source-level dataflow analysis useful for performing analyses; such as computing live variables. It also includes a; path-sensitive ""graph-reachability"" engine for writing; analyses that reason about different possible paths of; execution through source code. This is currently being; employed to write a set of checks for finding bugs in software. libcodegen - Lower the AST to LLVM IR for optimization & codegen. Depends; on libast.; ; clang - An example driver, client of the libraries at various levels.; This depends on all these libraries, and on LLVM VMCore. This front-end has been intentiona",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2007-OriginalClangReadme.txt:2193,depend,depends,2193,interpreter/llvm-project/llvm/docs/HistoricalNotes/2007-OriginalClangReadme.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2007-OriginalClangReadme.txt,1,['depend'],['depends']
Integrability,"out << a << std::endl;; }. // print.hpp; void print (int a);. // Commands; clang++-17 -c -o print.o print.cpp; clang-17 -shared print.o -o print.so. Comments:; =========. .. code-block:: text. clang-repl> // Comments in Clang-Repl; clang-repl> /* Comments in Clang-Repl */. Closure or Termination:; =======================. .. code-block:: text. clang-repl>%quit. Just like Clang, Clang-Repl can be integrated in existing applications as a library; (using the clangInterpreter library). This turns your C++ compiler into a service that; can incrementally consume and execute code. The **Compiler as A Service** (**CaaS**); concept helps support advanced use cases such as template instantiations on demand and; automatic language interoperability. It also helps static languages such as C/C++ become; apt for data science. Execution Results Handling in Clang-Repl; ========================================. Execution Results Handling features discussed below help extend the Clang-Repl; functionality by creating an interface between the execution results of a; program and the compiled program. 1. **Capture Execution Results**: This feature helps capture the execution results; of a program and bring them back to the compiled program. 2. **Dump Captured Execution Results**: This feature helps create a temporary dump; for Value Printing/Automatic Printf, that is, to display the value and type of; the captured data. 1. Capture Execution Results; ============================. In many cases, it is useful to bring back the program execution result to the; compiled program. This result can be stored in an object of type **Value**. How Execution Results are captured (Value Synthesis):; -----------------------------------------------------. The synthesizer chooses which expression to synthesize, and then it replaces; the original expression with the synthesized expression. Depending on the; expression type, it may choose to save an object (``LastValue``) of type 'value'; while allocating mem",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:5831,interface,interface,5831,interpreter/llvm-project/clang/docs/ClangRepl.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst,1,['interface'],['interface']
Integrability,"overwrites) the string representing the result of; a node. > For each `translate()` function, it is important to call `addResult()` since; this is what enables the squashing to happen. - **getResult()**: gets the result for the given node using the node name.; This node also performs the necessary code generation through recursive calls; to `translate()`. - **assembleCode()**: combines the generated code statements into the final; code body of the squashed function. These functions will appear again in this document with more contextual; examples. For detailed in-line documentation (code comments), please see:. > [roofit/roofitcore/src/RooFit/Detail/CodeSquashContext.cxx](https://github.com/root-project/root/blob/master/roofit/roofitcore/src/RooFit/Detail/CodeSquashContext.cxx). ### b. RooFuncWrapper. > [roofit/roofitcore/inc/RooFuncWrapper.h](https://github.com/root-project/root/blob/master/roofit/roofitcore/inc/RooFuncWrapper.h). This class wraps the generated C++ code in a RooFit object, so that it can be; used like other RooFit objects. It takes a function body as input and creates a callable function from it.; This allows users to evaluate the function and its derivatives efficiently. #### Helper Functions. - **loadParamsAndData()** extracts parameters and observables from the; provided data and prepares them for evaluation. - **declareAndDiffFunction()**: declare the function and create its; derivative. - **gradient()**: calculates the gradient of the function with respect to its; parameters. - **buildCode()**: generates the optimized code for evaluating the function; and its derivatives. - **dumpCode()**: prints the squashed code body to console (useful for; debugging). - **dumpGradient()**: prints the derivative code body to console (useful for; debugging). These functions will appear again in this document with more contextual; examples. For detailed in-line documentation (code comments), please see:. > [roofit/roofitcore/src/RooFuncWrapp9er.cxx](https://git",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:33298,wrap,wraps,33298,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['wrap'],['wraps']
Integrability,"ovide derivatives with respect to the; parameters. Here is an example:. ```{.cpp}; #include ""Math/IFunction.h""; #include ""Math/IParamFunction.h"". class MyParametricGradFunction:; public ROOT::Math::IParametricGradFunctionMultiDim; {; private:; const double* pars;. public:; double DoEvalPar(const double* x, const double* p) const; {; return p[0] * x[0] + sin(x[1]) + p[1];; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IParametricGradFunctionMultiDim* Clone() const; {; return new MyParametricGradFunction();; }. const double* Parameters() const; {; return pars;; }. void SetParameters(const double* p); {; pars = p;; }. unsigned int NPar() const; {; return 2;; }. double DoParameterDerivative(const double* x, const double* p,; unsigned int ipar) const; {; if ( ipar == 0 ); return sin(x[1]) + p[1];; else; return p[0] * x[0] + x[1] * cos(x[1]) + p[1];; }; };; ```. ### Wrapper Functions. To facilitate the user to insert their own type of function in the needed function interface, helper classes, wrapping the user interface in the; `ROOT::Math` function interfaces are provided.; this will avoid the user to re-implement dedicated function classes, following the code example shown in the previous paragraphs. There is one possible wrapper for every interface explained in the previous section.; The following table indicates the wrapper for the most basic ones:. | **Interface**| **Function Wrapper** |; |------------------------------------------|------------------------|; | `ROOT::Math::IBaseFunctionOneDim` | `ROOT::Math::Functor1D` |; | `ROOT::Math::IGradientFunctionOneDim` | `ROOT::Math::GradFunctor1D` |; | `ROOT::Math::IBaseFunctionMultiDim` | `ROOT::Math::Functor` |; | `ROOT::Math::IGradientFunctionMultiDim` | `ROOT::Math::GradFunctor` |. Thee functor wrapper are defined in the header file `Math/Functor.h`. #### Wrapping One Dimensional Functions. The `ROOT::Math::Functor1D` is used to wrap one-dimensional functions It can wrap all the following types:; * A free C ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:42114,interface,interface,42114,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,4,"['interface', 'wrap']","['interface', 'interfaces', 'wrapping']"
Integrability,"ow possible to use RooAbsReal derived functions as range definition for variables; to construct ranges that vary as function of another variable. For example. RooRealVar x(""x"",""x"",-10,10) ; // variable with fixed range [-10,10] ; RooRealVar y(""y"",""y"",0,20) ; // variable with fixed range [-10,10] ; ; RooFormulaVar x_lo(""x_lo"",""y-20"",y) ; ; RooFormulaVar x_hi(""x_hi"",""sin(y)*5"",y) ; ; x.setRange(x_lo,x_hi) ; // Change x to have variable range depending on y; ; It is also possible to define parameterized named ranges in the same way. x.setRange(""signalRegion"",x_lo,x_hi) ;. There are no fundamental limits to the complexity of the parameterized ranges; that can be defined as long as the problem is uniquely defined. For example, given three observables ; x, y and z, one can define a parameterized named range 'R' of x in terms of y and of y in terms of z; and ask to calculate the three dimensional integral of any function or p.d.f in terms of (x,y,z); over that range 'R' and it will be calculated correctly, taking recursive range dependencies into; account. A definition of a range 'R' on the other hand where the bounds of x depend on y and; the bounds of y depend on x is not allowed, and an error message will be printed to complain about; the ambiguity of the problem definition. Integrals over non-rectangular regions are created the; same way as integrals over rectangular regions using the RooAbsReal::createIntegral() function, the; chosen mode of operation depends on the shape of the requestion integration range. Note that in general integration over non (hyper)rectangular regions will be more computationally; intensive as only a subset of the observables can be integrated analytically (all of those that do not; have parameterized ranges plus those that have parameterized ranges but are not involved in the; parameterization of others (e.g. x and y in the example above). Running integrals and Cumulative distribution functions. It is now possible to create running integrals ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html:4229,depend,dependencies,4229,roofit/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html,2,['depend'],['dependencies']
Integrability,"ows look and feel. The main widgets are:. - Simple widgets: labels, icons, push buttons, either with text or; pixmaps, check buttons, radio buttons, menu bars and popup menus,; scroll bars, list boxes, combo boxes, group frames, text entry; widgets, tab widgets, progress bars, sliders, tool tips. - Complex widgets: shutter, toolbar, status bar, list view, list tree. - Common dialogs: File Open/Save, File Properties, Font Selection,; Color Selection, About. - The widgets are shown in frames:. - frame, composite frame, main frame, transient frame, group frame. - Arranged by layout managers:. - horizontal layout, vertical layout, row layout, list layout, tile; layout, matrix layout. Using a combination of layout hints:. - left, right, center x, center y, top, bottom, expand x, expand y,; fixed offsets. Event handling by signals/slots and messaging (as opposed to callbacks):. - in response to actions widgets send messages and emit signals. - associated frames process these messages or the slot methods; connected to the signals are executed. ## TVirtualX. The GUI classes interface to the platform dependent low level graphics; system via the semi-abstract graphics base class **`TVirtualX`**.; Currently concrete implementations exist for X11 and Win32 (MacOS X is; fully supported via Apple's X11 implementation). Thanks to this single; graphics interface, porting the ROOT GUI to a new platform requires only; the implementation of **`TVirtualX`**. ![](pictures/02000201.jpg). ## A Simple Example. We will start with a simple example that builds a small application; containing a canvas and two buttons: Draw and Exit. Its functionality; will be very simple: every time you click on Draw button, the graphics; of the function `sin(x)/x` will be drawn in randomly chosen interval in; the canvas window, if you click on Exit - you close the application.; This example shows the basic concepts for almost any GUI-application in; ROOT and it is important to understand how it is constructed.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:2190,message,messages,2190,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['message'],['messages']
Integrability,owsable.h; TBranchCacheInfo.h; TBranchClones.h; TBranchElement.h; TBranch.h; TBranchObject.h; TBranchRef.h; TBranchSTL.h; TBufferSQL.h; TChainElement.h; TChain.h; TCut.h; TEntryListArray.h; TEntryListBlock.h; TEntryListFromFile.h; TEntryList.h; TEventList.h; TFriendElement.h; TIndArray.h; TLeafB.h; TLeafC.h; TLeafD.h; TLeafD32.h; TLeafElement.h; TLeafF.h; TLeafF16.h; TLeaf.h; TLeafI.h; TLeafL.h; TLeafG.h; TLeafObject.h; TLeafO.h; TLeafS.h; TNtupleD.h; TNtuple.h; TQueryResult.h; TreeUtils.h; TSelector.h; TSelectorList.h; TSelectorScalar.h; TTreeCache.h; TTreeCacheUnzip.h; TTreeCloner.h; TTree.h; TTreeResult.h; TTreeRow.h; TTreeSQL.h; TVirtualIndex.h; TVirtualTreePlayer.h; ROOT/InternalTreeUtils.hxx; ROOT/RFriendInfo.hxx; ROOT/TIOFeatures.hxx; SOURCES; src/InternalTreeUtils.cxx; src/RFriendInfo.cxx; src/TBasket.cxx; src/TBasketSQL.cxx; src/TBranchBrowsable.cxx; src/TBranchClones.cxx; src/TBranch.cxx; src/TBranchElement.cxx; src/TBranchIMTHelper.h; src/TBranchObject.cxx; src/TBranchRef.cxx; src/TBranchSTL.cxx; src/TBufferSQL.cxx; src/TChain.cxx; src/TChainElement.cxx; src/TCut.cxx; src/TEntryListArray.cxx; src/TEntryListBlock.cxx; src/TEntryList.cxx; src/TEntryListFromFile.cxx; src/TEventList.cxx; src/TFriendElement.cxx; src/TIOFeatures.cxx; src/TLeafB.cxx; src/TLeafC.cxx; src/TLeaf.cxx; src/TLeafD.cxx; src/TLeafD32.cxx; src/TLeafElement.cxx; src/TLeafF.cxx; src/TLeafF16.cxx; src/TLeafI.cxx; src/TLeafL.cxx; src/TLeafG.cxx; src/TLeafObject.cxx; src/TLeafO.cxx; src/TLeafS.cxx; src/TNtuple.cxx; src/TNtupleD.cxx; src/TQueryResult.cxx; src/TreeUtils.cxx; src/TSelector.cxx; src/TSelectorList.cxx; src/TSelectorScalar.cxx; src/TTreeCache.cxx; src/TTreeCacheUnzip.cxx; src/TTreeCloner.cxx; src/TTree.cxx; src/TTreeResult.cxx; src/TTreeRow.cxx; src/TTreeSQL.cxx; src/TVirtualIndex.cxx; src/TVirtualTreePlayer.cxx; DICTIONARY_OPTIONS; -writeEmptyRootPCM; DEPENDENCIES; ${TREE_EXTRA_DEPENDENCIES}; Net; RIO; MathCore; LIBRARIES; ${ROOT_ATOMIC_LIBS}; ). ROOT_ADD_TEST_SUBDIRECTORY(test); ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/CMakeLists.txt:2449,DEPEND,DEPENDENCIES,2449,tree/tree/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/CMakeLists.txt,1,['DEPEND'],['DEPENDENCIES']
Integrability,"owse to the updated patch file. Click *Create Diff*.; * Select the review you want to from the *Attach To* dropdown and click; *Continue*.; * Leave the Repository field blank. (We previously filled out the Repository; for the review request.); * Add comments about the changes in the new diff. Click *Save*. Choosing reviewers: You typically pick one or two people as initial reviewers.; This choice is not crucial, because you are merely suggesting and not requiring; them to participate. Many people will see the email notification on cfe-commits; or llvm-commits, and if the subject line suggests the patch is something they; should look at, they will. .. _creating-a-patch-series:. Creating a patch series; -----------------------. Chaining reviews together requires some manual work. There are two ways to do it; (these are also described `here <https://moz-conduit.readthedocs.io/en/latest/arcanist-user.html#series-of-commits>`_; along with some screenshots of what to expect). .. _using-the-web-interface:. Using the web interface; ^^^^^^^^^^^^^^^^^^^^^^^. This assumes that you've already created a Phabricator review for each commit,; using `arc` or the web interface. * Go to what will be the last review in the series (the most recent).; * Click ""Edit Related Revisions"" then ""Edit Parent Revisions"".; * This will open a dialog where you will enter the patch number of the parent patch; (or patches). The patch number is of the form D<number> and you can find it by; looking at the URL for the review e.g. reviews.llvm/org/D12345.; * Click ""Save Parent Revisions"" after entering them.; * You should now see a ""Stack"" tab in the ""Revision Contents"" section of the web; interface, showing the parent patch that you added. Repeat this with each previous review until you reach the first in the series. This; one won't have a parent since it's the start of the series. If you prefer to start with the first in the series and go forward, you can use the; ""Edit Child Revisions"" option instead. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:5453,interface,interface,5453,interpreter/llvm-project/llvm/docs/Phabricator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst,1,['interface'],['interface']
Integrability,"oxy realProxy;; in RooFit classes, the above code can be simplified to; pdfProxy->fitTo(...);. Check the [doxygen reference guide](https://root.cern.ch/doc/master/classRooTemplateProxy.html) for `RooTemplateProxy` for; more information on how to modernise old code. ### HistFactory. #### Switch default statistical MC errors to Poisson; When defining HistFactory samples with statistical errors from C++, e.g.; Sample background1( ""background1"", ""background1"", InputFile );; background1.ActivateStatError();; statistical MC errors now have Poisson instead of Gaussian constraints. This better reflects the uncertainty of the MC simulations.; This can be reverted as follows:; // C++:; Channel chan(""channel1"");; chan.SetStatErrorConfig( 0.05, ""Gauss"" );; // Within <Channel ... > XML:; <StatErrorConfig RelErrorThreshold=""0.05"" ConstraintType=""Gauss"" />. #### Less verbose HistFactory; HistFactory was very verbose, writing to the terminal with lots of `cout`. Now, many HistFactory messages are going; into RooFit's message stream number 2. The verbosity can therefore be adjusted using; RooMsgService::instance().getStream(2).minLevel = RooFit::PROGRESS;. `hist2workspace` is also much less verbose. The verbosity can be restored with `hist2workspace -v` or `-vv`. ## 2D Graphics Libraries. - Universal time (correct time zone and daylight saving time) in PDF file. Implemented by; Jan Musinsky.; - The crosshair type cursor type did not work on MacOS Catalina. This has been fixed by; Timur Pocheptsoff.; - Take into account the Z errors when defining the frame to paint a TGraph2DErrors.; - Implement the of ""F"" in `TPad::RedrawAxis` to allow the plot's frame redrawing when; erased.; - Implement `TCanvas::SetRealAspectRatio` to resize a canvas so that the plot inside is; shown in real aspect.; - New graphics style ""BELLE2"" from Martin Ritter. ## 3D Graphics Libraries. ## Geometry Libraries. ### Geometry drawing in web browser. When ROOT compiled with -Droot7=ON flag, one can enable geometry",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md:5873,message,messages,5873,README/ReleaseNotes/v622/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md,2,['message'],"['message', 'messages']"
Integrability,"ox{up}$ (default value; $= 1.$), defining parameter errors. M defines parameter errors as the; change in parameter value required to change the function value by; $\mbox{up}$. Normally, for chisquared fits $\mbox{up = 1}$, and; for negative log likelihood, $\mbox{up = 0.5}$. ### $\mbox{FCN}$ function with gradient ###. By default first derivatives are calculated numerically by M . In case; the user wants to supply their own gradient calculator (e.g. analytical; derivatives), they need to implement the FCNGradientBase interface. ![](figures/fcngradientbase.png). The size of the output vector is the same as of the input one. The same; is true for the position of the elements (first derivative of the; function with respect to the $n_\mathrm{th}$ variable has index $n$ in; the output vector). ## M parameters ##. Interaction with the parameters of the function are essential both for M; and the user. Different interfaces are provided, depending on the level; of interaction. ### Minimal required interface ###. Starting values of parameters and uncertainties can be provided to M by; the user via std::vector$<$double$>$ vector containers. Any interaction; with the parameters before minimization (fix, release, limits, etc.) is; not possible then. Optionally if the user wants to provide starting values for the; covariance, they have to provide the values in a std::vector$<$double$>$; vector container stored in upper triangular packed storage format (see; [api:covariance]). ### MnUserParameters ###. A more functional interface to the user parameters is provided through M; via the class MnUserParameters. The user can add parameters giving them; a name and starting values. More information can be found in; [api:parameters]. ### MnUserCovariance ###. The user can (optionally) provide a covariance matrix as input using the; class MnUserCovariance. More information can be found in; [api:covariance]. ### MnUserParameterState ###. The MnUserParameterState contains the parameters (MnUs",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:30441,interface,interface,30441,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['interface'],['interface']
Integrability,"p of the while loop.; }. At this point, we know that the binary operator to the RHS of our; primary has higher precedence than the binop we are currently parsing.; As such, we know that any sequence of pairs whose operators are all; higher precedence than ""+"" should be parsed together and returned as; ""RHS"". To do this, we recursively invoke the ``ParseBinOpRHS`` function; specifying ""TokPrec+1"" as the minimum precedence required for it to; continue. In our example above, this will cause it to return the AST; node for ""(c+d)\*e\*f"" as RHS, which is then set as the RHS of the '+'; expression. Finally, on the next iteration of the while loop, the ""+g"" piece is; parsed and added to the AST. With this little bit of code (14; non-trivial lines), we correctly handle fully general binary expression; parsing in a very elegant way. This was a whirlwind tour of this code,; and it is somewhat subtle. I recommend running through it with a few; tough examples to see how it works. This wraps up handling of expressions. At this point, we can point the; parser at an arbitrary token stream and build an expression from it,; stopping at the first token that is not part of the expression. Next up; we need to handle function definitions, etc. Parsing the Rest; ================. The next thing missing is handling of function prototypes. In; Kaleidoscope, these are used both for 'extern' function declarations as; well as function body definitions. The code to do this is; straight-forward and not very interesting (once you've survived; expressions):. .. code-block:: c++. /// prototype; /// ::= id '(' id* ')'; static std::unique_ptr<PrototypeAST> ParsePrototype() {; if (CurTok != tok_identifier); return LogErrorP(""Expected function name in prototype"");. std::string FnName = IdentifierStr;; getNextToken();. if (CurTok != '('); return LogErrorP(""Expected '(' in prototype"");. // Read the list of argument names.; std::vector<std::string> ArgNames;; while (getNextToken() == tok_identifier); ArgNa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:20361,wrap,wraps,20361,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['wrap'],['wraps']
Integrability,"p; <writing-an-llvm-pass-runOnLoop>` for every loop in the program being compiled. .. _writing-an-llvm-pass-RegionPass:. The ``RegionPass`` class; ------------------------. ``RegionPass`` is similar to :ref:`LoopPass <writing-an-llvm-pass-LoopPass>`,; but executes on each single entry single exit region in the function.; ``RegionPass`` processes regions in nested order such that the outer most; region is processed last. ``RegionPass`` subclasses are allowed to update the region tree by using the; ``RGPassManager`` interface. You may override three virtual methods of; ``RegionPass`` to implement your own region pass. All these methods should; return ``true`` if they modified the program, or ``false`` if they did not. The ``doInitialization(Region *, RGPassManager &)`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doInitialization(Region *, RGPassManager &RGM);. The ``doInitialization`` method is designed to do simple initialization type of; stuff that does not depend on the functions being processed. The; ``doInitialization`` method call is not scheduled to overlap with any other; pass executions (thus it should be very fast). ``RPPassManager`` interface; should be used to access ``Function`` or ``Module`` level analysis information. .. _writing-an-llvm-pass-runOnRegion:. The ``runOnRegion`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool runOnRegion(Region *, RGPassManager &RGM) = 0;. The ``runOnRegion`` method must be implemented by your subclass to do the; transformation or analysis work of your pass. As usual, a true value should be; returned if the region is modified. ``RGPassManager`` interface should be used to; update region tree. The ``doFinalization()`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doFinalization();. The ``doFinalization`` method is an infrequently used method that is called; when the pass framework has finished calling :ref:`runOnReg",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:23601,depend,depend,23601,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['depend'],['depend']
Integrability,"p>` Implemented for float and half (and vectors). :ref:`llvm.log10 <int_log10>` Implemented for float and half (and vectors). :ref:`llvm.exp2 <int_exp2>` Implemented for float and half (and vectors of float or; half). Not implemented for double. Hardware provides; 1ULP accuracy for float, and 0.51ULP for half. Float; instruction does not natively support denormal; inputs. :ref:`llvm.stacksave.p5 <int_stacksave>` Implemented, must use the alloca address space.; :ref:`llvm.stackrestore.p5 <int_stackrestore>` Implemented, must use the alloca address space. :ref:`llvm.get.fpmode.i32 <int_get_fpmode>` The natural floating-point mode type is i32. This; implemented by extracting relevant bits out of the MODE; register with s_getreg_b32. The first 10 bits are the; core floating-point mode. Bits 12:18 are the exception; mask. On gfx9+, bit 23 is FP16_OVFL. Bitfields not; relevant to floating-point instructions are 0s. :ref:`llvm.get.rounding<int_get_rounding>` AMDGPU supports two separately controllable rounding; modes depending on the floating-point type. One; controls float, and the other controls both double and; half operations. If both modes are the same, returns; one of the standard return values. If the modes are; different, returns one of :ref:`12 extended values; <amdgpu-rounding-mode-enumeration-values-table>`; describing the two modes. To nearest, ties away from zero is not a supported; mode. The raw rounding mode values in the MODE; register do not exactly match the FLT_ROUNDS values,; so a conversion is performed. llvm.amdgcn.wave.reduce.umin Performs an arithmetic unsigned min reduction on the unsigned values; provided by each lane in the wavefront.; Intrinsic takes a hint for reduction strategy using second operand; 0: Target default preference,; 1: `Iterative strategy`, and; 2: `DPP`.; If target does not support the DPP operations (e.g. gfx6/7),; reduction will be performed using default iterative strategy.; Intrinsic is currently only implemented for i32. llv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:37710,depend,depending,37710,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['depend'],['depending']
Integrability,"package (minuit,GSLminimizer) and alg is the algorithm (migrad) to be used. By default, RooMinuit is still used when RooAbsPdf::fitTo() is called, but can be overridden with; a Minimizer() named argument. // Minimization with MINUIT/MIGRAD through RooMinuit; pdf->fitTo(data) ;. // Minimization with MINUIT/MIGRAD through RooMinimizer; pdf->fitTo(data,Minimizer(""minuit"")) ;. // Minimization with MINUIT2/MIGRAD through RooMinimizer; pdf->fitTo(data,Minimizer(""minuit2"")) ;. // Minimization with GSLMultiMin/conjugatefr through RooMinimizer; pdf->fitTo(data,Minimizer(""GSLMultiMin"",""conjugatefr"")) ;. Note that installation of GSL and the ROOT MathMore package is needed to access the GSL Minimizers and that the GSL; Minimizer do not implement error analysis. New numeric integration algorithms available; RooFit can now interface all MathCore numeric integration; algorithms. In this release ROOT::Math::AdaptiveIntegratorMultiDim,; which implements the 'Genz & Malik' algorithm has been interfaced; in RooAdaptiveIntegratorND and is now the default numeric integrator; for numeric integrations in two or more dimensions. This new default integrator has much improved stability and speed; for relatively smooth p.d.f.s in two or three dimensions and can; generally be used well for p.d.f. normalization integrals without; causing MINUIT converge problems due to numeric precision issues. In future release some more numeric integrators will be migrated to; a MathCore implementation. Interface to TFoam adaptive MC sampler added; RooFit can now use the TFoam adaptive MC sampler for event generation of p.d.f.s that; do not have an internal generator. The TFoam generator adaptively subdivides the; observable space and is generally more efficient both warmup and generation than the original; RooAcceptReject algorithm. In its current interface in RooFit, TFoam cannot; handle problems yet with discrete observables or conditional observables. For those problems; the original RooAcceptReject gene",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:4752,interface,interfaced,4752,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,6,"['integrat', 'interface']","['integrations', 'integrator', 'interfaced']"
Integrability,"parameter of a function or an ObjC method declaration or a; block. Does not match the 'this' parameter of a method. Given; class X { void f(int x, int y, int z) {} };; cxxMethodDecl(hasAnyParameter(hasName(""y""))); matches f(int x, int y, int z) {}; with hasAnyParameter(...); matching int y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end. the matcher objcMethodDecl(hasAnyParameter(hasName(""y""))); matches the declaration of method f with hasParameter; matching y. For blocks, given; b = ^(int y) { printf(""%d"", y) };. the matcher blockDecl(hasAnyParameter(hasName(""y""))); matches the declaration of the block b with hasParameter; matching y. Matcher<BlockDecl>hasParameterunsigned N, Matcher<ParmVarDecl> InnerMatcher; Matches the n'th parameter of a function or an ObjC method; declaration or a block. Given; class X { void f(int x) {} };; cxxMethodDecl(hasParameter(0, hasType(varDecl()))); matches f(int x) {}; with hasParameter(...); matching int x. For ObjectiveC, given; @interface I - (void) f:(int) y; @end. the matcher objcMethodDecl(hasParameter(0, hasName(""y""))); matches the declaration of method f with hasParameter; matching y. Matcher<BlockDecl>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<Typede",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:143200,interface,interface,143200,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['interface'],['interface']
Integrability,"part of the *MathMore* library.; We will later show in more detail the differences between the implementations. ### Integration of One-dimensional Functions. #### Using `ROOT::Math::IntegratorOneDim`. Here is a code example on how to use the `ROOT::Math::IntegratorOneDim` class; (note that the class is defined in the header file `Math/Integrator.h`). In this example we create; different instance of the class using some of the available algorithms in ROOT.; If no algorithm is specified, the default one is used. The default Integrator together with other integration options; such as relative and absolute tolerance, can be specified using the static method of the; `ROOT::Math::IntegratorOneDimOptions`. ```{.cpp}; #include ""Math/Integrator.h"". const double ERRORLIMIT = 1E-3;. double f(double x) {; return x;; }. double f2(const double * x) {; return x[0] + x[1];; }. int testIntegration1D() {. const double RESULT = 0.5;; int status = 0;. // set default tolerances for all integrators; ROOT::Math::IntegratorOneDimOptions::SetDefaultAbsTolerance(1.E-6);; ROOT::Math::IntegratorOneDimOptions::SetDefaultRelTolerance(1.E-6);. ROOT::Math::Functor1D wf(&f);; ROOT::Math::Integrator ig(ROOT::Math::IntegrationOneDim::kADAPTIVESINGULAR);; ig.SetFunction(wf);; double val = ig.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::Integrator ig2(ROOT::Math::IntegrationOneDim::kNONADAPTIVE);; ig2.SetFunction(wf);; val = ig2.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::Integrator ig3(wf, ROOT::Math::IntegrationOneDim::kADAPTIVE);; val = ig3.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::Integrator ig4(ROOT::Math::IntegrationOneDim::kGAUSS);; ig4.SetFunction(wf);; val = ig4.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:51297,integrat,integrators,51297,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['integrat'],['integrators']
Integrability,"path where the; conservative mode is used. Objective-C Message Heuristics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ExprEngine relies on a set of heuristics to partition the set of Objective-C; method calls into those that require bifurcation and those that do not. Below; are the cases when the DynamicTypeInfo of the object is considered precise; (cannot be a subclass):. - If the object was created with +alloc or +new and initialized with an -init; method. - If the calls are property accesses using dot syntax. This is based on the; assumption that children rarely override properties, or do so in an; essentially compatible way. - If the class interface is declared inside the main source file. In this case; it is unlikely that it will be subclassed. - If the method is not declared outside of main source file, either by the; receiver's class or by any superclasses. C++ Caveats; ^^^^^^^^^^^. C++11 [class.cdtor]p4 describes how the vtable of an object is modified as it is; being constructed or destructed; that is, the type of the object depends on; which base constructors have been completed. This is tracked using; DynamicTypeInfo in the DynamicTypePropagation checker. There are several limitations in the current implementation:. * Temporaries are poorly modeled right now because we're not confident in the; placement of their destructors in the CFG. We currently won't inline their; constructors unless the destructor is trivial, and don't process their; destructors at all, not even to invalidate the region. * 'new' is poorly modeled due to some nasty CFG/design issues. This is tracked; in PR12014. 'delete' is not modeled at all. * Arrays of objects are modeled very poorly right now. ExprEngine currently; only simulates the first constructor and first destructor. Because of this,; ExprEngine does not inline any constructors or destructors for arrays. CallEvent; ^^^^^^^^^. A CallEvent represents a specific call to a function, method, or other body of; code. It is path-sensitive, con",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:15767,depend,depends,15767,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,1,['depend'],['depends']
Integrability,"pdate fix handling of the case when; the global list file does not exist yet (new dataset directory). Fixes; error messages during editing dataset operations.; Fix issue with machine names consistency when working on a local; machine ('localhost' or 'localhost.localdomain' are mapped to; gSystem->HostName()); solves possible matching problems in the; packetizer.; In TProofServ, fill the ""grand total"" message with more blanks, so; that no remnants of the previous message are visible on the screen.; In the autoconf/bonjour interface, fix issue preventing the correct; port (the protocol one, which may be different from the application; default) being used when registering the service. . In TProofPlayer::AddQueryResult, fix a bug affecting the order in; whihc query results are registered when the start time is within 1; second.; Fix worker name in TSlaveLite.; Fix problem with enabling packages with option 'notOnClient' in; PROOF-Lite .; Make sure the log file is flushed at the end of startup to avoid; spurious log messages on next commands .; In CreateSession(), fix an issue with the validity check for existing; sessions .; In TProofLite: fix problem with passing the 'varexp' and 'selection'; strings for processing, preventing correct usage of the operators '|'; and '||' in TTreeFormula.; In the TProofOutputFile constructor, remove the 'localroot' prefix; only if present in the path. Fixes possible truncation problems; occuring when the paths are not under the localroot scope.; In TXSocket and TXSlave: fix problem with the way collection over a; socket just marked as 'bad' was interrupted; the interrupt was de facto; ineffective, so that collection stayed always until the timeout expired; (default: 5 minutes). Should solve some of the cases were slow response; was experienced.; Fix a problem with log path transmission when the node dies early or; not even starts. The log path was empty and wrong was filled in when; retrieving the log buffers, disorienting debugging.; F",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v530/index.html:6311,message,messages,6311,proof/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v530/index.html,2,['message'],['messages']
Integrability,"pe 'NSString *'; [birthDates addObject: [NSDate date]];. .. _osx-cocoa-RetainCount:. osx.cocoa.RetainCount (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for leaks and improper reference count management. .. code-block:: objc. void test() {; NSString *s = [[NSString alloc] init]; // warn; }. CFStringRef test(char *bytes) {; return CFStringCreateWithCStringNoCopy(; 0, bytes, NSNEXTSTEPStringEncoding, 0); // warn; }. .. _osx-cocoa-RunLoopAutoreleaseLeak:. osx.cocoa.RunLoopAutoreleaseLeak; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for leaked memory in autorelease pools that will never be drained. .. _osx-cocoa-SelfInit:. osx.cocoa.SelfInit (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""; Check that 'self' is properly initialized inside an initializer method. .. code-block:: objc. @interface MyObj : NSObject {; id x;; }; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; x = 0; // warn: instance variable used while 'self' is not; // initialized; return 0;; }; @end. @interface MyObj : NSObject; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; return self; // warn: returning uninitialized 'self'; }; @end. .. _osx-cocoa-SuperDealloc:. osx.cocoa.SuperDealloc (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about improper use of '[super dealloc]' in Objective-C. .. code-block:: objc. @interface SuperDeallocThenReleaseIvarClass : NSObject {; NSObject *_ivar;; }; @end. @implementation SuperDeallocThenReleaseIvarClass; - (void)dealloc {; [super dealloc];; [_ivar release]; // warn; }; @end. .. _osx-cocoa-UnusedIvars:. osx.cocoa.UnusedIvars (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about private ivars that are never used. .. code-block:: objc. @interface MyObj : NSObject {; @private; id x; // warn; }; @end. @implementation MyObj; @end. .. _osx-cocoa-VariadicMethodTypes:. osx.cocoa.VariadicMethodTypes (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for passing non-Objective-C types to variadic collection; initialization methods that expect only Objective-C t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:40826,interface,interface,40826,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['interface'],['interface']
Integrability,"pe is given for the very first leaf,; it becomes a `float` (F). This leaf list has three floats called `temp`,; `mass`, and `px`. ``` {.cpp}; ""temp:mass:px""; ```. The symbols used for the type are:. - `C`: a character string terminated by the 0 character; - `B`: an 8 bit signed integer; - `b`: an 8 bit unsigned integer; - `S`: a 16 bit signed integer; - `s`: a 16 bit unsigned integer; - `I`: a 32 bit signed integer; - `i`: a 32 bit unsigned integer; - `L`: a 64 bit signed integer; - `l`: a 64 bit unsigned integer; - `G`: a long signed integer, stored as 64 bit; - `g`: a long unsigned integer, stored as 64 bit; - `F`: a 32 bit floating point; - `D`: a 64 bit floating point; - `O`: [the letter 'o', not a zero] a boolean (Bool\_t). The type is used for a byte count to decide how much space to allocate.; The variable written is simply the block of bytes starting at the; starting address given in the second parameter. It may or may not match; the leaf list depending on whether or not the programmer is being; careful when choosing the leaf address, name, and type. By default, a variable will be copied with the number of bytes specified; in the type descriptor symbol. However, if the type consists of two; characters, the number specifies the number of bytes to be used when; copying the variable to the output buffer. The line below describes; `ntrack` to be written as a 16-bit integer (rather than a 32-bit; integer). ``` {.cpp}; ""ntrack/I2""; ```. With this Branch method, you can also add a leaf that holds an entire; array of variables. To add an array of floats use the `f[n]` notation; when describing the leaf. ``` {.cpp}; Float_t f[10];; tree->Branch(""fBranch"",f,""f[10]/F"");; ```. You can also add an array of variable length:. ``` {.cpp}; {; TFile *f = new TFile(""peter.root"",""recreate"");; Int_t nPhot;; Float_t E[500];; TTree* nEmcPhotons = new TTree(""nEmcPhotons"",""EMC Photons"");; nEmcPhotons->Branch(""nPhot"",&nPhot,""nPhot/I"");; nEmcPhotons->Branch(""E"",E,""E[nPhot]/F"");; }; ``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:21912,depend,depending,21912,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['depend'],['depending']
Integrability,"pe=""text/css"">; .none { background-color: #FFCCCC }; .part { background-color: #FFFF99 }; .good { background-color: #CCFF99 }; </style>. .. role:: none; .. role:: part; .. role:: good. .. contents::; :local:. ==============; AMDGPU Support; ==============. Clang supports OpenCL, HIP and OpenMP on AMD GPU targets. Predefined Macros; =================. .. list-table::; :header-rows: 1. * - Macro; - Description; * - ``__AMDGPU__``; - Indicates that the code is being compiled for an AMD GPU.; * - ``__AMDGCN__``; - Defined if the GPU target is AMDGCN.; * - ``__R600__``; - Defined if the GPU target is R600.; * - ``__<ArchName>__``; - Defined with the name of the architecture (e.g., ``__gfx906__`` for the gfx906 architecture).; * - ``__<GFXN>__``; - Defines the GFX family (e.g., for gfx906, this macro would be ``__GFX9__``).; * - ``__amdgcn_processor__``; - Defined with the processor name as a string (e.g., ``""gfx906""``).; * - ``__amdgcn_target_id__``; - Defined with the target ID as a string.; * - ``__amdgcn_feature_<feature-name>__``; - Defined for each supported target feature. The value is 1 if the feature is enabled and 0 if it is disabled. Allowed feature names are sramecc and xnack.; * - ``__AMDGCN_CUMODE__``; - Defined as 1 if the CU mode is enabled and 0 if the WGP mode is enabled.; * - ``__AMDGCN_UNSAFE_FP_ATOMICS__``; - Defined if unsafe floating-point atomics are allowed.; * - ``__AMDGCN_WAVEFRONT_SIZE__``; - Defines the wavefront size. Allowed values are 32 and 64.; * - ``__AMDGCN_WAVEFRONT_SIZE``; - Alias to ``__AMDGCN_WAVEFRONT_SIZE__``. To be deprecated.; * - ``__HAS_FMAF__``; - Defined if FMAF instruction is available (deprecated).; * - ``__HAS_LDEXPF__``; - Defined if LDEXPF instruction is available (deprecated).; * - ``__HAS_FP64__``; - Defined if FP64 instruction is available (deprecated). Please note that the specific architecture and feature names will vary depending on the GPU. Also, some macros are deprecated and may be removed in future releases.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AMDGPUSupport.rst:1929,depend,depending,1929,interpreter/llvm-project/clang/docs/AMDGPUSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AMDGPUSupport.rst,1,['depend'],['depending']
Integrability,"pecial lint-style warnings or errors for your project; * creating additional build artifacts from a single compile step. Use Clang Plugins when you...:. * need your tool to rerun if any of the dependencies change; * want your tool to make or break a build; * need full control over the Clang AST. Do not use Clang Plugins when you...:. * want to run tools outside of your build environment; * want full control on how Clang is set up, including mapping of in-memory; virtual files; * need to run over a specific subset of files in your project which is not; necessarily related to any changes which would trigger rebuilds. LibTooling; ----------. :doc:`LibTooling <LibTooling>` is a C++ interface aimed at writing standalone; tools, as well as integrating into services that run clang tools. Canonical; examples of when to use LibTooling:. * a simple syntax checker; * refactoring tools. Use LibTooling when you...:. * want to run tools over a single file, or a specific subset of files,; independently of the build system; * want full control over the Clang AST; * want to share code with Clang Plugins. Do not use LibTooling when you...:. * want to run as part of the build triggered by dependency changes; * want a stable interface so you don't need to change your code when the AST API; changes; * want high level abstractions like cursors and code completion out of the box; * do not want to write your tools in C++. :doc:`Clang tools <ClangTools>` are a collection of specific developer tools; built on top of the LibTooling infrastructure as part of the Clang project.; They are targeted at automating and improving core development activities of; C/C++ developers. Examples of tools we are building or planning as part of the Clang project:. * Syntax checking (:program:`clang-check`); * Automatic fixing of compile errors (:program:`clang-fixit`); * Automatic code formatting (:program:`clang-format`); * Migration tools for new features in new language standards; * Core refactoring tools. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst:2643,depend,dependency,2643,interpreter/llvm-project/clang/docs/Tooling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst,2,"['depend', 'interface']","['dependency', 'interface']"
Integrability,"pecified by name. There are multiple overloaded functions, some taking a; ``StringRef`` and others taking a ``const Init *``. Some functions return a; ``RecordVal *`` and others return a ``const RecordVal *``. If the field does; not exist, a fatal error message is printed. More often than not, you are interested in the value of the field, not all; the information in the ``RecordVal``. There is a large set of functions that; take a field name in some form and return its value. One function,; ``getValueInit``, returns the value as an ``Init *``. Another function,; ``isValueUnset``, returns a boolean specifying whether the value is unset; (uninitialized). Most of the functions return the value in some more useful form. For; example:. .. code-block:: text. std::vector<int64_t> RegCosts =; SomeRec->getValueAsListOfInts(""RegCosts"");. The field ``RegCosts`` is assumed to be a list of integers. That list is; returned as a ``std::vector`` of 64-bit integers. If the field is not a list; of integers, a fatal error message is printed. Here is a function that returns a field value as a ``Record``, but returns; null if the field does not exist. .. code-block:: text. if (Record *BaseRec = SomeRec->getValueAsOptionalDef(BaseFieldName)) {; ...; }. The field is assumed to have another record as its value. That record is returned; as a pointer to a ``Record``. If the field does not exist or is unset, the; functions returns null. Getting Record Superclasses; ===========================. The ``Record`` class provides a function to obtain the superclasses of a; record. It is named ``getSuperClasses`` and returns an ``ArrayRef`` of an; array of ``std::pair`` pairs. The superclasses are in post-order: the order; in which the superclasses were visited while copying their fields into the; record. Each pair consists of a pointer to the ``Record`` instance for a; superclass record and an instance of the ``SMRange`` class. The range; indicates the source file locations of the beginning and end o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst:21093,message,message,21093,interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,1,['message'],['message']
Integrability,"pects the bounds annotation on; the expression type, including the bounds annotation is implcit. For example,; the global variable ``g`` in the following code is implicitly ``__single`` so; ``typeof(g)`` gets ``char *__single``. The similar is true for the parameter; ``p``, so ``typeof(p)`` returns ``void *__single``. The local variable ``l`` is; implicitly ``__bidi_indexable``, so ``typeof(l)`` becomes; ``int *__bidi_indexable``. .. code-block:: C. char *g; // typeof(g) == char *__single. void foo(void *p) {; // typeof(p) == void *__single. int *l; // typeof(l) == int *__bidi_indexable; }. When the type of expression has an ""external"" bounds annotation, e.g.,; ``__sized_by``, ``__counted_by``, etc., the compiler may report an error on; ``typeof`` if the annotation creates a dependency with another declaration or; variable. For example, the compiler reports an error on ``typeof(p1)`` shown in; the following code because allowing it can potentially create another type; dependent on the parameter ``size`` in a different context (Please note that an; external bounds annotation on a parameter may only refer to another parameter of; the same function). On the other hand, ``typeof(p2)`` works resulting in ``int; *__counted_by(10)``, since it doesn't depend on any other declaration. .. TODO: add a section describing constraints on external bounds annotations. .. code-block:: C. void foo(int *__counted_by(size) p1, size_t size) {; // typeof(p1) == int *__counted_by(size); // -> a compiler error as it tries to create another type; // dependent on `size`. int *__counted_by(10) p2; // typeof(p2) == int *__counted_by(10); // -> no error. }. When ``typeof()`` takes a type name, the compiler doesn't apply an implicit; bounds annotation on the named pointer types. For example, ``typeof(int*)``; returns ``int *`` without any bounds annotation. A bounds annotation may be; added after the fact depending on the context. In the following example,; ``typeof(int *)`` returns ``int *`` so",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:26509,depend,dependent,26509,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['depend'],['dependent']
Integrability,"ped into a; new object file containing the code necessary to register it with the offloading; runtime. Usage; =====. This tool can be used with the following options. Any arguments not intended; only for the linker wrapper will be forwarded to the wrapped linker job. .. code-block:: console. USAGE: clang-linker-wrapper [options] -- <options to passed to the linker>. OPTIONS:; --bitcode-library=<kind>-<triple>-<arch>=<path>; Extra bitcode library to link; --cuda-path=<dir> Set the system CUDA path; --device-debug Use debugging; --device-linker=<value> or <triple>=<value>; Arguments to pass to the device linker invocation; --dry-run Print program arguments without running; --embed-bitcode Embed linked bitcode in the module; --help-hidden Display all available options; --help Display available options (--help-hidden for more); --host-triple=<triple> Triple to use for the host compilation; --linker-path=<path> The linker executable to invoke; -L <dir> Add <dir> to the library search path; -l <libname> Search for library <libname>; --opt-level=<O0, O1, O2, or O3>; Optimization level for LTO; -o <path> Path to file to write output; --pass-remarks-analysis=<value>; Pass remarks for LTO; --pass-remarks-missed=<value>; Pass remarks for LTO; --pass-remarks=<value> Pass remarks for LTO; --print-wrapped-module Print the wrapped module's IR for testing; --ptxas-arg=<value> Argument to pass to the 'ptxas' invocation; --save-temps Save intermediate results; --sysroot<value> Set the system root; --verbose Verbose output from tools; --v Display the version number and exit; -- The separator for the wrapped linker arguments. Example; =======. This tool links object files with offloading images embedded within it using the; ``-fembed-offload-object`` flag in Clang. Given an input file containing the; magic section we can pass it to this tool to extract the data contained at that; section and run a device linking job on it. .. code-block:: console. clang-linker-wrapper --host-triple=x86_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst:1918,wrap,wrapped-module,1918,interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst,3,['wrap'],"['wrapped', 'wrapped-module']"
Integrability,"ped network connection, etc.), or; malformed input. These errors should be detected and communicated to a level of; the program where they can be handled appropriately. Handling the error may be; as simple as reporting the issue to the user, or it may involve attempts at; recovery. .. note::. While it would be ideal to use this error handling scheme throughout; LLVM, there are places where this hasn't been practical to apply. In; situations where you absolutely must emit a non-programmatic error and; the ``Error`` model isn't workable you can call ``report_fatal_error``,; which will call installed error handlers, print a message, and abort the; program. The use of `report_fatal_error` in this case is discouraged. Recoverable errors are modeled using LLVM's ``Error`` scheme. This scheme; represents errors using function return values, similar to classic C integer; error codes, or C++'s ``std::error_code``. However, the ``Error`` class is; actually a lightweight wrapper for user-defined error types, allowing arbitrary; information to be attached to describe the error. This is similar to the way C++; exceptions allow throwing of user-defined types. Success values are created by calling ``Error::success()``, E.g.:. .. code-block:: c++. Error foo() {; // Do something.; // Return success.; return Error::success();; }. Success values are very cheap to construct and return - they have minimal; impact on program performance. Failure values are constructed using ``make_error<T>``, where ``T`` is any class; that inherits from the ErrorInfo utility, E.g.:. .. code-block:: c++. class BadFileFormat : public ErrorInfo<BadFileFormat> {; public:; static char ID;; std::string Path;. BadFileFormat(StringRef Path) : Path(Path.str()) {}. void log(raw_ostream &OS) const override {; OS << Path << "" is malformed"";; }. std::error_code convertToErrorCode() const override {; return make_error_code(object_error::parse_failed);; }; };. char BadFileFormat::ID; // This should be declared in the C",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:18710,wrap,wrapper,18710,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['wrap'],['wrapper']
Integrability,"pendant node.; Let's modify the previous example and import a ``FieldDecl`` instead of the ``ClassTemplateSpecializationDecl``. .. code-block:: cpp. auto Matcher = fieldDecl(hasName(""i2""));; auto *From = getFirstDecl<FieldDecl>(Matcher, FromUnit);. In this case we can see that an error is associated (``getImportDeclErrorIfAny``) to the specialization also, not just to the field:. .. code-block:: cpp. llvm::Expected<Decl *> ImportedOrErr = Importer.Import(From);; if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; consumeError(std::move(Err));. // check that the ClassTemplateSpecializationDecl is also marked as; // erroneous.; auto *FromSpec = getFirstDecl<ClassTemplateSpecializationDecl>(; classTemplateSpecializationDecl(hasName(""X"")), FromUnit);; assert(Importer.getImportDeclErrorIfAny(FromSpec));; // Btw, the error is also set for the FieldDecl.; assert(Importer.getImportDeclErrorIfAny(From));; return 1;; }. Polluted AST; """""""""""""""""""""""". We may recognize an error during the import of a dependent node. However, by that time, we had already created the dependant.; In these cases we do not remove the existing erroneous node from the ""to"" context, rather we associate an error to that node.; Let's extend the previous example with another class ``Y``.; This class has a forward definition in the ""to"" context, but its definition is in the ""from"" context.; We'd like to import the definition, but it contains a member whose type conflicts with the type in the ""to"" context:. .. code-block:: cpp. std::unique_ptr<ASTUnit> ToUnit = buildASTFromCode(; R""(; // primary template; template <typename T>; struct X {};; // explicit specialization; template<>; struct X<int> { int i; };. class Y;; )"",; ""to.cc"");; ToUnit->enableSourceFileDiagnostics();; std::unique_ptr<ASTUnit> FromUnit = buildASTFromCode(; R""(; // primary template; template <typename T>; struct X {};; // explicit specialization; template<>; struct X<int> { int i2; };; // field mismatch: ^^. class Y { void f(",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:16434,depend,dependent,16434,interpreter/llvm-project/clang/docs/LibASTImporter.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst,1,['depend'],['dependent']
Integrability,"pendent code generator and analysis improvements. N: Daniel Berlin; E: dberlin@dberlin.org; D: ET-Forest implementation.; D: Sparse bitmap. N: Geoff Berry; E: gberry@codeaurora.org; E: gcb@acm.org; D: AArch64 backend improvements; D: Added EarlyCSE MemorySSA support; D: CodeGen improvements. N: David Blaikie; E: dblaikie@gmail.com; D: General bug fixing/fit & finish, mostly in Clang. N: Neil Booth; E: neil@daikokuya.co.uk; D: APFloat implementation. N: Alex Bradbury; E: asb@igalia.com; D: RISC-V backend. N: Misha Brukman; E: brukman+llvm@uiuc.edu; W: http://misha.brukman.net; D: Portions of X86 and Sparc JIT compilers, PowerPC backend; D: Incremental bitcode loader. N: Cameron Buschardt; E: buschard@uiuc.edu; D: The `mem2reg' pass - promotes values stored in memory to registers. N: Brendon Cahoon; E: bcahoon@codeaurora.org; D: Loop unrolling with run-time trip counts. N: Chandler Carruth; E: chandlerc@gmail.com; E: chandlerc@google.com; D: Hashing algorithms and interfaces; D: Inline cost analysis; D: Machine block placement pass; D: SROA. N: Casey Carter; E: ccarter@uiuc.edu; D: Fixes to the Reassociation pass, various improvement patches. N: Evan Cheng; E: evan.cheng@apple.com; D: ARM and X86 backends; D: Instruction scheduler improvements; D: Register allocator improvements; D: Loop optimizer improvements; D: Target-independent code generator improvements. N: Dan Villiom Podlaski Christiansen; E: danchr@gmail.com; E: danchr@cs.au.dk; W: http://villiom.dk; D: LLVM Makefile improvements; D: Clang diagnostic & driver tweaks; S: Aarhus, Denmark. N: Jeff Cohen; E: jeffc@jolt-lang.org; W: http://jolt-lang.org; D: Native Win32 API portability layer. N: John T. Criswell; E: criswell@uiuc.edu; D: Original Autoconf support, documentation improvements, bug fixes. N: Anshuman Dasgupta; E: adasgupt@codeaurora.org; D: Deterministic finite automaton based infrastructure for VLIW packetization. N: Stefanus Du Toit; E: stefanus.du.toit@intel.com; D: Bug fixes and minor improvement",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CREDITS.TXT:2161,interface,interfaces,2161,interpreter/llvm-project/llvm/CREDITS.TXT,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CREDITS.TXT,1,['interface'],['interfaces']
Integrability,"per drawing of TEllipse; 24. Add proper support of ""Symbols"" and ""Wingdings"" fonts; 25. Make ""col"" default draw option for TH2 in JSROOT gui. ## Changes in 6.3.4; 1. Fix bug in handling superimposing items via URL syntax; 2. Enable geometry clipping in node.js; 3. Upgrade node.js packages; 4. Let draw TGeo object inside TCanvas; 5. Let superimpose TPolyLine3D and TPolyMarker3D with TGeo drawing; 6. Fix plain #sum and #int parsing in TLatex; 7. Fix ticks position for axes with labels. ## Changes in 6.3.3; 1. Fix TEfficiency drawing; 2. Provide TPadPainter.divide method; 3. Fix browsing remote file via THttpServer; 4. Fix lego draw update while zooming. ## Changes in 6.3.2; 1. Fix bug in TH1 drawing when minimum or/and maximum was configured for histogram. ## Changes in 6.3.1; 1. Fix bug with col draw option in TH2/RH2. ## Changes in 6.3.0; 1. Fully rewrite TLatex parsing, use svg elements instead of plain text/tspan; 2. Make TLatex reliably working in node.js, does not depend from availability of canvas component; 3. Many optimizations to produce smaller (and faster) SVG output; 4. Provide x3dscNNN and y3dscNNN draw option for histogram to resize x/y axis in 3D plots; 5. Provide ""Find label"" command in TAxis context menu to zoom into bin region; 6. Allows to use JSROOT.define() in external scripts; 7. Provide JSROOT.Painter.setDefaultDrawOpt() to change class default draw option; 8. Provide example of custom entries in histogram context menu; 9. Provide alternative external location for zstd-codec, let use zstd even when not found locally; 10. Let skip HEAD requests when reading files, adding ""^"" symbol to file name (#223); 11. Show long histogram names in stats box when possible; 12. Fix logic how ""ndiv"" parameter of TAxis is handled, showing really the configured number of ticks; 13. Fix problem with curved TGraph drawings (#218); 14. Fix problems with TGraph drawing updates; 15. Base version for ROOT 6.26 release. ## Changes in 6.2.2; 1. Fix - proper fill TH1 which",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:21134,depend,depend,21134,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['depend'],['depend']
Integrability,"perations easy, such as generating code to produce an lvalue or; an rvalue, or to initialize a memory location with a given value. Prefer; to use these functions rather than directly writing loads and stores,; because these functions take care of some of the tricky details for you; (e.g., for exceptions).; * If your expression requires some special behavior in the event of an; exception, look at the ``push*Cleanup`` functions in ``CodeGenFunction``; to introduce a cleanup. You shouldn't have to deal with; exception-handling directly.; * Testing is extremely important in IR generation. Use ``clang -cc1; -emit-llvm`` and `FileCheck; <https://llvm.org/docs/CommandGuide/FileCheck.html>`_ to verify that you're; generating the right IR. #. Teach template instantiation how to cope with your AST node, which requires; some fairly simple code:. * Make sure that your expression's constructor properly computes the flags; for type dependence (i.e., the type your expression produces can change; from one instantiation to the next), value dependence (i.e., the constant; value your expression produces can change from one instantiation to the; next), instantiation dependence (i.e., a template parameter occurs; anywhere in your expression), and whether your expression contains a; parameter pack (for variadic templates). Often, computing these flags; just means combining the results from the various types and; subexpressions.; * Add ``TransformXXX`` and ``RebuildXXX`` functions to the ``TreeTransform``; class template in ``Sema``. ``TransformXXX`` should (recursively); transform all of the subexpressions and types within your expression,; using ``getDerived().TransformYYY``. If all of the subexpressions and; types transform without error, it will then call the ``RebuildXXX``; function, which will in turn call ``getSema().BuildXXX`` to perform; semantic analysis and build your expression.; * To test template instantiation, take those tests you wrote to make sure; that you were type check",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:152614,depend,dependence,152614,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['depend'],['dependence']
Integrability,"perfectly legal to index partially through a structure,; returning a pointer to an inner element. Because of this, the LLVM code; for the given testcase is equivalent to:. .. code-block:: llvm. define ptr @foo(ptr %s) {; %t1 = getelementptr %struct.ST, ptr %s, i32 1; %t2 = getelementptr %struct.ST, ptr %t1, i32 0, i32 2; %t3 = getelementptr %struct.RT, ptr %t2, i32 0, i32 1; %t4 = getelementptr [10 x [20 x i32]], ptr %t3, i32 0, i32 5; %t5 = getelementptr [20 x i32], ptr %t4, i32 0, i32 13; ret ptr %t5; }. The indices are first converted to offsets in the pointer's index type. If the; currently indexed type is a struct type, the struct offset corresponding to the; index is sign-extended or truncated to the pointer index type. Otherwise, the; index itself is sign-extended or truncated, and then multiplied by the type; allocation size (that is, the size rounded up to the ABI alignment) of the; currently indexed type. The offsets are then added to the low bits of the base address up to the index; type width, with silently-wrapping two's complement arithmetic. If the pointer; size is larger than the index size, this means that the bits outside the index; type width will not be affected. The result value of the ``getelementptr`` may be outside the object pointed; to by the base pointer. The result value may not necessarily be used to access; memory though, even if it happens to point into allocated storage. See the; :ref:`Pointer Aliasing Rules <pointeraliasing>` section for more; information. If the ``inbounds`` keyword is present, the result value of a; ``getelementptr`` with any non-zero indices is a; :ref:`poison value <poisonvalues>` if one of the following rules is violated:. * The base pointer has an *in bounds* address of an allocated object, which; means that it points into an allocated object, or to its end. Note that the; object does not have to be live anymore; being in-bounds of a deallocated; object is sufficient.; * If the type of an index is larger than t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:436599,wrap,wrapping,436599,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['wrap'],['wrapping']
Integrability,"perform explicit conversions. The C++ code used for the examples below can be found; :doc:`here <cppyy_features_header>`, and it is assumed that that code is; loaded at the start of any session.; Download it, save it under the name ``features.h``, and load it:. .. code-block:: python. >>> import cppyy; >>> cppyy.include('features.h'); >>>. .. _sec-auto-casting-label:. `Auto-casting`; --------------. Object pointer returns from functions provide the most derived class known; (i.e. exposed in header files) in the hierarchy of the object being returned.; This is important to preserve object identity as well as to make casting,; a pure C++ feature after all, superfluous.; Example:. .. code-block:: python. >>> from cppyy.gbl import Abstract, Concrete; >>> c = Concrete(); >>> Concrete.show_autocast.__doc__; 'Abstract* Concrete::show_autocast()'; >>> d = c.show_autocast(); >>> type(d); <class '__main__.Concrete'>; >>>. As a consequence, if your C++ classes should only be used through their; interfaces, then no bindings should be provided to the concrete classes; (e.g. by excluding them using a :ref:`selection file <selection-files>`).; Otherwise, more functionality will be available in Python than in C++. Sometimes, however, full control over a cast is needed.; For example, if the instance is bound by another tool or even a 3rd party,; hand-written, extension library.; Assuming the object supports the ``PyCapsule`` or ``CObject`` abstraction,; then a C++-style reinterpret_cast (i.e. without implicitly taking offsets; into account), can be done by taking and rebinding the address of an; object:. .. code-block:: python. >>> from cppyy import addressof, bind_object; >>> e = bind_object(addressof(d), Abstract); >>> type(e); <class '__main__.Abstract'>; >>>. `Operators`; -----------. If conversion operators are defined in the C++ class and a Python equivalent; exists (i.e. all builtin integer and floating point types, as well as; ``bool``), then these will map onto those Python",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/type_conversions.rst:1207,interface,interfaces,1207,bindings/pyroot/cppyy/cppyy/doc/source/type_conversions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/type_conversions.rst,1,['interface'],['interfaces']
Integrability,"performance or correctness regressions in code; compiled by LLVM on all applicable targets. * You are expected to address any `GitHub Issues <https://github.com/llvm/llvm-project/issues>`_ that; result from your change. We prefer for this to be handled before submission but understand that it isn't; possible to test all of this for every submission. Our build bots and nightly; testing infrastructure normally finds these problems. A good rule of thumb is; to check the nightly testers for regressions the day after your change. Build; bots will directly email you if a group of commits that included yours caused a; failure. You are expected to check the build bot messages to see if they are; your fault and, if so, fix the breakage. Commits that violate these quality standards (e.g. are very broken) may be; reverted. This is necessary when the change blocks other developers from making; progress. The developer is welcome to re-commit the change after the problem has; been fixed. .. _commit messages:. Commit messages; ---------------. Although we don't enforce the format of commit messages, we prefer that; you follow these guidelines to help review, search in logs, email formatting; and so on. These guidelines are very similar to rules used by other open source; projects. Most importantly, the contents of the message should be carefully written to; convey the rationale of the change (without delving too much in detail). It; also should avoid being vague or overly specific. For example, ""bits were not; set right"" will leave the reviewer wondering about which bits, and why they; weren't right, while ""Correctly set overflow bits in TargetInfo"" conveys almost; all there is to the change. Below are some guidelines about the format of the message itself:. * Separate the commit message into title and body separated by a blank line. * If you're not the original author, ensure the 'Author' property of the commit is; set to the original author and the 'Committer' property is set to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:14797,message,messages,14797,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['message'],['messages']
Integrability,"piling Minuit2 on a compiler which supports openMP (for example gcc version >= 4.2); ; Add, thanks to Alfio Lazzaro, support for running Minuit2 using multi-process by using MPI. A new class MPIProcess deals with starting and terminating the MPI process. Each process calculates independently the derivatives for a given set of parameters.; A Minuit2 library with MPI support can be built by defining before compilation the environment variables USE_PARALLEL_MINUIT2 and USE_MPI. Unuran; Add constructor of Tunuran distributions using function objects defined using the mathcore interfaces:. TUnuranContDist (const ROOT::Math::IGenFunction & pdf, const ROOT::Math::IGenFunction * dpdf, bool isLogPdf);; TUnuranMultiContDist (const ROOT::Math::IMultiGenFunction & pdf, bool isLogPdf );; TUnuranDiscrDist (const ROOT::Math::IGenFunction & func );. TRolke; New version of TRolke from J. Lundberg. The interface of the class has been changed. The old user interface was very hard to use, and the documentation in the source was also not on par with the correct usage. The old interface was a single get-function with 12 arguments, and the user was supposed to figure out which ~ 5 arguments were relevant for a specific model (1 out of 7 models).; ; The new user interface is is easy to use correctly and hard to use incorrectly (TM). It's a single set-method for each method:. SetPoissonBkgBinomialEff(Int_t x,Int_t y,Int_t z,Double_t tau,Int_t m);; SetPoissonBkgGaussianEff(Int_t x,Int_t y,Double_t em, Double_t tau,Double_t sde);; SetGaussianBkgGaussianEff(Int_t x,Double_t bm,Double_t em, Double_t sde,Double_t sdb);; SetPoissondBkgknownEff(Int_t x,Int_t y,Double_t tau,Double_t e);; SetGaussianBkgknownEff(Int_t x,Double_t bm,Double_t sdb,Double_t e);; SetKnownBkgBinomialEff(Int_t x, Int_t z,Int_t m,Double_t b);; SetknownBkgGaussianEff(Int_t x,Double_t em,Double_t sde,Double_t b);. New methods for getting sensitivity (average limits) and related quantities and for critical number related to reje",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v524/index.html:8333,interface,interface,8333,math/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v524/index.html,2,['interface'],['interface']
Integrability,"ping the contents of a Tree to an ascii file, eg; from the command line:. ``` {.cpp}; root[] tree->SetScanField(0);; root[] tree->Scan(""*""); >tree.log; ```. will create a file `tree.log`. Arrays (within an entry) are printed in their linear forms. If several; arrays with multiple dimensions are printed together, they will NOT be; synchronized. For example, with a tree containing `arr1[4][2] `and; `arr2[2][3]`,. ``` {.cpp}; root[] MyTree(""arr1:arr2"");; ```. will results in a printing similar to:. ``` {.cpp}; ************************************************; * Row * Instance * arr1 * arr2 *; ***********************************************; * x * 0 * arr1[0][0]* arr2[0][0]*; * x * 1 * arr1[0][1]* arr2[0][1]*; * x * 2 * arr1[1][0]* arr2[0][2]*; * x * 3 * arr1[1][1]* arr2[1][0]*; * x * 4 * arr1[2][0]* arr2[1][1]*; * x * 5 * arr1[2][1]* arr2[1][2]*; * x * 6 * arr1[3][0]* *; * x * 7 * arr1[3][1]* *; ```. However, if there is a selection criterium which is an array, then all; the formulas will be synchronized with the selection criterium (see; **`TTree::Draw` for more information).**. The third parameter of `TTree::Scan` can be use to specific the layout; of the table:. - `lenmax=dd` - where 'dd' is the maximum number of elements per array; that should be printed. If 'dd' is 0, all elements are printed (this; is the default). - `colsize=ss` - where 'ss' will be used as the default size for all; the column. If this options is not specified, the default column; size is 9. - `precision=pp` - where 'pp' will be used as the default 'precision'; for the printing format. - `col=xxx` - where '`xxx`' is colon (:) delimited list of printing; format for each column if no format is specified for a column, the; default is used. For example:. ``` {.cpp}; tree->Scan(""a:b:c"","""",""colsize=30 precision=3 col=::20.10"");; ```. will print 3 columns, the first 2 columns will be 30 characters long,; the third columns will be 20 characters long. The printf format for the; columns (assuming they are",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:106806,synchroniz,synchronized,106806,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['synchroniz'],['synchronized']
Integrability,"pired from Python multiprocessor module. The new interface, implemented in the class TProcPool, provides the possibility to perform in parallel a very generic set of tasks, described by macros, functions or lambdas. This illustrates the usage of lambdas:. ``` {.cpp}; {; TProcPool pool;; auto ten = pool.MapReduce([]() { return 1; }, 10, [](std::vector<int> v) { return std::accumulate(v.begin(), v.end(), 0); }); }; ```. And this how it can be used to generate ten histos and merge them:. ``` {.cpp}; {; TObject *CreateAndFillHists(); {. TH1F *h = new TH1F(""h"", """", 100, -3., 3.);; h->SetDirectory(0);; h->FillRandom(""gaus"", 1000);; return h;; }. TProcPool pool;; auto hist = pool.MapReduce(CreateAndFillHists, 10, PoolUtils::ReduceObjects);; hist->DrawClone();; }; ```. Tutorials illustrating other usages of the new class TProcPool are available under tutorials/multicore. ## Language Bindings. ### Notebooks; We provided integration of ROOT with the Jupyter technology, integrating ROOT with Python Notebooks and providing a ROOT Kernel like functionality - de facto an enhanced C++ web based shell. Tab completion, output and graphics inlining have been added. These functionalities are automatically available upon import of the ROOT module in a Notebook or at startup of a ROOT prompt kernel.; We made it easier to use ROOT notebooks locally, by providing a 'root --notebook' command option to start a local notebook server customised with all the ROOT features. New tutorials and code examples have been provided. The simplest example showing the integration of ROOT with the notebook technology can be found [here](https://root.cern.ch/notebooks/HowTos/HowTo_ROOT-Notebooks.html) and many more snippets [here](https://root.cern.ch/code-examples#notebooks). Support for capturing large outputs (stderr/stdout) coming from C++ libraries has been added. ## JavaScript ROOT. - support registered in THttpServer commands with arguments.; - provide workaround for websites using require.js and old",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:22094,integrat,integration,22094,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,2,['integrat'],"['integrating', 'integration']"
Integrability,"placing the creation of a `ROOT::Math::GaussIntegrator` object with `ROOT::Math::GaussLegendreIntegrator`. #### ROOT::Math::GSLIntegrator. This is a wrapper for the *QUADPACK* integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time.; The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide; This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the; GSL library, wich is provided in the *MathMore* library of ROOT. The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the `ROOT::Math::GSLIntegrator` class.; ```{.cpp}; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; ```. The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <= max ( epsAbs, epsRel * Integral); $$; Where *absErr* is an estimate of the absolute error (it can be retrieved with `GSLIntegrator::Error()`) and *Integral* is the estimate of the function integral; (it can be obtained with `GSLIntegrator::Result()`). The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the `GSL` users documentation.; * `ROOT::Math::Integration::kNONADAPTIVE` : based on `gsl_integration_qng`. It is a non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson abscissae; to sample the integrand at a maximum of 87 points. It is provided for fast integ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:55387,integrat,integrator,55387,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['integrat'],['integrator']
Integrability,"plements. .. code-block:: none. void __cfi_check(uint64 CallSiteTypeId, void *TargetAddr, void *DiagData). This function provides external modules with access to CFI checks for; the targets inside this DSO. For each known ``CallSiteTypeId``, this; function performs an ``llvm.type.test`` with the corresponding type; identifier. It reports an error if the type is unknown, or if the; check fails. Depending on the values of compiler flags; ``-fsanitize-trap`` and ``-fsanitize-recover``, this function may; print an error, abort and/or return to the caller. ``DiagData`` is an; opaque pointer to the diagnostic information about the error, or; ``null`` if the caller does not provide this information. The basic implementation is a large switch statement over all values; of CallSiteTypeId supported by this DSO, and each case is similar to; the InlinedFastCheck() in the basic CFI mode. CFI Shadow; ----------. To route CFI checks to the target DSO's __cfi_check function, a; mapping from possible virtual / indirect call targets to the; corresponding __cfi_check functions is maintained. This mapping is; implemented as a sparse array of 2 bytes for every possible page (4096; bytes) of memory. The table is kept readonly most of the time. There are 3 types of shadow values:. - Address in a CFI-instrumented DSO.; - Unchecked address (a “trusted” non-instrumented DSO). Encoded as; value 0xFFFF.; - Invalid address (everything else). Encoded as value 0. For a CFI-instrumented DSO, a shadow value encodes the address of the; __cfi_check function for all call targets in the corresponding memory; page. If Addr is the target address, and V is the shadow value, then; the address of __cfi_check is calculated as. .. code-block:: none. __cfi_check = AlignUpTo(Addr, 4096) - (V + 1) * 4096. This works as long as __cfi_check is aligned by 4096 bytes and located; below any call targets in its DSO, but not more than 256MB apart from; them. CFI_SlowPath; ------------. The slow path check is implemente",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:21792,rout,route,21792,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,1,['rout'],['route']
Integrability,"ples. \defgroup tutorial_dataframe Dataframe tutorials; \ingroup Tutorials; \brief These examples show various features of [RDataFrame](classROOT_1_1RDataFrame.html): ROOT's declarative analysis interface. \defgroup tutorial_v7 ROOT 7 tutorials; \ingroup Tutorials; \brief Various examples showing the ROOT 7 interface. \defgroup tutorial_FOAM FOAM tutorials; \ingroup Tutorials; \brief Examples showing how to use FOAM. \defgroup tutorial_cont Containers tutorials; \ingroup Tutorials; \brief Examples showing the ""containers' classes"" usage. \defgroup tutorial_eve Event display tutorials; \ingroup Tutorials; \brief Examples showing the ""Event display classes"" usage. \defgroup tutorial_eve7 Event display ROOT7 tutorials; \ingroup Tutorials; \brief Examples showing the ""Event display classes"" usage with ROOT7. \defgroup tutorial_geom Geometry tutorials; \ingroup Tutorials; \brief Various ROOT geometry package examples. \defgroup tutorial_fft Fast Fourier Transforms tutorials; \ingroup Tutorials; \brief Example showing the Fast Fourier Transforms interface in ROOT. \defgroup tutorial_fit Fit Tutorials; \ingroup Tutorials; \brief These tutorials illustrate the main fitting features. Their names are related to the aspect which is treated in the code. \defgroup tutorial_roofit RooFit Tutorials; \ingroup Tutorials; \brief These tutorials illustrate the main features of [RooFit](group__Roofitmain.html): the name of the examples and their short description help in figuring out their objective. \defgroup tutorial_graphs Graphs tutorials; \ingroup Tutorials; \brief Examples showing the ""graphs classes"" usage. \defgroup tutorial_graphics Graphics tutorials; \ingroup Tutorials; \brief Various examples showing the basic ROOT graphics. \defgroup tutorial_gl OpenGL tutorials; \ingroup Tutorials; \brief Various examples showing the OpenGL graphics in ROOT. \defgroup tutorial_cocoa Tutorials specific to Mac/Cocoa; \ingroup Tutorials; \brief Various examples showing graphics done with the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/index.md:2191,interface,interface,2191,tutorials/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/index.md,1,['interface'],['interface']
Integrability,"plete; COMPONENT bash-autocomplete); endif(); endif(). option(CLANG_BUILD_TOOLS; ""Build the Clang tools. If OFF, just generate build targets."" ON). if(LLVM_ENABLE_PLUGINS OR LLVM_EXPORT_SYMBOLS_FOR_PLUGINS); set(HAVE_CLANG_PLUGIN_SUPPORT ON); else(); set(HAVE_CLANG_PLUGIN_SUPPORT OFF); endif(); CMAKE_DEPENDENT_OPTION(CLANG_PLUGIN_SUPPORT; ""Build clang with plugin support"" ON; ""HAVE_CLANG_PLUGIN_SUPPORT"" OFF). # If libstdc++ is statically linked, clang-repl needs to statically link libstdc++; # itself, which is not possible in many platforms because of current limitations in; # JIT stack. (more platforms need to be supported by JITLink); if(NOT LLVM_STATIC_LINK_CXX_STDLIB); set(HAVE_CLANG_REPL_SUPPORT ON); endif(). option(CLANG_ENABLE_ARCMT ""Build ARCMT."" ON); option(CLANG_ENABLE_STATIC_ANALYZER; ""Include static analyzer in clang binary."" ON). option(CLANG_ENABLE_PROTO_FUZZER ""Build Clang protobuf fuzzer."" OFF). if(NOT CLANG_ENABLE_STATIC_ANALYZER AND CLANG_ENABLE_ARCMT); message(FATAL_ERROR ""Cannot disable static analyzer while enabling ARCMT or Z3""); endif(). if(CLANG_ENABLE_ARCMT); set(CLANG_ENABLE_OBJC_REWRITER ON); endif(). # This option is a stop-gap, we should commit to removing this as; # soon as possible. See discussion:; # https://discourse.llvm.org/t/rationale-for-removing-versioned-libclang-middle-ground-to-keep-it-behind-option/; option(CLANG_FORCE_MATCHING_LIBCLANG_SOVERSION; ""Force the SOVERSION of libclang to be equal to CLANG_MAJOR"" ON). # Clang version information; set(CLANG_EXECUTABLE_VERSION; ""${CLANG_VERSION_MAJOR}"" CACHE STRING; ""Major version number that will be appended to the clang executable name""); set(LIBCLANG_LIBRARY_VERSION; ""${CLANG_VERSION_MAJOR}"" CACHE STRING; ""Major version number that will be appended to the libclang library""); mark_as_advanced(CLANG_EXECUTABLE_VERSION LIBCLANG_LIBRARY_VERSION). option(CLANG_INCLUDE_TESTS; ""Generate build targets for the Clang unit tests.""; ${LLVM_INCLUDE_TESTS}). option(CLANG_ENABLE_HLSL ""Include H",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:15814,message,message,15814,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,1,['message'],['message']
Integrability,"pletion (`Foo<std::vector<float>>` -> `Foo<std::vector<float, std::allocator<float>>>`). ### Experimental PyROOT; - Added pythonisations for `TTree` and its subclasses (e.g. `TChain`, `TNtuple`); - Pythonic iterator (`for event in tree:`); - Access tree branches as attributes (`mytree.mybranch`); - `TTree::Branch` pythonisation; - `TTree::SetBranchAddress` pythonisation; - Added pythonisations for `TDirectory` and its subclasses (e.g `TFile`, `TDirectoryFile`); - Access directories/objects in `TDirectory`/`TDirectoryFile`/`TFile` as attributes; (`mydir1.mydir2.myhist`, `myfile.myhist`, `myfile.mydir.myhist`); - `TDirectory::Get` pythonisation; - `TDirectory::WriteObject` pythonisation; - `TFile::Open` pythonisation; - Added pretty printing generic pythonisation for all classes; - Added interoperability with NumPy arrays for STL vectors and `RVec`s (zero-copy wrapping of; vectors and `RVec`s into NumPy arrays). ### Jupyter Notebook Integration; - Make sure the ROOT C++ Jupyter kernel runs with the same Python version (major and minor) that ROOT; was built with.; - Make the Jupyter server started with `root --notebook` listen on all interfaces. This can be useful; if the user wants to connect to the server remotely. It also fixes an issue observed when starting; the Jupyter server inside a Docker container. ## JavaScript ROOT; - Support of TWebCanvas functionality. Code for ROOT 6.16 will; be maintained in v6-16-00-patches branch of JSROOT repository. ; - Singificant speed up (factor 10) when drawing canvas with many subpads; - Many small improvements and bug fixes, see JSROOT release notes for v5.4.2 - v5.6.2 . ## Tutorials; - Refurbish text in the `RDataFrame` tutorials category. ## Command line tools; - Fixed `rooteventselector` when both applying a cut (based on branch values) and selecting only; a subset of the branches. Previously, the size of the output file was bigger than expected. ## Class Reference Guide. ## Build, Configuration and Testing Infrastructure; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md:20664,interface,interfaces,20664,README/ReleaseNotes/v616/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md,1,['interface'],['interfaces']
Integrability,"plex; method of Nelder and Mead. MnSimplex provides minimization of the; function by the method of $\mbox{SIMPLEX}$ and the functionality for; parameters interaction. It also retains the result from the last; minimization in case the user may want to do subsequent minimization; steps with parameter interactions in between the minimization requests.; The minimization is done by the SimplexMinimizer. Minimization of the; function can be done by directly using the SimplexMinimizer if no; parameters interaction is required. As $\mbox{SIMPLEX}$ is a; stepping method it does not produce a covariance matrix. ### MnSimplex(const FCNBase&, const std::vector$<$double$>$&,\; const std::vector$<$double$>$&, unsigned int) ###. Constructor for the minimal required interface: $\mbox{FCN}$ and; starting values for parameters and uncertainties. Optional the strategy; level in MnStrategy can be specified. ### MnSimplex(const FCNBase&, const MnUserParameters&,\; unsigned int) ###. Constructor for high level parameters interface. Optional the strategy; level in MnStrategy can be specified. ### MnSimplex(const FCNBase&, const MnUserParameterState&,\; const MnStrategy&) ###. Constructor from a full state (parameters + covariance) as starting; input plus the desired strategy. ### operator() ###. MnSimplex::operator()(unsigned int maxfcn, double tolerance) causes; minimization of the $\mbox{FCN}$ and returns the result in form of a; FunctionMinimum. Minimization terminates either when the function has; been called (approximately) $\mbox{maxfcn}$ times, or when the; estimated vertical distance to minimum ($\mbox{EDM}$) is less than; $\mbox{tolerance*up}$. The default value of $\mbox{tolerance}$; is $\mbox{0.1}$. (see [howto:errordef]). ### Parameter interaction ###. MnSimplex retains the result after each minimization; (MnUserParameterStae, see [api:state]) and forwards the interface for; parameter interaction. ### SimplexMinimizer() ###. The SimplexMinimizer() is instantiated using default ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:49495,interface,interface,49495,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['interface'],['interface']
Integrability,"plies; to these options. Defaults to ``-fno-unsafe-math-optimizations``. .. option:: -f[no-]finite-math-only. Allow floating-point optimizations that assume arguments and results are; not NaNs or +-Inf. ``-ffinite-math-only`` defines the; ``__FINITE_MATH_ONLY__`` preprocessor macro.; ``-ffinite-math-only`` implies:. * ``-fno-honor-infinities``; * ``-fno-honor-nans``. ``-ffno-inite-math-only`` implies:. * ``-fhonor-infinities``; * ``-fhonor-nans``. Defaults to ``-fno-finite-math-only``. .. option:: -f[no-]rounding-math. Force floating-point operations to honor the dynamically-set rounding mode by default. The result of a floating-point operation often cannot be exactly represented in the result type and therefore must be rounded. IEEE 754 describes different rounding modes that control how to perform this rounding, not all of which are supported by all implementations. C provides interfaces (``fesetround`` and ``fesetenv``) for dynamically controlling the rounding mode, and while it also recommends certain conventions for changing the rounding mode, these conventions are not typically enforced in the ABI. Since the rounding mode changes the numerical result of operations, the compiler must understand something about it in order to optimize floating point operations. Note that floating-point operations performed as part of constant initialization are formally performed prior to the start of the program and are therefore not subject to the current rounding mode. This includes the initialization of global variables and local ``static`` variables. Floating-point operations in these contexts will be rounded using ``FE_TONEAREST``. - The option ``-fno-rounding-math`` allows the compiler to assume that the rounding mode is set to ``FE_TONEAREST``. This is the default.; - The option ``-frounding-math`` forces the compiler to honor the dynamically-set rounding mode. This prevents optimizations which might affect results if the rounding mode changes or is different from the def",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:60793,interface,interfaces,60793,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['interface'],['interfaces']
Integrability,"plying; various optimization passes. Phase 4 : Symbol Resolution after optimization; ----------------------------------------------. In this phase, the linker reads optimized a native object file and updates the; internal global symbol table to reflect any changes. The linker also collects; information about any changes in use of external symbols by LLVM bitcode; files. In the example above, the linker notes that ``foo4()`` is not used any; more. If dead code stripping is enabled then the linker refreshes the live; symbol information appropriately and performs dead code stripping. After this phase, the linker continues linking as if it never saw LLVM bitcode; files. .. _libLTO:. ``libLTO``; ==========. ``libLTO`` is a shared object that is part of the LLVM tools, and is intended; for use by a linker. ``libLTO`` provides an abstract C interface to use the LLVM; interprocedural optimizer without exposing details of LLVM's internals. The; intention is to keep the interface as stable as possible even when the LLVM; optimizer continues to evolve. It should even be possible for a completely; different compilation technology to provide a different libLTO that works with; their object files and the standard linker tool. ``lto_module_t``; ----------------. A non-native object file is handled via an ``lto_module_t``. The following; functions allow the linker to check if a file (on disk or in a memory buffer) is; a file which libLTO can process:. .. code-block:: c. lto_module_is_object_file(const char*); lto_module_is_object_file_for_target(const char*, const char*); lto_module_is_object_file_in_memory(const void*, size_t); lto_module_is_object_file_in_memory_for_target(const void*, size_t, const char*). If the object file can be processed by ``libLTO``, the linker creates a; ``lto_module_t`` by using one of:. .. code-block:: c. lto_module_create(const char*); lto_module_create_from_memory(const void*, size_t). and when done, the handle is released via. .. code-block:: c. lto_m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LinkTimeOptimization.rst:8294,interface,interface,8294,interpreter/llvm-project/llvm/docs/LinkTimeOptimization.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LinkTimeOptimization.rst,1,['interface'],['interface']
Integrability,"po_Checkout(REPO_NAME rootbench FETCHURL ${upstreamprefix} FETCHREF master; REPO_DIR_VARIABLE rootbench_dir ${rootbench_opts}); if(NOT IS_DIRECTORY ${rootbench_dir}); message(FATAL_ERROR ""Expected rootbench at '${rootbench_dir}' (not a directory?)""); endif(); file(REMOVE_RECURSE ${CMAKE_CURRENT_BINARY_DIR}/rootbench); add_subdirectory(${rootbench_dir} rootbench); endif(); endif(). if(LLVM_LINKER_IS_MOLD); message(FATAL_ERROR ""The mold linker is not supported by ROOT. Please use a different linker""); endif(). cmake_host_system_information(RESULT PROCESSOR QUERY PROCESSOR_DESCRIPTION). message(STATUS ""ROOT Configuration \n; System: ${CMAKE_SYSTEM}; ROOT Platform: ${ROOT_PLATFORM}; ROOT Architecture: ${ROOT_ARCHITECTURE}; Processor: ${PROCESSOR} (${CMAKE_SYSTEM_PROCESSOR}); Build type: ${CMAKE_BUILD_TYPE}; Install path: ${CMAKE_INSTALL_PREFIX}; Compiler: ${CMAKE_CXX_COMPILER_ID} ${CMAKE_CXX_COMPILER_VERSION}; C++ standard: ${CMAKE_CXX_STANDARD}; Compiler flags:""); if(MSVC AND NOT CMAKE_GENERATOR MATCHES Ninja); message(STATUS ""; - C: ${CMAKE_C_FLAGS}; - C (build type specific):; Debug: ${CMAKE_C_FLAGS_DEBUG}; Release: ${CMAKE_C_FLAGS_RELEASE}; MinSizeRel: ${CMAKE_C_FLAGS_MINSIZEREL}; RelWithDebInfo: ${CMAKE_C_FLAGS_RELWITHDEBINFO}; - C++: ${CMAKE_CXX_FLAGS}; - C++ (build type specific):; Debug: ${CMAKE_CXX_FLAGS_DEBUG}; Release: ${CMAKE_CXX_FLAGS_RELEASE}; MinSizeRel: ${CMAKE_CXX_FLAGS_MINSIZEREL}; RelWithDebInfo: ${CMAKE_CXX_FLAGS_RELWITHDEBINFO}""); else(); message(STATUS ""; - C: ${CMAKE_C_FLAGS}; - C (build type specific): ${CMAKE_C_FLAGS_${_BUILD_TYPE_UPPER}}; - C++: ${CMAKE_CXX_FLAGS}; - C++ (build type specific): ${CMAKE_CXX_FLAGS_${_BUILD_TYPE_UPPER}}""); endif(); message(STATUS ""Linker flags:; - Executable: ${CMAKE_EXE_LINKER_FLAGS}; - Module: ${CMAKE_MODULE_LINKER_FLAGS}; - Shared: ${CMAKE_SHARED_LINKER_FLAGS}\n""). ROOT_SHOW_ENABLED_OPTIONS(). #---Packaging-------------------------------------------------------------------------------------; include(RootCPack); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt:30623,message,message,30623,CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt,4,['message'],['message']
Integrability,"point reciprocal approximation; #pragma clang fp reciprocal(on); return x / y;; }. ``#pragma clang fp contract`` specifies whether the compiler should; contract a multiply and an addition (or subtraction) into a fused FMA; operation when supported by the target. The pragma can take three values: ``on``, ``fast`` and ``off``. The ``on``; option is identical to using ``#pragma STDC FP_CONTRACT(ON)`` and it allows; fusion as specified the language standard. The ``fast`` option allows fusion; in cases when the language standard does not make this possible (e.g. across; statements in C). .. code-block:: c++. for(...) {; #pragma clang fp contract(fast); a = b[i] * c[i];; d[i] += a;; }. The pragma can also be used with ``off`` which turns FP contraction off for a; section of the code. This can be useful when fast contraction is otherwise; enabled for the translation unit with the ``-ffp-contract=fast-honor-pragmas`` flag.; Note that ``-ffp-contract=fast`` will override pragmas to fuse multiply and; addition across statements regardless of any controlling pragmas. ``#pragma clang fp exceptions`` specifies floating point exception behavior. It; may take one of the values: ``ignore``, ``maytrap`` or ``strict``. Meaning of; these values is same as for `constrained floating point intrinsics <http://llvm.org/docs/LangRef.html#constrained-floating-point-intrinsics>`_. .. code-block:: c++. {; // Preserve floating point exceptions; #pragma clang fp exceptions(strict); z = x + y;; if (fetestexcept(FE_OVERFLOW)); ...; }. A ``#pragma clang fp`` pragma may contain any number of options:. .. code-block:: c++. void func(float *dest, float a, float b) {; #pragma clang fp exceptions(maytrap) contract(fast) reassociate(on); ...; }. ``#pragma clang fp eval_method`` allows floating-point behavior to be specified; for a section of the source code. This pragma can appear at file or namespace; scope, or at the start of a compound statement (excluding comments).; The pragma is active within the s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:172161,contract,contract,172161,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['contract'],['contract']
Integrability,pointers and void*; No. 574; NAD; Definition of “copy assignment operator”; Clang 3.0. 575; C++11; Criteria for deduction failure; Yes. 576; CD2; Typedefs in function definitions; Clang 3.5. 577; CD3; void in an empty parameter list; Clang 3.5. 578; CD6; Phase 1 replacement of characters with universal-character-names; Unknown. 579; open; What is a “nested” > or >>?; Not resolved. 580; C++11; Access in template-parameters of member and friend definitions; Partial. 581; CD5; Can a templated constructor be explicitly instantiated or specialized?; Unknown. 582; CD1; Template conversion functions; N/A. 583; CD3; Relational pointer comparisons against the null pointer constant; Clang 4. 584; NAD; Unions and aliasing; N/A. 585; NAD; Friend template template parameters; Clang 3.0. 586; NAD; Default template-arguments and template argument deduction; N/A. 587; CD2; Lvalue operands of a conditional expression differing only in cv-qualification; Clang 3.2. 588; CD2; Searching dependent bases of classes local to function templates; Yes. 589; CD2; Direct binding of class and array rvalues in reference initialization; Yes. 590; C++11; Nested classes and the “current instantiation”; Yes. 591; CD4; When a dependent base class is the current instantiation; No. 592; CD1; Exceptions during construction of local static objects; N/A. 593; NAD; Falling off the end of a destructor's function-try-block handler; Unknown. 594; CD1; Coordinating issues 119 and 404 with delegating constructors; N/A. 595; dup; Exception specifications in templates instantiated from class bodies; Duplicate of 1330. 596; NAD; Replacing an exception object; Unknown. 597; CD3; Conversions applied to out-of-lifetime non-POD lvalues; N/A. 598; CD2; Associated namespaces of overloaded functions and function templates; Yes. 599; CD2; Deleting a null function pointer; Partial. 600; CD6; Does access control apply to members or to names?; Clang 2.8. 601; CD2; Type of literals in preprocessing expressions; Yes. 602; C++11;,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:40264,depend,dependent,40264,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['depend'],['dependent']
Integrability,"polluted by a different; # ROOT build. This is significant e,g. for roottest, which will otherwise have libraries; # of a different ROOT build available / visible / reachable.; if(NOT $ENV{ROOTSYS} STREQUAL """"); string(REPLACE ""$ENV{ROOTSYS}/bin"" """" ENV_PATH ""$ENV{PATH}""); string(REPLACE ""$ENV{ROOTSYS}/lib"" """" ENV_LD_LIBRARY_PATH ""$ENV{LD_LIBRARY_PATH}""); string(REPLACE ""$ENV{ROOTSYS}/lib"" """" ENV_PYTHONPATH ""$ENV{PYTHONPATH}""); string(REPLACE ""$ENV{ROOTSYS}"" """" ENV_CMAKE_PREFIX_PATH ""$ENV{CMAKE_PREFIX_PATH}""); set(ENV{PATH} ""${ENV_PATH}""); set(ENV{LD_LIBRARY_PATH} ""${ENV_LD_LIBRARY_PATH}""); set(ENV{PYTHONPATH} ""${ENV_PYTHONPATH}""); set(ENV{CMAKE_PREFIX_PATH} ""${ENV_CMAKE_PREFIX_PATH}""); set(ENV{ROOTSYS} ${CMAKE_BINARY_DIR}); endif(). set(ROOTSYS ${CMAKE_BINARY_DIR}); set(HEADER_OUTPUT_PATH ${CMAKE_BINARY_DIR}/include). #---Set the ROOT version--------------------------------------------------------------------; include(cmake/modules/SetROOTVersion.cmake). message(STATUS ""Building ROOT version ${ROOT_FULL_VERSION}""). #---Where to look first for cmake modules, before ${CMAKE_ROOT}/Modules/ is checked-------------; set(CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/cmake/modules). #---Enable Folders in IDE like Visual Studio----------------------------------------------------; set_property(GLOBAL PROPERTY USE_FOLDERS ON). #---Load some basic macros which are needed later for the confiuration and build----------------; include(CheckCompiler); include(RootBuildOptions); include(RootMacros); include(CheckAssembler); include(CheckIntrinsics). # relatedrepo_GetClosestMatch(REPO_NAME <repo> ORIGIN_PREFIX <originp> UPSTREAM_PREFIX <upstreamp>; # FETCHURL_VARIABLE <output_url> FETCHREF_VARIABLE <output_ref>); # Return the clone URL and head/tag of the closest match for `repo` (e.g. roottest), based on the; # current head name.; function(relatedrepo_GetClosestMatch); cmake_parse_arguments(_ """" ""REPO_NAME;ORIGIN_PREFIX;UPSTREAM_PREFIX;FETCHURL_VARIABLE;FETCHREF_VARIABLE"" """" ${ARGN}). set",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt:3261,message,message,3261,CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt,1,['message'],['message']
Integrability,"popup a dialog to open a file. - *Close Canvas*: close the canvas window. - *Save*: save the drawing of the current canvas in a format; selectable from the submenu. The current canvas name is used as a; file name for various formats such as PostScript, GIF, JPEG, C; macro file, root file. - *Save As...*: popup a dialog for saving the current canvas drawing; in a new filename. - *Print*: popup a dialog to print the current canvas drawing. - *Quit ROOT*: exit the ROOT session. ![](pictures/0300000B.png). #### Edit Menu. There is only one active menu entry in the Edit menu. The others menu; entries will be implemented and will become active in the near future. - *Clear:* delete all objects in the canvas; or in the selected pad according to the selected entry in the; submenu. #### View Menu. - *Editor*: toggles the view of the editor. If it is selected; activates and shows up the editor on the left side of the canvas; window. According to the selected object, the editor loads the; corresponding user interface for easy change of the object's; attributes. - *Toolbar*: toggles the view of the toolbar. If it is selected; activates and shows up the toolbar. It contains buttons for easy; and fast access to most frequently used commands and for graphics; primitive drawing. Tool tips are provided for helping users. - *Status Bar*: toggles the view of the status bar. If it is; selected, the status bar below the canvas window shows up. There; the identification of the objects is displayed when moving the; mouse (such as the object's name, the object's type, its; coordinates, etc.). - *Colors*: creates a new canvas showing the color palette. - *Markers*: creates a new canvas showing the various marker styles. - *Iconify*: create the canvas window icon, does not close the; canvas. - *View With...*: If the last selected pad contains a 3-d structure,; a new canvas is created with a 3-D picture according to the; selection made from the cascaded menu: X3D or OpenGL. The 3-D; image can ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:8666,interface,interface,8666,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['interface'],['interface']
Integrability,"port Library, located in the; source at ``lib/Support`` and ``include/llvm/Support``. The library's purpose; is to shield LLVM from the differences between operating systems for the few; services LLVM needs from the operating system. Much of LLVM is written using; portability features of standard C++. However, in a few areas, system dependent; facilities are needed and the Support Library is the wrapper around those; system calls. By centralizing LLVM's use of operating system interfaces, we make it possible; for the LLVM tool chain and runtime libraries to be more easily ported to new; platforms since (theoretically) only ``lib/Support`` needs to be ported. This; library also unclutters the rest of LLVM from #ifdef use and special cases for; specific operating systems. Such uses are replaced with simple calls to the; interfaces provided in ``include/llvm/Support``. Note that the Support Library is not intended to be a complete operating system; wrapper (such as the Adaptive Communications Environment (ACE) or Apache; Portable Runtime (APR)), but only provides the functionality necessary to; support LLVM. The Support Library was originally referred to as the System Library, written; by Reid Spencer who formulated the design based on similar work originating; from the eXtensible Programming System (XPS). Several people helped with the; effort; especially, Jeff Cohen and Henrik Bach on the Win32 port. Keeping LLVM Portable; =====================. In order to keep LLVM portable, LLVM developers should adhere to a set of; portability rules associated with the Support Library. Adherence to these rules; should help the Support Library achieve its goal of shielding LLVM from the; variations in operating system interfaces and doing so efficiently. The; following sections define the rules needed to fulfill this objective. Don't Include System Headers; ----------------------------. Except in ``lib/Support``, no LLVM source code should directly ``#include`` a; system header. C",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:1080,wrap,wrapper,1080,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['wrap'],['wrapper']
Integrability,"port M;; import third_party_module;; int main() {; Hello();; World();; return 0;; }. And here is the compilation database:. .. code-block:: text. [; {; ""directory"": ""."",; ""command"": ""<path-to-compiler-executable>/clang++ -std=c++20 M.cppm -c -o M.o"",; ""file"": ""M.cppm"",; ""output"": ""M.o""; },; {; ""directory"": ""."",; ""command"": ""<path-to-compiler-executable>/clang++ -std=c++20 Impl.cpp -c -o Impl.o"",; ""file"": ""Impl.cpp"",; ""output"": ""Impl.o""; },; {; ""directory"": ""."",; ""command"": ""<path-to-compiler-executable>/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o"",; ""file"": ""impl_part.cppm"",; ""output"": ""impl_part.o""; },; {; ""directory"": ""."",; ""command"": ""<path-to-compiler-executable>/clang++ -std=c++20 interface_part.cppm -c -o interface_part.o"",; ""file"": ""interface_part.cppm"",; ""output"": ""interface_part.o""; },; {; ""directory"": ""."",; ""command"": ""<path-to-compiler-executable>/clang++ -std=c++20 User.cpp -c -o User.o"",; ""file"": ""User.cpp"",; ""output"": ""User.o""; }; ]. And we can get the dependency information in P1689 format by:. .. code-block:: console. $ clang-scan-deps -format=p1689 -compilation-database P1689.json. And we will get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""Impl.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ]; },; {; ""primary-output"": ""M.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; },; {; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ]; },; {; ""primary-output"": ""User.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; },; {; ""logical-name"": ""third_party_module""; }; ]; },; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:34815,depend,dependency,34815,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['depend'],['dependency']
Integrability,"port for folding control flow into faulting machine instructions. :doc:`Atomics`; Information about LLVM's concurrency model. :doc:`ExceptionHandling`; This document describes the design and implementation of exception handling; in LLVM. :doc:`Extensions`; LLVM-specific extensions to tools and formats LLVM seeks compatibility with. :doc:`HowToSetUpLLVMStyleRTTI`; How to make ``isa<>``, ``dyn_cast<>``, etc. available for clients of your; class hierarchy. :doc:`BlockFrequencyTerminology`; Provides information about terminology used in the ``BlockFrequencyInfo``; analysis pass. :doc:`BranchWeightMetadata`; Provides information about Branch Prediction Information. :doc:`GetElementPtr`; Answers to some very frequent questions about LLVM's most frequently; misunderstood instruction. :doc:`ScudoHardenedAllocator`; A library that implements a security-hardened `malloc()`. :doc:`MemTagSanitizer`; Security hardening for production code aiming to mitigate memory; related vulnerabilities. Based on the Armv8.5-A Memory Tagging Extension. :doc:`Dependence Graphs <DependenceGraphs/index>`; A description of the design of the various dependence graphs such as; the DDG (Data Dependence Graph). :doc:`SpeculativeLoadHardening`; A description of the Speculative Load Hardening mitigation for Spectre v1. :doc:`SegmentedStacks`; This document describes segmented stacks and how they are used in LLVM. :doc:`MarkedUpDisassembly`; This document describes the optional rich disassembly output syntax. :doc:`StackMaps`; LLVM support for mapping instruction addresses to the location of; values and allowing code to be patched. :doc:`Coroutines`; LLVM support for coroutines. :doc:`PointerAuth`; A description of pointer authentication, its LLVM IR representation, and its; support in the backend. :doc:`YamlIO`; A reference guide for using LLVM's YAML I/O library. :doc:`ConvergenceAndUniformity`; A description of uniformity analysis in the presence of irreducible; control flow, and its implementation.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst:4633,depend,dependence,4633,interpreter/llvm-project/llvm/docs/Reference.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst,1,['depend'],['dependence']
Integrability,"positive or/and; negative bin contents. ## Random Numbers and Histograms. **`TH1`**`::FillRandom()` can be used to randomly fill a histogram; using the contents of an existing **`TF1`** function or another; **`TH1`** histogram (for all dimensions). For example, the following; two statements create and fill a histogram 10 000 times with a default; Gaussian distribution of `mean` `0` and `sigma` `1` :. ``` {.cpp}; root[] TH1F h1(""h1"",""Histo from a Gaussian"",100,-3,3);; root[] h1.FillRandom(""gaus"",10000);; ```. **`TH1`**`::GetRandom()` can be used to get a random number; distributed according the contents of a histogram. To fill a histogram; following the distribution in an existing histogram you can use the; second signature of **`TH1`**`::FillRandom()`. Next code snipped; assumes that `h` is an existing histogram (**`TH1`** ). ``` {.cpp}; root[] TH1F h2(""h2"",""Histo from existing histo"",100,-3,3);; root[] h2.FillRandom(&h1, 1000);; ```. The distribution contained in the histogram `h1` ( **`TH1`** ) is; integrated over the channel contents. It is normalized to one. The; second parameter (1000) indicates how many random numbers are; generated. Getting 1 random number implies:. - Generating a random number between 0 and 1 (say `r1` ). - Find the bin in the normalized integral for `r1`. - Fill histogram channel. You can see below an example of the **`TH1`**`::GetRandom()` method; which can be used to get a random number distributed according; the contents of a histogram. ``` {.cpp}; void getrandomh() {; TH1F *source = new TH1F(""source"",""source hist"",100,-3,3);; source->FillRandom(""gaus"",1000);; TH1F *final = new TH1F(""final"",""final hist"",100,-3,3);. // continued... for (Int_t i=0;i<10000;i++) {; final->Fill(source->GetRandom());; }; TCanvas *c1 = new TCanvas(""c1"",""c1"",800,1000);; c1->Divide(1,2);; c1->cd(1);; source->Draw();; c1->cd(2);; final->Draw();; c1->cd();; }; ```. ## Adding, Dividing, and Multiplying. Many types of operations are supported on histograms or between;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:10222,integrat,integrated,10222,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['integrat'],['integrated']
Integrability,"ppyy.gbl.get_data(NDATA); >>> print(d); <cppyy.LowLevelView object at 0x1068cba30>; >>> d = cppyy.ll.cast['int*'](d); >>> d.reshape((NDATA,)); >>> print(list(d)); [0, 1, 2, 3]; >>>. * **C++-style casts**: Similar to the C-style cast, there are; ``ll.static_cast`` and ``ll.reinterpret_cast``.; There should never be a reason for a ``dynamic_cast``, since that only; applies to objects, for which auto-casting will work.; The syntax is ""template-style"", just like for the C-style cast above. .. _npcasts:. `NumPy casts`; -------------. The ``cppyy.LowLevelView`` type returned for pointers to basic types,; including for ``void*``, is a simple and light-weight view on memory, given a; pointer, type, and number of elements (or unchecked, if unknown).; It only supports basic operations such as indexing and iterations, but also; the buffer protocol for integration with full-fledged functional arrays such; as NumPy`s ``ndarray``. In addition, specifically when dealing with ``void*`` returns, you can use; NumPy's low-level ``frombuffer`` interface to perform the cast.; Example:. .. code-block:: python. >>> cppyy.cppdef(""""""; ... void* create_float_array(int sz) {; ... float* pf = (float*)malloc(sizeof(float)*sz);; ... for (int i = 0; i < sz; ++i) pf[i] = 2*i;; ... return pf;; ... }""""""); ...; >>> import numpy as np; >>> NDATA = 8; >>> arr = cppyy.gbl.create_float_array(NDATA); >>> print(arr); <cppyy.LowLevelView object at 0x109f15230>; >>> arr.reshape((NDATA,)) # adjust the llv's size; >>> v = np.frombuffer(arr, dtype=np.float32, count=NDATA) # cast to float; >>> print(len(v)); 8; >>> print(v); array([ 0., 2., 4., 6., 8., 10., 12., 14.], dtype=float32); >>>. Note that NumPy will internally check the total buffer size, so if the size; you are casting *to* is larger than the size you are casting *from*, then; the number of elements set in the ``reshape`` call needs to be adjusted; accordingly. `Capsules`; ----------. It is not possible to pass proxies from cppyy through function argu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst:5002,interface,interface,5002,bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,1,['interface'],['interface']
Integrability,"prAST - Expression class for function calls.; class CallExprAST : public ExprAST {; std::string Callee;; std::vector<std::unique_ptr<ExprAST>> Args;. public:; CallExprAST(const std::string &Callee,; std::vector<std::unique_ptr<ExprAST>> Args); : Callee(Callee), Args(std::move(Args)) {}; };. This is all (intentionally) rather straight-forward: variables capture; the variable name, binary operators capture their opcode (e.g. '+'), and; calls capture a function name as well as a list of any argument; expressions. One thing that is nice about our AST is that it captures; the language features without talking about the syntax of the language.; Note that there is no discussion about precedence of binary operators,; lexical structure, etc. For our basic language, these are all of the expression nodes we'll; define. Because it doesn't have conditional control flow, it isn't; Turing-complete; we'll fix that in a later installment. The two things; we need next are a way to talk about the interface to a function, and a; way to talk about functions themselves:. .. code-block:: c++. /// PrototypeAST - This class represents the ""prototype"" for a function,; /// which captures its name, and its argument names (thus implicitly the number; /// of arguments the function takes).; class PrototypeAST {; std::string Name;; std::vector<std::string> Args;. public:; PrototypeAST(const std::string &Name, std::vector<std::string> Args); : Name(Name), Args(std::move(Args)) {}. const std::string &getName() const { return Name; }; };. /// FunctionAST - This class represents a function definition itself.; class FunctionAST {; std::unique_ptr<PrototypeAST> Proto;; std::unique_ptr<ExprAST> Body;. public:; FunctionAST(std::unique_ptr<PrototypeAST> Proto,; std::unique_ptr<ExprAST> Body); : Proto(std::move(Proto)), Body(std::move(Body)) {}; };. In Kaleidoscope, functions are typed with just a count of their; arguments. Since all values are double precision floating point, the; type of each argument doe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:3969,interface,interface,3969,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['interface'],['interface']
Integrability,"precated and now returns -1; to indicate the index is unavailable.; * Methods in SBHostOS related to threads have had their implementations; removed. These methods will return a value indicating failure.; * ``SBType::FindDirectNestedType`` function is added. It's useful; for formatters to quickly find directly nested type when it's known; where to search for it, avoiding more expensive global search via; ``SBTarget::FindFirstType``.; * ``lldb-vscode`` was renamed to ``lldb-dap`` and and its installation; instructions have been updated to reflect this. The underlying functionality; remains unchanged.; * The ``mte_ctrl`` register can now be read from AArch64 Linux core files.; * LLDB on AArch64 Linux now supports debugging the Scalable Matrix Extension; (SME) and Scalable Matrix Extension 2 (SME2) for both live processes and core; files. For details refer to the; `AArch64 Linux documentation <https://lldb.llvm.org/use/aarch64-linux.html>`_.; * LLDB now supports symbol and binary acquisition automatically using the; DEBUFINFOD protocol. The standard mechanism of specifying DEBUFINOD servers in; the ``DEBUGINFOD_URLS`` environment variable is used by default. In addition,; users can specify servers to request symbols from using the LLDB setting; ``plugin.symbol-locator.debuginfod.server_urls``, override or adding to the; environment variable. * When running on AArch64 Linux, ``lldb-server`` now provides register; field information for the following registers: ``cpsr``, ``fpcr``,; ``fpsr``, ``svcr`` and ``mte_ctrl``. ::. (lldb) register read cpsr; cpsr = 0x80001000; = (N = 1, Z = 0, C = 0, V = 0, SS = 0, IL = 0, <...>. This is only available when ``lldb`` is built with XML support.; Where possible the CPU's capabilities are used to decide which; fields are present, however this is not always possible or entirely; accurate. If in doubt, refer to the numerical value. * On Windows, LLDB can now read the thread names. Changes to Sanitizers; ---------------------; * HWASan now",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:16581,protocol,protocol,16581,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,1,['protocol'],['protocol']
Integrability,"preceeding; minimization in the next step and change parameters in between; (fix/release/put limits on them, etc.). How M minimizations can be performed is shown in [example:main]. ### Direct usage of minimizers ###. Minimizers such as the VariableMetricMinimizer are designed as; state-less minimization engines, which means that they do not depend on; the current function and its parameters. Any $\mbox{FCN}$ function; can be minimized with the same minimizer. The interface is restricted to; minimization and no parameter interaction is possible. ### Using an application (MnMigrad) ###. MnMigrad uses the VariableMetricMinimizer for minimization but allows as; well for parameter interaction by the user. An instance of MnMigrad is; specific to the current $\mbox{FCN}$ and user parameters. Any; parameter interaction of the user between two minimization steps will; make use of the result of the preceeding minimization in an optimal way.; The interface for parameters (see [api:parameters], [api:covariance] and; [api:state]) is forwardedin MnMigrad. ### Subsequent minimizations ###. M takes care that all information is treated in an optimal and correct; way if the user interacts with the parameters between two minimizations.; MnMigrad retains the result of the last minimization and uses this as; input for the next step. Between two minimization requests to MnMigrad; the user can fix or release parameters, put limits on them or remove; limits from them. Each instance of a MnMigrad object maintains its own; state and one can have multiple instances of MnMigrad objects. ### M fails to find a minimum ###. If M fails to find a minimum, the user is notified by a warning message; issued by M when running into troubles. Problems can be:. - a bug in M. - an error in the $\mbox{FCN}$. - a highly difficult problem (usually strong correlations among; parameters). - floating–point precision. ## The output from minimization ##. ### The FunctionMinimum ###. The output of the minimizers is ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:34637,interface,interface,34637,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['interface'],['interface']
Integrability,"present an error condition in the tree!. Matcher<ObjCMessageExpr>hasSelectorstd::string BaseName; Matches when BaseName == Selector.getAsString(). matcher = objCMessageExpr(hasSelector(""loadHTMLString:baseURL:""));; matches the outer message expr in the code below, but NOT the message; invocation for self.bodyView.; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMessageExpr>hasUnarySelector; Matches when the selector is a Unary Selector. matcher = objCMessageExpr(matchesSelector(hasUnarySelector());; matches self.bodyView in the code below, but NOT the outer message; invocation of ""loadHTMLString:baseURL:"".; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMessageExpr>isClassMessage; Returns true when the Objective-C message is sent to a class. Example; matcher = objcMessageExpr(isClassMessage()); matches; [NSString stringWithFormat:@""format""];; but not; NSString *x = @""hello"";; [x containsString:@""h""];. Matcher<ObjCMessageExpr>isInstanceMessage; Returns true when the Objective-C message is sent to an instance. Example; matcher = objcMessageExpr(isInstanceMessage()); matches; NSString *x = @""hello"";; [x containsString:@""h""];; but not; [NSString stringWithFormat:@""format""];. Matcher<ObjCMessageExpr>matchesSelectorStringRef RegExp, Regex::RegexFlags Flags = NoFlags; Matches ObjC selectors whose name contains; a substring matched by the given RegExp.; matcher = objCMessageExpr(matchesSelector(""loadHTMLStringmatches the outer message expr in the code below, but NOT the message; invocation for self.bodyView.; [self.bodyView loadHTMLString:html baseURL:NULL];. If the matcher is used in clang-query, RegexFlags parameter; should be passed as a quoted string. e.g: ""NoFlags"".; Flags can be combined with '|' example ""IgnoreCase | BasicRegex"". Matcher<ObjCMessageExpr>numSelectorArgsunsigned N; Matches when the selector has the specified number of arguments. matcher = objCMessageExpr(numSelectorArgs(0));; matches self.bodyView in the code below. match",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:107573,message,message,107573,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['message'],['message']
Integrability,pressions in initialization odr-use; Not resolved. 2445; C++20; Partial ordering with rewritten candidates; Unknown. 2446; C++20; Questionable type-dependency of concept-ids; Unknown. 2447; C++20; Unintended description of abbreviated function templates; Unknown. 2448; CD6; Cv-qualification of arithmetic types and deprecation of volatile; Unknown. 2449; extension; Thunks as an implementation technique for pointers to virtual functions; Extension. 2450; review; braced-init-list as a template-argument; Clang 18. 2451; C++23; promise.unhandled_exception() and final suspend point; Unknown. 2452; CD6; Flowing off the end of a coroutine; Unknown. 2453; NAD; Deduced return types and coroutine lambdas; Unknown. 2454; NAD; Tail recursion and coroutine symmetric transfer; Unknown. 2455; CD6; Concatenation of string literals vs translation phases 5 and 6; Unknown. 2456; open; Viable user-defined conversions in converted constant expressions; Not resolved. 2457; CD6; Unexpanded parameter packs don't make a function type dependent; Unknown. 2458; CD6; Value category of expressions denoting non-static member functions; Unknown. 2459; drafting; Template parameter initialization; Clang 18. 2460; CD6; C language linkage and constrained non-template friends; Unknown. 2461; CD6; Diagnosing non-bool type constraints; Unknown. 2462; drafting; Problems with the omission of the typename keyword; Not resolved. 2463; open; Trivial copyability and unions with non-trivial members; Not resolved. 2464; CD6; Constexpr launder and unions; Unknown. 2465; CD6; Coroutine parameters passed to a promise constructor; Unknown. 2466; CD6; co_await should be a single evaluation; Unknown. 2467; drafting; CTAD for alias templates and the deducible check; Not resolved. 2468; drafting; Omission of the typename keyword in a member template parameter list; Not resolved. 2469; drafting; Implicit object creation vs constant expressions; Not resolved. 2470; CD6; Multiple array objects providing storage for one obje,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:168309,depend,dependent,168309,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['depend'],['dependent']
Integrability,"profitable to emit these directly in the language frontend. This item; explicitly includes the use of the :ref:`overflow intrinsics <int_overflow>`. #. Avoid using the :ref:`assume intrinsic <int_assume>` until you've; established that a) there's no other way to express the given fact and b); that fact is critical for optimization purposes. Assumes are a great; prototyping mechanism, but they can have negative effects on both compile; time and optimization effectiveness. The former is fixable with enough; effort, but the later is fairly fundamental to their designed purpose. Describing Language Specific Properties; =======================================. When translating a source language to LLVM, finding ways to express concepts; and guarantees available in your source language which are not natively; provided by LLVM IR will greatly improve LLVM's ability to optimize your code.; As an example, C/C++'s ability to mark every add as ""no signed wrap (nsw)"" goes; a long way to assisting the optimizer in reasoning about loop induction; variables and thus generating more optimal code for loops. The LLVM LangRef includes a number of mechanisms for annotating the IR with; additional semantic information. It is *strongly* recommended that you become; highly familiar with this document. The list below is intended to highlight a; couple of items of particular interest, but is by no means exhaustive. Restricted Operation Semantics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; #. Add nsw/nuw flags as appropriate. Reasoning about overflow is; generally hard for an optimizer so providing these facts from the frontend; can be very impactful. #. Use fast-math flags on floating point operations if legal. If you don't; need strict IEEE floating point semantics, there are a number of additional; optimizations that can be performed. This can be highly impactful for; floating point intensive computations. Describing Aliasing Properties; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. #. Add noalias/align/dereferen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst:10173,wrap,wrap,10173,interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst,1,['wrap'],['wrap']
Integrability,"prompt another way is to link with the; ROOT libraries and make the ROOT classes available in your own program. Here is a short description of the most relevant libraries, the ones; marked with a \* are only installed when the options specified them. - `libAsImage` is the image manipulation library. - `libCling` is the C++ interpreter (Cling). - `libCore` is the Base classes. - `libEG` is the abstract event generator interface classes. - \*`libEGPythia` is the Pythia5 event generator interface. - \*`libEGPythia6` is the Pythia6 event generator interface. - `libFitPanel` contains the GUI used for fitting. - `libGed` contains the GUI used for editing the properties of; histograms, graphs, etc. - `libGeom` is the geometry package (with builder and painter). - `libGpad` is the pad and canvas classes which depend on low level; graphics. - `libGraf` is the 2D graphics primitives (can be used independent; of libGpad). - `libGraf3d` is the 3D graphics primitives. - `libGui` is the GUI classes (depend on low level graphics). - `libGuiBld` is the GUI designer. - `libGuiHtml` contains the embedded HTML browser. - `libGX11` is the low level graphics interface to the X11 system. - \*`libGX11TTF` is an add-on library to libGX11 providing TrueType; fonts. - `libHbook` is for interface ROOT - HBOOK. - `libHist` is the histogram classes (with accompanying painter; library). - `libHtml` is the HTML documentation generation system. - `libMatrix` is the matrix and vector manipulation. - `libMathCore` contains the core mathematics and physics vector; classes. - `libMathMore` contains additional functions, interfacing the GSL; math library. - `libMinuit` is the MINUIT fitter. - `libNet` contains functionality related to network transfer. - `libNew` is the special global new/delete, provides extra memory; checking and interface for shared memory (optional). - `libPhysics` contains the legacy physics classes (TLorentzVector,; etc.). - `libPostscript` is the PostScript interface. - `libProo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:14102,depend,depend,14102,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['depend'],['depend']
Integrability,"ps://git.llvm.org/git/compiler-rt.git) will continue to; be maintained. Read/write SVN bridge; ^^^^^^^^^^^^^^^^^^^^^. GitHub supports a read/write SVN bridge for its repositories. However,; there have been issues with this bridge working correctly in the past,; so it's not clear if this is something that will be supported going forward. Monorepo Drawbacks; ------------------. * Using the monolithic repository may add overhead for those contributing to a; standalone sub-project, particularly on runtimes like libcxx and compiler-rt; that don't rely on LLVM; currently, a fresh clone of libcxx is only 15MB (vs.; 1GB for the monorepo), and the commit rate of LLVM may cause more frequent; `git push` collisions when upstreaming. Affected contributors may be able to; use the SVN bridge or the single-subproject Git mirrors. However, it's; undecided if these projects will continue to be maintained.; * Using the monolithic repository may add overhead for those *integrating* a; standalone sub-project, even if they aren't contributing to it, due to the; same disk space concern as the point above. The availability of the; sub-project Git mirrors would addresses this.; * Preservation of the existing read/write SVN-based workflows relies on the; GitHub SVN bridge, which is an extra dependency. Maintaining this locks us; into GitHub and could restrict future workflow changes. Workflows; ^^^^^^^^^. * :ref:`Checkout/Clone a Single Project, without Commit Access <workflow-checkout-commit>`.; * :ref:`Checkout/Clone Multiple Projects, with Commit Access <workflow-monocheckout-multicommit>`.; * :ref:`Commit an API Change in LLVM and Update the Sub-projects <workflow-cross-repo-commit>`.; * :ref:`Branching/Stashing/Updating for Local Development or Experiments <workflow-mono-branching>`.; * :ref:`Bisecting <workflow-mono-bisecting>`. Workflow Before/After; =====================. This section goes through a few examples of workflows, intended to illustrate; how end-users or developers would ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:11651,integrat,integrating,11651,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['integrat'],['integrating']
Integrability,"ps://github.com/llvm/llvm-project/pull/72627>`_,; `#71518 <https://github.com/llvm/llvm-project/pull/71518>`_,; `#72016 <https://github.com/llvm/llvm-project/pull/72016>`_,; `#70540 <https://github.com/llvm/llvm-project/pull/70540>`_,; `#73638 <https://github.com/llvm/llvm-project/pull/73638>`_,; `#77331 <https://github.com/llvm/llvm-project/pull/77331>`_). - The ``alpha.security.taint.TaintPropagation`` checker no longer propagates; taint on ``strlen`` and ``strnlen`` calls, unless these are marked; explicitly propagators in the user-provided taint configuration file.; This removal empirically reduces the number of false positive reports.; Read the PR for the details.; (`#66086 <https://github.com/llvm/llvm-project/pull/66086>`_). - Other taint-related improvements.; (`#66358 <https://github.com/llvm/llvm-project/pull/66358>`_,; `#66074 <https://github.com/llvm/llvm-project/pull/66074>`_,; `#66358 <https://github.com/llvm/llvm-project/pull/66358>`_). - Checkers can query constraint bounds to improve diagnostic messages.; (`#74141 <https://github.com/llvm/llvm-project/pull/74141>`_). - Improved the generated initializers for modules. Now the calls to initialize; functions from imported module units can be omitted if the initialize; function is known to be empty.; (`#56794 <https://github.com/llvm/llvm-project/issues/56794>`_). - Clang now allow to export declarations within linkage-specification.; (`#71347 <https://github.com/llvm/llvm-project/issues/71347>`_). Moved checkers; ^^^^^^^^^^^^^^. - Move checker ``alpha.unix.Errno`` out of the ``alpha`` package; to ``unix.Errno``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#unix-errno-c>`__. - Move checker ``alpha.unix.StdCLibraryFunctions`` out of the ``alpha`` package; to ``unix.StdCLibraryFunctions``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#unix-stdclibraryfunctions-c>`__. - Move checker ``alpha.security.cert.env.InvalidPtr`` out of the ``alpha``; package to ``securit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:76073,message,messages,76073,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['message'],['messages']
Integrability,"ps[i]; // tool tip text; t[i].fStayDown = kFALSE; // button behavior if clicked; t[i].fId = i+1; // button id; t[i].fButton = NULL; // button pointer. if (strlen(xpms[i]) == 0) {; separator = 5;; continue;; }; tb->AddButton(fMain,&t[i],separator);; separator = 0;; }; // adding the tool bar to the main frame; fMain->AddFrame(tb, new TGLayoutHints(kLHintsTop|kLHintsExpandX));. // adding a horizontal line as a separator; TGHorizontal3DLine *lh = new TGHorizontal3DLine(fMain);; fMain->AddFrame(lh, new TGLayoutHints(kLHintsTop|kLHintsExpandX));; ```. To have a tool bar in your application you do not need to do anything; special - only to create objects: a tool bar and its picture buttons.; This sample code creates the following three toolbar buttons:. ![](pictures/03000218.png). First we need to complete a `ToolBarData_t` structure for each tool bar; button before adding it to the tool bar. This structure contains:. - the icon file name ""`filename.xpm`"". - the tool tip text - a short help message explaining the button; purpose. - the Boolean variable defining the button behavior when is clicked. - `kFALSE` - do not stay down. - `kTRUE` - to stay down. - the button ID. - the button pointer (**`TGButton *`**) - should be `NULL`. We create an array `*xpms[]` containing the icon file names that will be; used for a picture button creation. If you write only the file names; here ROOT will search these files in `$ROOTSYS/icons` directory. If the; icon files are not there, you should provide the full path name also.; The array `*tips[] `contains the tool tip texts for buttons. The integer; variable separator is used to set the distance between two groups of; toolbar buttons. It defines the amount of pixels to the left for each; button. We create a tool bar object and add the buttons using the `AddButton`; method. The variable separator helps us to define no space between the; buttons in a group (0), and 5 pixels extra-space before and after. All; buttons added via this method wil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:76229,message,message,76229,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['message'],['message']
Integrability,"ption in constructor:; new THttpServer(""http:8080?loopback""); or in clear text specify IP address to which http socket should be bind:; new THttpServer(""http:127.0.0.1:8080""); If host has several network interfaces, one could select one for binding:; new THttpServer(""http:192.168.1.17:8080""). ### TNetXNGFileStager; Fixed ROOT-7703. This restores the behavior of Locate() to that found with; TXNetFileStager: Rather than return only the xrootd server's reply, the endpoint; hostname is looked up and Locate() returns the full url, including the path. ### TWebFile; Fixed ROOT-7809. Returns an error for a redirect which does not specify the new; URI, rather than going into a loop. Fixed ROOT-7817. Avoid a crash under some circumstances when trying to open an; invalid path. ## GUI Libraries. ## Montecarlo Libraries. ## Multi-processing. With this version we introduce a new module, core/multiproc, for multi-processing on multi-core machines. This module is based on fork technology and offers an interface inspired from Python multiprocessor module. The new interface, implemented in the class TProcPool, provides the possibility to perform in parallel a very generic set of tasks, described by macros, functions or lambdas. This illustrates the usage of lambdas:. ``` {.cpp}; {; TProcPool pool;; auto ten = pool.MapReduce([]() { return 1; }, 10, [](std::vector<int> v) { return std::accumulate(v.begin(), v.end(), 0); }); }; ```. And this how it can be used to generate ten histos and merge them:. ``` {.cpp}; {; TObject *CreateAndFillHists(); {. TH1F *h = new TH1F(""h"", """", 100, -3., 3.);; h->SetDirectory(0);; h->FillRandom(""gaus"", 1000);; return h;; }. TProcPool pool;; auto hist = pool.MapReduce(CreateAndFillHists, 10, PoolUtils::ReduceObjects);; hist->DrawClone();; }; ```. Tutorials illustrating other usages of the new class TProcPool are available under tutorials/multicore. ## Language Bindings. ### Notebooks; We provided integration of ROOT with the Jupyter technology, integrating ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:21156,interface,interface,21156,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['interface'],['interface']
Integrability,"ptor objectForKey:@""PhotoCount""];; // Warning: Comparing a pointer value of type 'NSNumber *'; // to a scalar integer value; if (photoCount > 0) {; [self displayPhotos];; }. .. _osx-ObjCProperty:. osx.ObjCProperty (ObjC); """"""""""""""""""""""""""""""""""""""""""""""; Check for proper uses of Objective-C properties. .. code-block:: objc. NSNumber *photoCount = [albumDescriptor objectForKey:@""PhotoCount""];; // Warning: Comparing a pointer value of type 'NSNumber *'; // to a scalar integer value; if (photoCount > 0) {; [self displayPhotos];; }. .. _osx-SecKeychainAPI:. osx.SecKeychainAPI (C); """"""""""""""""""""""""""""""""""""""""""""; Check for proper uses of Secure Keychain APIs. .. literalinclude:: checkers/seckeychainapi_example.m; :language: objc. .. _osx-cocoa-AtSync:. osx.cocoa.AtSync (ObjC); """"""""""""""""""""""""""""""""""""""""""""""; Check for nil pointers used as mutexes for @synchronized. .. code-block:: objc. void test(id x) {; if (!x); @synchronized(x) {} // warn: nil value used as mutex; }. void test() {; id y;; @synchronized(y) {} // warn: uninitialized value used as mutex; }. .. _osx-cocoa-AutoreleaseWrite:. osx.cocoa.AutoreleaseWrite; """"""""""""""""""""""""""""""""""""""""""""""""""""; Warn about potentially crashing writes to autoreleasing objects from different autoreleasing pools in Objective-C. .. _osx-cocoa-ClassRelease:. osx.cocoa.ClassRelease (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for sending 'retain', 'release', or 'autorelease' directly to a Class. .. code-block:: objc. @interface MyClass : NSObject; @end. void test(void) {; [MyClass release]; // warn; }. .. _osx-cocoa-Dealloc:. osx.cocoa.Dealloc (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C classes that lack a correct implementation of -dealloc. .. literalinclude:: checkers/dealloc_example.m; :language: objc. .. _osx-cocoa-IncompatibleMethodTypes:. osx.cocoa.IncompatibleMethodTypes (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C method signatures with type incompatibilities. .. code-block:: objc. @interface MyClass1 : NSObject; - (int",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:36284,synchroniz,synchronized,36284,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['synchroniz'],['synchronized']
Integrability,"putation history depends; on that value. .. admonition:: Rationale. The intent of the second rule is to say that objects held in normal; ``__strong`` local variables may be released as soon as the value in; the variable is no longer being used: either the variable stops; being used completely or a new value is stored in the variable. The intent of the third rule is to say that return values may be; released after they've been used. A computation history depends on a pointer value ``P`` if it:. * performs a pointer comparison with ``P``,; * loads from ``P``,; * stores to ``P``,; * depends on a pointer value ``Q`` derived via pointer arithmetic; from ``P`` (including an instance-variable or field access), or; * depends on a pointer value ``Q`` loaded from ``P``. Dependency applies only to values derived directly or indirectly from; a particular expression result and does not occur merely because a; separate pointer value dynamically aliases ``P``. Furthermore, this; dependency is not carried by values that are stored to objects. .. admonition:: Rationale. The restrictions on dependency are intended to make this analysis; feasible by an optimizer with only incomplete information about a; program. Essentially, dependence is carried to ""obvious"" uses of a; pointer. Merely passing a pointer argument to a function does not; itself cause dependence, but since generally the optimizer will not; be able to prove that the function doesn't depend on that parameter,; it will be forced to conservatively assume it does. Dependency propagates to values loaded from a pointer because those; values might be invalidated by deallocating the object. For; example, given the code ``__strong id x = p->ivar;``, ARC must not; move the release of ``p`` to between the load of ``p->ivar`` and the; retain of that value for storing into ``x``. Dependency does not propagate through stores of dependent pointer; values because doing so would allow dependency to outlive the; full-expression which produc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:80353,depend,dependency,80353,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['depend'],['dependency']
Integrability,"puting resources. ROOT provides a very efficient storage system for data models, ; that demonstrated to scale at the Large Hadron Collider experiments: Exabytes ; of scientific data are written in columnar ROOT format.; ROOT comes with histogramming capabilities in an arbitrary number of ; dimensions, curve fitting, statistical modelling, minimization, to allow; the easy setup of a data analysis system that can query and process the data; interactively or in batch mode, as well as a general parallel processing; framework, RDataFrame, that can considerably speed up an analysis, taking ; full advantage of multi-core and distributed systems. ROOT is performance critical software written in C++ and enables rapid prototyping ; powered by a unique C++ compliant interpreter called Cling. ; Cling also enables performant C++ type introspection which is a building block of automatic ; interoperability with Python. Thanks to PyROOT, leveraging the cppyy technology, ; ROOT offers efficient, on-demand C++/Python interoperability in a uniform cross-language ; execution environment. ROOT fully embraces open-source, it's made with passion by its community,; for the benefit of its community. [![License: LGPL v2.1+](https://img.shields.io/badge/License-LGPL%20v2.1+-blue.svg)](https://www.gnu.org/licenses/lgpl.html); [![CII Best Practices](https://bestpractices.coreinfrastructure.org/projects/5060/badge)](https://bestpractices.coreinfrastructure.org/projects/5060). ## Contribution Guidelines; - [How to contribute](https://github.com/root-project/root/blob/master/CONTRIBUTING.md); - [Coding conventions](https://root.cern/coding-conventions); - [Meetings](https://root.cern/meetings). ## Cite; When citing ROOT, please use both the reference reported below and the DOI specific to your ROOT version available [on Zenodo](https://zenodo.org/badge/latestdoi/10994345) [![DOI](https://zenodo.org/badge/10994345.svg)](https://zenodo.org/badge/latestdoi/10994345). For example, you can copy-paste an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README.md:1569,interoperab,interoperability,1569,README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README.md,1,['interoperab'],['interoperability']
Integrability,"py RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} tmva/pytorch/*.py); list(APPEND pyveto ${tmva_veto_py}); endif(); # disable PyTorch model file used by TMVA_CNN_Classification.C; list(APPEND pyveto tmva/PyTorch_Generate_CNN_Model.py). if(NOT ROOT_geom_FOUND); list(APPEND pyveto pyroot/geometry.py); endif(). # Now glob all vetos for pyroot; file(GLOB pyveto RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} ${pyveto}). list(LENGTH pytutorials nTotal); # Apply global .C/.py veto from above:; list(REMOVE_ITEM pytutorials ${tutorials_veto}); list(REMOVE_ITEM pytutorials ${pyveto}); list(LENGTH pytutorials nAfterVeto). message(STATUS ""${nAfterVeto}/${nTotal} python tutorials have been activated.""). #---Python tutorials dependencies--------------------------------------; set(pyroot-ntuple1-depends tutorial-pyroot-hsimple-py); set(pyroot-h1ReadAndDraw-depends tutorial-pyroot-hsimple-py); set(pyroot-benchmarks-depends tutorial-pyroot-hsimple-py; tutorial-pyroot-fit1-py; tutorial-pyroot-na49view-py; tutorial-pyroot-h1ReadAndDraw-py; tutorial-pyroot-ntuple1-py); set(pyroot-fit1-depends tutorial-hist-fillrandom-py); set(pyroot-na49view-depends tutorial-pyroot-geometry-py); set(roofit-rf503_wspaceread-depends tutorial-roofit-rf502_wspacewrite-py); set(roofit-rf618_mixture_models-depends tutorial-dataframe-df106_HiggsToFourLeptons-py). # Avoid a race condition: make sure Python tutorial is run after C++ tutorial; set(roofit-rf104_classfactory-depends tutorial-roofit-rf104_classfactory); set(roofit-rf512_wsfactory_oper-depends tutorial-roofit-rf512_wsfactory_oper); set (tmva-TMVA_Higgs_Classification-depends tutorial-tmva-TMVA_Higgs_Classification); set (tmva-TMVA_CNN_Classification-depends tutorial-tmva-TMVA_CNN_Classification); set (tmva-TMVA_RNN_Classification-depends tutorial-tmva-TMVA_RNN_Classification). #----------------------------------------------------------------------; # List requirements for python tutorials.; # To add a new requirement, add a glob expression that's named requires_<packag",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt:30804,depend,dependencies,30804,tutorials/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt,8,['depend'],"['dependencies', 'depends']"
Integrability,py generatePyTorchModelMulticlass.py COPYONLY); configure_file(generatePyTorchModelRegression.py generatePyTorchModelRegression.py COPYONLY); configure_file(generatePyTorchModels.py generatePyTorchModels.py COPYONLY); # Test PyTorch: Binary classification. if (PY_SKLEARN_FOUND); set(PyMVA-Torch-Classification-depends PyMVA-AdaBoost-Classification); set(PyMVA-Torch-Multiclass-depends PyMVA-AdaBoost-Multiclass); endif(). ROOT_EXECUTABLE(testPyTorchClassification testPyTorchClassification.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-Torch-Classification COMMAND testPyTorchClassification DEPENDS ${PyMVA-Torch-Classification-depends}). # Test PyTorch: Regression; ROOT_EXECUTABLE(testPyTorchRegression testPyTorchRegression.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-Torch-Regression COMMAND testPyTorchRegression). # Test PyTorch: Multi-class classification; ROOT_EXECUTABLE(testPyTorchMulticlass testPyTorchMulticlass.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-Torch-Multiclass COMMAND testPyTorchMulticlass DEPENDS ${PyMVA-Torch-Multiclass-depends}). # Test RModelParser_PyTorch. ROOT_ADD_GTEST(TestRModelParserPyTorch TestRModelParserPyTorch.C; LIBRARIES; ROOTTMVASofie; TMVA; Python3::NumPy; Python3::Python; INCLUDE_DIRS; SYSTEM; ${CMAKE_CURRENT_BINARY_DIR}; ); target_link_libraries(TestRModelParserPyTorch ${BLAS_LINKER_FLAGS} ${BLAS_LIBRARIES}). endif(PY_TORCH_FOUND). if((PY_KERAS_FOUND AND PY_THEANO_FOUND) OR (PY_KERAS_FOUND AND PY_TENSORFLOW_FOUND)); configure_file(generateKerasModels.py generateKerasModels.py COPYONLY); configure_file(scale_by_2_op.hxx scale_by_2_op.hxx COPYONLY). if (PY_TORCH_FOUND); set(PyMVA-Keras-Classification-depends PyMVA-Torch-Classification); set(PyMVA-Keras-Regression-depends PyMVA-Torch-Regression); set(PyMVA-Keras-Multiclass-depends PyMVA-Torch-Multiclass); endif(). # Test PyKeras: Binary classification; ROOT_EXECUTABLE(testPyKerasClassification testPyKerasClassification.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-Keras-Classif,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/test/CMakeLists.txt:3472,depend,depends,3472,tmva/pymva/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/test/CMakeLists.txt,3,"['DEPEND', 'depend']","['DEPENDS', 'depends']"
Integrability,"pyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ROOT_GENERATE_DICTIONARY(ElementStructDict ElementStruct.h LINKDEF ElementStructLinkDef.h OPTIONS -inlineInputHeader); ROOT_ADD_GTEST(testTOffsetGeneration TOffsetGeneration.cxx ElementStruct.cxx ElementStructDict.cxx; LIBRARIES RIO Tree MathCore; ); if(MSVC AND NOT CMAKE_GENERATOR MATCHES Ninja); add_custom_command(TARGET testTOffsetGeneration POST_BUILD; COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_BINARY_DIR}/libElementStructDict_rdict.pcm; ${CMAKE_CURRENT_BINARY_DIR}/$<CONFIG>/libElementStructDict_rdict.pcm); endif(); target_include_directories(testTOffsetGeneration PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}); ROOT_STANDARD_LIBRARY_PACKAGE(SillyStruct NO_INSTALL_HEADERS HEADERS ${CMAKE_CURRENT_SOURCE_DIR}/SillyStruct.h SOURCES SillyStruct.cxx LINKDEF SillyStructLinkDef.h DEPENDENCIES RIO); ROOT_ADD_GTEST(testBulkApi BulkApi.cxx LIBRARIES RIO Tree TreePlayer); #FIXME: tests are having timeout on 32bit CERN VM (in docker container everything is fine),; # to be reverted after investigation.; if(NOT CMAKE_SIZEOF_VOID_P EQUAL 4); ROOT_ADD_GTEST(testBulkApiMultiple BulkApiMultiple.cxx LIBRARIES RIO Tree TreePlayer TIMEOUT 3000); ROOT_ADD_GTEST(testBulkApiVarLength BulkApiVarLength.cxx LIBRARIES RIO Tree TreePlayer); ROOT_ADD_GTEST(testBulkApiSillyStruct BulkApiSillyStruct.cxx LIBRARIES RIO Tree TreePlayer SillyStruct); endif(); ROOT_ADD_GTEST(testTBasket TBasket.cxx LIBRARIES RIO Tree); ROOT_ADD_GTEST(testTBranch TBranch.cxx LIBRARIES RIO Tree MathCore); ROOT_ADD_GTEST(testTIOFeatures TIOFeatures.cxx LIBRARIES RIO Tree); ROOT_ADD_GTEST(testTTreeCluster TTreeClusterTest.cxx LIBRARIES RIO Tree MathCore); ROOT_ADD_GTEST(testTChainParsing TChainParsing.cxx LIBRARIES RIO Tree); if(imt); ROOT_ADD_GTEST(testTTreeImplicitMT ImplicitMT.cxx LIBRARIES RIO Tree); endif(); ROOT_ADD_GTEST(testTCha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/test/CMakeLists.txt:978,DEPEND,DEPENDENCIES,978,tree/tree/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/test/CMakeLists.txt,1,['DEPEND'],['DEPENDENCIES']
Integrability,python_module(theano QUIET); find_python_module(tensorflow QUIET); find_python_module(sklearn QUIET). if(PY_SKLEARN_FOUND); # Test PyRandomForest: Classification; ROOT_EXECUTABLE(testPyRandomForestClassification testPyRandomForestClassification.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-RandomForest-Classification COMMAND testPyRandomForestClassification). # Test PyRandomForest: Multi-class classification; ROOT_EXECUTABLE(testPyRandomForestMulticlass testPyRandomForestMulticlass.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-RandomForest-Multiclass COMMAND testPyRandomForestMulticlass). # Test PyGTB: Classification; ROOT_EXECUTABLE(testPyGTBClassification testPyGTBClassification.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-GTB-Classification COMMAND testPyGTBClassification DEPENDS PyMVA-RandomForest-Classification). # Test PyGTB: Multi-class classification; ROOT_EXECUTABLE(testPyGTBMulticlass testPyGTBMulticlass.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-GTB-Multiclass COMMAND testPyGTBMulticlass DEPENDS PyMVA-RandomForest-Multiclass). # Test PyAdaBoost: Classification; ROOT_EXECUTABLE(testPyAdaBoostClassification testPyAdaBoostClassification.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-AdaBoost-Classification COMMAND testPyAdaBoostClassification DEPENDS PyMVA-GTB-Classification). # Test PyAdaBoost: Multi-class classification; ROOT_EXECUTABLE(testPyAdaBoostMulticlass testPyAdaBoostMulticlass.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-AdaBoost-Multiclass COMMAND testPyAdaBoostMulticlass DEPENDS PyMVA-GTB-Multiclass). endif(PY_SKLEARN_FOUND). # Enable tests based on available python modules; if(PY_TORCH_FOUND); configure_file(generatePyTorchModelClassification.py generatePyTorchModelClassification.py COPYONLY); configure_file(generatePyTorchModelMulticlass.py generatePyTorchModelMulticlass.py COPYONLY); configure_file(generatePyTorchModelRegression.py generatePyTorchModelRegression.py COPYONLY); configure_file(generatePyTorchModels.py generatePyT,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/test/CMakeLists.txt:1632,DEPEND,DEPENDS,1632,tmva/pymva/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/test/CMakeLists.txt,1,['DEPEND'],['DEPENDS']
Integrability,"p}; gGeoManager->FindNode();; ```. In order to have more flexibility, there are in fact several alternative; ways of initializing a modeller state:. ``` {.cpp}; // Setting the point and finding the state in one step:; gGeoManager->FindNode(Double_t x,Double_t y,Double_t z);; gGeoManager->FindNode(Double_t *point[3]);; // Setting both initial point and direction and finding the state:; gGeoManager->InitTrack(Double_t x,Double_t y,Double_t z,; Double_t nx, Double_t ny, Double_t nz);; gGeoManager->InitTrack(Double_t *point[3],Double_t *dir[3]);; ```. Note that the current point coordinates can be changed and the state; re-initialized at any time. This represents the `‘Where am I?'`; geometrical query representing the basic navigation functionality; provided by the modeller. ### Checking the Current State. The current state and all variables related to this are essential during; tracking and have to be checked several times. Besides the current point; and direction, the following additional information can be retrieved; from **`TGeoManager`** interface:. - The `current path`. This represents a string containing the names; and copy numbers of all positioned objects in the current `branch`; written in the /folder/folder/.../folder/file fashion. The final node; pointed by the path is the deepest object containing the current; point and is representative for the current state. All intermediate; `folders` in the path are in fact also nodes ""touched"" by the; current point, but having some ""touched"" containment. The current; path can be retrieved only after the state was initialized and is; useful for getting an idea of the current point location. ``` {.cpp}; const char *path = gGeoManager->GetPath();; cout << ""Current path is: "" << path << endl;; /A_1/B_34/C_3/D_1; ```. - The `current node`***`, `***`volume` and `material`. In order to; take decisions on post-step or further stepping actions, one has to; know these. In order to get a pointer to the current node one can; do:. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:107502,interface,interface,107502,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['interface'],['interface']
Integrability,"qual to 9. This means the full; address can only be guaranteed to be less than `(1 << 31) + 9`. The OS may wish; to protect an extra page of the low address space to account for this. ##### Optimizations. A very large portion of the cost for this approach comes from checking loads in; this way, so it is important to work to optimize this. However, beyond making; the instruction sequences to *apply* the checks efficient (for example by; avoiding `pushfq` and `popfq` sequences), the only significant optimization is; to check fewer loads without introducing a vulnerability. We apply several; techniques to accomplish that. ###### Don't check loads from compile-time constant stack offsets. We implement this optimization on x86 by skipping the checking of loads which; use a fixed frame pointer offset. The result of this optimization is that patterns like reloading a spilled; register or accessing a global field don't get checked. This is a very; significant performance win. ###### Don't check dependent loads. A core part of why this mitigation strategy works is that it establishes a; data-flow check on the loaded address. However, this means that if the address; itself was already loaded using a checked load, there is no need to check a; dependent load provided it is within the same basic block as the checked load,; and therefore has no additional predicates guarding it. Consider code like the; following:; ```; ... .LBB0_4: # %danger; movq (%rcx), %rdi; movl (%rdi), %edx; ```. This will get transformed into:; ```; ... .LBB0_4: # %danger; cmovneq %r8, %rax # Conditionally update predicate state.; orq %rax, %rcx # Mask the pointer if misspeculating.; movq (%rcx), %rdi # Hardened load.; movl (%rdi), %edx # Unhardened load due to dependent addr.; ```. This doesn't check the load through `%rdi` as that pointer is dependent on a; checked load already. ###### Protect large, load-heavy blocks with a single lfence. It may be worth using a single `lfence` instruction at the start o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:35301,depend,dependent,35301,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['depend'],['dependent']
Integrability,"qualsBoundNode(""d"")))))); will trigger a match for each combination of variable declaration; and reference to that variable declaration within a compound statement. Matcher<QualType>hasLocalQualifiers; Matches QualType nodes that have local CV-qualifiers attached to; the node, not hidden within a typedef. Given; typedef const int const_int;; const_int i;; int *const j;; int *volatile k;; int m;; varDecl(hasType(hasLocalQualifiers())) matches only j and k.; i is const-qualified but the qualifier is not local. Matcher<QualType>isAnyCharacter; Matches QualType nodes that are of character type. Given; void a(char);; void b(wchar_t);; void c(double);; functionDecl(hasAnyParameter(hasType(isAnyCharacter()))); matches ""a(char)"", ""b(wchar_t)"", but not ""c(double)"". Matcher<QualType>isAnyPointer; Matches QualType nodes that are of any pointer type; this includes; the Objective-C object pointer type, which is different despite being; syntactically similar. Given; int *i = nullptr;. @interface Foo; @end; Foo *f;. int j;; varDecl(hasType(isAnyPointer())); matches ""int *i"" and ""Foo *f"", but not ""int j"". Matcher<QualType>isConstQualified; Matches QualType nodes that are const-qualified, i.e., that; include ""top-level"" const. Given; void a(int);; void b(int const);; void c(const int);; void d(const int*);; void e(int const) {};; functionDecl(hasAnyParameter(hasType(isConstQualified()))); matches ""void b(int const)"", ""void c(const int)"" and; ""void e(int const) {}"". It does not match d as there; is no top-level const on the parameter type ""const int *"". Matcher<QualType>isInteger; Matches QualType nodes that are of integer type. Given; void a(int);; void b(long);; void c(double);; functionDecl(hasAnyParameter(hasType(isInteger()))); matches ""a(int)"", ""b(long)"", but not ""c(double)"". Matcher<QualType>isSignedInteger; Matches QualType nodes that are of signed integer type. Given; void a(int);; void b(unsigned long);; void c(double);; functionDecl(hasAnyParameter(hasType(isSignedInteger()",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:112498,interface,interface,112498,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['interface'],['interface']
Integrability,"quests and Force Pushes; ---------------------------------------; In general, you should avoid rebasing a Pull Request and force pushing to the; branch that's the root of the Pull Request during the review. This action will; make the context of the old changes and comments harder to find and read. Sometimes, a rebase might be needed to update your branch with a fix for a test; or in some dependent code. After your PR is reviewed and accepted, you want to rebase your branch to ensure; you won't encounter merge conflicts when landing the PR. Landing your change; -------------------; When your PR has been accepted you can use the web interface to land your change.; If you have created multiple commits to address feedback at this point you need; to consolidate those commits into one commit. There are two different ways to; do this:. `Interactive rebase <https://git-scm.com/docs/git-rebase#_interactive_mode>`_; with fixup's. This is the recommended method since you can control the final; commit message and inspect that the final commit looks as you expect. When; your local state is correct, remember to force-push to your branch and press; the merge button afterwards. Use the button `Squash and merge` in GitHub's web interface, if you do this; remember to review the commit message when prompted. Afterwards you can select the option `Delete branch` to delete the branch; from your fork. You can also merge via the CLI by switching to your branch locally and run:. ::. gh pr merge --squash --delete-branch. If you observe an error message from the above informing you that your pull; request is not mergeable, then that is likely because upstream has been; modified since your pull request was authored in a way that now results in a; merge conflict. You must first resolve this merge conflict in order to merge; your pull request. In order to do that:. ::. git fetch upstream; git rebase upstream/main. Then fix the source files causing merge conflicts and make sure to rebuild and; re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst:5219,message,message,5219,interpreter/llvm-project/llvm/docs/GitHub.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst,1,['message'],['message']
Integrability,"quickly create and store (compiled) models; workspace CINT interface to easily access contents in a typesafe way; new adaptive ND numeric integration technique to normalize arbitrary p.d.f. in fast; and reliable way; new adaptive TFoam sampling technique to efficiently generate toy MC data from strongly; peaked datasets; parallel processing in likelihood construction and use of profile likelihood operator; to represent profile likelihoods as regular RooFit functions. void demo(); {; // Construct compiled 2-D model that requires numeric integration for normalization; RooWorkspace w(""w"",1) ;; w.factory(""CEXPR::model('1/((x-a)*(x-a)+0.001)+1/((y-b)*(y-b)+0.001)',x[-1,1],y[-1,1],a[-5,5],b[-5,5])"") ;. // Generate data from model (using TFoam adaptive sampling algorithm); RooDataSet* d = w::model.generate(RooArgSet(w::x,w::y),1000) ;; w::model.fitTo(*d) ;. // Make 2D plot on (x,y); TH2* hh = w::model.createHistogram(""x,y"",40,40) ;; hh->SetLineColor(kBlue) ;. // Make Projection on x (integrate over y); RooPlot* framex = w::x.frame(Title(""Data and p.d.f. projected on X"")) ;; d->plotOn(framex) ;; w::model.plotOn(framex) ;. // Construct likelihood, profile likelihood in a, and draw the latter; RooAbsReal* nll = w::model.createNLL(*d,NumCPU(2)) ;; RooAbsReal* pll = nll->createProfile(w::a) ;; RooPlot* framea = w::a.frame(Title(""Profile likelihood in parameter a"")) ;; pll->plotOn(framea) ;. // Construct 2D cumulative distribution function from p.d.f.; RooAbsReal* cdfxy = w::model.createCdf(RooArgSet(w::x,w::y),ScanNoCdf()) ;; TH2* hhcdf = cdfxy->createHistogram(""x,y"",40,40) ;; hhcdf->SetLineColor(kRed) ;. TCanvas* c = new TCanvas(""c"",""c"",650,650) ; c->Divide(2,2) ;; c->cd(1) ; hh->Draw(""surf"") ; c->cd(2) ; framex->Draw() ;; c->cd(3) ; framea->Draw() ; c->cd(4) ; hhcdf->Draw(""surf"") ;; }. Plot that results from above macro. Miscellaneous small improvements. Utility function bindFunction() and bindPdf that can bind; external C++ functions as RooFit functions or p.d.f.s now can al",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:22944,integrat,integrate,22944,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,2,['integrat'],['integrate']
Integrability,"r ""pad""; instructions is described in the; `Windows exception handling documentation\ <ExceptionHandling.html#wineh>`_. When a ``catchpad`` has been ""entered"" but not yet ""exited"" (as; described in the `EH documentation\ <ExceptionHandling.html#wineh-constraints>`_),; it is undefined behavior to execute a :ref:`call <i_call>` or :ref:`invoke <i_invoke>`; that does not carry an appropriate :ref:`""funclet"" bundle <ob_funclet>`. Example:; """""""""""""""". .. code-block:: text. dispatch:; %cs = catchswitch within none [label %handler0] unwind to caller; ;; A catch block which can catch an integer.; handler0:; %tok = catchpad within %cs [ptr @_ZTIi]. .. _i_cleanuppad:. '``cleanuppad``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <resultval> = cleanuppad within <parent> [<args>*]. Overview:; """""""""""""""""". The '``cleanuppad``' instruction is used by `LLVM's exception handling; system <ExceptionHandling.html#overview>`_ to specify that a basic block; is a cleanup block --- one where a personality routine attempts to; transfer control to run cleanup actions.; The ``args`` correspond to whatever additional; information the :ref:`personality function <personalityfn>` requires to; execute the cleanup.; The ``resultval`` has the type :ref:`token <t_token>` and is used to; match the ``cleanuppad`` to corresponding :ref:`cleanuprets <i_cleanupret>`.; The ``parent`` argument is the token of the funclet that contains the; ``cleanuppad`` instruction. If the ``cleanuppad`` is not inside a funclet,; this operand may be the token ``none``. Arguments:; """""""""""""""""""". The instruction takes a list of arbitrary values which are interpreted; by the :ref:`personality function <personalityfn>`. Semantics:; """""""""""""""""""". When the call stack is being unwound due to an exception being thrown,; the :ref:`personality function <personalityfn>` transfers control to the; ``cleanuppad`` with the aid of the personality-specific arguments.; As with calling conventions, how the personality functio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:486035,rout,routine,486035,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['rout'],['routine']
Integrability,"r (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler is extremely compatible with GAS, but there are a couple of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific example is that the assembler rejects ambiguous X86 instructions; that don't have suffixes. For example:. asm(""add %al, (%rax)"");; asm(""addw $4, (%rax)"");; asm(""add $4, (%rax)"");. Both clang and GAS accept the first instruction: because the first; instruction uses the 8-bit %al register as an operand, it is clear that; it is an 8-bit add. The second instruction is accepted by both because the ""w""; suffix indicates that it is a 16-bit add. The last instruction is accepted by; GAS even though there is nothing that specifies the size of the instruction (and; the assembler randomly picks a 32-bit add). Because it is ambiguous, Clang; rejects the instruction with this error message:. <inline asm>:3:1: error: ambiguous instructions require an explicit suffix (could be 'addb', 'addw', 'addl', or 'addq'); add $4, (%rax); ^. To fix this compatibility issue, add an explicit suffix to the instruction:; this makes your code more clear and is compatible with both GCC and Clang. Objective-C compatibility. Cast of super. GCC treats the super identifier as an expression that; can, among other things, be cast to a different type. Clang treats; super as a context-sensitive keyword, and will reject a; type-cast of super:. super.m:11:12: error: cannot cast 'super' (it isn't an expression); [(Super*)super add:4];; ~~~~~~~~^. To fix this problem, remove the type cast, e.g. [super add:4];. Size of interfaces. When using the ""non-fragile"" Objective-C ABI in use, the size of an; Objective-C class may change over time as instance variables are added; (or removed). For this reason, Clang rejects the application of the; sizeof operator to an Obje",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:8515,message,message,8515,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,2,['message'],['message']
Integrability,"r *__single. void foo(void *p) {; // typeof(p) == void *__single. int *l; // typeof(l) == int *__bidi_indexable; }. When the type of expression has an ""external"" bounds annotation, e.g.,; ``__sized_by``, ``__counted_by``, etc., the compiler may report an error on; ``typeof`` if the annotation creates a dependency with another declaration or; variable. For example, the compiler reports an error on ``typeof(p1)`` shown in; the following code because allowing it can potentially create another type; dependent on the parameter ``size`` in a different context (Please note that an; external bounds annotation on a parameter may only refer to another parameter of; the same function). On the other hand, ``typeof(p2)`` works resulting in ``int; *__counted_by(10)``, since it doesn't depend on any other declaration. .. TODO: add a section describing constraints on external bounds annotations. .. code-block:: C. void foo(int *__counted_by(size) p1, size_t size) {; // typeof(p1) == int *__counted_by(size); // -> a compiler error as it tries to create another type; // dependent on `size`. int *__counted_by(10) p2; // typeof(p2) == int *__counted_by(10); // -> no error. }. When ``typeof()`` takes a type name, the compiler doesn't apply an implicit; bounds annotation on the named pointer types. For example, ``typeof(int*)``; returns ``int *`` without any bounds annotation. A bounds annotation may be; added after the fact depending on the context. In the following example,; ``typeof(int *)`` returns ``int *`` so it's equivalent as the local variable is; declared as ``int *l``, so it eventually becomes implicitly; ``__bidi_indexable``. .. code-block:: c. void foo(void) {; typeof(int *) l; // `int *__bidi_indexable` (same as `int *l`); }. The programmers can still explicitly add a bounds annotation on the types named; inside ``typeof``, e.g., ``typeof(int *__bidi_indexable)``, which evaluates to; ``int *__bidi_indexable``. Default pointer types in ``sizeof()``; ^^^^^^^^^^^^^^^^^^^^^^^^^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:27077,depend,dependent,27077,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['depend'],['dependent']
Integrability,"r = binaryOperator(hasRHS())); a || b. Matcher<CXXTemporaryObjectExpr>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<CXXUnresolvedConstructExpr>hasAnyArgumentMatcher<Expr> InnerMatcher; Matches any argument of a call expression or a constructor call; expression, or an ObjC-message-send expression. Given; void x(int, int, int) { int y; x(1, y, 42); }; callExpr(hasAnyArgument(declRefExpr())); matches x(1, y, 42); with hasAnyArgument(...); matching y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end; void foo(I *i) { [i f:12]; }; objcMessageExpr(hasAnyArgument(integerLiteral(equals(12)))); matches [i f:12]. Matcher<CXXUnresolvedConstructExpr>hasArgumentunsigned N, Matcher<Expr> InnerMatcher; Matches the n'th argument of a call expression or a constructor; call expression. Example matches y in x(y); (matcher = callExpr(hasArgument(0, declRefExpr()))); void x(int) { int y; x(y); }. Matcher<CXXUnresolvedConstructExpr>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matche",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:170620,message,message-send,170620,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['message'],['message-send']
Integrability,"r LLVM IR may optionally be wrapped in a simple wrapper; structure. This structure contains a simple header that indicates the offset; and size of the embedded BC file. This allows additional information to be; stored alongside the BC file. The structure of this file header is:. :raw-html:`<tt><blockquote>`; [Magic\ :sub:`32`, Version\ :sub:`32`, Offset\ :sub:`32`, Size\ :sub:`32`, CPUType\ :sub:`32`]; :raw-html:`</blockquote></tt>`. Each of the fields are 32-bit fields stored in little endian form (as with the; rest of the bitcode file fields). The Magic number is always ``0x0B17C0DE`` and; the version is currently always ``0``. The Offset field is the offset in bytes; to the start of the bitcode stream in the file, and the Size field is the size; in bytes of the stream. CPUType is a target-specific value that can be used to; encode the CPU of the target. .. _native object file:. Native Object File Wrapper Format; =================================. Bitcode files for LLVM IR may also be wrapped in a native object file; (i.e. ELF, COFF, Mach-O). The bitcode must be stored in a section of the object; file named ``__LLVM,__bitcode`` for MachO or ``.llvmbc`` for the other object; formats. ELF objects additionally support a ``.llvm.lto`` section for; :doc:`FatLTO`, which contains bitcode suitable for LTO compilation (i.e. bitcode; that has gone through a pre-link LTO pipeline). The ``.llvmbc`` section; predates FatLTO support in LLVM, and may not always contain bitcode that is; suitable for LTO (i.e. from ``-fembed-bitcode``). The wrapper format is useful; for accommodating LTO in compilation pipelines where intermediate objects must; be native object files which contain metadata in other sections. . Not all tools support this format. For example, lld and the gold plugin will; ignore the ``.llvmbc`` section when linking object files, but can use; ``.llvm.lto`` sections when passed the correct command line options. .. _encoding of LLVM IR:. LLVM IR Encoding; ==============",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst:19008,wrap,wrapped,19008,interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,1,['wrap'],['wrapped']
Integrability,"r a single work-group are executed in the same; WGP. In CU wavefront execution mode the wavefronts may be executed by; different SIMDs in the same CU. In WGP wavefront execution mode the; wavefronts may be executed by different SIMDs in different CUs in the same; WGP.; * Each WGP has a single LDS memory shared by the wavefronts of the work-groups; executing on it.; * All LDS operations of a WGP are performed as wavefront wide operations in a; global order and involve no caching. Completion is reported to a wavefront in; execution order.; * The LDS memory has multiple request queues shared by the SIMDs of a; WGP. Therefore, the LDS operations performed by different wavefronts of a; work-group can be reordered relative to each other, which can result in; reordering the visibility of vector memory operations with respect to LDS; operations of other wavefronts in the same work-group. A ``s_waitcnt; lgkmcnt(0)`` is required to ensure synchronization between LDS operations and; vector memory operations between wavefronts of a work-group, but not between; operations performed by the same wavefront.; * The vector memory operations are performed as wavefront wide operations.; Completion of load/store/sample operations are reported to a wavefront in; execution order of other load/store/sample operations performed by that; wavefront.; * The vector memory operations access a vector L0 cache. There is a single L0; cache per CU. Each SIMD of a CU accesses the same L0 cache. Therefore, no; special action is required for coherence between the lanes of a single; wavefront. However, a ``buffer_gl0_inv`` is required for coherence between; wavefronts executing in the same work-group as they may be executing on SIMDs; of different CUs that access different L0s. A ``buffer_gl0_inv`` is also; required for coherence between wavefronts executing in different work-groups; as they may be executing on different WGPs.; * The scalar memory operations access a scalar L0 cache shared by all wavefr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:336342,synchroniz,synchronization,336342,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['synchroniz'],['synchronization']
Integrability,"r and the sequential container,; using the set-like container for uniquing and the sequential container for; iteration. The difference between SetVector and other sets is that the order of iteration; is guaranteed to match the order of insertion into the SetVector. This property; is really important for things like sets of pointers. Because pointer values; are non-deterministic (e.g. vary across runs of the program on different; machines), iterating over the pointers in the set will not be in a well-defined; order. The drawback of SetVector is that it requires twice as much space as a normal; set and has the sum of constant factors from the set-like container and the; sequential container that it uses. Use it **only** if you need to iterate over; the elements in a deterministic order. SetVector is also expensive to delete; elements out of (linear time), unless you use its ""pop_back"" method, which is; faster. ``SetVector`` is an adapter class that defaults to using ``std::vector`` and a; size 16 ``SmallSet`` for the underlying containers, so it is quite expensive.; However, ``""llvm/ADT/SetVector.h""`` also provides a ``SmallSetVector`` class,; which defaults to using a ``SmallVector`` and ``SmallSet`` of a specified size.; If you use this, and if your sets are dynamically smaller than ``N``, you will; save a lot of heap traffic. .. _dss_uniquevector:. llvm/ADT/UniqueVector.h; ^^^^^^^^^^^^^^^^^^^^^^^. UniqueVector is similar to :ref:`SetVector <dss_setvector>` but it retains a; unique ID for each element inserted into the set. It internally contains a map; and a vector, and it assigns a unique ID for each value inserted into the set. UniqueVector is very expensive: its cost is the sum of the cost of maintaining; both the map and vector, it has high complexity, high constant factors, and; produces a lot of malloc traffic. It should be avoided. .. _dss_immutableset:. llvm/ADT/ImmutableSet.h; ^^^^^^^^^^^^^^^^^^^^^^^. ImmutableSet is an immutable (functional) set implement",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:85602,adapter,adapter,85602,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['adapter'],['adapter']
Integrability,"r bkg or signal like events. DTLogic No None None, GiniIndex, MisClassificationError, CrossEntropy, GiniIndexWithLaplace, SdivSqrtSplusB Use decision tree algorithm to split cells. Kernel No None None, Gauss, LinNeighbors Kernel type used. TargetSelection No Mean Mean, Mpv Target selection method. Configuration options for MVA method :. Configuration options reference for MVA method: TMlpANN. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). NCycles No 200 − Number of training cycles. HiddenLayers No N,N-1 − Specification of hidden layer architecture (N stands for number of variables; any integers may also be used). ValidationFraction No 0.5 − Fraction of events in training tree used for cross validation. LearningMethod No Stochastic Stochastic, Batch, SteepestDescent, RibierePolak, FletcherReeves, BFGS Learning method. Configuration options for setup and tuning of specific fitter :. Configuration options reference for fitting method: Simulated Annealing (SA). Option Array Default value Predefined values Description. MaxCalls No 100000 − Maximum number of minimisation calls. InitialTemp No 1e+06 − Initial temperature. MinTemp No 1e-06 − Mimimum temperature. Eps No",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:28472,message,message,28472,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,2,['message'],['message']
Integrability,"r classes. Name and title can be set optionally using the SetName and SetTitle methods. Please note that this change is not backward compatible.; Add the option to use binned generation (via SetGenerateBinned).; An estimated of the error in the obtained p values is now computed in the HybridResult class thanks to Matthias Wolf. The errors can be obtained with HybridResult::CLbError(), HybridResult::CLsplusbError() or HybridResult::CLsError().; A new tutorial has been added for showing the usage of the hybrid calculator: rs505_HybridCalculator_significance.C. new class HypoTestInverter. New class for performing an hypothesis test inversion by scanning; the hypothesis test results of the HybridCalculator for; various values of the parameter of interest. An upper (or lower) limit can be derived by looking at the; confidence level curve of the result as function of the parameter of; interest, where it intersects the desired confidence level. The class implements the IntervalCalculator interface and returns an HypoTestInverterResult class. The result is a SimpleInterval, which via the method UpperLimit returns to the user the upper limit value. The HypoTestInverter implements various option for performing the scan. HypoTestInverter::RunFixedScan will scan using a fixed grid the parameter of interest. HypoTestInverter::RunAutoScan will perform an automatic scan to find optimally the curve and it will stop when the desired precision is obtained.; The confidence level value at a given point can also be done via HypoTestInverter::RunOnePoint.; The class can scan the CLs+b values (default) or alternatively CLs (if the; method HypoTestInverter::UseCLs has been called).; The estimated error due to the MC toys statistics from the HybridCalculator is propagated into the limits obtained from the HypoTestResult; A new tutorial rs801_HypoTestInverter.C has been added in the tutorials/roostats directory to show the usage of this class. New class BayesianCalculator. New class for calcu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html:14963,interface,interface,14963,roofit/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html,2,['interface'],['interface']
Integrability,"r complex numbers, TComplex,; common interfaces for function evaluation and numerical algorithms.; Basic implementations of some of the numerical algorithms such as integration or derivation, are also provided by MathCore.; together with the core classes needed to fit any generic data set. - \ref MathMore ""MathMore"": a package incorporating advanced numerical functionality and dependent on external libraries like the GNU Scientific Library ([GSL](http://www.gnu.org/software/gsl/)). It complements the MathCore library by providing a more complete sets of special mathematical functions and implementations of the numerical algorithms interfaces defined in MathCore using GSL. - **Minimization and Fitting Libraries**; Libraries required for numerical minimization and fitting. The minimization libraries include the numerical methods for solving the fitting problem by finding minimum of multi-dimensional; function. The current common interface for minimization is the class ROOT::Math::Minimizer and implemented by derived classes in the minimization and fitting libraries. The fitting in %ROOT is; organized in fitting classes present in MathCore in the (ROOT::Fit namespace) for providing the fitting functionality and the use the minimization libraries via the common interface (ROOT::Math::Minimizer). In detail the minimization libraries, implementing all the new and old minimization interface, include:. - \ref MinuitOld ""Minuit"": library providing via a class TMinuit an implementation of the popular MINUIT minimization package. In addition the library contains also an implementation of the linear fitter (class TLinearFitter), for solving linear least square fits.; - \ref Minuit2Page ""Minuit2"": new object-oriented implementation of MINUIT, with the same minimization algorithms (such as Migrad or Simplex). In addition it provides a new implementation of the Fumili algorithm, a specialized method for finding the minimum of a standard least square or likelihood functions.; - **Fu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/index.md:1299,interface,interface,1299,math/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/index.md,1,['interface'],['interface']
Integrability,"r debugging. .. option:: -gen-searchable-tables. Generate generic searchable tables. See :doc:`TableGen BackEnds <../TableGen/BackEnds>`; for a detailed description. .. option:: -gen-subtarget. Generate subtarget enumerations. .. option:: -gen-x86-EVEX2VEX-tables. Generate X86 EVEX to VEX compress tables. .. option:: -gen-x86-fold-tables. Generate X86 fold tables. .. option:: -long-string-literals. When emitting large string tables, prefer string literals over; comma-separated char literals. This can be a readability and; compile-time performance win, but upsets some compilers. .. option:: -print-enums. Print enumeration values for a class. .. option:: -class=classname. Make -print-enums print the enumeration list for the specified class. .. option:: -print-sets. Print expanded sets for testing DAG exprs. mlir-tblgen Options; ~~~~~~~~~~~~~~~~~~~. .. option:: -gen-avail-interface-decls. Generate availability interface declarations. .. option:: -gen-avail-interface-defs. Generate op interface definitions. .. option:: -gen-dialect-doc. Generate dialect documentation. .. option:: -dialect. The dialect to generate. .. option:: -gen-directive-decl. Generate declarations for directives (OpenMP, etc.). .. option:: -gen-enum-decls. Generate enum utility declarations. .. option:: -gen-enum-defs. Generate enum utility definitions. .. option:: -gen-enum-from-llvmir-conversions. Generate conversions of EnumAttrs from LLVM IR. .. option:: -gen-enum-to-llvmir-conversions. Generate conversions of EnumAttrs to LLVM IR. .. option:: -gen-llvmir-conversions. Generate LLVM IR conversions. .. option:: -gen-llvmir-intrinsics. Generate LLVM IR intrinsics. .. option:: -llvmir-intrinsics-filter. Only keep the intrinsics with the specified substring in their record name. .. option:: -dialect-opclass-base. The base class for the ops in the dialect we are to emit. .. option:: -gen-op-decls. Generate operation declarations. .. option:: -gen-op-defs. Generate operation definitions. .. option:: -as",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/tblgen.rst:13011,interface,interface,13011,interpreter/llvm-project/llvm/docs/CommandGuide/tblgen.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/tblgen.rst,1,['interface'],['interface']
Integrability,"r displayed objects; 10. Fix errors with scaling of axis labels.; 11. Support also Y axis with custom labels like: http://jsroot.gsi.de/dev/?nobrowser&file=../files/atlas.root&item=LEDShapeHeightCorr_Gain0;1&opt=col. ## Changes in 3.7; 1. Support of X axis with custom labels like: http://jsroot.gsi.de/dev/?nobrowser&json=../files/hist_xlabels.json; 2. Extend functionality of JSROOT.addDrawFunc() function. One could register type-specific; `make_request` and `after_request` functions; `icon`, `prereq`, `script`, `monitor` properties.; This let add more custom elements to the generic gui, implemented with JSROOT.HierarchyPainter; 3. Provide full support of require.js. One could load now JSRootCore.js script like:. <script type=""text/javascript"" src=""require.js"" data-main=""scripts/JSRootCore.js""></script>. After this several modules are defined and can be used with syntax like:. require(['JSRootPainter'], function(jsroot) { /*any user code*/});. Also inside JSROOT require.js used to load all dependencies. ## Changes in 3.6; 1. Try to provide workaround for websites where require.js already loaded.; This makes problem by direct loading of jquery and jquery-ui; 2. Provide workaround for older version of jquery-ui; 3. Prompt for input of command arguments; 4. After command execution one could automatically reload hierarchy (_hreload property) or; update view of displayed object (_update_item property); 5. Use HierarchyPainter for implementing draw.htm. This let us handle; all different kinds of extra attributes in central place; 6. Fix problem in tabs layout - new tab should be add to direct child; 7. When drawing several tabs, activate frame before drawing - only then; real frame size will be set; 8. Fix problem with GetBBox - it only can be used for visible elements in mozilla.; 9. Support drawing of fit parameters in stat box, use (as far as possible) stat and; fit format for statistic display; 10. Implement 'g' formatting kind for stat box output - one need to checks; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:63819,depend,dependencies,63819,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['depend'],['dependencies']
Integrability,"r does not need anymore to clone the null parameter set. It; is done now inside the calculator; LikelihoodInterval::LowerLimit (and UpperLimit); returns now a boolean flag with the status of the limit search.; In case of a failure in finding the upper/lower limit a value of; zero is returned instead of the min/max of the variable range; LikelihoodIntervalPlot fix drawing of horizontal green; line when limits are outside the variable range . HybridCalculator. New re-written class based on the TestStatSampler and; TestStatistic interfaces. The new class is designed to provide; consistent use of a ModelConfig, specifying the Pdf and Prior. ; The old class remains, but with a new name: HybridCalculatorOriginal. ; The tutorial rs201b_hybridcalculator shows the usage of; the new class.; Note that the new class can be constructed only from a; ModelConfig; One can specify a TestStatSampler in the constructor (which implies a choice of a TestStatistic, or by default the tool will use the ToyMCSampler and the RatioOfProfiledLikelihoods; The interface of the new HybridCalculator class is now more uniform with the other calculator tools, which is different from the original; HybridCalculator's interface. Users wishing to run their old macro are advised to use ModelConfig, but if that is too time consuming one can just change the; name of the class from HybridCalculator to; HybridCalculatorOriginal; Note also that with the new class no HybridResult is; returned but directly the base class HypoTestResult which; has been improved for this release.; The plot class, HybridPlot is not returned, but; the user can create an HypoTestPlot object from the; HypoTestResult.; The classes HybridResult and HybridPlot work only; with the HybridCalculatorOriginal and remain for maintaining; a backward compatibility. ; Given a ModelConfig, the tool will attempt to form the posterior pdf ; for the nuisance parameters based on the prior and the constraint terms ; in the pdf. However, this is not yet",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v528/index.html:5058,interface,interface,5058,roofit/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v528/index.html,4,['interface'],['interface']
Integrability,"r emit function calls; ``MaterializationResponsibility::failMaterialization`` (this JIT clients who; may be waiting on other threads know that the code they were waiting for has; failed to compile) and logs the error with the execution session before bailing; out. The other half of the IRLayer interface we inherit unmodified from the IRLayer; class:. .. code-block:: c++. Error IRLayer::add(JITDylib &JD, ThreadSafeModule TSM, VModuleKey K) {; return JD.define(std::make_unique<BasicIRLayerMaterializationUnit>(; *this, std::move(K), std::move(TSM)));; }. This code, from ``llvm/lib/ExecutionEngine/Orc/Layer.cpp``, adds a; ThreadSafeModule to a given JITDylib by wrapping it up in a; ``MaterializationUnit`` (in this case a ``BasicIRLayerMaterializationUnit``).; Most layers that derived from IRLayer can rely on this default implementation; of the ``add`` method. These two operations, ``add`` and ``emit``, together constitute the layer; concept: A layer is a way to wrap a part of a compiler pipeline (in this case; the ""opt"" phase of an LLVM compiler) whose API is opaque to ORC with an; interface that ORC can call as needed. The add method takes an; module in some input program representation (in this case an LLVM IR module); and stores it in the target ``JITDylib``, arranging for it to be passed back; to the layer's emit method when any symbol defined by that module is requested.; Each layer can complete its own work by calling the ``emit`` method of its base; layer. For example, in this tutorial our IRTransformLayer calls through to; our IRCompileLayer to compile the transformed IR, and our IRCompileLayer in; turn calls our ObjectLayer to link the object file produced by our compiler. So far we have learned how to optimize and compile our LLVM IR, but we have; not focused on when compilation happens. Our current REPL optimizes and; compiles each function as soon as it is referenced by any other code,; regardless of whether it is ever called at runtime. In the next chapter ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst:9621,wrap,wrap,9621,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,2,"['interface', 'wrap']","['interface', 'wrap']"
Integrability,"r every event, whereas integrals are only evaluated when needed. The exception to the first type are pdfs; that only depend on constant parameters (or no parameters) - these are identified at the beginning, and precalculated once ; to avoid recalculating an expression with the same outcome for every iteration of the likelihood calculation. For composite pdfs a further optimization has been included: for a M(x,a,b) = f*F(x,a)+(1-f)G(x,b) ; it is e.g. not needed to recalculate G(x,b) if only parameter a has changed w.r.t to the previous likelihood; calculation. This optimization is now implemented by extending the value caching originally designed; for constant terms to be usable for non-constant terms, with a check executed at the beginning of each; likelihood evaluation if selected columns need to be updated because parameters have changed. The speed gain; of this optimization depends much on the structure of the pdf: in models with many free parameters most of the; likelihood evaluations are executed when MINUIT calculates numerical likelihood derivatives which vary ; one parameter at a time and the speedup is potentially larger. In models with few free parameters the; effect will be smaller. The new per-component caching strategy is enabled by default for all pdfs that are a component of; a RooAddPdf or a RooRealSumPdf, unless that component is a RooProdPdf or a RooProduct, in that; case the components of the product are cached instead of the product itself. You can disable this; new optimization by adding Optimize(1) to the RooAbsPdf::fitTo() command line (0 = no caching,; 1 = cache constant terms only, 2 = cache also variable terms according to above mentioned strategy (DEFAULT)). It is also possible to tune this 'cache-and-track' optimization to perform a more fine-grained caching; of components than Optimize(2) implements: to do so, call arg->setAttribute(""CacheAndTrack"") on each; pdf component that you'd like to be cache-and-tracked individually. New pdf/data",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v532/index.html:2862,depend,depends,2862,roofit/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v532/index.html,2,['depend'],['depends']
Integrability,"r example, an expression; like ``X[a][b][c]``, must be effectively lowered into a form like; ``X[a*m+b*n+c]``, so that it appears to the GEP as a single-dimensional array; reference. This means if you want to write an analysis which understands array indices and; you want to support VLAs, your code will have to be prepared to reverse-engineer; the linearization. One way to solve this problem is to use the ScalarEvolution; library, which always presents VLA and non-VLA indexing in the same manner. .. _Rules:. Rules; =====. What happens if an array index is out of bounds?; ------------------------------------------------. There are two senses in which an array index can be out of bounds. First, there's the array type which comes from the (static) type of the first; operand to the GEP. Indices greater than the number of elements in the; corresponding static array type are valid. There is no problem with out of; bounds indices in this sense. Indexing into an array only depends on the size of; the array element, not the number of elements. A common example of how this is used is arrays where the size is not known.; It's common to use array types with zero length to represent these. The fact; that the static type says there are zero elements is irrelevant; it's perfectly; valid to compute arbitrary element indices, as the computation only depends on; the size of the array element, not the number of elements. Note that zero-sized; arrays are not a special case here. This sense is unconnected with ``inbounds`` keyword. The ``inbounds`` keyword is; designed to describe low-level pointer arithmetic overflow conditions, rather; than high-level array indexing rules. Analysis passes which wish to understand array indexing should not assume that; the static array type bounds are respected. The second sense of being out of bounds is computing an address that's beyond; the actual underlying allocated object. With the ``inbounds`` keyword, the result value of the GEP is ``poison`` if",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst:12799,depend,depends,12799,interpreter/llvm-project/llvm/docs/GetElementPtr.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst,1,['depend'],['depends']
Integrability,"r for coherence between wavefronts in the same; work-group. A ``buffer_wbinvl1_vol`` is required for coherence between; wavefronts executing in different work-groups as they may be executing on; different CUs.; * The scalar memory operations access a scalar L1 cache shared by all wavefronts; on a group of CUs. The scalar and vector L1 caches are not coherent. However,; scalar operations are used in a restricted way so do not impact the memory; model. See :ref:`amdgpu-amdhsa-memory-spaces`.; * The vector and scalar memory operations use an L2 cache shared by all CUs on; the same agent.; * The L2 cache has independent channels to service disjoint ranges of virtual; addresses.; * Each CU has a separate request queue per channel. Therefore, the vector and; scalar memory operations performed by wavefronts executing in different; work-groups (which may be executing on different CUs) of an agent can be; reordered relative to each other. A ``s_waitcnt vmcnt(0)`` is required to; ensure synchronization between vector memory operations of different CUs. It; ensures a previous vector memory operation has completed before executing a; subsequent vector memory or LDS operation and so can be used to meet the; requirements of acquire and release.; * The L2 cache can be kept coherent with other agents on some targets, or ranges; of virtual addresses can be set up to bypass it to ensure system coherence. Scalar memory operations are only used to access memory that is proven to not; change during the execution of the kernel dispatch. This includes constant; address space and global address space for program scope ``const`` variables.; Therefore, the kernel machine code does not have to maintain the scalar cache to; ensure it is coherent with the vector caches. The scalar and vector caches are; invalidated between kernel dispatches by CP since constant address space data; may change between kernel dispatch executions. See; :ref:`amdgpu-amdhsa-memory-spaces`. The one exception is if scal",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:208868,synchroniz,synchronization,208868,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['synchroniz'],['synchronization']
Integrability,"r it does not have the; ``cf_returns_not_retained`` attribute but it does have a :ref:`selector; family <arc.method-families>` that implies a retained result. Furthermore:. * a comma expression is classified according to its right-hand side,; * a statement expression is classified according to its result expression, if; it has one,; * an lvalue-to-rvalue conversion applied to an Objective-C property lvalue is; classified according to the underlying message send, and; * a conditional operator is classified according to its second and third; operands, if they agree in classification, or else the other if one is known; retain-agnostic. If the cast operand is known retained, the conversion is treated as a; ``__bridge_transfer`` cast. If the cast operand is known unretained or known; retain-agnostic, the conversion is treated as a ``__bridge`` cast. .. admonition:: Rationale. Bridging casts are annoying. Absent the ability to completely automate the; management of CF objects, however, we are left with relatively poor attempts; to reduce the need for a glut of explicit bridges. Hence these rules. We've so far consciously refrained from implicitly turning retained CF; results from function calls into ``__bridge_transfer`` casts. The worry is; that some code patterns --- for example, creating a CF value, assigning it; to an ObjC-typed local, and then calling ``CFRelease`` when done --- are a; bit too likely to be accidentally accepted, leading to mysterious behavior. For loads from ``const`` global variables of :ref:`C retainable pointer type; <arc.misc.c-retainable>`, it is reasonable to assume that global system; constants were initialized with true constants (e.g. string literals), but; user constants might have been initialized with something dynamically; allocated, using a global initializer. .. _arc.objects.restrictions.conversion-exception-contextual:. Conversion from retainable object pointer type in certain contexts; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:28362,bridg,bridges,28362,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['bridg'],['bridges']
Integrability,"r of the scene. Set the guides using `TGLViewer::SetGuideState` e.g. to enable edge; axes, and enable a reference marker at world position 50, 60, 100:. ``` {.cpp}; Double_t refPos[3] = {50.0,60.0,100.0};; v->SetGuideState(TGLUtil::kAxesEdge, kTRUE, refPos);; ```. #### Selecting Scene Shapes. You can select a single shape from your scene by pressing ‘Shift' key,; pointing and left clicking anywhere on the shape in the viewer.; Selection is currently shown by drawing the shape-bounding box (not; depth clipped) in white (polygon or wire frame render styles) or red; (outline render style). Manipulators supported by the shape are drawn in; red, green and blue while the non-supported ones are drawn in grey. To; deselect a shape, either select another, or shift/click anywhere on the; background (empty space) in the viewer. You cannot select Manipulators; or Guides (Axes / Reference Marker). #### Editing Shapes. When a shape is selected, the viewer's control pane shows the user; interface that allows you to review and adjust the color and geometry; properties of the shape. Note: At present modifications to the shapes are local to the viewer -; they are not propagated back to external objects/client that published; to the viewer. The changes are preserved only until the viewer is; closed. In some cases, this will never be feasible as there is not a; one-to-one correspondence between a shape in the viewer and a single; external object in which the modification could be stored. #### Colors / Style. Viewer Controls Pane ‘Style' tab. A full description of OpenGL materials, colors and lighting is beyond; the scope of this document. You should refer to the OpenGL programming; manual (Red Book) for a full discussion. In most cases adjustment of the; Diffuse color material + Opacity/Shine properties is sufficient to; achieve desired results. A shape has four-color materials (components):. - Diffuse. - Ambient. - Specular. - Emissive. For each of these you can select the component v",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:119170,interface,interface,119170,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['interface'],['interface']
Integrability,"r of the; newly created folder. The code below creates the folder hierarchy shown in the browser. In; this macro, the folder is also added to the list of browsable. This way,; it is visible in the browser on the top level. ``` {.cpp}; {; // Add the top folder of my hierary to //root; TFolder *aliroot=gROOT->GetRootFolder()->AddFolder(""aliroot"",; ""aliroot top level folders"");; // Add the hierarchy to the list of browsables; gROOT->GetListOfBrowsables()->Add(aliroot,""aliroot"");. // Create and add the constants folder; TFolder *constants=aliroot->AddFolder(""Constants"",; ""Detector constants"");. // Create and add the pdg folder to pdg; TFolder *pdg = constants->AddFolder(""DatabasePDG"",""PDG database"");. // Create and add the run folder; TFolder *run = aliroot->AddFolder(""Run"",""Run dependent folders"");. // Create and add the configuration folder to run; TFolder *configuration = run->AddFolder(""Configuration"",; ""Run configuration"");. // Create and add the run_mc folder; TFolder *run_mc = aliroot->AddFolder(""RunMC"",; ""MonteCarlo run dependent folders"");. // Create and add the configuration_mc folder to run_mc; TFolder *configuration_mc = run_mc->AddFolder(""Configuration"",; ""MonteCarlo run configuration"");; }; ```. ### Posting Data to a Folder (Producer). ![](pictures/030000E4.png). A **`TFolder`** can contain other folders as shown above or any; **`TObject`** descendents. In general, users will not post a single; object to a folder; they will store a collection or multiple collections; in a folder. For example, to add an array to a folder:. ``` {.cpp}; TObjArray *array;; run_mc->Add(array);; ```. ### Reading Data from a Folder (Consumer). One can search for a folder or an object in a folder using the; `TROOT::FindObjectAny` method. It analyzes the string passed as its; argument and searches in the hierarchy until it finds an object or; folder matching the name. With `FindObjectAny`, you can give the full; path name, or the name of the folder. If only the name of the folder i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md:3746,depend,dependent,3746,documentation/users-guide/FoldersTasks.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md,1,['depend'],['dependent']
Integrability,"r p.d.f.s ; RooMCStudy - Add Silence() argument to constructor to request minimal verbosity during running; RooMinuit - Improve contour() method to return RooPlots rather than drawing TGraphs straight on a canvas; RooWorkspace - Add private expensive object cache to workspace; RooBinningCategory - New real-to-category function that maps values of input RooRealVar to categories with labels that correspond to bins of input RooRealVar. See rf405_realtocatfuncs.C for details . RooStats; This is a new package introduced in this version for statistical tools built on top of RooFit. It is a joint effort between the LHC experiments and the ROOT team (see the RooStats Wiki page).; ; This version contains the interfaces for performing the statistical calculations and dealing with the obtained results and concrete classes implementing the statistical methods.; ; All the classes and functions in RooStats are provided in the namespace RooStats.; ; RooStats interfaces. ConfInterval: interface for describing a confidence interval. ; IntervalCalculator: interface for a statistical tool producing confidence intervals (class ConfInterval).; HypoTestResult: interface for representing results of a hypothesis test; HypoTestCalculator: interface for a statistical tool performing an hypothesis test. ; CombinedCalculator: interface for a statistical tool which can produce both hypothesis test results and confidence intervals. ; RooStats concrete classes. The concrete classes describing statistical tools implementing the above interfaces are:; ; ProfileLikelihoodCalculator: it is an implementation of a CombinedCalculator using the profile likelihood ratio as a test statistics. After configuring the calculator, one only needs to ask GetHypoTest() (which will return a HypoTestResult pointer) or GetInterval() (which will return an ConfInterval pointer).; LikelihoodInterval: concrete implementation of a ConfInterval interface. It implements connected N-dimensional intervals based on the contour",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html:9841,interface,interface,9841,roofit/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html,2,['interface'],['interface']
Integrability,"r provides; to Clang. For example, if the user specifies; ``--target=arm-none-eabi -mcpu=cortex-m4`` the toolchain can choose a directory; containing headers and libraries suitable for Armv7E-M, because it knows that's; a suitable architecture for Arm Cortex-M4.; Multilib can also choose between libraries for the same architecture based on; other options. For example if the user specifies ``-fno-exceptions`` then a; toolchain could select libraries built without exception support, thereby; reducing the size of the resulting binary. Design; ======. Clang supports GCC's ``-print-multi-lib`` and ``-print-multi-directory``; options. These are described in; `GCC Developer Options <https://gcc.gnu.org/onlinedocs/gcc-12.2.0/gcc/Developer-Options.html>`_. There are two ways to configure multilib in Clang: hard-coded or via a; configuration file. Hard-coded Multilib; ===================. The available libraries can be hard-coded in Clang. Typically this is done; using the ``MultilibBuilder`` interface in; ``clang/include/clang/Driver/MultilibBuilder.h``.; There are many examples of this in ``lib/Driver/ToolChains/Gnu.cpp``.; The remainder of this document will not focus on this type of multilib. EXPERIMENTAL Multilib via configuration file; ============================================. Some Clang toolchains support loading multilib configuration from a; ``multilib.yaml`` configuration file. A ``multilib.yaml`` configuration file specifies which multilib variants are; available, their relative location, what compilation options were used to build; them, and the criteria by which they are selected. Multilib processing; ===================. Clang goes through the following steps to use multilib from a configuration; file:. #. Normalize command line options. Clang can accept the same; information via different options - for example,; ``--target=arm-none-eabi -march=armv7-m`` and; ``--target=armv7m-none-eabi`` are equivalent.; Clang normalizes the command line before passing them",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:1686,interface,interface,1686,interpreter/llvm-project/clang/docs/Multilib.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst,1,['interface'],['interface']
Integrability,"r stack within 2gb of any of the; text in the program, much like it can reserve the low 2gb of address space. ###### The flag registers again make everything hard. Unfortunately, the technique of using `orq`-instructions has a serious flaw on; x86. The very thing that makes it easy to accumulate state, the flag registers; containing predicates, causes serious problems here because they may be alive; and used by the loading instruction or subsequent instructions. On x86, the; `orq` instruction **sets** the flags and will override anything already there.; This makes inserting them into the instruction stream very hazardous.; Unfortunately, unlike when hardening the loaded value, we have no fallback here; and so we must have a fully general approach available. The first thing we must do when generating these sequences is try to analyze; the surrounding code to prove that the flags are not in fact alive or being; used. Typically, it has been set by some other instruction which just happens; to set the flags register (much like ours!) with no actual dependency. In those; cases, it is safe to directly insert these instructions. Alternatively we may; be able to move them earlier to avoid clobbering the used value. However, this may ultimately be impossible. In that case, we need to preserve; the flags around these instructions:; ```; ... .LBB0_4: # %danger; cmovneq %r8, %rax # Conditionally update predicate state.; pushfq; orq %rax, %rcx # Mask the pointer if misspeculating.; orq %rax, %rdx # Mask the index if misspeculating.; popfq; movl (%rcx,%rdx), %edi; ```. Using the `pushf` and `popf` instructions saves the flags register around our; inserted code, but comes at a high cost. First, we must store the flags to the; stack and reload them. Second, this causes the stack pointer to be adjusted; dynamically, requiring a frame pointer be used for referring to temporaries; spilled to the stack, etc. On newer x86 processors we can use the `lahf` and `sahf` instructions to save;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:32118,depend,dependency,32118,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['depend'],['dependency']
Integrability,"r to the same data. Also, if any thread changes one of the; shared system resources, all threads within the process are affected.; For example, if a thread closes a file, the file is closed for all; threads. ### The Initial Thread. When a process is created, one thread is automatically created. This; thread is called the initial thread or the main thread. The initial; thread executes the main routine in multi-threaded programs. Note: At the end of this chapter is a glossary of thread specific terms. ## Implementation of Threads in ROOT. The **`TThread`** class has been developed to provide a platform; independent interface to threads for ROOT. ### Installation. For the time being, it is still necessary to compile a threaded version; of ROOT to enable some very special treatments of the canvas operations.; We hope that this will become the default later. To compile ROOT, just do (for example on a debian Linux):. ```; ./configure linuxdeb2 --with-thread=/usr/lib/libpthread.so; gmake depend; gmake; ```. This configures and builds ROOT using `/usr/lib/libpthread.so` as the; `Pthread` library, and defines `R__THREAD`. This enables the thread specific treatment of *`gPad`*, and creates; `$ROOTSYS/lib/libThread.so.`. Note: The parameter linuxdeb2 has to be replaced with the appropriate; ROOT keyword for your platform. ### Classes. **`TThread`** class implements threads . The platform dependent; implementation is in the **`TThreadImp`** class and its descendant; classes (e.g. **`TPosixThread`** ). **`TMutex`** class implements `mutex` locks. A mutex is a mutually; exclusive lock. The platform dependent implementation is in the; **`TMutexImp`** class and its descendant classes (e.g.; **`TPosixMutex`**). **`TCondition`** class implements a condition variable. Use a condition; variable to signal threads. The platform dependent implementation is in; the **`TConditionImp`** and **`TPosixCondition`** classes . **`TSemaphore`** class implements a counting semaphore. Use a semaphore",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:3192,depend,depend,3192,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['depend'],['depend']
Integrability,"r tree pass, then ``true`` is supplied as; the fourth argument. As a whole, the ``.cpp`` file looks like:. .. code-block:: c++. #include ""llvm/Pass.h""; #include ""llvm/IR/Function.h""; #include ""llvm/Support/raw_ostream.h"". #include ""llvm/IR/LegacyPassManager.h"". using namespace llvm;. namespace {; struct Hello : public FunctionPass {; static char ID;; Hello() : FunctionPass(ID) {}. bool runOnFunction(Function &F) override {; errs() << ""Hello: "";; errs().write_escaped(F.getName()) << '\n';; return false;; }; }; // end of struct Hello; } // end of anonymous namespace. char Hello::ID = 0;; static RegisterPass<Hello> X(""hello"", ""Hello World Pass"",; false /* Only looks at CFG */,; false /* Analysis Pass */);. Now that it's all together, compile the file with a simple ""``gmake``"" command; from the top level of your build directory and you should get a new file; ""``lib/LLVMHello.so``"". Note that everything in this file is; contained in an anonymous namespace --- this reflects the fact that passes; are self contained units that do not need external interfaces (although they; can have them) to be useful. Running a pass with ``opt``; ---------------------------. Now that you have a brand new shiny shared object file, we can use the; :program:`opt` command to run an LLVM program through your pass. Because you; registered your pass with ``RegisterPass``, you will be able to use the; :program:`opt` tool to access it, once loaded. To test it, follow the example at the end of the :doc:`GettingStarted` to; compile ""Hello World"" to LLVM. We can now run the bitcode file (hello.bc) for; the program through our transformation like this (or course, any bitcode file; will work):. .. code-block:: console. $ opt -load lib/LLVMHello.so -hello < hello.bc > /dev/null; Hello: __main; Hello: puts; Hello: main. The :option:`-load` option specifies that :program:`opt` should load your pass; as a shared object, which makes ""``-hello``"" a valid command line argument; (which is one reason you need to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:7587,interface,interfaces,7587,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['interface'],['interfaces']
Integrability,"r was causing a std::bad_alloc exception to be thrown on workers; when opening a remote file after a local one.    ; Fix several problems in TChain::Draw including. drawing into an existing histogram, i.e.; chain->Draw(""var>>myhist"");. treatment of histogram merging in case of small; statistics, i.e. when; the autobinning is not or only partially active;. usage of existing canvases when different histogram; names are specified;. Fix a problem causing a duplication of the final feedback; object. Fix problem with determining the subdir name in; TFileMerger::MergeRecursive on Windows; Make sure that the default sandbox is under $HOME/.proof; Fix a problem with dataset validation in multi-level; master setups; Fix a problem with ordinal numbers in multi-master setups; Fix a problem with defining the internal paths for; executables when configuring with '--prefix'; Fix backward-incompatibility issue giving the error; message  ""unknown action code: 5112""; Fix a few problems with file retrieval from the cache; Fix a problem with iteration of a std::list occasionally; causing seg-violations in TXSocket; Fix a few problems preventing correct usage of entry; lists in PROOF; Fix a problem with the permissions of the credentials; files created under <sandbox>/.creds; Fix a potential problem while determining the log paths; in log retrieval. Do not use vnsprintf in the XrdProofd plug-in, potential; source of deadlocks.; Fix a problem overwriting the local environment settings; for the xrootd sec modules; In XrdProofdProofServMgr::Destroy, fix segv in message; creation when all sessions are destroyed at once; Fix a problem determining the relative time order of old; sessions for log retrieval; In TProof::HandleInputMessage, fix possible double delete; after kPROOF_STOPPROCESS; Fix a couple of issues on reconnection to a running; session (some dialog buttons not in the correct state; logs not; correctly redirected); Fix a problem creating spurious warnings during 'draw'; queries. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html:10329,message,message,10329,proof/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html,2,['message'],['message']
Integrability,"r"" who; maintains the build configuration. Generally, operational responsibility lies; with the ""config owner"". We do expect ""resource owners"" - who are generally; the contact listed in a workers attributes - to proxy requests to the relevant; ""config owner"" in a timely manner. Most issues with a buildbot should be addressed directly with a bot owner; via email. Please CC `Galina Kistanova <mailto:gkistanova@gmail.com>`_. Steps To Add Builder To LLVM Buildbot; =====================================; Volunteers can provide their build machines to work as build workers to; public LLVM Buildbot. Here are the steps you can follow to do so:. #. Check the existing build configurations to make sure the one you are; interested in is not covered yet or gets built on your computer much; faster than on the existing one. We prefer faster builds so developers; will get feedback sooner after changes get committed. #. The computer you will be registering with the LLVM buildbot; infrastructure should have all dependencies installed and be able to; build your configuration successfully. Please check what degree; of parallelism (-j param) would give the fastest build. You can build; multiple configurations on one computer. #. Install buildbot-worker (currently we are using buildbot version 2.8.4).; This specific version can be installed using ``pip``, with a command such; as ``pip3 install buildbot-worker==2.8.4``. #. Create a designated user account, your buildbot-worker will be running under,; and set appropriate permissions. #. Choose the buildbot-worker root directory (all builds will be placed under; it), buildbot-worker access name and password the build master will be using; to authenticate your buildbot-worker. #. Create a buildbot-worker in context of that buildbot-worker account. Point it; to the **lab.llvm.org** port **9994** (see `Buildbot documentation,; Creating a worker; <http://docs.buildbot.net/current/tutorial/firstrun.html#creating-a-worker>`_; for more details) by ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst:2805,depend,dependencies,2805,interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,1,['depend'],['dependencies']
Integrability,"r) curves; 12. Let change physical node visibility in TGeo drawings; 13. Use TGaxis attributes from gStyle - fAxisMaxDigits, fStripDecimals and exponent offset; 14. Implement ""projxy"" draw option for TH2 - like projxy3 or projx1_y5; 15. Support custom function in TGaxis - when drawn in TWebCanvas; 16. Introduce settings.WithCredentials, set xhr.withCredentials = true when submitting HTTP requests; 17. Let superimpose TH3 and geo drawings; 18. Apply pad draw options like 'gridx' or 'logy' to all subpads; 19. Support new TScatter and TAnnotation classes; 20. Implement moving and resizing of subpads; 21. Implement zooming in the TASImage; 22. Let configure position and direction of camera for TGeo, let create URL for that; 23. Support labels rotation for simple axis in geometry; 24. Support many orthographic cameras with overlayed grid/labels; 25. Support InstancedMesh for TGeo drawing, let show really large geometries; 26. Implement 'inject=path/script_name.js' url option to inject scripts without emulating of v6; 27. Exclude 'HEAD' http request when reading ROOT file, all necessary info can be get from first real HTTP request; 28. Provide makeImage function for generation of svg, png and jpeg images in batch and interactively (#257); 29. Implement interactive zoom shifting when middle-mouse button down or single-touch moving; 30. Several improvements for touch devices or devices with small displays; 31. Remove settings.FrameNDC, use Style.fPadLeft/Right/Top/BottomMargin values instead; 32. Fix - rescan sumw2 when update TH1; 33. Fix - correct placing for TLegend header; 34. Fix - correctly align sub/super scripts in complex TLatex; 35. Fix - correctly set visibility level for geo drawing (#258); 36. Fix - use more factor for number of nodes in geo drawing (#258). ## Changes in 7.3.4; 1. Fix - failure in normal_cdf calculation; 2. Fix - check in TTree::Draw for null buffer; 3. Fix - do not rise exception in treeProcess; 4. Fix - RH1 zero line drawing only when required",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:13682,inject,inject,13682,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['inject'],['inject']
Integrability,"r, ``MachineFunctionPass``\ es; are not allowed to do any of the following:. #. Modify or create any LLVM IR ``Instruction``\ s, ``BasicBlock``\ s,; ``Argument``\ s, ``Function``\ s, ``GlobalVariable``\ s,; ``GlobalAlias``\ es, or ``Module``\ s.; #. Modify a ``MachineFunction`` other than the one currently being processed.; #. Maintain state across invocations of :ref:`runOnMachineFunction; <writing-an-llvm-pass-runOnMachineFunction>` (including global data). .. _writing-an-llvm-pass-runOnMachineFunction:. The ``runOnMachineFunction(MachineFunction &MF)`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool runOnMachineFunction(MachineFunction &MF) = 0;. ``runOnMachineFunction`` can be considered the main entry point of a; ``MachineFunctionPass``; that is, you should override this method to do the; work of your ``MachineFunctionPass``. The ``runOnMachineFunction`` method is called on every ``MachineFunction`` in a; ``Module``, so that the ``MachineFunctionPass`` may perform optimizations on; the machine-dependent representation of the function. If you want to get at; the LLVM ``Function`` for the ``MachineFunction`` you're working on, use; ``MachineFunction``'s ``getFunction()`` accessor method --- but remember, you; may not modify the LLVM ``Function`` or its contents from a; ``MachineFunctionPass``. .. _writing-an-llvm-pass-registration:. Pass registration; -----------------. In the :ref:`Hello World <writing-an-llvm-pass-basiccode>` example pass we; illustrated how pass registration works, and discussed some of the reasons that; it is used and what it does. Here we discuss how and why passes are; registered. As we saw above, passes are registered with the ``RegisterPass`` template. The; template parameter is the name of the pass that is to be used on the command; line to specify that the pass should be added to a program (for example, with; :program:`opt` or :program:`bugpoint`). The first argument is the name of the;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:26376,depend,dependent,26376,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['depend'],['dependent']
Integrability,"r, the **`TPython`** class will be loaded; automatically on use, for older editions, the `libPyROOT.so` needs to be; loaded first before use. It is possible to switch between interpreters; by calling **`TPython::Prompt()`** on the ROOT side, while returning with; `^D` (`EOF`). State is preserved between successive switches, and string; based cross calls can nest as long as shared resources are properly; handled. ``` {.cpp}; // Example: accessing the Python interpreter from ROOT; // either load PyROOT explicitly or rely on auto-loading; root[] gSystem->Load( ""libPyROOT"" );; root[] TPython::Exec(""print1+1"");; 2. // create a TBrowser on the Python side, and transfer it back and forth; root[] TBrowser* b = (void*)TPython::Eval(""ROOT.TBrowser()"");; (class TObject*)0x8d1daa0; root[] TPython::Bind(b,""b"");. // builtin variables can cross-over (after the call i==2); root[] int i = TPython::Eval( ""1+1"" );; root[] i; (int)2; ```. ### Installation. There are several ways of obtaining `PyROOT`, and which is best depends; on your specific situation. If you work at CERN, you can use the; installation available on `afs`. Otherwise, you will want to build from; source, as `PyROOT` is not build by default in the binaries distributed; from the ROOT project site. If you download the ROOT binaries, take care; to download and install the Python distribution from; <http://www.python.org/> against which they were built. #### Environment Settings. ROOT installations with the build of `PyROOT` enabled are available from; the CERN `afs` cell `/afs/cern.ch/sw/root/<version>/<platform>`. To use; them, simply modify your shell environment accordingly. For Unix:. `export PATH=$ROOTSYS/bin:$PYTHONDIR/bin:$PATH`. `export LD_LIBRARY_PATH=$ROOTSYS/lib:$PYTHONDIR/lib:$LD_LIBRARY_PATH`. `export PYTHONPATH=$ROOTSYS/lib:$PYTHONPATH`. For Windows:. `set PATH=%ROOTSYS%/bin;%PYTHONDIR%/bin;%PATH%`. `set PYTHONPATH=%ROOTSYS%/bin;%PYTHONPATH%`. where `$ROOTSYS` should be set to; `/afs/cern.ch/sw/root/<version>",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:5497,depend,depends,5497,documentation/users-guide/PythonRuby.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md,1,['depend'],['depends']
Integrability,"r-info dump register information for debugging. .. option:: -gen-searchable-tables. Generate generic searchable tables. See :doc:`TableGen BackEnds <../TableGen/BackEnds>`; for a detailed description. .. option:: -gen-subtarget. Generate subtarget enumerations. .. option:: -gen-x86-EVEX2VEX-tables. Generate X86 EVEX to VEX compress tables. .. option:: -gen-x86-fold-tables. Generate X86 fold tables. .. option:: -long-string-literals. When emitting large string tables, prefer string literals over; comma-separated char literals. This can be a readability and; compile-time performance win, but upsets some compilers. .. option:: -print-enums. Print enumeration values for a class. .. option:: -class=classname. Make -print-enums print the enumeration list for the specified class. .. option:: -print-sets. Print expanded sets for testing DAG exprs. mlir-tblgen Options; ~~~~~~~~~~~~~~~~~~~. .. option:: -gen-avail-interface-decls. Generate availability interface declarations. .. option:: -gen-avail-interface-defs. Generate op interface definitions. .. option:: -gen-dialect-doc. Generate dialect documentation. .. option:: -dialect. The dialect to generate. .. option:: -gen-directive-decl. Generate declarations for directives (OpenMP, etc.). .. option:: -gen-enum-decls. Generate enum utility declarations. .. option:: -gen-enum-defs. Generate enum utility definitions. .. option:: -gen-enum-from-llvmir-conversions. Generate conversions of EnumAttrs from LLVM IR. .. option:: -gen-enum-to-llvmir-conversions. Generate conversions of EnumAttrs to LLVM IR. .. option:: -gen-llvmir-conversions. Generate LLVM IR conversions. .. option:: -gen-llvmir-intrinsics. Generate LLVM IR intrinsics. .. option:: -llvmir-intrinsics-filter. Only keep the intrinsics with the specified substring in their record name. .. option:: -dialect-opclass-base. The base class for the ops in the dialect we are to emit. .. option:: -gen-op-decls. Generate operation declarations. .. option:: -gen-op-defs. Generate op",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/tblgen.rst:12983,interface,interface-defs,12983,interpreter/llvm-project/llvm/docs/CommandGuide/tblgen.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/tblgen.rst,1,['interface'],['interface-defs']
Integrability,"r. The C interface was designed to require very little memory; management, and so is straightforward in this regard. What support is there for a higher level source language constructs for building a compiler?; --------------------------------------------------------------------------------------------; Currently, there isn't much. LLVM supports an intermediate representation; which is useful for code representation but will not support the high level; (abstract syntax tree) representation needed by most compilers. There are no; facilities for lexical nor semantic analysis. I don't understand the ``GetElementPtr`` instruction. Help!; -----------------------------------------------------------; See `The Often Misunderstood GEP Instruction <GetElementPtr.html>`_. Using the C and C++ Front Ends; ==============================. Can I compile C or C++ code to platform-independent LLVM bitcode?; -----------------------------------------------------------------; No. C and C++ are inherently platform-dependent languages. The most obvious; example of this is the preprocessor. A very common way that C code is made; portable is by using the preprocessor to include platform-specific code. In; practice, information about other platforms is lost after preprocessing, so; the result is inherently dependent on the platform that the preprocessing was; targeting. Another example is ``sizeof``. It's common for ``sizeof(long)`` to vary; between platforms. In most C front-ends, ``sizeof`` is expanded to a; constant immediately, thus hard-wiring a platform-specific detail. Also, since many platforms define their ABIs in terms of C, and since LLVM is; lower-level than C, front-ends currently must emit platform-specific IR in; order to have the result conform to the platform ABI. Questions about code generated by the demo page; ===============================================. What is this ``llvm.global_ctors`` and ``_GLOBAL__I_a...`` stuff that happens when I ``#include <iostream>``?; ------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FAQ.rst:5793,depend,dependent,5793,interpreter/llvm-project/llvm/docs/FAQ.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FAQ.rst,1,['depend'],['dependent']
Integrability,"r.GetFile();; TNtuple ntrand(""ntrand"", ""Random Numbers"", ""r"");; fill(ntrand, nEventsPerWorker);; ntrand.Write();; f->Write();; };; ```. ## Language Bindings. - Add in PyROOT the converter for std::string_view; - Fix ROOT-8811: pickling of ROOT.Long now works; - Fix ROOT-8809: push_back on a vector of pointers; - Fix ROOT-8805: itemsize was not set on buffers returned by PyROOT functions. ## JavaScript ROOT. ## Tutorials. ## Class Reference Guide. ## Build, Configuration and Testing Infrastructure. - rlibmap has been removed; it was deprecated for three years.; - Added the CMake exported ROOT libraries into the ROOT:: namespace. In this way, projects based on CMake using ROOT can avoid; conflicts in library target names. As an example, this is the way to build a project consisting of one library and one; executable using ROOT.; ```; find_package(ROOT REQUIRED); include(${ROOT_USE_FILE}). include_directories(${CMAKE_SOURCE_DIR} ${ROOT_INCLUDE_DIRS}); add_definitions(${ROOT_CXX_FLAGS}). ROOT_GENERATE_DICTIONARY(G__Event Event.h LINKDEF EventLinkDef.h). add_library(Event SHARED Event.cxx G__Event.cxx); target_link_libraries(Event ROOT::Hist ROOT::Tree). add_executable(Main MainEvent.cxx); target_link_libraries(Main Event); ```; - Added option `builtin_all` to enable all the built in options.; - For rootcling_stage1 (formerly known as rootcling_tmp), the package structure was changed to enable homogenous visibility; settings across object files. See core/README for an overview.; - Several non-public headers are not copied into include/ anymore; they reside in the PACKAGE/res/ subdirectory in the source tree.; - The IMT switch is set to on by default.; - A new library is now created, libImt. It contains all classes which depend on TBB. Those classes were previously part of libThread. As a consequence rootcling/genreflex do not depend anymore from TBB even in presence of imt builds.; - Refactoring of several math tests to avoid exact comparisons of floating point numbers; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md:18744,depend,depend,18744,README/ReleaseNotes/v610/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md,2,['depend'],['depend']
Integrability,"r.h"". class TUserHandler : public THttpWSHandler {; public:; TUserHandler(const char *name, const char *title) : THttpWSHandler(name, title) {}. // provide custom HTML page when open correspondent address; TString GetDefaultPageContent() override { return ""file:ws.htm""; }. Bool_t ProcessWS(THttpCallArg *arg) override;; };; ```. Central method is `TUserHandler::ProcessWS(THttpCallArg *arg)`, where four kinds of websockets events should be handled:. * WS_CONNECT - clients attempts to create websockets, return false when refusing connection; * WS_READY - connection is ready to use, **wsid** can be obtained with `arg->GetWSId()` calls; * WS_DATA - new portion of data received by webcosket; * WS_CLOSE - connection closed by the client, **wsid** is no longer valid. These kinds are coded as method name of THttpCallArg class and can be used like:. ```cpp; Bool_t TUserHandler::ProcessWS(THttpCallArg *arg); {; if (arg->IsMethod(""WS_CONNECT"")) {; return kTRUE; // accept all connections; }. if (arg->IsMethod(""WS_READY"")) {; SendCharStartWS(arg->GetWSId(), ""Init""); // immediately send message to the web socket; return kTRUE;; }. if (arg->IsMethod(""WS_CLOSE"")) {; return kTRUE; // just confirm connection; }. if (arg->IsMethod(""WS_DATA"")) {; TString str = arg->GetPostDataAsString();; printf(""Client msg: %s\n"", str.Data());; SendCharStarWS(arg->GetWSId(), ""Confirm"");; return kTRUE;; }. return kFALSE; // ignore all other kind of requests; }; ```. Instance of **TUserHandler** should be registered to the THttpServer like:. ```cpp; THttpServer *serv = new THttpServer(""http:8080"");; TUserHandler *handler = new TUserHandler(""name1"",""title"");; serv->Register(handler);; ```. After that web socket connection can be established with the address `ws://host_name:8080/name1/root.websocket`; Example client code can be found in `$ROOTSYS/tutorials/http/ws.htm` file. Custom HTML page for; websocket handler is specified with `TUserHandler::GetDefaultPageContent()` method returning `""file:ws.htm""`.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:26267,message,message,26267,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['message'],['message']
Integrability,"r2:var3"");; ```. will print the values of `var1`, `var2` and `var3`. A selection can be; applied in the second argument:. ``` {.cpp}; root[] MyTree->Scan(""var1:var2:var3"",""var1==0"");; ```. will print the values of `var1`, `var2` and `var3` for the entries where; var1 is exactly 0. `TTree::Scan` returns the number of entries passing the selection. By; default 50 rows are shown before `TTree::Scan` pauses and ask you to; press the Enter key to see the next 50 rows. You can change the default; number of rows to be shown before \<CR\> via; `mytree->SetScanfield(maxrows)` where maxrows is 50 by default. If; maxrows is set to 0 all rows of the **`Tree`** are shown. This option is; interesting when dumping the contents of a Tree to an ascii file, eg; from the command line:. ``` {.cpp}; root[] tree->SetScanField(0);; root[] tree->Scan(""*""); >tree.log; ```. will create a file `tree.log`. Arrays (within an entry) are printed in their linear forms. If several; arrays with multiple dimensions are printed together, they will NOT be; synchronized. For example, with a tree containing `arr1[4][2] `and; `arr2[2][3]`,. ``` {.cpp}; root[] MyTree(""arr1:arr2"");; ```. will results in a printing similar to:. ``` {.cpp}; ************************************************; * Row * Instance * arr1 * arr2 *; ***********************************************; * x * 0 * arr1[0][0]* arr2[0][0]*; * x * 1 * arr1[0][1]* arr2[0][1]*; * x * 2 * arr1[1][0]* arr2[0][2]*; * x * 3 * arr1[1][1]* arr2[1][0]*; * x * 4 * arr1[2][0]* arr2[1][1]*; * x * 5 * arr1[2][1]* arr2[1][2]*; * x * 6 * arr1[3][0]* *; * x * 7 * arr1[3][1]* *; ```. However, if there is a selection criterium which is an array, then all; the formulas will be synchronized with the selection criterium (see; **`TTree::Draw` for more information).**. The third parameter of `TTree::Scan` can be use to specific the layout; of the table:. - `lenmax=dd` - where 'dd' is the maximum number of elements per array; that should be printed. If 'dd' is 0, all e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:106134,synchroniz,synchronized,106134,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['synchroniz'],['synchronized']
Integrability,"r::SetFCN` is used to set the method function and `ROOT::Fit::FitFCN` is used for fitting. The method function can be passed also in `ROOT::Fit::FitFCN`, but in this; case a previously defined fitting configuration is used. The possible type of method functions that are based in `ROOT::Fit::Fitter::SetFCN` are:. * A generic functor object implementing `operator()(const double * p)` where **`p`** is the parameter vectors. In this case one needs to pass the number of parameters,; the function object and optionally a vector of initial parameter values. Other optional parameter include the size of the data sets and a flag specifying if it is a chi2 (least-square fit).; In the last two parameters are given, the `chi2/ndf` can be computed after fitting the data.; ``` {.cpp}; template <class Function>; bool Fitter::SetFCN(unsigned int npar, Function & f,; const double * initialParameters = 0,; unsigned int dataSize=0, bool isChi2Fit = false); ```. * A function object implementing the `ROOT::Math::IBaseFunctionMultiDim` interface:; ``` {.cpp}; bool Fitter::SetFCN(const ROOT::Math::IBaseFunctionMultiDim & f,; const double * initialParameters = 0,; unsigned int dataSize=0, bool isChi2Fit = false); ```. * A function object implementing the `ROOT::Math::FitMethodFunction` interface. This is an interface class extending; the `ROOT::Math::IBaseFunctionMultiDim` with some extra functionality which can be used when fitting.; This extra functionality is required by dedicated fitting algorithms like *Fumili* or *GSLMultiFit*.; ``` {.cpp}; bool Fitter::SetFCN(const ROOT::Math::FitMethodFunction & f,; const double * initialParameters = 0, unsigned int dataSize=0); ```. * A old-Minuit like FCN interface (i.e. a free function with the signature `fcn(int &npar, double *gin, double &f, double *u, int flag)`.; ``` {.cpp}; typedef void(* MinuitFCN)(int &npar, double *gin, double &f, double *u, int flag); bool Fitter::SetFCN(MinuitFCN fcn, int npar,; const double * initialParameters = 0,; uns",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:48526,interface,interface,48526,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['interface'],['interface']
Integrability,"r; <https://github.com/NVIDIA/nvidia-docker>`_ to run your docker containers. Note; that you don't need nvidia-docker to build the images, but you need it in order; to have an access to GPU from a docker container that is running the built; image. If you have a different use-case, you could create your own image based on; ``example/`` folder. Any docker image can be built and run using only the docker binary, i.e. you can; run debian10 build on Fedora or any other Linux distribution. You don't need to; install CMake, compilers or any other clang dependencies. It is all handled; during the build process inside Docker's isolated environment. Stable build; ============; If you want a somewhat recent and somewhat stable build, use the; ``branches/google/stable`` branch, i.e. the following command will produce a; Debian10-based image using the latest ``google/stable`` sources for you:. .. code-block:: bash. ./llvm/utils/docker/build_docker_image.sh \; 	-s debian10 --d clang-debian10 -t ""staging"" \; 	--branch branches/google/stable \; 	-p clang -i install-clang -i install-clang-resource-headers \; 	-- \; 	-DCMAKE_BUILD_TYPE=Release. Minimizing docker image size; ============================; Due to how Docker's filesystem works, all intermediate writes are persisted in; the resulting image, even if they are removed in the following commands.; To minimize the resulting image size we use `multi-stage Docker builds; <https://docs.docker.com/develop/develop-images/multistage-build/>`_.; Internally Docker builds two images. The first image does all the work: installs; build dependencies, checks out LLVM source code, compiles LLVM, etc.; The first image is only used during build and does not have a descriptive name,; i.e. it is only accessible via the hash value after the build is finished.; The second image is our resulting image. It contains only the built binaries; and not any build dependencies. It is also accessible via a descriptive name; (specified by -d and -t flags).; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Docker.rst:7806,depend,dependencies,7806,interpreter/llvm-project/llvm/docs/Docker.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Docker.rst,2,['depend'],['dependencies']
Integrability,"r; frame giving the possibility for changing different axis attributes.; The graphics editor can be:. Embedded - connected only with the canvas in the application window; that appears on the left of the canvas window after been activated via; View menu / Editor. It appears on the left side if the canvas window; allowing users to edit the attributes of the selected object via; provided user interface. The name of the selected object is displayed; on the top of the editor frame in red color. If the user interface; needs more space then the height of the canvas window, a vertical; scroll bar appears for easer navigation. ![](pictures/03000027.png). Global - has own application window and can be connected to any; created canvas in a ROOT session. It can be activated via the context; menu entries for setting line, fill, text and marker attributes for; backward compatibility, but there will be a unique entry in the near; future. ![](pictures/03000028.png). The user interface for the following classes is available since ROOT; v.4.04: **`TAttLine`**, **`TAttFill`**, **`TAttMarker`**,; **`TAttText`**, **`TArrow`**, **`TAxis`**, **`TCurlyArc`**,; **`TCurlyLine`**, **`TFrame`**, **`TH1`**, **`TH2`**, **`TGraph`**,; **`TPad`**, **`TCanvas`**, **`TPaveStats`**. For more details, see; ""The Graphics Editor"", ""The User Interface for Histograms"", ""The User; Interface for Graphs"". ### Classes, Methods and Constructors. Object oriented programming introduces objects, which have data; members and methods. The next line creates an object named `f1` of the; class **`TF1`** that is a one-dimensional function. The type of an; object is called a class. The object itself is called an instance of a; class. When a method builds an object, it is called a constructor. ``` {.cpp}; TF1 f1(""func1"",""sin(x)/x"",0,10); ```. In our constructor the function sin(x)/x is defined for use, and 0 and; 10 are the limits. The first parameter, `func1` is the name of the; object `f1`. Most objects in ROOT have a n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:18037,interface,interface,18037,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['interface'],['interface']
Integrability,"rCalculator when checking for delgam. Negative values are allowed. This fixes a test problem given privately by A. Suter.; ; Uses also a tighter condition on edm when exiting the iterations (factor of 5 smaller). This is more consistent with conditions used by F77Minuit.; ; Fix a bug in MnCross in the standalone version of Minuit (when WARNINGMSG was not defined).; ; Fix a bug in the sign of the derivative for sine transformation which are used with double bound parameters. The bug could affect the minimization of function with user provided gradient and bound parameters and bound parameters. It could also affected Fumili2. Furthermore, a wrong sign for the correlation matrix could also have been obtained in some cases with bound parameters.; ; Use a tolerance of 0.01 instead of 0.05 in MnContours. The value of 0.01 is the same used in Minos. This is sufficient to get good quality contours.; Improve also the debug in MnContour. Add printing of points as info messages; Remove some un-necessary assert() when defining the minimization parameters.; Fix a bug in MnHesse to return the information if the matrix was made pos def. In addition change in MinimumError the condition that when the matrix was made pos def the status of the error is still considered valid and not invalid as before. This makes also the function minimum valid when a matrix was decleared pos def.; Improvements in the Minuit2Minimizer class:; . implement the new methods defined in the base class: Hess() using MnHess and CovMatrixStatus();; ; improve the switch-off of the info message according to the print level;; ; define the variables passed with zero step-size as constant (as is done in F77 Minuit); . Fix a problem in building the parallel version of Minuit2. The parallel version is built if the environment variables USE_PARALLEL_MINUIT2 and USE_OPENMP are set before compiling Minuit2 on a compiler which supports openMP (for example gcc version >= 4.2); ; Add, thanks to Alfio Lazzaro, support for ru",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v524/index.html:6485,message,messages,6485,math/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v524/index.html,2,['message'],['messages']
Integrability,rExercise.C gl/glViewerLOD.C gl/gviz3d.C gl/nucleus.C gl/viewer3DLocal.C gl/viewer3DMaster.C; gui/*.C; hist/exec1.C; hist/exec2.C; hist/tprofile2polyRealistic.C; hist/tprofile2polyRealisticModuleError.C; image/*.C; graphics/psview.C graphics/gtime.C; graphics/graph_edit_playback.C; roostats/ModelInspector.C; tree/tvdemo.C; eve/*.C; webgui/geom/geom_threejs.cxx; webgui/panel/webpanel.cxx; webgui/webwindow/webwindow.cxx); if (NOT webgui); list(APPEND gui_veto graphics/save_batch.C rcanvas/df104.py rcanvas/df105.py); endif(). if (NOT ROOT_tmva_FOUND); list(APPEND tmva_veto tmva/*.C tmva/*.py tmva/envelope/*.C tmva/keras/*.C tmva/keras/*.py tmva/pytorch/*.py ); else(); #---These do not need to run for TMVA; list(APPEND tmva_veto tmva/createData.C); if(MSVC AND NOT win_broken_tests); list(APPEND tmva_veto tmva/envelope/classification.C); endif(); #these depends on external packages; if (tmva-pymva); find_python_module(torch QUIET); find_python_module(keras QUIET); find_python_module(sonnet QUIET); find_python_module(graph_nets QUIET); find_python_module(sklearn QUIET); endif(); if (NOT PY_KERAS_FOUND); list(APPEND tmva_veto tmva/TMVA_SOFIE_Keras.C); list(APPEND tmva_veto tmva/TMVA_SOFIE_Keras_HiggsModel.C); list(APPEND tmva_veto tmva/TMVA_SOFIE_RDataFrame.C); list(APPEND tmva_veto tmva/TMVA_SOFIE_RDataFrame.py); list(APPEND tmva_veto tmva/TMVA_SOFIE_RDataFrame_JIT.C); list(APPEND tmva_veto tmva/TMVA_SOFIE_Models.py); list(APPEND tmva_veto tmva/TMVA_SOFIE_Inference.py); list(APPEND tmva_veto tmva/TMVA_SOFIE_RSofieReader.C); list(APPEND tmva_veto tmva/RBatchGenerator_TensorFlow.py); endif(); if (NOT PY_SKLEARN_FOUND); list(APPEND tmva_veto tmva/TMVA_SOFIE_Models.py); endif(); if (NOT PY_TORCH_FOUND); list(APPEND tmva_veto tmva/TMVA_SOFIE_PyTorch.C); list(APPEND tmva_veto tmva/RBatchGenerator_PyTorch.py); endif(); #veto this tutorial since it is added directly; list(APPEND tmva_veto tmva/TMVA_SOFIE_GNN_Parser.py); if (NOT PY_SONNET_FOUND OR NOT PY_GRAPH_NETS_FOUND); list(AP,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt:10306,depend,depends,10306,tutorials/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt,1,['depend'],['depends']
Integrability,"rMatcher; Matches the expression in an explicit specifier if present in the given; declaration. Given; template<bool b>; struct S {; S(int); // #1; explicit S(double); // #2; operator int(); // #3; explicit operator bool(); // #4; explicit(false) S(bool) // # 7; explicit(true) S(char) // # 8; explicit(b) S(S) // # 9; };; S(int) -> S<true> // #5; explicit S(double) -> S<false> // #6; cxxConstructorDecl(hasExplicitSpecifier(constantExpr())) will match #7, #8 and #9, but not #1 or #2.; cxxConversionDecl(hasExplicitSpecifier(constantExpr())) will not match #3 or #4.; cxxDeductionGuideDecl(hasExplicitSpecifier(constantExpr())) will not match #5 or #6. Matcher<FunctionDecl>hasParameterunsigned N, Matcher<ParmVarDecl> InnerMatcher; Matches the n'th parameter of a function or an ObjC method; declaration or a block. Given; class X { void f(int x) {} };; cxxMethodDecl(hasParameter(0, hasType(varDecl()))); matches f(int x) {}; with hasParameter(...); matching int x. For ObjectiveC, given; @interface I - (void) f:(int) y; @end. the matcher objcMethodDecl(hasParameter(0, hasName(""y""))); matches the declaration of method f with hasParameter; matching y. Matcher<FunctionDecl>hasReturnTypeLocMatcher<TypeLoc> ReturnMatcher; Matches a function declared with the specified return `TypeLoc`. Given; int f() { return 5; }; void g() {}; functionDecl(hasReturnTypeLoc(loc(asString(""int"")))); matches the declaration of `f`, but not `g`. Matcher<FunctionDecl>hasTemplateArgumentunsigned N, Matcher<TemplateArgument> InnerMatcher; Matches classTemplateSpecializations, templateSpecializationType and; functionDecl where the n'th TemplateArgument matches the given InnerMatcher. Given; template<typename T, typename U> class A {};; A<bool, int> b;; A<int, bool> c;. template<typename T> void f() {}; void func() { f<int>(); };; classTemplateSpecializationDecl(hasTemplateArgument(; 1, refersToType(asString(""int"")))); matches the specialization A<bool, int>. functionDecl(hasTemplateArgument(0, refersToTyp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:205629,interface,interface,205629,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['interface'],['interface']
Integrability,rScan.cxx; src/MnPlot.cxx; src/MnPosDef.cxx; src/MnPrint.cxx; src/MnPrintImpl.cxx; src/MnScan.cxx; src/MnSeedGenerator.cxx; src/MnStrategy.cxx; src/MnTiny.cxx; src/MnTraceObject.cxx; src/MnUserFcn.cxx; src/MnUserParameterState.cxx; src/MnUserParameters.cxx; src/MnUserTransformation.cxx; src/ModularFunctionMinimizer.cxx; src/NegativeG2LineSearch.cxx; src/Numerical2PGradientCalculator.cxx; src/NumericalDerivator.cxx; src/ParametricFunction.cxx; src/ScanBuilder.cxx; src/SimplexBuilder.cxx; src/SimplexParameters.cxx; src/SimplexSeedGenerator.cxx; src/SinParameterTransformation.cxx; src/SqrtLowParameterTransformation.cxx; src/SqrtUpParameterTransformation.cxx; src/TMinuit2TraceObject.cxx; src/VariableMetricBuilder.cxx; src/VariableMetricEDMEstimator.cxx; src/mnbins.cxx; src/mndasum.cxx; src/mndaxpy.cxx; src/mnddot.cxx; src/mndscal.cxx; src/mndspmv.cxx; src/mndspr.cxx; src/mnlsame.cxx; src/mnteigen.cxx; src/mntplot.cxx; src/mnvert.cxx; src/mnxerbla.cxx; DICTIONARY_OPTIONS; -writeEmptyRootPCM; DEPENDENCIES; MathCore; Hist; ); endif(). if(minuit2_omp); find_package(OpenMP REQUIRED); find_package(Threads REQUIRED). if(NOT TARGET OpenMP::OpenMP_CXX); add_library(OpenMP::OpenMP_CXX IMPORTED INTERFACE); set_property(TARGET OpenMP::OpenMP_CXX PROPERTY INTERFACE_COMPILE_DEFINITIONS -D_GLIBCXX_PARALLEL); set_property(TARGET OpenMP::OpenMP_CXX PROPERTY INTERFACE_COMPILE_OPTIONS ${OpenMP_CXX_FLAGS}); set_property(TARGET OpenMP::OpenMP_CXX PROPERTY INTERFACE_LINK_LIBRARIES ${OpenMP_CXX_LIBRARIES}); endif(). if(CMAKE_PROJECT_NAME STREQUAL ROOT); target_link_libraries(Minuit2 PUBLIC Threads::Threads OpenMP::OpenMP_CXX); endif(); endif(). if(minuit2_mpi); find_package(MPI REQUIRED). if(NOT TARGET MPI::MPI_CXX); add_library(MPI::MPI_CXX IMPORTED INTERFACE); set_property(TARGET MPI::MPI_CXX PROPERTY INTERFACE_COMPILE_DEFINITIONS ${MPI_CXX_COMPILE_DEFINITIONS}); set_property(TARGET MPI::MPI_CXX PROPERTY INTERFACE_COMPILE_OPTIONS ${MPI_CXX_COMPILE_FLAGS}); set_property(TARGET MPI::MPI_CXX P,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/CMakeLists.txt:5455,DEPEND,DEPENDENCIES,5455,math/minuit2/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/CMakeLists.txt,1,['DEPEND'],['DEPENDENCIES']
Integrability,"r`** called **`TMessage`**. In the following; example, we create a **`TMessage`** with the intention to store an; object, hence the constant `kMESS_OBJECT` in the constructor. We create; and fill the histogram and write it into the message. Then we call; **`TSocket`**`::Send` to send the message with the histogram. ``` {.cpp}; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; socket->Send(message);; ...; ```. On the receiving end (in our case the server side), we write a while; loop to wait and receive a message with a histogram. Once we have a; message, we call `TMessage::ReadObject`, which returns a pointer to; **`TObject`**. We have to cast it to a **`TH1`** pointer, and now we; have a histogram. At the end of the loop, the message is deleted, and; another one is created at the beginning. ``` {.cpp}; while (1) {; TMessage *message;; socket->Recv(message);; TH1 *h = (TH1*)message->ReadObject(message->GetClass());; delete message;; }; ```. ## Closing the Connection. Once we are done sending objects, we close the connection by closing the; sockets at both ends. ``` {.cpp}; Socket->Close();; ```. This diagram summarizes the steps we just covered:. ![Server - Client setting-up and closing the connection](pictures/080001FF.png). ## A Server with Multiple Sockets. Chances are that your server has to be able to receive data from; multiple clients. The class we need for this is **`TMonitor`**. It lets; you add sockets and the `TMonitor::Select` method returns the socket; with data waiting. Sockets can be added, removed, or enabled and; disabled. Here is an example of a server that has a **`TMonitor`** to; manage multiple sockets:. ``` {.cpp}; {; TServerSocket *ss = new TServerSocket (9090, kTRUE);. // Accept a connection and return",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md:2356,message,message,2356,documentation/users-guide/Networking.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md,1,['message'],['message']
Integrability,"ra choices:. - Perspective (Floor XOZ) Default. - Perspective (Floor YOZ). - Perspective (Floor XOY). In each case the perspective camera is constrained to keep the chosen; floor plane, defined by a pair of world axes, appearing level at all; times - i.e. there is no banking of the ‘horizon' that you experience; when a plane rolls. There are also three orthographic camera choices:. - Orthographic (XOY). - Orthographic (XOZ). - Orthographic (ZOY). Orthographic projections are generally constrained to look down one of; the global axes of the world, with the other two axes lying; horizontal/vertical on the viewer window. Therefore, XOY has the X-axis; horizontal, the Y-axis vertical. You can always confirm the orientation; and constraints of the camera in the world by enabling axis drawing in; the ""Guides"" tab - see sections ""Guides"" and ""Clipping"" below. For; orthographic camera a ruler-depicting current scene units is also; available. You can also pick the current camera by obtaining a handle to the GL; Viewer object behind the interface:. ``` {.cpp}; TGLViewer * v = (TGLViewer *)gPad->GetViewer3D();; ```. calling the method `TGLViewer::SetCurrentCamera` with one of the; **`TGLViewer::ECameraType` types:**. ``` {.cpp}; v->SetCurrentCamera(TGLViewer::kCameraPerspXOZ);; ```. See also `$ROOTSYS/tutorials/gl/glViewerExercise.C`. #### Adjusting Cameras. The interactions with the camera are summarized above. In each case the; interaction is listed, along with description and user actions required; to achieve it. For all cameras you can reset the original default view,; framing the entire scene, by double clicking any mouse button. ![GL Viewer camera interactions](pictures/020000DB.jpg). For the Zoom interaction you can use the following modifiers; combinations to adjust the sensitivity:. - Shiftx 10. - Ctrlx 0.1. - Shift + Ctrlx 0.01. The modifiers must be applied after the zoom action has started (right; mouse button is down). Note for orthographic cameras:. - There is no ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:110008,interface,interface,110008,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['interface'],['interface']
Integrability,"ragma clang arc_cf_code_audited begin; ...; #pragma clang arc_cf_code_audited end. All C functions declared within the extent of this pragma are treated as if; annotated with the ``cf_audited_transfer`` attribute unless they otherwise have; the ``cf_unknown_transfer`` attribute. The pragma is accepted in all language; modes. A program is ill-formed if it attempts to change files, whether by; including a file or ending the current file, within the extent of this pragma. It is possible to test for all the features in this section with; ``__has_feature(arc_cf_code_audited)``. .. admonition:: Rationale. A significant inconvenience in ARC programming is the necessity of; interacting with APIs based around C retainable pointers. These features are; designed to make it relatively easy for API authors to quickly review and; annotate their interfaces, in turn improving the fidelity of tools such as; the static analyzer and ARC. The single-file restriction on the pragma is; designed to eliminate the risk of accidentally annotating some other header's; interfaces. .. _arc.runtime:. Runtime support; ===============. This section describes the interaction between the ARC runtime and the code; generated by the ARC compiler. This is not part of the ARC language; specification; instead, it is effectively a language-specific ABI supplement,; akin to the ""Itanium"" generic ABI for C++. Ownership qualification does not alter the storage requirements for objects,; except that it is undefined behavior if a ``__weak`` object is inadequately; aligned for an object of type ``id``. The other qualifiers may be used on; explicitly under-aligned memory. The runtime tracks ``__weak`` objects which holds non-null values. It is; undefined behavior to direct modify a ``__weak`` object which is being tracked; by the runtime except through an; :ref:`objc_storeWeak <arc.runtime.objc_storeWeak>`,; :ref:`objc_destroyWeak <arc.runtime.objc_destroyWeak>`, or; :ref:`objc_moveWeak <arc.runtime.objc_moveWeak>",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:105189,interface,interfaces,105189,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['interface'],['interfaces']
Integrability,"ral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. return status;; }; ```. ### One-dimensional Integration Algorithms. Here we provide a brief description of the different integration algorithms, which are also; implemented as separate classes. The algorithms can be instantiated using the following enumeration values:. | **Enumeration name**| **Integrator class** |; |------------------------------------ |-------------------------------|; | `ROOT::Math::IntegratorOneDim::kGAUSS` | `ROOT::Math::GaussianIntegrator` |; | `ROOT::Math::IntegratorOneDim::kLEGENDRE` | `ROOT::Math:::GausLegendreIntegrator` |; | `ROOT::Math::Integration::kNONADAPTIVE` | `ROOT::Math:::GSLIntegrator` |; | `ROOT::Math::Integration::kADAPTIVE` | `ROOT::Math:::GSLIntegrator` |; | `ROOT::Math::Integration::kADAPTIVESINGULAR` | `ROOT::Math:::GSLIntegrator` |. #### ROOT::Math:::GaussIntegrator. It uses the most basic Gaussian integration algorithm, it uses the 8-point and the 16-point Gaussian; quadrature approximations. It is derived from the `DGAUSS` routine of the *CERNLIB* by S. Kolbig.; This class; Here is an example of using directly the `GaussIntegrator` class. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedTF1.h""; #include ""Math/GaussIntegrator.h"". int main(); {; TF1 f(""Sin Function"", ""sin(x)"", 0, TMath::Pi());; ROOT::Math::WrappedTF1 wf1(f);. ROOT::Math::GaussIntegrator ig;. ig.SetFunction(wf1, false);; ig.SetRelTolerance(0.001);. cout << ig.Integral(0, TMath::PiOver2()) << endl;. return 0;; }; ```; #### ROOT::Math::GaussLegendreIntegrator. This class implementes the Gauss-Legendre quadrature formulas. This sort of numerical methods requieres that the user specifies the number of intermediate function points; used in the calculation of the integral. It will automatically determine the coordinates and weights of such points before performing the integration.; We can use the example above, but replacing the creation of a `ROOT:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:53442,integrat,integration,53442,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['integrat'],['integration']
Integrability,"ral::. module MyLib {; module Base {; header ""Base.h""; }. module Derived {; header ""Derived.h""; export Base; }; }. Note that, if ``Derived.h`` includes ``Base.h``, one can simply use a wildcard export to re-export everything ``Derived.h`` includes:. .. parsed-literal::. module MyLib {; module Base {; header ""Base.h""; }. module Derived {; header ""Derived.h""; export *; }; }. .. note::. The wildcard export syntax ``export *`` re-exports all of the; modules that were imported in the actual header file. Because; ``#include`` directives are automatically mapped to module imports,; ``export *`` provides the same transitive-inclusion behavior; provided by the C preprocessor, e.g., importing a given module; implicitly imports all of the modules on which it depends.; Therefore, liberal use of ``export *`` provides excellent backward; compatibility for programs that rely on transitive inclusion (i.e.,; all of them). Re-export Declaration; ~~~~~~~~~~~~~~~~~~~~~; An *export-as-declaration* specifies that the current module will have; its interface re-exported by the named module. .. parsed-literal::. *export-as-declaration*:; ``export_as`` *identifier*. The *export-as-declaration* names the module that the current; module will be re-exported through. Only top-level modules; can be re-exported, and any given module may only be re-exported; through a single module. **Example:** In the following example, the module ``MyFrameworkCore``; will be re-exported via the module ``MyFramework``:. .. parsed-literal::. module MyFrameworkCore {; export_as MyFramework; }. Use declaration; ~~~~~~~~~~~~~~~; A *use-declaration* specifies another module that the current top-level module; intends to use. When the option *-fmodules-decluse* is specified, a module can; only use other modules that are explicitly specified in this way. .. parsed-literal::. *use-declaration*:; ``use`` *module-id*. **Example:** In the following example, use of A from C is not declared, so will trigger a warning. .. parsed-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:43944,interface,interface,43944,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['interface'],['interface']
Integrability,"ram' ASTs depending on how they use the APIs. This depends; on libast and libparse. librewrite - Fast, scalable rewriting of source code. This operates on; the raw syntactic text of source code, allowing a client; to insert and delete text in very large source files using; the same source location information embedded in ASTs. This; is intended to be a low-level API that is useful for; higher-level clients and libraries such as code refactoring. libanalysis - Source-level dataflow analysis useful for performing analyses; such as computing live variables. It also includes a; path-sensitive ""graph-reachability"" engine for writing; analyses that reason about different possible paths of; execution through source code. This is currently being; employed to write a set of checks for finding bugs in software. libcodegen - Lower the AST to LLVM IR for optimization & codegen. Depends; on libast.; ; clang - An example driver, client of the libraries at various levels.; This depends on all these libraries, and on LLVM VMCore. This front-end has been intentionally built as a DAG of libraries, making it; easy to reuse individual parts or replace pieces if desired. For example, to; build a preprocessor, you take the Basic and Lexer libraries. If you want an; indexer, you take those plus the Parser library and provide some actions for; indexing. If you want a refactoring, static analysis, or source-to-source; compiler tool, it makes sense to take those plus the AST building and semantic; analyzer library. Finally, if you want to use this with the LLVM backend,; you'd take these components plus the AST to LLVM lowering code.; ; In the future I hope this toolkit will grow to include new and interesting; components, including a C++ front-end, ObjC support, and a whole lot of other; things. Finally, it should be pointed out that the goal here is to build something that; is high-quality and industrial-strength: all the obnoxious features of the C; family must be correctly supported (tri",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2007-OriginalClangReadme.txt:3120,depend,depends,3120,interpreter/llvm-project/llvm/docs/HistoricalNotes/2007-OriginalClangReadme.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2007-OriginalClangReadme.txt,1,['depend'],['depends']
Integrability,"ransformations defined as a; composition between a rotation and a translation using the class; **`ROOT::Math::Transform3D`**. It is important to note that; transformations act differently on vectors and points. The vectors only; rotate, therefore when applying a transformation (rotation +; translation) on a vector, only the rotation operates while the; translation has no effect. The **`Transform3D`** class interface is; similar to the one used in the CLHEP Geometry package (class; <HepGeom::Transform3D>). - Lorentz rotation:. - generic Lorentz rotation described by a `4x4` matrix containing a 3D; rotation part and a boost part (class; **`ROOT::Math::LorentzRotation`**). - a pure boost in an arbitrary direction and described by a 4x4; symmetric matrix or 10 numbers (class **`ROOT::Math::Boost`**). - boost along the axis:` x `(**`ROOT::Math::BoostX`**),; `y `(**`ROOT::Math::BoostY`**) and `z `(**`ROOT::Math::BoostZ`**). #### Minimal Vector Classes Interface. We have tried to keep the interface to a minimal level by:. - Avoiding methods that provide the same functionality but use; different names (like `getX()` and `x()`). - Minimizing the number of setter methods, avoiding methods, which can; be ambiguous and can set the vector classes in an inconsistent; state. We provide only methods which set all the coordinates at the; same time or set only the coordinates on which the vector is based,; for example `SetX()` for a Cartesian vector. We then enforce the use; of transformations as rotations or translations (additions) for; modifying the vector contents. - The majority of the functionality, which is present in the CLHEP; package, involving operations on two vectors, is moved in separated; helper functions (see `ROOT::Math::VectorUtil`). This has the; advantage that the basic interface will remain more stable with time; while additional functions can be added easily. #### Naming Convention. As part of ROOT, the `GenVector` package adheres to the prescribed ROOT; naming ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:74658,interface,interface,74658,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['interface'],['interface']
Integrability,"ransforms. Divergent Branch inside a Cycle; -------------------------------. .. figure:: convergence-divergent-inside.png; :name: convergence-divergent-inside. The above figure shows a divergent branch ``Q`` inside an irreducible; cyclic region. When two threads diverge at ``Q``, the convergence of; dynamic instances within the cyclic region depends on the cycle; hierarchy chosen:. 1. In an implementation that detects a single cycle ``C`` with header; ``P``, convergence inside the cycle is determined by ``P``. 2. In an implementation that detects two nested cycles with headers; ``R`` and ``S``, convergence inside those cycles is determined by; their respective headers. .. _convergence-diverged-entry:. A conservative approach would be to simply report all nodes inside; irreducible cycles as having divergent outputs. But it is desirable to; recognize m-converged nodes in the CFG in order to maximize; uniformity. This section describes one such pattern of nodes derived; from *closed paths*, which are a property of the CFG and do not depend; on the cycle hierarchy. **Diverged Entry Criterion:**. The dynamic instances of all the nodes in a closed path ``P`` are; m-converged only if for every divergent branch ``B`` and its; join node ``J`` that lie on ``P``, there is no entry to ``P`` which; lies on a diverged path from ``B`` to ``J``. .. figure:: convergence-closed-path.png; :name: convergence-closed-path. Consider the closed path ``P -> Q -> R -> S`` in the above figure.; ``P`` and ``R`` are :ref:`entries to the closed; path<cycle-closed-path>`. ``Q`` is a divergent branch and ``S`` is a; join for that branch, with diverged paths ``Q -> R -> S`` and ``Q ->; S``. - If a diverged entry ``R`` exists, then in some cycle hierarchy,; ``R`` is the header of the smallest cycle ``C`` containing the; closed path and a :ref:`child cycle<cycle-definition>` ``C'``; exists in the set ``C - R``, containing both branch ``Q`` and join; ``S``. When threads diverge at ``Q``, one subset ``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst:21904,depend,depend,21904,interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,1,['depend'],['depend']
Integrability,"rate over ; the instlist, and access the instructions through the instlist. To add or remove an instruction from a basic block, we need to get an ; iterator to an instruction, which, given just an Instruction*, requires a ; linear search of the basic block the instruction is contained in... just ; to insert an instruction before another instruction, or to delete an ; instruction! This complicates algorithms that should be very simple (like ; simple constant propagation), because they aren't actually sparse anymore,; they have to traverse basic blocks to remove constant propogated ; instructions. Additionally, adding or removing instructions to a basic block ; _invalidates all iterators_ pointing into that block, which is really ; irritating. To fix these problems (and others), I would like to make the ordering of; the instructions be represented with a doubly linked list in the; instructions themselves, instead of an external data structure. This is ; how many other representations do it, and frankly I can't remember why I ; originally implemented it the way I did. Long term, all of the code that depends on the nasty features in the ; instruction list (which can be found by grep'ing for getInstList()) will ; be changed to do nice local transformations. In the short term, I'll ; change the representation, but preserve the interface (including ; getInstList()) so that all of the code doesn't have to change. Iteration over the instructions in a basic block remains the simple:; for (BasicBlock::iterator I = BB->begin(), E = BB->end(); I != E; ++I) ... But we will also support:; for (Instruction *I = BB->front(); I; I = I->getNext()) ... After converting instructions over, I'll convert basic blocks and ; functions to have a similar interface. The only negative aspect of this change that I see is that it increases ; the amount of memory consumed by one pointer per instruction. Given the ; benefits, I think this is a very reasonable tradeoff. . What do you think?. -Chris; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2002-05-12-InstListChange.txt:1633,depend,depends,1633,interpreter/llvm-project/llvm/docs/HistoricalNotes/2002-05-12-InstListChange.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2002-05-12-InstListChange.txt,3,"['depend', 'interface']","['depends', 'interface']"
Integrability,"rated. A runtime library containing these atomics functions is; necessary for such programs. compiler-rt (LLVM); ^^^^^^^^^^^^^^^^^^. compiler-rt contains an implementation of an atomics library. libatomic (GNU); ^^^^^^^^^^^^^^^. libgcc_s does not provide an implementation of an atomics library. Instead,; `GCC's libatomic library <https://gcc.gnu.org/wiki/Atomic/GCCMM>`_ can be; used to supply these when using libgcc_s. .. note::. Clang does not currently automatically link against libatomic when using; libgcc_s. You may need to manually add ``-latomic`` to support this; configuration when using non-native atomic operations (if you see link errors; referring to ``__atomic_*`` functions). Unwind library; --------------. The unwind library provides a family of ``_Unwind_*`` functions implementing; the language-neutral stack unwinding portion of the Itanium C++ ABI; (`Level I <https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html#base-abi>`_).; It is a dependency of the C++ ABI library, and sometimes is a dependency; of other runtimes. libunwind (LLVM); ^^^^^^^^^^^^^^^^. LLVM's unwinder library is part of the llvm-project git repository. To; build it, pass ``-DLLVM_ENABLE_RUNTIMES=libunwind`` to the cmake invocation. If using libc++abi, you may need to configure it to use libunwind; rather than libgcc_s by passing ``-DLIBCXXABI_USE_LLVM_UNWINDER=YES``; to ``cmake``. If libc++abi is configured to use some version of; libunwind, that library will be implicitly linked into binaries that; link to libc++abi. libgcc_s (GNU); ^^^^^^^^^^^^^^. libgcc_s has an integrated unwinder, and does not need an external unwind; library to be provided. libunwind (nongnu.org); ^^^^^^^^^^^^^^^^^^^^^^. This is another implementation of the libunwind specification.; See `libunwind (nongnu.org) <https://www.nongnu.org/libunwind>`_. libunwind (PathScale); ^^^^^^^^^^^^^^^^^^^^^. This is another implementation of the libunwind specification.; See `libunwind (pathscale) <https://github.com/pathscale",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:8532,depend,dependency,8532,interpreter/llvm-project/clang/docs/Toolchain.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst,2,['depend'],['dependency']
Integrability,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<ArraySubscriptExpr>hasBaseMatcher<Expr> InnerMatcher; Matches the base expression of an array subscript expression. Given; int i[5];; void f() { i[1] = 42; }; arraySubscriptExpression(hasBase(implicitCastExpr(; hasSourceExpression(declRefExpr())))); matches i[1] with the declRefExpr() matching i. Matcher<ArraySubscriptExpr>hasIndexMatcher<Expr> InnerMatcher; Matches the index expression of an array subscript expression. Given; int i[5];; void f() { i[1] = 42; }; arraySubscriptExpression(hasIndex(integerLiteral())); matches i[1] with the integerLiteral() matching 1. Matcher<ArraySubscriptExpr>hasLHSMatcher<Expr> InnerMatcher; Matches the left hand side of binary operator expressions. Example matches a (matcher = binaryOperator(hasLHS())); a || b. Matcher<ArraySubscriptExpr>hasRHSMa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:138659,Inject,InjectedClassNameType,138659,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Inject'],['InjectedClassNameType']
Integrability,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<CXXConstructorDecl>forEachConstructorInitializerMatcher<CXXCtorInitializer> InnerMatcher; Matches each constructor initializer in a constructor definition. Given; class A { A() : i(42), j(42) {} int i; int j; };; cxxConstructorDecl(forEachConstructorInitializer(; forField(decl().bind(""x"")); )); will trigger two matches, binding for 'i' and 'j' respectively. Matcher<CXXConstructorDecl>hasAnyConstructorInitializerMatcher<CXXCtorInitializer> InnerMatcher; Matches a constructor initializer. Given; struct Foo {; Foo() : foo_(1) { }; int foo_;; };; cxxRecordDecl(has(cxxConstructorDecl(; hasAnyConstructorInitializer(anything()); ))); record matches Foo, hasAnyConstructorInitializer matches foo_(1). Matcher<CXXCtorInitializer>forFieldMatcher<FieldDecl> InnerMatcher; Matches the field decl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:150206,Inject,InjectedClassNameType,150206,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Inject'],['InjectedClassNameType']
Integrability,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<CXXNewExpr>hasPlacementArgunsigned Index, Matcher<Expr> InnerMatcher; Matches placement new expression arguments. Given:; MyClass *p1 = new (Storage, 16) MyClass();; cxxNewExpr(hasPlacementArg(1, integerLiteral(equals(16)))); matches the expression 'new (Storage, 16) MyClass()'. Matcher<CXXNewExpr>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitia",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:163310,Inject,InjectedClassNameType,163310,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Inject'],['InjectedClassNameType']
Integrability,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<CaseStmt>hasCaseConstantMatcher<Expr> InnerMatcher; If the given case statement does not use the GNU case range; extension, matches the constant given in the statement. Given; switch (1) { case 1: case 1+1: case 3 ... 4: ; }; caseStmt(hasCaseConstant(integerLiteral())); matches ""case 1:"". Matcher<CastExpr>hasSourceExpressionMatcher<Expr> InnerMatcher; Matches if the cast's source expression; or opaque value's source expression matches the given matcher. Example 1: matches ""a string""; (matcher = castExpr(hasSourceExpression(cxxConstructExpr()))); class URL { URL(string); };; URL url = ""a string"";. Example 2: matches 'b' (matcher =; opaqueValueExpr(hasSourceExpression(implicitCastExpr(declRefExpr()))); int a = b ?: 1;. Matcher<ClassTemplateSpecializationDecl>forEachTemplateArgumentc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:176505,Inject,InjectedClassNameType,176505,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Inject'],['InjectedClassNameType']
Integrability,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<DeclRefExpr>hasTemplateArgumentLocunsigned Index, Matcher<TemplateArgumentLoc> InnerMatcher; Matches template specialization `TypeLoc`s where the n'th; `TemplateArgumentLoc` matches the given `InnerMatcher`. Given; template<typename T, typename U> class A {};; A<double, int> b;; A<int, double> c;; varDecl(hasTypeLoc(templateSpecializationTypeLoc(hasTemplateArgumentLoc(0,; hasTypeLoc(loc(asString(""double""))))))); matches `A<double, int> b`, but not `A<int, double> c`. Matcher<DeclRefExpr>throughUsingDeclMatcher<UsingShadowDecl> Inner; Matches if a node refers to a declaration through a specific; using shadow declaration. Examples:; namespace a { int f(); }; using a::f;; int x = f();; declRefExpr(throughUsingDecl(anything())); matches f. namespace a { class X{}; }; using a::X;; X x;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:184219,Inject,InjectedClassNameType,184219,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Inject'],['InjectedClassNameType']
Integrability,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<ExplicitCastExpr>hasDestinationTypeMatcher<QualType> InnerMatcher; Matches casts whose destination type matches a given matcher. (Note: Clang's AST refers to other conversions as ""casts"" too, and calls; actual casts ""explicit"" casts.). Matcher<ExplicitCastExpr>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:191717,Inject,InjectedClassNameType,191717,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Inject'],['InjectedClassNameType']
Integrability,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<LabelStmt>hasDeclarationMatcher<Decl> InnerMatcher; Matches a node if the declaration associated with that node; matches the given matcher. The associated declaration is:; - for type nodes, the declaration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be ach",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:210160,Inject,InjectedClassNameType,210160,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Inject'],['InjectedClassNameType']
Integrability,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<LambdaCapture>capturesVarMatcher<ValueDecl> InnerMatcher; Matches a `LambdaCapture` that refers to the specified `VarDecl`. The; `VarDecl` can be a separate variable that is captured by value or; reference, or a synthesized variable if the capture has an initializer. Given; void foo() {; int x;; auto f = [x](){};; auto g = [x = 1](){};; }; In the matcher; lambdaExpr(hasAnyCapture(lambdaCapture(capturesVar(hasName(""x"")))),; capturesVar(hasName(""x"")) matches `x` and `x = 1`. Matcher<LambdaExpr>forEachLambdaCaptureMatcher<LambdaCapture> InnerMatcher; Matches each lambda capture in a lambda expression. Given; int main() {; int x, y;; float z;; auto f = [=]() { return x + y + z; };; }; lambdaExpr(forEachLambdaCapture(; lambdaCapture(capturesVar(varDecl(hasType(isInteger())))))); will t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:211568,Inject,InjectedClassNameType,211568,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Inject'],['InjectedClassNameType']
Integrability,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<MemberExpr>hasObjectExpressionMatcher<Expr> InnerMatcher; Matches a member expression where the object expression is matched by a; given matcher. Implicit object expressions are included; that is, it matches; use of implicit `this`. Given; struct X {; int m;; int f(X x) { x.m; return m; }; };; memberExpr(hasObjectExpression(hasType(cxxRecordDecl(hasName(""X""))))); matches `x.m`, but not `m`; however,; memberExpr(hasObjectExpression(hasType(pointsTo(; cxxRecordDecl(hasName(""X"")))))); matches `m` (aka. `this->m`), but not `x.m`. Matcher<MemberExpr>memberMatcher<ValueDecl> InnerMatcher; Matches a member expression where the member is matched by a; given matcher. Given; struct { int first, second; } first, second;; int i(second.first);; int j(first.second);; memberExpr(member(hasName(""",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:214167,Inject,InjectedClassNameType,214167,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Inject'],['InjectedClassNameType']
Integrability,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<QualType>ignoringParensMatcher<QualType> InnerMatcher; Matches types that match InnerMatcher after any parens are stripped. Given; void (*fp)(void);; The matcher; varDecl(hasType(pointerType(pointee(ignoringParens(functionType()))))); would match the declaration for fp. Matcher<QualType>pointsToMatcher<Decl> InnerMatcher; Overloaded to match the pointee type's declaration. Matcher<QualType>pointsToMatcher<QualType> InnerMatcher; Matches if the matched type is a pointer type and the pointee type; matches the specified matcher. Example matches y->x(); (matcher = cxxMemberCallExpr(on(hasType(pointsTo; cxxRecordDecl(hasName(""Y""))))))); class Y { public: void x(); };; void z() { Y *y; y->x(); }. Matcher<QualType>referencesMatcher<Decl> InnerMatcher; Overloaded to match the referenced t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:227551,Inject,InjectedClassNameType,227551,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Inject'],['InjectedClassNameType']
Integrability,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<ReferenceTypeLoc>hasReferentLocMatcher<TypeLoc> ReferentMatcher; Matches reference `TypeLoc`s that have a referent `TypeLoc` matching; `ReferentMatcher`. Given; int x = 3;; int& xx = x;; referenceTypeLoc(hasReferentLoc(loc(asString(""int"")))); matches `int&`. Matcher<ReferenceType>pointeeMatcher<Type>; Narrows PointerType (and similar) matchers to those where the; pointee matches a given matcher. Given; int *a;; int const *b;; float const *f;; pointerType(pointee(isConstQualified(), isInteger())); matches ""int const *b"". Usable as: Matcher<BlockPointerType>, Matcher<MemberPointerType>,; Matcher<PointerType>, Matcher<ReferenceType>. Matcher<ReturnStmt>hasReturnValueMatcher<Expr> InnerMatcher; Matches the return value expression of a return statement. Given; return a + b;; hasReturnV",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:230434,Inject,InjectedClassNameType,230434,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Inject'],['InjectedClassNameType']
Integrability,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<TemplateArgumentLoc>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropert",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:236306,Inject,InjectedClassNameType,236306,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Inject'],['InjectedClassNameType']
Integrability,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<TemplateSpecializationType>hasTemplateArgumentunsigned N, Matcher<TemplateArgument> InnerMatcher; Matches classTemplateSpecializations, templateSpecializationType and; functionDecl where the n'th TemplateArgument matches the given InnerMatcher. Given; template<typename T, typename U> class A {};; A<bool, int> b;; A<int, bool> c;. template<typename T> void f() {}; void func() { f<int>(); };; classTemplateSpecializationDecl(hasTemplateArgument(; 1, refersToType(asString(""int"")))); matches the specialization A<bool, int>. functionDecl(hasTemplateArgument(0, refersToType(asString(""int"")))); matches the specialization f<int>. Matcher<TemplateTypeParmType>hasDeclarationMatcher<Decl> InnerMatcher; Matches a node if the declaration associated with that node; matches the given matcher. The",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:242851,Inject,InjectedClassNameType,242851,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Inject'],['InjectedClassNameType']
Integrability,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<Type>hasUnqualifiedDesugaredTypeMatcher<Type> InnerMatcher; Matches if the matched type matches the unqualified desugared; type of the matched node. For example, in:; class A {};; using B = A;; The matcher type(hasUnqualifiedDesugaredType(recordType())) matches; both B and A. Matcher<UnaryExprOrTypeTraitExpr>hasArgumentOfTypeMatcher<QualType> InnerMatcher; Matches unary expressions that have a specific type of argument. Given; int a, c; float b; int s = sizeof(a) + sizeof(b) + alignof(c);; unaryExprOrTypeTraitExpr(hasArgumentOfType(asString(""int"")); matches sizeof(a) and alignof(c). Matcher<UnaryOperator>hasUnaryOperandMatcher<Expr> InnerMatcher; Matches if the operand of a unary operator matches. Example matches true (matcher = hasUnaryOperand(; cxxBoolLiteral(equals(true)))); !t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:247886,Inject,InjectedClassNameType,247886,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Inject'],['InjectedClassNameType']
Integrability,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<TypeLoc>locMatcher<QualType> InnerMatcher; Matches TypeLocs for which the given inner; QualType-matcher matches. Matcher<TypedefNameDecl>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecial",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:244907,Inject,InjectedClassNameType,244907,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Inject'],['InjectedClassNameType']
Integrability,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<UsingShadowDecl>hasTargetDeclMatcher<NamedDecl> InnerMatcher; Matches a using shadow declaration where the target declaration is; matched by the given matcher. Given; namespace X { int a; void b(); }; using X::a;; using X::b;; usingDecl(hasAnyUsingShadowDecl(hasTargetDecl(functionDecl()))); matches using X::b but not using X::a ; Matcher<UsingType>hasUnderlyingTypeMatcher<Type>; Matches DecltypeType or UsingType nodes to find the underlying type. Given; decltype(1) a = 1;; decltype(2.0) b = 2.0;; decltypeType(hasUnderlyingType(isInteger())); matches the type of ""a"". Usable as: Matcher<DecltypeType>, Matcher<UsingType>. Matcher<UsingType>throughUsingDeclMatcher<UsingShadowDecl> Inner; Matches if a node refers to a declaration through a specific; using shadow declaration. Examples:;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:250658,Inject,InjectedClassNameType,250658,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Inject'],['InjectedClassNameType']
Integrability,"raw option for `TH3`, configures logarithmic scale for box volume; 4. Implement color palette drawing for `TH3`; 5. Implement cutg draw option for `TH2`/`TF2` surface plots; 6. Implement `TMath::Sq()` function and several others like SinH, ASinH, ...; 7. Implement histogram drawing build from `TGraph2D` using Delaunay interpolation; 8. Provide preliminary `TF3` support; 9. Support `TLinearGradient` and `TRadialGradient` colors; 10. Support LZMA decompression of ROOT files #272; 11. Include ZSTD decompression to repository #274; 12. Support opacity transfer function for `TH3`, see tutorials/gl/glvox2.C; 13. Upgrade three.js r155 -> r158; 14. Handle TCanvas IsEdiatable flag to disable some interactive features; 15. Support PDF creation using jsPDF and svg2pdf.js - in browser and node.js; 16. Implement custom fonts support in TWebCanvas; 17. List of ROOT/JSON files on server with `&dir=<path>` URL parameter #283; 18. Load TGaxis function from the file #282; 19. Let display progress messages in modal element #285; 20. Fix - do not add `THStack` and `TMultiGraph` to legend; 21. Fix - correctly use margin in `TPaveText` class; 22. Fix - correctly draw endcaps in legend errors; 23. Fix - vertical position of up elements like {M}^{2} in TLatex; 24. Fix - let draw THStack with diff binning hists; 25. Fix - better tooltip name for the items; 26. Fix - better logy scale selection. ## Changes in 7.5.5; 1. Fix - abort tree draw operation faster; 2. Fix - support plain TRI option for TGraph2D; 3. Fix - use latest npm ""gl"" module. ## Changes in 7.5.4; 1. Fix - catch exception when parsing TF1 formula; 2. Fix - properly check THStack histograms axes when doing sum; 3. Fix - correctly handle negative offset on time axis; 4. Fix - do not use `inset` because of old Chrome browsers; 5. Fix - properly provide object hints. ## Changes in 7.5.3; 1. Fix - draw histograms with negative bins #276; 2. Fix - correctly read TLeaf with fixed-size array; 3. Fix - bug in options handling in startGU",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:7008,message,messages,7008,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['message'],['messages']
Integrability,"rcuit semantics). MC/DC builds on top of branch coverage and; requires that all code blocks and all execution paths have been tested. This; statistic is hidden by default in reports, but it can be enabled via the; ``-show-mcdc-summary`` option as long as code was also compiled using the; clang option ``-fcoverage-mcdc``. * Boolean expressions that are only comprised of one condition (and therefore; have no logical operators) are not included in MC/DC analysis and are; trivially deducible using branch coverage. Of these six statistics, function coverage is usually the least granular while; branch coverage (with MC/DC) is the most granular. 100% branch coverage for a; function implies 100% region coverage for a function. The project-wide totals; for each statistic are listed in the summary. Format compatibility guarantees; ===============================. * There are no backwards or forwards compatibility guarantees for the raw; profile format. Raw profiles may be dependent on the specific compiler; revision used to generate them. It's inadvisable to store raw profiles for; long periods of time. * Tools must retain **backwards** compatibility with indexed profile formats.; These formats are not forwards-compatible: i.e, a tool which uses format; version X will not be able to understand format version (X+k). * Tools must also retain **backwards** compatibility with the format of the; coverage mappings emitted into instrumented binaries. These formats are not; forwards-compatible. * The JSON coverage export format has a (major, minor, patch) version triple.; Only a major version increment indicates a backwards-incompatible change. A; minor version increment is for added functionality, and patch version; increments are for bugfixes. Impact of llvm optimizations on coverage reports; ================================================. llvm optimizations (such as inlining or CFG simplification) should have no; impact on coverage report quality. This is due to the fact that th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:13831,depend,dependent,13831,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,1,['depend'],['dependent']
Integrability,"rd C++ headers?; N/A. 371; open; Interleaving of constructor calls; Not resolved. 372; CD1; Is access granted by base class specifiers available in following base class specifiers?; No. 373; C++11; Lookup on namespace qualified name in using-directive; Clang 5. 374; CD2; Can explicit specialization outside namespace use qualified name?; Clang 7. 375; dup; Confusing example on lookup with typename; Duplicate of 345. 376; NAD; Class ""definition"" versus class ""declaration""; N/A. 377; CD1; Enum whose enumerators will not fit in any integral type; Yes. 378; CD1; Wording that says temporaries are declared; Duplicate of 276. 379; CD1; Change ""class declaration"" to ""class definition""; N/A. 380; open; Definition of ""ambiguous base class"" missing; Not resolved. 381; CD1; Incorrect example of base class member lookup; Yes. 382; CD1; Allow typename outside of templates; Yes (C++11 onwards). 383; CD1; Is a class with a declared but not defined destructor a POD?; Yes. 384; NAD; Argument-dependent lookup and operator functions; Yes. 385; CD1; How does protected member check of 11.5 interact with using-declarations?; Clang 2.8. 386; CD6; Friend declaration of name brought in by using-declaration; Unknown. 387; CD1; Errors in example in 14.6.5; Clang 2.8. 388; CD3; Catching base*& from a throw of derived*; Unknown. 389; CD1; Unnamed types in entities with linkage; No. 390; CD1; Pure virtual must be defined when implicitly called; Clang 3.3. 391; CD1; Require direct binding of short-lived references to rvalues; Clang 2.8 (C++11 onwards). 392; CD1; Use of full expression lvalue before temporary destruction; Unknown. 393; CD4; Pointer to array of unknown bound in template argument list in parameter; Unknown. 394; CD1; identifier-list is never defined; N/A. 395; NAD; Conversion operator template syntax; Clang 3.0. 396; CD1; Misleading note regarding use of auto for disambiguation; Yes. 397; CD1; Same address for string literals from default arguments in inline functions?; Superseded by 1",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:25729,depend,dependent,25729,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['depend'],['dependent']
Integrability,"re 64 kB for the page size and 50 MB for the cluster size (PR [#8703](https://github.com/root-project/root/pull/8703)).; - Storing objects of user-defined classes via `TClass` now also includes members inherited from all the base classes (PR [#8552](https://github.com/root-project/root/pull/8552)).; - Support for RFields whose type is a typedef to some other type. ## RDataFrame. ### New features. - Add [`Redefine`](https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html#a4e882a949c8a1022a38ec6936c2ff29c) to the `RDataFrame` interface, which allows to overwrite the value of an existing column.; - Add [`Describe`](https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html#a53f3e3d81e041a804481df228fe0081c) to the `RDataFrame` interface, which allows to get useful information, e.g. the columns and their types.; - Add [`DescribeDataset`](https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html#a1bc5b86a2a834bb06711fb535451146d) to the `RDataFrame` interface, which allows to get information about the dataset (subset of the output of Describe()).; - Add [`DefinePerSample`](https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html#a29d77593e95c0f84e359a802e6836a0e), a method which makes it possible to define columns based on the sample and entry range being processed. It is also a useful way to register callbacks that should only be called when the input dataset/TTree changes.; - Add [`HistoND`](https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html#a0c9956a0f48c26f8e4294e17376c7fea) action that fills a N-dimensional histogram.; - `Book` now supports just-in-time compilation, i.e. it can be called without passing the column types as template parameters (with some performance penalty, as usual).; - As an aid to `RDataSource` implementations with which collection sizes can be retrieved more efficiently than the full collection, `#var` can now be used as a short-hand notation for column name `R_rdf_sizeof_var`.; - Helpers have been adde",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:7753,interface,interface,7753,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['interface'],['interface']
Integrability,"re additional areas that LLVM does not directly address:. * Registration of global roots with the runtime. * Registration of stack map entries with the runtime. * The functions used by the program to allocate memory, trigger a collection,; etc. * Computation or compilation of type maps, or registration of them with the; runtime. These are used to crawl the heap for object references. In general, LLVM's support for GC does not include features which can be; adequately addressed with other features of the IR and does not specify a; particular binary interface. On the plus side, this means that you should be; able to integrate LLVM with an existing runtime. On the other hand, it can; have the effect of leaving a lot of work for the developer of a novel; language. We try to mitigate this by providing built in collector strategy; descriptions that can work with many common collector designs and easy; extension points. If you don't already have a specific binary interface; you need to support, we recommend trying to use one of these built in collector; strategies. .. _gc_intrinsics:. LLVM IR Features; ================. This section describes the garbage collection facilities provided by the; :doc:`LLVM intermediate representation <LangRef>`. The exact behavior of these; IR features is specified by the selected :ref:`GC strategy description; <plugin>`. Specifying GC code generation: ``gc ""...""``; -------------------------------------------. .. code-block:: text. define <returntype> @name(...) gc ""name"" { ... }. The ``gc`` function attribute is used to specify the desired GC strategy to the; compiler. Its programmatic equivalent is the ``setGC`` method of ``Function``. Setting ``gc ""name""`` on a function triggers a search for a matching subclass; of GCStrategy. Some collector strategies are built in. You can add others; using either the loadable plugin mechanism, or by patching your copy of LLVM.; It is the selected GC strategy which defines the exact nature of the code; ge",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:8052,interface,interface,8052,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['interface'],['interface']
Integrability,"re and submit the bug description if it doesn't exist; Open tasks; We have lots of ideas how to make cling better, but we don't have enough time for realizing them all. Here are tasks that are on our todo lists since a while, but we still cannot manage to get them done. They are not difficult to implement and excellent for getting to know cling. If you find something interesting, please go ahead and get your hands dirty!; The list is prioritized in descending order:; Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on.; Implementing auto completion - Clang has good interface for autocompletion which proposes possible completion options considering the current input.; Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int i; error_here;. int i should be reverted and the entire input should be invalidated. This is very complex because many implicit template instantiations could be triggered and so on. The idea of the future verifier is to serialize the AST with all the lookup structures (probably in pch or pcm), trigger an error causing a lot of things to happen in clang internally and serialize the new AST. The comparison with the old one must return perfect match.; Enabling clang's static analyzer - coming soon; Enabling ObjectiveC/ObjectiveC++ support - coming soon. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html:1601,interface,interface,1601,interpreter/cling/www/old/contact.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/contact.html,2,['interface'],['interface']
Integrability,"re is an example of a folder's path name:. `//root/Event/Hits/TCP`. One does not have to specify the full path name. If the partial path; name is unique, it will find it; otherwise it will return the first; occurrence of the path. The first diagram shows a system without folders. The objects have; pointers to each other to access each other's data. Pointers are an; efficient way to share data between classes. However, a direct pointer; creates a direct coupling between classes. This design can become a very; tangled web of dependencies in a system with a large number of classes. ![](pictures/020000E2.jpg). In the second diagram, a reference to the data is in the folder and the; consumers refer to the folder rather than each other to access the data.; The naming and search service provided by the ROOT folders hierarchy; provides an alternative. It loosely couples the classes and greatly; enhances I/O operations. In this way, folders separate the data from the; algorithms and greatly improve the modularity of an application by; minimizing the class dependencies. ![](pictures/020000E3.jpg). In addition, the folder hierarchy creates a picture of the data; organization. This is useful when discussing data design issues or when; learning the data organization. The example below illustrates this; point. ## How to Use Folders. Using folders means to build a hierarchy of folders, posting the; reference to the data in the folder by the producer, and creating a; reference to the folder by the user. ### Creating a Folder Hierarchy. To create a folder hierarchy you add the top folder of your hierarchy to; `//root`. Then you add a folder to an existing folder with the; **`TFolder::AddFolder`** method. This method takes two parameters: the; name and title of the folder to be added. It returns a pointer of the; newly created folder. The code below creates the folder hierarchy shown in the browser. In; this macro, the folder is also added to the list of browsable. This way,; it is v",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md:1952,depend,dependencies,1952,documentation/users-guide/FoldersTasks.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md,1,['depend'],['dependencies']
Integrability,"re is only defined to work sensibly for ELF targets. * If section name is specified through _attribute_((section(""myname""))), then; the attribute name gains precedence. * Global variables that are initialized to zero will be placed in the named; bss section, if one is present. * The ``#pragma clang section`` directive does not does try to infer section-kind; from the name. For example, naming a section ""``.bss.mySec``"" does NOT mean; it will be a bss section name. * The decision about which section-kind applies to each global is taken in the back-end.; Once the section-kind is known, appropriate section name, as specified by the user using; ``#pragma clang section`` directive, is applied to that global. Specifying Linker Options on ELF Targets; ========================================. The ``#pragma comment(lib, ...)`` directive is supported on all ELF targets.; The second parameter is the library name (without the traditional Unix prefix of; ``lib``). This allows you to provide an implicit link of dependent libraries. Evaluating Object Size Dynamically; ==================================. Clang supports the builtin ``__builtin_dynamic_object_size``, the semantics are; the same as GCC's ``__builtin_object_size`` (which Clang also supports), but; ``__builtin_dynamic_object_size`` can evaluate the object's size at runtime.; ``__builtin_dynamic_object_size`` is meant to be used as a drop-in replacement; for ``__builtin_object_size`` in libraries that support it. For instance, here is a program that ``__builtin_dynamic_object_size`` will make; safer:. .. code-block:: c. void copy_into_buffer(size_t size) {; char* buffer = malloc(size);; strlcpy(buffer, ""some string"", strlen(""some string""));; // Previous line preprocesses to:; // __builtin___strlcpy_chk(buffer, ""some string"", strlen(""some string""), __builtin_object_size(buffer, 0)); }. Since the size of ``buffer`` can't be known at compile time, Clang will fold; ``__builtin_object_size(buffer, 0)`` into ``-1``. However, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:188245,depend,dependent,188245,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['depend'],['dependent']
Integrability,"re sub-projects. .. _workflow-monocheckout-multicommit:. Monorepo Variant; ^^^^^^^^^^^^^^^^. The repository contains natively the source for every sub-projects at the right; revision, which makes this straightforward::. git clone https://github.com/llvm/llvm-project.git; cd llvm-projects; git checkout $REVISION. As before, at this point clang, llvm, and libcxx are stored in directories; alongside each other. .. _workflow-cross-repo-commit:. Commit an API Change in LLVM and Update the Sub-projects; --------------------------------------------------------. Today this is possible, even though not common (at least not documented) for; subversion users and for git-svn users. For example, few Git users try to update; LLD or Clang in the same commit as they change an LLVM API. The multirepo variant does not address this: one would have to commit and push; separately in every individual repository. It would be possible to establish a; protocol whereby users add a special token to their commit messages that causes; the umbrella repo's updater bot to group all of them into a single revision. The monorepo variant handles this natively. Branching/Stashing/Updating for Local Development or Experiments; ----------------------------------------------------------------. Currently; ^^^^^^^^^. SVN does not allow this use case, but developers that are currently using; git-svn can do it. Let's look in practice what it means when dealing with; multiple sub-projects. To update the repository to tip of trunk::. git pull; cd tools/clang; git pull; cd ../../projects/libcxx; git pull. To create a new branch::. git checkout -b MyBranch; cd tools/clang; git checkout -b MyBranch; cd ../../projects/libcxx; git checkout -b MyBranch. To switch branches::. git checkout AnotherBranch; cd tools/clang; git checkout AnotherBranch; cd ../../projects/libcxx; git checkout AnotherBranch. .. _workflow-mono-branching:. Monorepo Variant; ^^^^^^^^^^^^^^^^. Regular Git commands are sufficient, because everything",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:17447,protocol,protocol,17447,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,2,"['message', 'protocol']","['messages', 'protocol']"
Integrability,"re; can be multiple inner remainder loops. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.unroll_and_jam.followup_all``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Attributes specified in the metadata is added to all; ``llvm.loop.unroll_and_jam.*`` loops. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.licm_versioning.disable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata indicates that the loop should not be versioned for the purpose; of enabling loop-invariant code motion (LICM). The metadata has a single operand; which is the string ``llvm.loop.licm_versioning.disable``. For example:. .. code-block:: llvm. !0 = !{!""llvm.loop.licm_versioning.disable""}. '``llvm.loop.distribute.enable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Loop distribution allows splitting a loop into multiple loops. Currently,; this is only performed if the entire loop cannot be vectorized due to unsafe; memory dependencies. The transformation will attempt to isolate the unsafe; dependencies into their own loop. This metadata can be used to selectively enable or disable distribution of the; loop. The first operand is the string ``llvm.loop.distribute.enable`` and the; second operand is a bit. If the bit operand value is 1 distribution is; enabled. A value of 0 disables distribution:. .. code-block:: llvm. !0 = !{!""llvm.loop.distribute.enable"", i1 0}; !1 = !{!""llvm.loop.distribute.enable"", i1 1}. This metadata should be used in conjunction with ``llvm.loop`` loop; identification metadata. '``llvm.loop.distribute.followup_coincident``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata defines which attributes extracted loops with no cyclic; dependencies will have (i.e. can be vectorized). See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.distribute.followup_sequential``' Metadata; ^^^^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:307738,depend,dependencies,307738,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['dependencies']
Integrability,"reach(py_source ${py_sources}); add_custom_command(; OUTPUT ${localruntimedir}/${py_source}; COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}/python/${py_source}; ${localruntimedir}/${py_source}; DEPENDS python/${py_source}; COMMENT ""Copying ${CMAKE_CURRENT_SOURCE_DIR}/python/${py_source}""); list(APPEND py_sources_in_localruntimedir ${localruntimedir}/${py_source}); endforeach(). # A custom target that depends on the Python sources being present in the build; # directory. This will be used as a dependency of the pythonization libraries,; # such that the Python sources get re-copied to the build directory when; # changed.; add_custom_target(ROOTPythonizationsPySources ALL DEPENDS ${py_sources_in_localruntimedir}). # Copy headers inside build_dir/include/ROOT; file(COPY ${ROOT_headers_dir}/ DESTINATION ${CMAKE_BINARY_DIR}/include/ROOT). set(libname ROOTPythonizations). add_library(${libname} SHARED ${cpp_sources}). # Insert the ROOTPythonizationsPySources in the dependency graph; add_dependencies(${libname} ROOTPythonizationsPySources). # Set the suffix to '.so' and the prefix to 'lib'; set_target_properties(${libname} PROPERTIES ${ROOT_LIBRARY_PROPERTIES_NO_VERSION}); if(MSVC); set_target_properties(${libname} PROPERTIES WINDOWS_EXPORT_ALL_SYMBOLS TRUE); set_target_properties(${libname} PROPERTIES SUFFIX "".pyd""); target_link_libraries(${libname} PUBLIC Core Tree cppyy); elseif(APPLE); target_link_libraries(${libname} PUBLIC -Wl,-bind_at_load -Wl,-w -Wl,-undefined -Wl,dynamic_lookup Core Tree cppyy); else(); target_link_libraries(${libname} PUBLIC -Wl,--unresolved-symbols=ignore-all Core Tree cppyy); endif(). target_include_directories(${libname}; SYSTEM PRIVATE ${Python3_INCLUDE_DIRS}). target_include_directories(${libname}; PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/inc>). # Disables warnings caused by Py_RETURN_TRUE/Py_RETURN_FALSE; if(NOT MSVC); target_compile_options(${libname} PRIVATE -Wno-strict-aliasing); endif(). # Compile .py files; for",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/CMakeLists.txt:5168,depend,dependency,5168,bindings/pyroot/pythonizations/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/CMakeLists.txt,1,['depend'],['dependency']
Integrability,"reachable code; 3 . Compute live ranges for CSE; 4 . [t] Jump threading (jumps to jumps with identical or inverse conditions); 5 . [t] CSE; 6 . *** Conversion to SSA ; 7 . [t] SSA Based DCE; 8 . *** Conversion to LLVM; 9 . UnSSA; 10. GCSE; 11. LICM; 12. Strength Reduction; 13. Loop unrolling; 14. [t] CSE; 15. [t] DCE; 16. Instruction combination, register movement, scheduling... etc. I've marked optimizations with a [t] to indicate things that I believe to; be relatively trivial to implement in LLVM itself. The time consuming; things to reimplement would be SSA based PRE, Strength reduction & loop; unrolling... these would be the major things we would miss out on if we; did LLVM creation from tree code [inlining and other high level; optimizations are done on the tree representation]. Given the lack of ""strong"" optimizations that would take a long time to; reimplement, I am leaning a bit more towards creating LLVM from the tree; code. Especially given that SGI has GPL'd their compiler, including many; SSA based optimizations that could be adapted (besides the fact that their; code looks MUCH nicer than GCC :). Even if we choose to do LLVM code emission from RTL, we will almost; certainly want to move LLVM emission from step 8 down until at least CSE; has been rerun... which causes me to wonder if the SSA generation code; will still work (due to global variable dependencies and stuff). I assume; that it can be made to work, but might be a little more involved than we; would like. I'm continuing to look at the Tree -> RTL code. It is pretty gross; because they do some of the translation a statement at a time, and some; of it a function at a time... I'm not quite clear why and how the; distinction is drawn, but it does not appear that there is a wonderful; place to attach extra info. Anyways, I'm proceeding with the RTL -> LLVM conversion phase for now. We; can talk about this more on Monday. Wouldn't it be nice if there were a obvious decision to be made? :). -Chris. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-06-01-GCCOptimizations.txt:1811,depend,dependencies,1811,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-06-01-GCCOptimizations.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-06-01-GCCOptimizations.txt,1,['depend'],['dependencies']
Integrability,"ready checks that ``my_fun()`` is only called; on 10.12, then add an `availability attribute; <https://clang.llvm.org/docs/AttributeReference.html#availability>`_ to it,; which will also suppress the warning and require that calls to my_fun() are; checked:. .. code-block:: objc. API_AVAILABLE(macos(10.12)) void my_fun(NSSomeClass* var) {; [var fancyNewMethod]; // Now ok.; }. ``@available()`` is only available in Objective-C code. To use the feature; in C and C++ code, use the ``__builtin_available()`` spelling instead. If existing code uses null checks or ``-respondsToSelector:``, it should; be changed to use ``@available()`` (or ``__builtin_available``) instead. ``-Wunguarded-availability`` is disabled by default, but; ``-Wunguarded-availability-new``, which only emits this warning for APIs; that have been introduced in macOS >= 10.13, iOS >= 11, watchOS >= 4 and; tvOS >= 11, is enabled by default. .. _langext-overloading:. Objective-C++ ABI: protocol-qualifier mangling of parameters; ------------------------------------------------------------. Starting with LLVM 3.4, Clang produces a new mangling for parameters whose; type is a qualified-``id`` (e.g., ``id<Foo>``). This mangling allows such; parameters to be differentiated from those with the regular unqualified ``id``; type. This was a non-backward compatible mangling change to the ABI. This change; allows proper overloading, and also prevents mangling conflicts with template; parameters of protocol-qualified type. Query the presence of this new mangling with; ``__has_feature(objc_protocol_qualifier_mangling)``. Initializer lists for complex numbers in C; ==========================================. clang supports an extension which allows the following in C:. .. code-block:: c++. #include <math.h>; #include <complex.h>; complex float x = { 1.0f, INFINITY }; // Init to (1, Inf). This construct is useful because there is no way to separately initialize the; real and imaginary parts of a complex variable in standar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:83571,protocol,protocol-qualifier,83571,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['protocol'],['protocol-qualifier']
Integrability,"reated. * For example, the following are equivalent. .. code-block:: shell. $ opt -passes='no-op-function,no-op-loop' /tmp/a.ll -S; $ opt -passes='no-op-function,loop(no-op-loop)' /tmp/a.ll -S. For a list of available passes and analyses, including the IR unit (module,; CGSCC, function, loop) they operate on, run. .. code-block:: shell. $ opt --print-passes. or take a look at ``PassRegistry.def``. To make sure an analysis named ``foo`` is available before a pass, add; ``require<foo>`` to the pass pipeline. This adds a pass that simply requests; that the analysis is run. This pass is also subject to proper nesting. For; example, to make sure some function analysis is already computed for all; functions before a module pass:. .. code-block:: shell. $ opt -passes='function(require<my-function-analysis>),my-module-pass' /tmp/a.ll -S. Status of the New and Legacy Pass Managers; ==========================================. LLVM currently contains two pass managers, the legacy PM and the new PM. The; optimization pipeline (aka the middle-end) uses the new PM, whereas the backend; target-dependent code generation uses the legacy PM. The legacy PM somewhat works with the optimization pipeline, but this is; deprecated and there are ongoing efforts to remove its usage. Some IR passes are considered part of the backend codegen pipeline even if; they are LLVM IR passes (whereas all MIR passes are codegen passes). This; includes anything added via ``TargetPassConfig`` hooks, e.g.; ``TargetPassConfig::addCodeGenPrepare()``. The ``TargetMachine::adjustPassManager()`` function that was used to extend a; legacy PM with passes on a per target basis has been removed. It was mainly; used from opt, but since support for using the default pipelines has been; removed in opt the function isn't needed any longer. In the new PM such; adjustments are done by using ``TargetMachine::registerPassBuilderCallbacks()``. Currently there are efforts to make the codegen pipeline work with the new; PM.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:20837,depend,dependent,20837,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,1,['depend'],['dependent']
Integrability,"red a ""stack map"". Unlike the stack maps; defined above, the `GCFunctionMetadata` stack map interface does not; provide a way to associate live register values of arbitrary type with; an instruction address, nor does it specify a format for the resulting; stack map. The stack maps described here could potentially provide; richer information to a garbage collecting runtime, but that usage; will not be discussed in this document. Intrinsics; ==========. The following two kinds of intrinsics can be used to implement stack; maps and patch points: ``llvm.experimental.stackmap`` and; ``llvm.experimental.patchpoint``. Both kinds of intrinsics generate a; stack map record, and they both allow some form of code patching. They; can be used independently (i.e. ``llvm.experimental.patchpoint``; implicitly generates a stack map without the need for an additional; call to ``llvm.experimental.stackmap``). The choice of which to use; depends on whether it is necessary to reserve space for code patching; and whether any of the intrinsic arguments should be lowered according; to calling conventions. ``llvm.experimental.stackmap`` does not; reserve any space, nor does it expect any call arguments. If the; runtime patches code at the stack map's address, it will destructively; overwrite the program text. This is unlike; ``llvm.experimental.patchpoint``, which reserves space for in-place; patching without overwriting surrounding code. The; ``llvm.experimental.patchpoint`` intrinsic also lowers a specified; number of arguments according to its calling convention. This allows; patched code to make in-place function calls without marshaling. Each instance of one of these intrinsics generates a stack map record; in the :ref:`stackmap-section`. The record includes an ID, allowing; the runtime to uniquely identify the stack map, and the offset within; the code from the beginning of the enclosing function. '``llvm.experimental.stackmap``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. S",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst:3450,depend,depends,3450,interpreter/llvm-project/llvm/docs/StackMaps.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst,1,['depend'],['depends']
Integrability,"red as an; ""owning"" reference being returned to the caller. The; CoreFoundation framework defines a macro CF_RETURNS_NOT_RETAINED; that is functionally equivalent to the one shown below.; Usage is identical to cf_returns_retained. When using the; attribute, be sure to declare it within the proper macro that checks for; its availability, as it is not available in earlier versions of the analyzer:. $ cat test.m; #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef CF_RETURNS_NOT_RETAINED; #if __has_feature(attribute_cf_returns_not_retained); #define CF_RETURNS_NOT_RETAINED __attribute__((cf_returns_not_retained)); #else; #define CF_RETURNS_NOT_RETAINED; #endif; #endif. Attribute 'ns_consumed'; (Clang-specific); The 'ns_consumed' attribute can be placed on a specific parameter in either; the declaration of a function or an Objective-C method. It indicates to the; static analyzer that a release message is implicitly sent to the; parameter upon completion of the call to the given function or method. The; Foundation framework defines a macro NS_RELEASES_ARGUMENT that; is functionally equivalent to the NS_CONSUMED macro shown below.; Example. $ cat test.m; #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef NS_CONSUMED; #if __has_feature(attribute_ns_consumed); #define NS_CONSUMED __attribute__((ns_consumed)); #else; #define NS_CONSUMED; #endif; #endif. void consume_ns(id NS_CONSUMED x);. void test() {; id x = [[NSObject alloc] init];; consume_ns(x); // No leak!; }. @interface Foo : NSObject; + (void) releaseArg:(id) NS_CONSUMED x;; + (void) releaseSecondArg:(id)x second:(id) NS_CONSUMED y;; @end. void test_method() {; id x = [[NSObject alloc] init];; [Foo releaseArg:x]; // No leak!; }. void test_method2() {; id a = [[NSObject alloc] init];; id b = [[NSObject alloc] init];; [Foo releaseSecondArg:a second:b]; // 'a' is leaked, but 'b' ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:9919,message,message,9919,interpreter/llvm-project/clang/www/analyzer/annotations.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html,2,['message'],['message']
Integrability,"ref:`Pass Registration <writing-an-llvm-pass-registration>` is; optional for normal passes, all analysis group implementations must be; registered, and must use the :ref:`INITIALIZE_AG_PASS; <writing-an-llvm-pass-RegisterAnalysisGroup>` template to join the; implementation pool. Also, a default implementation of the interface **must**; be registered with :ref:`RegisterAnalysisGroup; <writing-an-llvm-pass-RegisterAnalysisGroup>`. As a concrete example of an Analysis Group in action, consider the; `AliasAnalysis <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`_; analysis group. The default implementation of the alias analysis interface; (the `basic-aa <https://llvm.org/doxygen/structBasicAliasAnalysis.html>`_ pass); just does a few simple checks that don't require significant analysis to; compute (such as: two different globals can never alias each other, etc).; Passes that use the `AliasAnalysis; <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`_ interface (for; example the `gvn <https://llvm.org/doxygen/classllvm_1_1GVN.html>`_ pass), do not; care which implementation of alias analysis is actually provided, they just use; the designated interface. From the user's perspective, commands work just like normal. Issuing the; command ``opt -gvn ...`` will cause the ``basic-aa`` class to be instantiated; and added to the pass sequence. Issuing the command ``opt -somefancyaa -gvn; ...`` will cause the ``gvn`` pass to use the ``somefancyaa`` alias analysis; (which doesn't actually exist, it's just a hypothetical example) instead. .. _writing-an-llvm-pass-RegisterAnalysisGroup:. Using ``RegisterAnalysisGroup``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``RegisterAnalysisGroup`` template is used to register the analysis group; itself, while the ``INITIALIZE_AG_PASS`` is used to add pass implementations to; the analysis group. First, an analysis group should be registered, with a; human readable name provided for it. Unlike registration of passes, there is; no co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:37529,interface,interface,37529,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['interface'],['interface']
Integrability,"reference:. core.NullDereference (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for dereferences of null pointers. This checker specifically does; not report null pointer dereferences for x86 and x86-64 targets when the; address space is 256 (x86 GS Segment), 257 (x86 FS Segment), or 258 (x86 SS; segment). See `X86/X86-64 Language Extensions; <https://clang.llvm.org/docs/LanguageExtensions.html#memory-references-to-specified-segments>`__; for reference. The ``SuppressAddressSpaces`` option suppresses; warnings for null dereferences of all pointers with address spaces. You can; disable this behavior with the option; ``-analyzer-config core.NullDereference:SuppressAddressSpaces=false``.; *Defaults to true*. .. code-block:: objc. // C; void test(int *p) {; if (p); return;. int x = p[0]; // warn; }. // C; void test(int *p) {; if (!p); *p = 0; // warn; }. // C++; class C {; public:; int x;; };. void test() {; C *pc = 0;; int k = pc->x; // warn; }. // Objective-C; @interface MyClass {; @public; int x;; }; @end. void test() {; MyClass *obj = 0;; obj->x = 1; // warn; }. .. _core-StackAddressEscape:. core.StackAddressEscape (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check that addresses to stack memory do not escape the function. .. code-block:: c. char const *p;. void test() {; char const str[] = ""string"";; p = str; // warn; }. void* test() {; return __builtin_alloca(12); // warn; }. void test() {; static int *x;; int y;; x = &y; // warn; }. .. _core-UndefinedBinaryOperatorResult:. core.UndefinedBinaryOperatorResult (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for undefined results of binary operators. .. code-block:: c. void test() {; int x;; int y = x + 1; // warn: left operand is garbage; }. .. _core-VLASize:. core.VLASize (C); """"""""""""""""""""""""""""""""; Check for declarations of Variable Length Arrays of undefined or zero size. Check for declarations of VLA of undefined or zero size. .. code-block:: c. void test() {; int x;; int vla1[x]; // warn: garbage as size; }. voi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:4541,interface,interface,4541,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['interface'],['interface']
Integrability,"regressions in code; compiled by LLVM on all applicable targets. * You are expected to address any `GitHub Issues <https://github.com/llvm/llvm-project/issues>`_ that; result from your change. We prefer for this to be handled before submission but understand that it isn't; possible to test all of this for every submission. Our build bots and nightly; testing infrastructure normally finds these problems. A good rule of thumb is; to check the nightly testers for regressions the day after your change. Build; bots will directly email you if a group of commits that included yours caused a; failure. You are expected to check the build bot messages to see if they are; your fault and, if so, fix the breakage. Commits that violate these quality standards (e.g. are very broken) may be; reverted. This is necessary when the change blocks other developers from making; progress. The developer is welcome to re-commit the change after the problem has; been fixed. .. _commit messages:. Commit messages; ---------------. Although we don't enforce the format of commit messages, we prefer that; you follow these guidelines to help review, search in logs, email formatting; and so on. These guidelines are very similar to rules used by other open source; projects. Most importantly, the contents of the message should be carefully written to; convey the rationale of the change (without delving too much in detail). It; also should avoid being vague or overly specific. For example, ""bits were not; set right"" will leave the reviewer wondering about which bits, and why they; weren't right, while ""Correctly set overflow bits in TargetInfo"" conveys almost; all there is to the change. Below are some guidelines about the format of the message itself:. * Separate the commit message into title and body separated by a blank line. * If you're not the original author, ensure the 'Author' property of the commit is; set to the original author and the 'Committer' property is set to yourself.; You can use a c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:14815,message,messages,14815,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['message'],['messages']
Integrability,"rent node for 2 different states. The; numbering order of states is therefore not important, but it can be; used as in the following lines:. ``` {.cpp}; gGeoManager->InitTrack(pt,dir); // anything to initialize a state; Int_t istate = gGeoManager->GetCurrentNodeId(); // in fact state Id; {; //... code changing the current state; }; gGeoManager->CdNode(istate); // forces state's re-initialization; ```. - Current `global transformation`. This represents the transformation; from `MARS` to the local reference of the current node, being the; product of all local mother-daughter transformations in the branch.; The global transformation can be referenced or copied:. ``` {.cpp}; const TGeoHMatrix *global = gGeoManager->GetCurrentMatrix();; TGeoHMatrix *copy = new TGeoHMatrix(*global);; ```. - One often needs to perform `master-to-local` and `local-to-master`; point and vector conversions to get from `MARS` to the local node; coordinates. This can be done by using the global transformation or; directly the **`TGeoManager`** corresponding interfaces:. ``` {.cpp}; Double_t *glob_pt = gGeoManager->GetCurrentPoint();; Double_t *glob_dir = gGeoManager->GetCurrentDirection();; Double_t loc_pt[3], loc_dir[3];; // Go from MARS to local coordinates:; gGeoManager->MasterToLocal(glob_pt,loc_pt); // or:; global->MasterToLocal(glob_pt,loc_pt); // will be omitted from now; ```. ### Saving and Restoring the Current State. As we already described, saving and restoring modeller states can be; quite useful during tracking and is a feature extensively used by; external tracking engines. We will call this navigation history; management, which in most of the cases can be performed by handling the; state identifiers. For quite big geometries, state indexing is not; possible anymore and will be automatically disabled by the modeller.; Fortunately there is a backup solution working in any condition: the; modeller maintains a stack of states that is internally used by its own; navigation algorithms,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:111944,interface,interfaces,111944,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['interface'],['interfaces']
Integrability,"rentheses are to guide the parser and provide; grouping. Once the parser constructs the AST, parentheses are not; needed. The next simple production is for handling variable references and; function calls:. .. code-block:: c++. /// identifierexpr; /// ::= identifier; /// ::= identifier '(' expression* ')'; static std::unique_ptr<ExprAST> ParseIdentifierExpr() {; std::string IdName = IdentifierStr;. getNextToken(); // eat identifier. if (CurTok != '(') // Simple variable ref.; return std::make_unique<VariableExprAST>(IdName);. // Call.; getNextToken(); // eat (; std::vector<std::unique_ptr<ExprAST>> Args;; if (CurTok != ')') {; while (true) {; if (auto Arg = ParseExpression()); Args.push_back(std::move(Arg));; else; return nullptr;. if (CurTok == ')'); break;. if (CurTok != ','); return LogError(""Expected ')' or ',' in argument list"");; getNextToken();; }; }. // Eat the ')'.; getNextToken();. return std::make_unique<CallExprAST>(IdName, std::move(Args));; }. This routine follows the same style as the other routines. (It expects; to be called if the current token is a ``tok_identifier`` token). It; also has recursion and error handling. One interesting aspect of this is; that it uses *look-ahead* to determine if the current identifier is a; stand alone variable reference or if it is a function call expression.; It handles this by checking to see if the token after the identifier is; a '(' token, constructing either a ``VariableExprAST`` or; ``CallExprAST`` node as appropriate. Now that we have all of our simple expression-parsing logic in place, we; can define a helper function to wrap it together into one entry point.; We call this class of expressions ""primary"" expressions, for reasons; that will become more clear `later in the; tutorial <LangImpl06.html#user-defined-unary-operators>`_. In order to parse an arbitrary; primary expression, we need to determine what sort of expression it is:. .. code-block:: c++. /// primary; /// ::= identifierexpr; /// ::= numberexpr; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:10359,rout,routine,10359,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,2,['rout'],"['routine', 'routines']"
Integrability,"required when constructing the functor. #### Special case: Wrapping TF1 objects in Parametric Function interfaces. In many cases, the user works with the `TF1` class. The mathematical library in ROOT provides some solutions to wrap these into the interfaces needed by other methods.; If the desired interface to wrap is one-dimensional, the class to use is `ROOT::Math::WrappedTF1`.; The default constructor takes a `TF1` reference as an argument, that will be wrapped with the interfaces of a `ROOT::Math::IParametricGradFunctionOneDim`.; Example:; ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedTF1.h"". int main(); {. TF1 f(""Sin Function"", ""sin(x)+y"",0,3);. ROOT::Math::WrappedTF1 wf1(f);. cout << f(1) << endl;; cout << wf1(1) << endl;. return 0;; }; ```. For a TF1 defining a multidimensional function or in case we need to wrap in a multi-dimensional function interface, the class to use is `ROOT::Math::WrappedMultiTF1`.; Following the usual procedure, setting the `TF1` though the constructor, will wrap it into a `ROOT::Math::IParametricGradFunctionMultiDim`.; Example:. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedMultiTF1.h"". int main(); {. TF2 f(""Sin Function"", ""sin(x) + y"",0,3,0,2);. ROOT::Math::WrappedMultiTF1 wf1(f);. double x[] = {1,2};. cout << f(x) << endl;; cout << wf1(x) << endl;. return 0;; }; ```. ## Numerical Integration. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image.; `ROOT::Math::VirtualIntegrator` defines the most basic functionality while the specific behaviours for one or multiple dimensions are implemented in; `ROOT::Math::VirtualIntegratorOneDim` and `ROOT::Math::VirtualIntegratorMultiDim`.; These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set the integration tolerance.; These methods must be implemented in the concrete classes existing for the different integration algorithms.; The user cannot ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:47919,wrap,wrap,47919,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['wrap'],['wrap']
Integrability,"requires clean layering, decent design, and avoiding tying the libraries to a; specific use. Oh yeah, did I mention that we want the resultant libraries to; be as fast as possible? :). This front-end is built as a component of the LLVM toolkit that can be used; with the LLVM backend or independently of it. In this spirit, the API has been; carefully designed as the following components:; ; libsupport - Basic support library, reused from LLVM. libsystem - System abstraction library, reused from LLVM.; ; libbasic - Diagnostics, SourceLocations, SourceBuffer abstraction,; file system caching for input source files. This depends on; libsupport and libsystem. libast - Provides classes to represent the C AST, the C type system,; builtin functions, and various helpers for analyzing and; manipulating the AST (visitors, pretty printers, etc). This; library depends on libbasic. liblex - C/C++/ObjC lexing and preprocessing, identifier hash table,; pragma handling, tokens, and macros. This depends on libbasic. libparse - C (for now) parsing and local semantic analysis. This library; invokes coarse-grained 'Actions' provided by the client to do; stuff (e.g. libsema builds ASTs). This depends on liblex. libsema - Provides a set of parser actions to build a standardized AST; for programs. AST's are 'streamed' out a top-level declaration; at a time, allowing clients to use decl-at-a-time processing,; build up entire translation units, or even build 'whole; program' ASTs depending on how they use the APIs. This depends; on libast and libparse. librewrite - Fast, scalable rewriting of source code. This operates on; the raw syntactic text of source code, allowing a client; to insert and delete text in very large source files using; the same source location information embedded in ASTs. This; is intended to be a low-level API that is useful for; higher-level clients and libraries such as code refactoring. libanalysis - Source-level dataflow analysis useful for performing analyses; such",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2007-OriginalClangReadme.txt:1666,depend,depends,1666,interpreter/llvm-project/llvm/docs/HistoricalNotes/2007-OriginalClangReadme.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2007-OriginalClangReadme.txt,1,['depend'],['depends']
Integrability,"res that any multiple inheritance (also in pure Python) has an; unambiguous method resolution order (mro), including for classes and thus; also for meta-classes.; In Python2, it was possible to resolve any mro conflicts automatically, but; meta-classes in Python3, although syntactically richer, have functionally; become far more limited.; In particular, the mro is checked in the builtin class builder, instead of; in the meta-class of the meta-class (which in Python3 is the builtin ``type``; rather than the meta-class itself as in Python2, another limitation, and; which actually checks the mro a second time for no reason).; The upshot is that a helper is required (``cppyy.multi``) to resolve the mro; to support Python3.; The helper is written to also work in Python2.; Example:. .. code-block:: python. >>> class PyConcrete(cppyy.multi(cppyy.gbl.Abstract1, cppyy.gbl.Abstract2)):; ... def abstract_method1(self):; ... return ""first message""; ... def abstract_method2(self):; ... return ""second message""; ...; >>> pc = PyConcrete(); >>> cppyy.gbl.call_abstract_method1(pc); first message; >>> cppyy.gbl/call_abstract_method2(pc); second message; >>>. Contrary to multiple inheritance in Python, in C++ there are no two separate; instances representing the base classes.; Thus, a single ``__init__`` call needs to construct and initialize all bases,; rather than calling ``__init__`` on each base independently.; To support this syntax, the arguments to each base class should be grouped; together in a tuple.; If there are no arguments, provide an empty tuple (or omit them altogether,; if these arguments apply to the right-most base(s)). .. _sec-methods-label:. `Methods`; ---------. C++ methods are represented as Python ones: these are first-class objects and; can be bound to an instance.; If a method is virtual in C++, the proper concrete method is called, whether; or not the concrete class is bound.; Similarly, if all classes are bound, the normal Python rules apply:. .. code-block:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/classes.rst:6405,message,message,6405,bindings/pyroot/cppyy/cppyy/doc/source/classes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/classes.rst,1,['message'],['message']
Integrability,"respectively. The index expressions shall have integral or unscoped; enumeration type and shall not be uses of the comma operator unless; parenthesized. The first index expression shall evaluate to a; non-negative value less than ``R``, and the second index expression shall; evaluate to a non-negative value less than ``C``, or else the expression has; undefined behavior. If ``E1`` is a prvalue, the result is a prvalue with type; ``T`` and is the value of the element at the given row and column in the matrix.; Otherwise, the result is a glvalue with type ``cv T`` and with the same value; category as ``E1`` which refers to the element at the given row and column in; the matrix. Programs containing a single subscript expression into a matrix are ill-formed. **Note**: We considered providing an expression of the form; ``postfix-expression [expression]`` to access columns of a matrix. We think; that such an expression would be problematic once both column and row major; matrixes are supported: depending on the memory layout, either accessing columns; or rows can be done efficiently, but not both. Instead, we propose to provide; builtins to extract rows and columns from a matrix. This makes the operations; more explicit. Matrix Type Binary Operators; ----------------------------. Given two matrixes, the ``+`` and ``-`` operators perform element-wise addition; and subtraction, while the ``*`` operator performs matrix multiplication.; ``+``, ``-``, ``*``, and ``/`` can also be used with a matrix and a scalar; value, applying the operation to each element of the matrix. Earlier versions of this extension did not support division by a scalar.; You can test for the availability of this feature with; ``__has_extension(matrix_types_scalar_division)``. For the expression ``M1 BIN_OP M2`` where. * ``BIN_OP`` is one of ``+`` or ``-``, one of ``M1`` and ``M2`` is of matrix; type, and the other is of matrix type or real type; or; * ``BIN_OP`` is ``*``, one of ``M1`` and ``M2`` is of ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst:4743,depend,depending,4743,interpreter/llvm-project/clang/docs/MatrixTypes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst,1,['depend'],['depending']
Integrability,ression.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-Torch-Regression COMMAND testPyTorchRegression). # Test PyTorch: Multi-class classification; ROOT_EXECUTABLE(testPyTorchMulticlass testPyTorchMulticlass.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-Torch-Multiclass COMMAND testPyTorchMulticlass DEPENDS ${PyMVA-Torch-Multiclass-depends}). # Test RModelParser_PyTorch. ROOT_ADD_GTEST(TestRModelParserPyTorch TestRModelParserPyTorch.C; LIBRARIES; ROOTTMVASofie; TMVA; Python3::NumPy; Python3::Python; INCLUDE_DIRS; SYSTEM; ${CMAKE_CURRENT_BINARY_DIR}; ); target_link_libraries(TestRModelParserPyTorch ${BLAS_LINKER_FLAGS} ${BLAS_LIBRARIES}). endif(PY_TORCH_FOUND). if((PY_KERAS_FOUND AND PY_THEANO_FOUND) OR (PY_KERAS_FOUND AND PY_TENSORFLOW_FOUND)); configure_file(generateKerasModels.py generateKerasModels.py COPYONLY); configure_file(scale_by_2_op.hxx scale_by_2_op.hxx COPYONLY). if (PY_TORCH_FOUND); set(PyMVA-Keras-Classification-depends PyMVA-Torch-Classification); set(PyMVA-Keras-Regression-depends PyMVA-Torch-Regression); set(PyMVA-Keras-Multiclass-depends PyMVA-Torch-Multiclass); endif(). # Test PyKeras: Binary classification; ROOT_EXECUTABLE(testPyKerasClassification testPyKerasClassification.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-Keras-Classification COMMAND testPyKerasClassification DEPENDS ${PyMVA-Keras-Classification-depends}). # Test PyKeras: Regression; if (NOT ROOT_ARCHITECTURE MATCHES macosx); #veto also keras tutorial on macos due to issue in disabling eager execution on macos; ROOT_EXECUTABLE(testPyKerasRegression testPyKerasRegression.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-Keras-Regression COMMAND testPyKerasRegression DEPENDS ${PyMVA-Keras-Regression-depends}); endif(). # Test PyKeras: Multi-class classification; ROOT_EXECUTABLE(testPyKerasMulticlass testPyKerasMulticlass.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-Keras-Multiclass COMMAND testPyKerasMulticlass DEPENDS ${PyMVA-Keras-Multiclass-depends}). ROOT_ADD_GTEST(TestRMod,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/test/CMakeLists.txt:4079,depend,depends,4079,tmva/pymva/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/test/CMakeLists.txt,6,['depend'],['depends']
Integrability,"ression/decompression if available. Can be ON, OFF, or FORCE_ON""). set(LLVM_ENABLE_ZSTD ""ON"" CACHE STRING ""Use zstd for compression/decompression if available. Can be ON, OFF, or FORCE_ON""). set(LLVM_USE_STATIC_ZSTD FALSE CACHE BOOL ""Use static version of zstd. Can be TRUE, FALSE""). set(LLVM_ENABLE_CURL ""OFF"" CACHE STRING ""Use libcurl for the HTTP client if available. Can be ON, OFF, or FORCE_ON""). set(LLVM_ENABLE_HTTPLIB ""OFF"" CACHE STRING ""Use cpp-httplib HTTP server library if available. Can be ON, OFF, or FORCE_ON""). set(LLVM_Z3_INSTALL_DIR """" CACHE STRING ""Install directory of the Z3 solver.""). option(LLVM_ENABLE_Z3_SOLVER; ""Enable Support for the Z3 constraint solver in LLVM.""; ${LLVM_ENABLE_Z3_SOLVER_DEFAULT}; ). if (LLVM_ENABLE_Z3_SOLVER); find_package(Z3 4.7.1). if (LLVM_Z3_INSTALL_DIR); if (NOT Z3_FOUND); message(FATAL_ERROR ""Z3 >= 4.7.1 has not been found in LLVM_Z3_INSTALL_DIR: ${LLVM_Z3_INSTALL_DIR}.""); endif(); endif(). if (NOT Z3_FOUND); message(FATAL_ERROR ""LLVM_ENABLE_Z3_SOLVER cannot be enabled when Z3 is not available.""); endif(). set(LLVM_WITH_Z3 1); endif(). set(LLVM_ENABLE_Z3_SOLVER_DEFAULT ""${Z3_FOUND}""). if( LLVM_TARGETS_TO_BUILD STREQUAL ""all"" ); set( LLVM_TARGETS_TO_BUILD ${LLVM_ALL_TARGETS} ); endif(). if(LLVM_EXPERIMENTAL_TARGETS_TO_BUILD STREQUAL ""all""); set(LLVM_EXPERIMENTAL_TARGETS_TO_BUILD ${LLVM_ALL_EXPERIMENTAL_TARGETS}); endif(). set(LLVM_TARGETS_TO_BUILD; ${LLVM_TARGETS_TO_BUILD}; ${LLVM_EXPERIMENTAL_TARGETS_TO_BUILD}); list(REMOVE_DUPLICATES LLVM_TARGETS_TO_BUILD). if (NOT CMAKE_SYSTEM_NAME MATCHES ""OS390""); option(LLVM_ENABLE_PIC ""Build Position-Independent Code"" ON); endif(); option(LLVM_ENABLE_MODULES ""Compile with C++ modules enabled."" OFF); if(${CMAKE_SYSTEM_NAME} MATCHES ""Darwin""); option(LLVM_ENABLE_MODULE_DEBUGGING ""Compile with -gmodules."" ON); else(); option(LLVM_ENABLE_MODULE_DEBUGGING ""Compile with -gmodules."" OFF); endif(); option(LLVM_ENABLE_LOCAL_SUBMODULE_VISIBILITY ""Compile with -fmodules-local-submodule-visibili",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:23484,message,message,23484,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['message'],['message']
Integrability,"ret void }`. - It is possible to drop the whole IR section of the MIR file if it only; contains dummy functions (see above). The .mir loader will create the; IR functions automatically in this case. .. _limitations:. Limitations; -----------. Currently the MIR format has several limitations in terms of which state it; can serialize:. - The target-specific state in the target-specific ``MachineFunctionInfo``; subclasses isn't serialized at the moment. - The target-specific ``MachineConstantPoolValue`` subclasses (in the ARM and; SystemZ backends) aren't serialized at the moment. - The ``MCSymbol`` machine operands don't support temporary or local symbols. - A lot of the state in ``MachineModuleInfo`` isn't serialized - only the CFI; instructions and the variable debug information from MMI is serialized right; now. These limitations impose restrictions on what you can test with the MIR format.; For now, tests that would like to test some behaviour that depends on the state; of temporary or local ``MCSymbol`` operands or the exception handling state in; MMI, can't use the MIR format. As well as that, tests that test some behaviour; that depends on the state of the target specific ``MachineFunctionInfo`` or; ``MachineConstantPoolValue`` subclasses can't use the MIR format at the moment. High Level Structure; ====================. .. _embedded-module:. Embedded Module; ---------------. When the first YAML document contains a `YAML block literal string`_, the MIR; parser will treat this string as an LLVM assembly language string that; represents an embedded LLVM IR module.; Here is an example of a YAML document that contains an LLVM module:. .. code-block:: llvm. define i32 @inc(i32* %x) {; entry:; %0 = load i32, i32* %x; %1 = add i32 %0, 1; store i32 %1, i32* %x; ret i32 %1; }. .. _YAML block literal string: http://www.yaml.org/spec/1.2/spec.html#id2795688. Machine Functions; -----------------. The remaining YAML documents contain the machine functions. This is an example",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst:6022,depend,depends,6022,interpreter/llvm-project/llvm/docs/MIRLangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst,1,['depend'],['depends']
Integrability,"return FALSE. In the case of dynamic dispatch where our information is not perfect, CallEvent; can make a guess, but RuntimeDefinition::mayHaveOtherDefinitions will return; TRUE. The RuntimeDefinition object will then also include a MemRegion; corresponding to the object being called (i.e., the ""receiver"" in Objective-C; parlance), which ExprEngine uses to decide whether or not the call should be; inlined. Inlining Dynamic Calls; ^^^^^^^^^^^^^^^^^^^^^^. The -analyzer-config ipa option has five different modes: none, basic-inlining,; inlining, dynamic, and dynamic-bifurcate. Under -analyzer-config ipa=dynamic,; all dynamic calls are inlined, whether we are certain or not that this will; actually be the definition used at runtime. Under -analyzer-config ipa=inlining,; only ""near-perfect"" devirtualized calls are inlined*, and other dynamic calls; are evaluated conservatively (as if no definition were available). * Currently, no Objective-C messages are not inlined under; -analyzer-config ipa=inlining, even if we are reasonably confident of the type; of the receiver. We plan to enable this once we have tested our heuristics; more thoroughly. The last option, -analyzer-config ipa=dynamic-bifurcate, behaves similarly to; ""dynamic"", but performs a conservative invalidation in the general virtual case; in *addition* to inlining. The details of this are discussed below. As stated above, -analyzer-config ipa=basic-inlining does not inline any C++; member functions or Objective-C method calls, even if they are non-virtual or; can be safely devirtualized. Bifurcation; ^^^^^^^^^^^. ExprEngine::BifurcateCall implements the ``-analyzer-config ipa=dynamic-bifurcate``; mode. When a call is made on an object with imprecise dynamic type information; (RuntimeDefinition::mayHaveOtherDefinitions() evaluates to TRUE), ExprEngine; bifurcates the path and marks the object's region (retrieved from the; RuntimeDefinition object) with a path-sensitive ""mode"" in the ProgramState. Currently, ther",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:12288,message,messages,12288,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,1,['message'],['messages']
Integrability,"rf-operation-expressions`). The DWARF; operations that can be used in E have the following restrictions:. * ``DW_OP_addrx``, ``DW_OP_call2``, ``DW_OP_call4``, ``DW_OP_call_ref``,; ``DW_OP_const_type``, ``DW_OP_constx``, ``DW_OP_convert``,; ``DW_OP_deref_type``, ``DW_OP_fbreg``, ``DW_OP_implicit_pointer``,; ``DW_OP_regval_type``, ``DW_OP_reinterpret``, and ``DW_OP_xderef_type``; operations are not allowed because the call frame information must not depend; on other debug sections. * ``DW_OP_push_object_address`` is not allowed because there is no object; context to provide a value to push. * ``DW_OP_LLVM_push_lane`` and ``DW_OP_LLVM_push_iteration`` are not allowed; because the call frame instructions describe the actions for the whole target; architecture thread, not the lanes or iterations independently. * ``DW_OP_call_frame_cfa`` and ``DW_OP_entry_value`` are not allowed because; their use would be circular. * ``DW_OP_LLVM_call_frame_entry_reg`` is not allowed if evaluating E causes a; circular dependency between ``DW_OP_LLVM_call_frame_entry_reg`` operations. *For example, if a register R1 has a* ``DW_CFA_def_cfa_expression``; *instruction that evaluates a* ``DW_OP_LLVM_call_frame_entry_reg`` *operation; that specifies register R2, and register R2 has a*; ``DW_CFA_def_cfa_expression`` *instruction that that evaluates a*; ``DW_OP_LLVM_call_frame_entry_reg`` *operation that specifies register R1.*. *Call frame instructions to which these restrictions apply include*; ``DW_CFA_def_cfa_expression``\ *,* ``DW_CFA_expression``\ *, and*; ``DW_CFA_val_expression``\ *.*. .. _amdgpu-dwarf-row-creation-instructions:. A.6.4.2.1 Row Creation Instructions; ###################################. .. note::. These instructions are the same as in DWARF Version 5 section 6.4.2.1. .. _amdgpu-dwarf-cfa-definition-instructions:. A.6.4.2.2 CFA Definition Instructions; #####################################. 1. ``DW_CFA_def_cfa``. The ``DW_CFA_def_cfa`` instruction takes two unsigned LEB128 ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:203898,depend,dependency,203898,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['depend'],['dependency']
Integrability,rflow; Not resolved. 1267; CD3; Rvalue reference types in exception-specifications; Unknown. 1268; CD3; reinterpret_cast of an xvalue operand; Unknown. 1269; CD3; dynamic_cast of an xvalue operand; Unknown. 1270; CD3; Brace elision in array temporary initialization; Unknown. 1271; CD5; Imprecise wording regarding dependent types; Unknown. 1272; NAD; Implicit definition of static data member of const literal type; Unknown. 1273; NAD; Accessibility and function signatures; Unknown. 1274; CD4; Common nonterminal for expression and braced-init-list; Unknown. 1275; CD3; Incorrect comment in example of template parameter pack restriction; Unknown. 1276; NAD; Reference to stdint.h; Unknown. 1277; NAD; Lax definition of intmax_t and uintmax_t; Unknown. 1278; drafting; Incorrect treatment of contrived object; Not resolved. 1279; drafting; Additional differences between C++ 2003 and C++ 2011; Not resolved. 1280; NAD; Object reallocation and reference members; Unknown. 1281; NAD; Virtual and dependent base classes; Unknown. 1282; CD3; Underspecified destructor exception-specification; Unknown. 1283; drafting; Static data members of classes with typedef name for linkage purposes; Not resolved. 1284; CD4; Should the lifetime of an array be independent of that of its elements?; Unknown. 1285; NAD; Trivial destructors and object lifetime; Unknown. 1286; drafting; Equivalence of alias templates; Not resolved. 1287; C++14; Direct initialization vs “implicit” conversion in reference binding; Unknown. 1288; CD3; Reference list initialization; Unknown. 1289; NAD; Can an alias template name the current instantiation?; Unknown. 1290; CD3; Lifetime of the underlying array of an initializer_list member; Unknown. 1291; CD6; Looking up a conversion-type-id; N/A. 1292; CD4; Dependent calls with braced-init-lists containing a pack expansion; Unknown. 1293; CD3; String literals in constant expressions; Unknown. 1294; open; Side effects in dynamic/static initialization; Not resolved. 1295; CD3; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:85526,depend,dependent,85526,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['depend'],['dependent']
Integrability,"rform an operation with weak; assignment semantics with a pointer to an Objective-C object whose class does; not support ``__weak`` references. .. admonition:: Rationale. Historically, it has been possible for a class to provide its own; reference-count implementation by overriding ``retain``, ``release``, etc.; However, weak references to an object require coordination with its class's; reference-count implementation because, among other things, weak loads and; stores must be atomic with respect to the final release. Therefore, existing; custom reference-count implementations will generally not support weak; references without additional effort. This is unavoidable without breaking; binary compatibility. A class may indicate that it does not support weak references by providing the; ``objc_arc_weak_reference_unavailable`` attribute on the class's interface declaration. A; retainable object pointer type is **weak-unavailable** if; is a pointer to an (optionally protocol-qualified) Objective-C class ``T`` where; ``T`` or one of its superclasses has the ``objc_arc_weak_reference_unavailable``; attribute. A program is ill-formed if it applies the ``__weak`` ownership; qualifier to a weak-unavailable type or if the value operand of a weak; assignment operation has a weak-unavailable type. .. _arc.ownership.restrictions.autoreleasing:. Storage duration of ``__autoreleasing`` objects; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A program is ill-formed if it declares an ``__autoreleasing`` object of; non-automatic storage duration. A program is ill-formed if it captures an; ``__autoreleasing`` object in a block or, unless by reference, in a C++11; lambda. .. admonition:: Rationale. Autorelease pools are tied to the current thread and scope by their nature.; While it is possible to have temporary objects whose instance variables are; filled with autoreleased objects, there is no way that ARC can provide any; sort of safety guarantee there. It is undefined behavior if a ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:42131,protocol,protocol-qualified,42131,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['protocol'],['protocol-qualified']
Integrability,"rful test statistic. ; NumEventsTestStatReturns the number of events in the; dataset. �Useful for number counting experiments.; DebuggingTestStat Simply returns a uniform random number; between 0,1. �Useful for debugging. SamplingDistribution and the�TestStatSampler interface and; implementations; We introduced a ``result'' or data model class called; SamplingDistribution, which holds the sampling distribution of an; arbitrary real valued test statistic. �The class also can return the; inverse of the cumulative distribution function (with or without; interpolation). �; We introduced an interface for any tool that can produce a; SamplingDistribution, called TestStatSampler. �The interface is; essentially GetSamplingDistribution(parameterPoint) which returns a; SamplingDistribution based on a given probability density function. �We; foresee a few versions of this tool based on toy Monte Carlo, importance; sampling, Fourier transforms, etc. �The following concrete implementation; of the TestStatSampler interface are currently available. ToyMCSamplerUses a Toy Monte Carlo approach to build the; sampling distribution. �The pdf's generate method to generate is used to; generate toy data, and then the test statistic is evaluated at the; requested parameter point. ; DebuggingSampler Simply returns a uniform distribution; between 0,1. �Useful for debugging. NeymanConstruction and FeldmanCousins; A flexible framework for the Neyman Construction was added in this; release. The NeymanConstruction is a concrete implementation of the; IntervalCalculator interface, but it needs several; additional components�to be specified before use. The design; factorizes the choice of the parameter points to be tested,�the choice of; the test statistic, and the generation of sampling distribution into; separate parts (described above). �Finally, the NeymanConstruction class; is simply in charge of using these parts (strategies) and constructing; the confidence belt and confidence intervals. �T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:27315,interface,interface,27315,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,2,['interface'],['interface']
Integrability,"rger"" accepts two functions *F1* and *F2*, and produces *F1F2*; function, the result of merging. Having such routines in our hands, we can process a whole module, and merge all; equal functions. In this case, we have to compare every function with every another function. As; the reader may notice, this way seems to be quite expensive. Of course we could; introduce hashing and other helpers, but it is still just an optimization, and; thus the level of O(N*N) complexity. Can we reach another level? Could we introduce logarithmical search, or random; access lookup? The answer is: ""yes"". Random-access; """"""""""""""""""""""""""; How it could this be done? Just convert each function to a number, and gather; all of them in a special hash-table. Functions with equal hashes are equal.; Good hashing means, that every function part must be taken into account. That; means we have to convert every function part into some number, and then add it; into the hash. The lookup-up time would be small, but such an approach adds some; delay due to the hashing routine. Logarithmical search; """"""""""""""""""""""""""""""""""""""""; We could introduce total ordering among the functions set, once ordered we; could then implement a logarithmical search. Lookup time still depends on N,; but adds a little of delay (*log(N)*). Present state; """"""""""""""""""""""""""; Both of the approaches (random-access and logarithmical) have been implemented; and tested and both give a very good improvement. What was most; surprising is that logarithmical search was faster; sometimes by up to 15%. The; hashing method needs some extra CPU time, which is the main reason why it works; slower; in most cases, total ""hashing"" time is greater than total; ""logarithmical-search"" time. So, preference has been granted to the ""logarithmical search"". Though in the case of need, *logarithmical-search* (read ""total-ordering"") could; be used as a milestone on our way to the *random-access* implementation. Every comparison is based either on the numbers or on the fla",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:6087,rout,routine,6087,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,1,['rout'],['routine']
Integrability,"rget name is ""clang"" and we run:. .. code:: console. $ ninja clang. The first time we build will be very slow - Clang + LLVM is a lot of; code. But incremental builds are fast: ninja will only rebuild the parts; that have changed. When it finally finishes you should have a working; clang binary. Try running:. .. code:: console. $ bin/clang --version. There's also a target for building and running all the clang tests:. .. code:: console. $ ninja check-clang. This is a common pattern in LLVM: check-llvm is all the checks for core,; other projects have targets like check-lldb. Making changes; ==============. Edit; ----. We need to find the file containing the error message. .. code:: console. $ git grep ""all paths through this function"" ..; ../clang/include/clang/Basic/DiagnosticSemaKinds.td: ""all paths through this function will call itself"">,. The string that appears in DiagnosticSemaKinds.td is the one that is; printed by Clang. \*.td files define tables - in this case it's a list; of warnings and errors clang can emit and their messages. Let's update; the message in your favorite editor:. .. code:: console. $ vi ../clang/include/clang/Basic/DiagnosticSemaKinds.td. Find the message (it should be under; ``warn_infinite_recursive_function``). Change the message to ""in order to; understand recursion, you must first understand recursion"". Test again; ----------. To verify our change, we can build clang and manually check that it; works. .. code:: console. $ ninja clang; $ bin/clang -Wall ~/test.cc; /path/test.cc:1:124: warning: in order to understand recursion, you must; first understand recursion [-Winfinite-recursion]. We should also run the tests to make sure we didn't break something. .. code:: console. $ ninja check-clang. Notice that it is much faster to build this time, but the tests take; just as long to run. Ninja doesn't know which tests might be affected,; so it runs them all. .. code:: console. ********************; Testing Time: 408.84s; *******************",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst:5758,message,messages,5758,interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,1,['message'],['messages']
Integrability,"rgetSelectionDAG.td, namely:; GlobalAddress, GlobalTLSAddress, JumpTable, ConstantPool,; ExternalSymbol, BlockAddress; The MIPS backend uses several principles to handle these. 1. Code for lowering addresses references to machine dependent code is; factored into common code for generating different address forms and; is called by the relocation model specific lowering function, using; templated functions. For example:. // lib/Target/Mips/MipsISelLowering.cpp; SDValue MipsTargetLowering::; lowerJumpTable(SDValue Op, SelectionDAG &DAG) const. calls. template <class NodeTy> // lib/Target/Mips/MipsISelLowering.h; SDValue getAddrLocal(NodeTy *N, const SDLoc &DL, EVT Ty,; SelectionDAG &DAG, bool IsN32OrN64) const. which calls the overloaded function:. // lib/Target/Mips/MipsISelLowering.h; SDValue getTargetNode(JumpTableSDNode *N, EVT Ty, SelectionDAG &DAG,; unsigned Flag) const;. 2. Generic address nodes are lowered to some combination of target; independent and machine specific SDNodes (for example:; MipsISD::{Highest, Higher, Hi, Lo}) depending upon relocation model,; ABI, and compilation options. The choice of specific instructions that are to be used is delegated; to ISel which in turn relies on TableGen patterns to choose subtarget; specific instructions. For example, in getAddrLocal, the pseudo-code; generated is:. (add (load (wrapper $gp, %got(sym)), %lo(sym)). where ""%lo"" represents an instance of an SDNode with opcode; ""MipsISD::Lo"", ""wrapper"" indicates one with opcode ""MipsISD::Wrapper"",; and ""%got"" the global table pointer ""getGlobalReg(...)"". The ""add"" is; ""ISD::ADD"", not a target dependent one. 3. A TableGen multiclass pattern ""MipsHiLoRelocs"" is used to define a; template pattern parameterized over the load upper immediate; instruction, add operation, the zero register, and register class.; Here the instantiation of MipsHiLoRelocs in MipsInstrInfo.td is used; to MIPS32 to compute addresses for the static relocation model. // lib/Target/Mips/MipsInstrInfo.td;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Relocation.txt:1234,depend,depending,1234,interpreter/llvm-project/llvm/lib/Target/Mips/Relocation.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Relocation.txt,2,['depend'],['depending']
Integrability,"ribute__((objc_externally_retained)) WobbleAmount *alias = amount;; }; @end. Annotating a function with this attribute makes every parameter with strong; retainable object pointer type externally-retained, unless the variable was; explicitly qualified with ``__strong``. For instance, ``first_param`` is; externally-retained (and therefore ``const``) below, but not ``second_param``:. .. code-block:: objc. __attribute__((objc_externally_retained)); void f(NSArray *first_param, __strong NSArray *second_param) {; // ...; }. You can test if your compiler has support for ``objc_externally_retained`` with; ``__has_attribute``:. .. code-block:: objc. #if __has_attribute(objc_externally_retained); // Use externally retained...; #endif. .. _arc.misc.self:. ``self``; --------. The ``self`` parameter variable of an non-init Objective-C method is considered; :ref:`externally-retained <arc.misc.externally_retained>` by the implementation.; It is undefined behavior, or at least dangerous, to cause an object to be; deallocated during a message send to that object. In an init method, ``self``; follows the :ref:``init family rules <arc.family.semantics.init>``. .. admonition:: Rationale. The cost of retaining ``self`` in all methods was found to be prohibitive, as; it tends to be live across calls, preventing the optimizer from proving that; the retain and release are unnecessary --- for good reason, as it's quite; possible in theory to cause an object to be deallocated during its execution; without this retain and release. Since it's extremely uncommon to actually; do so, even unintentionally, and since there's no natural way for the; programmer to remove this retain/release pair otherwise (as there is for; other parameters by, say, making the variable ``objc_externally_retained`` or; qualifying it with ``__unsafe_unretained``), we chose to make this optimizing; assumption and shift some amount of risk to the user. .. _arc.misc.enumeration:. Fast enumeration iteration variables; ----",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:94449,message,message,94449,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['message'],['message']
Integrability,"ric CPU without any additional feature or; target option. .. code-block:: c++. auto CPU = ""generic"";; auto Features = """";. TargetOptions opt;; auto TargetMachine = Target->createTargetMachine(TargetTriple, CPU, Features, opt, Reloc::PIC_);. Configuring the Module; ======================. We're now ready to configure our module, to specify the target and; data layout. This isn't strictly necessary, but the `frontend; performance guide <../../Frontend/PerformanceTips.html>`_ recommends; this. Optimizations benefit from knowing about the target and data; layout. .. code-block:: c++. TheModule->setDataLayout(TargetMachine->createDataLayout());; TheModule->setTargetTriple(TargetTriple);. Emit Object Code; ================. We're ready to emit object code! Let's define where we want to write; our file to:. .. code-block:: c++. auto Filename = ""output.o"";; std::error_code EC;; raw_fd_ostream dest(Filename, EC, sys::fs::OF_None);. if (EC) {; errs() << ""Could not open file: "" << EC.message();; return 1;; }. Finally, we define a pass that emits object code, then we run that; pass:. .. code-block:: c++. legacy::PassManager pass;; auto FileType = CodeGenFileType::ObjectFile;. if (TargetMachine->addPassesToEmitFile(pass, dest, nullptr, FileType)) {; errs() << ""TargetMachine can't emit a file of this type"";; return 1;; }. pass.run(*TheModule);; dest.flush();. Putting It All Together; =======================. Does it work? Let's give it a try. We need to compile our code, but; note that the arguments to ``llvm-config`` are different to the previous chapters. ::. $ clang++ -g -O3 toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs all` -o toy. Let's run it, and define a simple ``average`` function. Press Ctrl-D; when you're done. ::. $ ./toy; ready> def average(x y) (x + y) * 0.5;; ^D; Wrote output.o. We have an object file! To test it, let's write a simple program and; link it with our output. Here's the source code:. .. code-block:: c++. #include <iostream>. extern ""C"" ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl08.rst:4140,message,message,4140,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl08.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl08.rst,1,['message'],['message']
Integrability,ric/include/clc/math/sqrt.h; libclc/generic/include/clc/math/tan.h; libclc/generic/include/clc/math/tanh.h; libclc/generic/include/clc/math/tanpi.h; libclc/generic/include/clc/math/tgamma.h; libclc/generic/include/clc/math/trunc.h; libclc/generic/include/clc/relational/bitselect.h; libclc/generic/include/clc/relational/isfinite.h; libclc/generic/include/clc/relational/isgreater.h; libclc/generic/include/clc/relational/isgreaterequal.h; libclc/generic/include/clc/relational/isless.h; libclc/generic/include/clc/relational/islessequal.h; libclc/generic/include/clc/relational/islessgreater.h; libclc/generic/include/clc/relational/isnormal.h; libclc/generic/include/clc/relational/isnotequal.h; libclc/generic/include/clc/relational/isordered.h; libclc/generic/include/clc/relational/isunordered.h; libclc/generic/include/clc/relational/signbit.h; libclc/generic/include/clc/shared/clamp.h; libclc/generic/include/clc/shared/max.h; libclc/generic/include/clc/shared/min.h; libclc/generic/include/clc/synchronization/barrier.h; libclc/generic/include/clc/synchronization/cl_mem_fence_flags.h; libclc/generic/include/clc/workitem/get_global_id.h; libclc/generic/include/clc/workitem/get_global_offset.h; libclc/generic/include/clc/workitem/get_global_size.h; libclc/generic/include/clc/workitem/get_group_id.h; libclc/generic/include/clc/workitem/get_local_id.h; libclc/generic/include/clc/workitem/get_local_size.h; libclc/generic/include/clc/workitem/get_num_groups.h; libclc/generic/include/clc/workitem/get_work_dim.h; libclc/generic/include/integer/popcount.h; libclc/generic/include/math/clc_exp10.h; libclc/generic/include/math/clc_fma.h; libclc/generic/include/math/clc_fmod.h; libclc/generic/include/math/clc_hypot.h; libclc/generic/include/math/clc_ldexp.h; libclc/generic/include/math/clc_nextafter.h; libclc/generic/include/math/clc_pow.h; libclc/generic/include/math/clc_pown.h; libclc/generic/include/math/clc_powr.h; libclc/generic/include/math/clc_remainder.h; libclc/generic/include,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:158210,synchroniz,synchronization,158210,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['synchroniz'],['synchronization']
Integrability,"rical types, (; see issue in ROOT forum). When reading more than one TStreamerInfo for the same versioned; class, we now use the highest possible class version as the current; version of the class. Practically, we update the class version; when reading new (higher versioned) StreamerInfo until the Class; is actually used (i.e. TClass::GetClassVersion is call directly; or indirectly). In particular, if a file has several StreamerInfos for the same; versioned class, we will use the highest version number as the; 'current' class version (as opposed to the lowest until now). For backward compatibility TStreamerInfo::BuildCheck compares the checksum of; the on-file StreamerInfo not only to the current value of the class checksum; but also to the checksum calculated using the older algorithms. This patch extends this test to also be done when comparing 2 on-file StreamerInfos. This removes spurrious warning message when loading 2 older files which; were written with 2 different version of the TClass CheckSum algorithm; (and the in-memory class's version is greater than both TStreamerInfos'; class version). Extend support of TStreamerInfo::ReadValueAux to 'converted' numerical types, hence solving TTree::Draw's schema evolution problem (see http://root.cern/phpBB2/viewtopic.php?t=6225). DirectoryAutoAdd; Use the new DirectoryAutoAdd facility for the classes:; TTree, TH1, TEventList, TEntryList, TGraph2D; (and hence their derived classes). The instances of those classes are now added automatically; to the current directory only when Constructe'd with arguments or Clone'd; and to the directory they are read from when their are stored; directly in a TKey. [Note: the default constructor never adds; the object to the current directory]. The directory auto add can still be disabled for instance; of TH1 and TGraph2D by setting TH1::AddDirectory. Additionally one can disable the directory auto add for; a specific class by doing:. TClass::GetClass(""myclass"")->SetDirectoryAutoAdd(0)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v520/index.html:2023,message,message,2023,io/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v520/index.html,2,['message'],['message']
Integrability,ries bound to references; Unknown. 2432; C++20; Return types for defaulted <=>; Unknown. 2433; C++20; Variable templates in the ODR; Unknown. 2434; open; Mandatory copy elision vs non-class objects; Not resolved. 2435; open; Alias template specializations; Not resolved. 2436; C++20; Copy semantics of coroutine parameters; Unknown. 2437; C++20; Conversion of std::strong_ordering in a defaulted operator<=>; Unknown. 2438; open; Problems in the specification of qualification conversions; Not resolved. 2439; C++20; Undefined term in definition of “usable in constant expressions”; Unknown. 2440; C++23; Allocation in core constant expressions; Unknown. 2441; C++20; Inline function parameters; Unknown. 2442; C++20; Incorrect requirement for default arguments; Unknown. 2443; C++23; Meaningless template exports; Unknown. 2444; drafting; Constant expressions in initialization odr-use; Not resolved. 2445; C++20; Partial ordering with rewritten candidates; Unknown. 2446; C++20; Questionable type-dependency of concept-ids; Unknown. 2447; C++20; Unintended description of abbreviated function templates; Unknown. 2448; CD6; Cv-qualification of arithmetic types and deprecation of volatile; Unknown. 2449; extension; Thunks as an implementation technique for pointers to virtual functions; Extension. 2450; review; braced-init-list as a template-argument; Clang 18. 2451; C++23; promise.unhandled_exception() and final suspend point; Unknown. 2452; CD6; Flowing off the end of a coroutine; Unknown. 2453; NAD; Deduced return types and coroutine lambdas; Unknown. 2454; NAD; Tail recursion and coroutine symmetric transfer; Unknown. 2455; CD6; Concatenation of string literals vs translation phases 5 and 6; Unknown. 2456; open; Viable user-defined conversions in converted constant expressions; Not resolved. 2457; CD6; Unexpanded parameter packs don't make a function type dependent; Unknown. 2458; CD6; Value category of expressions denoting non-static member functions; Unknown. 2459; drafting; Te,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:167433,depend,dependency,167433,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['depend'],['dependency']
Integrability,"ries during session startup, as they may significantly slowdown; the startup process is the medium is busy. In such a case, admins; are responsible to create the directories in advance; the session; releated part fo the path is created by the session once up.; In XrdProofd, move the check for the username after authentication.; This is because authentication may run some credentials-to-user mapping; which can modify the requested username. This way we really check the; final username and not the one requested by the client, which may even; not exist on the machines. Side modification: when the mapping function; returns more usernames, the username specified by the client is used to; help choosing the effective username among the available choices; if not; match is found the handshake does any longer fail, the first mapped; username is chosen instead.; In XrdProofd, allow 'xpd.allowedgroups' to control also PROOF; groups, not only UNIX ones.In XrdProofd, simplify error; messages in case of login failure because of non-authorization.; Remove hardcoded additions of dirname(COMPILER) and of; '/bin:/usr/bin:/usr/local/bin' in front of PATH. These uncontrolled; additions could hide specific settings in PATH and be the source of; weird problems appearing in PROOF only.; Add more flexibility to the definition of the library path seen by; proofserv. So far to avoid ambiguites in some cases, $ROOTSYS/lib was; removed and the one of the ROOT version chosen was added later on in; front, which proved to be to aggressive in some cases.; All changes (and fixes) needed to build against the version of Xrootd,; now always installed as external.; Fixes. Fix GetSessionLogs in PROOF-Lite; Restore correct parsing of ""workers=N"" in PROOF-Lite; In Proof-Bench, make sure that it can be run from any directory; and no matter how ROOT was installed; Fix issue in TProofPlayer::HandleHistogram preventing proper; histogram cleaning right after merging when using TH1::Add; histogram; were still des",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v532/index.html:2939,message,messages,2939,proof/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v532/index.html,2,['message'],['messages']
Integrability,"ringRef test(char *bytes) {; return CFStringCreateWithCStringNoCopy(; 0, bytes, NSNEXTSTEPStringEncoding, 0); // warn; }. osx.cocoa.SelfInit; (ObjC); Check that self is properly initialized inside an initializer; method. @interface MyObj : NSObject {; id x;; }; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; x = 0; // warn: instance variable used while 'self' is not; // initialized; return 0;; }; @end. @interface MyObj : NSObject; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; return self; // warn: returning uninitialized 'self'; }; @end. osx.cocoa.SuperDealloc; (ObjC); Warn about improper use of '[super dealloc]' in Objective-C. @interface SuperDeallocThenReleaseIvarClass : NSObject {; NSObject *_ivar;; }; @end. @implementation SuperDeallocThenReleaseIvarClass; - (void)dealloc {; [super dealloc];; [_ivar release]; // warn; }; @end. osx.cocoa.UnusedIvars; (ObjC); Warn about private ivars that are never used. @interface MyObj : NSObject {; @private; id x; // warn; }; @end. @implementation MyObj; @end. osx.cocoa.VariadicMethodTypes; (ObjC); Check for passing non-Objective-C types to variadic collection initialization; methods that expect only Objective-C types. void test() {; [NSSet setWithObjects:@""Foo"", ""Bar"", nil];; // warn: argument should be an ObjC pointer type, not 'char *'; }. osx.coreFoundation.CFError; (C); Check usage of CFErrorRef* parameters. void test(CFErrorRef *error) {; // warn: function accepting CFErrorRef* should have a; // non-void return; }. int foo(CFErrorRef *error) {; *error = 0; // warn: potential null dereference; return 0;; }. osx.coreFoundation.CFNumber; (C); Check for improper uses of CFNumberCreate. CFNumberRef test(unsigned char x) {; return CFNumberCreate(0, kCFNumberSInt16Type, &x);; // warn: 8 bit integer is used to initialize a 16 bit integer; }. osx.coreFoundation.CFRetainRelease; (C); Check for null arguments to CFRetain, CFRelease,; CFMakeCollectable. void test(CFTypeRef p) {; if (!p)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:19376,interface,interface,19376,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,2,['interface'],['interface']
Integrability,"ript::DrawPolyMarker: do not draw the markers is the marker size; is 0.; Right aligned or centered text was not correctly positioned when rotated. TASImage. The text size adjustment applied TASImage::DrawText; was not valid (scale factor of 1.044). The text size was wrong and the; following macro produced a wrong title when ran in batch:; ; {; TCanvas *canvas = new TCanvas(""c5"",""c5"",900,900);; TH1F *histo = new TH1F(""Histo"",""123456x_{i}abcdefy^{2}"",100,0,20);; canvas->Print(""drawing.gif"");; }; ; Suppress annoying messages like:; ; root : looking for image ""filename"" in path [/home/username/icons]; ; printed by libAfterImage when using TImage::Open(""filename""); In TImageDump the hollow filled areas were not correct:; ; they used the line attributes,; a line was drawn around the polygons filled with patterns. This fixes the problem mentionned here:; https://savannah.cern.ch/bugs/index.php?59263; as well as the test #22 in stressGraphics (no need to change; the reference file). Interface to graphviz. Thanks to three new classes (TGraphStruct, TGraphNode and; TGraphEdge) ROOT provides; an interface to the graphs visualization package graphviz. Graph; visualization is a way of representing structural information as diagrams of; abstract graphs and networks. Example:. The previous image is produced by the following ROOT macro:; ; // Draw a simple graph structure.; // The graph layout is made using graphviz. This macro creates some; // nodes and edges and change a few graphical attributes on some of them.; // Author: Olivier Couet; {; TGraphStruct *gs = new TGraphStruct();. // create some nodes and put them in the graph in one go ...; TGraphNode *n0 = gs->AddNode(""n0"",""Node 0"");; TGraphNode *n1 = gs->AddNode(""n1"",""First node"");; TGraphNode *n2 = gs->AddNode(""n2"",""Second node"");; TGraphNode *n3 = gs->AddNode(""n3"",""Third node"");; TGraphNode *n4 = gs->AddNode(""n4"",""Fourth node"");; TGraphNode *n5 = gs->AddNode(""n5"",""5th node"");; TGraphNode *n6 = gs->AddNode(""n6"",""Node number si",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v526/index.html:1431,Interface,Interface,1431,graf2d/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v526/index.html,1,['Interface'],['Interface']
Integrability,"ription directly using ``DW_OP_call_frame_cfa``,; ``DW_OP_breg*``, or ``DW_OP_LLVM_aspace_bregx``. This would also then; allow a target to implement the call frames within a large register. Otherwise, the DWARF is ill-formed if SL is not a memory location; description in any of the target architecture specific address spaces. The resulting L is the *frame base* for the subprogram or entry point. *Typically, E will use the* ``DW_OP_call_frame_cfa`` *operation or be a; stack pointer register plus or minus some offset.*. *The frame base for a subprogram is typically an address relative to the; first unit of storage allocated for the subprogram's stack frame. The*; ``DW_AT_frame_base`` *attribute can be used in several ways:*. 1. *In subprograms that need location lists to locate local variables, the*; ``DW_AT_frame_base`` *can hold the needed location list, while all; variables' location descriptions can be simpler ones involving the frame; base.*. 2. *It can be used in resolving ""up-level"" addressing within; nested routines. (See also* ``DW_AT_static_link``\ *, below)*. *Some languages support nested subroutines. In such languages, it is; possible to reference the local variables of an outer subroutine from within; an inner subroutine. The* ``DW_AT_static_link`` *and* ``DW_AT_frame_base``; *attributes allow debuggers to support this same kind of referencing.*. 3. If a ``DW_TAG_subprogram`` or ``DW_TAG_entry_point`` debugger information; entry is lexically nested, it may have a ``DW_AT_static_link`` attribute,; whose value is a DWARF expression E. The result of the attribute is obtained by evaluating E with a context that; has a result kind of a location description, an unspecified object, the; compilation unit that contains E, an empty initial stack, and other context; elements corresponding to the source language thread of execution upon which; the user is focused, if any. The result of the evaluation is the location; description L of the *canonical frame address* (s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:159145,rout,routines,159145,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['rout'],['routines']
Integrability,"ritten by vmulps is immediately used by the first; vhaddps, and register %xmm3 written by the first vhaddps is used by the second; vhaddps. Long data dependencies negatively impact the ILP (Instruction Level; Parallelism). In the dot-product example, there are anti-dependencies introduced by; instructions from different iterations. However, those dependencies can be; removed at register renaming stage (at the cost of allocating register aliases,; and therefore consuming physical registers). Table *Average Wait times* helps diagnose performance issues that are caused by; the presence of long latency instructions and potentially long data dependencies; which may limit the ILP. Last row, ``<total>``, shows a global average over all; instructions measured. Note that :program:`llvm-mca`, by default, assumes at; least 1cy between the dispatch event and the issue event. When the performance is limited by data dependencies and/or long latency; instructions, the number of cycles spent while in the *ready* state is expected; to be very small when compared with the total number of cycles spent in the; scheduler's queue. The difference between the two counters is a good indicator; of how large of an impact data dependencies had on the execution of the; instructions. When performance is mostly limited by the lack of hardware; resources, the delta between the two counters is small. However, the number of; cycles spent in the queue tends to be larger (i.e., more than 1-3cy),; especially when compared to other low latency instructions. Bottleneck Analysis; ^^^^^^^^^^^^^^^^^^^; The ``-bottleneck-analysis`` command line option enables the analysis of; performance bottlenecks. This analysis is potentially expensive. It attempts to correlate increases in; backend pressure (caused by pipeline resource pressure and data dependencies) to; dynamic dispatch stalls. Below is an example of ``-bottleneck-analysis`` output generated by; :program:`llvm-mca` for 500 iterations of the dot-product e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst:25860,depend,dependencies,25860,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,1,['depend'],['dependencies']
Integrability,"rivative estimates to compute a third, more accurate estimation). This is used by the TD1::Derivative method. ; BrentRootFinder for finding the root of one-dimensional function using the Brent algorithm. The class inherits from a virtual interface, which is also implemented by the MathMore root finder methods. The user can instantiate, via the common ROOT::Math::RootFinder class, all the various root finder algorithms. The BrentRootFinder class is used by TF1::GetX . ; A similar class, BrentMinimizer1D, provides the possibility to find the minimum of one-dimensional functions using the Brent algorithm. This class is used by TF1::GetMinimum or TF1::GetMaximum; Use ROOT convention for all enumeration names defining the type of numerical algorithms (start with k, like kADAPTIVE for the integration type). This affects both MathCore and MathMore.; . In addition we use now the ROOT convention for all enumeration names defining the type of numerical algorithms. The names start with k, like kADAPTIVE for the integration type. This change affects both MathCore and MathMore and it breaks backward compatibility. MathCore Function interfaces; Mathcore provides as well interfaces for the evaluation of mathematical and parametric functions to be used in the numerical methods. This release contains the following changes:. The ROOT::Math::IParamFunction, ROOT::Math::IParamMultiFunction interfaces (used mainly for fitting) require now a pointer to the parameters (type const double *), when evaluating the function. The derived classes must implement now the const; method DoEvalPar (and not DoEval as before). In addition the method; operator()(const double * x, const double * p) is now const. This change makes the caching of parameter not hidden and the interface is now; thread-safe. ; A similar change in the ROOT::Math::IParamGradFunction, ROOT::Math::IParamMultiGradFunction interfaces, where the parameter values are now required for calculating the partial derivatives with respect to",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:8599,integrat,integration,8599,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,2,['integrat'],['integration']
Integrability,"rived : protected Base {}; // matches 'Base'. Matcher<Decl>isPublic; Matches public C++ declarations and C++ base specifers that specify public; inheritance. Examples:; class C {; public: int a; // fieldDecl(isPublic()) matches 'a'; protected: int b;; private: int c;; };. class Base {};; class Derived1 : public Base {}; // matches 'Base'; struct Derived2 : Base {}; // matches 'Base'. Matcher<DesignatedInitExpr>designatorCountIsunsigned N; Matches designated initializer expressions that contain; a specific number of designators. Example: Given; point ptarray[10] = { [2].y = 1.0, [0].x = 1.0 };; point ptarray2[10] = { [2].y = 1.0, [2].x = 0.0, [0].x = 1.0 };; designatorCountIs(2); matches '{ [2].y = 1.0, [0].x = 1.0 }',; but not '{ [2].y = 1.0, [2].x = 0.0, [0].x = 1.0 }'. Matcher<EnumDecl>isScoped; Matches C++11 scoped enum declaration. Example matches Y (matcher = enumDecl(isScoped())); enum X {};; enum class Y {};. Matcher<Expr>isInstantiationDependent; Matches expressions that are instantiation-dependent even if it is; neither type- nor value-dependent. In the following example, the expression sizeof(sizeof(T() + T())); is instantiation-dependent (since it involves a template parameter T),; but is neither type- nor value-dependent, since the type of the inner; sizeof is known (std::size_t) and therefore the size of the outer; sizeof is known.; template<typename T>; void f(T x, T y) { sizeof(sizeof(T() + T()); }; expr(isInstantiationDependent()) matches sizeof(sizeof(T() + T()). Matcher<Expr>isTypeDependent; Matches expressions that are type-dependent because the template type; is not yet instantiated. For example, the expressions ""x"" and ""x + y"" are type-dependent in; the following code, but ""y"" is not type-dependent:; template<typename T>; void add(T x, int y) {; x + y;; }; expr(isTypeDependent()) matches x + y. Matcher<Expr>isValueDependent; Matches expression that are value-dependent because they contain a; non-type template parameter. For example, the array bo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:86124,depend,dependent,86124,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,4,['depend'],['dependent']
Integrability,"rived classes must implement now the const; method DoEvalPar (and not DoEval as before). In addition the method; operator()(const double * x, const double * p) is now const. This change makes the caching of parameter not hidden and the interface is now; thread-safe. ; A similar change in the ROOT::Math::IParamGradFunction, ROOT::Math::IParamMultiGradFunction interfaces, where the parameter values are now required for calculating the partial derivatives with respect to the parameters.; This changes the signature of the pure abstract method, DoParameterDerivative(const double *x, const double * p, , which takes also a pointer (type const double *) to the parameters.; In addition, these classes do not inherit anymore from the function gradient interface (ROOT::Math::IGradFunction and ROOT::Math::IMultiGradFunction). They define only the parameter gradient which is needed for fitting and not the coordinate gradient. A derived class, like ROOT::Math::Polynomial, implementing both functionality (coordinate and parameter gradient) inherits then from both interfaces.; . More detailed description of the current MathCore release can be found at this location. MathMore; This new release contains:. Modify and rename the class ROOT::Math::RootFinder to ROOT::Math::GSLRootFinder to distinguish from the main interface class which has been put in the Mathcore library and it can create the GSLRootFinder using the plug-in manager. Furthermore, the class ROOT::Math::GSLRootFinder is not anymore a template class on the algorithm. They type of root-finder algorithm can now be selected via an enumeration; Fixed a bug in the ROOT::Math::GSLNLSMultiFi class.; Changes also in the class for the new enumeration names (all names start with k, like kADAPTIVE for the integration types).; . More detailed description of the current MathMore release can be found at this location. GenVector; The new physics vector classes have been moved out from the MathCore library in a new library, libGenVector. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:10176,interface,interfaces,10176,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,2,['interface'],['interfaces']
Integrability,"rk on C++20, C++23, C++2c, and C23 support:; There are still several C++20 features to complete, and work has begun on; supporting the latest language standards. Please see the; C++ status report page to find out what is; missing.; StringRef'ize APIs: A thankless but incredibly useful project is; StringRef'izing (converting to use llvm::StringRef instead of const; char * or std::string) various clang interfaces. This generally; simplifies the code and makes it more efficient.; Configuration Manager: Clang/LLVM works on a large number of; architectures and operating systems and can cross-compile to a similarly large; number of configurations, but the pitfalls of choosing the command-line; options, making sure the right sub-architecture is chosen and that the correct; optional elements of your particular system can be a pain. A tool that would investigate hosts and targets, and store the configuration; in files that can later be used by Clang itself to avoid command-line options,; especially the ones regarding which target options to use, would greatly alleviate; this problem. A simple tool, with little or no dependency on LLVM itself, that; will investigate a target architecture by probing hardware, software, libraries; and compiling and executing code to identify all properties that would be relevant; to command-line options (VFP, SSE, NEON, ARM vs. Thumb etc), triple settings etc.; The first stage is to build a CFLAGS for Clang that would produce code on the; current Host to the identified Target.; The second stage would be to produce a configuration file (that can be used; independently of the Host) so that Clang can read it and not need a gazillion; of command-line options. Such file should be simple JSON / INI or anything that; a text editor could change. If you hit a bug with Clang, it is very useful for us if you reduce the code; that demonstrates the problem down to something small. There are many ways to; do this; ask on Discourse,; Discord,; or for advice. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:5981,depend,dependency,5981,interpreter/llvm-project/clang/www/OpenProjects.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html,2,['depend'],['dependency']
Integrability,"rk` (OFF by default). ## Histogram Libraries. ## Math Libraries. - Update the definitions of the physical constants using the recommended 2018 values from NIST.; - Use also the new SI definition of base units from 2019, where the Planck constant, the Boltzmann constant, the elementary electric charge and the Avogadro constant are exact numerical values. See <https://en.wikipedia.org/wiki/2019_redefinition_of_the_SI_base_units>. Note that with this new definition the functions `TMath::HUncertainty()`, `TMath::KUncertainty()`, `TMath::QeUncertainty()` and `TMath::NaUncertainty()` all return a `0.0` value.; - Due to some planned major improvements to `RVec`, the layout of `RVec` objects will change in a backward-incompatible way between v6.24 and v6.26.; Because of this, we now print a warning if an application is reading or writing a `ROOT::RVec` object from/to a ROOT file. We assume this is an; exceedingly rare case, as the ROOT interface typically used to manipulate `RVec`s is `RDataFrame`, and `RDataFrame` performs an on-the-fly; `RVec <-> std::vector` conversion rather than writing `RVec`s to disk. Note that, currently, `RVecs` written e.g. in a `TTree` cannot be read back; using certain ROOT interfaces (e.g. `TTreeReaderArray`, `RDataFrame` and the experimental `RNTuple`). All these limitations will be lifted in v6.26.; - Portable implementation of the RANLUX++ generator, see [RanluxppEngine](https://root.cern/doc/master/classROOT_1_1Math_1_1RanluxppEngine.html) and [our blog post](https://root.cern/blog/ranluxpp/). ## TMVA. - Introducing TMVA PyTorch Interface, a method to use PyTorch internally with TMVA for deep learning. This can be used as an alternative to PyKeras Interface for complex models providing more flexibility and power. ## RooFit Libraries. - Extension / updates of the doxygen reference guide.; - Allow for removing RooPlot from global directory management, see [RooPlot::AddDirectory](https://root.cern/doc/v624/classRooPlot.html#a47f7ba71dcaca30ad9e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:13014,interface,interface,13014,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,1,['interface'],['interface']
Integrability,"rloads. * ``PrintWarning`` prints a message tagged as a warning. * ``PrintError`` prints a message tagged as an error. * ``PrintFatalError`` prints a message tagged as an error and then terminates. * ``PrintNote`` prints a note. It is often used after one of the previous; functions to provide more information. * ``PrintFatalNote`` prints a note and then terminates. Each of these five functions is overloaded four times. * ``PrintError(const Twine &Msg)``:; Prints the message with no source file location. * ``PrintError(ArrayRef<SMLoc> ErrorLoc, const Twine &Msg)``:; Prints the message followed by the specified source line,; along with a pointer to the item in error. The array of; source file locations is typically taken from a ``Record`` instance. * ``PrintError(const Record *Rec, const Twine &Msg)``:; Prints the message followed by the source line associated with the; specified record (see `Record`_). * ``PrintError(const RecordVal *RecVal, const Twine &Msg)``:; Prints the message followed by the source line associated with the; specified record field (see `RecordVal`_). Using these functions, the goal is to produce the most specific error report; possible. Debugging Tools; ===============. TableGen provides some tools to aid in debugging backends. The ``PrintRecords`` Backend; ----------------------------. The TableGen command option ``--print-records`` invokes a simple backend; that prints all the classes and records defined in the source files. This is; the default backend option. The format of the output is guaranteed to be; constant over time, so that the output can be compared in tests. The output; looks like this:. .. code-block:: text. ------------- Classes -----------------; ...; class XEntry<string XEntry:str = ?, int XEntry:val1 = ?> { // XBase; string Str = XEntry:str;; bits<8> Val1 = { !cast<bits<8>>(XEntry:val1){7}, ... };; bit Val3 = 1;; }; ...; ------------- Defs -----------------; def ATable {	// GenericTable; string FilterClass = ""AEntry"";; string C",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst:24881,message,message,24881,interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,1,['message'],['message']
Integrability,"rm queries on bin b information; ; Double_t density = GetBinDensity(b);; Double_t volume = GetBinVolume(b);; Double_t* center = GetBinCenter(b);; . The tutorial math/kdTreeBinning.C is an example on; how to use this class. New statistical functions ROOT::Math::landau_quantile (inverse of landau cumulative distribution); translated from RANLAN and; ROOT::Math::landau_quantile_c.; ; New statistical functions; ROOT::Math::negative_binomial_pdf and the cumulative distributions; ROOT::Math::negative_binomial_cdf and ROOT::Math::negative_binomial_cdf_c.; ; New special functions: sine and cosine integral, translated by; B. List from CERNLIB:; ROOT::Math::sinint and ROOT::Math::cosint. New classes ROOT::Math::IOptions and; ROOT::Math::GenAlgoOptions for dealing in general with the; options for the numerical algorithm. The first one is the interface; for the second and defines the setting and retrieval of generic pair; of (name,value) options.; They are used for defining possible extra; options for the minimizer, integration and sampler options.; ; Integration classes:; ; Fix a bug in the templated method setting the integrand; function; Use now IntegrationOneDim::kADAPTIVESINGULAR as default method for the 1D; integration; Add the method IntegrationOneDim::kLEGENDRE based on; the GaussLegendreIntegrator class. ; Implement also for the GaussIntegrator and; GaussLegendreIntegrator the undefined and semi-undefined integral; using a function transformation as it is done in the GSLIntegrator; Fix a bug in IntegratorOneDim::SetAbsTolerance; New class ROOT::Math::IntegratorOptions which can be passed to; all integrator allowing the user to give options to the class and in; particular default value. Via the support for extra options (with; the class ROOT::Math::IOptions generic (string,value); options can be used in the base class to define specific options for; the implementations. For example for the MCIntegrator class,; specific options can now be passed to VEGAS or MISER.; . Im",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v528/index.html:5163,integrat,integration,5163,math/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v528/index.html,2,['integrat'],['integration']
Integrability,"rmalized in order to compute the triangles.; The scale factor used was the same for the X and Y axis.; This generated problems (very long triangles instead of the obvious ones); in some cases when the X and Y axis had very different ranges. Having two; scale factors, one for the X axis and one for the Y axis, cures the problem. TGraph2D. In case all the points are in the same Z-plane Z0 (zmin = zmax), the graph; minimum is set to Z0-0.01*Z0 and the maximum to Z0+0.01*Z0. This; allow to make TGraph2D like:; ; {; double *x = new double[2];; double *y = new double[2];; double *z = new double[2];; x[0] = 6215.;; x[1] = 5542.;; y[0] = 3853.;; y[1] = 5270.;; z[0] = 2723.;; z[1] = 2723.;; TGraph2D * g = new TGraph2D(2, x, y, z);; g->Draw(""LINE"");; }; . TGraph2DPainter. When a TGraph2D was painted with the option TRI1 the; color distribution in case of log scale along the Z axis was wrong. THistPainter. After executing the following macro, zooming the X axis interactively; generated the error message:; ; Error in <TGraphPainter::PaintGraphHist>: X must have N+1 values with option N . {; int n = 70;; TH1F h(""h"",""test"",n,0.,30.);; TRandom3 rndm_engine;; for (int i=0; i<10000; ++i) h->Fill(rndm_engine->Gaus(15.,4.));; TF1 f(""f"",""gaus"");; h->Fit(""f"");; gPad->SetLogx();; }; . The following macro didn't draw any box. Because of a precision; problem the filled bin was not drawn.; ; {; double yarr[] = { 1.0, 2.0, 3.0, 4.0 };; double xarr[] = { 0.01, 0.02, 0.03, 0.04 };; TH2D *h = new TH2D(""h"",""h"",3,xarr,3,yarr);; h->Fill(0.011,2.5);; h->Draw(""box"");; }; . The following macro displayed the histogram out of the frame; (option ""bar""):; ; {; gStyle->SetHistMinimumZero();; TH1F* h = new TH1F(""h"",""h"", 44, -0.5, 43.5);; h->SetBarWidth(0.7);; h->SetBarOffset(0.2);; h->SetFillColor(kGreen);; for (int i=0;i<44; i++ ) h->Fill(i, -i-60);; h->DrawCopy(""bar1"");; }; . The setting gStyle->SetHistMinimumZero() now works for horizontal; plots produced with the option HBAR.; . In the case of profile ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html:1933,message,message,1933,hist/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html,2,['message'],['message']
Integrability,"rmat. Changes in the; minor version number should not affect backward compatibility, while changes; in the major version number imply that a newer compiler cannot read an older; precompiled header (and vice-versa). Original file name; The full path of the header that was used to generate the AST file. Predefines buffer; Although not explicitly stored as part of the metadata, the predefines buffer; is used in the validation of the AST file. The predefines buffer itself; contains code generated by the compiler to initialize the preprocessor state; according to the current target, platform, and command-line options. For; example, the predefines buffer will contain ""``#define __STDC__ 1``"" when we; are compiling C without Microsoft extensions. The predefines buffer itself; is stored within the :ref:`pchinternals-sourcemgr`, but its contents are; verified along with the rest of the metadata. A chained PCH file (that is, one that references another PCH) and a module; (which may import other modules) have additional metadata containing the list; of all AST files that this AST file depends on. Each of those files will be; loaded along with this AST file. For chained precompiled headers, the language options, target architecture and; predefines buffer data is taken from the end of the chain, since they have to; match anyway. .. _pchinternals-sourcemgr:. Source Manager Block; ^^^^^^^^^^^^^^^^^^^^. The source manager block contains the serialized representation of Clang's; :ref:`SourceManager <SourceManager>` class, which handles the mapping from; source locations (as represented in Clang's abstract syntax tree) into actual; column/line positions within a source file or macro instantiation. The AST; file's representation of the source manager also includes information about all; of the headers that were (transitively) included when building the AST file. The bulk of the source manager block is dedicated to information about the; various files, buffers, and macro instantiations ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:9403,depend,depends,9403,interpreter/llvm-project/clang/docs/PCHInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst,1,['depend'],['depends']
Integrability,"rmational messages; -quiet - Don't print informational messages; -help - display available options (-help-hidden for more). This brief example has shown you how to use the '`cl::opt`_' class to parse; simple scalar command line arguments. In addition to simple scalar arguments,; the CommandLine library also provides primitives to support CommandLine option; `aliases`_, and `lists`_ of options. .. _aliases:. Argument Aliases; ----------------. So far, the example works well, except for the fact that we need to check the; quiet condition like this now:. .. code-block:: c++. ...; if (!Quiet && !Quiet2) printInformationalMessage(...);; ... ... which is a real pain! Instead of defining two values for the same; condition, we can use the ""`cl::alias`_"" class to make the ""``-q``"" option an; **alias** for the ""``-quiet``"" option, instead of providing a value itself:. .. code-block:: c++. cl::opt<bool> Force (""f"", cl::desc(""Overwrite output files""));; cl::opt<bool> Quiet (""quiet"", cl::desc(""Don't print informational messages""));; cl::alias QuietA(""q"", cl::desc(""Alias for -quiet""), cl::aliasopt(Quiet));. The third line (which is the only one we modified from above) defines a ""``-q``""; alias that updates the ""``Quiet``"" variable (as specified by the `cl::aliasopt`_; modifier) whenever it is specified. Because aliases do not hold state, the only; thing the program has to query is the ``Quiet`` variable now. Another nice; feature of aliases is that they automatically hide themselves from the ``-help``; output (although, again, they are still visible in the ``-help-hidden output``). Now the application code can simply use:. .. code-block:: c++. ...; if (!Quiet) printInformationalMessage(...);; ... ... which is much nicer! The ""`cl::alias`_"" can be used to specify an; alternative name for any variable type, and has many uses. .. _unnamed alternatives using the generic parser:. Selecting an alternative from a set of possibilities; ----------------------------------------------------.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:12371,message,messages,12371,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['message'],['messages']
Integrability,"rms; like OSF, this does not HAVE to be an executable) containing the; script. It uses the directive `fMakeExe` to do so. For both; directives, before passing them to `TSystem::Exec()`, it expands the; variables `$SourceFiles`, `$SharedLib`, `$LibName`, `$IncludePath`,; `$LinkedLibs`, `$ExeName `and` $ObjectFiles`. See `SetMakeSharedLib()`; for more information on those variables. When the file being passed to; ACLiC is on a read only file system, ACLiC warns the user and creates; the library in a temporary directory:. ``` {.cpp}; root[] .L readonly/t.C++; Warning in <ACLiC>: /scratch/aclic/subs/./readonly is not writable!; Warning in <ACLiC>: Output will be written to /tmp; Info in <TUnixSystem::ACLiC>: creating shared library; /tmp//scratch/aclic/subs/./readonly/t_C.so; ```. To select the temporary directory ACLiC looks at `$TEMP`, `$TEMP_DIR`,; `$TEMPDIR`, `$TMP`, `$TMPDIR`, `$TMP_DIR `or uses `/tmp (`or `C:/)`.; Also, a new interface `TSystem::Get/SetBuildDir` is introduced; to let users select an alternative 'root' for building of the ACLiC; libraries. For `filename/full/path/name/macro.C`, the library is; created as `fBuildDir/full/path/name/macro_C.so.`. ### Dictionary Generation. You can direct what is added to the dictionary generated by ACLiC in; two ways. The simplest way is to add at the end of script (i.e. after; the symbols have been defined) something like:. ``` {.cpp}; #if defined(__ROOTCLING__); #pragma link C++ class MyOtherClass;; #endif; ```. You can also write this portion of code in a file name; `MyScript_linkdef.h` where the suffix `'_linkdef' `is the prefix; defined by the key `‘ACLiC.Linkdef`‘ in the currently used resource; file (usually `.rootrc `or` $ROOTSYS/etc/system.rootrc`) and the; prefix is the name of your script. The default behavior of `rootcling` is to; not link in (i.e. generate the dictionary for) any of the symbols. In; particular, this means that the following lines are, in the; general case, unnecessary. ``` {.cpp}; #pragma ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:18447,interface,interface,18447,documentation/users-guide/Cling.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md,1,['interface'],['interface']
Integrability,"rn Operands[I];; }. Here are more examples:. .. code-block:: c++. assert(Ty->isPointerType() && ""Can't allocate a non-pointer type!"");. assert((Opcode == Shl || Opcode == Shr) && ""ShiftInst Opcode invalid!"");. assert(idx < getNumSuccessors() && ""Successor # out of range!"");. assert(V1.getType() == V2.getType() && ""Constant types must be identical!"");. assert(isa<PHINode>(Succ->front()) && ""Only works on PHId BBs!"");. You get the idea. In the past, asserts were used to indicate a piece of code that should not be; reached. These were typically of the form:. .. code-block:: c++. assert(0 && ""Invalid radix for integer literal"");. This has a few issues, the main one being that some compilers might not; understand the assertion, or warn about a missing return in builds where; assertions are compiled out. Today, we have something much better: ``llvm_unreachable``:. .. code-block:: c++. llvm_unreachable(""Invalid radix for integer literal"");. When assertions are enabled, this will print the message if it's ever reached; and then exit the program. When assertions are disabled (i.e. in release; builds), ``llvm_unreachable`` becomes a hint to compilers to skip generating; code for this branch. If the compiler does not support this, it will fall back; to the ""abort"" implementation. Use ``llvm_unreachable`` to mark a specific point in code that should never be; reached. This is especially desirable for addressing warnings about unreachable; branches, etc., but can be used whenever reaching a particular code path is; unconditionally a bug (not originating from user input; see below) of some kind.; Use of ``assert`` should always include a testable predicate (as opposed to; ``assert(false)``). If the error condition can be triggered by user input then the; recoverable error mechanism described in :doc:`ProgrammersManual` should be; used instead. In cases where this is not practical, ``report_fatal_error`` may; be used. Another issue is that values used only by assertions will produ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:46777,message,message,46777,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['message'],['message']
Integrability,"rnal ROOT memory management system, the second string type; parameter defines the function, here `sin(x)/x`, and the two parameters; of type double define the range of the variable *x*. The `Draw()`; method, here without any parameters, displays the function in a window; which should pop up after you typed the above two lines. A slightly extended version of this example is the definition of a; function with parameters, called `[0]`, `[1]` and so on in the ROOT; formula syntax. We now need a way to assign values to these parameters;; this is achieved with the method; `SetParameter(<parameter_number>,<parameter_value>)` of class `TF1`.; Here is an example:. ``` {.cpp}; root [13] TF1 f2(""f2"",""[0]*sin([1]*x)/x"",0.,10.);; root [14] f2.SetParameter(0,1);; root [15] f2.SetParameter(1,1);; root [16] f2.Draw();; ```. Of course, this version shows the same results as the initial one. Try; playing with the parameters and plot the function again. The class `TF1`; has a large number of very useful methods, including integration and; differentiation. To make full use of this and other ROOT classes, visit; the documentation on the Internet under; <https://root.cern/doc/master/>. Formulae in ROOT; are evaluated using the class `TFormula`, so also look up the relevant; class documentation for examples, implemented functions and syntax. You should definitely download this guide to your own system to have it; at you disposal whenever you need it. To extend a little bit on the above example, consider a more complex; function you would like to define. You can also do this using standard; `C` or `C++` code. Consider the example below, which calculates and displays the; interference pattern produced by light falling on a multiple slit.; Please do not type in the example below at the ROOT command line, there; is a much simpler way: Make sure you have the file `slits.C` on disk,; and type `root slits.C` in the shell. This will start root and make it; read the ""macro"" `slits.C`, i.e. all the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:4530,integrat,integration,4530,documentation/primer/ROOT_as_calculator.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md,1,['integrat'],['integration']
Integrability,"rned RooDataHist is controlled by the default; binning associated with the observables generated. To set the number; of bins in x to 200, do e.g. x.setBins(200) prior to the call; to generateBinned(). The binned dataset generation method does not (yet) support the concept of; prototype datasets. New minimizer interface to Minuit2, GSLMinimizer etc... A new minimizer interface, RooMinimizer has been added (contribution; from Alfio Lazarro). The new minimizer is similar in functionality to; the existing class RooMinuit, but supports the new ROOT abstract; minimizer interface and supports multiple minimizer packages and algorithms; through that interface. The present interface of RooMinimizer is identical to that of RooMinuit; with two extensions. The setMinimizer(const char*) method allows to choose between ""minuit"" and ""minuit2""); as implementation for migrad(),hesse(),minos() etc...; The minimizer(const char* package, const char* alg) provides a completely generic interface; to all minimizers, where package is the package (minuit,GSLminimizer) and alg is the algorithm (migrad) to be used. By default, RooMinuit is still used when RooAbsPdf::fitTo() is called, but can be overridden with; a Minimizer() named argument. // Minimization with MINUIT/MIGRAD through RooMinuit; pdf->fitTo(data) ;. // Minimization with MINUIT/MIGRAD through RooMinimizer; pdf->fitTo(data,Minimizer(""minuit"")) ;. // Minimization with MINUIT2/MIGRAD through RooMinimizer; pdf->fitTo(data,Minimizer(""minuit2"")) ;. // Minimization with GSLMultiMin/conjugatefr through RooMinimizer; pdf->fitTo(data,Minimizer(""GSLMultiMin"",""conjugatefr"")) ;. Note that installation of GSL and the ROOT MathMore package is needed to access the GSL Minimizers and that the GSL; Minimizer do not implement error analysis. New numeric integration algorithms available; RooFit can now interface all MathCore numeric integration; algorithms. In this release ROOT::Math::AdaptiveIntegratorMultiDim,; which implements the 'Genz & Malik'",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:3711,interface,interface,3711,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,2,['interface'],['interface']
Integrability,"rnsteinCorrection.C Demonstrates use of; BernsteinCorrection class, which corrects a nominal PDF with a polynomial; to agree with observed or simulated data. TestStatistic interface and implementations; We added a new interface class called TestStatistic. It defines the; method Evaluate(data, parameterPoint), which returns a double. �This; class can be used in�conjunction�with the ToyMCSampler class to generate; sampling distributions for a user-defined test statistic. �; The following concrete implementations of the TestStatistic interface; are currently available. ProfileLikelihoodTestStatReturns the log of profile; likelihood ratio. �Generally a powerful test statistic. ; NumEventsTestStatReturns the number of events in the; dataset. �Useful for number counting experiments.; DebuggingTestStat Simply returns a uniform random number; between 0,1. �Useful for debugging. SamplingDistribution and the�TestStatSampler interface and; implementations; We introduced a ``result'' or data model class called; SamplingDistribution, which holds the sampling distribution of an; arbitrary real valued test statistic. �The class also can return the; inverse of the cumulative distribution function (with or without; interpolation). �; We introduced an interface for any tool that can produce a; SamplingDistribution, called TestStatSampler. �The interface is; essentially GetSamplingDistribution(parameterPoint) which returns a; SamplingDistribution based on a given probability density function. �We; foresee a few versions of this tool based on toy Monte Carlo, importance; sampling, Fourier transforms, etc. �The following concrete implementation; of the TestStatSampler interface are currently available. ToyMCSamplerUses a Toy Monte Carlo approach to build the; sampling distribution. �The pdf's generate method to generate is used to; generate toy data, and then the test statistic is evaluated at the; requested parameter point. ; DebuggingSampler Simply returns a uniform distribution; betwe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:26567,interface,interface,26567,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,2,['interface'],['interface']
Integrability,"rocessor. There are also less commonly used components, as: 3D Graphics,; Parallel Processing (PROOF), Run Time Type Identification (RTTI),; Socket and Network Communication, Threads. #### Advantages of Frameworks. The benefits of frameworks can be summarized as follows:. - Less code to write - the programmer should be able to use and; reuse the majority of the existing code. Basic functionality, such; as fitting and histogramming are implemented and ready to use and; customize. - More reliable and robust code - the code inherited from a; framework has already been tested and integrated with the rest of; the framework. - More consistent and modular code - the code reuse provides; consistency and common capabilities between programs, no matter; who writes them. Frameworks make it easier to break programs into; smaller pieces. - More focus on areas of expertise - users can concentrate on their; particular problem domain. They do not have to be experts at; writing user interfaces, graphics, or networking to use the; frameworks that provide those services. ### Why Object-Oriented?. Object-Oriented Programming offers considerable benefits compared to; Procedure-Oriented Programming:. - Encapsulation enforces data abstraction and increases opportunity; for reuse. - Sub classing and inheritance make it possible to extend and modify; objects. - Class hierarchies and containment containment hierarchies provide; a flexible mechanism for modeling real-world objects and the; relationships among them. - Complexity is reduced because there is little growth of the global; state, the state is contained within each object, rather than; scattered through the program in the form of global variables. - Objects may come and go, but the basic structure of the program; remains relatively static, increases opportunity for reuse of; design. ## Installing ROOT; \index{install ROOT}. To install ROOT you have the choice to; download the binaries or the source. The source is quicker to transfer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:7885,interface,interfaces,7885,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['interface'],['interfaces']
Integrability,"rom; large classes of continuous or discrete distributions, and also from practically all standard distributions.; An extensive online documentation are available at the (UNU.RAN Web Site)[http://statistik.wu-wien.ac.at/unuran/]. New classes have been introduced to use the UNU.RAN C library from ROOT and C++ from ROOT and using C++ objects.; To use UNU.RAN one needs always an instance of the class **TUnuran**.; It can then be used in two distinct ways:; - using the UNU.RAN native string API for pre-defined distributions (see<a href=""http://statistik.wu-wien.ac.at/unuran/doc/unuran.html#StringAPI""> UNU.RAN documentation</a> for the string API):. ~~~{.cpp}; TUnuran unr;; //initialize unuran to generate normal random numbers using a ""arou"" method; unr.Init(""normal()"",""method=arou"");; //......; // sample distributions N times (generate N random numbers); for (int i = 0; i &lt; N; ++i); double x = unr.Sample();. ~~~. - Using a distribution object. We have then the following cases depending on the dimension and the distribution object. - For 1D distribution the class **TUnuranContDist** must be used.; - A **TUnuranContDist** object can be created from a function; providing the pdf (probability density function) and optionally one providing the derivative of the pdf.; - If the derivative is not provided and the generation method requires it, then it is estimated numerically.; - The user can optionally provide the; - cdf (cumulative distribution function) via the **TUnuranContDist::SetCdf** function,; - the mode via **TUnuranContDist::SetMode**,; - the domain via **TUnuranContDist::SetDomain** for generating numbers in a restricted region,; - the area below the pdf via **TUnuranContDist::SetPdfArea**. Some of this information is required depending on the chosen UNURAN generation method. ~~~~{.cpp}; //1D case: create a distribution from two TF1 object pointers pdfFunc; TUnuranContDist dist( pdfFunc);; //initialize unuran passing the distribution and a string defining the meth",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/unuran/doc/index.md:1390,depend,depending,1390,math/unuran/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/unuran/doc/index.md,1,['depend'],['depending']
Integrability,"ront`` Synchronizes with, and participates in modification; and seq_cst total orderings with, other operations; (except image operations) for all address spaces; (except private, or generic that accesses private); provided the other operation's sync scope is:. - ``system``, ``agent``, ``workgroup`` or; ``wavefront`` and executed by a thread in the; same wavefront. ``singlethread`` Only synchronizes with and participates in; modification and seq_cst total orderings with,; other operations (except image operations) running; in the same thread for all address spaces (for; example, in signal handlers). ``one-as`` Same as ``system`` but only synchronizes with other; operations within the same address space. ``agent-one-as`` Same as ``agent`` but only synchronizes with other; operations within the same address space. ``workgroup-one-as`` Same as ``workgroup`` but only synchronizes with; other operations within the same address space. ``wavefront-one-as`` Same as ``wavefront`` but only synchronizes with; other operations within the same address space. ``singlethread-one-as`` Same as ``singlethread`` but only synchronizes with; other operations within the same address space.; ======================= ===================================================. LLVM IR Intrinsics; ------------------. The AMDGPU backend implements the following LLVM IR intrinsics. *This section is WIP.*. .. table:: AMDGPU LLVM IR Intrinsics; :name: amdgpu-llvm-ir-intrinsics-table. ============================================== ==========================================================; LLVM Intrinsic Description; ============================================== ==========================================================; llvm.amdgcn.sqrt Provides direct access to v_sqrt_f64, v_sqrt_f32 and v_sqrt_f16; (on targets with half support). Performs sqrt function. llvm.amdgcn.log Provides direct access to v_log_f32 and v_log_f16; (on targets with half support). Performs log2 function. llvm.amdgcn.exp2 Provides di",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:35086,synchroniz,synchronizes,35086,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['synchroniz'],['synchronizes']
Integrability,"root ${CMAKE_OSX_SYSROOT}""); endif(). #---configure unuran (required for creating the config.h used by unuran source files)----------------; add_custom_command(OUTPUT ${UNR_UNTARDIR}/config.h; COMMAND GNUMAKE=make ./configure CC=${UNR_CC} CFLAGS=${UNR_CFLAGS} > /dev/null 2>& 1; WORKING_DIRECTORY ${UNR_UNTARDIR}); endif(). #---We need to disable some warnings-------------------------------------------------------------------; string(REPLACE -Wall """" CMAKE_C_FLAGS ""${CMAKE_C_FLAGS}""); if(${CMAKE_CXX_COMPILER_ID} MATCHES Clang); ROOT_ADD_C_FLAG(CMAKE_C_FLAGS -Wno-parentheses-equality); ROOT_ADD_C_FLAG(CMAKE_C_FLAGS -Wno-deprecated-non-prototype); endif(); if(${CMAKE_CXX_COMPILER_ID} MATCHES GNU); ROOT_ADD_C_FLAG(CMAKE_C_FLAGS -Wno-maybe-uninitialized); ROOT_ADD_C_FLAG(CMAKE_C_FLAGS -Wno-alloc-size-larger-than). endif(). set(unrsources ${UNR_UNTARDIR}/src/utils/*.c; ${UNR_UNTARDIR}/src/methods/*.c; ${UNR_UNTARDIR}/src/specfunct/*.c; ${UNR_UNTARDIR}/src/distr/*.c; ${UNR_UNTARDIR}/src/distributions/*.c; ${UNR_UNTARDIR}/src/parser/*.c; ${UNR_UNTARDIR}/src/tests/*.c; ${UNR_UNTARDIR}/src/uniform/*.c; ${UNR_UNTARDIR}/src/urng/*.c ); set(unrconfig ${UNR_UNTARDIR}/config.h). else(). set(unrsources); set(unrconfig). endif(builtin_unuran). ROOT_STANDARD_LIBRARY_PACKAGE(Unuran; HEADERS; TUnuran.h; TUnuranBaseDist.h; TUnuranContDist.h; TUnuranDiscrDist.h; TUnuranEmpDist.h; TUnuranMultiContDist.h; TUnuranSampler.h; SOURCES; src/TUnuran.cxx; src/TUnuranContDist.cxx; src/TUnuranDiscrDist.cxx; src/TUnuranEmpDist.cxx; src/TUnuranMultiContDist.cxx; src/TUnuranSampler.cxx; ${unrconfig}; ${unrsources}; LIBRARIES; ${UNURAN_LIBRARIES}; DEPENDENCIES; Core; Hist; MathCore; ). if(builtin_unuran); target_include_directories(Unuran SYSTEM BEFORE PRIVATE ${UNR_UNTARDIR} ${UNR_UNTARDIR}/src ${UNR_UNTARDIR}/src/utils); target_compile_definitions(Unuran PRIVATE HAVE_CONFIG_H); else(); target_include_directories(Unuran SYSTEM PRIVATE ${UNURAN_INCLUDE_DIRS}); endif(). ROOT_ADD_TEST_SUBDIRECTORY(test); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/unuran/CMakeLists.txt:3812,DEPEND,DEPENDENCIES,3812,math/unuran/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/unuran/CMakeLists.txt,1,['DEPEND'],['DEPENDENCIES']
